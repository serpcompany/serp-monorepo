[
  {
    "owner": "micropython",
    "repo": "micropython",
    "content": "TITLE: Setting Up WiFi Connection Using Network Module in MicroPython for ESP8266\nDESCRIPTION: Demonstrates how to use the network module to create a WLAN interface, scan for access points, and connect to a WiFi network on an ESP8266 board.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport network\n\nwlan = network.WLAN(network.WLAN.IF_STA) # create station interface\nwlan.active(True)       # activate the interface\nwlan.scan()             # scan for access points\nwlan.isconnected()      # check if the station is connected to an AP\nwlan.connect('ssid', 'key') # connect to an AP\nwlan.config('mac')      # get the interface's MAC address\nwlan.ipconfig('addr4')  # get the interface's IPv4 addresses\n\nap = network.WLAN(network.WLAN.IF_AP) # create access-point interface\nap.active(True)         # activate the interface\nap.config(ssid='ESP-AP') # set the SSID of the access point\n```\n\n----------------------------------------\n\nTITLE: Simple HTTP Server for GPIO Pin States in MicroPython\nDESCRIPTION: This code creates a simple HTTP server that serves a webpage displaying the state of GPIO pins. It uses the machine module to access GPIO pins and the socket module to create the server.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_tcp.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport machine\npins = [machine.Pin(i, machine.Pin.IN) for i in (0, 2, 4, 5, 12, 13, 14, 15)]\n\nhtml = \"\"\"<!DOCTYPE html>\n<html>\n    <head> <title>ESP8266 Pins</title> </head>\n    <body> <h1>ESP8266 Pins</h1>\n        <table border=\"1\"> <tr><th>Pin</th><th>Value</th></tr> %s </table>\n    </body>\n</html>\n\"\"\"\n\nimport socket\naddr = socket.getaddrinfo('0.0.0.0', 80)[0][-1]\n\ns = socket.socket()\ns.bind(addr)\ns.listen(1)\n\nprint('listening on', addr)\n\nwhile True:\n    cl, addr = s.accept()\n    print('client connected from', addr)\n    cl_file = cl.makefile('rwb', 0)\n    while True:\n        line = cl_file.readline()\n        if not line or line == b'\\r\\n':\n            break\n    rows = ['<tr><td>%s</td><td>%d</td></tr>' % (str(p), p.value()) for p in pins]\n    response = html % '\\n'.join(rows)\n    cl.send('HTTP/1.0 200 OK\\r\\nContent-type: text/html\\r\\n\\r\\n')\n    cl.send(response)\n    cl.close()\n```\n\n----------------------------------------\n\nTITLE: Basic Machine and ESP Module Operations in MicroPython\nDESCRIPTION: Core functions for controlling ESP32 hardware including CPU frequency management and flash operations\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport machine\n\nmachine.freq()          # get the current frequency of the CPU\nmachine.freq(240000000) # set the CPU frequency to 240 MHz\n```\n\nLANGUAGE: python\nCODE:\n```\nimport esp\n\nesp.osdebug(None)       # turn off vendor O/S debugging messages\nesp.osdebug(0)          # redirect vendor O/S debugging messages to UART(0)\n\n# low level methods to interact with flash storage\nesp.flash_size()\nesp.flash_user_start()\nesp.flash_erase(sector_no)\nesp.flash_write(byte_offset, buffer)\nesp.flash_read(byte_offset, buffer)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Pin Objects in MicroPython\nDESCRIPTION: This snippet demonstrates how to create Pin objects for input and output, set pin values, and configure interrupts. It showcases basic usage of the Pin class for GPIO control.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.Pin.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\n\n# create an output pin on pin #0\np0 = Pin(0, Pin.OUT)\n\n# set the value low then high\np0.value(0)\np0.value(1)\n\n# create an input pin on pin #2, with a pull up resistor\np2 = Pin(2, Pin.IN, Pin.PULL_UP)\n\n# read and print the pin value\nprint(p2.value())\n\n# reconfigure pin #0 in input mode with a pull down resistor\np0.init(p0.IN, p0.PULL_DOWN)\n\n# configure an irq callback\np0.irq(lambda p:print(p))\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using SPI in MicroPython\nDESCRIPTION: This snippet demonstrates how to create an SPI object, initialize a chip select pin, and perform various SPI operations such as writing, reading, and simultaneous read-write.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.SPI.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import SPI, Pin\n\nspi = SPI(0, baudrate=400000)           # Create SPI peripheral 0 at frequency of 400kHz.\n                                        # Depending on the use case, extra parameters may be required\n                                        # to select the bus characteristics and/or pins to use.\ncs = Pin(4, mode=Pin.OUT, value=1)      # Create chip-select on pin 4.\n\ntry:\n    cs(0)                               # Select peripheral.\n    spi.write(b\"12345678\")              # Write 8 bytes, and don't care about received data.\nfinally:\n    cs(1)                               # Deselect peripheral.\n\ntry:\n    cs(0)                               # Select peripheral.\n    rxdata = spi.read(8, 0x42)          # Read 8 bytes while writing 0x42 for each byte.\nfinally:\n    cs(1)                               # Deselect peripheral.\n\nrxdata = bytearray(8)\ntry:\n    cs(0)                               # Select peripheral.\n    spi.readinto(rxdata, 0x42)          # Read 8 bytes inplace while writing 0x42 for each byte.\nfinally:\n    cs(1)                               # Deselect peripheral.\n\ntxdata = b\"12345678\"\nrxdata = bytearray(len(txdata))\ntry:\n    cs(0)                               # Select peripheral.\n    spi.write_readinto(txdata, rxdata)  # Simultaneously write and read bytes.\nfinally:\n    cs(1)                               # Deselect peripheral.\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous LED Blinking with MicroPython asyncio\nDESCRIPTION: This example demonstrates how to use asyncio in MicroPython to create concurrent tasks for blinking LEDs. It shows the creation of coroutines, tasks, and the main event loop execution.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/asyncio.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nasync def blink(led, period_ms):\n    while True:\n        led.on()\n        await asyncio.sleep_ms(5)\n        led.off()\n        await asyncio.sleep_ms(period_ms)\n\nasync def main(led1, led2):\n    asyncio.create_task(blink(led1, 700))\n    asyncio.create_task(blink(led2, 400))\n    await asyncio.sleep_ms(10_000)\n\n# Running on a pyboard\nfrom pyb import LED\nasyncio.run(main(LED(1), LED(2)))\n\n# Running on a generic board\nfrom machine import Pin\nasyncio.run(main(Pin(1), Pin(2)))\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython for RP2 using Make\nDESCRIPTION: Commands to build the MicroPython firmware for RP2 using Make. It includes steps for building the cross-compiler, updating submodules, and compiling the firmware.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make -C mpy-cross\n$ make submodules\n$ make clean\n$ make\n```\n\n----------------------------------------\n\nTITLE: Basic LED Control in MicroPython REPL\nDESCRIPTION: Demonstrates how to create an LED object and control it using the on() and off() methods in the MicroPython REPL. This basic example shows how to interact with the Pyboard's built-in LEDs.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/leds.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> myled = pyb.LED(1)\n>>> myled.on()\n>>> myled.off()\n```\n\n----------------------------------------\n\nTITLE: Using pyboard.py as a Python Library\nDESCRIPTION: Demonstrates how to use the pyboard.py tool as a Python library to script interactions with a MicroPython board. The example shows connecting to a board, entering raw REPL mode, executing code, and exiting raw REPL mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/pyboard.py.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pyboard\npyb = pyboard.Pyboard('/dev/ttyACM0', 115200)\npyb.enter_raw_repl()\nret = pyb.exec('print(1+1)')\nprint(ret)\npyb.exit_raw_repl()\n```\n\n----------------------------------------\n\nTITLE: Basic I2C Communication Example in MicroPython\nDESCRIPTION: Demonstrates initialization of I2C peripheral, scanning for devices, and basic read/write operations. Shows common usage patterns including writing to specific memory addresses.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.I2C.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2C\n\ni2c = I2C(freq=400000)          # create I2C peripheral at frequency of 400kHz\n                                # depending on the port, extra parameters may be required\n                                # to select the peripheral and/or pins to use\n\ni2c.scan()                      # scan for peripherals, returning a list of 7-bit addresses\n\ni2c.writeto(42, b'123')         # write 3 bytes to peripheral with 7-bit address 42\ni2c.readfrom(42, 4)             # read 4 bytes from peripheral with 7-bit address 42\n\ni2c.readfrom_mem(42, 8, 3)      # read 3 bytes from memory of peripheral 42,\n                                #   starting at memory-address 8 in the peripheral\ni2c.writeto_mem(42, 2, b'\\x10') # write 1 byte to memory of peripheral 42\n                                #   starting at address 2 in the peripheral\n```\n\n----------------------------------------\n\nTITLE: Defining GPIO Interrupt Callback\nDESCRIPTION: Creates a callback function for handling GPIO interrupts. The function receives the triggering pin as an argument.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pins.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef callback(p):\n    print('pin change', p)\n```\n\n----------------------------------------\n\nTITLE: Configuring GPIO Interrupt Triggers\nDESCRIPTION: Sets up interrupt triggers for GPIO pins with different trigger conditions and associates them with the callback function.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pins.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\np0.irq(trigger=Pin.IRQ_FALLING, handler=callback)\np2.irq(trigger=Pin.IRQ_RISING | Pin.IRQ_FALLING, handler=callback)\n```\n\n----------------------------------------\n\nTITLE: Controlling GPIO Pins in MicroPython on ESP32\nDESCRIPTION: Demonstrates the use of the machine.Pin class for GPIO control on ESP32. Includes examples of setting up input and output pins, using pull-up resistors, and configuring drive strength.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\n\np0 = Pin(0, Pin.OUT)    # create output pin on GPIO0\np0.on()                 # set pin to \"on\" (high) level\np0.off()                # set pin to \"off\" (low) level\np0.value(1)             # set pin to on/high\n\np2 = Pin(2, Pin.IN)     # create input pin on GPIO2\nprint(p2.value())       # get value, 0 or 1\n\np4 = Pin(4, Pin.IN, Pin.PULL_UP) # enable internal pull-up resistor\np5 = Pin(5, Pin.OUT, value=1) # set pin high on creation\np6 = Pin(6, Pin.OUT, drive=Pin.DRIVE_3) # set maximum drive strength\n```\n\n----------------------------------------\n\nTITLE: Initializing Hardware I2C on RP2040 in MicroPython\nDESCRIPTION: Shows how to initialize hardware I2C on the RP2040 microcontroller using MicroPython. It demonstrates different ways to configure I2C, including specifying pins and frequency.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, I2C\n\ni2c = I2C(0)   # default assignment: scl=Pin(9), sda=Pin(8)\ni2c = I2C(1, scl=Pin(3), sda=Pin(2), freq=400_000)\n```\n\n----------------------------------------\n\nTITLE: Interfacing ISR with asyncio using ThreadSafeFlag in Python\nDESCRIPTION: This snippet demonstrates how to safely create a task in response to an interrupt using asyncio.ThreadSafeFlag. It shows the implementation of an interrupt handler and an asynchronous function that creates a task when the flag is set.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/isr_rules.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntsf = asyncio.ThreadSafeFlag()\n\ndef isr(_):  # Interrupt handler\n    tsf.set()\n\nasync def foo():\n    while True:\n        await tsf.wait()\n        asyncio.create_task(bar())\n```\n\n----------------------------------------\n\nTITLE: Using Watchdog Timer (WDT) in MicroPython on ESP32\nDESCRIPTION: Example showing how to use the Watchdog Timer (WDT) on ESP32 with MicroPython. The WDT can reset the system if it is not fed within the specified timeout.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import WDT\n\n# enable the WDT with a timeout of 5s (1s is the minimum)\nwdt = WDT(timeout=5000)\nwdt.feed()\n```\n\n----------------------------------------\n\nTITLE: UART Communication in MicroPython\nDESCRIPTION: Illustrates how to use the `machine.UART` class for UART (serial bus) communication in MicroPython. It shows how to create a UART object, specify the baud rate and pins, and write and read data.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import UART, Pin\nuart1 = UART(1, baudrate=9600, tx=Pin(4), rx=Pin(5))\nuart1.write('hello')  # write 5 bytes\nuart1.read(5)         # read up to 5 bytes\n```\n\n----------------------------------------\n\nTITLE: WiFi Connection Function for ESP32\nDESCRIPTION: Python function to establish a WiFi connection on an ESP32 using the network module, with configurable SSID and password\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/README.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef wlan_connect(ssid='MYSSID', password='MYPASS'):\n    import network\n    wlan = network.WLAN(network.WLAN.IF_STA)\n    if not wlan.active() or not wlan.isconnected():\n        wlan.active(True)\n        print('connecting to:', ssid)\n        wlan.connect(ssid, password)\n        while not wlan.isconnected():\n            pass\n    print('network config:', wlan.ifconfig())\n```\n\n----------------------------------------\n\nTITLE: Setting up WebREPL on ESP32 with MicroPython\nDESCRIPTION: This code snippet shows how to set up and start the WebREPL (REPL over WebSockets) on an ESP32 running MicroPython. It demonstrates the initial setup process and how to start the WebREPL daemon on demand, optionally with a specific password.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nimport webrepl_setup\n\n# After following on-screen instructions and rebooting, use:\nimport webrepl\nwebrepl.start()\n\n# or, start with a specific password\nwebrepl.start(password='mypass')\n```\n\n----------------------------------------\n\nTITLE: Implementing LED Flashing with Object Methods as Callbacks in MicroPython\nDESCRIPTION: Demonstrates how to use object methods as ISR callbacks to share instance variables. This example shows two LEDs flashing at different rates using timer interrupts and class instances.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/isr_rules.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pyb, micropython\nmicropython.alloc_emergency_exception_buf(100)\nclass Foo(object):\n    def __init__(self, timer, led):\n        self.led = led\n        timer.callback(self.cb)\n    def cb(self, tim):\n        self.led.toggle()\n\nred = Foo(pyb.Timer(4, freq=1), pyb.LED(1))\ngreen = Foo(pyb.Timer(2, freq=0.8), pyb.LED(2))\n```\n\n----------------------------------------\n\nTITLE: Pyboard Raw REPL Communication Tool\nDESCRIPTION: A utility script for executing Python code on MicroPython-enabled boards using raw REPL mode, including raw-paste mode for code transfer and execution\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/repl.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntools/pyboard.py\n```\n\n----------------------------------------\n\nTITLE: Configuring Wake-on-Touch for ESP32 Sleep Mode\nDESCRIPTION: This code snippet shows how to configure an ESP32 to wake from sleep mode when a touch pad is touched. It demonstrates setting up a TouchPad, configuring the touch threshold, and putting the MCU to sleep.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nimport machine\nfrom machine import TouchPad, Pin\nimport esp32\n\nt = TouchPad(Pin(14))\nt.config(500)               # configure the threshold at which the pin is considered touched\nesp32.wake_on_touch(True)\nmachine.lightsleep()        # put the MCU to sleep until a touchpad is touched\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Cross-Compiler\nDESCRIPTION: Command to build the MicroPython cross-compiler required for pre-compiling built-in scripts to bytecode. Must be executed from repository root directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ make -C mpy-cross\n```\n\n----------------------------------------\n\nTITLE: Implementing PWM Control in MicroPython on ESP32\nDESCRIPTION: Demonstrates how to use Pulse Width Modulation (PWM) on ESP32 using the machine.PWM class. Shows various methods to configure PWM frequency and duty cycle.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, PWM\n\npwm0 = PWM(Pin(0), freq=5000, duty_u16=32768) # create PWM object from a pin\nfreq = pwm0.freq()         # get current frequency\npwm0.freq(1000)            # set PWM frequency from 1Hz to 40MHz\n\nduty = pwm0.duty()         # get current duty cycle, range 0-1023 (default 512, 50%)\npwm0.duty(256)             # set duty cycle from 0 to 1023 as a ratio duty/1023, (now 25%)\n\nduty_u16 = pwm0.duty_u16() # get current duty cycle, range 0-65535\npwm0.duty_u16(2**16*3//4)  # set duty cycle from 0 to 65535 as a ratio duty_u16/65535, (now 75%)\n\nduty_ns = pwm0.duty_ns()   # get current pulse width in ns\npwm0.duty_ns(250_000)      # set pulse width in nanoseconds from 0 to 1_000_000_000/freq, (now 25%)\n\npwm0.deinit()              # turn off PWM on the pin\n\npwm2 = PWM(Pin(2), freq=20000, duty=512)  # create and configure in one go\nprint(pwm2)                               # view PWM settings\n```\n\n----------------------------------------\n\nTITLE: Basic PWM Usage Example in MicroPython\nDESCRIPTION: Demonstrates basic PWM initialization, duty cycle modification, frequency changes, and cleanup. Shows how to create a PWM object on a pin with specific frequency and duty cycle settings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.PWM.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import PWM\n\npwm = PWM(pin, freq=50, duty_u16=8192)  # create a PWM object on a pin\n                                        # and set freq and duty\npwm.duty_u16(32768)     # set duty to 50%\n\n# reinitialise with a period of 200us, duty of 5us\npwm.init(freq=5000, duty_ns=5000)\n\npwm.duty_ns(3000)       # set pulse width to 3us\n\npwm.deinit()\n```\n\n----------------------------------------\n\nTITLE: Setting PWM Frequency and Duty Cycle\nDESCRIPTION: Demonstrates how to configure PWM frequency and duty cycle. Frequency is set to 500Hz and duty cycle to 512 (50%).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pwm.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> pwm12.freq(500)\n>>> pwm12.duty(512)\n```\n\n----------------------------------------\n\nTITLE: Configuring Hardware Timers in MicroPython on ESP32\nDESCRIPTION: Shows how to use the machine.Timer class to set up hardware timers on ESP32. The ESP32 has four hardware timers, and this example demonstrates setting up both one-shot and periodic timers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Timer\n\ntim0 = Timer(0)\ntim0.init(period=5000, mode=Timer.ONE_SHOT, callback=lambda t:print(0))\n\ntim1 = Timer(1)\ntim1.init(period=2000, mode=Timer.PERIODIC, callback=lambda t:print(1))\n```\n\n----------------------------------------\n\nTITLE: Controlling NeoPixel LEDs with MicroPython on ESP32\nDESCRIPTION: This snippet demonstrates how to initialize and control NeoPixel LEDs using MicroPython on an ESP32 board. It shows setting up the GPIO pin, creating a NeoPixel driver, setting pixel colors, and reading color values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom neopixel import NeoPixel\n\npin = Pin(0, Pin.OUT)   # set GPIO0 to output to drive NeoPixels\nnp = NeoPixel(pin, 8)   # create NeoPixel driver on GPIO0 for 8 pixels\nnp[0] = (255, 255, 255) # set the first pixel to white\nnp.write()              # write data to all pixels\nr, g, b = np[0]         # get first pixel colour\n```\n\n----------------------------------------\n\nTITLE: GPIO Pin Control in MicroPython\nDESCRIPTION: Demonstrates how to use the `machine.Pin` class for controlling GPIO pins in MicroPython. It covers creating output and input pins, setting pin values to on/high or off/low, enabling internal pull-up resistors, and setting pin values on creation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\n\np0 = Pin(0, Pin.OUT)    # create output pin on GPIO0\np0.on()                 # set pin to \"on\" (high) level\np0.off()                # set pin to \"off\" (low) level\np0.value(1)             # set pin to on/high\n\np2 = Pin(2, Pin.IN)     # create input pin on GPIO2\nprint(p2.value())       # get value, 0 or 1\n\np4 = Pin(4, Pin.IN, Pin.PULL_UP) # enable internal pull-up resistor\np5 = Pin(5, Pin.OUT, value=1) # set pin high on creation\n```\n\n----------------------------------------\n\nTITLE: DHT Temperature/Humidity Sensor Driver\nDESCRIPTION: Implementation example for DHT11 and DHT22 temperature and humidity sensors.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nimport dht\nimport machine\n\nd = dht.DHT11(machine.Pin(4))\nd.measure()\nd.temperature() # eg. 23 (°C)\nd.humidity()    # eg. 41 (% RH)\n\nd = dht.DHT22(machine.Pin(4))\nd.measure()\nd.temperature() # eg. 23.6 (°C)\nd.humidity()    # eg. 41.3 (% RH)\n```\n\n----------------------------------------\n\nTITLE: Memory Access Example in MicroPython\nDESCRIPTION: Demonstrates how to use machine module's memory access objects (mem32) to control GPIO pins on an STM32 microcontroller by directly accessing hardware registers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport machine\nfrom micropython import const\n\nGPIOA = const(0x48000000)\nGPIO_BSRR = const(0x18)\nGPIO_IDR = const(0x10)\n\n# set PA2 high\nmachine.mem32[GPIOA + GPIO_BSRR] = 1 << 2\n\n# read PA3\nvalue = (machine.mem32[GPIOA + GPIO_IDR] >> 3) & 1\n```\n\n----------------------------------------\n\nTITLE: WLAN Network Configuration in MicroPython\nDESCRIPTION: Functions for configuring and managing WiFi connections on ESP32, including station and access point modes\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport network\n\nwlan = network.WLAN()       # create station interface\nwlan.active(True)           # activate the interface\nwlan.scan()                 # scan for access points\nwlan.isconnected()          # check if the station is connected to an AP\nwlan.connect('ssid', 'key') # connect to an AP\nwlan.config('mac')          # get the interface's MAC address\nwlan.ipconfig('addr4')      # get the interface's IPv4 addresses\n\nap = network.WLAN(network.WLAN.IF_AP) # create access-point interface\nap.config(ssid='ESP-AP')              # set the SSID of the access point\nap.config(max_clients=10)             # set how many clients can connect to the network\nap.active(True)                       # activate the interface\n```\n\n----------------------------------------\n\nTITLE: Registering BLE GATT Services in MicroPython\nDESCRIPTION: This example demonstrates how to register Heart Rate and Nordic UART services with the BLE GATT server. It shows the definition of service and characteristic UUIDs, setting appropriate flags for read/write/notify permissions, and obtaining value handles for later use.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nHR_UUID = bluetooth.UUID(0x180D)\nHR_CHAR = (bluetooth.UUID(0x2A37), bluetooth.FLAG_READ | bluetooth.FLAG_NOTIFY,)\nHR_SERVICE = (HR_UUID, (HR_CHAR,),)\nUART_UUID = bluetooth.UUID('6E400001-B5A3-F393-E0A9-E50E24DCCA9E')\nUART_TX = (bluetooth.UUID('6E400003-B5A3-F393-E0A9-E50E24DCCA9E'), bluetooth.FLAG_READ | bluetooth.FLAG_NOTIFY,)\nUART_RX = (bluetooth.UUID('6E400002-B5A3-F393-E0A9-E50E24DCCA9E'), bluetooth.FLAG_WRITE,)\nUART_SERVICE = (UART_UUID, (UART_TX, UART_RX,),)\nSERVICES = (HR_SERVICE, UART_SERVICE,)\n( (hr,), (tx, rx,), ) = bt.gatts_register_services(SERVICES)\n```\n\n----------------------------------------\n\nTITLE: Using UART Serial Communication on pyboard in MicroPython\nDESCRIPTION: Setting up and using the Universal Asynchronous Receiver-Transmitter (UART) for serial communication. The example initializes UART 1 with 9600 baud rate and demonstrates sending and receiving data.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import UART\n\nuart = UART(1, 9600)\nuart.write('hello')\nuart.read(5) # read up to 5 bytes\n```\n\n----------------------------------------\n\nTITLE: Flashing STM32 Firmware via ST-Link using st-flash\nDESCRIPTION: This snippet demonstrates how to use st-flash to erase the existing filesystem and flash either a .bin or .hex firmware file onto an STM32 microcontroller. The st-flash tool is used for Nucleo and Discovery boards with built-in ST-Link programmers.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Optional erase to clear existing filesystem.\nst-flash erase\n\n# Flash .bin\nst-flash write firmware.bin 0x08000000\n# or, flash .hex\nst-flash --format ihex write firmware.hex\n```\n\n----------------------------------------\n\nTITLE: PWM Control in MicroPython\nDESCRIPTION: Demonstrates how to use the `machine.PWM` class for PWM (pulse width modulation) control in MicroPython. It covers creating a PWM object, setting the frequency and duty cycle, getting the current frequency and duty cycle, stopping the output, showing the properties of the PWM object, and turning off PWM.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, PWM\n\n# create PWM object from a pin and set the frequency of slice 0\n# and duty cycle for channel A\npwm0 = PWM(Pin(0), freq=2000, duty_u16=32768)\npwm0.freq()             # get the current frequency of slice 0\npwm0.freq(1000)         # set/change the frequency of slice 0\npwm0.duty_u16()         # get the current duty cycle of channel A, range 0-65535\npwm0.duty_u16(200)      # set the duty cycle of channel A, range 0-65535\npwm0.duty_u16(0)        # stop the output at channel A\nprint(pwm0)             # show the properties of the PWM object.\npwm0.deinit()           # turn off PWM of slice 0, stopping channels A and B\n```\n\n----------------------------------------\n\nTITLE: Using Software SPI Bus in MicroPython on ESP32\nDESCRIPTION: Example demonstrating how to initialize and use a Software SPI bus with MicroPython on ESP32. This implementation uses bit-banging to work on any pins and provides methods for reading and writing data.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SoftSPI\n\n# construct a SoftSPI bus on the given pins\n# polarity is the idle state of SCK\n# phase=0 means sample on the first edge of SCK, phase=1 means the second\nspi = SoftSPI(baudrate=100000, polarity=1, phase=0, sck=Pin(0), mosi=Pin(2), miso=Pin(4))\n\nspi.init(baudrate=200000) # set the baudrate\n\nspi.read(10)            # read 10 bytes on MISO\nspi.read(10, 0xff)      # read 10 bytes while outputting 0xff on MOSI\n\nbuf = bytearray(50)     # create a buffer\nspi.readinto(buf)       # read into the given buffer (reads 50 bytes in this case)\nspi.readinto(buf, 0xff) # read into the given buffer and output 0xff on MOSI\n\nspi.write(b'12345')     # write 5 bytes on MOSI\n\nbuf = bytearray(4)      # create a buffer\nspi.write_readinto(b'1234', buf) # write to MOSI and read from MISO into the buffer\nspi.write_readinto(buf, buf) # write buf to MOSI and read MISO back into buf\n```\n\n----------------------------------------\n\nTITLE: Basic WiFi Station Connection in MicroPython\nDESCRIPTION: Demonstrates how to enable the WiFi station interface and connect to an access point. Shows the basic workflow of importing network module, creating WLAN object, activating interface and connecting to WiFi.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.WLAN.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport network\n# enable station interface and connect to WiFi access point\nnic = network.WLAN(network.WLAN.IF_STA)\nnic.active(True)\nnic.connect('your-ssid', 'your-key')\n# now use sockets as usual\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using WDT in MicroPython\nDESCRIPTION: Basic example of creating a WDT instance with a 2-second timeout and feeding it. The watchdog timer must be fed periodically to prevent system reset. This functionality is available on pyboard, WiPy, esp8266, esp32, rp2040, and mimxrt platforms.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.WDT.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import WDT\nwdt = WDT(timeout=2000)  # enable it with a timeout of 2s\nwdt.feed()\n```\n\n----------------------------------------\n\nTITLE: Basic Control Functions for SSD1306 OLED Display in MicroPython\nDESCRIPTION: Demonstrates the basic control functions for the SSD1306 display including power control, contrast adjustment, display inversion, rotation, and screen refresh.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/ssd1306.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndisplay.poweroff()     # power off the display, pixels persist in memory\ndisplay.poweron()      # power on the display, pixels redrawn\ndisplay.contrast(0)    # dim\ndisplay.contrast(255)  # bright\ndisplay.invert(1)      # display inverted\ndisplay.invert(0)      # display normal\ndisplay.rotate(True)   # rotate 180 degrees\ndisplay.rotate(False)  # rotate 0 degrees\ndisplay.show()         # write the contents of the FrameBuffer to display memory\n```\n\n----------------------------------------\n\nTITLE: I2S Asyncio Operations in MicroPython\nDESCRIPTION: Shows how to use I2S with asyncio for asynchronous audio operations. Demonstrates both streaming write and read operations using StreamWriter and StreamReader.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.I2S.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nswriter = asyncio.StreamWriter(audio_out)\nswriter.write(buf)\nawait swriter.drain()\n\nsreader = asyncio.StreamReader(audio_in)\nnum_read = await sreader.readinto(buf)\n```\n\n----------------------------------------\n\nTITLE: Setting MCU and Peripheral Frequencies in MicroPython\nDESCRIPTION: Demonstrates how to use `machine.freq()` to change the MCU frequency and control the peripheral frequency for UART and SPI on the RP2 board. It shows examples of setting the CPU frequency while keeping the UART frequency at 48MHz, and setting both CPU and UART frequency to 125 MHz.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport machine\n\nmachine.freq()          # get the current frequency of the CPU\nmachine.freq(240000000) # set the CPU frequency to 240 MHz and keep\n                        # the UART frequency at 48MHz\nmachine.freq(125000000, 125000000) # set the CPU and UART frequency to 125 MHz\n```\n\n----------------------------------------\n\nTITLE: Exception Handling Pattern for Robust MicroPython Applications\nDESCRIPTION: A robust error handling pattern for main.py that catches exceptions, prints error information, and automatically resets the device. This prevents the device from becoming unresponsive after crashes.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/reset_boot.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport machine, sys\nimport my_app\ntry:\n    my_app.main()\nexcept Exception as e:\n    print(\"Fatal error in main:\")\n    sys.print_exception(e)\n\n# Following a normal Exception or main() exiting, reset the board.\n# Following a non-Exception error such as KeyboardInterrupt (Ctrl-C),\n# this code will drop to a REPL. Place machine.reset() in a finally\n# block to always reset, instead.\nmachine.reset()\n```\n\n----------------------------------------\n\nTITLE: Debouncing a Pin Input - MicroPython\nDESCRIPTION: This function monitors a pin for changes in its value, ensuring that it is stable for at least 20 milliseconds before registering a change. This is useful for filtering out noise from mechanical switches. The function depends on the 'pyb' library for handling pin operations and delays.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/debounce.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport pyb\n\ndef wait_pin_change(pin):\n    # wait for pin to change value\n    # it needs to be stable for a continuous 20ms\n    cur_value = pin.value()\n    active = 0\n    while active < 20:\n        if pin.value() != cur_value:\n            active += 1\n        else:\n            active = 0\n        pyb.delay(1)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Timer Callbacks in MicroPython\nDESCRIPTION: Demonstrates registering a callback function that toggles an LED when the timer triggers. The example shows how to enable, modify, and disable timer callbacks. The callback function must accept one argument which is the timer object that triggered.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/timer.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> tim.callback(lambda t:pyb.LED(1).toggle())\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> tim.init(freq=20)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> tim.callback(None)\n```\n\n----------------------------------------\n\nTITLE: Configuring GPIO Pins on pyboard in MicroPython\nDESCRIPTION: Setting up and using GPIO pins for digital input and output. The example shows configuring a pin as push-pull output to drive high/low signals and setting up an input pin with pull-up resistor to read digital values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import Pin\n\np_out = Pin('X1', Pin.OUT_PP)\np_out.high()\np_out.low()\n\np_in = Pin('X2', Pin.IN, Pin.PULL_UP)\np_in.value() # get value, 0 or 1\n```\n\n----------------------------------------\n\nTITLE: Regular Expression Pattern Matching Example in MicroPython\nDESCRIPTION: Demonstrates using the re module to compile a regex pattern and split a string on carriage return and newline characters. Shows how to properly handle escape sequences in MicroPython regex patterns.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/re.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport re\n\n# As re doesn't support escapes itself, use of r\"\" strings is not\n# recommended.\nregex = re.compile(\"[\\r\\n]\")\n\nregex.split(\"line1\\rline2\\nline3\\r\\n\")\n\n# Result:\n# ['line1', 'line2', 'line3', '', '']\n```\n\n----------------------------------------\n\nTITLE: Implementing Deep Sleep with ESPNow in MicroPython\nDESCRIPTION: Demonstrates how to properly use deep sleep with ESPNow. The code initializes WiFi, sets up ESPNow, sends a message, and then correctly disables WiFi before entering deep sleep to conserve power.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport network, machine, espnow\n\nsta, ap = wifi_reset()            # Reset wifi to AP off, STA on and disconnected\npeer = b'0\\xaa\\xaa\\xaa\\xaa\\xaa'   # MAC address of peer\ne = espnow.ESPNow()\ne.active(True)\ne.add_peer(peer)                  # Register peer on STA_IF\n\nprint('Sending ping...')\nif not e.send(peer, b'ping'):\n  print('Ping failed!')\ne.active(False)\nsta.active(False)                 # Disable the wifi before sleep\nprint('Going to sleep...')\nmachine.deepsleep(10000)          # Sleep for 10 seconds then reboot\n```\n\n----------------------------------------\n\nTITLE: Blinking LED with Pin control using MicroPython\nDESCRIPTION: This code snippet demonstrates how to blink an LED connected to the RA MCU using the MicroPython 'machine' module. It initializes the Pin corresponding to 'LED1' and toggles its state every second.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/tutorial/using_peripheral.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport time\\nfrom machine import Pin\\nled1 = Pin('LED1')\\nprint(led1)\\nwhile True:\\n    led1.on()\\n    time.sleep(1)\\n    led1.off()\\n    time.sleep(1)\n```\n\n----------------------------------------\n\nTITLE: Reading Temperatures from DS18X20 Sensors using MicroPython\nDESCRIPTION: This script demonstrates how to initialize a DS18X20 temperature sensor on GPIO12, scan for devices on the 1-wire bus, and read temperatures in a loop. It requires at least one DS18S20 or DS18B20 sensor connected to GPIO12 with appropriate power and resistor setup.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/onewire.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport time\nimport machine\nimport onewire, ds18x20\n\n# the device is on GPIO12\ndat = machine.Pin(12)\n\n# create the onewire object\nds = ds18x20.DS18X20(onewire.OneWire(dat))\n\n# scan for devices on the bus\nroms = ds.scan()\nprint('found devices:', roms)\n\n# loop 10 times and print all temperatures\nfor i in range(10):\n    print('temperatures:', end=' ')\n    ds.convert_temp()\n    time.sleep_ms(750)\n    for rom in roms:\n        print(ds.read_temp(rom), end=' ')\n    print()\n```\n\n----------------------------------------\n\nTITLE: Setting Up I2C Communication on pyboard in MicroPython\nDESCRIPTION: Configuring and using the Inter-Integrated Circuit (I2C) bus in both hardware and software modes. The example demonstrates scanning for devices, writing to and reading from peripherals, and accessing specific memory addresses on I2C devices.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2C\n\ni2c = I2C('X', freq=400000)                 # create hardware I2c object\ni2c = I2C(scl='X1', sda='X2', freq=100000)  # create software I2C object\n\ni2c.scan()                          # returns list of peripheral addresses\ni2c.writeto(0x42, 'hello')          # write 5 bytes to peripheral with address 0x42\ni2c.readfrom(0x42, 5)               # read 5 bytes from peripheral\n\ni2c.readfrom_mem(0x42, 0x10, 2)     # read 2 bytes from peripheral 0x42, peripheral memory 0x10\ni2c.writeto_mem(0x42, 0x10, 'xy')   # write 2 bytes to peripheral 0x42, peripheral memory 0x10\n```\n\n----------------------------------------\n\nTITLE: Flashing MicroPython Firmware to ESP32 Board\nDESCRIPTION: This command flashes the MicroPython firmware to an ESP32 board using esptool.py. It specifies a baud rate of 460800 and a flash offset. Replace ESP32_BOARD_NAME-DATE-VERSION.bin with the actual firmware file name.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/boards/deploy.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py --baud 460800 write_flash {deploy_options[flash_offset]} ESP32_BOARD_NAME-DATE-VERSION.bin\n```\n\n----------------------------------------\n\nTITLE: Delay and Timing in MicroPython\nDESCRIPTION: Demonstrates how to use the `time` module for introducing delays and measuring time differences in MicroPython. It shows how to sleep for seconds, milliseconds, and microseconds, and how to get a millisecond counter and compute time differences.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\ntime.sleep(1)           # sleep for 1 second\ntime.sleep_ms(500)      # sleep for 500 milliseconds\ntime.sleep_us(10)       # sleep for 10 microseconds\nstart = time.ticks_ms() # get millisecond counter\ndelta = time.ticks_diff(time.ticks_ms(), start) # compute time difference\n```\n\n----------------------------------------\n\nTITLE: Configuring GPIO Pin Retention During Deep-Sleep in MicroPython on ESP32\nDESCRIPTION: Example showing how to configure GPIO pins to retain their state during deep-sleep on ESP32. This includes disabling pull-up resistors to save power and using pad hold functionality.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, deepsleep\n\n# configure input RTC pin with pull-up on boot\npin = Pin(2, Pin.IN, Pin.PULL_UP)\n\n# disable pull-up and put the device to sleep for 10 seconds\npin.init(pull=None)\nmachine.deepsleep(10000)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, deepsleep\nimport esp32\n\nopin = Pin(19, Pin.OUT, value=1, hold=True) # hold output level\nipin = Pin(21, Pin.IN, Pin.PULL_UP, hold=True) # hold pull-up\n\n# enable pad hold in deep-sleep for non-RTC GPIO\nesp32.gpio_deep_sleep_hold(True)\n\n# put the device to sleep for 10 seconds\ndeepsleep(10000)\n```\n\n----------------------------------------\n\nTITLE: Implementing ADC in MicroPython on ESP32\nDESCRIPTION: Demonstrates how to use the Analog to Digital Converter (ADC) on ESP32 using the machine.ADC class. Includes examples of reading raw analog values and calibrated voltage readings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import ADC\n\nadc = ADC(pin)        # create an ADC object acting on a pin\nval = adc.read_u16()  # read a raw analog value in the range 0-65535\nval = adc.read_uv()   # read an analog value in microvolts\n```\n\n----------------------------------------\n\nTITLE: Initializing Pin Objects in MicroPython\nDESCRIPTION: Demonstrates various ways to create and initialize Pin objects, including using board names, CPU pins, and custom mappings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Pin.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx1_pin = pyb.Pin.board.X1\n\ng = pyb.Pin(pyb.Pin.board.X1, pyb.Pin.IN)\n\ng = pyb.Pin('X1', pyb.Pin.OUT_PP)\n\nMyMapperDict = { 'LeftMotorDir' : pyb.Pin.cpu.C12 }\npyb.Pin.dict(MyMapperDict)\ng = pyb.Pin(\"LeftMotorDir\", pyb.Pin.OUT_OD)\n\npin = pyb.Pin(\"LeftMotorDir\")\n\ndef MyMapper(pin_name):\n   if pin_name == \"LeftMotorDir\":\n       return pyb.Pin.cpu.A0\n\npyb.Pin.mapper(MyMapper)\n```\n\n----------------------------------------\n\nTITLE: Creating a WiFi Connection Function in MicroPython for ESP8266\nDESCRIPTION: Defines a function to connect to a local WiFi network using the network module on an ESP8266 board. It attempts to connect and waits until the connection is established.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef do_connect():\n    import network\n    wlan = network.WLAN(network.WLAN.IF_STA)\n    wlan.active(True)\n    if not wlan.isconnected():\n        print('connecting to network...')\n        wlan.connect('ssid', 'key')\n        while not wlan.isconnected():\n            pass\n    print('network config:', wlan.ipconfig('addr4'))\n```\n\n----------------------------------------\n\nTITLE: Resolving hostnames with socket.getaddrinfo in MicroPython\nDESCRIPTION: This snippet demonstrates how to use the `socket.getaddrinfo` function to resolve a hostname and port into a socket address. This is the recommended way to obtain socket addresses for network connections in MicroPython due to its efficiency and portability. The example shows resolving both a domain name and a numeric IP address.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/socket.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"\nsockaddr = socket.getaddrinfo('www.micropython.org', 80)[0][-1]\n# You must use getaddrinfo() even for numeric addresses\nsockaddr = socket.getaddrinfo('127.0.0.1', 80)[0][-1]\n# Now you can use that address\nsock.connect(sockaddr)\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Hardware SPI Bus in MicroPython on ESP32\nDESCRIPTION: Example showing how to initialize and use hardware SPI channels on ESP32 using MicroPython. Hardware SPI allows faster transmission rates up to 80MHz and is accessed via the machine.SPI class.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SPI\n\nhspi = SPI(1, 10000000)\nhspi = SPI(1, 10000000, sck=Pin(14), mosi=Pin(13), miso=Pin(12))\nvspi = SPI(2, baudrate=80000000, polarity=0, phase=0, bits=8, firstbit=0, sck=Pin(18), mosi=Pin(23), miso=Pin(19))\n```\n\n----------------------------------------\n\nTITLE: Flashing STM32 Firmware via ST-Link using STM32 Cube Programmer\nDESCRIPTION: This snippet shows how to use the STM32 Cube Programmer to flash a .hex firmware file onto an STM32 microcontroller. The command uses the SWD (Serial Wire Debug) interface and performs a hard reset after flashing.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/deploy.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nSTM32_Programmer.sh -c port=SWD -d firmware.hex -hardRst\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using ADCBlock in MicroPython\nDESCRIPTION: This snippet demonstrates how to create an ADCBlock instance, connect a channel to a pin, and read an analog value. It showcases the basic usage of the ADCBlock class.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.ADCBlock.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import ADCBlock\n\nblock = ADCBlock(id, bits=12)  # create an ADCBlock with 12-bit resolution\nadc = block.connect(4, pin)    # connect channel 4 to the given pin\nval = adc.read_uv()            # read an analog value\n```\n\n----------------------------------------\n\nTITLE: Servo Motor Control with PWM\nDESCRIPTION: Demonstrates servo motor control using PWM with 50Hz frequency and duty cycles between 40 and 115 for full range of motion.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pwm.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> servo = machine.PWM(machine.Pin(12), freq=50)\n>>> servo.duty(40)\n>>> servo.duty(115)\n>>> servo.duty(77)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Signal Class for LEDs in MicroPython\nDESCRIPTION: This snippet demonstrates how to use the Signal class to control both active-high and active-low LEDs. It shows the advantage of Signal over Pin by abstracting away the active-high/active-low difference.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.Signal.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, Signal\n\n# Suppose you have an active-high LED on pin 0\nled1_pin = Pin(0, Pin.OUT)\n# ... and active-low LED on pin 1\nled2_pin = Pin(1, Pin.OUT)\n\n# Now to light up both of them using Pin class, you'll need to set\n# them to different values\nled1_pin.value(1)\nled2_pin.value(0)\n\n# Signal class allows to abstract away active-high/active-low\n# difference\nled1 = Signal(led1_pin, invert=False)\nled2 = Signal(led2_pin, invert=True)\n\n# Now lighting up them looks the same\nled1.value(1)\nled2.value(1)\n\n# Even better:\nled1.on()\nled2.on()\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple PWM Channels on ESP32\nDESCRIPTION: Demonstrates configuration of all 16 PWM channels across 8 timers with varying frequencies and duty cycles. Each pin is initialized with a unique frequency and duty cycle combination.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/tutorial/pwm.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, PWM\ntry:\n    f = 100  # Hz\n    d = 1024 // 16  # 6.25%\n    pins = (15, 2, 4, 16, 18, 19, 22, 23, 25, 26, 27, 14 , 12, 13, 32, 33)\n    pwms = []\n    for i, pin in enumerate(pins):\n        pwms.append(PWM(Pin(pin), freq=f * (i // 2 + 1), duty= 1023 if i==15 else d * (i + 1)))\n        print(pwms[i])\nfinally:\n    for pwm in pwms:\n        try:\n            pwm.deinit()\n        except:\n            pass\n```\n\n----------------------------------------\n\nTITLE: Using micropython.schedule for Safe Method Calling from ISRs\nDESCRIPTION: Shows how to safely call methods from an ISR by pre-allocating a reference to a bound method and using micropython.schedule to defer execution to the main thread.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/isr_rules.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass Foo():\n    def __init__(self):\n        self.bar_ref = self.bar  # Allocation occurs here\n        self.x = 0.1\n        tim = pyb.Timer(4)\n        tim.init(freq=2)\n        tim.callback(self.cb)\n\n    def bar(self, _):\n        self.x *= 1.2\n        print(self.x)\n\n    def cb(self, t):\n        # Passing self.bar would cause allocation.\n        micropython.schedule(self.bar_ref, 0)\n```\n\n----------------------------------------\n\nTITLE: Implementing Delays and Timing in MicroPython\nDESCRIPTION: Functions from the time module to create delays of different durations (seconds, milliseconds, microseconds) and measure time intervals using tick counters. These functions are essential for timing control in embedded applications.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\ntime.sleep(1)           # sleep for 1 second\ntime.sleep_ms(500)      # sleep for 500 milliseconds\ntime.sleep_us(10)       # sleep for 10 microseconds\nstart = time.ticks_ms() # get value of millisecond counter\ndelta = time.ticks_diff(time.ticks_ms(), start) # compute time difference\n```\n\n----------------------------------------\n\nTITLE: Handling Pin Interrupts in Zephyr\nDESCRIPTION: This code demonstrates how to use interrupts with pins in Zephyr. It initializes two pins (SW2 and SW3) as inputs and sets up interrupt handlers to print a message when the state of each pin changes. The while loop keeps the program running to listen for interrupts.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/tutorial/pins.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\n\nSW2 = Pin((\"GPIO_2\", 6), Pin.IN)            # create Pin object for switch 2\nSW3 = Pin((\"GPIO_0\", 4), Pin.IN)            # create Pin object for switch 3\n\nSW2.irq(lambda t: print(\"SW2 changed\"))     # print message when SW2 state is changed (triggers change IRQ)\nSW3.irq(lambda t: print(\"SW3 changed\"))     # print message when SW3 state is changed (triggers change IRQ)\n\nwhile True:                                 # wait\n    pass\n```\n\n----------------------------------------\n\nTITLE: Using MicroPython Garbage Collection Module\nDESCRIPTION: Demonstrates basic usage of MicroPython's gc module for memory management, including enabling/disabling garbage collection, checking memory allocation/free space, and triggering collection manually.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/memorymgt.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n>>> x = 5\n>>> x\n5\n>>> import gc\n>>> gc.enable()\n>>> gc.mem_alloc()\n1312\n>>> gc.mem_free()\n2071392\n>>> gc.collect()\n19\n>>> gc.disable()\n>>>\n```\n\n----------------------------------------\n\nTITLE: Configuring Deep Sleep Mode for ESP8266\nDESCRIPTION: Demonstrates how to configure and use deep sleep mode with RTC alarm wake-up functionality.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport machine\n\n# configure RTC.ALARM0 to be able to wake the device\nrtc = machine.RTC()\nrtc.irq(trigger=rtc.ALARM0, wake=machine.DEEPSLEEP)\n\n# check if the device woke from a deep sleep\nif machine.reset_cause() == machine.DEEPSLEEP_RESET:\n    print('woke from a deep sleep')\n\n# set RTC.ALARM0 to fire after 10 seconds (waking the device)\nrtc.alarm(rtc.ALARM0, 10000)\n\n# put the device to sleep\nmachine.deepsleep()\n```\n\n----------------------------------------\n\nTITLE: GPIO Pin Management with machine.Pin\nDESCRIPTION: Demonstrates how to use the machine.Pin class for managing GPIO pins on the Renesas RA boards. It includes configuring pins as input or output, setting pin values, and enabling internal pull-ups.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/quickref.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Pin\n\np0 = Pin('P000', Pin.OUT)      # create output pin on P000\np0.on()                        # set pin to \"on\" (high) level\np0.off()                       # set pin to \"off\" (low) level\np0.value(1)                    # set pin to on/high\n\np2 = Pin(Pin.cpu.P002, Pin.IN) # create input pin on P002\nprint(p2.value())              # get value, 0 or 1\n\np4 = Pin('P004', Pin.PULL_UP)      # enable internal pull-up register\np5 = Pin('P005', Pin.OUT, value=1) # set pin high on creation\n```\n\n----------------------------------------\n\nTITLE: Controlling GPIO Pins Using machine.Pin in MicroPython for ESP8266\nDESCRIPTION: Demonstrates how to use the machine.Pin class to control GPIO pins on an ESP8266 board. Shows examples of creating output and input pins, setting pin values, and using internal pull-up resistors.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\n\np0 = Pin(0, Pin.OUT)    # create output pin on GPIO0\np0.on()                 # set pin to \"on\" (high) level\np0.off()                # set pin to \"off\" (low) level\np0.value(1)             # set pin to on/high\n\np2 = Pin(2, Pin.IN)     # create input pin on GPIO2\nprint(p2.value())       # get value, 0 or 1\n\np4 = Pin(4, Pin.IN, Pin.PULL_UP) # enable internal pull-up resistor\np5 = Pin(5, Pin.OUT, value=1) # set pin high on creation\n```\n\n----------------------------------------\n\nTITLE: Creating a Servo Object and Setting Angle\nDESCRIPTION: This code snippet demonstrates how to create a Servo object and set its angle using the MicroPython pyboard. The angle can be adjusted and retrieved with the corresponding methods.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/servo.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> servo1 = pyb.Servo(1)\n>>> servo1.angle(45)\n>>> servo1.angle(-60)\n>>> servo1.angle()\n-60\n>>> servo1.angle(50, 1000)\n```\n\n----------------------------------------\n\nTITLE: Converting binary address to text with inet_ntop in MicroPython\nDESCRIPTION: This snippet demonstrates the use of `socket.inet_ntop` to convert a binary network address to its textual representation. This function is useful for displaying or logging IP addresses in a human-readable format. The example shows how to convert an IPv4 address from binary to a string.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/socket.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\"\"\">>> socket.inet_ntop(socket.AF_INET, b\"\\x7f\\0\\0\\1\")\n'127.0.0.1'\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing SPI Communication on pyboard in MicroPython\nDESCRIPTION: Configuring and using the Serial Peripheral Interface (SPI) bus. The example sets up SPI 1 in controller mode with specific baudrate, polarity, and phase settings, then demonstrates sending and receiving data over the bus.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import SPI\n\nspi = SPI(1, SPI.CONTROLLER, baudrate=200000, polarity=1, phase=0)\nspi.send('hello')\nspi.recv(5) # receive 5 bytes on the bus\nspi.send_recv('hello') # send and receive 5 bytes\n```\n\n----------------------------------------\n\nTITLE: Blinking an LED in app.py using hwconfig\nDESCRIPTION: This snippet demonstrates how to blink an LED using the hardware configuration defined in `hwconfig.py`. It imports the `LED` object from `hwconfig` and toggles its value in a loop using `time.sleep_ms` for delays. This illustrates the separation of application logic from hardware details.\nSOURCE: https://github.com/micropython/micropython/blob/master/examples/hwapi/README.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"from hwconfig import *\nimport time\n\nwhile True:\n    LED.value(1)\n    time.sleep_ms(500)\n    LED.value(0)\n    time.sleep_ms(500)\"\n```\n\n----------------------------------------\n\nTITLE: Controlling Servo Motors with pyboard in MicroPython\nDESCRIPTION: Using the Servo class to control servo motors connected to the pyboard. The code demonstrates setting specific angles, moving to positions with specified durations, and setting speeds for continuous rotation servos.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import Servo\n\ns1 = Servo(1) # servo on position 1 (X1, VIN, GND)\ns1.angle(45) # move to 45 degrees\ns1.angle(-60, 1500) # move to -60 degrees in 1500ms\ns1.speed(50) # for continuous rotation servos\n```\n\n----------------------------------------\n\nTITLE: Setting GPIO Output Values\nDESCRIPTION: Demonstrates different methods to set the output value of a GPIO pin using both numeric values and on/off functions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pins.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npin.value(0)\npin.value(1)\n\npin.off()\npin.on()\n```\n\n----------------------------------------\n\nTITLE: Initializing SSD1306 OLED with Hardware SPI Interface in MicroPython\nDESCRIPTION: Sets up an SSD1306 OLED display using Hardware SPI interface. Defines pins for clock, data, command, reset, and chip select, then initializes a 128x64 display.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/ssd1306.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SPI\nimport ssd1306\n\nhspi = SPI(1)  # sck=14 (scl), mosi=13 (sda), miso=12 (unused)\n\ndc = Pin(4)    # data/command\nrst = Pin(5)   # reset\ncs = Pin(15)   # chip select, some modules do not have a pin for this\n\ndisplay = ssd1306.SSD1306_SPI(128, 64, hspi, dc, rst, cs)\n```\n\n----------------------------------------\n\nTITLE: Using I2C in MicroPython for ESP8266\nDESCRIPTION: Shows how to use the machine.I2C class (which is an alias of machine.SoftI2C) to create an I2C bus on an ESP8266 board. Demonstrates reading from and writing to I2C devices.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, I2C\n\n# construct an I2C bus\ni2c = I2C(scl=Pin(5), sda=Pin(4), freq=100000)\n\ni2c.readfrom(0x3a, 4)   # read 4 bytes from peripheral device with address 0x3a\ni2c.writeto(0x3a, '12') # write '12' to peripheral device with address 0x3a\n\nbuf = bytearray(10)     # create a buffer with 10 bytes\ni2c.writeto(0x3a, buf)  # write the given buffer to the peripheral\n```\n\n----------------------------------------\n\nTITLE: WLAN Configuration in MicroPython\nDESCRIPTION: Illustrates how to configure and use WLAN on RP2 boards with WiFi support. It covers creating a station interface, activating the interface, scanning for access points, connecting to an AP, getting the MAC address, and getting the IPv4 addresses. Also, it shows how to create and configure an access point interface.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport network\n\nwlan = network.WLAN()       # create station interface (the default, see below for an access point interface)\nwlan.active(True)           # activate the interface\nwlan.scan()                 # scan for access points\nwlan.isconnected()          # check if the station is connected to an AP\nwlan.connect('ssid', 'key') # connect to an AP\nwlan.config('mac')          # get the interface's MAC address\nwlan.ipconfig('addr4')      # get the interface's IPv4 addresses\n\nap = network.WLAN(network.WLAN.IF_AP) # create access-point interface\nap.config(ssid='RP2-AP')              # set the SSID of the access point\nap.config(max_clients=10)             # set how many clients can connect to the network\nap.active(True)                       # activate the interface\n```\n\n----------------------------------------\n\nTITLE: WiFi Connection Helper Function\nDESCRIPTION: Utility function to connect to a local WiFi network with status monitoring\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef do_connect():\n    import machine, network\n    wlan = network.WLAN()\n    wlan.active(True)\n    if not wlan.isconnected():\n        print('connecting to network...')\n        wlan.connect('ssid', 'key')\n        while not wlan.isconnected():\n            machine.idle()\n    print('network config:', wlan.ipconfig('addr4'))\n```\n\n----------------------------------------\n\nTITLE: Deploying MicroPython Firmware to Teensy 4.0/4.1 Using Command Line\nDESCRIPTION: Command for uploading MicroPython firmware to Teensy 4.0 and 4.1 boards using the teensy_loader_cli tool. The command specifies the microcontroller model (imxrt1062), enables verbose output (-v), and writes (-w) the firmware hex file to the board.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/tutorial/intro.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nteensy_loader_cli --mcu=imxrt1062 -v -w firmware.hex\n```\n\n----------------------------------------\n\nTITLE: Timer Usage in MicroPython\nDESCRIPTION: Illustrates how to use the `machine.Timer` class for creating and initializing timers in MicroPython. It shows how to create a one-shot timer and a periodic timer with specified periods and callbacks.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Timer\n\ntim = Timer(period=5000, mode=Timer.ONE_SHOT, callback=lambda t:print(1))\ntim.init(period=2000, mode=Timer.PERIODIC, callback=lambda t:print(2))\n```\n\n----------------------------------------\n\nTITLE: Implementing Smooth Frequency Change for PWM\nDESCRIPTION: Creates a PWM signal with smoothly varying frequency between 500Hz and 1000Hz. The frequency is incrementally adjusted with sleep delays to create a visible effect on an oscilloscope.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/tutorial/pwm.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom time import sleep\nfrom machine import Pin, PWM\n\nF_MIN = 500\nF_MAX = 1000\n\nf = F_MIN\ndelta_f = 1\n\np = PWM(Pin(5), f)\nprint(p)\n\nwhile True:\n    p.freq(f)\n    \n    sleep(10 / F_MIN)\n    \n    f += delta_f\n    if f >= F_MAX or f <= F_MIN:\n        delta_f = -delta_f\n```\n\n----------------------------------------\n\nTITLE: Configuring Timers on WiPy with MicroPython\nDESCRIPTION: This snippet illustrates how to configure and use timers on the WiPy board. It shows creating a periodic timer and setting its frequency. The code also demonstrates how to trigger interrupts using timers to toggle a GPIO pin.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Timer\nfrom machine import Pin\n\ntim = Timer(0, mode=Timer.PERIODIC)\ntim_a = tim.channel(Timer.A, freq=1000)\ntim_a.freq(5) # 5 Hz\n\np_out = Pin('GP2', mode=Pin.OUT)\ntim_a.irq(trigger=Timer.TIMEOUT, handler=lambda t: p_out.toggle())\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using ADC in MicroPython\nDESCRIPTION: Basic example showing how to create an ADC object, set up an analog pin on GP3, and read an analog value. This demonstrates the core functionality of the ADCWiPy class.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.ADCWiPy.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport machine\n\nadc = machine.ADC()             # create an ADC object\napin = adc.channel(pin='GP3')   # create an analog pin on GP3\nval = apin()                    # read an analog value\n```\n\n----------------------------------------\n\nTITLE: Initializing RTC Object in MicroPython\nDESCRIPTION: This snippet creates an instance of the RTC class, enabling users to manipulate the real time clock. It is useful when tracking date and time is required for applications running on MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.RTC.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nrtc = pyb.RTC()\n```\n\n----------------------------------------\n\nTITLE: Running NeoPixel Demo\nDESCRIPTION: Command to execute the animation demonstration function\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/neopixel.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndemo(np)\n```\n\n----------------------------------------\n\nTITLE: Configuring and Using RMT (Remote Control) Module in Python\nDESCRIPTION: This code snippet shows how to initialize and use the RMT (Remote Control) module on an ESP32. It demonstrates creating an RMT object, configuring it with a specific pin and clock divider, and sending a series of pulses. It also includes an example of applying a carrier frequency to the output.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp32.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport esp32\nfrom machine import Pin\n\nr = esp32.RMT(0, pin=Pin(18), clock_div=8)\nr  # RMT(channel=0, pin=18, source_freq=80000000, clock_div=8, idle_level=0)\n\n# To apply a carrier frequency to the high output\nr = esp32.RMT(0, pin=Pin(18), clock_div=8, tx_carrier=(38000, 50, 1))\n\n# The channel resolution is 100ns (1/(source_freq/clock_div)).\nr.write_pulses((1, 20, 2, 40), 0)  # Send 0 for 100ns, 1 for 2000ns, 0 for 200ns, 1 for 4000ns\n```\n\n----------------------------------------\n\nTITLE: Using a RAM Block Device with FAT Filesystem in MicroPython\nDESCRIPTION: Demonstrates how to create and mount a FAT filesystem using a RAM block device. This example creates a 25KB RAM disk that can be accessed through the '/ramdisk' path.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport vfs\n\nbdev = RAMBlockDev(512, 50)\nvfs.VfsFat.mkfs(bdev)\nvfs.mount(bdev, '/ramdisk')\n```\n\n----------------------------------------\n\nTITLE: Hardware I2C Bus Interaction - MicroPython\nDESCRIPTION: This snippet demonstrates the use of the I2C class to communicate with I2C devices. It includes example methods for scanning devices, reading from and writing to devices, and managing data buffers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/quickref.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import I2C\n\ni2c = I2C(\"i2c0\")           # construct an i2c bus\nprint(i2c)                  # print device name\ni2c.scan()                  # scan the device for available I2C slaves\ni2c.readfrom(0x1D, 4)                # read 4 bytes from slave 0x1D\ni2c.readfrom_mem(0x1D, 0x0D, 1)      # read 1 byte from slave 0x1D at slave memory 0x0D\ni2c.writeto(0x1D, b'abcd')           # write to slave with address 0x1D\ni2c.writeto_mem(0x1D, 0x0D, b'ab')   # write to slave 0x1D at slave memory 0x0D\n\nbuf = bytearray(8)                  # create buffer of size 8\ni2c.writeto(0x1D, b'abcd')          # write buf to slave 0x1D\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Independent Timers in MicroPython\nDESCRIPTION: Creates two separate timer objects with different frequencies and assigns each to toggle a different LED. This demonstrates how multiple hardware timers can run independently of each other as proper hardware interrupts.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/timer.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> tim4 = pyb.Timer(4, freq=10)\n>>> tim7 = pyb.Timer(7, freq=20)\n>>> tim4.callback(lambda t: pyb.LED(1).toggle())\n>>> tim7.callback(lambda t: pyb.LED(2).toggle())\n```\n\n----------------------------------------\n\nTITLE: Generating PWM Signals with Machine Module\nDESCRIPTION: This snippet demonstrates how to generate PWM (pulse width modulation) signals using the machine.PWM class. All channels of a module run at the same frequency, but allow for different duty cycles. Outputs are assigned to channels in modulo-n fashion, where n is the number of channels. Outputs of a channel have the same frequency and duty rate, but may have different polarity.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Samples for Adafruit ItsyBitsy M4 Express\n\nfrom machine import Pin, PWM\n\n# create PWM object from a pin and set the frequency and duty cycle\npwm = PWM(Pin('D7'), freq=2000, duty_u16=32768)\npwm.freq()             # get the current frequency\npwm.freq(1000)         # set/change the frequency\npwm.duty_u16()         # get the current duty cycle, range 0-65535\npwm.duty_u16(200)      # set the duty cycle, range 0-65535\npwm.deinit()           # turn off PWM on the pin\n\npwm                    # show the PWM objects properties\n```\n\n----------------------------------------\n\nTITLE: Using DHT11 and DHT22 Temperature/Humidity Sensors with MicroPython\nDESCRIPTION: This snippet demonstrates how to use DHT11 and DHT22 temperature and humidity sensors with MicroPython. It shows initializing the sensors, taking measurements, and reading temperature and humidity values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nimport dht\nimport machine\n\nd = dht.DHT11(machine.Pin(4))\nd.measure()\nd.temperature() # eg. 23 (°C)\nd.humidity()    # eg. 41 (% RH)\n\nd = dht.DHT22(machine.Pin(4))\nd.measure()\nd.temperature() # eg. 23.6 (°C)\nd.humidity()    # eg. 41.3 (% RH)\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing with UART in MicroPython\nDESCRIPTION: This snippet shows various methods for reading and writing data using a UART object. It includes examples of reading a specific number of characters, reading all available characters, reading a line, reading into a buffer, and writing a string.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.UART.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nuart.read(10)       # read 10 characters, returns a bytes object\nuart.read()         # read all available characters\nuart.readline()     # read a line\nuart.readinto(buf)  # read and store into the given buffer\nuart.write('abc')   # write the 3 characters\n```\n\n----------------------------------------\n\nTITLE: Controlling GPIO Pins with Machine Module\nDESCRIPTION: This snippet demonstrates how to control GPIO pins using the machine.Pin class.  Pins can be denoted by a string (pin label like 'D0' or 'SDA', or 'Pxnn' where x is A, B, C or D, and nn is a two digit number in the range 0-31) or a number.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\n\np0 = Pin('D0', Pin.OUT) # create output pin on GPIO0\np0.on()                 # set pin to \"on\" (high) level\np0.off()                # set pin to \"off\" (low) level\np0.value(1)             # set pin to on/high\n\np2 = Pin('D2', Pin.IN)  # create input pin on GPIO2\nprint(p2.value())       # get value, 0 or 1\n\np4 = Pin('D4', Pin.IN, Pin.PULL_UP) # enable internal pull-up resistor\np7 = Pin('PA07', Pin.OUT, value=1) # set pin high on creation\n```\n\n----------------------------------------\n\nTITLE: Using Real Time Clock (RTC) in MicroPython on ESP32\nDESCRIPTION: Example demonstrating how to use the Real Time Clock (RTC) on ESP32 with MicroPython. The RTC allows setting and retrieving date and time.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import RTC\n\nrtc = RTC()\nrtc.datetime((2017, 8, 23, 0, 1, 12, 48, 0)) # set a specific date and\n                                             # time, eg. 2017/8/23 1:12:48\n                                             # the day-of-week value is ignored\nrtc.datetime() # get date and time\n```\n\n----------------------------------------\n\nTITLE: Entering the REPL on a connected device\nDESCRIPTION: Command to enter the interactive Read-Eval-Print Loop on the connected MicroPython device, with optional parameters for escaping non-printable characters, capturing output, and injecting code.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote repl [--options]\n```\n\n----------------------------------------\n\nTITLE: Reading Accelerometer Values in MicroPython\nDESCRIPTION: Basic example of creating an accelerometer object and reading the x-axis value. The accelerometer returns values between approximately -30 and 30, with some noise in the measurements.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/accel.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> accel = pyb.Accel()\n>>> accel.x()\n7\n```\n\n----------------------------------------\n\nTITLE: Generating PWM Signals on pyboard in MicroPython\nDESCRIPTION: Creating Pulse Width Modulation (PWM) signals using timers and pins. This example configures Timer 2 channel 1 connected to pin X1 to generate a 1kHz PWM signal with 50% duty cycle, useful for controlling motor speed or LED brightness.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import Pin, Timer\n\np = Pin('X1') # X1 has TIM2, CH1\ntim = Timer(2, freq=1000)\nch = tim.channel(1, Timer.PWM, pin=p)\nch.pulse_width_percent(50)\n```\n\n----------------------------------------\n\nTITLE: Connecting to a URL using socket.getaddrinfo in MicroPython\nDESCRIPTION: This snippet demonstrates how to connect to a URL using `socket.getaddrinfo`. It creates a socket, resolves the address using `socket.getaddrinfo`, and then connects to the resolved address. It shows a basic example, and a more robust one using filtering parameters for stream operations, guaranteeing a connectable address.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/socket.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"\ns = socket.socket()\n# This assumes that if \"type\" is not specified, an address for\n# SOCK_STREAM will be returned, which may be not true\ns.connect(socket.getaddrinfo('www.micropython.org', 80)[0][-1])\n\ns = socket.socket()\n# Guaranteed to return an address which can be connect'ed to for\n# stream operation.\ns.connect(socket.getaddrinfo('www.micropython.org', 80, 0, SOCK_STREAM)[0][-1])\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: ADC Usage in MicroPython\nDESCRIPTION: Illustrates how to use the `machine.ADC` class for ADC (analog to digital conversion) in MicroPython. It shows how to create an ADC object on an ADC pin and read the value.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import ADC, Pin\nadc = ADC(Pin(26))     # create ADC object on ADC pin\nadc.read_u16()         # read value, 0-65535 across voltage range 0.0v - 3.3v\n```\n\n----------------------------------------\n\nTITLE: Initializing I2C Connections MicroPython\nDESCRIPTION: This snippet demonstrates how to initialize an I2C object in MicroPython using the pyb library. It shows initializing on different buses and modes, along with options for baud rate and address. Key parameters like bus number, mode, baud rate, and address are essential for setup.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.I2C.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom pyb import I2C\n\ni2c = I2C(1)                             # create on bus 1\ni2c = I2C(1, I2C.CONTROLLER)             # create and init as a controller\ni2c.init(I2C.CONTROLLER, baudrate=20000) # init as a controller\ni2c.init(I2C.PERIPHERAL, addr=0x42)      # init as a peripheral with given address\ni2c.deinit()                             # turn off the I2C unit\n```\n\n----------------------------------------\n\nTITLE: Creating and Writing Files in MicroPython\nDESCRIPTION: Demonstrates how to create a new text file, write data to it, and close the file using the built-in open() function. The write() method returns the number of bytes written.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/filesystem.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nf = open('data.txt', 'w')\nf.write('some data')\nf.close()\n```\n\n----------------------------------------\n\nTITLE: Initializing UART in MicroPython\nDESCRIPTION: This snippet demonstrates how to import and initialize a UART object with a given baudrate. It also shows how to initialize with specific parameters such as bits, parity, and stop bits.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.UART.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import UART\n\nuart = UART(1, 9600)                         # init with given baudrate\nuart.init(9600, bits=8, parity=None, stop=1) # init with given parameters\n```\n\n----------------------------------------\n\nTITLE: Connecting to WiFi Network using WLANWiPy in MicroPython\nDESCRIPTION: This snippet demonstrates how to set up a WiFi connection as a station using the WLANWiPy class. It includes connecting to a network, waiting for the connection to be established, and printing the IP address.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.WLANWiPy.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport network\nimport time\n# setup as a station\nwlan = network.WLAN(mode=WLAN.STA)\nwlan.connect('your-ssid', auth=(WLAN.WPA2, 'your-key'))\nwhile not wlan.isconnected():\n    time.sleep_ms(50)\nprint(wlan.ipconfig(\"addr4\"))\n\n# now use socket as usual\n...\n```\n\n----------------------------------------\n\nTITLE: Scanning and Connecting to a Wi-Fi Network in MicroPython\nDESCRIPTION: This code snippet demonstrates how to scan for available Wi-Fi networks, identify a specific network by its SSID, and connect to it using the `wlan.connect()` method on a WiPy device. It includes error handling for network connection and waits until the connection is established using `wlan.isconnected()` and `machine.idle()` to save power. It also assumes the availability of the `machine` module.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/wlan.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnets = wlan.scan()\nfor net in nets:\n    if net.ssid == 'mywifi':\n        print('Network found!')\n        wlan.connect(net.ssid, auth=(net.sec, 'mywifikey'), timeout=5000)\n        while not wlan.isconnected():\n            machine.idle() # save power while waiting\n        print('WLAN connection succeeded!')\n        break\n```\n\n----------------------------------------\n\nTITLE: Deploy Firmware Using ST-LINK\nDESCRIPTION: Command to flash firmware using st-flash utility for boards with ST-LINK programmer.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ make BOARD=STM32F4DISC deploy-stlink\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Hardware SPI in MicroPython on SAMD21/SAMD51\nDESCRIPTION: This snippet demonstrates how to set up and use a Hardware SPI bus on SAMD21/SAMD51 devices. It shows initialization with default and custom settings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import SPI\n\nspi = SPI(1, sck=Pin(\"SCK\"), mosi=Pin(\"MOSI\"), miso=Pin(\"MISO\"), baudrate=10000000)\nspi.write('Hello World')\n\n# Using default values\nspi = SPI()  # Use the default device and default baudrate\nspi = SPI(baudrate=12_000_000)  # Use the default device and change the baudrate\n```\n\n----------------------------------------\n\nTITLE: WiFi Connection Function in MicroPython\nDESCRIPTION: Provides a function `do_connect()` to connect to a local WiFi network using the `network` module. It activates the WLAN interface, connects to the specified SSID with the given key, and prints the network configuration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef do_connect():\n    import machine, network\n    wlan = network.WLAN()\n    wlan.active(True)\n    if not wlan.isconnected():\n        print('connecting to network...')\n        wlan.connect('ssid', 'key')\n        while not wlan.isconnected():\n            machine.idle()\n    print('network config:', wlan.ipconfig('addr4'))\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using RTC in MicroPython\nDESCRIPTION: This snippet demonstrates how to create an RTC object, set the date and time, and then read the current datetime. It showcases the basic usage of the RTC class.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.RTC.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nrtc = machine.RTC()\nrtc.datetime((2020, 1, 21, 2, 10, 32, 36, 0))\nprint(rtc.datetime())\n```\n\n----------------------------------------\n\nTITLE: Initializing CAN FD with Extended Options (Python)\nDESCRIPTION: Example of initializing and using a CAN FD controller with all possible options enabled. It sets up FD frame, BRS mode, Extended frame ID, and different baudrates for arbitration and data phases.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.CAN.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# FD frame + BRS mode + Extended frame ID. 500 Kbit/s for arbitration phase, 1Mbit/s for data phase.\ncan = CAN(1, CAN.NORMAL, baudrate=500_000, brs_baudrate=1_000_000, sample_point=80)\ncan.setfilter(0, CAN.RANGE, 0, (0xFFF0, 0xFFFF))\ncan.send('a'*64, 0xFFFF, fdf=True, brs=True, extframe=True)\ncan.recv(0)\n```\n\n----------------------------------------\n\nTITLE: Comprehensive APA102 LED Demo in MicroPython\nDESCRIPTION: This extensive demonstration script showcases various effects with APA102 LEDs. It includes initializing the strip, defining a color wheel function, and running multiple demo patterns such as RGB cycling, rainbow colors, fading, and brightness control.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/apa102.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport time\nimport machine, apa102\n\n# 1M strip with 60 LEDs\nstrip = apa102.APA102(machine.Pin(5), machine.Pin(4), 60)\n\nbrightness = 1  # 0 is off, 1 is dim, 31 is max\n\n# Helper for converting 0-255 offset to a colour tuple\ndef wheel(offset, brightness):\n    # The colours are a transition r - g - b - back to r\n    offset = 255 - offset\n    if offset < 85:\n        return (255 - offset * 3, 0, offset * 3, brightness)\n    if offset < 170:\n        offset -= 85\n        return (0, offset * 3, 255 - offset * 3, brightness)\n    offset -= 170\n    return (offset * 3, 255 - offset * 3, 0, brightness)\n\n# Demo 1: RGB RGB RGB\nred = 0xff0000\ngreen = red >> 8\nblue = red >> 16\nfor i in range(strip.n):\n    colour = red >> (i % 3) * 8\n    strip[i] = ((colour & red) >> 16, (colour & green) >> 8, (colour & blue), brightness)\nstrip.write()\n\n# Demo 2: Show all colours of the rainbow\nfor i in range(strip.n):\n    strip[i] = wheel((i * 256 // strip.n) % 255, brightness)\nstrip.write()\n\n# Demo 3: Fade all pixels together through rainbow colours, offset each pixel\nfor r in range(5):\n    for n in range(256):\n        for i in range(strip.n):\n            strip[i] = wheel(((i * 256 // strip.n) + n) & 255, brightness)\n        strip.write()\n    time.sleep_ms(25)\n\n# Demo 4: Same colour, different brightness levels\nfor b in range(31,-1,-1):\n    strip[0] = (255, 153, 0, b)\n    strip.write()\n    time.sleep_ms(250)\n\n# End: Turn off all the LEDs\nstrip.fill((0, 0, 0, 0))\nstrip.write()\n```\n\n----------------------------------------\n\nTITLE: Implementing Smooth Duty Cycle Change for PWM\nDESCRIPTION: Demonstrates smooth PWM duty cycle modulation using 16-bit resolution. The duty cycle gradually changes between 0 and maximum (65535), creating a visible effect on an oscilloscope.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/tutorial/pwm.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom time import sleep\nfrom machine import Pin, PWM\n\nDUTY_MAX = 2**16 - 1\n\nduty_u16 = 0\ndelta_d = 16\n\np = PWM(Pin(5), 1000, duty_u16=duty_u16)\nprint(p)\n\nwhile True:\n    p.duty_u16(duty_u16)\n    \n    sleep(1 / 1000)\n    \n    duty_u16 += delta_d\n    if duty_u16 >= DUTY_MAX:\n        duty_u16 = DUTY_MAX\n        delta_d = -delta_d\n    elif duty_u16 <= 0:\n        duty_u16 = 0\n        delta_d = -delta_d\n```\n\n----------------------------------------\n\nTITLE: Creating a Microsecond Counter with Timer in MicroPython\nDESCRIPTION: Sets up timer 2 as a microsecond counter for precise timing measurements. The timer is configured with a 1 MHz frequency by setting the appropriate prescaler value. The period is set to a large value to prevent frequent overflow.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/timer.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> micros = pyb.Timer(2, prescaler=83, period=0x3fffffff)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> micros.counter(0)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> start_micros = micros.counter()\n\n... do some stuff ...\n\n>>> end_micros = micros.counter()\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Memory Usage Report in MicroPython\nDESCRIPTION: This extensive code snippet provides a detailed report on memory usage in MicroPython. It demonstrates various memory-related functions and their usage, including garbage collection, memory information retrieval, and allocation reporting.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport gc\nimport micropython\ngc.collect()\nmicropython.mem_info()\nprint('-----------------------------')\nprint('Initial free: {} allocated: {}'.format(gc.mem_free(), gc.mem_alloc()))\ndef func():\n    a = bytearray(10000)\ngc.collect()\nprint('Func definition: {} allocated: {}'.format(gc.mem_free(), gc.mem_alloc()))\nfunc()\nprint('Func run free: {} allocated: {}'.format(gc.mem_free(), gc.mem_alloc()))\ngc.collect()\nprint('Garbage collect free: {} allocated: {}'.format(gc.mem_free(), gc.mem_alloc()))\nprint('-----------------------------')\nmicropython.mem_info(1)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom USB Protocol in Python\nDESCRIPTION: This snippet showcases a custom USB protocol implementation using the machine.USBDevice class in MicroPython. This serves to create a USB device that communicates with a corresponding host program, providing a tailored interaction method. Dependencies include the MicroPython environment with USB capabilities.\nSOURCE: https://github.com/micropython/micropython/blob/master/examples/usb/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n## usb_simple_device.py\n\n# Implementation of a custom USB protocol with a matching host program.\n\n```\n\n----------------------------------------\n\nTITLE: Using I2S Bus in MicroPython on ESP32\nDESCRIPTION: Example showing how to configure and use I2S bus on ESP32 with MicroPython. I2S is used for audio applications and the ESP32 has two I2S buses with id=0 and id=1.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2S, Pin\n\ni2s = I2S(0, sck=Pin(13), ws=Pin(14), sd=Pin(34), mode=I2S.TX, bits=16, format=I2S.STEREO, rate=44100, ibuf=40000) # create I2S object\ni2s.write(buf)             # write buffer of audio samples to I2S device\n\ni2s = I2S(1, sck=Pin(33), ws=Pin(25), sd=Pin(32), mode=I2S.RX, bits=16, format=I2S.MONO, rate=22050, ibuf=40000) # create I2S object\ni2s.readinto(buf)          # fill buffer with audio samples from I2S device\n```\n\n----------------------------------------\n\nTITLE: Using select.poll as an Alternative to settimeout() in MicroPython\nDESCRIPTION: This example demonstrates how to use select.poll for handling socket timeouts in a more portable way across MicroPython ports. It shows the replacement of the direct settimeout() method with a polling approach that supports multiple objects and generic stream operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/socket.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Instead of:\ns.settimeout(1.0)  # time in seconds\ns.read(10)  # may timeout\n\n# Use:\npoller = select.poll()\npoller.register(s, select.POLLIN)\nres = poller.poll(1000)  # time in milliseconds\nif not res:\n    # s is still not ready for input, i.e. operation timed out\n```\n\n----------------------------------------\n\nTITLE: MicroPython Remote Usage Examples\nDESCRIPTION: Collection of example commands showing various ways to use mpremote, including connection management, file operations, code execution, and package installation.\nSOURCE: https://github.com/micropython/micropython/blob/master/tools/mpremote/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmpremote\nmpremote a1\nmpremote connect /dev/ttyUSB0 repl\nmpremote ls\nmpremote a1 ls\nmpremote exec \"import micropython; micropython.mem_info()\"\nmpremote eval 1/2 eval 3/4\nmpremote mount .\nmpremote mount . exec \"import local_script\"\nmpremote ls\nmpremote cat boot.py\nmpremote cp :main.py .\nmpremote cp main.py :\nmpremote cp -r dir/ :\nmpremote sha256sum :main.py\nmpremote mip install aioble\nmpremote mip install github:org/repo@branch\nmpremote mip install gitlab:org/repo@branch\n```\n\n----------------------------------------\n\nTITLE: Connecting to TCP Server in MicroPython\nDESCRIPTION: This snippet demonstrates how to create a socket and connect to a TCP server using the obtained IP address.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_tcp.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ns = socket.socket()\ns.connect(addr)\n```\n\n----------------------------------------\n\nTITLE: Reading the Internal Accelerometer on pyboard in MicroPython\nDESCRIPTION: Accessing the pyboard's built-in accelerometer to measure acceleration and tilt. The example initializes the accelerometer object and reads the X, Y, Z acceleration values as well as the tilt measurement.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import Accel\n\naccel = Accel()\nprint(accel.x(), accel.y(), accel.z(), accel.tilt())\n```\n\n----------------------------------------\n\nTITLE: Toggle LED with Timer (Named Function)\nDESCRIPTION: This example uses a named function as a callback for a MicroPython timer to toggle an LED. It initializes a 32-bit timer in periodic mode, configures a channel with a specific frequency, defines a callback function to toggle the LED, and then attaches the callback to the timer's interrupt.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/timer.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Timer\nfrom machine import Pin\ntim = Timer(1, mode=Timer.PERIODIC, width=32)\ntim_a = tim.channel(Timer.A | Timer.B, freq=1)   # 1 Hz frequency requires a 32 bit timer\n\nled = Pin('GP16', mode=Pin.OUT) # enable GP16 as output to drive the LED\n\ndef tick(timer):                # we will receive the timer object when being called\n    global led\n    led.toggle()                # toggle the LED\n\ntim_a.irq(handler=tick, trigger=Timer.TIMEOUT)         # create the interrupt\n```\n\n----------------------------------------\n\nTITLE: Communicating Over SPI on WiPy with MicroPython\nDESCRIPTION: This snippet showcases configuring an SPI bus on the WiPy board using the 'machine.SPI' class. It demonstrates writing to the SPI bus, reading from it, and simultaneously writing to and reading from the bus using a buffer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import SPI\n\n# configure the SPI controller @ 2MHz\nspi = SPI(0, SPI.CONTROLLER, baudrate=2_000_000, polarity=0, phase=0)\nspi.write('hello')\nspi.read(5) # receive 5 bytes on the bus\nrbuf = bytearray(5)\nspi.write_readinto('hello', rbuf) # send and receive 5 bytes\n```\n\n----------------------------------------\n\nTITLE: Wrapping Socket with SSL\nDESCRIPTION: Wraps a socket with SSL/TLS encryption. Takes parameters for server/client mode, certificates, and handshake behavior.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/ssl.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nssl.wrap_socket(sock, server_side=False, key=None, cert=None, cert_reqs=CERT_NONE, cadata=None, server_hostname=None, do_handshake=True)\n```\n\n----------------------------------------\n\nTITLE: Using DS18x20 Temperature Sensors with OneWire in MicroPython on ESP32\nDESCRIPTION: Example demonstrating how to use DS18S20 and DS18B20 temperature sensors with OneWire on ESP32 using MicroPython. This shows how to scan for devices, convert temperature readings, and read the temperature values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nimport time, ds18x20\nds = ds18x20.DS18X20(ow)\nroms = ds.scan()\nds.convert_temp()\ntime.sleep_ms(750)\nfor rom in roms:\n    print(ds.read_temp(rom))\n```\n\n----------------------------------------\n\nTITLE: Configuring WLAN on WiPy with MicroPython\nDESCRIPTION: This snippet demonstrates setting up a WLAN connection on the WiPy board. The code sets up the WLAN module in station mode, configures IP settings, scans networks, connects to a specified network, and enables wake-on-wireless functionality.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nimport machine, network\nfrom network import WLAN\n\n# configure the WLAN subsystem in station mode (the default is AP)\nwlan = WLAN(mode=WLAN.STA)\n# go for fixed IP settings\nnetwork.ipconfig(dns='8.8.8.8')\nwlan.ipconfig(addr4='192.168.0.107/24', gw4='192.168.0.1')\nwlan.scan()     # scan for available networks\nwlan.connect(ssid='mynetwork', auth=(WLAN.WPA2, 'mynetworkkey'))\nwhile not wlan.isconnected():\n    pass\n# enable wake on WLAN\nwlan.irq(trigger=WLAN.ANY_EVENT, wake=machine.SLEEP)\n# go to sleep\nmachine.lightsleep()\n# now, connect to the FTP or the Telnet server and the WiPy will wake-up\n```\n\n----------------------------------------\n\nTITLE: Initializing DHT22 Sensor in MicroPython\nDESCRIPTION: Creates a DHT22 sensor object using machine.Pin(4) for more precise temperature and humidity readings. DHT22 provides decimal resolution and should be read once every two seconds.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/dht.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport dht\nimport machine\nd = dht.DHT22(machine.Pin(4))\n```\n\n----------------------------------------\n\nTITLE: Basic ADC Usage in MicroPython\nDESCRIPTION: Basic initialization and reading of analog values from a pin using the ADC class\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.ADC.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pyb\n\nadc = pyb.ADC(pin)                  # create an analog object from a pin\nval = adc.read()                    # read an analog value\n\nadc = pyb.ADCAll(resolution)        # create an ADCAll object\nadc = pyb.ADCAll(resolution, mask)  # create an ADCAll object for selected analog channels\nval = adc.read_channel(channel)     # read the given channel\nval = adc.read_core_temp()          # read MCU temperature\nval = adc.read_core_vbat()          # read MCU VBAT\nval = adc.read_core_vref()          # read MCU VREF\nval = adc.read_vref()               # read MCU supply voltage\n```\n\n----------------------------------------\n\nTITLE: Using Hardware I2C Bus in MicroPython on ESP32\nDESCRIPTION: Example showing how to initialize and use hardware I2C peripherals on ESP32 using MicroPython. The ESP32 has two hardware I2C peripherals with identifiers 0 and 1.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, I2C\n\ni2c = I2C(0)\ni2c = I2C(1, scl=Pin(5), sda=Pin(4), freq=400000)\n```\n\n----------------------------------------\n\nTITLE: Reading Analog Values with ADC on pyboard in MicroPython\nDESCRIPTION: Using the Analog-to-Digital Converter (ADC) to read analog values from a pin. The example initializes an ADC on pin X19 and reads the analog value in the range of 0-4095 (12-bit resolution).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import Pin, ADC\n\nadc = ADC(Pin('X19'))\nadc.read() # read value, 0-4095\n```\n\n----------------------------------------\n\nTITLE: Reading DHT22 Temperature Sensor Data in MicroPython\nDESCRIPTION: Example showing how to initialize and read data from a DHT22 sensor connected to pin D4. The DHT22 provides higher precision readings compared to DHT11. Returns temperature in Celsius and relative humidity as a percentage.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nd = dht.DHT22(machine.Pin('D4'))\nd.measure()\nd.temperature() # eg. 23.6 (°C)\nd.humidity()    # eg. 41.3 (% RH)\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython for WeAct F411 Blackpill v1.3 with 2MB Flash and 8MHz Crystal\nDESCRIPTION: This command builds MicroPython for a WeAct F411 Blackpill v1.3 board with a manually replaced 8MHz crystal and a 2MB SPI flash chip. It specifies the board type, variant, SPI flash size, and crystal frequency.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/WEACT_F411_BLACKPILL/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake -C ports/stm32 BOARD=WEACT_F411_BLACKPILL BOARD_VARIANT=V13 SPI_FLASH_SIZE_MB=2 XTAL_FREQ_MHZ=8\n```\n\n----------------------------------------\n\nTITLE: Toggle LED with Timer (Periodic)\nDESCRIPTION: This example demonstrates how to use a MicroPython timer in periodic mode to toggle an LED at a fixed frequency. It initializes a timer object, configures a channel with a specific frequency, and sets up an interrupt to call a lambda function that toggles the LED.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/timer.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Timer\nfrom machine import Pin\nled = Pin('GP16', mode=Pin.OUT)                  # enable GP16 as output to drive the LED\ntim = Timer(3)                                   # create a timer object using timer 3\ntim.init(mode=Timer.PERIODIC)                    # initialize it in periodic mode\ntim_ch = tim.channel(Timer.A, freq=5)            # configure channel A at a frequency of 5Hz\ntim_ch.irq(handler=lambda t:led.toggle(), trigger=Timer.TIMEOUT)        # toggle a LED on every cycle of the timer\n```\n\n----------------------------------------\n\nTITLE: UART-USB Passthrough Function in MicroPython\nDESCRIPTION: This function `pass_through` creates a bridge between a USB VCP and a UART interface. It uses the `select` module to monitor both interfaces for incoming data and then relays the data from one interface to the other. The function takes the USB VCP object and the UART object as input parameters.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/pass_through.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pyb\nimport select\n\ndef pass_through(usb, uart):\n    usb.setinterrupt(-1)\n    while True:\n        select.select([usb, uart], [], [])\n        if usb.any():\n            uart.write(usb.read(256))\n        if uart.any():\n            usb.write(uart.read(256))\n\npass_through(pyb.USB_VCP(), pyb.UART(1, 9600, timeout=0))\n```\n\n----------------------------------------\n\nTITLE: Initializing MicroPython Timer with Period\nDESCRIPTION: Example of initializing a Timer object with a specific period in milliseconds. This snippet sets up a timer to run periodically every 100ms.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.Timer.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntim.init(period=100, callback=mycallback)\n```\n\n----------------------------------------\n\nTITLE: Sending Messages on CAN Bus in Python\nDESCRIPTION: This method sends a message on the CAN bus, supporting both data and remote transmission request messages. It provides options for message ID, timeout, frame type, and various CAN FD specific settings. If the message cannot be handled within the specified timeout, an exception is raised.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.CAN.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n\n.. method:: CAN.send(data, id, *, timeout=0, rtr=False, extframe=False, fdf=False, brs=False)\n\n   Send a message on the bus:\n\n     - *data* is the data to send (an integer to send, or a buffer object).\n     - *id* is the id of the message to be sent.\n     - *timeout* is the timeout in milliseconds to wait for the send.\n     - *rtr* is a boolean that specifies if the message shall be sent as\n       a remote transmission request.  If *rtr* is True then only the length\n       of *data* is used to fill in the DLC slot of the frame; the actual\n       bytes in *data* are unused.\n     - *extframe* if True the frame will have an extended identifier (29 bits),\n       otherwise a standard identifier (11 bits) is used.\n     - *fdf* for CAN FD controllers, if set to True, the frame will have an FD\n       frame format, which supports data payloads up to 64 bytes.\n     - *brs* for CAN FD controllers, if set to True, the bitrate switching mode\n       is enabled, in which the data phase is transmitted at a different bitrate.\n       See :meth:`CAN.init` for the data bit timing configuration parameters.\n\n     If timeout is 0 the message is placed in a buffer in one of three hardware\n     buffers and the method returns immediately. If all three buffers are in use\n     an exception is thrown. If timeout is not 0, the method waits until the\n     message is transmitted. If the message can't be transmitted within the\n     specified time an exception is thrown.\n\n   Return value: ``None``.\n\n```\n\n----------------------------------------\n\nTITLE: Initializing LAN Network Interface\nDESCRIPTION: Basic example of initializing and using the LAN network interface to get IP configuration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.LAN.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport network\nnic = network.LAN(0)\nprint(nic.ipconfig(\"addr4\"))\n\n# now use socket as usual\n...\n```\n\n----------------------------------------\n\nTITLE: I2S Blocking Operations in MicroPython\nDESCRIPTION: Shows blocking mode operations for I2S audio input and output. Write operation blocks until buffer is emptied, and read operation blocks until buffer is filled.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.I2S.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnum_written = audio_out.write(buf) # blocks until buf emptied\n\nnum_read = audio_in.readinto(buf) # blocks until buf filled\n```\n\n----------------------------------------\n\nTITLE: GPIO Pin Initialization and Control on WiPy\nDESCRIPTION: This snippet shows how to initialize and control GPIO pins on the WiPy board using the 'machine.Pin' class. It demonstrates initializing a pin as output or input with a pull-up resistor and shows how to toggle output pin states.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Pin\n\n# initialize GP2 in gpio mode (alt=0) and make it an output\np_out = Pin('GP2', mode=Pin.OUT)\np_out.value(1)\np_out.value(0)\np_out.toggle()\np_out(True)\n\n# make GP1 an input with the pull-up enabled\np_in = Pin('GP1', mode=Pin.IN, pull=Pin.PULL_UP)\np_in() # get value, 0 or 1\n```\n\n----------------------------------------\n\nTITLE: Accelerometer-Based Mouse Control in main.py\nDESCRIPTION: This main.py script uses the pyboard's accelerometer to control mouse movement. The mouse movements correspond to the physical tilt of the board, and the USR switch stops the motion.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/usb_mouse.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport pyb\n\nswitch = pyb.Switch()\naccel = pyb.Accel()\nhid = pyb.USB_HID()\n\nwhile not switch():\n    hid.send((0, accel.x(), accel.y(), 0))\n    pyb.delay(20)\n```\n\n----------------------------------------\n\nTITLE: Evaluating a Python expression\nDESCRIPTION: Command to evaluate a Python expression on the connected device and print the result.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote eval <string>\n```\n\n----------------------------------------\n\nTITLE: Simultaneous Send and Receive via SPI Bus\nDESCRIPTION: This method facilitates simultaneous sending and receiving of data over SPI. The user can send data, specify a buffer for receiving, or omit the receiving buffer to create a new one, with a timeout parameter for operation completion.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.SPI.rst#2025-04-21_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n.. method:: SPI.send_recv(send, recv=None, *, timeout=5000)\n\n   Send and receive data on the bus at the same time:\n\n     - ``send`` is the data to send (an integer to send, or a buffer object).\n     - ``recv`` is a mutable buffer which will be filled with received bytes.\n       It can be the same as ``send``, or omitted.  If omitted, a new buffer will\n       be created.\n     - ``timeout`` is the timeout in milliseconds to wait for the receive.\n\n   Return value: the buffer with the received bytes.\n```\n\n----------------------------------------\n\nTITLE: Using PWM in MicroPython for ESP8266\nDESCRIPTION: Shows how to use the machine.PWM class to control Pulse Width Modulation on an ESP8266 board. Demonstrates creating PWM objects, setting frequency and duty cycle, and deinitializing PWM.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, PWM\n\npwm0 = PWM(Pin(0))      # create PWM object from a pin\npwm0.freq()             # get current frequency\npwm0.freq(1000)         # set frequency\npwm0.duty()             # get current duty cycle\npwm0.duty(200)          # set duty cycle\npwm0.deinit()           # turn off PWM on the pin\n\npwm2 = PWM(Pin(2), freq=500, duty=512) # create and configure in one go\n```\n\n----------------------------------------\n\nTITLE: Interacting with 'machine' Module in MicroPython\nDESCRIPTION: This snippet demonstrates how to use various functions of the 'machine' module for general control of the WiPy board, including getting the CPU frequency, unique ID, and using different sleep modes to manage power consumption.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport machine\n\nhelp(machine) # display all members from the machine module\nmachine.freq() # get the CPU frequency\nmachine.unique_id() # return the 6-byte unique id of the board (the WiPy's MAC address)\n\nmachine.idle()        # average current decreases to (~12mA), any interrupts wake it up\nmachine.lightsleep()  # everything except for WLAN is powered down (~950uA avg. current)\n                      # wakes from Pin, RTC or WLAN\nmachine.deepsleep()   # deepest sleep mode, MCU starts from reset. Wakes from Pin and RTC.\n```\n\n----------------------------------------\n\nTITLE: Setting RGBW/RGBY NeoPixel Colors\nDESCRIPTION: Examples of setting individual pixel colors using 4-tuple values for RGBW/RGBY pixels\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/neopixel.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnp[0] = (255, 0, 0, 128) # Orange in an RGBY Setup\nnp[1] = (0, 255, 0, 128) # Yellow-green in an RGBY Setup\nnp[2] = (0, 0, 255, 128) # Green-blue in an RGBY Setup\n```\n\n----------------------------------------\n\nTITLE: Using OneWire Driver in MicroPython\nDESCRIPTION: Shows how to use the OneWire driver in MicroPython. It covers basic operations like scanning for devices, resetting the bus, and reading/writing data. Also includes an example for DS18x20 temperature sensors.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\nimport onewire\n\now = onewire.OneWire(Pin(12)) # create a OneWire bus on GPIO12\now.scan()               # return a list of devices on the bus\now.reset()              # reset the bus\now.readbyte()           # read a byte\now.writebyte(0x12)      # write a byte on the bus\now.write('123')         # write bytes on the bus\now.select_rom(b'12345678') # select a specific device by its ROM code\n\nimport time, ds18x20\nds = ds18x20.DS18X20(ow)\nroms = ds.scan()\nds.convert_temp()\ntime.sleep_ms(750)\nfor rom in roms:\n    print(ds.read_temp(rom))\n```\n\n----------------------------------------\n\nTITLE: Using the Debounced Pin Input Function - MicroPython\nDESCRIPTION: This snippet demonstrates how to initialize a pin as an input with a pull-down resistor and utilize the 'wait_pin_change' function in an infinite loop to toggle an LED each time the pin's state changes significantly. This also relies on the 'pyb' library for pin management.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/debounce.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport pyb\n\npin_x1 = pyb.Pin('X1', pyb.Pin.IN, pyb.Pin.PULL_DOWN)\nwhile True:\n    wait_pin_change(pin_x1)\n    pyb.LED(4).toggle()\n```\n\n----------------------------------------\n\nTITLE: Creating SSL Sockets in MicroPython on WiPy\nDESCRIPTION: Shows the process of creating SSL sockets on WiPy, including socket initialization and wrapping with ssl.wrap_socket. Also demonstrates connecting to Blynk servers using certificates.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport socket\nimport ssl\ns = socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_SEC)\nss = ssl.wrap_socket(s)\n```\n\nLANGUAGE: python\nCODE:\n```\nimport socket\nimport ssl\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_SEC)\nss = ssl.wrap_socket(s, cert_reqs=ssl.CERT_REQUIRED, ca_certs='/flash/cert/ca.pem')\nss.connect(socket.getaddrinfo('cloud.blynk.cc', 8441)[0][-1])\n```\n\n----------------------------------------\n\nTITLE: Basic File Operations on a Mounted Filesystem in MicroPython\nDESCRIPTION: Demonstrates basic file operations on a mounted filesystem. This example writes to a file and then reads its contents, showing how Python's standard file I/O can be used with custom filesystems.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nwith open('/ramdisk/hello.txt', 'w') as f:\n    f.write('Hello world')\nprint(open('/ramdisk/hello.txt').read())\n```\n\n----------------------------------------\n\nTITLE: Formatting ESP8266/ESP32 Flash with Littlefs v2 in MicroPython\nDESCRIPTION: Code for formatting the entire flash memory of ESP8266/ESP32 devices with littlefs v2. This filesystem type is more resistant to corruption from power failure than FAT.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# ESP8266 and ESP32\nimport vfs\nvfs.umount('/')\nvfs.VfsLfs2.mkfs(bdev)\nvfs.mount(bdev, '/')\n```\n\n----------------------------------------\n\nTITLE: Installing Packages with mpremote in MicroPython\nDESCRIPTION: Examples of using the mpremote tool from a host PC to install packages to a connected MicroPython device, including version specification and various URL schemes.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote mip install pkgname\n$ mpremote mip install pkgname@x.y\n$ mpremote mip install http://example.com/x/y/foo.py\n$ mpremote mip install github:org/repo\n$ mpremote mip install github:org/repo@branch-or-tag\n$ mpremote mip install gitlab:org/repo\n$ mpremote mip install gitlab:org/repo@branch-or-tag\n```\n\n----------------------------------------\n\nTITLE: Using UART (Serial Bus) with Machine Module\nDESCRIPTION: This snippet demonstrates how to use the UART (serial bus) with the machine.UART class. If the id, rx or tx pins are not specified, the default values are used. If the baudrate is changed and the UART id is omitted, it must be set using the baudrate keyword.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Use UART 3 on a ItsyBitsy M4 board\nfrom machine import UART\n\nuart3 = UART(3, tx=Pin('D1'), rx=Pin('D0'), baudrate=115200)\nuart3.write('hello')  # write 5 bytes\nuart3.read(5)         # read up to 5 bytes\n\nuart = UART()         # Use the default values for id, rx and tx.\nuart = UART(baudrate=9600) # Use the default UART and set the baudrate\n```\n\n----------------------------------------\n\nTITLE: Initializing SSD1306 OLED with Software SPI Interface in MicroPython\nDESCRIPTION: Sets up an SSD1306 OLED display using Software SPI interface. Configures a SoftSPI object with specific baudrate, polarity, phase, and pins, then initializes a 128x64 display.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/ssd1306.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SoftSPI\nimport ssd1306\n\nspi = SoftSPI(baudrate=500000, polarity=1, phase=0, sck=Pin(14), mosi=Pin(13), miso=Pin(12))\n\ndc = Pin(4)   # data/command\nrst = Pin(5)  # reset\ncs = Pin(15)  # chip select, some modules do not have a pin for this\n\ndisplay = ssd1306.SSD1306_SPI(128, 64, spi, dc, rst, cs)\n```\n\n----------------------------------------\n\nTITLE: Initializing Timer for LED Control in MicroPython\nDESCRIPTION: This code initializes a timer object to toggle an LED at a specified frequency using a callback function. The timer is set to trigger at a frequency of 2Hz, and a lambda function is used to toggle the LED state.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntim = pyb.Timer(4)              # create a timer object using timer 4\n    tim.init(freq=2)                # trigger at 2Hz\n    tim.callback(lambda t:pyb.LED(1).toggle())\n```\n\n----------------------------------------\n\nTITLE: Connecting to WiFi Network in MicroPython\nDESCRIPTION: Connects the ESP8266 to a specified WiFi network using SSID and password. This establishes the network connection for further operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_basics.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> sta_if.connect('<your SSID>', '<your key>')\n```\n\n----------------------------------------\n\nTITLE: Flash Memory Operations in MicroPython\nDESCRIPTION: Functions for reading, writing, and erasing flash memory. These operations allow direct manipulation of the flash storage.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nflash_read(byte_offset, length_or_buffer)\nflash_write(byte_offset, bytes)\nflash_erase(sector_no)\n```\n\n----------------------------------------\n\nTITLE: Writing LED Blinking Program to main.py in MicroPython\nDESCRIPTION: This code snippet demonstrates how to write an LED blinking program to the `main.py` file in the internal flash file system. It uses the `os` module to get the current working directory and the `open()` function to open, write to, and read from the `main.py` file. The program blinks an LED connected to pin P106 every second.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/tutorial/program_in_flash.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nos.getcwd()\nf = open('main.py', 'rw+')\nprint(f.read())\nf.write('import time\\n')\nf.write('from machine import Pin\\n')\nf.write('led1 = Pin(Pin.cpu.P106)\\n')\nf.write('while True:\\n')\nf.write('    led1.on()\\n')\nf.write('    time.sleep(1)\\n')\nf.write('    led1.off()\\n')\nf.write('    time.sleep(1)\\n')\nf.close()\nf = open('main.py', 'r')\nprint(f.read())\nf.close()\n```\n\n----------------------------------------\n\nTITLE: HTTP GET Request Function in MicroPython\nDESCRIPTION: This function demonstrates how to perform an HTTP GET request in MicroPython. It connects to a server, sends a GET request, and prints the received data.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_tcp.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef http_get(url):\n    import socket\n    _, _, host, path = url.split('/', 3)\n    addr = socket.getaddrinfo(host, 80)[0][-1]\n    s = socket.socket()\n    s.connect(addr)\n    s.send(bytes('GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % (path, host), 'utf8'))\n    while True:\n        data = s.recv(100)\n        if data:\n            print(str(data, 'utf8'), end='')\n        else:\n            break\n    s.close()\n```\n\n----------------------------------------\n\nTITLE: Compiling MicroPython Cross-Compiler Locally in Bash\nDESCRIPTION: This command compiles the MicroPython cross-compiler (mpy-cross) locally. It should be run from the root directory of the MicroPython repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ make -C mpy-cross\n```\n\n----------------------------------------\n\nTITLE: Initializing Timer and PWM Channel in MicroPython\nDESCRIPTION: This code initializes a Timer object for timer 5 with a frequency of 100 Hz and creates a TimerChannel object for channel 1, connecting it to pin X1 for PWM control. It imports the `Timer` class from the `pyb` module and the `sleep` function from the `time` module, both necessary for PWM and timing operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/fading_led.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import Timer\nfrom time import sleep\n\n# timer 5 will be created with a frequency of 100 Hz\ntim = pyb.Timer(5, freq=100)\ntchannel = tim.channel(1, Timer.PWM, pin=pyb.Pin.board.X1, pulse_width=0)\n```\n\n----------------------------------------\n\nTITLE: Erasing ESP32 Flash Memory Using Esptool\nDESCRIPTION: Command to completely erase the flash memory of an ESP32 board using the Espressif esptool utility. PORTNAME should be replaced with the actual serial port identifier of the connected board.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/tutorial/reset.rst#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nesptool.py -p PORTNAME erase_flash\n```\n\n----------------------------------------\n\nTITLE: Using Pins and GPIO - MicroPython\nDESCRIPTION: This code snippet illustrates how to interact with GPIO pins using MicroPython. It showcases creating input and output pins, configuring pin modes, and handling pin values with interrupts.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/quickref.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Pin\n\npin = Pin((\"gpiob\", 21), Pin.IN)    # create input pin on GPIO port B\nprint(pin)                          # print pin port and number\n\npin.init(Pin.OUT, Pin.PULL_UP, value=1)     # reinitialize pin\n\npin.value(1)                        # set pin to high\npin.value(0)                        # set pin to low\n\npin.on()                            # set pin to high\npin.off()                           # set pin to low\n\npin = Pin((\"gpiob\", 21), Pin.IN)              # create input pin on GPIO port B\n\npin = Pin((\"gpiob\", 21), Pin.OUT, value=1)    # set pin high on creation\n\npin = Pin((\"gpiob\", 21), Pin.IN, Pin.PULL_UP) # enable internal pull-up resistor\n\nswitch = Pin((\"gpioc\", 6), Pin.IN)            # create input pin for a switch\nswitch.irq(lambda t: print(\"SW2 changed\"))    # enable an interrupt when switch state is changed\n```\n\n----------------------------------------\n\nTITLE: Initializing WiFi Interfaces in MicroPython\nDESCRIPTION: Creates WLAN objects for station and access point interfaces using the network module. This is the first step in configuring WiFi on an ESP8266 device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_basics.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import network\n>>> sta_if = network.WLAN(network.WLAN.IF_STA)\n>>> ap_if = network.WLAN(network.WLAN.IF_AP)\n```\n\n----------------------------------------\n\nTITLE: Recording Configuration with Sparkfun WM8960 Breakout Board and Teensy\nDESCRIPTION: Configures the WM8960 for recording with a Sparkfun breakout board and Teensy microcontroller. Uses the PLL as system clock source with 24MHz MCLK frequency. Sets ADC sync for the connected WS pins and configures inputs with left channel using MIC1 and right channel closed.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/wm8960.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, I2C\nimport wm8960\ni2c = I2C(0)\nwm=wm8960.WM8960(i2c, sample_rate=16_000,\n    adc_sync=wm8960.SYNC_ADC,\n    sysclk_source=wm8960.SYSCLK_PLL,\n    mclk_freq=24_000_000,\n    left_input=wm8960.INPUT_MIC1,\n    right_input=wm8960.INPUT_CLOSED)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a FrameBuffer in MicroPython\nDESCRIPTION: This snippet demonstrates how to create a FrameBuffer object, fill it with a color, draw text, and add a horizontal line. It uses the RGB565 color format and creates a 100x10 pixel buffer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/framebuf.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport framebuf\n\n# FrameBuffer needs 2 bytes for every RGB565 pixel\nfbuf = framebuf.FrameBuffer(bytearray(100 * 10 * 2), 100, 10, framebuf.RGB565)\n\nfbuf.fill(0)\nfbuf.text('MicroPython!', 0, 0, 0xffff)\nfbuf.hline(0, 9, 96, 0xffff)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Controlling Servo Motors in MicroPython\nDESCRIPTION: Example showing how to create and control two servo objects using the pyb.Servo class. Demonstrates basic angle control and synchronized movement with timing parameters.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Servo.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pyb\n\ns1 = pyb.Servo(1)   # create a servo object on position X1\ns2 = pyb.Servo(2)   # create a servo object on position X2\n\ns1.angle(45)        # move servo 1 to 45 degrees\ns2.angle(0)         # move servo 2 to 0 degrees\n\n# move servo1 and servo2 synchronously, taking 1500ms\ns1.angle(-60, 1500)\ns2.angle(30, 1500)\n```\n\n----------------------------------------\n\nTITLE: Reading ADC Values on WiPy with MicroPython\nDESCRIPTION: This snippet shows how to perform Analog-to-Digital Conversion (ADC) on the WiPy board using the 'machine.ADCWiPy' class. It initializes an ADC channel for a specified pin and reads digital values converted from analog signals.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import ADC\n\nadc = ADC()\napin = adc.channel(pin='GP3')\napin() # read value, 0-4095\n```\n\n----------------------------------------\n\nTITLE: Time Measurement Example - Milliseconds\nDESCRIPTION: Example showing how to measure elapsed time in milliseconds using pyb.millis() and pyb.elapsed_millis() functions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nstart = pyb.millis()\nwhile pyb.elapsed_millis(start) < 1000:\n    # Perform some operation\n```\n\n----------------------------------------\n\nTITLE: Initializing and Configuring W5500 Network Interface in MicroPython\nDESCRIPTION: This snippet shows how to import the network module, create a WIZNET5K network interface object, activate it, and configure IP settings using DHCP. It also demonstrates how to check the connection status and retrieve the network configuration.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/boards/W5500_EVB_PICO/readme.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import network\n>>> nic = network.WIZNET5K()\n>>> nic.active(True)\n>>> nic.ifconfig()\n('0.0.0.0', '0.0.0.0', '0.0.0.0', '0.0.0.0')\n>>> nic.ifconfig(\"dhcp\")\n('192.168.0.10', '255.255.255.0', '192.168.0.1', '192.168.0.1')\n>>> nic.isconnected()\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating Persistent Timer Interrupt in MicroPython REPL\nDESCRIPTION: This snippet demonstrates how interrupt handlers can continue to run after a program terminates in the REPL. It creates a timer that prints dots continuously, persisting even after the function scope ends.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/isr_rules.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef bar():\n    foo = pyb.Timer(2, freq=4, callback=lambda t: print('.', end=''))\n\nbar()\n```\n\n----------------------------------------\n\nTITLE: Installing from GitHub and GitLab with mip in MicroPython\nDESCRIPTION: Examples of using the github: and gitlab: URL schemes to install packages from GitHub and GitLab repositories, with optional branch/tag specification.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> mip.install(\"github:org/repo/path/foo.py\")  # Uses default branch\n>>> mip.install(\"github:org/repo/path/foo.py\", version=\"branch-or-tag\")  # Optionally specify the branch or tag\n>>> mip.install(\"gitlab:org/repo/path/foo.py\")  # Uses default branch\n>>> mip.install(\"gitlab:org/repo/path/foo.py\", version=\"branch-or-tag\")  # Optionally specify the branch or tag\n```\n\n----------------------------------------\n\nTITLE: Basic ADC Usage in MicroPython\nDESCRIPTION: Demonstrates how to create an ADC object and read analog values in both raw format (16-bit range) and microvolts.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.ADC.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import ADC\n\nadc = ADC(pin)        # create an ADC object acting on a pin\nval = adc.read_u16()  # read a raw analog value in the range 0-65535\nval = adc.read_uv()   # read an analog value in microvolts\n```\n\n----------------------------------------\n\nTITLE: FatFS with SD card using DiskAccess in MicroPython\nDESCRIPTION: This code demonstrates how to use the FatFS filesystem with an SD card on the mimxrt1050_evk board using the `zephyr.DiskAccess` class. It initializes the SD card as a block device, creates a FAT filesystem on it, mounts it to a directory, and then writes and reads a file.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/tutorial/storage.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport vfs\nfrom zephyr import DiskAccess\nbdev = zephyr.DiskAccess('SDHC')        # create block device object using DiskAccess\nvfs.VfsFat.mkfs(bdev)                   # create FAT filesystem object using the disk storage block\nvfs.mount(bdev, '/sd')                  # mount the filesystem at the SD card subdirectory\nwith open('/sd/hello.txt','w') as f:    # open a new file in the directory\n    f.write('Hello world')              # write to the file\nprint(open('/sd/hello.txt').read())     # print contents of the file\n```\n\n----------------------------------------\n\nTITLE: NeoPixel LED Driver Configuration\nDESCRIPTION: Example of using the NeoPixel driver to control RGB LED strips connected to ESP8266.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\nfrom neopixel import NeoPixel\n\npin = Pin(0, Pin.OUT)   # set GPIO0 to output to drive NeoPixels\nnp = NeoPixel(pin, 8)   # create NeoPixel driver on GPIO0 for 8 pixels\nnp[0] = (255, 255, 255) # set the first pixel to white\nnp.write()              # write data to all pixels\nr, g, b = np[0]         # get first pixel colour\n```\n\n----------------------------------------\n\nTITLE: Flashing MicroPython Firmware with Specified Port\nDESCRIPTION: This command flashes the MicroPython firmware to an ESP32 board using esptool.py with a specified serial port. It's useful when auto-detection fails. Replace PORTNAME and ESP32_BOARD_NAME-DATE-VERSION.bin with actual values.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/boards/deploy.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py --port PORTNAME --baud 460800 write_flash {deploy_options[flash_offset]} ESP32_BOARD_NAME-DATE-VERSION.bin\n```\n\n----------------------------------------\n\nTITLE: Fading LED with PWM in MicroPython\nDESCRIPTION: This code creates a fading effect on an LED by gradually increasing the pulse width of the PWM signal. The pulse width is incremented in a loop, and when it reaches a maximum value, it resets to a minimum value. The sleep function introduces a delay that determines the fading speed.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/fading_led.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# maximum and minimum pulse-width, which corresponds to maximum\n# and minimum brightness\nmax_width = 200000\nmin_width = 20000\n\n# how much to change the pulse-width by each step\nwstep = 1500\ncur_width = min_width\n\nwhile True:\n  tchannel.pulse_width(cur_width)\n\n  # this determines how often we change the pulse-width. It is\n  # analogous to frames-per-second\n  sleep(0.01)\n\n  cur_width += wstep\n\n  if cur_width > max_width:\n    cur_width = min_width\n```\n\n----------------------------------------\n\nTITLE: Using Software I2C Bus in MicroPython on ESP32\nDESCRIPTION: Example demonstrating how to initialize and use a Software I2C bus with MicroPython on ESP32. This implementation uses bit-banging to work on all output-capable pins.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SoftI2C\n\ni2c = SoftI2C(scl=Pin(5), sda=Pin(4), freq=100000)\n\ni2c.scan()              # scan for devices\n\ni2c.readfrom(0x3a, 4)   # read 4 bytes from device with address 0x3a\ni2c.writeto(0x3a, '12') # write '12' to device with address 0x3a\n\nbuf = bytearray(10)     # create a buffer with 10 bytes\ni2c.writeto(0x3a, buf)  # write the given buffer to the peripheral\n```\n\n----------------------------------------\n\nTITLE: Using Real-Time Clock (RTC) in MicroPython\nDESCRIPTION: Shows how to use the Real-Time Clock (RTC) in MicroPython. It demonstrates setting and getting the date and time.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import RTC\n\nrtc = RTC()\nrtc.datetime((2017, 8, 23, 0, 1, 12, 48, 0)) # set a specific date and\n                                               # time, eg. 2017/8/23 1:12:48\n                                               # the day-of-week value is ignored\nrtc.datetime() # get date and time\n```\n\n----------------------------------------\n\nTITLE: Checking WiFi Connection Status in MicroPython\nDESCRIPTION: Verifies if the WiFi connection has been established. This can be used to confirm successful connection to the network.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_basics.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> sta_if.isconnected()\n```\n\n----------------------------------------\n\nTITLE: Initializing I2S Audio Interface in MicroPython\nDESCRIPTION: Demonstrates how to create and initialize I2S objects for both audio output and input. Shows pin configuration for ESP32 and PyBoard platforms with different audio formats and sampling rates.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.I2S.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2S\nfrom machine import Pin\n\n# ESP32\nsck_pin = Pin(14)   # Serial clock output\nws_pin = Pin(13)    # Word clock output\nsd_pin = Pin(12)    # Serial data output\n\nor\n\n# PyBoards\nsck_pin = Pin(\"Y6\")   # Serial clock output\nws_pin = Pin(\"Y5\")    # Word clock output\nsd_pin = Pin(\"Y8\")    # Serial data output\n\naudio_out = I2S(2,\n                sck=sck_pin, ws=ws_pin, sd=sd_pin,\n                mode=I2S.TX,\n                bits=16,\n                format=I2S.MONO,\n                rate=44100,\n                ibuf=20000)\n\naudio_in = I2S(2,\n               sck=sck_pin, ws=ws_pin, sd=sd_pin,\n               mode=I2S.RX,\n               bits=32,\n               format=I2S.STEREO,\n               rate=22050,\n               ibuf=20000)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Controlling NeoPixel LED Strip in MicroPython\nDESCRIPTION: Example demonstrating how to initialize a 32-LED NeoPixel strip connected to pin X8 and create a red gradient pattern. Shows basic setup, pixel manipulation, and updating the LED strip.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/neopixel.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport neopixel\n\n# 32 LED strip connected to X8.\np = machine.Pin.board.X8\nn = neopixel.NeoPixel(p, 32)\n\n# Draw a red gradient.\nfor i in range(32):\n    n[i] = (i * 8, 0, 0)\n\n# Update the strip.\nn.write()\n```\n\n----------------------------------------\n\nTITLE: Using NeoPixel and APA106 LED Drivers in MicroPython\nDESCRIPTION: Demonstrates how to use NeoPixel and APA106 LED drivers in MicroPython. It covers initializing the drivers, setting LED colors, and reading color values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\nfrom neopixel import NeoPixel\n\npin = Pin(0, Pin.OUT)   # set GPIO0 to output to drive NeoPixels\nnp = NeoPixel(pin, 8)   # create NeoPixel driver on GPIO0 for 8 pixels\nnp[0] = (255, 255, 255) # set the first pixel to white\nnp.write()              # write data to all pixels\nr, g, b = np[0]         # get first pixel colour\n\n\nfrom apa106 import APA106\nap = APA106(pin, 8)\nr, g, b = ap[0]\n```\n\n----------------------------------------\n\nTITLE: Using UART in MicroPython for ESP8266\nDESCRIPTION: Shows how to use the machine.UART class to communicate via the serial bus on an ESP8266 board. Demonstrates creating a UART object, writing data, and reading data.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import UART\nuart = UART(0, baudrate=9600)\nuart.write('hello')\nuart.read(5) # read up to 5 bytes\n```\n\n----------------------------------------\n\nTITLE: Automatic WiFi Connection Function in MicroPython\nDESCRIPTION: Defines a function to automatically connect to a WiFi network. This can be used in boot.py for automatic connection on device startup. It activates the station interface, connects to the specified network, and waits for the connection to be established.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_basics.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef do_connect():\n    import network\n    sta_if = network.WLAN(network.WLAN.IF_STA)\n    if not sta_if.isconnected():\n        print('connecting to network...')\n        sta_if.active(True)\n        sta_if.connect('<ssid>', '<key>')\n        while not sta_if.isconnected():\n            pass\n    print('network config:', sta_if.ipconfig('addr4'))\n```\n\n----------------------------------------\n\nTITLE: Compiling ESP8266 Firmware with Docker in Bash\nDESCRIPTION: This command compiles the ESP8266 firmware using Docker. It should be run from the ports/esp8266 directory of the MicroPython repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ docker run --rm -v $HOME:$HOME -u $UID -w $PWD larsks/esp-open-sdk make -j BOARD=ESP8266_GENERIC\n```\n\n----------------------------------------\n\nTITLE: Configuring Ethernet Connection in MicroPython\nDESCRIPTION: Example demonstrating how to initialize and activate an Ethernet connection on MIMXRT boards. Uses the network module to create a LAN interface that can obtain an IP address via DHCP or be configured manually.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nimport network\n\nlan = network.LAN(0)\nlan.active(True)\n```\n\n----------------------------------------\n\nTITLE: Basic mpremote usage\nDESCRIPTION: The simplest way to use mpremote without arguments, which automatically connects to the first available USB serial device and provides an interactive terminal.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote\n```\n\n----------------------------------------\n\nTITLE: Using Timers on pyboard in MicroPython\nDESCRIPTION: Configuring hardware timers to create periodic events or measure time. The example initializes a timer with 1kHz frequency, shows how to read the counter value, change the frequency, and set up a callback to toggle an LED when the timer triggers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import Timer\n\ntim = Timer(1, freq=1000)\ntim.counter() # get counter value\ntim.freq(0.5) # 0.5 Hz\ntim.callback(lambda t: pyb.LED(1).toggle())\n```\n\n----------------------------------------\n\nTITLE: Advanced I2C Controller Operations in MicroPython\nDESCRIPTION: Demonstrates advanced I2C operations using the controller mode in MicroPython, such as checking device readiness, scanning for peripherals, and performing memory operations. The snippet relies on the pyb library and includes methods for reading and writing to device memory, along with scan capabilities.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.I2C.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ni2c.is_ready(0x42)           # check if peripheral 0x42 is ready\ni2c.scan()                   # scan for peripherals on the bus\ni2c.mem_read(3, 0x42, 2)     # read 3 bytes from memory of peripheral 0x42\ni2c.mem_write('abc', 0x42, 2, timeout=1000) # write 'abc' (3 bytes) to memory of peripheral 0x42\n```\n\n----------------------------------------\n\nTITLE: Initializing WM8960 in Master Mode with Custom Audio Format\nDESCRIPTION: Configures the WM8960 audio codec in primary (master) mode with a 44.1kHz sample rate and 16-bit audio depth. This setup allows the WM8960 to control the audio clock instead of being controlled by another device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/wm8960.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, I2C\nimport wm8960\n\ni2c = I2C(0)\nwm=wm8960.WM8960(i2c, 44100, primary=True, bits=16)\n```\n\n----------------------------------------\n\nTITLE: Reading DHT Sensor Values in MicroPython\nDESCRIPTION: Commands for measuring and reading temperature (in Celsius) and humidity (in percentage) values from a DHT sensor. Must call measure() before reading values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/dht.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nd.measure()\nd.temperature()\nd.humidity()\n```\n\n----------------------------------------\n\nTITLE: Registering Callback for CAN Reception in Python\nDESCRIPTION: The rxcallback method registers a user-defined function to be triggered when a message arrives in an empty FIFO. The function takes parameters for the Bus object and the reason for invocation, which can be a new message, FIFO full, or message loss due to full FIFO.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.CAN.rst#2025-04-21_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n\n.. method:: CAN.rxcallback(fifo, fun)\n\n   Register a function to be called when a message is accepted into a empty fifo:\n\n   - *fifo* is the receiving fifo.\n   - *fun* is the function to be called when the fifo becomes non empty.\n\n   The callback function takes two arguments the first is the can object it self the second is\n   a integer that indicates the reason for the callback.\n\n   +--------+------------------------------------------------+\n   | Reason |                                                |\n   +========+================================================+\n   | 0      | A message has been accepted into a empty FIFO. |\n   +--------+------------------------------------------------+\n   | 1      | The FIFO is full                               |\n   +--------+------------------------------------------------+\n   | 2      | A message has been lost due to a full FIFO     |\n   +--------+------------------------------------------------+\n\n   Example use of rxcallback::\n\n     def cb0(bus, reason):\n       print('cb0')\n       if reason == 0:\n           print('pending')\n       if reason == 1:\n           print('full')\n       if reason == 2:\n           print('overflow')\n\n     can = CAN(1, CAN.LOOPBACK)\n     can.rxcallback(0, cb0)\n\n```\n\n----------------------------------------\n\nTITLE: Reading Analog Values with Machine Module\nDESCRIPTION: This snippet shows how to read analog values using the machine.ADC class. The resolution of the ADC is 12 bit with 12 bit accuracy, irrespective of the value returned by read_u16().\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import ADC\n\nadc0 = ADC(Pin('A0'))            # create ADC object on ADC pin, average=16\nadc0.read_u16()                  # read value, 0-65535 across voltage range 0.0v - 3.3v\nadc1 = ADC(Pin('A1'), average=1) # create ADC object on ADC pin, average=1\n```\n\n----------------------------------------\n\nTITLE: Interrupt Handling on GPIO - Python\nDESCRIPTION: This code demonstrates how to set up an interrupt on a GPIO pin. The snippet includes a callback function that triggers on a rising edge event.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Pin\n\ndef pincb(pin):\n    print(pin.id())\n\npin_int = Pin('GP10', mode=Pin.IN, pull=Pin.PULL_DOWN)\npin_int.irq(trigger=Pin.IRQ_RISING, handler=pincb)\n```\n\n----------------------------------------\n\nTITLE: Running a local Python script\nDESCRIPTION: Command to run a Python script from the local filesystem directly in RAM on the device without copying it to the device's filesystem, with an option to run it in the background.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote run <file.py>\n```\n\n----------------------------------------\n\nTITLE: Accessing Sensor Data - MicroPython\nDESCRIPTION: This snippet shows how to create a sensor object for an accelerometer and retrieve measurement data. It highlights methods for obtaining and printing sensor values in different formats.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/quickref.rst#2025-04-21_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nimport zsensor\nfrom zsensor import Sensor\n\naccel = Sensor(\"fxos8700\")    # create sensor object for the accelerometer\n\naccel.measure()               # obtain a measurement reading from the accelerometer\n\n# each of these prints the value taken by measure()\naccel.get_float(zsensor.ACCEL_X)  # print measurement value for accelerometer X-axis sensor channel as float\naccel.get_millis(zsensor.ACCEL_Y) # print measurement value for accelerometer Y-axis sensor channel in millionths\naccel.get_micro(zsensor.ACCEL_Z)  # print measurement value for accelerometer Z-axis sensor channel in thousandths\naccel.get_int(zsensor.ACCEL_X)    # print measurement integer value only for accelerometer X-axis sensor channel\n```\n\n----------------------------------------\n\nTITLE: Random Generator Seeding in MicroPython\nDESCRIPTION: Initializes the random number generator with an integer seed. Can use hardware-generated true random number if supported by the port.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/random.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nseed(n=None, /)\n```\n\n----------------------------------------\n\nTITLE: Formatting ESP8266/ESP32 Flash with FAT Filesystem in MicroPython\nDESCRIPTION: Code snippet for formatting the entire flash memory of ESP8266/ESP32 devices with a FAT filesystem. This process unmounts the current filesystem, formats the block device, and remounts it at the root directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# ESP8266 and ESP32\nimport vfs\nvfs.umount('/')\nvfs.VfsFat.mkfs(bdev)\nvfs.mount(bdev, '/')\n```\n\n----------------------------------------\n\nTITLE: Drawing MicroPython Logo on SSD1306 OLED Display in MicroPython\nDESCRIPTION: Creates a MicroPython logo and displays it with text on the SSD1306 OLED display. Uses fill_rect and vline methods to draw the logo shape, and displays text labels to the right of the logo.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/ssd1306.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndisplay.fill(0)\ndisplay.fill_rect(0, 0, 32, 32, 1)\ndisplay.fill_rect(2, 2, 28, 28, 0)\ndisplay.vline(9, 8, 22, 1)\ndisplay.vline(16, 2, 22, 1)\ndisplay.vline(23, 8, 22, 1)\ndisplay.fill_rect(26, 24, 2, 4, 1)\ndisplay.text('MicroPython', 40, 0, 1)\ndisplay.text('SSD1306', 40, 12, 1)\ndisplay.text('OLED 128x64', 40, 24, 1)\ndisplay.show()\n```\n\n----------------------------------------\n\nTITLE: PIO Example for LED Blinking in MicroPython\nDESCRIPTION: Shows an example of using PIO (Programmable IO) to blink an LED at 1Hz.  It defines a PIO program using `@rp2.asm_pio` and then creates and starts a StateMachine with the defined PIO program, outputting on Pin(25).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\nimport rp2\n\n@rp2.asm_pio(set_init=rp2.PIO.OUT_LOW)\ndef blink_1hz():\n    # Cycles: 1 + 7 + 32 * (30 + 1) = 1000\n    set(pins, 1)\n    set(x, 31)                  [6]\n    label(\"delay_high\")\n    nop()                       [29]\n    jmp(x_dec, \"delay_high\")\n\n    # Cycles: 1 + 7 + 32 * (30 + 1) = 1000\n    set(pins, 0)\n    set(x, 31)                  [6]\n    label(\"delay_low\")\n    nop()                       [29]\n    jmp(x_dec, \"delay_low\")\n\n# Create and start a StateMachine with blink_1hz, outputting on Pin(25)\nsm = rp2.StateMachine(0, blink_1hz, freq=2000, set_base=Pin(25))\nsm.active(1)\n```\n\n----------------------------------------\n\nTITLE: Setting Up GPIO Pins for Interrupts\nDESCRIPTION: Initializes two GPIO pins as inputs for interrupt handling.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pins.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\np0 = Pin(0, Pin.IN)\np2 = Pin(2, Pin.IN)\n```\n\n----------------------------------------\n\nTITLE: Controlling Internal LEDs on pyboard in MicroPython\nDESCRIPTION: Using the LED class to control the onboard LEDs. The pyboard has four LEDs (red, green, yellow, blue) that can be toggled, turned on/off, and for LEDs 3 and 4, their intensity can be adjusted using PWM.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import LED\n\nled = LED(1) # 1=red, 2=green, 3=yellow, 4=blue\nled.toggle()\nled.on()\nled.off()\n\n# LEDs 3 and 4 support PWM intensity (0-255)\nLED(4).intensity()    # get intensity\nLED(4).intensity(128) # set intensity to half\n```\n\n----------------------------------------\n\nTITLE: Using RAM Block Device with Littlefs in MicroPython\nDESCRIPTION: Shows how to create and mount a littlefs filesystem on a RAM block device. This example formats a 25KB RAM disk with littlefs v2 and mounts it at '/ramdisk'.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport vfs\n\nbdev = RAMBlockDev(512, 50)\nvfs.VfsLfs2.mkfs(bdev)\nvfs.mount(bdev, '/ramdisk')\n```\n\n----------------------------------------\n\nTITLE: Random Range Generation in MicroPython\nDESCRIPTION: Returns a random integer from a range with optional start, stop, and step parameters. Available only with MICROPY_PY_RANDOM_EXTRA_FUNCS enabled.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/random.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nrandrange(stop)\nrandrange(start, stop)\nrandrange(start, stop[, step])\n```\n\n----------------------------------------\n\nTITLE: Importing Frozen Modules in MicroPython\nDESCRIPTION: Demonstrates how to import a custom module that has been frozen into the MicroPython firmware. Frozen modules are stored in the firmware flash memory rather than requiring additional RAM.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport mymodule\n```\n\n----------------------------------------\n\nTITLE: Using Time Module for Delay and Timing\nDESCRIPTION: This snippet showcases the usage of the time module for creating delays and measuring time differences.  `time.sleep_us()` delays by busy waiting, during which other tasks are not scheduled.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\ntime.sleep(1)           # sleep for 1 second\ntime.sleep_ms(500)      # sleep for 500 milliseconds\ntime.sleep_us(10)       # sleep for 10 microseconds\nstart = time.ticks_ms() # get millisecond counter\ndelta = time.ticks_diff(time.ticks_ms(), start) # compute time difference\n```\n\n----------------------------------------\n\nTITLE: Controlling GPIO Pins Directly via Registers in Python\nDESCRIPTION: This example demonstrates high-performance GPIO control by directly accessing ESP32 registers. It configures pins 16, 17, 32, and 33 as outputs and shows how to toggle them efficiently, including simultaneous operations on multiple pins.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/tutorial/peripheral_access.rst#2025-04-21_snippet_2\n\nLANGUAGE: python3\nCODE:\n```\nfrom micropython import const\nfrom machine import mem32, Pin\n\nGPIO_OUT_REG = const(0x3FF44004)  # GPIO 0-31 output register\nGPIO_OUT1_REG = const(0x3FF44010)  # GPIO 32-39 output register\n\nGPIO_ENABLE_REG = const(0x3FF44020)  # GPIO 0-31 output enable register\nGPIO_ENABLE1_REG = const(0x3FF4402C)  # GPIO 32-39 output enable register\n\nM16 = 1 << 16  # Pin(16) bit mask\nM17 = 1 << 17  # Pin(17) bit mask\n\nM32 = 1 << (32-32)  # Pin(32) bit mask\nM33 = 1 << (33-32)  # Pin(33) bit mask\n\n# Enable pin output mode like\n# p16 = Pin(16, mode=Pin.OUT)\n# p17 = Pin(17, mode=Pin.OUT)\n# p32 = Pin(32, mode=Pin.OUT)\n# p33 = Pin(33, mode=Pin.OUT)\nmem32[GPIO_ENABLE_REG] = mem32[GPIO_ENABLE_REG] | M16 | M17\nmem32[GPIO_ENABLE1_REG] = mem32[GPIO_ENABLE1_REG] | M32 | M33\n\nprint(hex(mem32[GPIO_OUT_REG]), hex(mem32[GPIO_OUT1_REG]))\n\n# Set outputs to 1 like\n# p16(1)\n# p17(1)\n# p32(1)\n# p33(1)\nmem32[GPIO_OUT_REG] = mem32[GPIO_OUT_REG] | M16 | M17\nmem32[GPIO_OUT1_REG] = mem32[GPIO_OUT1_REG] | M32 | M33\n\nprint(hex(mem32[GPIO_OUT_REG]), hex(mem32[GPIO_OUT1_REG]))\n\n# Set outputs to 0 like\n# p16(0)\n# p17(0)\n# p32(0)\n# p33(0)\nmem32[GPIO_OUT_REG] = mem32[GPIO_OUT_REG] & ~(M16 | M17)\nmem32[GPIO_OUT1_REG] = mem32[GPIO_OUT1_REG] & ~(M32 | M33)\n\nprint(hex(mem32[GPIO_OUT_REG]), hex(mem32[GPIO_OUT1_REG]))\n\nwhile True:\n    # Set outputs to 1\n    mem32[GPIO_OUT_REG] = mem32[GPIO_OUT_REG] | M16 | M17\n    mem32[GPIO_OUT1_REG] = mem32[GPIO_OUT1_REG] | M32 | M33\n\n    # Set outputs to 0\n    mem32[GPIO_OUT_REG] = mem32[GPIO_OUT_REG] & ~(M16 | M17)\n    mem32[GPIO_OUT1_REG] = mem32[GPIO_OUT1_REG] & ~(M32 | M33)\n```\n\n----------------------------------------\n\nTITLE: Basic UART Stream Operations in MicroPython\nDESCRIPTION: Examples of common UART read/write operations using stream methods for reading and writing data\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.UART.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nuart.read(10)       # read 10 characters, returns a bytes object\nuart.read()         # read all available characters\nuart.readline()     # read a line\nuart.readinto(buf)  # read and store into the given buffer\nuart.write('abc')   # write the 3 characters\n```\n\n----------------------------------------\n\nTITLE: NeoPixel Class Constructor Definition in MicroPython\nDESCRIPTION: Constructor signature for the NeoPixel class showing parameters for pin configuration, number of LEDs, bits per pixel, and timing settings. Supports both RGB and RGBW LED configurations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/neopixel.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nNeoPixel(pin, n, *, bpp=3, timing=1)\n```\n\n----------------------------------------\n\nTITLE: Using RMT for Pulse Generation in MicroPython on ESP32\nDESCRIPTION: Example demonstrating how to use the RMT (Remote Control Transceiver) on ESP32 for generating accurate digital pulses with 12.5ns resolution using MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nimport esp32\nfrom machine import Pin\n\nr = esp32.RMT(0, pin=Pin(18), clock_div=8)\nr   # RMT(channel=0, pin=18, source_freq=80000000, clock_div=8)\n# The channel resolution is 100ns (1/(source_freq/clock_div)).\nr.write_pulses((1, 20, 2, 40), 0) # Send 0 for 100ns, 1 for 2000ns, 0 for 200ns, 1 for 4000ns\n```\n\n----------------------------------------\n\nTITLE: Initializing MicroPython Timer with Periodic Callback\nDESCRIPTION: Example of initializing a Timer object with a periodic callback function. This snippet demonstrates setting up a timer to run at 1kHz frequency.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.Timer.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef mycallback(t):\n    pass\n\n# periodic at 1kHz\ntim.init(mode=Timer.PERIODIC, freq=1000, callback=mycallback)\n```\n\n----------------------------------------\n\nTITLE: Using SD Card in MicroPython on ESP32\nDESCRIPTION: Example showing how to initialize, mount, and use an SD card on ESP32 with MicroPython. This allows accessing files on the SD card through the filesystem.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nimport machine, os, vfs\n\n# On original ESP32, slot 2 uses pins sck=18, cs=5, miso=19, mosi=23\nsd = machine.SDCard(slot=2)\nvfs.mount(sd, '/sd') # mount\n\nos.listdir('/sd')    # list directory contents\n\nvfs.umount('/sd')    # eject\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython QEMU Port (Makefile)\nDESCRIPTION: Command to build the MicroPython QEMU port. The default board is mps2-an385 (Cortex-M3), but can be changed using the BOARD argument.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/qemu/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make\n```\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make BOARD=SABRELITE\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using DAC in MicroPython on SAMD21/SAMD51\nDESCRIPTION: This snippet demonstrates how to create DAC objects and write values to the DAC outputs. It shows the usage for both SAMD21 (10-bit) and SAMD51 (12-bit) devices.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import DAC\n\ndac0 = DAC(0)                    # create DAC object on DAC pin A0\ndac0.write(1023)                 # write value, 0-4095 across voltage range 0.0v - 3.3v\ndac1 = DAC(1)                    # create DAC object on DAC pin A1\ndac1.write(2000)                 # write value, 0-4095 across voltage range 0.0v - 3.3v\n```\n\n----------------------------------------\n\nTITLE: Controlling Telnet/FTP Server in MicroPython on WiPy\nDESCRIPTION: Demonstrates how to control the telnet/FTP server on WiPy using the network.Server class, including initialization, deinitialization, and configuration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport network\nserver = network.Server()\nserver.deinit() # disable the server\n# enable the server again with new settings\nserver.init(login=('user', 'password'), timeout=600)\n```\n\n----------------------------------------\n\nTITLE: Using CAN Bus on pyboard in MicroPython\nDESCRIPTION: Configuring and using the Controller Area Network (CAN) bus. The example sets up CAN 1 in loopback mode, configures message filtering, and demonstrates sending and receiving messages with specific identifiers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import CAN\n\ncan = CAN(1, CAN.LOOPBACK)\ncan.setfilter(0, CAN.LIST16, 0, (123, 124, 125, 126))\ncan.send('message!', 123)   # send a message with id 123\ncan.recv(0)                 # receive message on FIFO 0\n```\n\n----------------------------------------\n\nTITLE: Configuring GPIO Output Pin\nDESCRIPTION: Creates a GPIO pin configured as output for controlling external devices.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pins.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npin = machine.Pin(0, machine.Pin.OUT)\n```\n\n----------------------------------------\n\nTITLE: Using Virtual Timers in MicroPython for i.MXRT\nDESCRIPTION: Example of creating and configuring virtual timers on i.MXRT, demonstrating both one-shot and periodic timer modes with callback functions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Timer\n\ntim0 = Timer(-1)\ntim0.init(period=5000, mode=Timer.ONE_SHOT, callback=lambda t:print(0))\n\ntim1 = Timer(-1)\ntim1.init(period=2000, mode=Timer.PERIODIC, callback=lambda t:print(1))\n```\n\n----------------------------------------\n\nTITLE: Creating Bouncing Dot Animation on LCD in MicroPython\nDESCRIPTION: Implements a bouncing dot animation using the LCD's double buffer for setting/getting pixels. The dot moves and bounces off the edges of the screen.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.LCD.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx = y = 0\ndx = dy = 1\nwhile True:\n    # update the dot's position\n    x += dx\n    y += dy\n\n    # make the dot bounce of the edges of the screen\n    if x <= 0 or x >= 127: dx = -dx\n    if y <= 0 or y >= 31: dy = -dy\n\n    lcd.fill(0)                 # clear the buffer\n    lcd.pixel(x, y, 1)          # draw the dot\n    lcd.show()                  # show the buffer\n    pyb.delay(50)               # pause for 50ms\n```\n\n----------------------------------------\n\nTITLE: Using Hardware SPI in MicroPython for ESP8266\nDESCRIPTION: Demonstrates how to use the machine.SPI class to create a hardware SPI bus on an ESP8266 board. Hardware SPI is faster but works only on specific pins.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SPI\n\nhspi = SPI(1, baudrate=80000000, polarity=0, phase=0)\n```\n\n----------------------------------------\n\nTITLE: SPI Communication with machine.SPI\nDESCRIPTION: Illustrates how to set up and use the Serial Peripheral Interface (SPI) with the machine.SPI class on Renesas RA boards, including initializing SPI, selecting the chip select pin, and sending data.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/quickref.rst#2025-04-21_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import SPI, Pin\n\nspi = SPI(0, baudrate=500000)\ncs = Pin.cpu.P103\ncs(0)\nspi.write(b\"12345678\")\ncs(1)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Writing to LCD Display in MicroPython\nDESCRIPTION: Basic example of initializing the LCD display connected to the X position on the pyboard, turning on the backlight, and writing text to the screen.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/lcd_skin.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import pyb\n>>> lcd = pyb.LCD('X')\n>>> lcd.light(True)\n>>> lcd.write('Hello uPy!\\n')\n```\n\n----------------------------------------\n\nTITLE: Performing a Soft Reset in MicroPython\nDESCRIPTION: This snippet demonstrates how to perform a soft reset in the MicroPython virtual machine using the sys module. It clears the state while leaving hardware peripherals unaffected. The main functionality is to exit the current script or REPL safely.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/reset.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport sys\nsys.exit()\n```\n\n----------------------------------------\n\nTITLE: Detecting Platform Bitness in MicroPython\nDESCRIPTION: Code snippet demonstrating how to detect the bitness (32-bit vs 64-bit) of a platform using sys.maxsize. The code counts the number of bits in maxsize to determine platform characteristics.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/sys.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nbits = 0\nv = sys.maxsize\nwhile v:\n    bits += 1\n    v >>= 1\nif bits > 32:\n    # 64-bit (or more) platform\n    ...\nelse:\n    # 32-bit (or less) platform\n    # Note that on 32-bit platform, value of bits may be less than 32\n    # (e.g. 31) due to peculiarities described above, so use \"> 16\",\n    # \"> 32\", \"> 64\" style of comparisons.\n```\n\n----------------------------------------\n\nTITLE: Controlling GPIO LED with MicroPython\nDESCRIPTION: Code to control an LED connected to GPIO2 on ESP8266. Imports the machine module, configures a pin as output, and demonstrates turning the LED on and off.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/repl.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import machine\n>>> pin = machine.Pin(2, machine.Pin.OUT)\n>>> pin.on()\n>>> pin.off()\n```\n\n----------------------------------------\n\nTITLE: Using Named Constants in Assembly Code\nDESCRIPTION: Demonstrates how to make assembly code more readable and maintainable by using named constants. The const() construct causes MicroPython to replace the variable name with its value at compile time.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_hints_tips.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nMYDATA = const(33)\n\n@micropython.asm_thumb\ndef foo():\n    mov(r0, MYDATA)\n```\n\n----------------------------------------\n\nTITLE: Configuring UART in MicroPython on ESP32\nDESCRIPTION: Shows how to set up and use UART (serial bus) communication on ESP32 using the machine.UART class. Demonstrates initializing UART with custom baud rate and pin assignments.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import UART\n\nuart1 = UART(1, baudrate=9600, tx=33, rx=32)\nuart1.write('hello')  # write 5 bytes\nuart1.read(5)         # read up to 5 bytes\n```\n\n----------------------------------------\n\nTITLE: ADC with machine.ADC for Analog Input\nDESCRIPTION: Shows how to utilize the machine.ADC class in MicroPython for reading analog signals on Renesas RA boards using ADC pins, demonstrating the instantiation and reading processes.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/quickref.rst#2025-04-21_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import ADC\n\nadc = ADC('P000')    # create an ADC object acting on a pin\nadc.read_u16()       # read a raw analog value in the range 0-65535\n```\n\n----------------------------------------\n\nTITLE: Incorrect vs Correct PWM Pin Configuration\nDESCRIPTION: Shows the wrong and correct ways to initialize and modify PWM settings. Demonstrates proper pin configuration without explicitly setting Pin.OUT mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/tutorial/pwm.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Wrong way\npwm = PWM(Pin(5, Pin.OUT), freq=1000, duty=512)  # Pin(5) in PWM mode here\npwm = PWM(Pin(5, Pin.OUT), freq=500, duty=256)  # Pin(5) in OUT mode here, PWM is off\n\n# Correct way\npwm = PWM(Pin(5), freq=1000, duty=512)\npwm.init(freq=500, duty=256)\n```\n\n----------------------------------------\n\nTITLE: Using OneWire Bus in MicroPython\nDESCRIPTION: This code snippet demonstrates how to use the OneWire protocol in MicroPython for communication with devices on a single wire. It creates a OneWire object on a specified pin and demonstrates scanning for devices, resetting the bus, reading bytes, writing bytes, and selecting a specific device by its ROM code.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\nimport onewire\n\now = onewire.OneWire(Pin('D12')) # create a OneWire bus on GPIO12\now.scan()                     # return a list of devices on the bus\now.reset()                    # reset the bus\now.readbyte()                 # read a byte\now.writebyte(0x12)            # write a byte on the bus\now.write('123')               # write bytes on the bus\now.select_rom(b'12345678')    # select a specific device by its ROM code\n```\n\n----------------------------------------\n\nTITLE: Getting and Setting Clock and Time with RTC Module\nDESCRIPTION: This snippet demonstrates how to get and set the clock and time information using the RTC module, available on boards with a 32kHz crystal. rtc.now() is only provided at SAMD51 boards. The weekday value set will be ignored and calculated in the returned tuple from the actual date. The value used in the rtc.calibration() call has a range from -127 - 127.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import RTC\nrtc = RTC()\ndate_time = rtc.datetime()      # return the actual date & time.\nrtc.datetime(date_time_tuple)   # Set date & time, ignoring weekday\ndate_time = rtc.now()           # Return date & time in Unix order.\nrtc.calibration(value)          # Set a calibration factor\n```\n\n----------------------------------------\n\nTITLE: Reading GPIO Pin Value\nDESCRIPTION: Reads the current digital value from a GPIO pin. Returns 0 or 1 depending on the pin's state.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pins.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npin.value()\n```\n\n----------------------------------------\n\nTITLE: Sending and Receiving Data via SPI\nDESCRIPTION: This snippet demonstrates various ways of sending and receiving data using the SPI class. The examples include sending bytes and handling the returned data, with the use of buffers to store received information.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.SPI.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndata = spi.send_recv(b'1234')        # send 4 bytes and receive 4 bytes\nbuf = bytearray(4)\nspi.send_recv(b'1234', buf)          # send 4 bytes and receive 4 into buf\nspi.send_recv(buf, buf)              # send/recv 4 bytes from/to buf\n```\n\n----------------------------------------\n\nTITLE: Initializing DHT11 Sensor in MicroPython\nDESCRIPTION: Creates a DHT11 sensor object using machine.Pin(4) for temperature and humidity readings. DHT11 provides whole number resolution and can be read once per second.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/dht.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport dht\nimport machine\nd = dht.DHT11(machine.Pin(4))\n```\n\n----------------------------------------\n\nTITLE: Creating ExtInt Object in MicroPython\nDESCRIPTION: This code shows how to create an ExtInt object. It configures pin X1 to trigger an interrupt on a falling edge, with a pull-up resistor enabled, and associates it with the 'callback' function.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.ExtInt.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nextint = pyb.ExtInt(pin, pyb.ExtInt.IRQ_FALLING, pyb.Pin.PULL_UP, callback)\n```\n\n----------------------------------------\n\nTITLE: Playing Large WAV Files in Chunks on AMP Audio Skin in MicroPython\nDESCRIPTION: Function to play larger WAV files by reading and processing them in one-second chunks. This approach works with 8-bit wave files up to 16kHz sampling rate stored on a micro-SD card.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/amp_skin.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport wave\nfrom pyb import DAC\nfrom pyb import delay\ndac = DAC(1)\n\ndef play(filename):\n    f = wave.open(filename, 'r')\n    total_frames = f.getnframes()\n    framerate = f.getframerate()\n\n    for position in range(0, total_frames, framerate):\n        f.setpos(position)\n        dac.write_timed(f.readframes(framerate), framerate)\n        delay(1000)\n```\n\n----------------------------------------\n\nTITLE: Deserializing JSON Stream to Python Object in MicroPython\nDESCRIPTION: The 'load' function parses a JSON string from a given stream and deserializes it into a Python object. It raises a ValueError if the input is not correctly formed JSON.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/json.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nload(stream)\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Embed Port\nDESCRIPTION: Command to generate a self-contained MicroPython directory suitable for embedding into a C project using a custom Makefile\nSOURCE: https://github.com/micropython/micropython/blob/master/examples/embedding/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ make -f micropython_embed.mk\n```\n\n----------------------------------------\n\nTITLE: Blinking LED using PIO in MicroPython on RP2\nDESCRIPTION: Python code to blink the on-board LED of a Pico board at 1Hz using a PIO peripheral and PIO assembler to directly toggle the LED at the required rate.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/README.md#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Pin\nimport rp2\n\n@rp2.asm_pio(set_init=rp2.PIO.OUT_LOW)\ndef blink_1hz():\n    # Turn on the LED and delay, taking 1000 cycles.\n    set(pins, 1)\n    set(x, 31)                  [6]\n    label(\"delay_high\")\n    nop()                       [29]\n    jmp(x_dec, \"delay_high\")\n\n    # Turn off the LED and delay, taking 1000 cycles.\n    set(pins, 0)\n    set(x, 31)                  [6]\n    label(\"delay_low\")\n    nop()                       [29]\n    jmp(x_dec, \"delay_low\")\n\n# Create StateMachine(0) with the blink_1hz program, outputting on Pin(25).\nsm = rp2.StateMachine(0, blink_1hz, freq=2000, set_base=Pin(25))\nsm.active(1)\n```\n\n----------------------------------------\n\nTITLE: Setting CPU Frequency with Machine Module\nDESCRIPTION: This snippet demonstrates how to get and set the CPU frequency using the machine module. The frequency range varies between SAMD21 and SAMD51 boards. Changing the frequency below 48MHz impacts the baud rates of UART, I2C and SPI.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport machine\n\nmachine.freq()            # get the current frequency of the CPU\nmachine.freq(96_000_000)  # set the CPU frequency to 96 MHz\n```\n\n----------------------------------------\n\nTITLE: Timing function with decorator\nDESCRIPTION: This Python code defines a decorator `timed_function` that measures the execution time of a function using `time.ticks_us()` and prints the result in milliseconds. It helps to identify slow sections of code for performance optimization.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/speed_python.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef timed_function(f, *args, **kwargs):\n    myname = str(f).split(' ')[1]\n    def new_func(*args, **kwargs):\n        t = time.ticks_us()\n        result = f(*args, **kwargs)\n        delta = time.ticks_diff(time.ticks_us(), t)\n        print('Function {} Time = {:6.3f}ms'.format(myname, delta/1000))\n        return result\n    return new_func\n```\n\n----------------------------------------\n\nTITLE: Initializing APA102 LED Strip in MicroPython\nDESCRIPTION: This snippet demonstrates how to import necessary modules and create an APA102 object for a 60-pixel LED strip. It uses machine.Pin for clock and data pins.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/apa102.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import machine, apa102\n>>> strip = apa102.APA102(machine.Pin(5), machine.Pin(4), 60)\n```\n\n----------------------------------------\n\nTITLE: Memory-to-Memory DMA Transfer in MicroPython\nDESCRIPTION: Demonstrates a basic DMA transfer between two byte arrays using the RP2040 DMA controller. Transfers 32KB of data from source to destination array while using default control settings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/rp2.DMA.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\na = bytearray(32*1024)\nb = bytearray(32*1024)\nd = rp2.DMA()\nc = d.pack_ctrl()  # Just use the default control value.\n# The count is in 'transfers', which defaults to four-byte words, so divide length by 4\nd.config(read=a, write=b, count=len(a)//4, ctrl=c, trigger=True)\n# Wait for completion\nwhile d.active():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Reading Flash Memory Information in MicroPython\nDESCRIPTION: Functions to read various information about the flash memory, including device ID, total size, and user space start offset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nflash_id()\nflash_size()\nflash_user_start()\n```\n\n----------------------------------------\n\nTITLE: Mounting Filesystem Objects in MicroPython VFS\nDESCRIPTION: Function to mount filesystem objects at specified mount points in the Virtual Filesystem. Supports both VFS objects with mount() method and block devices with automatic filesystem detection.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/vfs.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmount(fsobj, mount_point, *, readonly)\n```\n\n----------------------------------------\n\nTITLE: Using UART for Serial Communication on WiPy\nDESCRIPTION: This code snippet demonstrates establishing and using a UART connection on the WiPy board. It configures the UART with a specified baud rate, writes data to the serial line, and reads incoming data up to a specified number of bytes.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import UART\nuart = UART(0, baudrate=9600)\nuart.write('hello')\nuart.read(5) # read up to 5 bytes\n```\n\n----------------------------------------\n\nTITLE: Setting up SDCard Driver in MicroPython\nDESCRIPTION: This code snippet shows how to mount an SDCard using the drivers module in MicroPython. It uses the machine, os, vfs, and sdcard modules to initialize SPI communication, set up the card, mount the file system, and interact with files. The SPI must be configured with appropriate pins and a microSD card connected to them.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/quickref.rst#2025-04-21_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Pin, SPI\nimport os, vfs, sdcard\n\nspi = SPI(0, baudrate=500000)\ncs = Pin.cpu.P103\nsd = sdcard.SDCard(spi, cs)\nvfs.mount(sd, '/sd')\nos.listdir('/')\nos.chdir('/sd')\nvfs.umount('/sd')\n```\n\n----------------------------------------\n\nTITLE: Reading USB VCP Data - Python\nDESCRIPTION: Method to read bytes from the USB device with optional size limit. Returns bytes object or None if no data available.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.USB_VCP.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nUSB_VCP.read([nbytes])\n```\n\n----------------------------------------\n\nTITLE: Multiple LED Sequence Control with List Comprehension\nDESCRIPTION: Creates a list of LED objects using a list comprehension and cycles through them in sequence. This demonstrates how to control multiple LEDs and use the modulus operator for cycling through a sequence.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/leds.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nleds = [pyb.LED(i) for i in range(1,5)]\n\nn = 0\nwhile True:\n  n = (n + 1) % 4\n  leds[n].toggle()\n  pyb.delay(50)\n```\n\n----------------------------------------\n\nTITLE: Packing Data Values in Python\nDESCRIPTION: Packs multiple values according to a format string and returns a bytes object containing the encoded values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/struct.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npack(fmt, v1, v2, ...)\n```\n\n----------------------------------------\n\nTITLE: Connecting to MicroPython REPL on Mac OS X using screen command\nDESCRIPTION: Command to connect to the MicroPython REPL prompt on Mac OS X using the screen utility. The asterisk is a wildcard to match any available pyboard device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/repl.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nscreen /dev/tty.usbmodem*\n```\n\n----------------------------------------\n\nTITLE: Initializing ESPNow and Sending Messages in MicroPython\nDESCRIPTION: Sets up an ESPNow connection with a peer device and sends sensor data in a continuous loop. The code activates ESPNow, adds a peer using its MAC address, and sends messages at 1-second intervals.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\npeer = b'0\\xaa\\xaa\\xaa\\xaa\\xaa'  # MAC address of proxy\ne = espnow.ESPNow(); e.active(True);\ne.add_peer(peer)\nwhile True:\n    msg = read_sensor()\n    e.send(peer, msg)\n    time.sleep(1)\n```\n\n----------------------------------------\n\nTITLE: Configuring Software Timers on Renesas RA Boards\nDESCRIPTION: Shows the use of the machine.Timer class in MicroPython to create software timers on the Renesas RA microcontrollers. Detailing how to set up one-shot and periodic timer modes with specific periods executing callback functions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/quickref.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Timer\n\ntim = Timer(-1)\ntim.init(period=5000, mode=Timer.ONE_SHOT, callback=lambda t:print(1))\ntim.init(period=2000, mode=Timer.PERIODIC, callback=lambda t: print(2))\n```\n\n----------------------------------------\n\nTITLE: Defining IRQ Trigger Type Constants in MicroPython\nDESCRIPTION: Constants used to select the IRQ (Interrupt Request) trigger type for a pin in MicroPython. These include falling edge, rising edge, low level, and high level triggers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.Pin.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nPin.IRQ_FALLING\nPin.IRQ_RISING\nPin.IRQ_LOW_LEVEL\nPin.IRQ_HIGH_LEVEL\n```\n\n----------------------------------------\n\nTITLE: Manually Sending Mouse Events via REPL\nDESCRIPTION: This code demonstrates how to manually send mouse events through the REPL interface. It sends a command to move the mouse 100 pixels to the right.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/usb_mouse.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> hid = pyb.USB_HID()\n>>> hid.send((0, 100, 0, 0)) # (button status, x-direction, y-direction, scroll)\n```\n\n----------------------------------------\n\nTITLE: Blinking LED using Timer in MicroPython on RP2\nDESCRIPTION: Python code to blink the on-board LED of a Pico board at 1.25Hz using a Timer object with a callback function.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/README.md#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Pin, Timer\nled = Pin(25, Pin.OUT)\ntim = Timer()\ndef tick(timer):\n    led.toggle()\n\ntim.init(freq=2.5, mode=Timer.PERIODIC, callback=tick)\n```\n\n----------------------------------------\n\nTITLE: Flashing MicroPython to ESP8266 with Custom Settings in Bash\nDESCRIPTION: This command flashes the MicroPython image to the ESP8266 module with custom settings for port, flash mode, and flash size.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ make PORT=/dev/ttyUSB0 FLASH_MODE=qio FLASH_SIZE=32m deploy\n```\n\n----------------------------------------\n\nTITLE: Freezing a Package of Python Modules (Python)\nDESCRIPTION: Manifest code to include a package directory of Python files. This demonstrates the package() function with optional parameters for specifying included files.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/manifest.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npackage(\"foo\")\n\n# With base_path\npackage(\"foo\", base_path=\"path/to/libraries\")\n\n# Restricting to specific files\npackage(\"foo\", files=[\"bar/baz.py\"])\n```\n\n----------------------------------------\n\nTITLE: Unpacking Data in Python\nDESCRIPTION: Unpacks data according to a format string and returns a tuple of the unpacked values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/struct.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nunpack(fmt, data)\n```\n\n----------------------------------------\n\nTITLE: Flashing MicroPython to ESP8266 in Bash\nDESCRIPTION: This command flashes the MicroPython image to the ESP8266 module. It uses the default settings for port, flash mode, and flash size.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ make deploy\n```\n\n----------------------------------------\n\nTITLE: SD Card Access on WiPy with MicroPython\nDESCRIPTION: This snippet provides a method to access and mount an SD card on the WiPy board using default or specified pins. It utilizes the 'machine.SD' and 'vfs' modules for integration with the board’s file system.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import SD\nimport vfs\n\n# clock pin, cmd pin, data0 pin\nsd = SD(pins=('GP10', 'GP11', 'GP15'))\n# or use default ones for the expansion board\nsd = SD()\nvfs.mount(sd, '/sd')\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic GPIO Pin in MicroPython\nDESCRIPTION: Creates a basic GPIO pin object without specific configuration. This is the simplest form of pin initialization.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pins.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npin = machine.Pin(0)\n```\n\n----------------------------------------\n\nTITLE: Basic DAC Usage Example in MicroPython\nDESCRIPTION: Demonstrates basic DAC initialization and writing a simple value to output an analog voltage on pin X5.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.DAC.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import DAC\n\ndac = DAC(1)            # create DAC 1 on pin X5\ndac.write(128)          # write a value to the DAC (makes X5 1.65V)\n\ndac = DAC(1, bits=12)   # use 12 bit resolution\ndac.write(4095)         # output maximum value, 3.3V\n```\n\n----------------------------------------\n\nTITLE: Flashing MicroPython firmware to ESP8266\nDESCRIPTION: Command to write MicroPython firmware to an ESP8266 device using esptool.py, with automatic flash size detection.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/intro.rst#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py --port /dev/ttyUSB0 --baud 460800 write_flash --flash_size=detect 0 esp8266-20170108-v1.8.7.bin\n```\n\n----------------------------------------\n\nTITLE: Using the Real-Time Clock (RTC) on pyboard in MicroPython\nDESCRIPTION: Accessing and setting the pyboard's real-time clock. The code demonstrates initializing the RTC object, setting a specific date and time, and reading the current date and time values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import RTC\n\nrtc = RTC()\nrtc.datetime((2017, 8, 23, 0, 1, 12, 48, 0)) # set a specific date and\n                                             # time, eg. 2017/8/23 1:12:48\n                                             # the day-of-week value is ignored\nrtc.datetime() # get date and time\n```\n\n----------------------------------------\n\nTITLE: Initializing UART Communication in MicroPython\nDESCRIPTION: Basic UART initialization example showing how to create and configure a UART object with baudrate and optional parameters\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.UART.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import UART\n\nuart = UART(1, 9600)                         # init with given baudrate\nuart.init(9600, bits=8, parity=None, stop=1) # init with given parameters\n```\n\n----------------------------------------\n\nTITLE: Initializing SSD1306 OLED with I2C Interface in MicroPython\nDESCRIPTION: Sets up an SSD1306 OLED display using I2C interface. Creates an I2C object with specified SDA and SCL pins, then initializes a 128x64 display using the default I2C address of 0x3C.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/ssd1306.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, I2C\nimport ssd1306\n\n# using default address 0x3C\ni2c = I2C(sda=Pin(4), scl=Pin(5))\ndisplay = ssd1306.SSD1306_I2C(128, 64, i2c)\n```\n\n----------------------------------------\n\nTITLE: Installing nRFUtil and IntelHex Packages for MicroPython Flashing on nRF52\nDESCRIPTION: Install the necessary Python packages (nrfutil and intelhex) for flashing MicroPython firmware using the bootloader. The intelhex package provides the hexmerge.py utility used by the Makefile to trim the MBR when SoftDevice flashing is requested.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/README.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsudo pip install nrfutil\nsudo pip install intelhex\n```\n\n----------------------------------------\n\nTITLE: Setting Pulse Width Percentage for Timer Channel in MicroPython\nDESCRIPTION: Method for getting or setting the pulse width as a percentage (0-100%) of the timer period. This represents the duty cycle of the PWM signal. The value can be an integer or floating-point number for greater precision.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ntimerchannel.pulse_width_percent([value])\n```\n\n----------------------------------------\n\nTITLE: Initializing and Reading Touch Sensor Data via I2C in MicroPython\nDESCRIPTION: Basic example of initializing the I2C bus, enabling the MPR121 touch sensors, and reading their status. The touch variable will hold the state of the 4 touch buttons (A, B, X, Y).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/lcd_skin.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import pyb\n>>> i2c = pyb.I2C(1, pyb.I2C.CONTROLLER)\n>>> i2c.mem_write(4, 90, 0x5e)\n>>> touch = i2c.mem_read(1, 90, 0)[0]\n```\n\n----------------------------------------\n\nTITLE: SSD1306 OLED Display Driver Setup\nDESCRIPTION: Example of initializing and using an SSD1306 OLED display over I2C interface.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, I2C\nimport ssd1306\n\ni2c = I2C(scl=Pin(5), sda=Pin(4), freq=100000)\ndisplay = ssd1306.SSD1306_I2C(128, 64, i2c)\n\ndisplay.text('Hello World', 0, 0, 1)\ndisplay.show()\n```\n\n----------------------------------------\n\nTITLE: Configuring LAN with Seeed Arch Mix Board\nDESCRIPTION: Example showing how to initialize LAN interface with specific PHY configuration for the Seeed Arch Mix board.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.LAN.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnic = LAN(0, phy_type=LAN.PHY_LAN8720, phy_addr=1, ref_clk_mode=Pin.IN)\n```\n\n----------------------------------------\n\nTITLE: Using BLE.l2cap_send Method in MicroPython\nDESCRIPTION: Sends data on an L2CAP channel identified by connection handle and CID. Returns False if the channel becomes stalled, requiring the application to wait for the _IRQ_L2CAP_SEND_READY event before sending more data.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nBLE.l2cap_send(conn_handle, cid, buf, /)\n```\n\n----------------------------------------\n\nTITLE: BTree Database Usage Example in MicroPython\nDESCRIPTION: Demonstrates how to create, open, and manipulate a BTree database including basic operations like inserting, reading, deleting keys, and iterating over the database. Shows proper database opening/closing patterns and transaction handling.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/btree.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport btree\n\n# First, we need to open a stream which holds a database\n# This is usually a file, but can be in-memory database\n# using io.BytesIO, a raw flash partition, etc.\n# Oftentimes, you want to create a database file if it doesn't\n# exist and open if it exists. Idiom below takes care of this.\n# DO NOT open database with \"a+b\" access mode.\ntry:\n    f = open(\"mydb\", \"r+b\")\nexcept OSError:\n    f = open(\"mydb\", \"w+b\")\n\n# Now open a database itself\ndb = btree.open(f)\n\n# The keys you add will be sorted internally in the database\ndb[b\"3\"] = b\"three\"\ndb[b\"1\"] = b\"one\"\ndb[b\"2\"] = b\"two\"\n\n# Assume that any changes are cached in memory unless\n# explicitly flushed (or database closed). Flush database\n# at the end of each \"transaction\".\ndb.flush()\n\n# Prints b'two'\nprint(db[b\"2\"])\n\n# Iterate over sorted keys in the database, starting from b\"2\"\n# until the end of the database, returning only values.\n# Mind that arguments passed to values() method are *key* values.\n# Prints:\n#   b'two'\n#   b'three'\nfor word in db.values(b\"2\"):\n    print(word)\n\ndel db[b\"2\"]\n\n# No longer true, prints False\nprint(b\"2\" in db)\n\n# Prints:\n#  b\"1\"\n#  b\"3\"\nfor key in db:\n    print(key)\n\ndb.close()\n\n# Don't forget to close the underlying stream!\nf.close()\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple RAM Block Device in Python for MicroPython\nDESCRIPTION: Creates a basic block device that stores data in RAM using a bytearray. This implementation provides the simple block device interface with readblocks, writeblocks, and ioctl methods for filesystem operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass RAMBlockDev:\n    def __init__(self, block_size, num_blocks):\n        self.block_size = block_size\n        self.data = bytearray(block_size * num_blocks)\n\n    def readblocks(self, block_num, buf):\n        for i in range(len(buf)):\n            buf[i] = self.data[block_num * self.block_size + i]\n\n    def writeblocks(self, block_num, buf):\n        for i in range(len(buf)):\n            self.data[block_num * self.block_size + i] = buf[i]\n\n    def ioctl(self, op, arg):\n        if op == 4: # get number of blocks\n            return len(self.data) // self.block_size\n        if op == 5: # get block size\n            return self.block_size\n```\n\n----------------------------------------\n\nTITLE: PIO State Machine DMA Transfer in MicroPython\nDESCRIPTION: Illustrates a more complex DMA transfer from a byte array to a PIO state machine's TX FIFO, demonstrating byte-level transfer with controlled pacing and non-incrementing write address.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/rp2.DMA.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# pio_num is index of the PIO block being used, sm_num is the state machine in that block.\n# my_state_machine is an rp2.PIO() instance.\nDATA_REQUEST_INDEX = (pio_num << 3) + sm_num\n\nsrc_data = bytearray(1024)\nd = rp2.DMA()\n\n# Transfer bytes, rather than words, don't increment the write address and pace the transfer.\nc = d.pack_ctrl(size=0, inc_write=False, treq_sel=DATA_REQUEST_INDEX)\n\nd.config(\n    read=src_data,\n    write=my_state_machine,\n    count=len(src_data),\n    ctrl=c,\n    trigger=True\n)\n```\n\n----------------------------------------\n\nTITLE: Controlling RGB LED on nullbits Bit-C PRO Board using MicroPython\nDESCRIPTION: This code snippet demonstrates how to use the 'board' module to control the onboard RGB LED on the nullbits Bit-C PRO Board. It shows how to turn on the red, green, and blue components of the LED individually.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/boards/NULLBITS_BIT_C_PRO/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import board\n>>> board.led_red.on()\n>>> board.led_green.on()\n>>> board.led_blue.on()\n```\n\n----------------------------------------\n\nTITLE: Configuring Timer Prescaler in MicroPython\nDESCRIPTION: Method for getting or setting the prescaler value of a timer. The prescaler divides the timer's input clock frequency to determine the timer's counting rate.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nTimer.prescaler([value])\n```\n\n----------------------------------------\n\nTITLE: Setting Date and Time in RTC\nDESCRIPTION: This snippet sets the date and time of the RTC to the specified 8-tuple. Providing an 8-tuple updates the RTC with the desired date and time, while calling the method without any arguments returns the current date and time.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.RTC.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nrtc.datetime((2014, 5, 1, 4, 13, 0, 0, 0))\n```\n\n----------------------------------------\n\nTITLE: Initializing and Reading Accelerometer in MicroPython\nDESCRIPTION: This snippet demonstrates how to create an Accel object and read x, y, and z values from the accelerometer. It loops 10 times, printing the accelerometer readings each iteration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Accel.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\naccel = pyb.Accel()\nfor i in range(10):\n    print(accel.x(), accel.y(), accel.z())\n```\n\n----------------------------------------\n\nTITLE: Blinking LED using specific Pin identifier\nDESCRIPTION: This snippet shows an alternative way to control the LED by directly using its CPU pin identifier instead of the symbolic 'LED1'. It achieves the same LED blinking functionality.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/tutorial/using_peripheral.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport time\\nfrom machine import Pin\\nled1 = Pin(Pin.cpu.P106)\\nprint(led1)\\nwhile True:\\n    led1.on()\\n    time.sleep(1)\\n    led1.off()\\n    time.sleep(1)\n```\n\n----------------------------------------\n\nTITLE: Multi-Channel ADC Reading\nDESCRIPTION: Example of reading from multiple ADC channels simultaneously using Timer-based sampling\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.ADC.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nadc0 = pyb.ADC(pyb.Pin.board.X1)    # Create ADC's\nadc1 = pyb.ADC(pyb.Pin.board.X2)\nadc2 = pyb.ADC(pyb.Pin.board.X3)\ntim = pyb.Timer(8, freq=100)        # Create timer\nrx0 = array.array('H', (0 for i in range(100))) # ADC buffers of\nrx1 = array.array('H', (0 for i in range(100))) # 100 16-bit words\nrx2 = array.array('H', (0 for i in range(100)))\n# read analog values into buffers at 100Hz (takes one second)\npyb.ADC.read_timed_multi((adc0, adc1, adc2), (rx0, rx1, rx2), tim)\nfor n in range(len(rx0)):\n    print(rx0[n], rx1[n], rx2[n])\n```\n\n----------------------------------------\n\nTITLE: Initializing Switch Object on Pyboard\nDESCRIPTION: This snippet shows how to create an instance of the Switch class in MicroPython on a pyboard. It demonstrates the basic setup required to start interacting with the USR switch. Prerequisites include importing the pyb module.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/switch.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> sw = pyb.Switch()\n```\n\n----------------------------------------\n\nTITLE: Configuring USB Mode in boot.py for Mouse Functionality\nDESCRIPTION: This code snippet shows how to modify the boot.py file to configure the pyboard as both a Virtual COM Port (VCP) and Human Interface Device (HID) for mouse functionality.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/usb_mouse.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# boot.py -- run on boot to configure USB and filesystem\n# Put app code in main.py\n\nimport pyb\n#pyb.main('main.py') # main script to run after this one\n#pyb.usb_mode('VCP+MSC') # act as a serial and a storage device\n#pyb.usb_mode('VCP+HID') # act as a serial device and a mouse\n```\n\n----------------------------------------\n\nTITLE: Working with the machine Module in MicroPython\nDESCRIPTION: Demonstrates how to use the machine module to interact with the hardware features of Renesas RA boards, including obtaining the CPU frequency and controlling board resets. Important functions such as machine.freq() and machine.reset() are available, while some functions like machine.bootloader() are not supported.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/quickref.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport machine\n\nmachine.freq()    # get the current frequency of the CPU\n```\n\n----------------------------------------\n\nTITLE: Toggling LED State in MicroPython\nDESCRIPTION: Toggles the LED between on (maximum intensity) and off. If the LED is at non-zero intensity, it is considered 'on' and toggle will turn it off.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.LED.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nLED.toggle()\n```\n\n----------------------------------------\n\nTITLE: Setting Speed for Continuous Rotation Servos\nDESCRIPTION: This code snippet illustrates how to set the speed of a continuous rotation servo. It uses the speed method to adjust the motor's speed and can set it with a duration to reach the final speed.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/servo.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> servo1.speed(30)\n>>> servo1.speed()\n30\n>>> servo1.speed(-20)\n>>> servo1.speed(0, 2000)\n```\n\n----------------------------------------\n\nTITLE: Formatting STM32 Flash with FAT Filesystem in MicroPython\nDESCRIPTION: Code for formatting the internal flash of STM32/Pyboard devices with a FAT filesystem. This example unmounts the current filesystem, formats the flash starting at offset 0, and remounts it at '/flash'.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# STM32\nimport os, vfs, pyb\nvfs.umount('/flash')\nvfs.VfsFat.mkfs(pyb.Flash(start=0))\nvfs.mount(pyb.Flash(start=0), '/flash')\nos.chdir('/flash')\n```\n\n----------------------------------------\n\nTITLE: Creating an LED Blinking Loop\nDESCRIPTION: Code that creates an infinite loop to toggle an LED at 1Hz frequency (500ms on, 500ms off). Uses the time module for creating delays between toggles.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/repl.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import time\n>>> while True:\n...     toggle(pin)\n...     time.sleep_ms(500)\n...    \n...    \n...    \n>>>\n```\n\n----------------------------------------\n\nTITLE: Initializing RGB NeoPixel Strip\nDESCRIPTION: Creates a NeoPixel object for a basic RGB LED strip on GPIO4 with 8 pixels\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/neopixel.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport machine, neopixel\nnp = neopixel.NeoPixel(machine.Pin(4), 8)\n```\n\n----------------------------------------\n\nTITLE: Implementing WDT (Watchdog Timer) in MicroPython\nDESCRIPTION: Example showing how to enable and feed the watchdog timer on ESP8266.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import WDT\n\n# enable the WDT\nwdt = WDT()\nwdt.feed()\n```\n\n----------------------------------------\n\nTITLE: UART Serial Communication in MicroPython for i.MXRT\nDESCRIPTION: Example showing how to set up and use UART (serial bus) communication on i.MXRT boards with configurable baudrate and basic read/write operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import UART\n\nuart1 = UART(1, baudrate=115200)\nuart1.write('hello')  # write 5 bytes\nuart1.read(5)         # read up to 5 bytes\nuart1 = UART(baudrate=19200) # open UART 1 at 19200 baud\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Timers in MicroPython for ESP8266\nDESCRIPTION: Shows how to create and use virtual (RTOS-based) timers using the machine.Timer class on an ESP8266 board. Demonstrates both one-shot and periodic timer modes.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Timer\n\ntim = Timer(-1)\ntim.init(period=5000, mode=Timer.ONE_SHOT, callback=lambda t:print(1))\ntim.init(period=2000, mode=Timer.PERIODIC, callback=lambda t:print(2))\n```\n\n----------------------------------------\n\nTITLE: Implementing Capacitive Touch Sensing with MicroPython on ESP32\nDESCRIPTION: This snippet demonstrates how to use the TouchPad class for capacitive touch sensing on ESP32, ESP32-S2, and ESP32-S3 boards. It shows how to create a TouchPad object and read touch values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import TouchPad, Pin\n\nt = TouchPad(Pin(14))\nt.read()              # Returns a smaller number when touched\n```\n\n----------------------------------------\n\nTITLE: Deploying MicroPython Firmware to Arduino Nicla Vision\nDESCRIPTION: This command uses the MicroPython build system to compile and deploy firmware specifically for the Arduino Nicla Vision board. It assumes you are in the MicroPython source repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/ARDUINO_NICLA_VISION/deploy.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake BOARD=ARDUINO_NICLA_VISION deploy\n```\n\n----------------------------------------\n\nTITLE: Creating and Initializing a Timer in MicroPython\nDESCRIPTION: Creates a Timer object attached to timer 4 and initializes it to trigger at 10 Hz. After initialization, the timer's configuration details are displayed, showing the prescaler, period, mode and division settings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/timer.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> tim = pyb.Timer(4)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> tim\nTimer(4)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> tim.init(freq=10)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> tim\nTimer(4, prescaler=624, period=13439, mode=UP, div=1)\n```\n\n----------------------------------------\n\nTITLE: Optimizing Garbage Collection in MicroPython\nDESCRIPTION: This code snippet demonstrates a quick way to optimize garbage collection in MicroPython. It forces garbage collection and sets a new threshold based on current memory usage.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ngc.collect()\ngc.threshold(gc.mem_free() // 4 + gc.mem_alloc())\n```\n\n----------------------------------------\n\nTITLE: Installing Package with MicroPython Package Manager in Python\nDESCRIPTION: This Python code demonstrates how to use the built-in 'mip' package manager to install additional modules on the ESP8266. It installs the 'hmac' module and shows its usage.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> import mip\n>>> mip.install(\"hmac\")\n[...]\n>>> import hmac\n>>> hmac.new(b\"1234567890\", msg=\"hello world\").hexdigest()\n```\n\n----------------------------------------\n\nTITLE: Bluetooth Event Handler Implementation in Python\nDESCRIPTION: Example event handler function showing all possible Bluetooth events and their data structures. Handles various events like connections, disconnections, GATT operations, scanning results, and MTU exchanges.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef bt_irq(event, data):\n    if event == _IRQ_CENTRAL_CONNECT:\n        # A central has connected to this peripheral.\n        conn_handle, addr_type, addr = data\n    elif event == _IRQ_CENTRAL_DISCONNECT:\n        # A central has disconnected from this peripheral.\n        conn_handle, addr_type, addr = data\n    elif event == _IRQ_GATTS_WRITE:\n        # A client has written to this characteristic or descriptor.\n        conn_handle, attr_handle = data\n    elif event == _IRQ_GATTS_READ_REQUEST:\n        # A client has issued a read. Note: this is only supported on STM32.\n        # Return a non-zero integer to deny the read (see below), or zero (or None)\n        # to accept the read.\n        conn_handle, attr_handle = data\n    elif event == _IRQ_SCAN_RESULT:\n        # A single scan result.\n        addr_type, addr, adv_type, rssi, adv_data = data\n    elif event == _IRQ_SCAN_DONE:\n        # Scan duration finished or manually stopped.\n        pass\n    elif event == _IRQ_PERIPHERAL_CONNECT:\n        # A successful gap_connect().\n        conn_handle, addr_type, addr = data\n    elif event == _IRQ_PERIPHERAL_DISCONNECT:\n        # Connected peripheral has disconnected.\n        conn_handle, addr_type, addr = data\n    elif event == _IRQ_GATTC_SERVICE_RESULT:\n        # Called for each service found by gattc_discover_services().\n        conn_handle, start_handle, end_handle, uuid = data\n    elif event == _IRQ_GATTC_SERVICE_DONE:\n        # Called once service discovery is complete.\n        # Note: Status will be zero on success, implementation-specific value otherwise.\n        conn_handle, status = data\n    elif event == _IRQ_GATTC_CHARACTERISTIC_RESULT:\n        # Called for each characteristic found by gattc_discover_services().\n        conn_handle, end_handle, value_handle, properties, uuid = data\n    elif event == _IRQ_GATTC_CHARACTERISTIC_DONE:\n        # Called once service discovery is complete.\n        # Note: Status will be zero on success, implementation-specific value otherwise.\n        conn_handle, status = data\n    elif event == _IRQ_GATTC_DESCRIPTOR_RESULT:\n        # Called for each descriptor found by gattc_discover_descriptors().\n        conn_handle, dsc_handle, uuid = data\n    elif event == _IRQ_GATTC_DESCRIPTOR_DONE:\n        # Called once service discovery is complete.\n        # Note: Status will be zero on success, implementation-specific value otherwise.\n        conn_handle, status = data\n    elif event == _IRQ_GATTC_READ_RESULT:\n        # A gattc_read() has completed.\n        conn_handle, value_handle, char_data = data\n    elif event == _IRQ_GATTC_READ_DONE:\n        # A gattc_read() has completed.\n        # Note: Status will be zero on success, implementation-specific value otherwise.\n        conn_handle, value_handle, status = data\n    elif event == _IRQ_GATTC_WRITE_DONE:\n        # A gattc_write() has completed.\n        # Note: Status will be zero on success, implementation-specific value otherwise.\n        conn_handle, value_handle, status = data\n    elif event == _IRQ_GATTC_NOTIFY:\n        # A server has sent a notify request.\n        conn_handle, value_handle, notify_data = data\n    elif event == _IRQ_GATTC_INDICATE:\n        # A server has sent an indicate request.\n        conn_handle, value_handle, notify_data = data\n    elif event == _IRQ_GATTS_INDICATE_DONE:\n        # A client has acknowledged the indication.\n        # Note: Status will be zero on successful acknowledgment, implementation-specific value otherwise.\n        conn_handle, value_handle, status = data\n    elif event == _IRQ_MTU_EXCHANGED:\n        # ATT MTU exchange complete (either initiated by us or the remote device).\n        conn_handle, mtu = data\n    elif event == _IRQ_L2CAP_ACCEPT:\n        # A new channel has been accepted.\n        # Return a non-zero integer to reject the connection, or zero (or None) to accept.\n```\n\n----------------------------------------\n\nTITLE: Initializing LCD Object in MicroPython\nDESCRIPTION: Shows how to create an LCD object based on the position of the pyskin. The pyskin must be connected in either the X or Y position.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.LCD.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nlcd = pyb.LCD('X')      # if pyskin is in the X position\nlcd = pyb.LCD('Y')      # if pyskin is in the Y position\n```\n\n----------------------------------------\n\nTITLE: Initializing WM8960 in Slave Mode with Default Settings\nDESCRIPTION: Sets up the WM8960 audio codec in slave mode with a 32kHz sample rate. Configures the left input to use microphone input 1 and sets the headphone output volume to maximum (100).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/wm8960.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, I2C\nimport wm8960\ni2c = I2C(0)\nwm=wm8960.WM8960(i2c, 32000, left_input=wm8960.INPUT_MIC1)\nwm.set_volume(wm8960.MODULE_HEADPHONE, 100)\n```\n\n----------------------------------------\n\nTITLE: Handling OSError Exceptions with ESP-NOW\nDESCRIPTION: This snippet demonstrates how to handle different OSError exceptions in ESP-NOW communications by checking specific error codes returned by the Espressif ESP-NOW software stack, and implementing appropriate corrective measures. Requires the espnow module in MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ntry:\n    e.send(peer, 'Hello')\nexcept OSError as err:\n    if len(err.args) < 2:\n        raise err\n    if err.args[1] == 'ESP_ERR_ESPNOW_NOT_INIT':\n        e.active(True)\n    elif err.args[1] == 'ESP_ERR_ESPNOW_NOT_FOUND':\n        e.add_peer(peer)\n    elif err.args[1] == 'ESP_ERR_ESPNOW_IF':\n        network.WLAN(network.WLAN.IF_STA).active(True)\n    else:\n        raise err\n```\n\n----------------------------------------\n\nTITLE: Timer Modes and PWM Configuration\nDESCRIPTION: This example demonstrates various timer modes (ONE_SHOT, PWM) and PWM configuration options in MicroPython. It showcases how to initialize timers in different modes, configure channels with specific frequencies and duty cycles, and modify the frequency, duty cycle, and polarity of a PWM signal.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/timer.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Timer\ntim1 = Timer(1, mode=Timer.ONE_SHOT)                               # initialize it in one shot mode\ntim2 = Timer(2, mode=Timer.PWM)                                    # initialize it in PWM mode\ntim1_ch = tim1.channel(Timer.A, freq=10, polarity=Timer.POSITIVE)  # start the event counter with a frequency of 10Hz and triggered by positive edges\ntim2_ch = tim2.channel(Timer.B, freq=10000, duty_cycle=5000)       # start the PWM on channel B with a 50% duty cycle\ntim2_ch.freq(20)                                                   # set the frequency (can also get)\ntim2_ch.duty_cycle(3010)                                           # set the duty cycle to 30.1% (can also get)\ntim2_ch.duty_cycle(3020, Timer.NEGATIVE)                           # set the duty cycle to 30.2% and change the polarity to negative\ntim2_ch.period(2000000)                                            # change the period to 2 seconds\n```\n\n----------------------------------------\n\nTITLE: Using the Touch Sensor on LCD160CR Display\nDESCRIPTION: Shows how to detect touches on the display and get the touch coordinates. The display includes a resistive touch sensor that can report the position in pixels.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/lcd160cr_skin.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> lcd.is_touched()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> lcd.get_touch()\n```\n\n----------------------------------------\n\nTITLE: Blinking LED Example in MicroPython on Zephyr\nDESCRIPTION: This snippet demonstrates how to blink an LED using MicroPython on a Zephyr-supported board. It uses the machine.Pin class to control a GPIO pin and a loop with time.sleep() for timing.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/zephyr/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport time\nfrom machine import Pin\n\nLED = Pin((\"gpiob\", 21), Pin.OUT)\nwhile True:\n    LED.value(1)\n    time.sleep(0.5)\n    LED.value(0)\n    time.sleep(0.5)\n```\n\n----------------------------------------\n\nTITLE: Setting RTC Calibration\nDESCRIPTION: This snippet allows users to get or set the calibration value for the RTC. Adjusting calibration helps in fine-tuning the RTC's clock rate using a specific integer range for accurate timekeeping.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.RTC.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nrtc.calibration(cal)\n```\n\n----------------------------------------\n\nTITLE: ELF File Header Parsing Example\nDESCRIPTION: Example of using uctypes to parse a subset of an ELF file header, demonstrating basic structure definition and binary data access.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/uctypes.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport uctypes\n\nELF_HEADER = {\n    \"EI_MAG\": (0x0 | uctypes.ARRAY, 4 | uctypes.UINT8),\n    \"EI_DATA\": 0x5 | uctypes.UINT8,\n    \"e_machine\": 0x12 | uctypes.UINT16,\n}\n\nbuf = f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN))\nheader = uctypes.struct(uctypes.addressof(buf), ELF_HEADER, uctypes.LITTLE_ENDIAN)\nassert header.EI_MAG == b\"\\x7fELF\"\nassert header.EI_DATA == 1, \"Oops, wrong endianness. Could retry with uctypes.BIG_ENDIAN.\"\nprint(\"machine:\", hex(header.e_machine))\n```\n\n----------------------------------------\n\nTITLE: Continuous Sine Wave Output with 8-bit DAC\nDESCRIPTION: Creates and outputs a continuous sine wave at 400Hz using 8-bit resolution with circular buffer mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.DAC.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport math\nfrom pyb import DAC\n\n# create a buffer containing a sine-wave\nbuf = bytearray(100)\nfor i in range(len(buf)):\n    buf[i] = 128 + int(127 * math.sin(2 * math.pi * i / len(buf)))\n\n# output the sine-wave at 400Hz\ndac = DAC(1)\ndac.write_timed(buf, 400 * len(buf), mode=DAC.CIRCULAR)\n```\n\n----------------------------------------\n\nTITLE: I2C Device Scanning in MicroPython on Zephyr\nDESCRIPTION: This snippet demonstrates how to use the machine.I2C class to scan for I2C slave devices on the bus. It initializes an I2C interface and uses the scan() method to detect connected devices.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/zephyr/README.md#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import I2C\n\ni2c = I2C(\"i2c0\")\ni2c.scan()\n```\n\n----------------------------------------\n\nTITLE: Enabling WebREPL on ESP8266\nDESCRIPTION: Code to run the WebREPL setup utility via a serial connection. This is required to enable and configure WebREPL access before using it over WiFi.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/repl.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport webrepl_setup\n```\n\n----------------------------------------\n\nTITLE: Caching Object References\nDESCRIPTION: This code demonstrates how to cache object references within a method to avoid repeated lookups. By assigning `self.ba` and `obj_display.framebuffer` to local variables, the iterative code in the `bar()` method can access these objects more efficiently, improving performance.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/speed_python.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass foo(object):\n    def __init__(self):\n        self.ba = bytearray(100)\n    def bar(self, obj_display):\n        ba_ref = self.ba\n        fb = obj_display.framebuffer\n        # iterative code using these two objects\n```\n\n----------------------------------------\n\nTITLE: Compiling with Bluetooth Stack for nRF Series\nDESCRIPTION: Commands to download the Bluetooth LE stacks and headers, then compile the nRF port with Bluetooth support. Also shows how to flash the Bluetooth stack.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/README.md#2025-04-21_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n./drivers/bluetooth/download_ble_stack.sh\n\nmake BOARD=PCA10040 SD=s132\n\n# Flash the Bluetooth stack\nmake BOARD=PCA10040 SD=s132 sd\n```\n\n----------------------------------------\n\nTITLE: Using the Internal Switch on pyboard in MicroPython\nDESCRIPTION: Accessing and configuring the pyboard's onboard switch. The code demonstrates how to read the switch state and set up a callback function to toggle an LED when the switch is pressed.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import Switch\n\nsw = Switch()\nsw.value() # returns True or False\nsw.callback(lambda: pyb.LED(1).toggle())\n```\n\n----------------------------------------\n\nTITLE: Time Measurement Example - Microseconds\nDESCRIPTION: Example demonstrating microsecond time measurement using pyb.micros() and pyb.elapsed_micros() functions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nstart = pyb.micros()\nwhile pyb.elapsed_micros(start) < 1000:\n    # Perform some operation\n    pass\n```\n\n----------------------------------------\n\nTITLE: Directory Mounting\nDESCRIPTION: Command to mount local directory on remote device for development purposes\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote mount [options] <local-dir>\n```\n\n----------------------------------------\n\nTITLE: Accessing ESP32 RSSI and Peer Table\nDESCRIPTION: This snippet shows how to access the peer device table in an ESPNow object to track the RSSI and timestamp of peers, beneficial for applications that need to monitor signal strength and proximity. This is only applicable for ESP32 devices.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n{b'\\\\xaa\\\\xaa\\\\xaa\\\\xaa\\\\xaa\\\\xaa': [-31, 18372],\n b'\\\\xbb\\\\xbb\\\\xbb\\\\xbb\\\\xbb\\\\xbb': [-43, 12541]}\n```\n\n----------------------------------------\n\nTITLE: GPIO Pin Configuration and Control in MicroPython for i.MXRT\nDESCRIPTION: Code demonstrating how to configure and control GPIO pins on i.MXRT boards, including setting pins as inputs or outputs, reading values, and using internal pull-up resistors.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\n\np0 = Pin('D0', Pin.OUT) # create output pin on GPIO0\np0.on()                 # set pin to \"on\" (high) level\np0.off()                # set pin to \"off\" (low) level\np0.value(1)             # set pin to on/high\n\np2 = Pin('D2', Pin.IN)  # create input pin on GPIO2\nprint(p2.value())       # get value, 0 or 1\n\np4 = Pin('D4', Pin.IN, Pin.PULL_UP) # enable internal pull-up resistor\np5 = Pin('D5', Pin.OUT, value=1) # set pin high on creation\n\np6 = Pin(pin.cpu.GPIO_B1_15, Pin.OUT) # Use the cpu pin name.\n```\n\n----------------------------------------\n\nTITLE: Displaying Hello World Text on SSD1306 OLED in MicroPython\nDESCRIPTION: Writes 'Hello, World!' text to the first line of the SSD1306 display and refreshes the display to show the text. Uses the text() method to write at position (0,0) with color 1 (white).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/ssd1306.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndisplay.text('Hello, World!', 0, 0, 1)\ndisplay.show()\n```\n\n----------------------------------------\n\nTITLE: NeoPixel Animation Demo Function\nDESCRIPTION: Demonstration function showing various LED animation patterns including cycling, bouncing, and fading effects\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/neopixel.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\ndef demo(np):\n    n = np.n\n\n    # cycle\n    for i in range(4 * n):\n        for j in range(n):\n            np[j] = (0, 0, 0)\n        np[i % n] = (255, 255, 255)\n        np.write()\n        time.sleep_ms(25)\n\n    # bounce\n    for i in range(4 * n):\n        for j in range(n):\n            np[j] = (0, 0, 128)\n        if (i // n) % 2 == 0:\n            np[i % n] = (0, 0, 0)\n        else:\n            np[n - 1 - (i % n)] = (0, 0, 0)\n        np.write()\n        time.sleep_ms(60)\n\n    # fade in/out\n    for i in range(0, 4 * 256, 8):\n        for j in range(n):\n            if (i // 256) % 2 == 0:\n                val = i & 0xff\n            else:\n                val = 255 - (i & 0xff)\n            np[j] = (val, 0, 0)\n        np.write()\n\n    # clear\n    for i in range(n):\n        np[i] = (0, 0, 0)\n    np.write()\n```\n\n----------------------------------------\n\nTITLE: RTC Initialization and Date/Time Management\nDESCRIPTION: Utilizes the machine.RTC class to set up real-time clocks on Renesas RA boards. This example shows how to initialize the RTC and set or get the current date and time.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/quickref.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import RTC\n\nrtc = RTC()\nrtc.datetime((2017, 8, 23, 0, 1, 12, 48, 0)) # set a specific date and\n                                             # time, eg. 2017/8/23 1:12:48\n                                             # the day-of-week value is ignored\nrtc.datetime() # get date and time\n```\n\n----------------------------------------\n\nTITLE: Using DAC in MicroPython on ESP32\nDESCRIPTION: Shows how to use the Digital to Analog Converter (DAC) on ESP32 using the machine.DAC class. DAC functionality is available on specific pins depending on the ESP32 variant.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import DAC, Pin\n\ndac = DAC(Pin(25))  # create an DAC object acting on a pin\ndac.write(128)      # set a raw analog value in the range 0-255, 50% now\n```\n\n----------------------------------------\n\nTITLE: Deploying Firmware using MicroPython Make System for Arduino Giga\nDESCRIPTION: This command uses the MicroPython make system to build and deploy firmware for the Arduino Giga board. It specifies the board type as ARDUINO_GIGA.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/ARDUINO_GIGA/deploy.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake BOARD=ARDUINO_GIGA deploy\n```\n\n----------------------------------------\n\nTITLE: Connecting to MicroPython REPL on Linux using screen command\nDESCRIPTION: Command to connect to the MicroPython REPL prompt on Linux using the screen utility, targeting the typical USB device path for pyboard.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/repl.rst#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nscreen /dev/ttyACM0\n```\n\n----------------------------------------\n\nTITLE: Configuring WM8960 for MIMXRT10xx_DEV Board in Slave Mode\nDESCRIPTION: Sets up the WM8960 in slave mode for a MIMXRT10xx_DEV board with 16kHz sample rate. Swaps input channels to route the microphone (connected to right input) to the left audio channel. Uses DAC sync and MCLK as the system clock source.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/wm8960.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, I2C\nimport wm8960\ni2c = I2C(0)\nwm=wm8960.WM8960(i2c, sample_rate=16_000,\n    adc_sync=wm8960.SYNC_DAC,\n    swap=wm8960.SWAP_INPUT,\n    sysclk_source=wm8960.SYSCLK_MCLK)\n```\n\n----------------------------------------\n\nTITLE: Implementing USB Device Firmware Update Protocol in Python\nDESCRIPTION: This snippet demonstrates the implementation of the USB Device Firmware Update (DFU) protocol using the low-level machine.USBDevice class. It is designed to enable firmware updates over USB. The implementation might depend on the MicroPython environment that supports the USBDevice class functionalities.\nSOURCE: https://github.com/micropython/micropython/blob/master/examples/usb/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n## usb_dfu_device.py\n\n# Implementation of the USB Device Firmware Update protocol.\n\n```\n\n----------------------------------------\n\nTITLE: Network Interface Configuration in MicroPython\nDESCRIPTION: Shows how to configure network interface parameters including IP address, subnet mask, gateway and DNS server using the ifconfig method.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.WLAN.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnic.ifconfig(('192.168.0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))\n```\n\n----------------------------------------\n\nTITLE: Initializing Software I2C in MicroPython\nDESCRIPTION: This code snippet shows how to initialize and use a Software I2C (Inter-Integrated Circuit) bus in MicroPython. It creates a SoftI2C object with specified pin assignments for SCL (Serial Clock) and SDA (Serial Data), along with a frequency setting. The snippet demonstrates scanning for devices, reading from a device, and writing to a device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SoftI2C\n\ni2c = SoftI2C(scl=Pin('D5'), sda=Pin('D4'), freq=100000)\n\ni2c.scan()              # scan for devices\n\ni2c.readfrom(0x3a, 4)   # read 4 bytes from device with address 0x3a\ni2c.writeto(0x3a, '12') # write '12' to device with address 0x3a\n\nbuf = bytearray(10)     # create a buffer with 10 bytes\ni2c.writeto(0x3a, buf)  # write the given buffer to the slave\n```\n\n----------------------------------------\n\nTITLE: Sending Data Over USB HID in MicroPython\nDESCRIPTION: This method sends data over the USB HID interface. The 'data' parameter should be a tuple, list of integers, or a bytearray representing the data to be sent. It is essential to format the data correctly for successful transmission.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.USB_HID.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef send(data):\n   \"\"\"Send data over the USB HID interface:\n     - ``data`` is the data to send (a tuple/list of integers, or a\n       bytearray).\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: WiFi Access Point Configuration in MicroPython\nDESCRIPTION: Demonstrates how to configure WiFi access point parameters such as SSID and channel using the config method. Shows both setting and querying configuration values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.WLAN.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Set WiFi access point name (formally known as SSID) and WiFi channel\nap.config(ssid='My AP', channel=11)\n# Query params one by one\nprint(ap.config('ssid'))\nprint(ap.config('channel'))\n```\n\n----------------------------------------\n\nTITLE: Using OneWire Protocol in MicroPython on SAMD21/SAMD51\nDESCRIPTION: This snippet shows how to use the OneWire protocol for communication with devices like DS18x20 temperature sensors. It demonstrates bus initialization, device scanning, and temperature reading.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\nimport onewire\n\now = onewire.OneWire(Pin('D12')) # create a OneWire bus on GPIO12\now.scan()                     # return a list of devices on the bus\now.reset()                    # reset the bus\now.readbyte()                 # read a byte\now.writebyte(0x12)            # write a byte on the bus\now.write('123')               # write bytes on the bus\now.select_rom(b'12345678')    # select a specific device by its ROM code\n\n# Using DS18x20 temperature sensor\nimport time, ds18x20\nds = ds18x20.DS18X20(ow)\nroms = ds.scan()\nds.convert_temp()\ntime.sleep_ms(750)\nfor rom in roms:\n    print(ds.read_temp(rom))\n```\n\n----------------------------------------\n\nTITLE: Configuring GPIO Pins - Python\nDESCRIPTION: This snippet shows how to configure GPIO pins on the WiPy using the MicroPython machine module. It includes setting up a pin and enabling interrupts.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Pin\n\ng = machine.Pin('GP9', mode=Pin.OUT, pull=None, drive=Pin.MED_POWER, alt=-1)\n```\n\n----------------------------------------\n\nTITLE: Comparing Data Structure Memory Efficiency in MicroPython\nDESCRIPTION: Demonstrates how bytes objects use less memory than lists or tuples of integers. This example shows three ways to pass data to a function, with increasing memory efficiency.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef foo(bar):\n    for x in bar:\n        print(x)\nfoo([1, 2, 0xff])\nfoo((1, 2, 0xff))\nfoo(b'\\1\\2\\xff')\n```\n\n----------------------------------------\n\nTITLE: Querying Switch Status on Pyboard\nDESCRIPTION: These snippets demonstrate two methods to query whether the USR switch on a pyboard is pressed. The switch() and value() methods return a boolean indicating the switch's current state. These methods require that a Switch object has already been instantiated.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/switch.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> sw.value()\nFalse\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> sw()\nFalse\n```\n\n----------------------------------------\n\nTITLE: Reading ADC Values with MicroPython\nDESCRIPTION: This code snippet demonstrates how to initialize and read analog values using the ADC (Analog to Digital Converter) class in MicroPython. It sets up an ADC object on a specified pin and then reads the analog value, returning a 16-bit unsigned integer representing the voltage level.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import ADC\n\nadc = ADC(Pin('A2'))        # create ADC object on ADC pin\nadc.read_u16()              # read value, 0-65535 across voltage range 0.0v - 3.3v\n```\n\n----------------------------------------\n\nTITLE: Creating a Hybrid Filesystem on STM32 in MicroPython\nDESCRIPTION: Sets up a hybrid filesystem configuration on STM32/Pyboard devices with the first 256KB as FAT (accessible over USB MSC) and the remainder as littlefs. This combines USB accessibility with resilience to power failure.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport os, vfs, pyb\nvfs.umount('/flash')\np1 = pyb.Flash(start=0, len=256*1024)\np2 = pyb.Flash(start=256*1024)\nvfs.VfsFat.mkfs(p1)\nvfs.VfsLfs2.mkfs(p2)\nvfs.mount(p1, '/flash')\nvfs.mount(p2, '/data')\nos.chdir('/flash')\n```\n\n----------------------------------------\n\nTITLE: Graphics Primitives for SSD1306 OLED Using FrameBuffer in MicroPython\nDESCRIPTION: Shows how to use FrameBuffer graphics primitives with the SSD1306 display. Includes examples of filling the screen, setting/getting pixels, drawing lines and rectangles, displaying text, scrolling, and blitting another FrameBuffer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/ssd1306.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndisplay.fill(0)                         # fill entire screen with colour=0\ndisplay.pixel(0, 10)                    # get pixel at x=0, y=10\ndisplay.pixel(0, 10, 1)                 # set pixel at x=0, y=10 to colour=1\ndisplay.hline(0, 8, 4, 1)               # draw horizontal line x=0, y=8, width=4, colour=1\ndisplay.vline(0, 8, 4, 1)               # draw vertical line x=0, y=8, height=4, colour=1\ndisplay.line(0, 0, 127, 63, 1)          # draw a line from 0,0 to 127,63\ndisplay.rect(10, 10, 107, 43, 1)        # draw a rectangle outline 10,10 to 117,53, colour=1\ndisplay.fill_rect(10, 10, 107, 43, 1)   # draw a solid rectangle 10,10 to 117,53, colour=1\ndisplay.text('Hello World', 0, 0, 1)    # draw some text at x=0, y=0, colour=1\ndisplay.scroll(20, 0)                   # scroll 20 pixels to the right\n\n# draw another FrameBuffer on top of the current one at the given coordinates\nimport framebuf\nfbuf = framebuf.FrameBuffer(bytearray(8 * 8 * 1), 8, 8, framebuf.MONO_VLSB)\nfbuf.line(0, 0, 7, 7, 1)\ndisplay.blit(fbuf, 10, 10, 0)           # draw on top at x=10, y=10, key=0\ndisplay.show()\n```\n\n----------------------------------------\n\nTITLE: Creating a Tilt Detector with Accelerometer in MicroPython\nDESCRIPTION: This code creates a tilt detector that turns on an LED when the board is tilted beyond a certain threshold. It uses the accelerometer's x-axis value and compares it against a defined sensitivity value.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/accel.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\naccel = pyb.Accel()\nlight = pyb.LED(3)\nSENSITIVITY = 3\n\nwhile True:\n    x = accel.x()\n    if abs(x) > SENSITIVITY:\n        light.on()\n    else:\n        light.off()\n\n    pyb.delay(100)\n```\n\n----------------------------------------\n\nTITLE: Mounting Custom Partition in MicroPython on ESP32\nDESCRIPTION: This code snippet demonstrates how to mount a custom partition named 'foo' at the '/foo' mount point in MicroPython on ESP32. It uses the esp32 module to find the partition and the vfs module to mount it.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nimport esp32, vfs\np = esp32.Partition.find(esp32.Partition.TYPE_DATA, label='foo')\nvfs.mount(p, '/foo')\n```\n\n----------------------------------------\n\nTITLE: Executing MicroPython Command in Shell\nDESCRIPTION: This shell command demonstrates how to execute MicroPython with various options. The options include running Python code, modules, or scripts, setting optimization levels, verbosity, and interactive inspection. Key parameters include '-c' for commands, '-m' for modules, and '<script>' for script files. This command is useful for automating or customizing MicroPython execution according to specific needs.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/unix/quickref.rst#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmicropython [ -h ] [ -i ] [ -O<level> ] [ -v ] [ -X <option> ] [ -c <command> | -m <module> | <script> ] [ <args> ]\n```\n\n----------------------------------------\n\nTITLE: Implementing DMA Chaining and Register Triggering with MicroPython\nDESCRIPTION: This Python code snippet demonstrates the use of MicroPython to implement DMA channel chaining and register triggering on the RP2040. It utilizes two DMA channels where the first channel sends lengths and source addresses from a list to the second channel, which handles the data copying. This is achieved without CPU intervention by manipulating the DMA channel control registers. Dependencies include the rp2 and uctypes modules in MicroPython. The primary inputs are a list of strings to gather and a buffer to store the output. The output is a bytearray containing the concatenated data from the input strings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/rp2.DMA.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom rp2 import DMA\nfrom uctypes import addressof\nfrom array import array\n\ndef gather_strings(string_list, buf):\n    # We use two DMA channels. The first sends lengths and source addresses from the gather\n    # list to the registers of the second. The second copies the data itself.\n    gather_dma = DMA()\n    buffer_dma = DMA()\n\n    # Pack up length/address pairs to be sent to the registers.\n    gather_list = array(\"I\")\n\n    for s in string_list:\n        gather_list.append(len(s))\n        gather_list.append(addressof(s))\n\n    gather_list.append(0)\n    gather_list.append(0)\n\n    # When writing to the registers of the second DMA channel, we need to wrap the\n    # write address on an 8-byte (1<<3 bytes) boundary. We write to the ``TRANS_COUNT``\n    # and ``READ_ADD_TRIG`` registers in the last register alias (registers 14 and 15).\n    gather_ctrl = gather_dma.pack_ctrl(ring_size=3, ring_sel=True)\n    gather_dma.config(\n        read=gather_list, write=buffer_dma.registers[14:16],\n        count=2, ctrl=gather_ctrl\n    )\n\n    # When copying the data, the transfer size is single bytes, and when completed we need\n    # to chain back to the start another gather DMA transaction.\n    buffer_ctrl = buffer_dma.pack_ctrl(size=0, chain_to=gather_dma.channel)\n    # The read and count values will be set by the other DMA channel.\n    buffer_dma.config(write=buf, ctrl=buffer_ctrl)\n\n    # Set the transfer in motion.\n    gather_dma.active(1)\n\n    # Wait until all the register values have been sent\n    end_address = addressof(gather_list) + 4 * len(gather_list)\n    while gather_dma.read != end_address:\n        pass\n\ninput = [\"This is \", \"a \", \"test\", \" of the scatter\", \" gather\", \" process\"]\noutput = bytearray(64)\n\nprint(output)\ngather_strings(input, output)\nprint(output)\n```\n\n----------------------------------------\n\nTITLE: Initializing Hardware I2C in MicroPython\nDESCRIPTION: This code snippet demonstrates how to initialize and use a Hardware I2C (Inter-Integrated Circuit) bus in MicroPython. It creates an I2C object with a specified ID and frequency, then writes data to a device on the I2C bus.  It also shows how to initialize I2C using only the frequency, implying the default I2C ID.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2C\n\ni2c = I2C(0, 400_000)\ni2c.writeto(0x76, b\"Hello World\")\ni2c = I2C(freq=100_000)  # use I2C(0) at 100kHz\n```\n\n----------------------------------------\n\nTITLE: RMT Module Method Examples\nDESCRIPTION: Method signatures and usage examples for the RMT (Remote Control) module, including pulse transmission and looping configuration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp32.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nRMT.loop(enable_loop)\nRMT.write_pulses(duration, data=True)\nRMT.bitstream_channel([value])\n```\n\n----------------------------------------\n\nTITLE: PWM Configuration Examples for Teensy Boards using MicroPython\nDESCRIPTION: Examples of PWM (Pulse Width Modulation) configuration on Teensy boards running MicroPython, demonstrating simple PWM output, complementary signal pairs, and synchronized signal groups.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Samples for Teensy\n#\n\nfrom machine import Pin, PWM\n\n# create PWM object from a pin and set the frequency and duty cycle\npwm2 = PWM(Pin('D2'), freq=2000, duty_u16=32768)\npwm2.freq()             # get the current frequency\npwm2.freq(1000)         # set/change the frequency\npwm2.duty_u16()         # get the current duty cycle, range 0-65535\npwm2.duty_u16(200)      # set the duty cycle, range 0-65535\npwm2.deinit()           # turn off PWM on the pin\n# create a complementary signal pair on Pin 2 and 3\npwm2 = PWM(('D2', 'D3'), freq=2000, duty_ns=20000)\n\n# Create a group of four synchronized signals.\n# Start with Pin('D4') at submodule 0, which creates the sync pulse.\npwm4 = PWM(Pin('D4'), freq=1000, align=PWM.HEAD)\n# Pins D5, D6, and D9 are pins at the same module\npwm5 = PWM(Pin('D5'), freq=1000, duty_u16=10000, align=PWM.HEAD, sync=True)\npwm6 = PWM(Pin('D6', freq=1000, duty_u16=20000, align=PWM.HEAD, sync=True)\npwm9 = PWM(Pin('D9'), freq=1000, duty_u16=30000, align=PWM.HEAD, sync=True)\n\npwm3                    # show the PWM objects properties\n```\n\n----------------------------------------\n\nTITLE: Decrypting Data with AES in MicroPython\nDESCRIPTION: This method decrypts the input buffer using the initialized AES cipher. It functions similarly to the encrypt method, allowing for in-place decryption or writing to a separate output buffer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/cryptolib.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndecrypt(in_buf, [out_buf])\n```\n\n----------------------------------------\n\nTITLE: Basic I2C Send and Receive Operations in MicroPython\nDESCRIPTION: This snippet shows how to perform basic send and receive operations using I2C in MicroPython, including sending bytes and receiving them into pre-defined buffers. Dependencies include the pyb library, with inputs being the data to send or receive and any applicable timeouts.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.I2C.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ni2c.send('abc')      # send 3 bytes\ni2c.send(0x42)       # send a single byte, given by the number\ndata = i2c.recv(3)   # receive 3 bytes\ndata = bytearray(3)  # create a buffer\ni2c.recv(data)       # receive 3 bytes, writing them into data\n```\n\n----------------------------------------\n\nTITLE: Importing and Using the Machine Module in MicroPython for ESP8266\nDESCRIPTION: Demonstrates how to import the machine module and use it to get and set the CPU frequency on an ESP8266 board.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport machine\n\nmachine.freq()          # get the current frequency of the CPU\nmachine.freq(160000000) # set the CPU frequency to 160 MHz\n```\n\n----------------------------------------\n\nTITLE: Encrypting Data with AES in MicroPython\nDESCRIPTION: This method encrypts the input buffer using the initialized AES cipher. It can return the result as a new bytes object or write it to a provided output buffer. In-place encryption is also supported.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/cryptolib.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nencrypt(in_buf, [out_buf])\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython under Cygwin\nDESCRIPTION: Build commands for compiling MicroPython using Cygwin for both 32-bit and 64-bit Windows targets.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/windows/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake -C ../../mpy-cross CROSS_COMPILE=i686-w64-mingw32-\nmake CROSS_COMPILE=i686-w64-mingw32-\n```\n\n----------------------------------------\n\nTITLE: Executing Python code\nDESCRIPTION: Command to execute Python code on the connected device, with an option to run it in the background without waiting for completion.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote exec <string>\n```\n\n----------------------------------------\n\nTITLE: Random Integer in Range in MicroPython\nDESCRIPTION: Returns a random integer in the closed interval [a, b], including both endpoints.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/random.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nrandint(a, b)\n```\n\n----------------------------------------\n\nTITLE: Serial Communication with machine.UART\nDESCRIPTION: This snippet demonstrates basic UART communication using the machine.UART class on Renesas RA boards, showing how to initialize UART with specific baud rates and perform basic read/write operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/quickref.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import UART\n\nuart1 = UART(1, 115200)\nuart1.write('hello')    # write 5 bytes\nuart1.read(5)           # read up to 5 bytes\n```\n\n----------------------------------------\n\nTITLE: LED Fading Implementation with PWM\nDESCRIPTION: Creates a PWM object for LED control and defines a pulse function that uses sine wave math to create a smooth fading effect.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pwm.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> led = machine.PWM(machine.Pin(2), freq=1000)\n>>> import time, math\n>>> def pulse(l, t):\n...     for i in range(20):\n...         l.duty(int(math.sin(i / 10 * math.pi) * 500 + 500))\n...         time.sleep_ms(t)\n```\n\n----------------------------------------\n\nTITLE: Using RTC in MicroPython for ESP8266\nDESCRIPTION: Demonstrates how to use the machine.RTC class to work with the Real Time Clock on an ESP8266 board. Shows setting and getting date and time, and synchronizing with NTP.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import RTC\n\nrtc = RTC()\nrtc.datetime((2017, 8, 23, 0, 1, 12, 48, 0)) # set a specific date and\n                                                # time, eg. 2017/8/23 1:12:48\n                                                # the day-of-week value is ignored\nrtc.datetime() # get date and time\n\n# synchronize with ntp\n# need to be connected to wifi\nimport ntptime\nntptime.settime() # set the rtc datetime from the remote server\nrtc.datetime()    # get the date and time in UTC\n```\n\n----------------------------------------\n\nTITLE: WDT Constructor Signature\nDESCRIPTION: Constructor definition for the WDT class showing the default parameters. The id parameter defaults to 0, and the timeout parameter defaults to 5000 milliseconds. Note that esp8266 doesn't support custom timeouts, and rp2040 has a maximum timeout of 8388ms.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.WDT.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nWDT(id=0, timeout=5000)\n```\n\n----------------------------------------\n\nTITLE: Entering Deep Sleep on ESP8266 in MicroPython\nDESCRIPTION: Function to enter deep sleep mode on ESP8266. The entire module powers down except for the RTC clock circuit. It can restart after a specified time if pin 16 is connected to the reset pin.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndeepsleep(time_us=0, /)\n```\n\n----------------------------------------\n\nTITLE: Enabling and Feeding the Watchdog Timer on WiPy\nDESCRIPTION: This code snippet demonstrates enabling a watchdog timer on the WiPy board with a specified timeout. It also includes the method to periodically feed the watchdog to prevent it from resetting the device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import WDT\n\n# enable the WDT with a timeout of 5s (1s is the minimum)\nwdt = WDT(timeout=5000)\nwdt.feed()\n```\n\n----------------------------------------\n\nTITLE: Pin Change IRQ Handling in MicroPython on Zephyr\nDESCRIPTION: This example shows how to set up and respond to Pin change interrupts using MicroPython on a FRDM-K64F board. It demonstrates the use of Pin.irq() method to attach interrupt handlers.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/zephyr/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Pin\n\nSW2 = Pin((\"gpioc\", 6), Pin.IN)\nSW3 = Pin((\"gpioa\", 4), Pin.IN)\n\nSW2.irq(lambda t: print(\"SW2 changed\"))\nSW3.irq(lambda t: print(\"SW3 changed\"))\n\nwhile True:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Calling MicroPython Bootloader in Python\nDESCRIPTION: This code snippet demonstrates how to programmatically start the UF2 bootloader from within MicroPython. It uses the machine.bootloader() function, which can be called from the REPL or a Python script.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/mimxrt/boards/deploy_mimxrt.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmachine.bootloader()\n```\n\n----------------------------------------\n\nTITLE: Using Board-specific Module in MicroPython for WeAct Studio RP2040\nDESCRIPTION: This Python code snippet demonstrates how to use the board module to control the onboard LED and read the state of the user button on the WeAct Studio RP2040 Board. It includes examples of toggling the LED and reading the button state.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/boards/WEACTSTUDIO/README.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n> import board\n> board.led.toggle()  # Toggles the state of the on-board LED\n> board.key.value()  # Returns 0 or 1 corresponding to the state of the user key\n```\n\n----------------------------------------\n\nTITLE: Determining MicroPython System's .mpy Compatibility Information\nDESCRIPTION: This snippet shows how to determine the .mpy version, sub-version, and architecture flags supported by your MicroPython system. It extracts this information from sys.implementation._mpy and prints it in a human-readable format.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpyfiles.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nsys_mpy = sys.implementation._mpy\narch = [None, 'x86', 'x64',\n    'armv6', 'armv6m', 'armv7m', 'armv7em', 'armv7emsp', 'armv7emdp',\n    'xtensa', 'xtensawin', 'rv32imc'][sys_mpy >> 10]\nprint('mpy version:', sys_mpy & 0xff)\nprint('mpy sub-version:', sys_mpy >> 8 & 3)\nprint('mpy flags:', end='')\nif arch:\n    print(' -march=' + arch, end='')\nprint()\n```\n\n----------------------------------------\n\nTITLE: Using OSError errno codes in MicroPython\nDESCRIPTION: The convention for MicroPython operations is to return 0 on success and a non-zero OSError errno code on failure. This allows for consistent error handling across the MicroPython codebase.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/vfs.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nOSError\n```\n\n----------------------------------------\n\nTITLE: GPIO Polling with Timeout\nDESCRIPTION: Example showing how to implement a timeout while polling a GPIO pin using ticks_diff()\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/time.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nstart = time.ticks_us()\nwhile pin.value() == 0:\n    if time.ticks_diff(time.ticks_us(), start) > 500:\n        raise TimeoutError\n```\n\n----------------------------------------\n\nTITLE: Mounting a Secondary Partition in boot.py on STM32 in MicroPython\nDESCRIPTION: Code to add to boot.py for mounting a secondary partition at system startup on STM32/Pyboard devices. This example mounts a littlefs partition that starts at the 256KB offset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport vfs, pyb\np2 = pyb.Flash(start=256*1024)\nvfs.mount(p2, '/data')\n```\n\n----------------------------------------\n\nTITLE: Updating NeoPixel Display\nDESCRIPTION: Sends the color data to the LED strip to update the physical display\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/neopixel.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnp.write()\n```\n\n----------------------------------------\n\nTITLE: Creating Simple Animation on LCD Display in MicroPython\nDESCRIPTION: Code to create a simple animation on the LCD by scrolling text across the screen. Uses a loop to redraw the text at different horizontal positions with a short delay between frames.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/lcd_skin.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pyb\nlcd = pyb.LCD('X')\nlcd.light(True)\nfor x in range(-80, 128):\n    lcd.fill(0)\n    lcd.text('Hello uPy!', x, 10, 1)\n    lcd.show()\n    pyb.delay(25)\n```\n\n----------------------------------------\n\nTITLE: Assigning Static IP Address on Boot in MicroPython\nDESCRIPTION: This code snippet shows how to configure a WiPy device to connect to a home router with a fixed IP address after boot-up. It checks the reset cause, initializes the WLAN in STA mode, sets the IP configuration (address, gateway, DNS), and attempts to connect to the specified Wi-Fi network. This is typically placed in `/flash/boot.py`.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/wlan.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport machine, network\nfrom network import WLAN\nwlan = WLAN() # get current object, without changing the mode\n\nif machine.reset_cause() != machine.SOFT_RESET:\n    wlan.init(WLAN.STA)\n    # configuration below MUST match your home router settings!!\n    network.ipconfig(dns='8.8.8.8')\n    wlan.ipconfig(addr4='192.168.0.107/24', gw4='192.168.0.1')\n\nif not wlan.isconnected():\n    # change the line below to match your network ssid, security and password\n    wlan.connect('mywifi', auth=(WLAN.WPA2, 'mywifikey'), timeout=5000)\n    while not wlan.isconnected():\n        machine.idle() # save power while waiting\n```\n\n----------------------------------------\n\nTITLE: Installing from package.json with mip in MicroPython\nDESCRIPTION: Examples of installing packages by specifying the path to a package.json file, which can include multiple files and dependencies.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> mip.install(\"http://example.com/x/package.json\")\n>>> mip.install(\"github:org/user/path/package.json\")\n>>> mip.install(\"gitlab:org/user/path/package.json\")\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Software I2C in MicroPython\nDESCRIPTION: Demonstrates how to initialize and use software I2C (Inter-Integrated Circuit) in MicroPython. It covers scanning for devices, reading from and writing to I2C devices.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SoftI2C\n\ni2c = SoftI2C(scl=Pin(5), sda=Pin(4), freq=100_000)\n\ni2c.scan()              # scan for devices\n\ni2c.readfrom(0x3a, 4)   # read 4 bytes from device with address 0x3a\ni2c.writeto(0x3a, '12') # write '12' to device with address 0x3a\n\nbuf = bytearray(10)     # create a buffer with 10 bytes\ni2c.writeto(0x3a, buf)  # write the given buffer to the peripheral\n```\n\n----------------------------------------\n\nTITLE: Device Reset\nDESCRIPTION: Command to perform hard reset of the device\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote reset\n```\n\n----------------------------------------\n\nTITLE: LED Sequence with Exception Handling in MicroPython\nDESCRIPTION: Implements a full LED sequence with proper initialization and cleanup using a try/finally block. This ensures all LEDs are turned off when the script is interrupted, demonstrating proper resource management in MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/leds.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nleds = [pyb.LED(i) for i in range(1,5)]\nfor l in leds:\n    l.off()\n\nn = 0\ntry:\n   while True:\n      n = (n + 1) % 4\n      leds[n].toggle()\n      pyb.delay(50)\nfinally:\n    for l in leds:\n        l.off()\n```\n\n----------------------------------------\n\nTITLE: Single Character UART Operations in MicroPython\nDESCRIPTION: Methods for reading and writing individual characters through UART interface\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.UART.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nuart.readchar()     # read 1 character and returns it as an integer\nuart.writechar(42)  # write 1 character\n```\n\n----------------------------------------\n\nTITLE: Installing Packages with mip from REPL in MicroPython\nDESCRIPTION: Examples of using the 'mip' module from the REPL to install packages from micropython-lib or third-party sources. Shows basic installation, version specification, source installation, and custom target directory usage.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import mip\n>>> mip.install(\"pkgname\")  # Installs the latest version of \"pkgname\" (and dependencies)\n>>> mip.install(\"pkgname\", version=\"x.y\")  # Installs version x.y of \"pkgname\"\n>>> mip.install(\"pkgname\", mpy=False)  # Installs the source version (i.e. .py rather than .mpy files)\n```\n\n----------------------------------------\n\nTITLE: Setting Sleep Type for ESP8266 in MicroPython\nDESCRIPTION: Function to get or set the sleep type on ESP8266. It accepts an optional sleep_type parameter and returns the current sleep type if called without parameters. Sleep types are defined as constants: SLEEP_NONE, SLEEP_MODEM, and SLEEP_LIGHT.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsleep_type([sleep_type])\n```\n\n----------------------------------------\n\nTITLE: Setting Network Configuration\nDESCRIPTION: Example of configuring network parameters including IP address, subnet mask, gateway and DNS server.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.LAN.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnic.ifconfig(('192.168.0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))\n```\n\n----------------------------------------\n\nTITLE: Initializing Hardware SPI in MicroPython\nDESCRIPTION: This code snippet demonstrates how to initialize and use a Hardware SPI (Serial Peripheral Interface) bus in MicroPython. It creates an SPI object with a specified ID and baud rate, then controls a chip select (CS) pin to communicate with a slave device. The example includes writing data to the SPI bus.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import SPI, Pin\n\nspi = SPI(0, 10000000)\ncs_pin = Pin('D6', Pin.OUT, value=1)\ncs_pin(0)\nspi.write('Hello World')\ncs_pin(1)\nspi = SPI(baudrate=4_000_000)  # Use SPI(0) at a baudrate of 4 MHz\n```\n\n----------------------------------------\n\nTITLE: Configuring General Board Control in MicroPython\nDESCRIPTION: Basic operations for controlling the pyboard including duplicating REPL on UART, pausing CPU, checking and setting CPU frequency, and stopping CPU. These functions provide fundamental control over the board's operation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pyb\n\npyb.repl_uart(pyb.UART(1, 9600)) # duplicate REPL on UART(1)\npyb.wfi() # pause CPU, waiting for interrupt\npyb.freq() # get CPU and bus frequencies\npyb.freq(60000000) # set CPU freq to 60MHz\npyb.stop() # stop CPU, waiting for external interrupt\n```\n\n----------------------------------------\n\nTITLE: Initializing a Pin for Zephyr\nDESCRIPTION: This code snippet demonstrates how to initialize a pin on Zephyr using a tuple of port and pin number for the id value. It sets the pin as an output. This is an example for the red LED on a FRDM-k64 board.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/tutorial/pins.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nLED = Pin((\"GPIO_1\", 22), Pin.OUT)\n```\n\n----------------------------------------\n\nTITLE: Implementing Deep Sleep Mode in MicroPython\nDESCRIPTION: Complete example of configuring and entering deep-sleep mode. Shows how to set up RTC alarm to wake the device after a specified time period.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/powerctrl.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport machine\n\n# configure RTC.ALARM0 to be able to wake the device\nrtc = machine.RTC()\nrtc.irq(trigger=rtc.ALARM0, wake=machine.DEEPSLEEP)\n\n# set RTC.ALARM0 to fire after 10 seconds (waking the device)\nrtc.alarm(rtc.ALARM0, 10000)\n\n# put the device to sleep\nmachine.deepsleep()\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython under MSYS2\nDESCRIPTION: Commands to install dependencies and build MicroPython using the MSYS2 environment.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/windows/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npacman -Syuu\npacman -S make mingw-w64-x86_64-gcc pkg-config mingw-w64-x86_64-python3\nmake -C ../../mpy-cross STRIP=echo SIZE=echo\nmake\n```\n\n----------------------------------------\n\nTITLE: Receiving Data Over USB HID in MicroPython\nDESCRIPTION: This method receives data on the USB HID interface. The 'data' parameter can either specify the number of bytes to receive as an integer, or a mutable buffer where received bytes will be stored. The 'timeout' parameter defines how long to wait for data in milliseconds. It returns either a new buffer of received bytes or the number of bytes read into the provided buffer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.USB_HID.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef recv(data, *, timeout=5000):\n   \"\"\"Receive data on the bus:\n     - ``data`` can be an integer, which is the number of bytes to receive,\n       or a mutable buffer, which will be filled with received bytes.\n     - ``timeout`` is the timeout in milliseconds to wait for the receive.\n   \"\"\"\n   Return value: if ``data`` is an integer then a new buffer of the bytes received,\n   otherwise the number of bytes read into ``data`` is returned.\n```\n\n----------------------------------------\n\nTITLE: Controlling Heartbeat LED on WiPy with MicroPython\nDESCRIPTION: This snippet provides methods for controlling the heartbeat LED on the WiPy board using the 'wipy' module. It demonstrates enabling, disabling, and checking the status of the LED's heartbeat indicator.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nimport wipy\n\nwipy.heartbeat(False)  # disable the heartbeat LED\nwipy.heartbeat(True)   # enable the heartbeat LED\nwipy.heartbeat()       # get the heartbeat state\n```\n\n----------------------------------------\n\nTITLE: Defining Pin Mode Constants in MicroPython\nDESCRIPTION: Constants used to select the pin mode in MicroPython. These include input, output, open drain, alternate function, and analog modes.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.Pin.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nPin.IN\nPin.OUT\nPin.OPEN_DRAIN\nPin.ALT\nPin.ALT_OPEN_DRAIN\nPin.ANALOG\n```\n\n----------------------------------------\n\nTITLE: Writing Blocks to Flash in MicroPython\nDESCRIPTION: Methods for writing blocks to the flash device. These methods implement the simple and extended block protocol defined by vfs.AbstractBlockDev.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Flash.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nFlash.writeblocks(block_num, buf)\nFlash.writeblocks(block_num, buf, offset)\n```\n\n----------------------------------------\n\nTITLE: Reading ADC Value on ESP8266 with MicroPython\nDESCRIPTION: Reads the current analog value from the ADC pin. Returns values between 0 (0.0V) and 1024 (1.0V). Note that the input voltage must not exceed 1.0V.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/adc.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nadc.read()\n```\n\n----------------------------------------\n\nTITLE: PHY Mode Configuration for ESP8266\nDESCRIPTION: Function to get or set the PHY (Physical Layer) mode for wireless networking on ESP8266 devices. Supports IEEE 802.11b, 802.11g, and 802.11n modes. Returns current mode when called without parameters.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nphy_mode([mode])\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Race Condition in MicroPython Interrupt Handling\nDESCRIPTION: This code example illustrates a potential race condition between the main loop and an interrupt callback when modifying a shared variable. It demonstrates the read-modify-write hazard in real-time systems.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/isr_rules.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncount = 0\ndef cb(): # An interrupt callback\n    count +=1\ndef main():\n    # Code to set up the interrupt callback omitted\n    while True:\n        count += 1\n```\n\n----------------------------------------\n\nTITLE: Installing Direct URL Files with mip in MicroPython\nDESCRIPTION: Examples of installing individual Python files directly from URLs using the mip module.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> mip.install(\"http://example.com/x/y/foo.py\")\n>>> mip.install(\"http://example.com/x/y/foo.mpy\")\n```\n\n----------------------------------------\n\nTITLE: Accessing CRC Generator with Full 32-bit Handling\nDESCRIPTION: Demonstrates a technique to overcome MicroPython's integer restrictions when working with the STM32 CRC generator. It uses assembly to store the result in an array and Python to convert it to an arbitrary precision unsigned integer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_hints_tips.rst#2025-04-21_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nfrom array import array\nimport stm\n\ndef enable_crc():\n    stm.mem32[stm.RCC + stm.RCC_AHB1ENR] |= 0x1000\n\ndef reset_crc():\n    stm.mem32[stm.CRC+stm.CRC_CR] = 1\n\n@micropython.asm_thumb\ndef getval(r0, r1):\n    movwt(r3, stm.CRC + stm.CRC_DR)\n    str(r1, [r3, 0])\n    ldr(r2, [r3, 0])\n    str(r2, [r0, 0])\n\ndef getcrc(value):\n    a = array('i', [0])\n    getval(a, value)\n    return a[0] & 0xffffffff # coerce to arbitrary precision\n\nenable_crc()\nreset_crc()\nfor x in range(20):\n    print(hex(getcrc(0)))\n```\n\n----------------------------------------\n\nTITLE: Telnet Access to WiPy - Python\nDESCRIPTION: This snippet provides a command-line example of how to connect to the WiPy's Telnet REPL via the standard telnet utility from a Linux shell. It allows for interaction with the device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n$ telnet 192.168.1.1\n```\n\n----------------------------------------\n\nTITLE: Setting Timer Period in MicroPython\nDESCRIPTION: Method for getting or setting the period of a timer. The period determines when the timer completes one cycle and resets.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nTimer.period([value])\n```\n\n----------------------------------------\n\nTITLE: ESPNow Interrupt Callback Handler\nDESCRIPTION: Example implementation of an interrupt callback function for handling received ESPNow messages efficiently.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef recv_cb(e):\n    while True:  # Read out all messages waiting in the buffer\n        mac, msg = e.irecv(0)  # Don't wait if no messages left\n        if mac is None:\n            return\n        print(mac, msg)\ne.irq(recv_cb)\n```\n\n----------------------------------------\n\nTITLE: Blinking LED on FRDM-K64F Board\nDESCRIPTION: Use this code snippet to blink an LED connected to GPIO pin 21 on the FRDM-K64F board using MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/tutorial/repl.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import time\n>>> from machine import Pin\n\n>>> LED = Pin((\"GPIO_1\", 21), Pin.OUT)\n>>> while True:\n...    LED.value(1)\n...    time.sleep(0.5)\n...    LED.value(0)\n...    time.sleep(0.5)\n```\n\n----------------------------------------\n\nTITLE: Defining Pull Resistor Constants in MicroPython\nDESCRIPTION: Constants used to select the pull-up or pull-down resistor configuration for a pin in MicroPython. Use None for no pull resistor.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.Pin.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nPin.PULL_UP\nPin.PULL_DOWN\nPin.PULL_HOLD\n```\n\n----------------------------------------\n\nTITLE: Toggling LED Using Switch Callback on Pyboard\nDESCRIPTION: This snippet sets a callback to toggle the red LED on the pyboard each time the USR switch is pressed. The lambda function calls the toggle method of the LED class. This demonstrates using hardware interrupts for controlling other components.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/switch.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> sw.callback(lambda:pyb.LED(1).toggle())\n```\n\n----------------------------------------\n\nTITLE: Mounting and Using SD Card (SPI) with VFS in MicroPython\nDESCRIPTION: This code snippet shows how to use a SPI-based SD card driver with VFS on boards without SDCard class support, like i.mx-rt 1011 and 1015. It initializes SPI, defines and controls the CS pin, creates an SDCard object using the custom driver, then mounts and accesses the SD card.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport vfs, sdcard, machine\n\ncs_pin = \"D10\"\nspi = machine.SPI(0) # SPI0 with cs at Pin \"D10\" used for SDCARD\ncs = machine.Pin(cs_pin, machine.Pin.OUT, value=1)\nsd = sdcard.SDCard(spi, cs)\nfs = vfs.VfsFat(sd)\nvfs.mount(fs, \"/sdcard\")\n```\n\n----------------------------------------\n\nTITLE: Firmware Upgrade Over FTP - Python\nDESCRIPTION: This snippet explains how to upgrade the WiPy firmware over the air by uploading a binary file via FTP. It also shows how to reset the device post-upload using MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n>>> import machine\n>>> machine.reset()\n```\n\n----------------------------------------\n\nTITLE: Controlling Multiple Servos Simultaneously\nDESCRIPTION: This snippet shows how to control multiple servo motors simultaneously by sending angle commands in a chain. The method allows for synchronized movements of two servos.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/servo.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> servo1.angle(-45, 2000); servo2.angle(60, 2000)\n```\n\n----------------------------------------\n\nTITLE: Using mip from Command Line in Unix Port of MicroPython\nDESCRIPTION: Examples of using the mip module via the command line with the MicroPython Unix port, including package installation with version specification.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ ./micropython -m mip install pkgname-or-url\n$ ./micropython -m mip install pkgname-or-url@version\n```\n\n----------------------------------------\n\nTITLE: Initializing USB VCP Class - Python\nDESCRIPTION: Constructor for creating a new USB_VCP object. Takes an optional id parameter to specify which USB VCP port to use.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.USB_VCP.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nUSB_VCP(id=0)\n```\n\n----------------------------------------\n\nTITLE: LAN Configuration Examples for ESP32 Boards\nDESCRIPTION: Sample configurations for ethernet connections on various ESP32 development boards\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Olimex ESP32-GATEWAY: power controlled by Pin(5)\n# Olimex ESP32 PoE and ESP32-PoE ISO: power controlled by Pin(12)\n\nlan = network.LAN(mdc=machine.Pin(23), mdio=machine.Pin(18), power=machine.Pin(5),\n                  phy_type=network.PHY_LAN8720, phy_addr=0,\n                  ref_clk=machine.Pin(17), ref_clk_mode=machine.Pin.OUT)\n\n# Wireless-Tag's WT32-ETH01\n\nlan = network.LAN(mdc=machine.Pin(23), mdio=machine.Pin(18),\n                  phy_type=network.PHY_LAN8720, phy_addr=1, power=None)\n\n# Wireless-Tag's WT32-ETH01 v1.4\n\nlan = network.LAN(mdc=machine.Pin(23), mdio=machine.Pin(18),\n                  phy_type=network.PHY_LAN8720, phy_addr=1,\n                  power=machine.Pin(16))\n\n# Espressif ESP32-Ethernet-Kit_A_V1.2\n\nlan = network.LAN(id=0, mdc=Pin(23), mdio=Pin(18), power=Pin(5),\n                  phy_type=network.PHY_IP101, phy_addr=1)\n```\n\n----------------------------------------\n\nTITLE: Closing Sockets Safely in Python\nDESCRIPTION: Demonstrates how to properly close a socket using a try/finally block to ensure the socket is closed even if an exception occurs. This helps prevent memory leaks and WiFi stack overflow issues.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/general.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsock = socket(...)\ntry:\n    # Use sock\nfinally:\n    sock.close()\n```\n\n----------------------------------------\n\nTITLE: Basic PPP Connection Example - Python\nDESCRIPTION: Demonstrates how to create and manage a PPP network connection using a UART stream. Shows connection establishment, status checking, and IP configuration retrieval.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.PPP.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport network\n\nppp = network.PPP(uart)\nppp.connect()\n\nwhile not ppp.isconnected():\n    pass\n\nprint(ppp.ipconfig(\"addr4\"))\n\n# use the socket module as usual, etc\n\nppp.disconnect()\n```\n\n----------------------------------------\n\nTITLE: Hardware SPI Bus Interaction - MicroPython\nDESCRIPTION: This snippet showcases how to configure and use the SPI bus using MicroPython's SPI class. It includes examples for reading and writing bytes, as well as buffer management with read and write operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/quickref.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import SPI\n\nspi = SPI(\"spi0\")           # construct a spi bus with default configuration\nspi.init(baudrate=100000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB) # set configuration\n\n# equivalently, construct spi bus and set configuration at the same time\nspi = SPI(\"spi0\", baudrate=100000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB)\nprint(spi)                  # print device name and bus configuration\n\nspi.read(4)                 # read 4 bytes on MISO\nspi.read(4, write=0xF)      # read 4 bytes while writing 0xF on MOSI\n\nbuf = bytearray(8)          # create a buffer of size 8\nspi.readinto(buf)           # read into the buffer (reads number of bytes equal to the buffer size)\nspi.readinto(buf, 0xF)      # read into the buffer while writing 0xF on MOSI\n\nspi.write(b'abcd')          # write 4 bytes on MOSI\n\nbuf = bytearray(4)                  # create buffer of size 8\nspi.write_readinto(b'abcd', buf)    # write to MOSI and read from MISO into the buffer\nspi.write_readinto(buf, buf)        # write buf to MOSI and read back into the buf\n```\n\n----------------------------------------\n\nTITLE: GPIO Pin Control Example using STM32 Peripheral Registers in Python\nDESCRIPTION: Demonstrates how to set GPIO pin states and read pin values using direct memory access to peripheral registers. Shows setting PA2 high and reading PA3 state.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/stm.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# set PA2 high\nstm.mem32[stm.GPIOA + stm.GPIO_BSRR] = 1 << 2\n\n# read PA3\nvalue = (stm.mem32[stm.GPIOA + stm.GPIO_IDR] >> 3) & 1\n```\n\n----------------------------------------\n\nTITLE: Configuring WLANWiPy as Access Point in MicroPython\nDESCRIPTION: This example shows how to initialize and configure the WLANWiPy object as an access point. It sets the SSID, authentication method, channel, and antenna type.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.WLANWiPy.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# create and configure as an access point\nwlan.init(mode=WLAN.AP, ssid='wipy-wlan', auth=(WLAN.WPA2,'www.wipy.io'), channel=7, antenna=WLAN.INT_ANT)\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project for MicroPython on Raspberry Pi Pico\nDESCRIPTION: Sets up the CMake project for building MicroPython firmware on Raspberry Pi Pico. It defines the minimum CMake version, sets the build type, and configures paths for MicroPython and Pico SDK.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13)\n\n# Set build type to reduce firmware size\nif(NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE MinSizeRel)\nendif()\n\n# Set main target and component locations\nset(MICROPY_TARGET firmware)\nget_filename_component(MICROPY_DIR \"../..\" ABSOLUTE)\nif (PICO_SDK_PATH_OVERRIDE)\n    set(PICO_SDK_PATH ${PICO_SDK_PATH_OVERRIDE})\nelse()\n    set(PICO_SDK_PATH ../../lib/pico-sdk)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Mount with Code Injection\nDESCRIPTION: Mounts directory and sets up code injection via Ctrl-J for development workflow.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\nmpremote mount . repl --inject-code \"import demo\"\n```\n\n----------------------------------------\n\nTITLE: Getting and Setting Timer Counter Value in MicroPython\nDESCRIPTION: Method for getting or setting the current value of a timer counter. When called without arguments, it returns the current counter value. When provided with a value, it sets the counter to that value.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nTimer.counter([value])\n```\n\n----------------------------------------\n\nTITLE: LED Intensity Control for Special LEDs\nDESCRIPTION: Demonstrates controlling the intensity of the blue LED (LED 4) on the Pyboard. This script gradually increases the LED brightness in a loop, showcasing the intensity() method that is available for the special yellow and blue LEDs.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/leds.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nled = pyb.LED(4)\nintensity = 0\nwhile True:\n    intensity = (intensity + 1) % 255\n    led.intensity(intensity)\n    pyb.delay(20)\n```\n\n----------------------------------------\n\nTITLE: Sending Messages with ESP-NOW Protocol in Python\nDESCRIPTION: Example code demonstrating how to initialize ESP-NOW, add a peer device, and send messages. Requires an active WLAN interface in station mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport network\nimport espnow\n\n# A WLAN interface must be active to send()/recv()\nsta = network.WLAN(network.WLAN.IF_STA)  # Or network.WLAN.IF_AP\nsta.active(True)\nsta.disconnect()      # For ESP8266\n\ne = espnow.ESPNow()\ne.active(True)\npeer = b'\\xbb\\xbb\\xbb\\xbb\\xbb\\xbb'   # MAC address of peer's wifi interface\ne.add_peer(peer)      # Must add_peer() before send()\n\ne.send(peer, \"Starting...\")\nfor i in range(100):\n    e.send(peer, str(i)*20, True)\ne.send(peer, b'end')\n```\n\n----------------------------------------\n\nTITLE: SSLContext Creation\nDESCRIPTION: Creates a new SSLContext instance with specified protocol type.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/ssl.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nSSLContext(protocol, /)\n```\n\n----------------------------------------\n\nTITLE: Initializing SPI Bus\nDESCRIPTION: This snippet initializes an SPI object with specific parameters including bus number, mode, baudrate, polarity, phase, and CRC settings. The required parameter is the mode, which specifies whether the SPI device operates as a controller or peripheral.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.SPI.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom pyb import SPI\nspi = SPI(1, SPI.CONTROLLER, baudrate=600000, polarity=1, phase=0, crc=0x7)\n```\n\n----------------------------------------\n\nTITLE: Resetting WiFi to Known State in MicroPython\nDESCRIPTION: Function to reset WiFi to a known state after a soft reset. It deactivates both STA and AP interfaces, then activates and disconnects the STA interface to ensure a clean state for ESPNow operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport network, time\n\ndef wifi_reset():   # Reset wifi to AP_IF off, STA_IF on and disconnected\n  sta = network.WLAN(network.WLAN.IF_STA); sta.active(False)\n  ap = network.WLAN(network.WLAN.IF_AP); ap.active(False)\n  sta.active(True)\n  while not sta.active():\n      time.sleep(0.1)\n  sta.disconnect()   # For ESP8266\n  while sta.isconnected():\n      time.sleep(0.1)\n  return sta, ap\n\nsta, ap = wifi_reset()\n```\n\n----------------------------------------\n\nTITLE: Disk Access with FileSystem - MicroPython\nDESCRIPTION: This code snippet demonstrates how to manage filesystem operations using the DiskAccess class from the zephyr module in MicroPython. It covers creating a filesystem on an SD card and basic file handling operations such as writing to and reading from files.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/quickref.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nimport vfs\nfrom zephyr import DiskAccess\n\nblock_dev = DiskAccess('SDHC')      # create a block device object for an SD card\nvfs.VfsFat.mkfs(block_dev)          # create FAT filesystem object using the disk storage block\nvfs.mount(block_dev, '/sd')         # mount the filesystem at the SD card subdirectory\n\n# with the filesystem mounted, files can be manipulated as normal\nwith open('/sd/hello.txt','w') as f:     # open a new file in the directory\n    f.write('Hello world')                  # write to the file\nprint(open('/sd/hello.txt').read())      # print contents of the file\n```\n\n----------------------------------------\n\nTITLE: Reading DHT11 Temperature Sensor Data in MicroPython\nDESCRIPTION: Example showing how to read temperature and humidity data from a DHT11 sensor. Requires a 4.7k pull-up resistor on the data line. Returns temperature in Celsius and relative humidity as a percentage.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nd.temperature() # eg. 23 (°C)\nd.humidity()    # eg. 41 (% RH)\n```\n\n----------------------------------------\n\nTITLE: Using pyb.wfi for Power Saving in MicroPython\nDESCRIPTION: The `pyb.wfi()` method reduces power consumption by putting the CPU into a low-power state until an interrupt occurs. This is typically used in the main loop of a program to conserve power while waiting for events.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/power_ctrl.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nwhile True:\n    do_some_processing()\n    pyb.wfi()\n```\n\n----------------------------------------\n\nTITLE: Checking WLAN Mode in MicroPython\nDESCRIPTION: This code snippet shows how to check the current WLAN mode on a WiPy device using the `wlan.mode()` method. The mode is typically `WLAN.AP` after power up. This snippet relies on a previously initialized WLAN instance.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/wlan.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> wlan.mode()\n```\n\n----------------------------------------\n\nTITLE: Writing USB VCP Data - Python\nDESCRIPTION: Method to write bytes to the USB device. Returns number of bytes written.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.USB_VCP.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nUSB_VCP.write(buf)\n```\n\n----------------------------------------\n\nTITLE: Setting TimerChannel Callback Function in MicroPython\nDESCRIPTION: Method for setting a callback function that will be executed when the timer channel triggers. The callback function receives the timer object as an argument. Setting the callback to None disables it.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ntimerchannel.callback(fun)\n```\n\n----------------------------------------\n\nTITLE: Using DHT11/DHT22 Sensors in MicroPython on SAMD21/SAMD51\nDESCRIPTION: This snippet demonstrates how to use DHT11 and DHT22 temperature and humidity sensors. It shows sensor initialization and reading temperature and humidity values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport dht\nimport machine\n\nd = dht.DHT11(machine.Pin('D4'))\nd.measure()\nd.temperature() # eg. 23 (°C)\nd.humidity()    # eg. 41 (% RH)\n\nd = dht.DHT22(machine.Pin('D4'))\nd.measure()\nd.temperature() # eg. 23.6 (°C)\nd.humidity()    # eg. 41.3 (% RH)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Messages with ESP-NOW\nDESCRIPTION: This snippet demonstrates how to send broadcast messages using ESP-NOW, by first registering the broadcast MAC address as a peer. Broadcasting is not encrypted, and it sends messages to all registered peers except the broadcast address itself.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nbcast = b'\\\\xff' * 6\ne.add_peer(bcast)\ne.send(bcast, \"Hello World!\")\n```\n\n----------------------------------------\n\nTITLE: Mounting and Using SD Card with VFS in MicroPython\nDESCRIPTION: This code snippet demonstrates how to mount and use an SD card with the VFS (Virtual File System) in MicroPython. It initializes an SDCard object, creates a VfsFat object, mounts the file system, lists directory contents, and then unmounts the SD card.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport machine, os, vfs\n\nsd = machine.SDCard()\nfs = vfs.VfsFat(sd)\nvfs.mount(fs, \"/sd\") # mount\nos.listdir('/sd')    # list directory contents\nvfs.umount('/sd')    # eject\n```\n\n----------------------------------------\n\nTITLE: Configuring LWIP (Lightweight IP) Support for MicroPython\nDESCRIPTION: Configures MicroPython build to include LWIP networking stack support. It links the LWIP library and adds necessary include directories and compiler definitions.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif (MICROPY_PY_LWIP)\n    target_link_libraries(${MICROPY_TARGET} micropy_lib_lwip)\n\n    target_include_directories(${MICROPY_TARGET} PRIVATE\n        lwip_inc\n    )\n    target_compile_definitions(${MICROPY_TARGET} PRIVATE\n        MICROPY_PY_LWIP=1\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Importing and Running a Python Application in main.py\nDESCRIPTION: A simple pattern for structuring MicroPython applications by importing and running code from separate modules rather than placing all code directly in main.py.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/reset_boot.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport my_app\nmy_app.main()\n```\n\n----------------------------------------\n\nTITLE: Executing Addition Instructions in ARM Assembly\nDESCRIPTION: The addition instructions demonstrate operations that add register contents or an immediate value, reflecting changes directly on condition flags except when specified otherwise. Dependencies include ARM assembly environment knowledge and ARM registers setup.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_arith.rst#2025-04-21_snippet_0\n\nLANGUAGE: Assembly\nCODE:\n```\n* add(Rdn, imm8) ``Rdn = Rdn + imm8``\n* add(Rd, Rn, imm3) ``Rd = Rn + imm3``\n* add(Rd, Rn, Rm) ``Rd = Rn +Rm``\n* adc(Rd, Rn) ``Rd = Rd + Rn + carry``\n```\n\n----------------------------------------\n\nTITLE: Accessing Structure Fields in MicroPython uctypes Module\nDESCRIPTION: Demonstrates various syntax examples for accessing C-style structure fields in MicroPython using the uctypes module, including nested structures, arrays, and pointer dereferencing.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/uctypes.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmy_struct.substruct1.field1\n```\n\nLANGUAGE: python\nCODE:\n```\n[]\n```\n\nLANGUAGE: python\nCODE:\n```\n[0]\n```\n\nLANGUAGE: python\nCODE:\n```\nmcu_registers.peripheral_a.register1\n```\n\nLANGUAGE: python\nCODE:\n```\nperipheral_a.register1\n```\n\nLANGUAGE: python\nCODE:\n```\nperipheral_a = mcu_registers.peripheral_a\n```\n\nLANGUAGE: python\nCODE:\n```\nreg_a = mcu_registers.peripheral_a.reg_a\n```\n\nLANGUAGE: python\nCODE:\n```\nperipheral_a.register[0]\n```\n\nLANGUAGE: python\nCODE:\n```\nperipheral_a.register0\n```\n\nLANGUAGE: python\nCODE:\n```\nregister0 = peripheral_a.register[0]\n```\n\n----------------------------------------\n\nTITLE: USB VCP Send/Receive Methods - Python\nDESCRIPTION: Methods for sending and receiving data with timeout options. Data can be integer count or buffer object.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.USB_VCP.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nUSB_VCP.recv(data, *, timeout=5000)\nUSB_VCP.send(data, *, timeout=5000)\n```\n\n----------------------------------------\n\nTITLE: Using ADC in MicroPython for ESP8266\nDESCRIPTION: Demonstrates how to use the machine.ADC class to perform analog-to-digital conversion on the dedicated ADC pin of an ESP8266 board.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import ADC\n\nadc = ADC(0)            # create ADC object on ADC pin\nadc.read()              # read value, 0-1024\n```\n\n----------------------------------------\n\nTITLE: Accessing ESP-IDF Heap Information in Python\nDESCRIPTION: This code snippet demonstrates how to use the esp32.idf_heap_info() function to retrieve information about ESP-IDF heap memory regions. It returns a list of 4-tuples containing total bytes, free bytes, largest free block, and minimum free seen over time for each heap region.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp32.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import esp32; esp32.idf_heap_info(esp32.HEAP_DATA)\n[(240, 0, 0, 0), (7288, 0, 0, 0), (16648, 4, 4, 4), (79912, 35712, 35512, 35108),\n (15072, 15036, 15036, 15036), (113840, 0, 0, 0)]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Network Settings in MicroPython\nDESCRIPTION: Shows how to retrieve the IP address and netmask of a WiFi interface. This is useful for confirming network configuration details.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_basics.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> ap_if.ipconfig('addr4')\n('192.168.4.1', '255.255.255.0')\n```\n\n----------------------------------------\n\nTITLE: Advanced Switch Callback Definition on Pyboard\nDESCRIPTION: This snippet shows how to define a standalone function for complex logic in a switch callback, bypassing the constraints of a lambda. The function toggles the LED when the switch is pressed, illustrating advanced event handling setup.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/switch.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> def f():\n...   pyb.LED(1).toggle()\n...\n>>> sw.callback(f)\n```\n\n----------------------------------------\n\nTITLE: Playback Configuration with Sparkfun WM8960 Breakout Board and Teensy\nDESCRIPTION: Sets up the WM8960 for audio playback with a Sparkfun breakout board and Teensy. Configures a 44.1kHz sample rate with PLL as system clock source using a 24MHz MCLK frequency. Sets headphone volume to maximum (100) for audio output.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/wm8960.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2C\ni2c=I2C(0)\nimport wm8960\nwm=wm8960.WM8960(i2c, sample_rate=44_100,\n    adc_sync=wm8960.SYNC_ADC,\n    sysclk_source=wm8960.SYSCLK_PLL,\n    mclk_freq=24_000_000)\nwm.set_volume(wm8960.MODULE_HEADPHONE, 100)\n```\n\n----------------------------------------\n\nTITLE: Integer Bytes Conversion Methods in MicroPython\nDESCRIPTION: Implementation of int.from_bytes() and int.to_bytes() methods in MicroPython. These methods handle conversion between integers and their byte representations, with specific requirements for byteorder parameter positioning and signed number handling.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/builtins.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nint.from_bytes(bytes, byteorder)\nint.to_bytes(size, byteorder)\n```\n\n----------------------------------------\n\nTITLE: Configuring External Libraries for Raspberry Pi Pico MicroPython\nDESCRIPTION: Specifies the paths for external libraries used in the MicroPython build, including TinyUSB, lwIP, and BTstack. It overrides the default libraries provided by the Pico SDK.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Use the local tinyusb instead of the one in pico-sdk\nset(PICO_TINYUSB_PATH ${MICROPY_DIR}/lib/tinyusb)\n# Use the local lwip instead of the one in pico-sdk\nset(PICO_LWIP_PATH ${MICROPY_DIR}/lib/lwip)\n# Use the local btstack instead of the one in pico-sdk\nset(PICO_BTSTACK_PATH ${MICROPY_DIR}/lib/btstack)\n```\n\n----------------------------------------\n\nTITLE: Download File from Device\nDESCRIPTION: Copies main.py from device to local directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\nmpremote cp :main.py .\n```\n\n----------------------------------------\n\nTITLE: Accessing ESP32 Python REPL\nDESCRIPTION: Terminal commands to connect to the MicroPython REPL on an ESP32 using serial communication tools\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/README.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ picocom -b 115200 /dev/ttyUSB0\n$ miniterm.py /dev/ttyUSB0 115200\n```\n\n----------------------------------------\n\nTITLE: Setting up TimerChannel with TimerWiPy in MicroPython\nDESCRIPTION: Example of initializing a TimerChannel object using the channel method of TimerWiPy. This shows how to set up a channel with specific frequency, period, polarity, and duty cycle for PWM operation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.TimerWiPy.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nTimerWiPy.channel(channel, **, freq, period, polarity=TimerWiPy.POSITIVE, duty_cycle=0)\n```\n\n----------------------------------------\n\nTITLE: Creating Preallocated StringIO and BytesIO Objects in MicroPython\nDESCRIPTION: MicroPython-specific constructors for creating empty StringIO and BytesIO objects with preallocated buffer sizes. Useful for system-level libraries and special cases.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/io.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nStringIO(alloc_size)\nByteIO(alloc_size)\n```\n\n----------------------------------------\n\nTITLE: Implementing Delays and Timing in MicroPython on ESP32\nDESCRIPTION: Demonstrates how to use the time module for various delay and timing operations in MicroPython on ESP32. Includes examples of sleep functions and measuring time differences.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\ntime.sleep(1)           # sleep for 1 second\ntime.sleep_ms(500)      # sleep for 500 milliseconds\ntime.sleep_us(10)       # sleep for 10 microseconds\nstart = time.ticks_ms() # get millisecond counter\ndelta = time.ticks_diff(time.ticks_ms(), start) # compute time difference\n```\n\n----------------------------------------\n\nTITLE: Initializing I2S in MicroPython (Teensy 4.1)\nDESCRIPTION: This code snippet demonstrates how to initialize and use the I2S (Inter-IC Sound) interface in MicroPython, specifically for a Teensy 4.1 board. It configures the I2S peripheral for transmission mode (TX) with specified parameters like sample rate, bit size, format, and buffer size, then writes audio data to the I2S device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2S, Pin\ni2s = I2S(2, sck=Pin('D26'), ws=Pin('D27'), sd=Pin('D7'),\n    mode=I2S.TX, bts=16,format=I2S.STEREO,\n    rate=44100,ibuf=40000)\ni2s.write(buf)             # write buffer of audio samples to I2S device\n```\n\n----------------------------------------\n\nTITLE: Using MPR121 Touch Sensor Driver with MicroPython\nDESCRIPTION: Example of using the MPR121 driver module to continuously monitor touch sensor status. The code imports a driver library, initializes the touch sensor over I2C, and prints touch status in a loop with a delay.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/lcd_skin.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import pyb\n>>> import mpr121\n>>> m = mpr121.MPR121(pyb.I2C(1, pyb.I2C.CONTROLLER))\n>>> for i in range(100):\n...   print(m.touch_status())\n...   pyb.delay(100)\n...\n```\n\n----------------------------------------\n\nTITLE: Using String Format Method for Dynamic Strings in MicroPython\nDESCRIPTION: Shows how to efficiently create dynamic strings using the format() method. This approach is more memory-efficient than concatenating multiple string objects.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nvar = \"Temperature {:5.2f} Pressure {:06d}\\n\".format(temp, press)\n```\n\n----------------------------------------\n\nTITLE: Deinitializing SPI Bus\nDESCRIPTION: This method deinitializes the SPI bus, turning it off and freeing any resources that were in use by the SPI instance.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.SPI.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n.. method:: SPI.deinit()\n\n   Turn off the SPI bus.\n```\n\n----------------------------------------\n\nTITLE: Turning on an LED Using STM32 Registers with Inline Assembly\nDESCRIPTION: Function that turns on the red LED (PA13) on a PyBoard by directly manipulating the STM32 GPIO registers. It uses movwt to load a 32-bit address and strh to set the appropriate bit in the BSRRL register.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/assembler.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@micropython.asm_thumb\ndef led_on():\n    movwt(r0, stm.GPIOA)\n    movw(r1, 1 << 13)\n    strh(r1, [r0, stm.GPIO_BSRRL])\n```\n\n----------------------------------------\n\nTITLE: Managing Timer Frequency in MicroPython\nDESCRIPTION: Method for getting or setting the frequency of a timer. When a new frequency value is provided, this method automatically adjusts the prescaler and period settings to achieve the requested frequency.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nTimer.freq([value])\n```\n\n----------------------------------------\n\nTITLE: Implementing an Extended RAM Block Device in Python for MicroPython\nDESCRIPTION: Creates a more advanced block device that supports both simple and extended interfaces. This implementation includes offset parameters and block erase functionality required for some filesystem types like littlefs.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass RAMBlockDev:\n    def __init__(self, block_size, num_blocks):\n        self.block_size = block_size\n        self.data = bytearray(block_size * num_blocks)\n\n    def readblocks(self, block_num, buf, offset=0):\n        addr = block_num * self.block_size + offset\n        for i in range(len(buf)):\n            buf[i] = self.data[addr + i]\n\n    def writeblocks(self, block_num, buf, offset=None):\n        if offset is None:\n            # do erase, then write\n            for i in range(len(buf) // self.block_size):\n                self.ioctl(6, block_num + i)\n            offset = 0\n        addr = block_num * self.block_size + offset\n        for i in range(len(buf)):\n            self.data[addr + i] = buf[i]\n\n    def ioctl(self, op, arg):\n        if op == 4: # block count\n            return len(self.data) // self.block_size\n        if op == 5: # block size\n            return self.block_size\n        if op == 6: # block erase\n            return 0\n```\n\n----------------------------------------\n\nTITLE: Deserializing JSON String to Python Object in MicroPython\nDESCRIPTION: The 'loads' function parses a JSON string and returns a Python object. It raises a ValueError if the input string is not correctly formed JSON.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/json.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nloads(str)\n```\n\n----------------------------------------\n\nTITLE: Initializing Hardware SPI on RP2040 in MicroPython\nDESCRIPTION: Shows how to initialize hardware SPI on the RP2040 microcontroller using MicroPython. It demonstrates different ways to configure SPI, including specifying pins and communication parameters.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SPI\n\nspi = SPI(1, 10_000_000)  # Default assignment: sck=Pin(10), mosi=Pin(11), miso=Pin(8)\nspi = SPI(1, 10_000_000, sck=Pin(14), mosi=Pin(15), miso=Pin(12))\nspi = SPI(0, baudrate=80_000_000, polarity=0, phase=0, bits=8, sck=Pin(6), mosi=Pin(7), miso=Pin(4))\n```\n\n----------------------------------------\n\nTITLE: Flash Area Management - MicroPython\nDESCRIPTION: This snippet demonstrates how to instantiate and manage a FlashArea for filesystem operations in MicroPython. It includes creating a LFS2 filesystem for data storage and performing file write and read operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/quickref.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nimport vfs\nfrom zephyr import FlashArea\n\nblock_dev = FlashArea(4, 4096)      # creates a block device object in the frdm-k64f flash scratch partition\nvfs.VfsLfs2.mkfs(block_dev)         # create filesystem in lfs2 format using the flash block device\nvfs.mount(block_dev, '/flash')      # mount the filesystem at the flash subdirectory\n\n# with the filesystem mounted, files can be manipulated as normal\nwith open('/flash/hello.txt','w') as f:     # open a new file in the directory\n    f.write('Hello world')                  # write to the file\nprint(open('/flash/hello.txt').read())      # print contents of the file\n```\n\n----------------------------------------\n\nTITLE: LittleFS v1 Filesystem Class Constructor\nDESCRIPTION: Creates a LittleFS v1 filesystem object with configurable read size, program size and lookahead parameters. Requires a block device supporting the extended interface.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/vfs.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nVfsLfs1(block_dev, readsize=32, progsize=32, lookahead=32)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Sensor Float Values in MicroPython with Zephyr\nDESCRIPTION: Method to get the sensor measurement value as a floating-point number for a specific sensor channel.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.zsensor.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nSensor.get_float(sensor_channel)\n```\n\n----------------------------------------\n\nTITLE: Configuring USB Device with Callbacks - Python\nDESCRIPTION: Example signature of the USBDevice.config() method showing how to configure a USB device with descriptors and callbacks for handling USB communications. Handles device initialization, interface opening, reset events, and transfer operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.USBDevice.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nUSBDevice.config(desc_dev, desc_cfg, desc_strs=None, open_itf_cb=None, reset_cb=None, control_xfer_cb=None, xfer_cb=None)\n```\n\n----------------------------------------\n\nTITLE: Configuring Timer Channels in MicroPython\nDESCRIPTION: This method initializes or returns a previously initialized timer channel object, allowing configurations for PWM, output compare, or input capture functionalities based on specified modes and optional parameters.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n.. method:: Timer.channel(channel, mode, ...)\n\n   If only a channel number is passed, then a previously initialized channel\n   object is returned (or ``None`` if there is no previous channel).\n\n   Otherwise, a TimerChannel object is initialized and returned.\n\n   Each channel can be configured to perform pwm, output compare, or\n   input capture. All channels share the same underlying timer, which means\n   that they share the same timer clock.\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current Time in Seconds with MicroPython\nDESCRIPTION: The time() function returns the number of seconds since the Epoch (or port-specific reference point if RTC isn't set). It provides second-level precision and behavior varies between Unix ports and embedded hardware implementations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/time.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ntime()\n```\n\n----------------------------------------\n\nTITLE: Using Named Function as Timer Callback in MicroPython\nDESCRIPTION: This code demonstrates creating a timer object with a callback function defined elsewhere. The callback 'tick' function is designed to print the current counter value of the timer when triggered at a frequency of 1Hz.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef tick(timer):                # we will receive the timer object when being called\n        print(timer.counter())      # show current timer's counter value\n    tim = pyb.Timer(4, freq=1)      # create a timer object using timer 4 - trigger at 1Hz\n    tim.callback(tick)              # set the callback to our tick function\n```\n\n----------------------------------------\n\nTITLE: Setting Volume Control on AMP Audio Skin in MicroPython\nDESCRIPTION: Function to control the volume of the AMP audio skin by writing values to the digital potentiometer via I2C. The potentiometer is an I2C device with address 46 on the IC2(1) bus.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/amp_skin.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pyb\ndef volume(val):\n    pyb.I2C(1, pyb.I2C.CONTROLLER).mem_write(val, 46, 0)\n```\n\n----------------------------------------\n\nTITLE: Formatting STM32 Flash with Littlefs v2 in MicroPython\nDESCRIPTION: Code for formatting the internal flash of STM32/Pyboard devices with littlefs v2. After formatting, it mounts the filesystem at '/flash' and changes the current directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# STM32\nimport os, vfs, pyb\nvfs.umount('/flash')\nvfs.VfsLfs2.mkfs(pyb.Flash(start=0))\nvfs.mount(pyb.Flash(start=0), '/flash')\nos.chdir('/flash')\n```\n\n----------------------------------------\n\nTITLE: Math Module Basic Function Examples\nDESCRIPTION: Examples of basic math module function usage including trigonometric, inverse trigonometric, and exponential functions\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/math.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Trigonometric functions\nmath.cos(x)\nmath.sin(x)\nmath.tan(x)\n\n# Inverse trigonometric functions\nmath.acos(x)\nmath.asin(x)\nmath.atan(x)\nmath.atan2(y, x)\n\n# Hyperbolic functions\nmath.cosh(x)\nmath.sinh(x)\nmath.tanh(x)\n\n# Exponential and logarithmic functions\nmath.exp(x)\nmath.log(x)\nmath.log(x, base)\nmath.log10(x)\nmath.log2(x)\n```\n\n----------------------------------------\n\nTITLE: Install Package from micropython-lib\nDESCRIPTION: Installs aioble package from micropython-lib repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_44\n\nLANGUAGE: bash\nCODE:\n```\nmpremote mip install aioble\n```\n\n----------------------------------------\n\nTITLE: Package Installation\nDESCRIPTION: Command to install packages from micropython-lib using mip tool\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote mip install <packages...>\n```\n\n----------------------------------------\n\nTITLE: Configuring WiFi Antenna on Pycom Boards\nDESCRIPTION: Python code to select the internal antenna on Pycom boards like LoPy and WiPy 2.0, typically placed in boot.py\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/README.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport machine\nantenna = machine.Pin(16, machine.Pin.OUT, value=0)\n```\n\n----------------------------------------\n\nTITLE: Controlling APA102 LED in MicroPython on SAMD21/SAMD51\nDESCRIPTION: This snippet shows how to control an APA102 LED using SoftSPI. It demonstrates SPI initialization and a function to set LED color.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import SoftSPI, Pin\n# create the SPI object. miso can be any unused pin.\nspi=SoftSPI(sck=Pin('D25'), mosi=Pin('D26'), miso=Pin('D14'))\n\n# define a little function that writes the data with\n# preamble and postfix\ndef write(red, green, blue):\n    spi.write(b\"\\x00\\x00\\x00\\x00\\xff\")\n    spi.write(bytearray((blue, green, red)))\n    spi.write(b\"\\xff\\xff\\xff\")\n\n# set the LED to red\nwrite(128, 0, 0)\n```\n\n----------------------------------------\n\nTITLE: Directory and File Management\nDESCRIPTION: Basic file system operations for creating/removing directories and files, renaming files, and getting file/directory status.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/os.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmkdir(path)\nremove(path)\nrmdir(path)\nrename(old_path, new_path)\nstat(path)\n```\n\n----------------------------------------\n\nTITLE: LittleFS v2 Filesystem Class Constructor\nDESCRIPTION: Creates a LittleFS v2 filesystem object with optional modification timestamp support and configurable parameters. Requires a block device supporting the extended interface.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/vfs.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nVfsLfs2(block_dev, readsize=32, progsize=32, lookahead=32, mtime=True)\n```\n\n----------------------------------------\n\nTITLE: OneWire Driver Implementation\nDESCRIPTION: Shows how to use the software-implemented OneWire driver and specific DS18x20 temperature sensor functions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\nimport onewire\n\now = onewire.OneWire(Pin(12)) # create a OneWire bus on GPIO12\now.scan()               # return a list of devices on the bus\now.reset()              # reset the bus\now.readbyte()           # read a byte\now.writebyte(0x12)      # write a byte on the bus\now.write('123')         # write bytes on the bus\now.select_rom(b'12345678') # select a specific device by its ROM code\n```\n\nLANGUAGE: python\nCODE:\n```\nimport time, ds18x20\nds = ds18x20.DS18X20(ow)\nroms = ds.scan()\nds.convert_temp()\ntime.sleep_ms(750)\nfor rom in roms:\n    print(ds.read_temp(rom))\n```\n\n----------------------------------------\n\nTITLE: Setting RGB NeoPixel Colors\nDESCRIPTION: Examples of setting individual pixel colors with different brightness levels using RGB values\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/neopixel.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnp[0] = (255, 0, 0) # set to red, full brightness\nnp[1] = (0, 128, 0) # set to green, half brightness\nnp[2] = (0, 0, 64)  # set to blue, quarter brightness\n```\n\n----------------------------------------\n\nTITLE: Implementing a Spirit Level Using Accelerometer in MicroPython\nDESCRIPTION: This code creates a spirit level by using both x and y accelerometer values to control four LEDs. Different LEDs light up depending on the tilt direction of the board, providing visual feedback of the orientation in two dimensions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/accel.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nxlights = (pyb.LED(2), pyb.LED(3))\nylights = (pyb.LED(1), pyb.LED(4))\n\naccel = pyb.Accel()\nSENSITIVITY = 3\n\nwhile True:\n    x = accel.x()\n    if x > SENSITIVITY:\n        xlights[0].on()\n        xlights[1].off()\n    elif x < -SENSITIVITY:\n        xlights[1].on()\n        xlights[0].off()\n    else:\n        xlights[0].off()\n        xlights[1].off()\n\n    y = accel.y()\n    if y > SENSITIVITY:\n        ylights[0].on()\n        ylights[1].off()\n    elif y < -SENSITIVITY:\n        ylights[1].on()\n        ylights[0].off()\n    else:\n        ylights[0].off()\n        ylights[1].off()\n\n    pyb.delay(100)\n```\n\n----------------------------------------\n\nTITLE: Installing Packages with MicroPython Package Manager (mip)\nDESCRIPTION: These commands demonstrate how to use the built-in package manager 'mip' to install modules in MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/unix/README.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ ./build-standard/micropython -m mip install hmac\n```\n\n----------------------------------------\n\nTITLE: Basic MicroPython REPL Interaction\nDESCRIPTION: This snippet demonstrates a basic interaction with the MicroPython REPL, printing a simple \"hello WiPy!\" message.  This verifies that the REPL is working correctly and can execute basic Python code. The `>>>` represents the REPL prompt.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/repl.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> print(\"hello WiPy!\")\nhello WiPy!\n```\n\n----------------------------------------\n\nTITLE: Creating String Constants in MicroPython\nDESCRIPTION: Demonstrates different approaches to string creation and concatenation, with emphasis on compile-time optimization to reduce memory fragmentation. The first approach creates unnecessary intermediate objects.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nvar = \"foo\" + \"bar\"\nvar1 = \"foo\" \"bar\"\nvar2 = \"\"\"\\\nfoo\\\nbar\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Flash Control Operations in MicroPython RP2\nDESCRIPTION: IOCTL method for performing control operations on the flash memory, implementing the block device interface protocol.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/rp2.Flash.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nFlash.ioctl(cmd, arg)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Mounting SD Card in MicroPython (cc3200)\nDESCRIPTION: This snippet demonstrates how to create an SD card object, initialize it with specific pins, and mount it to the file system. It requires the machine and vfs modules.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.SD.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import SD\nimport vfs\n# clk cmd and dat0 pins must be passed along with\n# their respective alternate functions\nsd = machine.SD(pins=('GP10', 'GP11', 'GP15'))\nvfs.mount(sd, '/sd')\n# do normal file operations\n```\n\n----------------------------------------\n\nTITLE: Configuring PWM Using Timer on WiPy\nDESCRIPTION: This snippet demonstrates configuring a PWM signal using a timer on the WiPy board in MicroPython. It sets a timer in PWM mode with a specified frequency and duty cycle, utilizing a 16-bit width.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Timer\n\n# timer 1 in PWM mode and width must be 16 bits\ntim = Timer(1, mode=Timer.PWM, width=16)\n\n# enable channel A @1KHz with a 50.55% duty cycle\ntim_a = tim.channel(Timer.A, freq=1000, duty_cycle=5055)\n```\n\n----------------------------------------\n\nTITLE: Getting Current Date and Time from RTC\nDESCRIPTION: This snippet retrieves the current date and time from the RTC instance. It returns an 8-tuple containing year, month, day, weekday, hours, minutes, seconds, and subseconds.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.RTC.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nprint(rtc.datetime())\n```\n\n----------------------------------------\n\nTITLE: Generating Analog Signals with DAC on pyboard in MicroPython\nDESCRIPTION: Using the Digital-to-Analog Converter (DAC) to output analog voltage from a pin. The example initializes a DAC on pin X5 and sets an output value in the range of 0-255 to generate a corresponding voltage level.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import Pin, DAC\n\ndac = DAC(Pin('X5'))\ndac.write(120) # output between 0 and 255\n```\n\n----------------------------------------\n\nTITLE: Using mip Command Line Options in Unix Port of MicroPython\nDESCRIPTION: Examples of command line options for mip in the Unix port, including setting custom target paths, disabling mpy compilation, and specifying custom index URLs.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ ./micropython -m mip install --target third-party pkgname\n$ ./micropython -m mip install --no-mpy pkgname\n$ ./micropython -m mip install --index https://host/pi pkgname\n```\n\n----------------------------------------\n\nTITLE: Flashing STM32 Firmware via DFU using dfu-util\nDESCRIPTION: This snippet demonstrates how to use dfu-util to flash a .dfu firmware file onto an STM32 microcontroller that supports USB and the ST DFU bootloader. The command specifies alternate setting 0 for the DFU interface.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/deploy.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndfu-util --alt 0 -D firmware.dfu\n```\n\n----------------------------------------\n\nTITLE: File Update and Script Execution\nDESCRIPTION: Updates a file on device and executes a test script from RAM without copying to device filesystem.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\nmpremote cp utils/driver.py :utils/driver.py + run test.py\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Cross-Compiler and ESP32 Firmware\nDESCRIPTION: Commands to build the MicroPython cross-compiler and compile firmware for ESP32 microcontrollers\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ make -C mpy-cross\n$ cd ports/esp32\n$ make submodules\n$ make\n```\n\n----------------------------------------\n\nTITLE: Executing Shell Commands in Zephyr\nDESCRIPTION: Function that executes a given command on the UART backend. Requires CONFIG_SHELL_BACKEND_SERIAL to be configured in the port.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nshell_exec(cmd_in)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using I2S in MicroPython on RP2040\nDESCRIPTION: Demonstrates how to initialize and use I2S (Inter-IC Sound) on the RP2040 microcontroller using MicroPython. It covers both transmit and receive modes with different configurations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2S, Pin\n\ni2s = I2S(0, sck=Pin(16), ws=Pin(17), sd=Pin(18), mode=I2S.TX, bits=16, format=I2S.STEREO, rate=44100, ibuf=40000) # create I2S object\ni2s.write(buf)             # write buffer of audio samples to I2S device\n\ni2s = I2S(1, sck=Pin(0), ws=Pin(1), sd=Pin(2), mode=I2S.RX, bits=16, format=I2S.MONO, rate=22050, ibuf=40000) # create I2S object\ni2s.readinto(buf)          # fill buffer with audio samples from I2S device\n```\n\n----------------------------------------\n\nTITLE: Configuring Pin Alternate Functions in MicroPython\nDESCRIPTION: Shows how to access and configure alternate functions for a pin using the PinAF class.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Pin.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx3 = pyb.Pin.board.X3\nx3_af = x3.af_list()\n\npin = pyb.Pin(pyb.Pin.board.X3, mode=pyb.Pin.ALT, alt=pyb.Pin.AF1_TIM2)\n\npin = pyb.Pin(pyb.Pin.board.X3, mode=pyb.Pin.ALT, alt=1)\n```\n\n----------------------------------------\n\nTITLE: Continuous Sine Wave Output with 12-bit DAC\nDESCRIPTION: Creates and outputs a continuous sine wave at 400Hz using 12-bit resolution with array and circular buffer mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.DAC.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport math\nfrom array import array\nfrom pyb import DAC\n\n# create a buffer containing a sine-wave, using half-word samples\nbuf = array('H', 2048 + int(2047 * math.sin(2 * math.pi * i / 128)) for i in range(128))\n\n# output the sine-wave at 400Hz\ndac = DAC(1, bits=12)\ndac.write_timed(buf, 400 * len(buf), mode=DAC.CIRCULAR)\n```\n\n----------------------------------------\n\nTITLE: Setting Timer Callback Functionality in MicroPython\nDESCRIPTION: This method sets the function to be executed when the timer triggers an event. If the provided function is None, the callback is disabled.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n.. method:: Timer.callback(fun)\n\n   Set the function to be called when the timer triggers.\n   ``fun`` is passed 1 argument, the timer object.\n   If ``fun`` is ``None`` then the callback will be disabled.\n```\n\n----------------------------------------\n\nTITLE: Initializing I2S in MicroPython (Teensy Audio Shield)\nDESCRIPTION: This code snippet demonstrates the initialization and usage of the I2S (Inter-IC Sound) interface with a Teensy Audio Shield in MicroPython. It sets up the I2S peripheral for transmission, configures an SGTL5000 codec via I2C, and then writes audio data to the I2S device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2C, I2S, Pin\nfrom sgtl5000 import CODEC\ni2s = I2S(1, sck=Pin('D21'), ws=Pin('D20'), sd=Pin('D7'), mck=Pin('D23'),\n    mode=I2S.TX, bits=16,rate=44100,format=I2S.STEREO,\n    ibuf=40000,\n)\n\n# configure the SGTL5000 codec\ni2c = I2C(0, freq=400000)\ncodec = CODEC(0x0A, i2c)\ncodec.mute_dac(False)\ncodec.dac_volume(0.9, 0.9)\ncodec.headphone_select(0)\ncodec.mute_headphone(False)\ncodec.volume(0.7, 0.7)\n\ni2s.write(buf)             # write buffer of audio samples to I2S device\n```\n\n----------------------------------------\n\nTITLE: Advanced Timer Initialization in MicroPython\nDESCRIPTION: This snippet shows various ways of initializing a timer object with different frequencies and settings, including prescaler and period values. It also demonstrates getting and setting the timer counter and its properties.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntim = pyb.Timer(4, freq=100)    # freq in Hz\n    tim = pyb.Timer(4, prescaler=0, period=99)\n    tim.counter()                   # get counter (can also set)\n    tim.prescaler(2)                # set prescaler (can also get)\n    tim.period(199)                 # set period (can also get)\n    tim.callback(lambda t: ...)     # set callback for update interrupt (t=tim instance)\n    tim.callback(None)              # clear callback\n```\n\n----------------------------------------\n\nTITLE: Installing Local Files with mpremote in MicroPython\nDESCRIPTION: Examples of using mpremote to install packages from files on the host's local filesystem, useful for testing packages during development.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote mip install path/to/pkg.py\n$ mpremote mip install path/to/app/package.json\n$ mpremote mip install \\\\path\\\\to\\\\pkg.py\n```\n\n----------------------------------------\n\nTITLE: Maintaining interpreter state between commands\nDESCRIPTION: Command to disable auto-soft-reset, allowing subsequent commands to run without resetting the device first, preserving the interpreter state.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote resume\n```\n\n----------------------------------------\n\nTITLE: Executing PIO Instructions\nDESCRIPTION: Examples demonstrating how to execute single PIO instructions using both string and encoded instruction formats.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/rp2.StateMachine.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsm.exec(\"set(0, 1)\")\nsm.exec(rp2.asm_pio_encode(\"out(y, 8)\", 0))\n```\n\n----------------------------------------\n\nTITLE: Controlling Neopixel LED in MicroPython on SAMD21/SAMD51\nDESCRIPTION: This snippet demonstrates how to control a Neopixel LED using the machine.bitstream() method and the Neopixel driver. It shows LED initialization and setting color.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nimport neopixel\nimport machine\n\n# 1 LED connected to Pin D8 on Adafruit Feather boards\np = machine.Pin('D8', machine.Pin.OUT)\nn = neopixel.NeoPixel(p, 1)\n\n# set the led to red.\nn[0] = (128, 0, 0)\n\n# Update the LED.\nn.write()\n```\n\n----------------------------------------\n\nTITLE: Defining Callback Function for ExtInt in MicroPython\nDESCRIPTION: This snippet demonstrates how to define a callback function for an external interrupt. The function takes a 'line' parameter which represents the interrupt line number.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.ExtInt.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef callback(line):\n    print(\"line =\", line)\n```\n\n----------------------------------------\n\nTITLE: Checking State Machine Active Status\nDESCRIPTION: Example showing how to check and set the active status of a state machine using the active() method.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/rp2.StateMachine.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsm.active()\nTrue\nsm.active(0)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Basic SD Card Mounting in MicroPython\nDESCRIPTION: Simple example of mounting an SD card to the filesystem using the default interface configuration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.SDCard.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nvfs.mount(machine.SDCard(), \"/sd\")\n```\n\n----------------------------------------\n\nTITLE: APA102 LED Driver Implementation\nDESCRIPTION: Shows how to use the APA102 driver for controlling APA102 LED strips with clock and data pins.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\nfrom apa102 import APA102\n\nclock = Pin(14, Pin.OUT)     # set GPIO14 to output to drive the clock\ndata = Pin(13, Pin.OUT)      # set GPIO13 to output to drive the data\napa = APA102(clock, data, 8) # create APA102 driver on the clock and the data pin for 8 pixels\napa[0] = (255, 255, 255, 31) # set the first pixel to white with a maximum brightness of 31\napa.write()                  # write data to all pixels\nr, g, b, brightness = apa[0] # get first pixel colour\n```\n\n----------------------------------------\n\nTITLE: Implementing I2S Audio Interface on pyboard in MicroPython\nDESCRIPTION: Setting up and using the Inter-IC Sound (I2S) bus for digital audio transmission. The example shows configurations for both transmit and receive modes with different bit depths, formats, and sample rates, and demonstrates writing and reading audio sample buffers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2S, Pin\n\ni2s = I2S(2, sck=Pin('Y6'), ws=Pin('Y5'), sd=Pin('Y8'), mode=I2S.TX, bits=16, format=I2S.STEREO, rate=44100, ibuf=40000) # create I2S object\ni2s.write(buf)             # write buffer of audio samples to I2S device\n\ni2s = I2S(1, sck=Pin('X5'), ws=Pin('X6'), sd=Pin('Y4'), mode=I2S.RX, bits=16, format=I2S.MONO, rate=22050, ibuf=40000) # create I2S object\ni2s.readinto(buf)          # fill buffer with audio samples from I2S device\n```\n\n----------------------------------------\n\nTITLE: Using const Keyword for Memory Optimization in MicroPython\nDESCRIPTION: Shows how to use the const keyword to optimize memory usage by substituting literal values at compile time. Using underscore prefix (_COLS) makes symbols invisible outside the module, saving additional RAM.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom micropython import const\nROWS = const(33)\n_COLS = const(0x10)\na = ROWS\nb = _COLS\n```\n\n----------------------------------------\n\nTITLE: Running Tests with run-tests.py\nDESCRIPTION: Commands for running tests using the run-tests.py script, including examples for running on boards and specific test directories.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/writingtests.rst#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cd tests\n$ ./run-tests.py\n```\n\n----------------------------------------\n\nTITLE: Using Type Hints for Unsigned Integer Return Values\nDESCRIPTION: Shows how to use Python type hints to correctly handle return values where the most significant bit might be set. The example ensures that addition results exceeding 31-bit values are properly interpreted as unsigned integers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_hints_tips.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n@micropython.asm_thumb\ndef uadd(r0, r1) -> uint:\n    add(r0, r0, r1)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Named Tuples in MicroPython\nDESCRIPTION: Example demonstrating how to create and use named tuples using the namedtuple factory function. Shows creation of a custom tuple type with named fields and accessing values both by index and attribute notation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/collections.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom collections import namedtuple\n\nMyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\"))\nt1 = MyTuple(1, \"foo\")\nt2 = MyTuple(2, \"bar\")\nprint(t1.name)\nassert t2.name == t2[1]\n```\n\n----------------------------------------\n\nTITLE: Configuring NINA-W10 WiFi and Bluetooth Support for MicroPython\nDESCRIPTION: Sets up MicroPython to use the NINA-W10 WiFi and Bluetooth module. It includes the necessary driver files and compiler definitions for NINA-W10-based networking and Bluetooth functionality.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nif (MICROPY_PY_NETWORK_NINAW10)\n    target_compile_definitions(${MICROPY_TARGET} PRIVATE\n        MICROPY_PY_NETWORK_NINAW10=1\n    )\n\n    target_include_directories(${MICROPY_TARGET} PRIVATE\n        ${MICROPY_DIR}/drivers/ninaw10/\n    )\n\n    # Enable NINA-W10 WiFi and Bluetooth drivers.\n    list(APPEND MICROPY_SOURCE_DRIVERS\n        ${MICROPY_DIR}/drivers/ninaw10/nina_bt_hci.c\n        ${MICROPY_DIR}/drivers/ninaw10/nina_wifi_drv.c\n        ${MICROPY_DIR}/drivers/ninaw10/nina_wifi_bsp.c\n        ${MICROPY_DIR}/drivers/ninaw10/machine_pin_nina.c\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Receiving Data from SPI Bus\nDESCRIPTION: This method allows receiving data from the SPI bus. Users can pass either the number of bytes to receive or a mutable buffer to store the received data, with optional timeout settings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.SPI.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n.. method:: SPI.recv(recv, *, timeout=5000)\n\n   Receive data on the bus:\n\n     - ``recv`` can be an integer, which is the number of bytes to receive,\n       or a mutable buffer, which will be filled with received bytes.\n     - ``timeout`` is the timeout in milliseconds to wait for the receive.\n\n   Return value: if ``recv`` is an integer then a new buffer of the bytes received,\n   otherwise the same buffer that was passed in to ``recv``.\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using SPI in MicroPython\nDESCRIPTION: Demonstrates how to initialize and use SPI (Serial Peripheral Interface) in MicroPython. It covers reading and writing data, as well as using buffers for I/O operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nspi.init(baudrate=200000) # set the baudrate\n\nspi.read(10)            # read 10 bytes on MISO\nspi.read(10, 0xff)      # read 10 bytes while outputting 0xff on MOSI\n\nbuf = bytearray(50)     # create a buffer\nspi.readinto(buf)       # read into the given buffer (reads 50 bytes in this case)\nspi.readinto(buf, 0xff) # read into the given buffer and output 0xff on MOSI\n\nspi.write(b'12345')     # write 5 bytes on MOSI\n\nbuf = bytearray(4)      # create a buffer\nspi.write_readinto(b'1234', buf) # write to MOSI and read from MISO into the buffer\nspi.write_readinto(buf, buf) # write buf to MOSI and read MISO back into buf\n```\n\n----------------------------------------\n\nTITLE: Compiling with Freeze Manifest for nRF Series\nDESCRIPTION: Commands to compile the nRF port using a freeze manifest, which allows including frozen Python modules in the firmware. Shows both command-line and makefile methods.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/README.md#2025-04-21_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nmake BOARD=PCA10040 FROZEN_MANIFEST=path/to/manifest.py\n```\n\n----------------------------------------\n\nTITLE: Turning Off LED in MicroPython\nDESCRIPTION: Turns the LED off.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.LED.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nLED.off()\n```\n\n----------------------------------------\n\nTITLE: Including Micropython-lib Packages (Python)\nDESCRIPTION: Manifest code to include a package from micropython-lib using the require() function, which also manages dependencies.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/manifest.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nrequire(\"hmac\")\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Hardware I2C in MicroPython on SAMD21/SAMD51\nDESCRIPTION: This snippet demonstrates how to set up and use a Hardware I2C bus on SAMD21/SAMD51 devices. It shows initialization with default and custom settings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2C\n\ni2c = I2C(2, scl=Pin(\"SCL\"), sda=Pin(\"SDA\"), freq=400_000)\ni2c.writeto(0x76, b\"Hello World\")\n\ni2c2 = I2C()   # Use the default values for id, scl and sda.\ni2c2 = I2C(freq=100_000) # Use the default device and set freq.\n```\n\n----------------------------------------\n\nTITLE: Retrieving Sensor Milli Values in MicroPython with Zephyr\nDESCRIPTION: Method to get the sensor measurement value in thousandths (millisystem) for a specific sensor channel.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.zsensor.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nSensor.get_millis(sensor_channel)\n```\n\n----------------------------------------\n\nTITLE: ADCAll Object Usage\nDESCRIPTION: Example of using ADCAll object to read internal channels with specific resolution and channel mask\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.ADC.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nadcall = pyb.ADCAll(12, 0x70000) # 12 bit resolution, internal channels\ntemp = adcall.read_core_temp()\n```\n\n----------------------------------------\n\nTITLE: Basic Switch Usage in MicroPython\nDESCRIPTION: Demonstrates basic initialization and usage of the Switch class, including getting the switch state and registering callbacks.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Switch.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsw = pyb.Switch()       # create a switch object\nsw.value()              # get state (True if pressed, False otherwise)\nsw()                    # shorthand notation to get the switch state\nsw.callback(f)          # register a callback to be called when the\n                         #   switch is pressed down\nsw.callback(None)       # remove the callback\n```\n\n----------------------------------------\n\nTITLE: Retrieving System Information with uname()\nDESCRIPTION: Returns a tuple containing system and machine information including system name, network name, version details, and hardware identifiers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/os.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nuname()\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Software I2C in MicroPython on SAMD21/SAMD51\nDESCRIPTION: This snippet shows how to set up a Software I2C bus using bit-banging. It demonstrates initialization and various I2C operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SoftI2C\n\ni2c = SoftI2C(scl=Pin('D10'), sda=Pin('D11'), freq=100000)\n\ni2c.scan()              # scan for devices\n\ni2c.readfrom(0x3a, 4)   # read 4 bytes from device with address 0x3a\ni2c.writeto(0x3a, '12') # write '12' to device with address 0x3a\n\nbuf = bytearray(10)     # create a buffer with 10 bytes\ni2c.writeto(0x3a, buf)  # write the given buffer to the slave\n```\n\n----------------------------------------\n\nTITLE: Seeed WIO Terminal Pin Assignment Table\nDESCRIPTION: A comprehensive table showing pin assignments for the Seeed WIO Terminal, including GPIO, pin names, IRQ, ADC, Serial, TC, and PWM information. It also includes default pin assignments for UART, I2C, and SPI interfaces.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/pinout.rst#2025-04-21_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\nSeeed WIO Terminal pin assignment table\n---------------------------------------\n\n=== ==== ============ ==== ==== ==== ====== ====== ===== ===== =====\nPin GPIO Pin name     IRQ  ADC  ADC  Serial Serial  TC    PWM   PWM\n=== ==== ============ ==== ==== ==== ====== ====== ===== ===== =====\n 33 PB01           CS   1   13    -     -    5/3    7/1    -     -\n 59 PB27           RX  13    -    -    2/1   4/0     -    1/3    -\n 58 PB26           TX  12    -    -    2/0   4/1     -    1/2    -\n 79 PC15   3V3_ENABLE  15    -    -    7/3   6/3     -    0/5   1/1\n 78 PC14    5V_ENABLE  14    -    -    7/2   6/2     -    0/4   1/0\n 40 PB08        A0_D0   8    2    0     -    4/0    4/0    -     -\n 41 PB09        A1_D1   9    3    1     -    4/1    4/1    -     -\n  7 PA07        A2_D2   7    7    -     -    0/3    1/1    -     -\n 36 PB04        A3_D3   4    -    6     -     -      -     -     -\n 37 PB05        A4_D4   5    -    7     -     -      -     -     -\n 38 PB06        A5_D5   6    -    8     -     -      -     -     -\n  4 PA04        A6_D6   4    4    -     -    0/0    0/0    -     -\n 39 PB07        A7_D7   7    -    9     -     -      -     -     -\n  6 PA06        A8_D8   6    6    -     -    0/2    1/0    -     -\n 90 PC26     BUTTON_1  10    -    -     -     -      -     -     -\n 91 PC27     BUTTON_2  11    -    -    1/0    -      -     -     -\n 92 PC28     BUTTON_3  12    -    -    1/1    -      -     -     -\n107 PD11       BUZZER   6    -    -    7/3   6/3     -    0/4    -\n 47 PB15       GPCLK0  15    -    -    4/3    -     5/1   4/1   0/3\n 44 PB12       GPCLK1  12    -    -    4/0    -     4/0   3/0   0/0\n 45 PB13       GPCLK2  13    -    -    4/1    -     4/1   3/1   0/1\n 48 PB16     I2C_BCLK   0    -    -    5/0    -     6/0   3/0   0/4\n 20 PA20    I2S_LRCLK   4    -    -    5/2   3/2    7/0   1/4   0/0\n 21 PA21     I2S_SDIN   5    -    -    5/3   3/3    7/1   1/5   0/1\n 22 PA22    I2S_SDOUT   6    -    -    3/0   5/1    4/0   1/6   0/2\n 50 PB18     LCD_MISO   2    -    -    5/2   7/2     -    1/0    -\n 51 PB19     LCD_MOSI   3    -    -    5/3   7/3     -    1/1    -\n 52 PB20      LCD_SCK   4    -    -    3/0   7/1     -    1/2    -\n 53 PB21       LCD_CS   5    -    -    3/1   7/0     -    1/3    -\n 70 PC06      LCD_D/C   6    -    -    6/2    -      -     -     -\n 71 PC07    LCD_RESET   9    -    -    6/3    -      -     -     -\n 74 PC10       LCD_XL  10    -    -    6/2   7/2     -    0/0   1/4\n 76 PC12       LCD_XR  12    -    -    7/0   6/1     -    0/2   1/6\n 77 PC13       LCD_YD  13    -    -    7/1   6/0     -    0/3   1/7\n 75 PC11       LCD_YU  11    -    -    6/3   7/3     -    0/1   1/5\n 15 PA15     LED_BLUE  15    -    -    2/3   4/3    3/1   2/1   1/3\n 69 PC05      LED_LCD   5    -    -    6/1    -      -     -     -\n 94 PC30          MIC  14    -   12     -     -      -     -     -\n 32 PB00         MISO   9   12    -     -    5/2    7/0    -     -\n 34 PB02         MOSI   2   14    -     -    5/0    6/0   2/2    -\n 35 PB03          SCK   9   15    -     -    5/1    6/1    -     -\n 12 PA12         SCL0  12    -    -    2/0   4/1    2/0   0/6   1/2\n 13 PA13         SDA0  13    -    -    2/1   4/0    2/1   0/7   1/3\n 16 PA16         SCL1   0    -    -    1/0   3/1    2/0   1/0   0/4\n 17 PA17         SDA1   1    -    -    1/1   3/0    2/1   1/1   0/5\n117 PD21       SD_DET  11    -    -    1/3   3/3     -    1/1    -\n 83 PC19        SD_CS   3    -    -    6/3   0/3     -    0/3    -\n 82 PC18      SD_MISO   2    -    -    6/2   0/2     -    0/2    -\n 43 PB11      QSPI_CS  12    -    -     -     4/3   5/1   0/5   1/1\n  8 PA08      QSPI_D0   -    8    2    0/0    2/1   0/0   0/0   1/4\n  9 PA09      QSPI_D1   9    9    3    0/1    2/0   0/1   0/1   1/5\n 10 PA10      QSPI_D2  10   10    -    0/2    2/2   1/0   0/2   1/6\n 11 PA11      QSPI_D3  11   11    -    0/3    2/3   1/1   0/3   1/7\n 42 PB10     QSPI_SCK  10    -    -     -     4/2   5/0   0/4   1/0\n 80 PC16      SD_MOSI   0    -    -    6/0   0/1     -    0/0    -\n 81 PC17       SD_SCK   1    -    -    6/1   0/0     -    0/1    -\n 30 PA30        SWCLK  14    -    -    7/2   1/2    6/0   2/0    -\n 31 PA31        SWDIO  15    -    -    7/3   1/3    6/1   2/1    -\n108 PD12     SWITCH_B   7    -    -     -     -      -    0/5    -\n116 PD20     SWITCH_U  10    -    -    1/2   3/2     -    1/0    -\n104 PD08     SWITCH_X   3    -    -    7/0   6/1     -    0/1    -\n105 PD09     SWITCH_Y   4    -    -    7/1   6/0     -    0/2    -\n106 PD10     SWITCH_Z   5    -    -    7/2   6/2     -    0/3    -\n 24 PA24       USB_DM   8    -    -    3/2   5/2    5/0   2/2    -\n 25 PA25       USB_DP   9    -    -    3/3   5/3    5/1    -     -\n  0 PA00            -   0    -    -     -    1/0    2/0    -     -\n  1 PA01            -   1    -    -     -    1/1    2/1    -     -\n  2 PA02            -   2    0    -     -     -      -     -     -\n  3 PA03            -   3   10    -     -     -      -     -     -\n  5 PA05            -   5    5    -     -    0/1    0/1    -     -\n 14 PA14            -  14    -    -    2/2   4/2    3/0   2/0   1/2\n 18 PA18            -   2    -    -    1/2   3/2    3/0   1/2   0/6\n 19 PA19            -   3    -    -    1/3   3/3    3/1   1/3   0/7\n 23 PA23            -   7    -    -    3/1   5/0    4/1   1/7   0/3\n 27 PA27            -  11    -    -     -     -      -     -     -\n 46 PB14            -  14    -    -    4/2    -     5/0   4/0   0/2\n 49 PB17            -   1    -    -    5/1    -     6/1   3/1   0/5\n 54 PB22            -  22    -    -    1/2   5/2    7/0    -     -\n 55 PB23            -   7    -    -    1/3   5/3    7/1    -     -\n 56 PB24            -   8    -    -    0/0   2/1     -     -     -\n 57 PB25            -   9    -    -    0/1   2/0     -     -     -\n 60 PB28            -  14    -    -    2/2   4/2     -    1/4    -\n 61 PB29            -  15    -    -    2/3   4/3     -    1/5    -\n 62 PB30            -  14    -    -    7/0   5/1    0/0   4/0   0/6\n 63 PB31            -  15    -    -    7/1   5/0    0/1   4/1   0/7\n 64 PC00            -   0    -   10     -     -      -     -     -\n 65 PC01            -   1    -   11     -     -      -     -     -\n 66 PC02            -   2    -    4     -     -      -     -     -\n 67 PC03            -   3    -    5     -     -      -     -     -\n 68 PC04            -   4    -    -    6/0    -      -    0/0    -\n 84 PC20            -   4    -    -     -     -      -    0/4    -\n 85 PC21            -   5    -    -     -     -      -    0/5    -\n 86 PC22            -   6    -    -    1/0   3/1     -    0/5    -\n 87 PC23            -   7    -    -    1/1   3/0     -    0/7    -\n 88 PC24            -   8    -    -    0/2   2/2     -     -     -\n 89 PC25            -   9    -    -    0/3   2/3     -     -     -\n 95 PC31            -  15    -   13     -     -      -     -     -\n 96 PD00            -   0    -   14     -     -      -     -     -\n 97 PD01            -   1    -   15     -     -      -     -     -\n=== ==== ============ ==== ==== ==== ====== ====== ===== ===== =====\n\nFor the definition of the table columns see the explanation at the table for\nAdafruit ItsyBitsy M4 Express :ref:`samd51_pinout_table`.\n\nDefault pin assignments:\n- UART 2 at pins PB27 and PB26, labelled RX and TX\n- I2C 4 at pins PA12 and PA13, labelled SCL0 and SDA0\n- I2C 3 at pins PA16 and PA17, labelled SCL1 and SDA1\n- SPI 5 at pins PB00, PB02 and PB03, labelle MISO, MOSI and SCK\n\nThere seems to be no default pin assignment for this board.\n```\n\n----------------------------------------\n\nTITLE: Constructing SPI Objects\nDESCRIPTION: This snippet provides the constructor for the SPI class which creates an SPI object on a specified bus. It highlights how to create a non-initialized SPI object and discusses the physical pin mappings for SPI buses 1 and 2.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.SPI.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n.. class:: SPI(bus, ...)\n\n   Construct an SPI object on the given bus.  ``bus`` can be 1 or 2, or\n   'X' or 'Y'. With no additional parameters, the SPI object is created but\n   not initialised (it has the settings from the last initialisation of\n   the bus, if any).  If extra arguments are given, the bus is initialised.\n   See ``init`` for parameters of initialisation.\n\n   The physical pins of the SPI buses are:\n\n     - ``SPI(1)`` is on the X position: ``(NSS, SCK, MISO, MOSI) = (X5, X6, X7, X8) = (PA4, PA5, PA6, PA7)``\n     - ``SPI(2)`` is on the Y position: ``(NSS, SCK, MISO, MOSI) = (Y5, Y6, Y7, Y8) = (PB12, PB13, PB14, PB15)``\n\n   At the moment, the NSS pin is not used by the SPI driver and is free\n   for other use.\n```\n\n----------------------------------------\n\nTITLE: Configuring Bluetooth Support for MicroPython\nDESCRIPTION: Adds Bluetooth functionality to the MicroPython build by including necessary source files and setting compiler definitions. It enables central mode and synchronous events for the Bluetooth implementation.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif(MICROPY_PY_BLUETOOTH)\n    list(APPEND MICROPY_SOURCE_PORT mpbthciport.c)\n    target_compile_definitions(${MICROPY_TARGET} PRIVATE\n        MICROPY_PY_BLUETOOTH=1\n        MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS=1\n        MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE=1\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Native Code Emitter\nDESCRIPTION: This code snippet shows the usage of the `@micropython.native` decorator. This decorator tells the MicroPython compiler to emit native CPU opcodes for the decorated function, potentially increasing its execution speed. Most functions don't require any adaptation to use this decorator.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/speed_python.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@micropython.native\n```\n\n----------------------------------------\n\nTITLE: Install Package to Custom Directory\nDESCRIPTION: Installs functools package to specified directory on device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_47\n\nLANGUAGE: bash\nCODE:\n```\nmpremote mip install --target /flash/third-party functools\n```\n\n----------------------------------------\n\nTITLE: Performing a Hard Reset in MicroPython\nDESCRIPTION: This snippet illustrates how to perform a hard reset on the WiPy board using the machine module. A hard reset is equivalent to a power cycle, which fully resets the hardware. This can be initiated programmatically as shown below.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/reset.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport machine\nmachine.reset()\n```\n\n----------------------------------------\n\nTITLE: Initializing ADC Pin on ESP8266 with MicroPython\nDESCRIPTION: Creates an ADC object to read analog values from pin 0 on the ESP8266. This is the only analog input pin available on the microcontroller.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/adc.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport machine\nadc = machine.ADC(0)\n```\n\n----------------------------------------\n\nTITLE: Display Frame Buffer - LCD160CR Method\nDESCRIPTION: Shows a buffer of 16-bit RGB values on the display within the specified SPI window area.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.show_framebuf(buf)\n```\n\n----------------------------------------\n\nTITLE: Defining DiskAccess Class for Zephyr in Python\nDESCRIPTION: This class definition facilitates interfacing with disk storage devices in embedded systems like SD card controllers. It requires the Zephyr framework and proper board configuration for auto-detection of devices. The class supports read and write operations adhering to the block protocol.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.DiskAccess.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass DiskAccess:\n    \"\"\"Access to disk storage using Zephyr's Disk Access API.\"\"\"\n    def __init__(self, disk_name):\n        pass  # Gets an object for accessing disk memory of the specific disk\n```\n\n----------------------------------------\n\nTITLE: Getting PIO State Machine Instance\nDESCRIPTION: Example showing how to get state machine #3 from PIO instance 1. State machines are numbered 0-3 on each PIO instance.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/rp2.PIO.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nrp2.PIO(1).state_machine(3)\nStateMachine(7)\n```\n\n----------------------------------------\n\nTITLE: Getting and Setting Clock and Time with Time Module\nDESCRIPTION: This snippet illustrates how to get and set the clock and time information using the time module. It also demonstrates decoding date/time from seconds and converting seconds to a datetime tuple. The µs value of the date_time tuple is ignored. On boards without the RTC module, time.localtime(seconds) sets the system time.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\ndate_time = time.localtime()        # Show the actual date/time information\ndate_time = time.localtime(seconds) # decode the date/time form the seconds value\nseconds = time.mktime(date_time_tuple) # Convert seconds to a datetime tuple\nsecond = time.time()                # Return the actual system time.\n```\n\n----------------------------------------\n\nTITLE: Basic MicroPython REPL interaction examples\nDESCRIPTION: Examples of basic MicroPython commands that can be executed at the REPL prompt, demonstrating printing, LED control, and simple arithmetic operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/repl.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> print(\"hello pyboard!\")\nhello pyboard!\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> pyb.LED(1).on()\n>>> pyb.LED(2).on()\n>>> 1 + 2\n3\n>>> 1 / 2\n0.5\n>>> 20 * 'py'\n'pypypypypypypypypypypypypypypypypypypypy'\n```\n\n----------------------------------------\n\nTITLE: Adding Manifest to Board Definition (CMake)\nDESCRIPTION: Configuration in mpconfigboard.cmake to specify a default manifest path for a custom board in CMake-based ports like ESP32 and RP2.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/manifest.rst#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(MICROPY_FROZEN_MANIFEST ${MICROPY_BOARD_DIR}/manifest.py)\n```\n\n----------------------------------------\n\nTITLE: Flashing SoftDevice for Bluetooth LE on NRF52840_MDK_USB_DONGLE\nDESCRIPTION: Command to flash the SoftDevice (s140) for enabling Bluetooth LE on an NRF52840_MDK_USB_DONGLE board. This should be done before flashing the main firmware when enabling Bluetooth LE functionality.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/README.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nmake BOARD=NRF52840_MDK_USB_DONGLE SD=s140 NRFUTIL_PORT=/dev/ttyACM0 sd\n```\n\n----------------------------------------\n\nTITLE: ESPNow Message Reception with Iteration\nDESCRIPTION: Example showing how to read messages by iterating over an ESPNow object using the irecv() method for allocation-free reads.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport espnow\ne = espnow.ESPNow(); e.active(True)\nfor mac, msg in e:\n    print(mac, msg)\n    if mac is None:   # mac, msg will equal (None, None) on timeout\n        break\n```\n\n----------------------------------------\n\nTITLE: Configuring CYW43 WiFi Support for MicroPython\nDESCRIPTION: Sets up MicroPython to use the CYW43 driver for WiFi functionality on the Raspberry Pi Pico W. It adds the Git submodule, necessary source files, and compiler definitions for CYW43-based networking.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nif (MICROPY_PY_NETWORK_CYW43)\n    list(APPEND GIT_SUBMODULES lib/cyw43-driver)\n    if(NOT UPDATE_SUBMODULES AND NOT EXISTS ${MICROPY_DIR}/lib/cyw43-driver/src/cyw43.h)\n        message(FATAL_ERROR \" cyw43-driver not initialized.\\n Run 'make BOARD=${MICROPY_BOARD} submodules'\")\n    endif()\n\n    target_compile_definitions(${MICROPY_TARGET} PRIVATE\n        MICROPY_PY_NETWORK_CYW43=1\n        MICROPY_PY_SOCKET_DEFAULT_TIMEOUT_MS=30000 # default socket timeout\n    )\n    if (CMAKE_BUILD_TYPE MATCHES Debug)\n    target_compile_definitions(${MICROPY_TARGET} PRIVATE\n        CYW43_USE_STATS=1\n    )\n    endif()\n\n    list(APPEND MICROPY_SOURCE_PORT\n        machine_pin_cyw43.c\n    )\n\n    target_link_libraries(${MICROPY_TARGET}\n        cyw43_driver_picow\n    )\n    target_include_directories(${MICROPY_TARGET} PRIVATE\n        ${MICROPY_DIR}/lib/cyw43-driver/\n    )\n\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating StringIO and BytesIO Objects in MicroPython\nDESCRIPTION: Classes for creating in-memory file-like objects for text and binary I/O operations. They support common file methods and an additional getvalue() method.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/io.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nStringIO([string])\nByteIO([string])\n\n# Method available on both classes\ngetvalue()\n```\n\n----------------------------------------\n\nTITLE: Operating I2C Bus on WiPy using MicroPython\nDESCRIPTION: This snippet illustrates how to configure and communicate using the I2C interface on the WiPy board. It demonstrates scanning for devices, writing to and reading from peripherals, and performing memory operations on connected devices.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import I2C\n# configure the I2C bus\ni2c = I2C(baudrate=100000)\ni2c.scan() # returns list of peripheral addresses\ni2c.writeto(0x42, 'hello') # send 5 bytes to peripheral with address 0x42\ni2c.readfrom(0x42, 5) # receive 5 bytes from peripheral\ni2c.readfrom_mem(0x42, 0x10, 2) # read 2 bytes from peripheral 0x42, peripheral memory 0x10\ni2c.writeto_mem(0x42, 0x10, 'xy') # write 2 bytes to peripheral 0x42, peripheral memory 0x10\n```\n\n----------------------------------------\n\nTITLE: Enabling ESP-Hosted Driver in Makefile\nDESCRIPTION: This snippet shows how to enable the esp-hosted driver by setting `MICROPY_PY_NETWORK_ESP_HOSTED` to 1 in the Makefile. If `MICROPY_PY_BLUETOOTH` is also set, the Bluetooth host driver will be built as well.\nSOURCE: https://github.com/micropython/micropython/blob/master/drivers/esp-hosted/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\n\"MICROPY_PY_NETWORK_ESP_HOSTED := 1\"\n```\n\n----------------------------------------\n\nTITLE: Basic HTML integration of MicroPython\nDESCRIPTION: Demonstrates the simplest way to load MicroPython in a browser, create an interpreter context, and run Python code.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/webassembly/README.md#2025-04-21_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html>\n  <head>\n    <script src=\"build-standard/micropython.mjs\" type=\"module\"></script>\n  </head>\n  <body>\n    <script type=\"module\">\n      const mp = await loadMicroPython();\n      mp.runPython(\"print('hello world')\");\n    </script>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Copy File on Device\nDESCRIPTION: Copies a file from one location to another on the device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_41\n\nLANGUAGE: bash\nCODE:\n```\nmpremote cp :a.py :b.py\n```\n\n----------------------------------------\n\nTITLE: Implementing Loops in Inline Assembly for LED Flashing\nDESCRIPTION: A more complex example that demonstrates loops and conditional branching in inline assembly. This function flashes the green LED (PA14) for a specified number of times, using labels and branch instructions to create loops for delays and repetition.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/assembler.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@micropython.asm_thumb\ndef flash_led(r0):\n    # get the GPIOA address in r1\n    movwt(r1, stm.GPIOA)\n\n    # get the bit mask for PA14 (the pin LED #2 is on)\n    movw(r2, 1 << 14)\n\n    b(loop_entry)\n\n    label(loop1)\n\n    # turn LED on\n    strh(r2, [r1, stm.GPIO_BSRRL])\n\n    # delay for a bit\n    movwt(r4, 5599900)\n    label(delay_on)\n    sub(r4, r4, 1)\n    cmp(r4, 0)\n    bgt(delay_on)\n\n    # turn LED off\n    strh(r2, [r1, stm.GPIO_BSRRH])\n\n    # delay for a bit\n    movwt(r4, 5599900)\n    label(delay_off)\n    sub(r4, r4, 1)\n    cmp(r4, 0)\n    bgt(delay_off)\n\n    # loop r0 times\n    sub(r0, r0, 1)\n    label(loop_entry)\n    cmp(r0, 0)\n    bgt(loop1)\n```\n\n----------------------------------------\n\nTITLE: Deploying OTA Update to CC3200 - Bash\nDESCRIPTION: This command automates the OTA update process for the CC3200 running MicroPython, using default network and authentication settings unless overridden. It is essential for applying new firmware over a network connection.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/cc3200/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmake BTARGET=application BTYPE=release BOARD=LAUNCHXL WIPY_IP=192.168.1.1 WIPY_USER=micro WIPY_PWD=python deploy-ota\n```\n\n----------------------------------------\n\nTITLE: Controlling WiPy Pins via REPL\nDESCRIPTION: This snippet shows how to control the WiPy's GPIO pins via the REPL.  It imports the `machine` and `wipy` modules, disables the heartbeat LED, and then configures and toggles the GP25 pin as an output.  It demonstrates basic pin manipulation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/repl.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from machine import Pin\n>>> import wipy\n>>> wipy.heartbeat(False)  # disable the heartbeat\n>>> led = Pin('GP25', mode=Pin.OUT)\n>>> led(1)\n>>> led(0)\n>>> led.toggle()\n>>> 1 + 2\n3\n>>> 4 // 2\n2\n>>> 20 * 'py'\n'pypypypypypypypypypypypypypypypypypypypy'\n```\n\n----------------------------------------\n\nTITLE: Initializing the SPI Bus with Parameters\nDESCRIPTION: This method initializes the SPI bus with given parameters, such as mode, baudrate, prescaler, polarity, phase, bits, firstbit, ti, and crc. It specifies constraints on baudrate based on hardware support.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.SPI.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n.. method:: SPI.init(mode, baudrate=328125, *, prescaler=-1, polarity=1, phase=0, bits=8, firstbit=SPI.MSB, ti=False, crc=None)\n\n   Initialise the SPI bus with the given parameters:\n\n     - ``mode`` must be either ``SPI.CONTROLLER`` or ``SPI.PERIPHERAL``.\n     - ``baudrate`` is the SCK clock rate (only sensible for a controller).\n     - ``prescaler`` is the prescaler to use to derive SCK from the APB bus frequency;\n       use of ``prescaler`` overrides ``baudrate``.\n     - ``polarity`` can be 0 or 1, and is the level the idle clock line sits at.\n     - ``phase`` can be 0 or 1 to sample data on the first or second clock edge\n       respectively.\n     - ``bits`` can be 8 or 16, and is the number of bits in each transferred word.\n     - ``firstbit`` can be ``SPI.MSB`` or ``SPI.LSB``.\n     - ``ti`` True indicates Texas Instruments, as opposed to Motorola, signal conventions.\n     - ``crc`` can be None for no CRC, or a polynomial specifier.\n\n   Note that the SPI clock frequency will not always be the requested baudrate.\n   The hardware only supports baudrates that are the APB bus frequency\n   (see :meth:`pyb.freq`) divided by a prescaler, which can be 2, 4, 8, 16, 32,\n   64, 128 or 256.  SPI(1) is on AHB2, and SPI(2) is on AHB1.  For precise\n   control over the SPI clock frequency, specify ``prescaler`` instead of\n   ``baudrate``.\n\n   Printing the SPI object will show you the computed baudrate and the chosen\n   prescaler.\n```\n\n----------------------------------------\n\nTITLE: Configuring Interrupts for TimerChannel in MicroPython\nDESCRIPTION: Example of setting up an interrupt for a TimerChannel. This demonstrates how to configure the priority, handler function, and trigger for different timer modes.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.TimerWiPy.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntimerchannel.irq(*, trigger, priority=1, handler=None)\n```\n\n----------------------------------------\n\nTITLE: Managing SSL Ciphers\nDESCRIPTION: Methods for getting and setting enabled cipher suites for SSL connections.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/ssl.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nSSLContext.get_ciphers()\nSSLContext.set_ciphers(ciphers)\n```\n\n----------------------------------------\n\nTITLE: Getting Touch Coordinates - LCD160CR Method\nDESCRIPTION: Method to retrieve the touch status and coordinates. Returns a 3-tuple with touch status and x,y position.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.get_touch()\n```\n\n----------------------------------------\n\nTITLE: Playing a WAV File on AMP Audio Skin in MicroPython\nDESCRIPTION: Example showing how to play a WAV file using the Python wave module and the DAC. This method loads the entire WAV file into RAM, so it only works for small files.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/amp_skin.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import wave\n>>> from pyb import DAC\n>>> dac = DAC(1)\n>>> f = wave.open('test.wav')\n>>> dac.write_timed(f.readframes(f.getnframes()), f.getframerate())\n```\n\n----------------------------------------\n\nTITLE: Complex Number Polar Form Operations in MicroPython\nDESCRIPTION: Functions for working with polar form of complex numbers including phase(), polar(), and rect().\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/cmath.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nphase(z)      # Returns phase of z in range (-pi, +pi]\npolar(z)      # Returns tuple of polar form of z\nrect(r, phi)  # Returns complex number from modulus and phase\n```\n\n----------------------------------------\n\nTITLE: Configuring NimBLE Bluetooth Implementation for MicroPython\nDESCRIPTION: Sets up the NimBLE Bluetooth implementation for MicroPython. It adds the necessary Git submodule, source files, libraries, and compiler definitions to enable NimBLE-based Bluetooth functionality with pairing/bonding and L2CAP channels support.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nif(MICROPY_BLUETOOTH_NIMBLE)\n    list(APPEND GIT_SUBMODULES lib/mynewt-nimble)\n    if(NOT UPDATE_SUBMODULES AND NOT EXISTS ${MICROPY_DIR}/lib/mynewt-nimble/nimble/host/include/host/ble_hs.h)\n        message(FATAL_ERROR \" mynewt-nimble not initialized.\\n Run 'make BOARD=${MICROPY_BOARD} submodules'\")\n    endif()\n\n    list(APPEND MICROPY_SOURCE_PORT mpnimbleport.c)\n    target_compile_definitions(${MICROPY_TARGET} PRIVATE\n        MICROPY_BLUETOOTH_NIMBLE=1\n        MICROPY_BLUETOOTH_NIMBLE_BINDINGS_ONLY=0\n        MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING=1\n        MICROPY_PY_BLUETOOTH_ENABLE_L2CAP_CHANNELS=1\n    )\n    target_compile_options(${MICROPY_TARGET} PRIVATE\n    # TODO: This flag is currently needed to make nimble build.\n    -Wno-unused-but-set-variable\n    )\n    include(${MICROPY_DIR}/extmod/nimble/nimble.cmake)\n    target_link_libraries(${MICROPY_TARGET} micropy_extmod_nimble)\n    get_target_property(NIMBLE_INCLUDE micropy_extmod_nimble INTERFACE_INCLUDE_DIRECTORIES)\n    list(APPEND MICROPY_INC_CORE ${NIMBLE_INCLUDE})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Getting Block Device Parameters for Littlefs FUSE Driver in MicroPython\nDESCRIPTION: Code to retrieve the block size and block count from a flash device for use with the littlefs FUSE driver. This allows accessing a littlefs filesystem on a PC over USB MSC.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/filesystem.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport pyb\nf = pyb.Flash(start=0)\nf.ioctl(1, 1)  # initialise flash in littlefs raw-block mode\nblock_count = f.ioctl(4, 0)\nblock_size = f.ioctl(5, 0)\n```\n\n----------------------------------------\n\nTITLE: Timer Initialization Method in MicroPython\nDESCRIPTION: This snippet describes the initialization method for the Timer class, explaining how to set up the timer by frequency or via prescaler and period. It lists the parameters and their effects on timer operation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n.. method:: Timer.init(*, freq, prescaler, period, mode=Timer.UP, div=1, callback=None, deadtime=0, brk=Timer.BRK_OFF)\n\n   Initialise the timer.  Initialisation must be either by frequency (in Hz)\n   or by prescaler and period::\n\n       tim.init(freq=100)                  # set the timer to trigger at 100Hz\n       tim.init(prescaler=83, period=999)  # set the prescaler and period directly\n```\n\n----------------------------------------\n\nTITLE: Accessing Indirect Arrays in Assembly\nDESCRIPTION: Demonstrates how to use indirection to access multiple arrays beyond the three-argument limit. The code uses the uctypes.addressof() function to get the address of an array and load values through a pointer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_hints_tips.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom uctypes import addressof\n@micropython.asm_thumb\ndef getindirect(r0):\n    ldr(r0, [r0, 0]) # Address of array loaded from passed array\n    ldr(r0, [r0, 4]) # Return element 1 of indirect array (24)\n\ndef testindirect():\n    a = array.array('i',[23, 24])\n    b = array.array('i',[0,0])\n    b[0] = addressof(a)\n    print(getindirect(b))\n```\n\n----------------------------------------\n\nTITLE: I2S Non-blocking Operations with Callbacks in MicroPython\nDESCRIPTION: Demonstrates non-blocking I2S operations using callback functions. Operations return immediately and callback is triggered when buffer is emptied (write) or filled (read).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.I2S.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\naudio_out.irq(i2s_callback)         # i2s_callback is called when buf is emptied\nnum_written = audio_out.write(buf)  # returns immediately\n\naudio_in.irq(i2s_callback)          # i2s_callback is called when buf is filled\nnum_read = audio_in.readinto(buf)   # returns immediately\n```\n\n----------------------------------------\n\nTITLE: Setting USB VCP Interrupt Character - Python\nDESCRIPTION: Method to set the interrupt character (default CTRL-C) that halts Python code execution when received over USB VCP.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.USB_VCP.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nUSB_VCP.setinterrupt(chr)\n```\n\n----------------------------------------\n\nTITLE: Connecting to a Network and Making an HTTP Request in MicroPython\nDESCRIPTION: This snippet demonstrates how to connect to a network using a network driver, wait for the connection to be established, and then make an HTTP request using the socket module.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# connect/ show IP config a specific network interface\n# see below for examples of specific drivers\nimport network\nimport time\nnic = network.Driver(...)\nif not nic.isconnected():\n    nic.connect()\n    print(\"Waiting for connection...\")\n    while not nic.isconnected():\n        time.sleep(1)\nprint(nic.ipconfig(\"addr4\"))\n\n# now use socket as usual\nimport socket\naddr = socket.getaddrinfo('micropython.org', 80)[0][-1]\ns = socket.socket()\ns.connect(addr)\ns.send(b'GET / HTTP/1.1\\r\\nHost: micropython.org\\r\\n\\r\\n')\ndata = s.recv(1000)\ns.close()\n```\n\n----------------------------------------\n\nTITLE: Disabling Garbage Collection in MicroPython\nDESCRIPTION: Disables automatic garbage collection in MicroPython. Heap memory can still be allocated, and garbage collection can be initiated manually using gc.collect().\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/gc.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ngc.disable()\n```\n\n----------------------------------------\n\nTITLE: Configuring Wiznet5k Ethernet Support for MicroPython\nDESCRIPTION: Configures MicroPython to use Wiznet5k Ethernet chips for networking. It sets up the necessary Git submodule, source files, and compiler definitions for various Wiznet chip models including W5100, W5100S, W5200, W5300, and W5500.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nif (MICROPY_PY_NETWORK_WIZNET5K)\n    list(APPEND GIT_SUBMODULES lib/wiznet5k)\n    if(NOT UPDATE_SUBMODULES AND NOT EXISTS ${MICROPY_DIR}/lib/wiznet5k/README.md)\n        message(FATAL_ERROR \" wiznet5k not initialized.\\n Run 'make BOARD=${MICROPY_BOARD} submodules'\")\n    endif()\n\n    target_compile_definitions(${MICROPY_TARGET} PRIVATE\n        MICROPY_PY_NETWORK_WIZNET5K=1\n        WIZCHIP_PREFIXED_EXPORTS=1\n        _WIZCHIP_=${MICROPY_PY_NETWORK_WIZNET5K}\n        WIZCHIP_YIELD=mpy_wiznet_yield\n    )\n\n    if (MICROPY_PY_LWIP)\n        target_compile_definitions(${MICROPY_TARGET} PRIVATE\n            # When using MACRAW mode (with lwIP), maximum buffer space must be used for the raw socket\n            WIZCHIP_USE_MAX_BUFFER=1\n        )\n    endif()\n\n    target_include_directories(${MICROPY_TARGET} PRIVATE\n        ${MICROPY_DIR}/lib/wiznet5k/\n        ${MICROPY_DIR}/lib/wiznet5k/Ethernet/\n    )\n\n    list(APPEND MICROPY_SOURCE_LIB\n        ${MICROPY_DIR}/lib/wiznet5k/Ethernet/W5100/w5100.c\n        ${MICROPY_DIR}/lib/wiznet5k/Ethernet/W5100S/w5100s.c\n        ${MICROPY_DIR}/lib/wiznet5k/Ethernet/W5200/w5200.c\n        ${MICROPY_DIR}/lib/wiznet5k/Ethernet/W5300/w5300.c\n        ${MICROPY_DIR}/lib/wiznet5k/Ethernet/W5500/w5500.c\n        ${MICROPY_DIR}/lib/wiznet5k/Ethernet/socket.c\n        ${MICROPY_DIR}/lib/wiznet5k/Ethernet/wizchip_conf.c\n        ${MICROPY_DIR}/lib/wiznet5k/Internet/DNS/dns.c\n        ${MICROPY_DIR}/lib/wiznet5k/Internet/DHCP/dhcp.c\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Wrapping Pico SDK Floating-Point Operations in MicroPython\nDESCRIPTION: Wraps low-level floating-point operations to use the Pico SDK implementations for ARM EABI. These functions handle arithmetic operations, comparisons, and type conversions for floating-point numbers.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# pico_float_micropython: wrap low-level floating-point ops, to call the pico-sdk versions.\npico_wrap_function(pico_float_micropython __aeabi_fdiv)\npico_wrap_function(pico_float_micropython __aeabi_fmul)\npico_wrap_function(pico_float_micropython __aeabi_frsub)\npico_wrap_function(pico_float_micropython __aeabi_fsub)\npico_wrap_function(pico_float_micropython __aeabi_cfcmpeq)\npico_wrap_function(pico_float_micropython __aeabi_cfrcmple)\npico_wrap_function(pico_float_micropython __aeabi_cfcmple)\npico_wrap_function(pico_float_micropython __aeabi_fcmpeq)\npico_wrap_function(pico_float_micropython __aeabi_fcmplt)\npico_wrap_function(pico_float_micropython __aeabi_fcmple)\npico_wrap_function(pico_float_micropython __aeabi_fcmpge)\npico_wrap_function(pico_float_micropython __aeabi_fcmpgt)\npico_wrap_function(pico_float_micropython __aeabi_fcmpun)\npico_wrap_function(pico_float_micropython __aeabi_i2f)\npico_wrap_function(pico_float_micropython __aeabi_l2f)\npico_wrap_function(pico_float_micropython __aeabi_ui2f)\npico_wrap_function(pico_float_micropython __aeabi_ul2f)\npico_wrap_function(pico_float_micropython __aeabi_f2iz)\npico_wrap_function(pico_float_micropython __aeabi_f2lz)\npico_wrap_function(pico_float_micropython __aeabi_f2uiz)\nif(PICO_RP2040)\n    pico_wrap_function(pico_float_micropython __aeabi_f2ulz)\nendif()\npico_wrap_function(pico_float_micropython __aeabi_f2d)\n```\n\n----------------------------------------\n\nTITLE: Using mpremote Command Line Options for Package Installation\nDESCRIPTION: Examples of command line options for mpremote mip, including setting custom target paths, disabling mpy compilation, and specifying custom index URLs.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote mip install --target=/flash/third-party pkgname\n$ mpremote mip install --no-mpy pkgname\n$ mpremote mip install --index https://host/pi pkgname\n```\n\n----------------------------------------\n\nTITLE: Calibration of Servo Parameters\nDESCRIPTION: This snippet provides a method to retrieve and set calibration values for servo motors. Calibration helps ensure accurate pulse width settings for angles and speeds.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/servo.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> servo1.calibration()\n(640, 2420, 1500, 2470, 2200)\n>>> servo1.calibration(700, 2400, 1510, 2500, 2000)\n```\n\n----------------------------------------\n\nTITLE: Creating TCP and UDP sockets in MicroPython\nDESCRIPTION: This snippet demonstrates how to create TCP (STREAM) and UDP (DGRAM) sockets using the `socket()` constructor in MicroPython. It highlights the use of `AF_INET` for the address family and `SOCK_STREAM` or `SOCK_DGRAM` for the socket type to create different types of sockets.  The `proto` argument is often not required.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/socket.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"# Create STREAM TCP socket\nsocket(AF_INET, SOCK_STREAM)\n# Create DGRAM UDP socket\nsocket(AF_INET, SOCK_DGRAM)\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Processing Floating Point Arrays in ARM Assembly\nDESCRIPTION: Shows how to handle non-integer data types by working with arrays. This example processes an array of floating point values, squaring each element in-place using ARM VFP instructions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_hints_tips.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom array import array\n\n@micropython.asm_thumb\ndef square(r0, r1):\n    label(LOOP)\n    vldr(s0, [r0, 0])\n    vmul(s0, s0, s0)\n    vstr(s0, [r0, 0])\n    add(r0, 4)\n    sub(r1, 1)\n    bgt(LOOP)\n\na = array('f', (x for x in range(10)))\nsquare(a, len(a))\nprint(a)\n```\n\n----------------------------------------\n\nTITLE: Initializing PWM Pin in MicroPython\nDESCRIPTION: Creates a PWM object from a pin object on pin 12. Shows basic setup of PWM functionality.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pwm.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import machine\n>>> p12 = machine.Pin(12)\n>>> pwm12 = machine.PWM(p12)\n```\n\n----------------------------------------\n\nTITLE: Utilizing OneWire Driver in MicroPython\nDESCRIPTION: This snippet showcases how to use the OneWire driver to communicate with devices like DS18S20 and DS18B20 in MicroPython. It requires onewire and ds18x20 modules. Pins must be initialized and a 4.7k pull-up resistor should be used. Methods like scan, reset, readbyte, and writebyte facilitate data exchange over the bus.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/quickref.rst#2025-04-21_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import Pin\nimport onewire\n\now = onewire.OneWire(Pin(P012)) # create a OneWire bus on P012\now.scan()               # return a list of devices on the bus\now.reset()              # reset the bus\now.readbyte()           # read a byte\now.writebyte(0x12)      # write a byte on the bus\now.write('123')         # write bytes on the bus\now.select_rom(b'12345678') # select a specific device by its ROM code\n\nimport time, ds18x20\nds = ds18x20.DS18X20(ow)\nroms = ds.scan()\nds.convert_temp()\ntime.sleep_ms(750)\nfor rom in roms:\n    print(ds.read_temp(rom))\n```\n\n----------------------------------------\n\nTITLE: SPI Data Transmission in MicroPython on Zephyr\nDESCRIPTION: This example shows how to use the machine.SPI class to transmit data over SPI. It initializes an SPI interface with specific parameters and writes a byte string to the MOSI pin.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/zephyr/README.md#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import SPI\n\nspi = SPI(\"spi0\")\nspi.init(baudrate=500000, polarity=1, phase=1, bits=8, firstbit=SPI.MSB)\nspi.write(b'abcd')\n```\n\n----------------------------------------\n\nTITLE: Entering DFU Bootloader Mode via REPL\nDESCRIPTION: Command to enter the DFU bootloader mode through MicroPython REPL. This allows firmware flashing via DFU programmer.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/PYBV10/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmachine.bootloader()\n```\n\n----------------------------------------\n\nTITLE: Cloning MicroPython Repository - Bash\nDESCRIPTION: Command to clone a forked MicroPython repository to local machine\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/gettingstarted.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/<your-user-name>/micropython\n```\n\n----------------------------------------\n\nTITLE: Configuring Switch Callback with Lambda in Pyboard\nDESCRIPTION: This snippet configures an interrupt-based callback that prints a message each time the USR switch is pressed. It uses a lambda function for concise syntax. This requires the callback method of the Switch class and knowledge of asynchronous execution in embedded systems.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/switch.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> sw.callback(lambda:print('press!'))\n```\n\n----------------------------------------\n\nTITLE: Connecting to WiPy via Telnet on macOS\nDESCRIPTION: This command connects to the WiPy board via Telnet. Replace `192.168.1.1` with the actual IP address of your WiPy, which is typically `192.168.1.1` when the WiPy is in WLAN.AP mode.  It uses the default Telnet port.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/repl.rst#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ telnet 192.168.1.1\n```\n\n----------------------------------------\n\nTITLE: Disabling Switch Callback on Pyboard\nDESCRIPTION: This snippet disables the switch callback by passing None to the callback method. This effectively stops any interrupt handling previously set for the switch.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/switch.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> sw.callback(None)\n```\n\n----------------------------------------\n\nTITLE: ESPNow Select Polling Example\nDESCRIPTION: Demonstrates how to use select.poll() to check for available data on an ESPNow connection.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport select\nimport espnow\n\ne = espnow.ESPNow()\npoll = select.poll()\npoll.register(e, select.POLLIN)\npoll.poll(timeout)\n```\n\n----------------------------------------\n\nTITLE: Creating ADC Channel in MicroPython\nDESCRIPTION: Different equivalent ways to create an ADC channel on GP3 using channel ID or pin name. All examples result in enabling ADC channel 1 on GP3.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.ADCWiPy.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# all of these are equivalent and enable ADC channel 1 on GP3\napin = adc.channel(1)\napin = adc.channel(pin='GP3')\napin = adc.channel(id=1, pin='GP3')\n```\n\n----------------------------------------\n\nTITLE: Retrieving Server IP Address in MicroPython\nDESCRIPTION: This code snippet shows how to get the IP address of a server using the getaddrinfo function and extract the necessary information.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_tcp.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\naddr_info = socket.getaddrinfo(\"towel.blinkenlights.nl\", 23)\naddr = addr_info[0][-1]\n```\n\n----------------------------------------\n\nTITLE: Switch Callback with LED Toggle Example\nDESCRIPTION: Shows how to create a switch callback that toggles an LED when the switch is pressed.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Switch.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npyb.Switch().callback(lambda: pyb.LED(1).toggle())\n```\n\n----------------------------------------\n\nTITLE: Event Scheduling Example\nDESCRIPTION: Example demonstrating event scheduling with different timing scenarios using ticks_diff()\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/time.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnow = time.ticks_ms()\nscheduled_time = task.scheduled_time()\nif ticks_diff(scheduled_time, now) > 0:\n    print(\"Too early, let's nap\")\n    sleep_ms(ticks_diff(scheduled_time, now))\n    task.run()\nelif ticks_diff(scheduled_time, now) == 0:\n    print(\"Right at time!\")\n    task.run()\nelif ticks_diff(scheduled_time, now) < 0:\n    print(\"Oops, running late, tell task to run faster!\")\n    task.run(run_faster=true)\n```\n\n----------------------------------------\n\nTITLE: Sending Data to SPI Bus\nDESCRIPTION: This method sends data through the SPI bus. You can send either an integer or a buffer object, with an optional timeout parameter indicating the time to wait for the send operation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.SPI.rst#2025-04-21_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n.. method:: SPI.send(send, *, timeout=5000)\n\n   Send data on the bus:\n\n     - ``send`` is the data to send (an integer to send, or a buffer object).\n     - ``timeout`` is the timeout in milliseconds to wait for the send.\n\n   Return value: ``None``.\n```\n\n----------------------------------------\n\nTITLE: Finalizing MicroPython Build for Zephyr\nDESCRIPTION: Adds dependencies, includes MicroPython build rules, and specifies additional source files for the Zephyr app. It also links the app with the MicroPython library.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/zephyr/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(${MICROPY_TARGET} zephyr_generated_headers)\n\ninclude(${MICROPY_DIR}/py/mkrules.cmake)\n\ntarget_sources(app PRIVATE\n    src/zephyr_start.c\n    src/zephyr_getchar.c\n)\n\ntarget_link_libraries(app PRIVATE ${MICROPY_TARGET})\n```\n\n----------------------------------------\n\nTITLE: Setting Garbage Collection Threshold in MicroPython\nDESCRIPTION: This snippet shows how to set a threshold for automatic garbage collection in MicroPython. It sets the threshold to trigger when more than 25% of the currently free heap becomes occupied.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ngc.collect()\ngc.threshold(gc.mem_free() // 4 + gc.mem_alloc())\n```\n\n----------------------------------------\n\nTITLE: Downloading and Extracting ESP8266 Toolchain in Bash\nDESCRIPTION: These commands download and extract the pre-built toolchain for ESP8266. They should be run in the directory where you want to install the toolchain.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cd ~/espressif # Change as necessary\n$ wget https://github.com/jepler/esp-open-sdk/releases/download/2018-06-10/xtensa-lx106-elf-standalone.tar.gz\n$ tar zxvf xtensa-lx106-elf-standalone.tar.gz\n$ rm xtensa-lx106-elf/bin/esptool.py  # Use system version of esptool.py instead.\n```\n\n----------------------------------------\n\nTITLE: Using push() and pop() Instructions with Register Sets in MicroPython\nDESCRIPTION: Example showing how to save and restore registers using push() and pop() operations. The code demonstrates that register order doesn't matter in the set notation, as long as the same registers are included in both operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_stack.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npush({r1, r8, r7}) # Save three registers on the stack.\npop({r7, r1, r8}) # Restore them\n```\n\n----------------------------------------\n\nTITLE: Initializing MicroPython Timer in One-Shot Mode\nDESCRIPTION: Example of initializing a Timer object in one-shot mode. This snippet configures the timer to fire once after a 1000ms delay.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.Timer.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntim.init(mode=Timer.ONE_SHOT, period=1000, callback=mycallback)\n```\n\n----------------------------------------\n\nTITLE: Enabling Garbage Collection in MicroPython\nDESCRIPTION: Enables automatic garbage collection in MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/gc.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ngc.enable()\n```\n\n----------------------------------------\n\nTITLE: Using Deep-Sleep Mode in MicroPython on ESP32\nDESCRIPTION: Example demonstrating how to use deep-sleep mode on ESP32 with MicroPython. Deep-sleep mode allows for significant power saving, and the device can be configured to wake up after a certain time or on specific events.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nimport machine\n\n# check if the device woke from a deep sleep\nif machine.reset_cause() == machine.DEEPSLEEP_RESET:\n    print('woke from a deep sleep')\n\n# put the device to sleep for 10 seconds\nmachine.deepsleep(10000)\n```\n\n----------------------------------------\n\nTITLE: Running Garbage Collection in MicroPython\nDESCRIPTION: Manually initiates a garbage collection cycle in MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/gc.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ngc.collect()\n```\n\n----------------------------------------\n\nTITLE: Reading DHT Sensor Data in MicroPython\nDESCRIPTION: This code snippet demonstrates how to read data from a DHT11 sensor using the dht driver in MicroPython.  It creates a DHT11 object on a specified pin and then calls the measure method to read the humidity and temperature values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nimport dht\nimport machine\n\nd = dht.DHT11(machine.Pin('D4'))\nd.measure()\n```\n\n----------------------------------------\n\nTITLE: Directory Mounting\nDESCRIPTION: Mounts current local directory to /remote on device and starts REPL session.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\nmpremote mount .\n```\n\n----------------------------------------\n\nTITLE: Loading 32-bit Word from Memory in ARM Thumb Assembly\nDESCRIPTION: Loads a 32-bit word from memory at address [Rn + imm7] into register Rt. The imm7 offset is measured in bytes and allows access to word-aligned values with a maximum offset of 31 words.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_ldr.rst#2025-04-21_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\nldr(Rt, [Rn, imm7])\n```\n\n----------------------------------------\n\nTITLE: Formatting the Internal Filesystem in MicroPython\nDESCRIPTION: This code snippet is used for formatting the internal flash drive of the WiPy, which is useful in case of filesystem corruption. It deletes all files on the internal storage and restores the system files to their original state after the next reset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/reset.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nimport os\nos.mkfs('/flash')\n```\n\n----------------------------------------\n\nTITLE: Getting or Setting LED Intensity in MicroPython\nDESCRIPTION: Gets or sets the LED intensity. Intensity ranges from 0 (off) to 255 (full on). If no argument is given, it returns the current intensity. If an argument is provided, it sets the intensity and returns None.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.LED.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nLED.intensity([value])\n```\n\n----------------------------------------\n\nTITLE: Using the time Module for Delays and Timing\nDESCRIPTION: Illustrates how to use the time module in MicroPython on a Renesas RA board to perform task delays and measure durations. This snippet covers functions like time.sleep() for different time units and time.ticks_ms() for timing operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/quickref.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport time\n\ntime.sleep(1)           # sleep for 1 second\ntime.sleep_ms(500)      # sleep for 500 milliseconds\ntime.sleep_us(10)       # sleep for 10 microseconds\nstart = time.ticks_ms() # get value of millisecond counter\ndelta = time.ticks_diff(time.ticks_ms(), start) # compute time difference\n```\n\n----------------------------------------\n\nTITLE: WebREPL Setup and Configuration\nDESCRIPTION: Shows how to configure and start the WebREPL daemon for browser-based interaction.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nimport webrepl_setup\n```\n\nLANGUAGE: python\nCODE:\n```\nimport webrepl\nwebrepl.start()\n```\n\n----------------------------------------\n\nTITLE: Setting and Getting RTC Date/Time in MicroPython\nDESCRIPTION: This code snippet shows how to set and get the date and time using the RTC (Real Time Clock) class in MicroPython. It demonstrates setting a specific date and time, and then retrieving the current date and time in different formats.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import RTC\n\nrtc = RTC()\nrtc.datetime((2017, 8, 23, 0, 1, 12, 48, 0)) # set a specific date and\n                                             # time, eg. 2017/8/23 1:12:48\n                                             # the day-of-week value is ignored\nrtc.datetime() # get date and time\nrtc.now() # return date and time in CPython format.\n```\n\n----------------------------------------\n\nTITLE: Resetting the Machine in MicroPython - Python\nDESCRIPTION: This Python command is used to reset the machine in a MicroPython environment. It is part of the OTA firmware update process, ensuring that the new image is loaded correctly.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/cc3200/README.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport machine\nmachine.reset()\n```\n\n----------------------------------------\n\nTITLE: Accessing MicroPython REPL\nDESCRIPTION: Commands to access the MicroPython REPL via serial connection using mpremote or picocom.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/README.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote\n$ picocom /dev/ttyACM0\n```\n\n----------------------------------------\n\nTITLE: File Copy Command with REPL\nDESCRIPTION: Example showing how to copy a file to device and enter REPL using the + operator to separate commands\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote fs cp main.py :main.py + repl\n```\n\n----------------------------------------\n\nTITLE: Building Board Firmware in Makefile\nDESCRIPTION: Command to build the firmware for a specific board. This example uses the SEEED_ARCH_MIX board. The resulting binary images will be produced in the corresponding build directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/mimxrt/README.md#2025-04-21_snippet_2\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make BOARD=SEEED_ARCH_MIX\n```\n\n----------------------------------------\n\nTITLE: Moving Data Between ARM Core and FPU Registers\nDESCRIPTION: These instructions allow data transfer between ARM core registers and floating-point registers. They also provide access to the FPSCR register which stores condition codes for floating-point operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_float.rst#2025-04-21_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\nvmov(Sd, Rm) \"Sd = Rm\"\nvmov(Rd, Sm) \"Rd = Sm\"\nvmrs(APSR_nzcv, FPSCR)\nvmrs(Rd, FPSCR) \"Rd = FPSCR\"\n```\n\n----------------------------------------\n\nTITLE: Testing New MicroPython Module\nDESCRIPTION: Example showing how to import and test the newly implemented subsystem module in MicroPython REPL.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/library.rst#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n>>> import subsystem\n>>> subsystem.info()\n42\n>>>\n```\n\n----------------------------------------\n\nTITLE: Using Delay and Timing - MicroPython\nDESCRIPTION: This snippet demonstrates how to use the time module to create delays and measure time intervals. It includes functions to pause execution for specified durations in seconds, milliseconds, and microseconds.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/quickref.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport time\n\ntime.sleep(1)               # sleep for 1 second\n\ntime.sleep_ms(500)          # sleep for 500 milliseconds\n\ntime.sleep_us(10)           # sleep for 10 microseconds\n\nstart = time.ticks_ms()     # get millisecond counter\ndelta = time.ticks_diff(time.ticks_ms(), start) # compute time difference\n```\n\n----------------------------------------\n\nTITLE: Directory Listing and Navigation\nDESCRIPTION: Functions for changing directories, getting current directory, and listing directory contents with optional metadata.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/os.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nchdir(path)\ngetcwd()\nilistdir([dir])\nlistdir([dir])\n```\n\n----------------------------------------\n\nTITLE: Configuring WLANWiPy as Station in MicroPython\nDESCRIPTION: This snippet demonstrates how to configure the WLANWiPy object as a station for connecting to existing WiFi networks.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.WLANWiPy.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# configure as an station\nwlan.init(mode=WLAN.STA)\n```\n\n----------------------------------------\n\nTITLE: Converting Binary Data to Hexadecimal in MicroPython\nDESCRIPTION: The hexlify function converts bytes to a hexadecimal representation. It takes a data object and an optional separator, returning a bytes object.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/binascii.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nhexlify(data, [sep])\n```\n\n----------------------------------------\n\nTITLE: Initializing I2C on WiPy with MicroPython\nDESCRIPTION: Demonstrates how to create an I2C instance on WiPy using default settings or with custom frequency and pin assignments.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ni2c = machine.I2C()\n```\n\nLANGUAGE: python\nCODE:\n```\ni2c = machine.I2C(freq=400000, scl='GP23', sda='GP13')\n```\n\n----------------------------------------\n\nTITLE: Retrieving WLAN Instance in MicroPython\nDESCRIPTION: This code snippet demonstrates how to retrieve the current WLAN instance on a WiPy device using the `network` module. It initializes the WLAN object without parameters. This assumes that the WLAN is enabled and the `network` module is available.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/wlan.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from network import WLAN\n>>> wlan = WLAN() # we call the constructor without params\n```\n\n----------------------------------------\n\nTITLE: Using zlib.decompress Function in MicroPython\nDESCRIPTION: Decompresses data into a bytes object using the DEFLATE algorithm. The wbits parameter controls window size and format detection, with values 0-47 having special meanings for automatic format detection.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zlib.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndecompress(data, wbits=15, /)\n```\n\n----------------------------------------\n\nTITLE: Example package.json for MicroPython Packages\nDESCRIPTION: A sample package.json file structure for a MicroPython package, showing how to specify files to be installed, dependencies on other packages, and package version information.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"urls\": [\n    [\"mlx90640/__init__.py\", \"mlx90640/__init__.py\"],\n    [\"mlx90640/utils.py\", \"mlx90640/utils.py\"]\n  ],\n  \"deps\": [\n    [\"collections-defaultdict\", \"latest\"],\n    [\"os-path\", \"latest\"],\n    [\"github:org/micropython-additions\", \"main\"],\n    [\"gitlab:org/micropython-otheradditions\", \"main\"]\n  ],\n  \"version\": \"0.2\"\n}\n```\n\n----------------------------------------\n\nTITLE: POSIX Filesystem Class Constructor\nDESCRIPTION: Creates a filesystem object that accesses the host POSIX filesystem, with optional root path specification.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/vfs.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nVfsPosix(root=None)\n```\n\n----------------------------------------\n\nTITLE: Installing ESP-IDF Environment\nDESCRIPTION: Commands to install the ESP-IDF toolchain and set up the development environment for different platforms\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ cd esp-idf\n$ ./install.sh esp32 # (or install.bat on Windows)\n$ source export.sh   # (or export.bat on Windows)\n```\n\n----------------------------------------\n\nTITLE: Defining BLE Characteristic Flags in MicroPython\nDESCRIPTION: Constants for BLE characteristic and descriptor flags that define their behavior, security, and privacy requirements. These flags control read/write permissions, notifications, indications, and various authentication requirements.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom micropython import const\n_FLAG_BROADCAST = const(0x0001)\n_FLAG_READ = const(0x0002)\n_FLAG_WRITE_NO_RESPONSE = const(0x0004)\n_FLAG_WRITE = const(0x0008)\n_FLAG_NOTIFY = const(0x0010)\n_FLAG_INDICATE = const(0x0020)\n_FLAG_AUTHENTICATED_SIGNED_WRITE = const(0x0040)\n\n_FLAG_AUX_WRITE = const(0x0100)\n_FLAG_READ_ENCRYPTED = const(0x0200)\n_FLAG_READ_AUTHENTICATED = const(0x0400)\n_FLAG_READ_AUTHORIZED = const(0x0800)\n_FLAG_WRITE_ENCRYPTED = const(0x1000)\n_FLAG_WRITE_AUTHENTICATED = const(0x2000)\n_FLAG_WRITE_AUTHORIZED = const(0x4000)\n```\n\n----------------------------------------\n\nTITLE: Using OrderedDict in MicroPython\nDESCRIPTION: Example showing how to use OrderedDict to maintain insertion order of dictionary items. Demonstrates initialization from a sequence of key-value pairs and adding new items while preserving order.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/collections.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom collections import OrderedDict\n\n# To make benefit of ordered keys, OrderedDict should be initialized\n# from sequence of (key, value) pairs.\nd = OrderedDict([(\"z\", 1), (\"a\", 2)])\n# More items can be added as usual\nd[\"w\"] = 5\nd[\"b\"] = 3\nfor k, v in d.items():\n    print(k, v)\n```\n\n----------------------------------------\n\nTITLE: Using OneWire Driver in MicroPython on ESP32\nDESCRIPTION: Example showing how to use the OneWire driver on ESP32 with MicroPython. This software implementation works on all pins and allows communication with 1-Wire devices.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin\nimport onewire\n\now = onewire.OneWire(Pin(12)) # create a OneWire bus on GPIO12\now.scan()               # return a list of devices on the bus\now.reset()              # reset the bus\now.readbyte()           # read a byte\now.writebyte(0x12)      # write a byte on the bus\now.write('123')         # write bytes on the bus\now.select_rom(b'12345678') # select a specific device by its ROM code\n```\n\n----------------------------------------\n\nTITLE: Deadline Calculation Example\nDESCRIPTION: Example demonstrating how to calculate and check against a deadline using ticks_add() and ticks_diff()\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/time.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndeadline = ticks_add(time.ticks_ms(), 200)\nwhile ticks_diff(deadline, time.ticks_ms()) > 0:\n    do_a_little_of_something()\n```\n\n----------------------------------------\n\nTITLE: Breathing LED Effect with PWM in MicroPython\nDESCRIPTION: This code modifies the fading LED effect to create a breathing effect, where the LED fades from dim to bright and then back to dim. It achieves this by reversing the increment step (`wstep`) when the pulse width reaches its maximum or minimum values. This creates a smooth transition between increasing and decreasing brightness.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/fading_led.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nwhile True:\n  tchannel.pulse_width(cur_width)\n\n  sleep(0.01)\n\n  cur_width += wstep\n\n  if cur_width > max_width:\n    cur_width = max_width\n    wstep *= -1\n  elif cur_width < min_width:\n    cur_width = min_width\n    wstep *= -1\n```\n\n----------------------------------------\n\nTITLE: Logical Instruction Example (XOR Operation)\nDESCRIPTION: Example of how to use the eor instruction to zero a register by XORing it with itself. This is equivalent to the Python operation R0 ^= R0.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_logical_bit.rst#2025-04-21_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\neor(r0, r0)\n```\n\n----------------------------------------\n\nTITLE: Set Default MicroPython Board\nDESCRIPTION: Sets the default MicroPython board to ESP32_GENERIC if the MICROPY_BOARD variable is not already defined. Prevents potential build errors from unset board variables.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT MICROPY_BOARD)\n    set(MICROPY_BOARD ESP32_GENERIC)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Converting text address to binary with inet_pton in MicroPython\nDESCRIPTION: This snippet demonstrates the use of `socket.inet_pton` to convert a textual network address to its binary representation. This function is useful for preparing IP addresses for use in socket operations. The example shows how to convert an IPv4 address from string to binary.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/socket.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n\"\"\">>> socket.inet_pton(socket.AF_INET, \"1.2.3.4\")\nb'\\x01\\x02\\x03\\x04'\"\"\"\n```\n\n----------------------------------------\n\nTITLE: NVS Storage Method Examples\nDESCRIPTION: Method signatures for Non-Volatile Storage operations, including reading/writing integers and binary blobs.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp32.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nNVS.set_i32(key, value)\nNVS.get_i32(key)\nNVS.set_blob(key, value)\nNVS.get_blob(key, buffer)\nNVS.erase_key(key)\nNVS.commit()\n```\n\n----------------------------------------\n\nTITLE: Turning on Blue LED with pyb Module\nDESCRIPTION: This code snippet imports the `pyb` module, which provides access to the pyboard's hardware features. It then uses the `LED` class from the `pyb` module to turn on the blue LED (LED number 4).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/script.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"# main.py -- put your code here!\\nimport pyb\\npyb.LED(4).on()\"\n```\n\n----------------------------------------\n\nTITLE: Building with Custom Manifest (Bash)\nDESCRIPTION: Complete command example showing how to build firmware for a specific board (PYBD_SF2) with a custom manifest file.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/manifest.rst#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ cd ports/stm32\n$ make BOARD=PYBD_SF2 FROZEN_MANIFEST=~/src/myproject/manifest.py\n```\n\n----------------------------------------\n\nTITLE: Accessing REPL via Terminal Emulator (Linux/Mac)\nDESCRIPTION: Connect to the MicroPython REPL using the 'screen' command over a USB-serial connection on Linux or Mac.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/tutorial/repl.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nscreen /dev/ttyACM0 115200\n```\n\n----------------------------------------\n\nTITLE: Remote File Editing\nDESCRIPTION: Command to edit files on the device by copying to local temp directory and launching editor\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote edit <files...>\n```\n\n----------------------------------------\n\nTITLE: Deploying MicroPython Firmware using Make\nDESCRIPTION: This command uses the MicroPython build system to compile and deploy the firmware to the Arduino Portenta H7 board. It specifies the board type as ARDUINO_PORTENTA_H7 and uses the 'deploy' target.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/ARDUINO_PORTENTA_H7/deploy.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake BOARD=ARDUINO_PORTENTA_H7 deploy\n```\n\n----------------------------------------\n\nTITLE: Set Board Directory and Validate\nDESCRIPTION: Sets the MICROPY_BOARD_DIR variable based on the specified board and checks if the board configuration file (mpconfigboard.cmake) exists. Terminates the build with a fatal error if the specified board is invalid.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT MICROPY_BOARD_DIR)\n    set(MICROPY_BOARD_DIR ${CMAKE_CURRENT_LIST_DIR}/boards/${MICROPY_BOARD})\nendif()\nif(NOT EXISTS ${MICROPY_BOARD_DIR}/mpconfigboard.cmake)\n    message(FATAL_ERROR \"Invalid MICROPY_BOARD specified: ${MICROPY_BOARD}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Set FTP to Passive Mode - Python\nDESCRIPTION: The following code shows how to set the FTP connection to passive mode after logging in, which is necessary for proper functionality with the WiPy's FTP server.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nftp> passive\n```\n\n----------------------------------------\n\nTITLE: Querying Available Heap Memory in MicroPython\nDESCRIPTION: Returns the number of bytes of heap RAM that is available for Python code to allocate, or -1 if this amount is not known. This function is a MicroPython extension and not available in CPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/gc.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ngc.mem_free()\n```\n\n----------------------------------------\n\nTITLE: Array Indexed Assignment Operation\nDESCRIPTION: Implements indexed writing to array using square bracket notation. Supports both single value assignment with integer indices and slice assignment.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/array.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n__setitem__(index, value)\n```\n\n----------------------------------------\n\nTITLE: Using zlib.compress Function in MicroPython\nDESCRIPTION: Compresses data into a bytes object using the DEFLATE algorithm. The wbits parameter configures window size (5-15) and output format (raw DEFLATE, zlib, or gzip), offering memory usage vs compression level trade-offs.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zlib.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncompress(data, wbits=15, /)\n```\n\n----------------------------------------\n\nTITLE: Unpacking Data from Offset in Python\nDESCRIPTION: Unpacks data starting from a specified offset according to a format string. Supports negative offsets and returns tuple of unpacked values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/struct.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nunpack_from(fmt, data, offset=0, /)\n```\n\n----------------------------------------\n\nTITLE: Calculating Past Ticks Example\nDESCRIPTION: Example showing how to calculate ticks value from 100ms ago using ticks_add()\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/time.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nprint(ticks_add(time.ticks_ms(), -100))\n```\n\n----------------------------------------\n\nTITLE: Custom Manifest with Board Default and Custom Modules (Python)\nDESCRIPTION: Complete example of a custom manifest file that includes the board's default manifest, adds a custom driver module, and includes a library from micropython-lib.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/manifest.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Include the board's default manifest.\ninclude(\"$(BOARD_DIR)/manifest.py\")\n# Add a custom driver\nmodule(\"mydriver.py\")\n# Add aiorepl from micropython-lib\nrequire(\"aiorepl\")\n```\n\n----------------------------------------\n\nTITLE: Defining Assembler Functions as Static Class Methods\nDESCRIPTION: Shows how to properly define assembly functions as class methods by declaring them as static methods. This avoids receiving the self pointer as the first argument, which is usually not useful in assembly context.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_hints_tips.rst#2025-04-21_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nclass foo:\n  @staticmethod\n  @micropython.asm_thumb\n  def bar(r0):\n    add(r0, r0, r0)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating MicroPython Constant Optimization\nDESCRIPTION: Shows how MicroPython optimizes constant variables, especially those prefixed with underscore using const(). Variables defined with const() are treated as proper constants and avoid dictionary allocation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/optimizations.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom micropython import const\n\nX = const(1)\n_Y = const(2)\nfoo(X, _Y)\n```\n\n----------------------------------------\n\nTITLE: Executing filesystem commands\nDESCRIPTION: Command to execute various filesystem operations on the device, including listing directories, copying files, removing files/directories, creating directories, and calculating file checksums.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote fs <sub-command>\n```\n\n----------------------------------------\n\nTITLE: Initializing LED Object in MicroPython\nDESCRIPTION: Creates an LED object associated with a specific LED. The id parameter specifies the LED number (1-4).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.LED.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nLED(id)\n```\n\n----------------------------------------\n\nTITLE: Serializing Python Object to JSON Stream in MicroPython\nDESCRIPTION: The 'dump' function serializes a Python object to a JSON string and writes it to a given stream. It accepts optional separators to control the formatting of the output JSON.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/json.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndump(obj, stream, separators=None)\n```\n\n----------------------------------------\n\nTITLE: Configure Scroll Window - LCD160CR Method\nDESCRIPTION: Sets up a window region for scrolling with specified parameters including position, direction, speed, and colors.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.set_scroll_win(win, x=-1, y=0, w=0, h=0, vec=0, pat=0, fill=0x07e0, color=0)\n```\n\n----------------------------------------\n\nTITLE: Opening a File in MicroPython\nDESCRIPTION: Function to open a file in MicroPython. It supports the 'mode' parameter and other arguments that may vary by port.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/io.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nopen(name, mode='r', **kwargs)\n```\n\n----------------------------------------\n\nTITLE: LittleFS with internal flash using FlashArea in MicroPython\nDESCRIPTION: This code demonstrates how to use the LittleFS filesystem with internal flash memory on the reel_board or rv32m1_vega_ri5cy board using the `zephyr.FlashArea` class. It initializes the flash area as a block device, creates a LittleFS filesystem on it, mounts it to a directory, and then writes and reads a file.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/tutorial/storage.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport vfs\nfrom zephyr import FlashArea\nbdev = FlashArea(FlashArea.STORAGE, 4096)   # create block device object using FlashArea\nvfs.VfsLfs2.mkfs(bdev)                      # create Little filesystem object using the flash area block\nvfs.mount(bdev, '/flash')                   # mount the filesystem at the flash storage subdirectory\nwith open('/flash/hello.txt','w') as f:     # open a new file in the directory\n    f.write('Hello world')                  # write to the file\nprint(open('/flash/hello.txt').read())      # print contents of the file\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython for WeAct F411 Blackpill v3.1 (8MHz) with 4MB Flash\nDESCRIPTION: This command builds MicroPython for a WeAct F411 Blackpill v3.1 board with an 8MHz crystal and a 4MB SPI flash chip. It specifies the board type, variant, and SPI flash size.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/WEACT_F411_BLACKPILL/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake -C ports/stm32 BOARD=WEACT_F411_BLACKPILL BOARD_VARIANT=V31_XTAL_8M SPI_FLASH_SIZE_MB=4\n```\n\n----------------------------------------\n\nTITLE: Building Firmware for SAMD Board\nDESCRIPTION: Commands to clean the build directory and then compile the firmware for a specific board (ADAFRUIT_ITSYBITSY_M4_EXPRESS in this example). The resulting binary images will be placed in the corresponding build directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/samd/README.md#2025-04-21_snippet_2\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make BOARD=ADAFRUIT_ITSYBITSY_M4_EXPRESS clean\n$ make BOARD=ADAFRUIT_ITSYBITSY_M4_EXPRESS\n```\n\n----------------------------------------\n\nTITLE: Configuring Mboot Filesystem Support in mpconfigboard.h\nDESCRIPTION: Example configuration for enabling filesystem support in Mboot. Defines flags for FAT, LFS1, LFS2, and RAW filesystem types.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/mboot/README.md#2025-04-21_snippet_5\n\nLANGUAGE: C\nCODE:\n```\n#define MBOOT_FSLOAD (1)\n#define MBOOT_VFS_FAT (1)\n#define MBOOT_VFS_LFS1 (1)\n#define MBOOT_VFS_LFS2 (1)\n#define MBOOT_VFS_RAW (1)\n```\n\n----------------------------------------\n\nTITLE: Default main.py Content\nDESCRIPTION: This is the default content of the `main.py` file, which is a Python script that runs after `boot.py` when the pyboard starts. The `#` character indicates a comment, which the Python interpreter ignores.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/script.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"# main.py -- put your code here!\"\n```\n\n----------------------------------------\n\nTITLE: Controlling MCPWM0 Peripheral via Direct Register Access in Python\nDESCRIPTION: This code demonstrates how to enable and configure the MCPWM0 peripheral on an ESP32 by directly manipulating hardware registers. It shows enabling the peripheral clock, taking it out of reset, and changing the prescaler value.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/tutorial/peripheral_access.rst#2025-04-21_snippet_0\n\nLANGUAGE: python3\nCODE:\n```\nfrom micropython import const\nfrom machine import mem32\n\n# Define the register addresses that will be used.\nDR_REG_DPORT_BASE = const(0x3FF00000)\nDPORT_PERIP_CLK_EN_REG = const(DR_REG_DPORT_BASE + 0x0C0)\nDPORT_PERIP_RST_EN_REG = const(DR_REG_DPORT_BASE + 0x0C4)\nDPORT_PWM0_CLK_EN = const(1 << 17)\nMCPWM0 = const(0x3FF5E000)\nMCPWM1 = const(0x3FF6C000)\n\n# Enable CLK and disable RST.\nprint(hex(mem32[DPORT_PERIP_CLK_EN_REG] & 0xffffffff))\nprint(hex(mem32[DPORT_PERIP_RST_EN_REG] & 0xffffffff))\nmem32[DPORT_PERIP_CLK_EN_REG] |= DPORT_PWM0_CLK_EN\nmem32[DPORT_PERIP_RST_EN_REG] &= ~DPORT_PWM0_CLK_EN\nprint(hex(mem32[DPORT_PERIP_CLK_EN_REG] & 0xffffffff))\nprint(hex(mem32[DPORT_PERIP_RST_EN_REG] & 0xffffffff))\n\n# Change the MCPWM0 prescaler.\nprint(hex(mem32[MCPWM0])) # read PWM_CLK_CFG_REG (reset value = 0)\nmem32[MCPWM0] = 0x55      # change PWM_CLK_PRESCALE\nprint(hex(mem32[MCPWM0])) # read PWM_CLK_CFG_REG\n```\n\n----------------------------------------\n\nTITLE: File Update with Soft Reset and REPL\nDESCRIPTION: Updates a file, performs soft reset, and starts REPL session.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\nmpremote cp utils/driver.py :utils/driver.py + soft-reset repl\n```\n\n----------------------------------------\n\nTITLE: Interrupt Control Example in MicroPython\nDESCRIPTION: Shows how to safely disable and re-enable interrupts for time-critical operations using the machine module's interrupt control functions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport machine\n\n# Disable interrupts\nstate = machine.disable_irq()\n\n# Do a small amount of time-critical work here\n\n# Enable interrupts\nmachine.enable_irq(state)\n```\n\n----------------------------------------\n\nTITLE: Minimal boot.py Configuration for Mouse Functionality\nDESCRIPTION: The minimal code required in boot.py to configure the pyboard as both a serial device and a mouse, suitable if you've already modified your boot.py file.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/usb_mouse.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport pyb\npyb.usb_mode('VCP+HID')\n```\n\n----------------------------------------\n\nTITLE: Building Reduced FlashROM Variants for ESP8266 in Bash\nDESCRIPTION: These commands build MicroPython for ESP8266 modules with reduced flash memory. The FLASH_512K variant is for 512kiB modules, while FLASH_1M is for 1MiB modules.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ make BOARD=ESP8266_GENERIC BOARD_VARIANT=FLASH_512K\n$ make BOARD=ESP8266_GENERIC BOARD_VARIANT=FLASH_1M\n```\n\n----------------------------------------\n\nTITLE: Deploying MicroPython Firmware via nrfjprog on Arduino Nano 33 BLE\nDESCRIPTION: This command uses nrfjprog (with Jlink) to deploy MicroPython firmware to the Arduino Nano 33 BLE board. It builds and deploys the firmware for the specified board and softdevice version. This method requires the MicroPython source repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/boards/ARDUINO_NANO_33_BLE_SENSE/deploy.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake -j8 BOARD=arduino_nano_33_ble_sense SD=s140 deploy\n```\n\n----------------------------------------\n\nTITLE: Obtaining Submodules for Renesas RA Port\nDESCRIPTION: Command to obtain the required submodules for building the Renesas RA port. This should be executed from the ports/renesas-ra/ directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/renesas-ra/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ make submodules\n```\n\n----------------------------------------\n\nTITLE: Running Embedded MicroPython Example\nDESCRIPTION: Command to execute the compiled embedded MicroPython application\nSOURCE: https://github.com/micropython/micropython/blob/master/examples/embedding/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ ./embed\n```\n\n----------------------------------------\n\nTITLE: Running Tests on Hardware Board\nDESCRIPTION: Command for running tests on a physical board connected via serial port.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/writingtests.rst#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ ./run-tests.py -t /dev/ttyACM0\n```\n\n----------------------------------------\n\nTITLE: Using Custom C Module Function in MicroPython\nDESCRIPTION: This example demonstrates how to import and use a function from a custom C module in MicroPython. It imports the 'cexample' module and calls the 'add_ints' function with two integer arguments.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/cmodules.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport cexample\nprint(cexample.add_ints(1, 3))\n# should display 4\n```\n\n----------------------------------------\n\nTITLE: Integer Frequency ADC Reading\nDESCRIPTION: Alternative example of timed ADC reading using an integer frequency value instead of a Timer object\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.ADC.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nadc = pyb.ADC(pyb.Pin.board.X19)    # create an ADC on pin X19\nbuf = bytearray(100)                # create a buffer of 100 bytes\nadc.read_timed(buf, 10)             # read analog values into buf at 10Hz\n                                   #   this will take 10 seconds to finish\nfor val in buf:                     # loop over all values\n    print(val)                      # print the value out\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Gzip Files in Python using gzip.GzipFile\nDESCRIPTION: Demonstrates how to read from and write to gzip-compressed files using the gzip.GzipFile class. It shows both direct usage of GzipFile and the convenience wrapper gzip.open().\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/gzip.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport gzip\n\n# Reading:\nwith open(\"data.gz\", \"rb\") as f:\n    with gzip.GzipFile(fileobj=f, mode=\"rb\") as g:\n        # Use g.read(), g.readinto(), etc.\n\n # Same, but using gzip.open:\nwith gzip.open(\"data.gz\", \"rb\") as f:\n     # Use f.read(), f.readinto(), etc.\n\n# Writing:\nwith open(\"data.gz\", \"wb\") as f:\n    with gzip.GzipFile(fileobj=f, mode=\"wb\") as g:\n        # Use g.write(...) etc\n\n# Same, but using gzip.open:\nwith gzip.open(\"data.gz\", \"wb\") as f:\n    # Use f.write(...) etc\n\n# Write a dictionary as JSON in gzip format, with a\n# small (64 byte) window size.\nconfig = { ... }\nwith gzip.open(\"config.gz\", \"wb\") as f:\n    json.dump(config, f)\n```\n\n----------------------------------------\n\nTITLE: Compressing and Decompressing Bytes Objects Using BytesIO in Python\nDESCRIPTION: Illustrates how to use DeflateIO with BytesIO to compress and decompress bytes or bytearray objects that are not in stream format.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/deflate.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport deflate, io\n\n# Decompress a bytes/bytearray value.\ncompressed_data = get_data_z()\nwith deflate.DeflateIO(io.BytesIO(compressed_data), deflate.ZLIB) as d:\n    decompressed_data = d.read()\n\n# Compress a bytes/bytearray value.\nuncompressed_data = get_data()\nstream = io.BytesIO()\nwith deflate.DeflateIO(stream, deflate.ZLIB) as d:\n    d.write(uncompressed_data)\ncompressed_data = stream.getvalue()\n```\n\n----------------------------------------\n\nTITLE: Constructing WIZNET5K Object in MicroPython\nDESCRIPTION: This code snippet shows the constructor for the WIZNET5K class. It initializes a WIZNET5K driver object using the specified SPI bus and pins for chip select and reset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.WIZNET5K.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nWIZNET5K(spi, pin_cs, pin_rst)\n```\n\n----------------------------------------\n\nTITLE: Allocating Emergency Exception Buffer in MicroPython\nDESCRIPTION: Creates an emergency exception buffer to enable error reporting from interrupt service routines. This is essential for debugging code that uses interrupts in MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/isr_rules.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport micropython\nmicropython.alloc_emergency_exception_buf(100)\n```\n\n----------------------------------------\n\nTITLE: Flashing MicroPython Firmware to ESP32\nDESCRIPTION: Commands to erase existing firmware and deploy new MicroPython firmware to an ESP32 microcontroller\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ make erase\n$ make deploy\n```\n\n----------------------------------------\n\nTITLE: Programming Arduino Nano ESP32 via DFU Bootloader using Bash\nDESCRIPTION: This bash command is used to program the Arduino Nano ESP32 board using the DFU bootloader. The dfu-util tool is required for this operation. Key parameter includes the device ID (0x2341:0x0070) for selecting the correct USB device. The command uploads the specified .app-bin file and resets the board after flashing. This process assumes the DFU bootloader is factory flashed, and if erased, it needs to be re-installed.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/boards/ARDUINO_NANO_ESP32/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndfu-util -d 0x2341:0x0070 -R -D build-ARDUINO_NANO_ESP32/micropython.app-bin\n```\n\n----------------------------------------\n\nTITLE: Generating Elliptic Curve Key/Certificate Pair for MicroPython Tests\nDESCRIPTION: These commands create an elliptic curve key and a corresponding certificate using OpenSSL, then convert them to DER format for use in MicroPython SSL/TLS tests.\nSOURCE: https://github.com/micropython/micropython/blob/master/tests/README.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ openssl ecparam -name prime256v1 -genkey -noout -out ec_key.pem\n$ openssl pkey -in ec_key.pem -out ec_key.der -outform DER\n$ openssl req -new -x509 -key ec_key.pem -out ec_cert.der -outform DER -days 3650 -nodes -subj '/CN=micropython.local/O=MicroPython/C=AU'\n```\n\n----------------------------------------\n\nTITLE: Creating SHA256 Hasher Object in MicroPython\nDESCRIPTION: Constructor for creating an SHA256 hasher object. Optionally accepts initial data to feed into the hash.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/hashlib.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nhashlib.sha256([data])\n```\n\n----------------------------------------\n\nTITLE: Random Float Generation in MicroPython\nDESCRIPTION: Returns a random floating point number in the half-open interval [0.0, 1.0).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/random.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nrandom()\n```\n\n----------------------------------------\n\nTITLE: Getting Timer Source Frequency in MicroPython\nDESCRIPTION: Method for retrieving the frequency of the timer's source clock. This is the base frequency before any prescaler is applied.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nTimer.source_freq()\n```\n\n----------------------------------------\n\nTITLE: Retrieving MAC Address Configuration\nDESCRIPTION: Example showing how to retrieve the MAC address from the LAN interface configuration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.LAN.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmac = LAN.config(\"mac\")\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Software SPI in MicroPython on SAMD21/SAMD51\nDESCRIPTION: This snippet shows how to set up a Software SPI bus using bit-banging. It demonstrates initialization with custom pins and various read/write operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SoftSPI\n\n# construct a SoftSPI bus on the given pins\n# polarity is the idle state of SCK\n# phase=0 means sample on the first edge of SCK, phase=1 means the second\nspi = SoftSPI(baudrate=100000, polarity=1, phase=0, sck=Pin('D7'), mosi=Pin('D9'), miso=Pin('D10'))\n\nspi.init(baudrate=200000) # set the baud rate\n\nspi.read(10)            # read 10 bytes on MISO\nspi.read(10, 0xff)      # read 10 bytes while outputting 0xff on MOSI\n\nbuf = bytearray(50)     # create a buffer\nspi.readinto(buf)       # read into the given buffer (reads 50 bytes in this case)\nspi.readinto(buf, 0xff) # read into the given buffer and output 0xff on MOSI\n\nspi.write(b'12345')     # write 5 bytes on MOSI\n\nbuf = bytearray(4)      # create a buffer\nspi.write_readinto(b'1234', buf) # write to MOSI and read from MISO into the buffer\nspi.write_readinto(buf, buf) # write buf to MOSI and read MISO back into buf\n```\n\n----------------------------------------\n\nTITLE: Configuring Mboot SPI Flash in mpconfigboard.h\nDESCRIPTION: Example configuration for programming external SPI flash via DFU and I2C interfaces. Defines address range, size, layout, and other SPI flash parameters.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/mboot/README.md#2025-04-21_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n#define MBOOT_SPIFLASH_ADDR (0x80000000)\n#define MBOOT_SPIFLASH_BYTE_SIZE (2 * 1024 * 1024)\n#define MBOOT_SPIFLASH_LAYOUT \"/0x80000000/64*32Kg\"\n#define MBOOT_SPIFLASH_ERASE_BLOCKS_PER_PAGE (32 / 4)\n#define MBOOT_SPIFLASH_SPIFLASH (&spi_bdev.spiflash)\n#define MBOOT_SPIFLASH_CONFIG (&spiflash_config)\n```\n\n----------------------------------------\n\nTITLE: Copying Prefixed LittleFS Files\nDESCRIPTION: This shell command copies the prefixed LittleFS source files (lfs1*.[ch] or lfs2*.[ch]) into the MicroPython library directory ($MPY_DIR/lib/littlefs). The $MPY_DIR variable must be set to the path of the MicroPython project.\nSOURCE: https://github.com/micropython/micropython/blob/master/lib/littlefs/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncp lfs1*.[ch] $MPY_DIR/lib/littlefs\n```\n\nLANGUAGE: shell\nCODE:\n```\ncp lfs2*.[ch] $MPY_DIR/lib/littlefs\n```\n\n----------------------------------------\n\nTITLE: Compressing and Decompressing JSON Data with Gzip in Python\nDESCRIPTION: Shows how to use DeflateIO with JSON operations to compress and decompress data in gzip format. It demonstrates setting a custom window size of 64 bytes.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/deflate.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport deflate, json\n\n# Write a dictionary as JSON in gzip format, with a\n# small (64 byte) window size.\nconfig = { ... }\nwith open(\"config.gz\", \"wb\") as f:\n    with deflate.DeflateIO(f, deflate.GZIP, 6) as f:\n        json.dump(config, f)\n\n# Read back that dictionary.\nwith open(\"config.gz\", \"rb\") as f:\n    with deflate.DeflateIO(f, deflate.GZIP, 6) as f:\n        config = json.load(f)\n```\n\n----------------------------------------\n\nTITLE: Connecting to WiPy via Serial on macOS\nDESCRIPTION: This command connects to the WiPy board via a serial connection using the `screen` utility.  `/dev/tty.usbmodem*` represents the serial port of the USB-to-serial adapter.  The `115200` parameter sets the baud rate.  The exact port name might vary.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/repl.rst#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ screen /dev/tty.usbmodem* 115200\n```\n\n----------------------------------------\n\nTITLE: Array Creation and Initialization in MicroPython\nDESCRIPTION: Creates an array with specified typecode and optional initial contents. Supports various format codes including b, B, h, H, i, I, l, L, q, Q, f, d for different numeric types.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/array.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\narray(typecode, [iterable])\n```\n\n----------------------------------------\n\nTITLE: Running the MicroPython Unix Port REPL\nDESCRIPTION: This command starts the MicroPython REPL (Read-Eval-Print Loop) for interactive use.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/unix/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ./build-standard/micropython\n```\n\n----------------------------------------\n\nTITLE: Defining a Grammar Rule with Compile Function in C\nDESCRIPTION: Implementation of a grammar rule for the 'add1' statement with an associated compile function. The rule specifies that 'add1' takes one numeric argument and has two nodes associated with it.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nDEF_RULE(add1_stmt, c(add1_stmt), and(2), tok(KW_ADD1), rule(testlist))\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Subroutine Call in MicroPython ARM Assembly\nDESCRIPTION: Demonstrates a simple function call structure using the inline assembler. The code shows how to branch around subroutines, call them using bl(), and return using bx(lr). The example quadruples a number by doubling it twice.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_hints_tips.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n@micropython.asm_thumb\ndef quad(r0):\n    b(START)\n    label(DOUBLE)\n    add(r0, r0, r0)\n    bx(lr)\n    label(START)\n    bl(DOUBLE)\n    bl(DOUBLE)\n\nprint(quad(10))\n```\n\n----------------------------------------\n\nTITLE: Flashing Firmware with dfu-util for Arduino Nicla Vision\nDESCRIPTION: This command uses dfu-util to write firmware to the Arduino Nicla Vision board. It specifies the device ID, firmware file, and necessary options for the flashing process.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/ARDUINO_NICLA_VISION/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndfu-util -w -a 0 -d 2341:035b -D build-ARDUINO_NICLA_VISION/firmware.dfu\n```\n\n----------------------------------------\n\nTITLE: Flashing Firmware to Arduino Portenta C33 using dfu-util\nDESCRIPTION: This command uses dfu-util to program the Arduino Portenta C33 board with a new firmware. It specifies the device ID, firmware file, and other necessary parameters for the DFU process.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/renesas-ra/boards/ARDUINO_PORTENTA_C33/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndfu-util -a 0 -d 2341:0368 -D build-ARDUINO_PORTENTA_C33/firmware.bin -Q # -s :leave\n```\n\n----------------------------------------\n\nTITLE: Configuring MicroPython Remote Custom Commands\nDESCRIPTION: Example configuration file (.config/mpremote/config.py) showing how to define custom macro commands for mpremote, including device connection shortcuts and custom command definitions with help text.\nSOURCE: https://github.com/micropython/micropython/blob/master/tools/mpremote/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Custom macro commands\ncommands = {\n    \"c33\": \"connect id:334D335C3138\",\n    \"bl\": \"bootloader\",\n    \"double x=4\": {\n        \"command\": \"eval x*2\",\n        \"help\": \"multiply by two\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Remote Repositories - Bash\nDESCRIPTION: Commands to configure remote repositories for upstream tracking\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/gettingstarted.rst#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cd micropython\n$ git remote add upstream https://github.com/micropython/micropython\n```\n\n----------------------------------------\n\nTITLE: Using BLE.gap_passkey Method in MicroPython\nDESCRIPTION: Responds to a _IRQ_PASSKEY_ACTION event with the appropriate passkey based on the action type: input, display, or numeric comparison.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nBLE.gap_passkey(conn_handle, action, passkey, /)\n```\n\n----------------------------------------\n\nTITLE: Querying Allocated Heap Memory in MicroPython\nDESCRIPTION: Returns the number of bytes of heap RAM that are allocated by Python code. This function is a MicroPython extension and not available in CPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/gc.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ngc.mem_alloc()\n```\n\n----------------------------------------\n\nTITLE: Writing and Reading Zlib-Compressed Streams in Python\nDESCRIPTION: Demonstrates how to use DeflateIO to write and read zlib-compressed streams to/from files. It shows the default window size usage for writing and auto-detection for reading.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/deflate.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport deflate\n\n# Writing a zlib-compressed stream (uses the default window size of 256 bytes).\nwith open(\"data.gz\", \"wb\") as f:\n    with deflate.DeflateIO(f, deflate.ZLIB) as d:\n        # Use d.write(...) etc\n\n# Reading a zlib-compressed stream (auto-detect window size).\nwith open(\"data.z\", \"rb\") as f:\n    with deflate.DeflateIO(f, deflate.ZLIB) as d:\n        # Use d.read(), d.readinto(), etc.\n```\n\n----------------------------------------\n\nTITLE: Timed ADC Reading with Timer\nDESCRIPTION: Example of reading ADC values at a specific frequency using a Timer object. Demonstrates sampling analog values into a buffer at 10Hz.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.ADC.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nadc = pyb.ADC(pyb.Pin.board.X19)    # create an ADC on pin X19\ntim = pyb.Timer(6, freq=10)         # create a timer running at 10Hz\nbuf = bytearray(100)                # creat a buffer to store the samples\nadc.read_timed(buf, tim)            # sample 100 values, taking 10s\n```\n\n----------------------------------------\n\nTITLE: Managing Network Server on WiPy with MicroPython\nDESCRIPTION: This code snippet shows how to initialize and control a network server on the WiPy board by configuring user authentication and managing server timeout settings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nfrom network import Server\n\n# init with new user, password and seconds timeout\nserver = Server(login=('user', 'password'), timeout=60)\nserver.timeout(300) # change the timeout\nserver.timeout() # get the timeout\nserver.isrunning() # check whether the server is running or not\n```\n\n----------------------------------------\n\nTITLE: Implementing Read and Write Blocks in DiskAccess with Python\nDESCRIPTION: This implementation provides methods to read and write data blocks directly to storage devices. Using block number and buffer as parameters, these methods transfer data between disk devices and memory. It adheres to the block protocol as defined by the Zephyr documentation, enabling extended access capabilities.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.DiskAccess.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef readblocks(self, block_num, buf, offset=0):\n    pass  # Transfers data from disk to memory buffer\n\ndef writeblocks(self, block_num, buf, offset=0):\n    pass  # Transfers data from memory buffer to disk\n\ndef ioctl(self, cmd, arg):\n    pass  # Implements disk control commands\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Float Implementation for MicroPython on Raspberry Pi Pico\nDESCRIPTION: Sets up a custom float implementation for MicroPython on Raspberry Pi Pico. This is necessary to fix infinity handling and use custom libm functions for improved accuracy.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# Use our custom pico_float_micropython float implementation.  This is needed for two reasons:\n# - to fix inf handling in pico-sdk's __wrap___aeabi_fadd();\n# - so we can use our own libm functions, to fix inaccuracies in the pico-sdk versions.\npico_set_float_implementation(${MICROPY_TARGET} micropython)\n\n# Define our custom pico_float_micropython component.\npico_add_library(pico_float_micropython)\n\n# pico_float_micropython: add pico-sdk float and our libm source files.\ntarget_sources(pico_float_micropython INTERFACE\n    ${MICROPY_SOURCE_LIB_LIBM}\n    ${MICROPY_SOURCE_LIB_LIBM_SQRT_SW}\n    ${MICROPY_PORT_DIR}/libm_extra.c\n)\n\nif(PICO_RP2040)\n    target_sources(pico_float_micropython INTERFACE\n        ${PICO_SDK_PATH}/src/rp2_common/pico_float/float_aeabi_rp2040.S\n        ${PICO_SDK_PATH}/src/rp2_common/pico_float/float_init_rom_rp2040.c\n        ${PICO_SDK_PATH}/src/rp2_common/pico_float/float_v1_rom_shim_rp2040.S\n    )\nelseif(PICO_RP2350 AND PICO_ARM)\n    target_sources(pico_float_micropython INTERFACE\n        ${PICO_SDK_PATH}/src/rp2_common/pico_float/float_aeabi_dcp.S\n        ${PICO_SDK_PATH}/src/rp2_common/pico_float/float_common_m33.S\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Hard Reset and Enter Bootloader\nDESCRIPTION: Performs a hard reset on the device, waits 500ms, then enters bootloader mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\nmpremote reset sleep 0.5 bootloader\n```\n\n----------------------------------------\n\nTITLE: Connecting to WiPy via Telnet on Linux\nDESCRIPTION: This command connects to the WiPy board via Telnet. Replace `192.168.1.1` with the actual IP address of your WiPy. It assumes the WiPy is configured to be accessible via Telnet.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/repl.rst#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ telnet 192.168.1.1\n```\n\n----------------------------------------\n\nTITLE: Build Board Firmware with LTO\nDESCRIPTION: Command to build firmware for a specific board with Link Time Optimization enabled for reduced binary size.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ make BOARD=boardname LTO=1\n```\n\n----------------------------------------\n\nTITLE: Generating Random Bytes\nDESCRIPTION: Generates n random bytes using hardware random number generator when available.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/os.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nurandom(n)\n```\n\n----------------------------------------\n\nTITLE: Complex Exponential and Logarithmic Operations in MicroPython\nDESCRIPTION: Exponential and logarithmic functions exp(), log(), and log10() for complex numbers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/cmath.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nexp(z)    # Return the exponential of z\nlog(z)    # Return the natural logarithm of z\nlog10(z)  # Return the base-10 logarithm of z\n```\n\n----------------------------------------\n\nTITLE: Managing Compare Value for Timer Channel in MicroPython\nDESCRIPTION: Method for getting or setting the compare value for a timer channel. This method is primarily used when the channel is in output compare mode, though it's an alias that can also be used for capture and pulse_width functions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ntimerchannel.compare([value])\n```\n\n----------------------------------------\n\nTITLE: Loading Certificate Chain\nDESCRIPTION: Loads a private key and corresponding certificate for SSL context.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/ssl.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nSSLContext.load_cert_chain(certfile, keyfile)\n```\n\n----------------------------------------\n\nTITLE: Redirecting MicroPython REPL Output to LCD160CR Display\nDESCRIPTION: Demonstrates how to set up the pyboard to redirect its REPL (Read-Eval-Print Loop) output to the LCD display using a UART connection, allowing the display to function as a terminal.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/lcd160cr_skin.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import pyb\n>>> uart = pyb.UART('XA', 115200)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> pyb.repl_uart(uart)\n```\n\n----------------------------------------\n\nTITLE: Running sdphost Commands for Bootloader Installation on iMX RT1011 Nano Kit\nDESCRIPTION: These commands use the sdphost utility to write the bootloader file to the device and then jump to the bootloader's start address. The commands require sudo privileges and specify the USB device ID for the iMX RT1011 Nano Kit.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/mimxrt/boards/MAKERDIARY_RT1011_NANO_KIT/deploy_makerdiary.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo ./sdphost -u 0x1fc9,0x0145 -- write-file 0x20206400 tinyuf2-makerdiary_rt1011-0.21.0.bin\nsudo ./sdphost -u 0x1fc9,0x0145 -- jump-address 0x20207000\n```\n\n----------------------------------------\n\nTITLE: Programming Quail Firmware Using DFU-UTIL\nDESCRIPTION: Command to flash firmware to Quail device using dfu-util tool. Uses alternate setting 0 to write the firmware.dfu file to the device.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/MIKROE_QUAIL/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndfu-util --alt 0 -D firmware.dfu\n```\n\n----------------------------------------\n\nTITLE: Configuring Mboot Boot Pin in mpconfigboard.h\nDESCRIPTION: Example configuration for a pin to force entry into the bootloader. Defines the pin, pull direction, and active state.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/mboot/README.md#2025-04-21_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n#define MBOOT_BOOTPIN_PIN (pin_A0)\n#define MBOOT_BOOTPIN_PULL (MP_HAL_PIN_PULL_UP)\n#define MBOOT_BOOTPIN_ACTIVE (0)\n```\n\n----------------------------------------\n\nTITLE: Activating Station Interface in MicroPython\nDESCRIPTION: Activates the station interface to prepare for connecting to a WiFi network. This is typically the first step in joining an existing WiFi network.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_basics.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> sta_if.active(True)\n```\n\n----------------------------------------\n\nTITLE: Defining LED pin in hwconfig.py using machine.Pin\nDESCRIPTION: This snippet shows how to define an LED pin as a `Pin` object using the `machine` module. This is done within `hwconfig.py` to abstract the hardware configuration from the main application logic. It uses Pin A3 as an output.\nSOURCE: https://github.com/micropython/micropython/blob/master/examples/hwapi/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"from machine import Pin\n\nLED = Pin(\"A3\", Pin.OUT)\"\n```\n\n----------------------------------------\n\nTITLE: Setting CPU Frequency in MicroPython\nDESCRIPTION: Demonstrates how to change the CPU frequency to 160MHz for increased processing power. This comes at the cost of higher power consumption.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/powerctrl.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> machine.freq(160000000)\n>>> machine.freq()\n160000000\n```\n\n----------------------------------------\n\nTITLE: Mount and Execute Script\nDESCRIPTION: Mounts directory and executes a Python module from mounted location.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\nmpremote mount . exec \"import demo\"\n```\n\n----------------------------------------\n\nTITLE: Unix Port Test Execution Output\nDESCRIPTION: Example output from running tests on the Unix port, showing pass/skip status for various test files.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/writingtests.rst#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ cd ports/unix\n$ make tests\nskip  unix/extra_coverage.py\npass  unix/ffi_callback.py\npass  unix/ffi_float.py\npass  unix/ffi_float2.py\npass  unix/print.py\npass  unix/time.py\npass  unix/time2.py\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Cross-Compiler\nDESCRIPTION: Command to build the MicroPython cross-compiler, which is required before building firmware for a specific board. This should be executed from the root directory of the repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/samd/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make -C mpy-cross\n```\n\n----------------------------------------\n\nTITLE: Building and Installing MicroPython Bootloader\nDESCRIPTION: Shell commands sequence for building and installing the mboot bootloader on the LEGO Hub.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/LEGO_HUB_NO6/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ cd ports/stm32/mboot\n$ make BOARD=LEGO_HUB_NO6\n$ make BOARD=LEGO_HUB_NO6 deploy\n```\n\n----------------------------------------\n\nTITLE: Updating MicroPython Firmware via Filesystem\nDESCRIPTION: Shell and Python commands for updating the MicroPython firmware using the Hub's filesystem.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/LEGO_HUB_NO6/README.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ make BOARD=LEGO_HUB_NO6\n$ gzip build-LEGO_HUB_NO6/firmware.dfu\n$ mpremote cp build-LEGO_HUB_NO6/firmware.dfu.gz :\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import appupdate\n>>> appupdate.update_app(\"firmware.dfu.gz\")\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ mpremote exec --no-follow \"import appupdate; appupdate.update_app('firmware.dfu.gz')\"\n```\n\n----------------------------------------\n\nTITLE: reStructuredText Method Documentation\nDESCRIPTION: Example of documenting a method using reStructuredText syntax with parameter references.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_9\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. method:: poll.unregister(obj)\n\n   Unregister *obj* from polling.\n```\n\n----------------------------------------\n\nTITLE: Using BLE.l2cap_disconnect Method in MicroPython\nDESCRIPTION: Disconnects an active L2CAP channel with the specified connection handle and CID parameters.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nBLE.l2cap_disconnect(conn_handle, cid, /)\n```\n\n----------------------------------------\n\nTITLE: Random Sequence Choice in MicroPython\nDESCRIPTION: Randomly selects and returns one item from a sequence. Available only with MICROPY_PY_RANDOM_EXTRA_FUNCS enabled.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/random.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nchoice(sequence)\n```\n\n----------------------------------------\n\nTITLE: Extending Built-in Modules in MicroPython v1.21.0+\nDESCRIPTION: Demonstrates how to extend a built-in module (e.g., 'time') with additional functionality in MicroPython version 1.21.0 and higher by temporarily clearing sys.path.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/index.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n_path = sys.path\nsys.path = ()\ntry:\n    from time import *\nfinally:\n    sys.path = _path\n    del _path\n\ndef extra_method():\n    pass\n```\n\n----------------------------------------\n\nTITLE: RingIO Buffer Usage in MicroPython\nDESCRIPTION: Examples of creating a RingIO buffer instance, which provides a fixed-size ringbuffer for bytes with a stream interface. Can be initialized with either a size or a pre-allocated buffer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/micropython.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Create with size\nbuffer = RingIO(16)\n\n# Create with pre-allocated buffer\nbuffer = RingIO(bytearray(16))\n```\n\n----------------------------------------\n\nTITLE: Converting Python Object to Binary Format\nDESCRIPTION: Function that converts a Python value (currently only supporting code objects) to binary format and returns a bytes object.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/marshal.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndumps(value, /)\n```\n\n----------------------------------------\n\nTITLE: LED Toggling Loop in MicroPython\nDESCRIPTION: Creates an infinite loop that toggles an LED on and off with a 1-second delay. This script demonstrates the toggle() method and the pyb.delay() function for timing control.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/leds.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nled = pyb.LED(2)\nwhile True:\n    led.toggle()\n    pyb.delay(1000)\n```\n\n----------------------------------------\n\nTITLE: Deploy Firmware Using PYDFU\nDESCRIPTION: Command to flash firmware using the built-in pydfu.py script, used after board is in DFU mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ make BOARD=PYBV11 deploy\n```\n\n----------------------------------------\n\nTITLE: Soft Resetting MicroPython\nDESCRIPTION: This snippet demonstrates how to perform a soft reset of the MicroPython environment via the REPL.  Typing CTRL-D will restart the MicroPython runtime without a full hardware reset. It shows the expected output after the soft reset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/repl.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> \nMPY: soft reboot\nMicroPython v1.4.6-146-g1d8b5e5 on 2015-10-21; WiPy with CC3200\nType \"help()\" for more information.\n>>>\n```\n\n----------------------------------------\n\nTITLE: Enabling LittleFS for nRF Series\nDESCRIPTION: Command to compile the nRF port with LittleFS (version 2) support enabled for use as the device flash filesystem.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/README.md#2025-04-21_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nmake BOARD=PCA10056 MICROPY_VFS_LFS2=1\n```\n\n----------------------------------------\n\nTITLE: Computing CRC-32 Checksum in MicroPython\nDESCRIPTION: The crc32 function computes the 32-bit CRC checksum of data. It takes the data and an optional initial value, defaulting to zero. The algorithm is consistent with ZIP file checksums.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/binascii.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncrc32(data, [value])\n```\n\n----------------------------------------\n\nTITLE: Array Indexed Access Operation\nDESCRIPTION: Implements indexed reading from array using square bracket notation. Supports both integer indices and slices, with negative indexing capability.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/array.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n__getitem__(index)\n```\n\n----------------------------------------\n\nTITLE: Setting Wakeup Timer in RTC\nDESCRIPTION: This snippet sets a wakeup timer for the RTC that re-triggers after a specified timeout in milliseconds. If a callback function is provided, it will be executed at each timeout event, allowing for periodic tasks.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.RTC.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nrtc.wakeup(timeout, callback=None)\n```\n\n----------------------------------------\n\nTITLE: Initializing Flash Object in MicroPython RP2\nDESCRIPTION: Constructor for getting the singleton Flash object that provides access to SPI flash memory.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/rp2.Flash.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nFlash()\n```\n\n----------------------------------------\n\nTITLE: Reading a Timer's Counter Value in MicroPython\nDESCRIPTION: Demonstrates how to read the current value of a timer's counter. The counter continuously increments until it reaches the configured period value, then resets to zero.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/timer.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> tim.counter()\n21504\n```\n\n----------------------------------------\n\nTITLE: Include IDF Project CMake File\nDESCRIPTION: Includes the main IDF project CMake file, which defines the project and sets up the build environment. Relies on the IDF_PATH environment variable to locate the file.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/CMakeLists.txt#2025-04-21_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: C Function Style Example\nDESCRIPTION: Demonstrates the standard code formatting for C functions including braces, spaces, and naming conventions.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n#define TO_ADD (123)\n\n// This function will always recurse indefinitely and is only used to show\n// coding style\nint foo_function(int x, int some_value) {\n    if (x < some_value) {\n        foo(some_value, x);\n    } else {\n        foo(x + TO_ADD, some_value - 1);\n    }\n\n    for (int my_counter = 0; my_counter < x; ++my_counter) {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Drive Strength Constants in MicroPython\nDESCRIPTION: Constants used to select the pin drive strength in MicroPython. Higher numbers correspond to higher drive strength. Ports may define additional drive constants.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.Pin.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nPin.DRIVE_0\nPin.DRIVE_1\nPin.DRIVE_2\n```\n\n----------------------------------------\n\nTITLE: Accessing MicroPython REPL using USB serial\nDESCRIPTION: Demonstrates how to connect to the MicroPython REPL on a Renesas RA board using a USB-Serial conversion cable. It requires a terminal software like picocom on Linux or Tera Term on Windows, and it should be connected using a baud rate of 115200, no parity, and 1 stop bit.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/tutorial/intro.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ picocom /dev/ttyACM0\n```\n\n----------------------------------------\n\nTITLE: SSLContext Socket Wrapping\nDESCRIPTION: Wraps a stream socket with SSL/TLS functionality, configuring server/client mode and handshake behavior.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/ssl.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nSSLContext.wrap_socket(sock, *, server_side=False, do_handshake_on_connect=True, server_hostname=None)\n```\n\n----------------------------------------\n\nTITLE: Performing a soft-reset of the device\nDESCRIPTION: Command to perform a soft reset of the MicroPython device, which clears the Python heap and restarts the interpreter without triggering auto-soft-reset for the next command.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote soft-reset\n```\n\n----------------------------------------\n\nTITLE: Updating Existing ESP-IDF Repository\nDESCRIPTION: Git commands to checkout a specific version and update submodules for an existing ESP-IDF repository\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cd esp-idf\n$ git checkout v5.2.2\n$ git submodule update --init --recursive\n```\n\n----------------------------------------\n\nTITLE: Running MicroPython PowerPC Port on QEMU\nDESCRIPTION: Command to run the compiled MicroPython PowerPC firmware on QEMU, emulating a POWER9 CPU on a powernv machine.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/powerpc/README.md#2025-04-21_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$ ./qemu-system-ppc64 -M powernv -cpu POWER9 -nographic -bios build/firmware.bin\n```\n\n----------------------------------------\n\nTITLE: reStructuredText Location Reference\nDESCRIPTION: Demonstrates how to create and reference arbitrary locations in documentation.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_11\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. _xref_target:\n\nNormal non-indented text.\n\nThis is :ref:`reference <xref_target>`.\n\n(If xref target is followed by section title, can be just\n:ref:`xref_target`).\n```\n\n----------------------------------------\n\nTITLE: Using mpy-tool.py to Inspect .mpy File Contents\nDESCRIPTION: This example demonstrates how to use the mpy-tool.py utility to examine the contents of an .mpy file. The command extracts and displays the detailed structure inside the binary file.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpyfiles.rst#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./tools/mpy-tool.py -xd myfile.mpy\n```\n\n----------------------------------------\n\nTITLE: Passkey Action Constants Definition in Python\nDESCRIPTION: Definition of constants for passkey actions used during BLE pairing process.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n_PASSKEY_ACTION_NONE = const(0)\n_PASSKEY_ACTION_INPUT = const(2)\n_PASSKEY_ACTION_DISPLAY = const(3)\n_PASSKEY_ACTION_NUMERIC_COMPARISON = const(4)\n```\n\n----------------------------------------\n\nTITLE: Retrieving High-Precision Nanosecond Time in MicroPython\nDESCRIPTION: The time_ns() function returns nanoseconds since the Epoch as an integer. It provides higher precision than time() but may allocate memory on the heap due to the large integer value returned.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/time.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntime_ns()\n```\n\n----------------------------------------\n\nTITLE: USB Transfer Submission Method\nDESCRIPTION: Method to submit a USB transfer on a specified endpoint. Takes endpoint number and buffer as parameters. Returns boolean indicating success of transfer queue. Raises OSError if device is not active.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.USBDevice.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nUSBDevice.submit_xfer(self, ep, buffer /)\n```\n\n----------------------------------------\n\nTITLE: Basic LCD Operations in MicroPython\nDESCRIPTION: Demonstrates basic operations with the LCD object, including turning on the backlight and printing text to the screen.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.LCD.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nlcd.light(True)                 # turn the backlight on\nlcd.write('Hello world!\\n')     # print text to the screen\n```\n\n----------------------------------------\n\nTITLE: Converting Binary Data to Python Object\nDESCRIPTION: Function that converts bytes-like data back to its corresponding Python object representation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/marshal.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nloads(data, /)\n```\n\n----------------------------------------\n\nTITLE: Using Watchdog Timer (WDT) in MicroPython on RP2040\nDESCRIPTION: Demonstrates how to use the Watchdog Timer (WDT) on the RP2040 microcontroller using MicroPython. It shows how to enable the WDT with a timeout and feed it.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import WDT\n\n# enable the WDT with a timeout of 5s (1s is the minimum)\nwdt = WDT(timeout=5000)\nwdt.feed()\n```\n\n----------------------------------------\n\nTITLE: Entering Bootloader Mode in MicroPython on SAMD\nDESCRIPTION: This code snippet shows how to programmatically enter bootloader mode on a SAMD module running MicroPython. It's an alternative to manually pressing the reset button twice.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/samd/boards/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmachine.bootloader()\n```\n\n----------------------------------------\n\nTITLE: Creating USB_HID Object in MicroPython\nDESCRIPTION: This constructor initializes a new USB_HID object, allowing for interaction with the USB Human Interface Device interface. It is essential to call this constructor before using methods to send or receive data. There are no special parameters required for instantiation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.USB_HID.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass USB_HID():\n   Create a new USB_HID object.\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Cross-Compiler in Makefile\nDESCRIPTION: Command to build the MicroPython cross-compiler, which is required before building the firmware for a specific board. This command should be executed from the root directory of the repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/mimxrt/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make -C mpy-cross\n```\n\n----------------------------------------\n\nTITLE: Filesystem Status Information\nDESCRIPTION: Functions to get filesystem information including block size, space usage, and inode details.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/os.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nstatvfs(path)\nsync()\n```\n\n----------------------------------------\n\nTITLE: Array Concatenation Operation\nDESCRIPTION: Returns a new array that is the concatenation of two arrays using the + operator.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/array.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n__add__(other)\n```\n\n----------------------------------------\n\nTITLE: Asyncio Support for ESP-NOW\nDESCRIPTION: This snippet showcases the use of aioespnow for integrating asyncio support in ESP-NOW operations, exemplified by an async server that sends periodic pings and echoes received messages. A WLAN interface must be active for send/recv operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nimport network\nimport aioespnow\nimport asyncio\n\n# A WLAN interface must be active to send()/recv()\nnetwork.WLAN(network.WLAN.IF_STA).active(True)\n\ne = aioespnow.AIOESPNow()  # Returns AIOESPNow enhanced with async support\ne.active(True)\npeer = b'\\\\xbb\\\\xbb\\\\xbb\\\\xbb\\\\xbb\\\\xbb'\ne.add_peer(peer)\n\n# Send a periodic ping to a peer\nasync def heartbeat(e, peer, period=30):\n    while True:\n        if not await e.asend(peer, b'ping'):\n            print(\"Heartbeat: peer not responding:\", peer)\n        else:\n            print(\"Heartbeat: ping\", peer)\n        await asyncio.sleep(period)\n\n# Echo any received messages back to the sender\nasync def echo_server(e):\n    async for mac, msg in e:\n        print(\"Echo:\", msg)\n        try:\n            await e.asend(mac, msg)\n        except OSError as err:\n            if len(err.args) > 1 and err.args[1] == 'ESP_ERR_ESPNOW_NOT_FOUND':\n                e.add_peer(mac)\n                await e.asend(mac, msg)\n\nasync def main(e, peer, timeout, period):\n    asyncio.create_task(heartbeat(e, peer, period))\n    asyncio.create_task(echo_server(e))\n    await asyncio.sleep(timeout)\n\nasyncio.run(main(e, peer, 120, 10))\n```\n\n----------------------------------------\n\nTITLE: Initializing Flash Object with Custom Offset in MicroPython\nDESCRIPTION: Creates a Flash object that accesses the flash at a specified offset. The length defaults to the remaining size of the device. The start and len parameters must be multiples of the block size (typically 512 bytes for internal flash).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Flash.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nFlash(*, start=-1, len=-1)\n```\n\n----------------------------------------\n\nTITLE: Cloning ESP-IDF Repository\nDESCRIPTION: Git command to clone the Espressif IDF repository with a specific version, used for setting up the ESP32 development environment\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone -b v5.2.2 --recursive https://github.com/espressif/esp-idf.git\n```\n\n----------------------------------------\n\nTITLE: Compiling MicroPython for nRF Series\nDESCRIPTION: Commands to clone the MicroPython repository, build the cross-compiler, and compile the nRF port. This snippet also shows how to specify a target board.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit clone <URL>.git micropython\ncd micropython\nmake -C mpy-cross\n\nmake submodules\nmake\nmake deploy\n\n# Alternatively, specify the target board:\nmake submodules\nmake BOARD=PCA10040\nmake BOARD=PCA10040 deploy\n```\n\n----------------------------------------\n\nTITLE: Fourth Compiler Pass in MicroPython\nDESCRIPTION: Implementation of the fourth compiler pass that emits the final bytecode or native code that can be executed.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nfor (scope_t *s = comp->scope_head; s != NULL && comp->compile_error == MP_OBJ_NULL; s = s->next) {\n    ...\n\n    // Pass 4: Emit the compiled bytecode or native code.\n    if (comp->compile_error == MP_OBJ_NULL) {\n        compile_scope(comp, s, MP_PASS_EMIT);\n\n```\n\n----------------------------------------\n\nTITLE: Detaching and Reattaching REPL from UART0 in MicroPython for ESP8266\nDESCRIPTION: Demonstrates how to detach the REPL from UART0 and reattach it using the os module on an ESP8266 board.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport os\nos.dupterm(None, 1)\n\n# To reattach:\nimport os, machine\nuart = machine.UART(0, 115200)\nos.dupterm(uart, 1)\n```\n\n----------------------------------------\n\nTITLE: Erasing Flash Memory on ESP32 Board with Specified Port\nDESCRIPTION: This command erases the flash memory of an ESP32 board using esptool.py with a specified serial port. It's useful when auto-detection fails or multiple Espressif devices are connected.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/boards/deploy.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py --port PORTNAME erase_flash\n```\n\n----------------------------------------\n\nTITLE: Connecting ADC Channels in MicroPython\nDESCRIPTION: These methods connect a channel on the ADC peripheral for sampling. They return an ADC object representing the connection. Various parameter combinations are possible for flexible configuration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.ADCBlock.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nADCBlock.connect(channel, *, ...)\nADCBlock.connect(source, *, ...)\nADCBlock.connect(channel, source, *, ...)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Soft Reset in MicroPython REPL\nDESCRIPTION: Shows the state of variables before and after performing a soft reset using Ctrl-D. The code demonstrates how variables created in a session are cleared after reset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/repl.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nMPY: sync filesystems\nMPY: soft reboot\nMicroPython v1.5-51-g6f70283-dirty on 2015-10-30; PYBv1.0 with STM32F405RG\nType \"help()\" for more information.\n>>> dir()\n['__name__', 'pyb']\n>>>\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for MicroPython Unix Port on Debian-based Systems\nDESCRIPTION: This command installs the necessary dependencies for building the MicroPython Unix port on Debian-based Linux distributions.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/unix/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# apt install build-essential git python3 pkg-config libffi-dev\n```\n\n----------------------------------------\n\nTITLE: Flashing STM32 Using STM32 Cube Programmer\nDESCRIPTION: Command for flashing .hex firmware files using STM32 Cube Programmer tool. Uses SWD interface in UR mode with hardware reset.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/NUCLEO_L152RE/deploy.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nSTM32_Programmer.sh -c port=SWD mode=UR dLPM -d firmware.hex -v -hardRst\n```\n\n----------------------------------------\n\nTITLE: Enabling UART0 REPL Duplication in MicroPython\nDESCRIPTION: This code snippet enables REPL duplication on UART0, which is accessible via the expansion board. This allows you to interact with the MicroPython REPL through the UART interface. Place this code in your `boot.py` file to have it run automatically after each reset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/repl.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from machine import UART\n>>> import os\n>>> uart = UART(0, 115200)\n>>> os.dupterm(uart)\n```\n\n----------------------------------------\n\nTITLE: GATTS Error Code Constants Definition in Python\nDESCRIPTION: Definition of GATT server error code constants used for handling read requests and permissions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n_GATTS_NO_ERROR = const(0x00)\n_GATTS_ERROR_READ_NOT_PERMITTED = const(0x02)\n_GATTS_ERROR_WRITE_NOT_PERMITTED = const(0x03)\n_GATTS_ERROR_INSUFFICIENT_AUTHENTICATION = const(0x05)\n_GATTS_ERROR_INSUFFICIENT_AUTHORIZATION = const(0x08)\n_GATTS_ERROR_INSUFFICIENT_ENCRYPTION = const(0x0f)\n```\n\n----------------------------------------\n\nTITLE: Using the Time Module for Delays in MicroPython for ESP8266\nDESCRIPTION: Demonstrates how to use the time module for various delay operations and timing measurements on an ESP8266 board.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\ntime.sleep(1)           # sleep for 1 second\ntime.sleep_ms(500)      # sleep for 500 milliseconds\ntime.sleep_us(10)       # sleep for 10 microseconds\nstart = time.ticks_ms() # get millisecond counter\ndelta = time.ticks_diff(time.ticks_ms(), start) # compute time difference\n```\n\n----------------------------------------\n\nTITLE: Unmounting VFS Filesystems\nDESCRIPTION: Function to unmount a filesystem given either its mount point string or filesystem object. Calls umount() method on the filesystem object during unmounting.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/vfs.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\numount(mount_point)\n```\n\n----------------------------------------\n\nTITLE: Implementing Core MicroPython Module in C\nDESCRIPTION: Complete C implementation of a new MicroPython core module named 'subsystem'. Shows module structure including function definition, globals table setup, and module registration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/library.rst#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include \"py/builtin.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_SUBSYSTEM\n\n// info()\nstatic mp_obj_t py_subsystem_info(void) {\n    return MP_OBJ_NEW_SMALL_INT(42);\n}\nMP_DEFINE_CONST_FUN_OBJ_0(subsystem_info_obj, py_subsystem_info);\n\nstatic const mp_rom_map_elem_t mp_module_subsystem_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_subsystem) },\n    { MP_ROM_QSTR(MP_QSTR_info), MP_ROM_PTR(&subsystem_info_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(mp_module_subsystem_globals, mp_module_subsystem_globals_table);\n\nconst mp_obj_module_t mp_module_subsystem = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_subsystem_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_subsystem, mp_module_subsystem);\n\n#endif\n```\n\n----------------------------------------\n\nTITLE: Directory Update with Soft Reset\nDESCRIPTION: Updates entire utils directory and performs soft reset with REPL.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\nmpremote cp -r utils/ :utils/ + soft-reset repl\n```\n\n----------------------------------------\n\nTITLE: PWM Resolution Limitation Example\nDESCRIPTION: Illustrates PWM duty cycle resolution limitations at high frequencies. Shows how different duty_u16 values may result in the same effective duty cycle due to hardware constraints.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.PWM.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npwm=PWM(Pin(13), freq=300_000, duty_u16=2**16//2)\n\npwm=PWM(Pin(13), freq=300_000, duty_u16=2**16//2 + 255)\n```\n\n----------------------------------------\n\nTITLE: RTC Management\nDESCRIPTION: Commands for getting and setting device RTC time\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote rtc\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote rtc --set\n```\n\n----------------------------------------\n\nTITLE: Entering Bootloader Mode via MicroPython REPL\nDESCRIPTION: Command to enter bootloader mode through the MicroPython REPL interface. This prepares the device for firmware updates via UF2 file transfer.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/boards/WEACTSTUDIO/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmachine.bootloader()\n```\n\n----------------------------------------\n\nTITLE: Converting Firmware to UF2 Format\nDESCRIPTION: Command to convert the firmware from .hex to .uf2 format using uf2conv.py. This step is necessary if starting with a .hex file. The command specifies the chip type, output file name, and input file.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/boards/SEEED_XIAO_NRF52/deploy.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nuf2conv.py -c -f 0xADA52840 -o firmware.uf2 firmware.hex\n```\n\n----------------------------------------\n\nTITLE: Building the MicroPython Cross Compiler\nDESCRIPTION: Standard Unix-style build process for compiling the mpy-cross compiler executable using make command\nSOURCE: https://github.com/micropython/micropython/blob/master/mpy-cross/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ make\n```\n\n----------------------------------------\n\nTITLE: Filesystem Operations using OS Module\nDESCRIPTION: Demonstrates common filesystem operations using the os module, including listing directory contents, creating directories, and removing files.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/filesystem.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport os\nos.listdir()\nos.mkdir('dir')\nos.remove('data.txt')\n```\n\n----------------------------------------\n\nTITLE: Finalizing Hash and Retrieving Digest in MicroPython\nDESCRIPTION: Method to return the hash for all data passed through the hash object as a bytes object. After calling this method, no more data can be fed into the hash.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/hashlib.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nhash.digest()\n```\n\n----------------------------------------\n\nTITLE: ULP Co-processor Method Examples\nDESCRIPTION: Method signatures for controlling the Ultra-Low-Power co-processor, including binary loading and execution control.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp32.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nULP.set_wakeup_period(period_index, period_us)\nULP.load_binary(load_addr, program_binary)\nULP.run(entry_point)\n```\n\n----------------------------------------\n\nTITLE: Reading blocks from flash memory in MicroPython Zephyr module\nDESCRIPTION: Methods for reading data from flash memory blocks. The methods implement the block protocol defined by vfs.AbstractBlockDev, allowing reading from a specific block number into a buffer, with an optional offset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.FlashArea.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nFlashArea.readblocks(block_num, buf)\nFlashArea.readblocks(block_num, buf, offset)\n```\n\n----------------------------------------\n\nTITLE: Configuring BTstack Bluetooth Implementation for MicroPython\nDESCRIPTION: Sets up the BTstack Bluetooth implementation for MicroPython. It adds the necessary Git submodule, source files, libraries, and compiler definitions to enable BTstack-based Bluetooth functionality.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif (MICROPY_BLUETOOTH_BTSTACK)\n    list(APPEND GIT_SUBMODULES lib/btstack)\n\n    list(APPEND MICROPY_SOURCE_PORT mpbtstackport.c)\n\n    include(${MICROPY_DIR}/extmod/btstack/btstack.cmake)\n    target_link_libraries(${MICROPY_TARGET} micropy_extmod_btstack)\n\n    target_compile_definitions(${MICROPY_TARGET} PRIVATE\n        MICROPY_BLUETOOTH_BTSTACK=1\n        MICROPY_BLUETOOTH_BTSTACK_CONFIG_FILE=\\\"btstack_inc/btstack_config.h\\\"\n    )\n\n    # For modbluetooth_btstack.c includes\n    get_target_property(BTSTACK_INCLUDE micropy_extmod_btstack INTERFACE_INCLUDE_DIRECTORIES)\n    list(APPEND MICROPY_INC_CORE ${BTSTACK_INCLUDE})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython for Renesas RA Board\nDESCRIPTION: Commands to clean and build MicroPython for a specific Renesas RA board. The example uses the EK_RA6M2 board, but can be replaced with other supported board names.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/renesas-ra/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ make BOARD=EK_RA6M2 clean\n$ make BOARD=EK_RA6M2\n```\n\n----------------------------------------\n\nTITLE: Emitting Bytecode for Unary Operations in MicroPython\nDESCRIPTION: This function emits bytecode for unary operations in MicroPython. It writes a single byte of bytecode that represents the unary operation, using a base opcode (MP_BC_UNARY_OP_MULTI) combined with the specific operation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nvoid mp_emit_bc_unary_op(emit_t *emit, mp_unary_op_t op) {\n    emit_write_bytecode_byte(emit, 0, MP_BC_UNARY_OP_MULTI + op);\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding Binary Data to Base64 in MicroPython\nDESCRIPTION: The b2a_base64 function encodes binary data in base64 format according to RFC 3548. It returns the encoded data as a bytes object, optionally followed by a newline character.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/binascii.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nb2a_base64(data, *, newline=True)\n```\n\n----------------------------------------\n\nTITLE: Erasing ESP32 Flash Memory with Specific Port using esptool.py\nDESCRIPTION: Command to erase the flash memory of an ESP32 board, specifying the serial port explicitly. This is useful when multiple devices are connected or automatic port detection fails.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/boards/deploy_nativeusb.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py --port PORTNAME erase_flash\n```\n\n----------------------------------------\n\nTITLE: Initializing WIZNET5K Ethernet Module in MicroPython\nDESCRIPTION: This snippet demonstrates how to create and use a WIZNET5K object to control a WIZnet5x00 Ethernet adapter. It shows the initialization of the network interface and how to retrieve the IP configuration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.WIZNET5K.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport network\nnic = network.WIZNET5K(pyb.SPI(1), pyb.Pin.board.X5, pyb.Pin.board.X4)\nprint(nic.ipconfig(\"addr4\"))\n\n# now use socket as usual\n...\n```\n\n----------------------------------------\n\nTITLE: Deploying MicroPython Firmware on Teensy 4.1 using Command-line Teensy Loader\nDESCRIPTION: This command uses the Teensy Loader CLI to deploy MicroPython firmware on a Teensy 4.1 board. It specifies the microcontroller unit, enables verbose output, and writes the firmware file to the board.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/mimxrt/boards/deploy_teensy.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nteensy_loader_cli --mcu=imxrt1062 -v -w TEENSY41-<date_version_tag>.hex\n```\n\n----------------------------------------\n\nTITLE: Compiling MicroPython Cross-Compiler with Docker in Bash\nDESCRIPTION: This command compiles the MicroPython cross-compiler (mpy-cross) using Docker. It should be run from the root directory of the MicroPython repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ docker run --rm -v $HOME:$HOME -u $UID -w $PWD larsks/esp-open-sdk make -C mpy-cross\n```\n\n----------------------------------------\n\nTITLE: Restoring LEGO Hub Firmware using Shell Command\nDESCRIPTION: Command to restore the original LEGO Hub firmware from a backup file.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/LEGO_HUB_NO6/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ make BOARD=LEGO_HUB_NO6 restore-hub-firmware\n```\n\n----------------------------------------\n\nTITLE: Calculating Structure Size in Python\nDESCRIPTION: Returns the number of bytes needed to store a given format string.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/struct.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncalcsize(fmt)\n```\n\n----------------------------------------\n\nTITLE: Managing Pulse Width for Timer Channel in MicroPython\nDESCRIPTION: Method for getting or setting the pulse width value for a timer channel. This method is primarily used when the channel is in PWM mode, though it's an alias that can also be used for capture and compare functions. Different alignment modes affect how 100% duty cycle is calculated.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ntimerchannel.pulse_width([value])\n```\n\n----------------------------------------\n\nTITLE: Constructing ADCBlock Object in MicroPython\nDESCRIPTION: This snippet shows the constructor for the ADCBlock class. It takes an id parameter and an optional bits parameter to set the resolution of the conversion process.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.ADCBlock.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nADCBlock(id, *, bits)\n```\n\n----------------------------------------\n\nTITLE: Edit Remote File\nDESCRIPTION: Opens device file in local editor specified by $EDITOR environment variable.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_38\n\nLANGUAGE: bash\nCODE:\n```\nmpremote edit utils/driver.py\n```\n\n----------------------------------------\n\nTITLE: Setting APA102 LED Colors in MicroPython\nDESCRIPTION: This snippet demonstrates how to set colors for individual LEDs in the strip. It shows examples of setting white, red, green, and blue colors with different brightness levels.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/apa102.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> strip[0] = (255, 255, 255, 31) # set to white, full brightness\n>>> strip[1] = (255, 0, 0, 31) # set to red, full brightness\n>>> strip[2] = (0, 255, 0, 15) # set to green, half brightness\n>>> strip[3] = (0, 0, 255, 7)  # set to blue, quarter brightness\n```\n\n----------------------------------------\n\nTITLE: ROMFS Management\nDESCRIPTION: Commands for managing ROMFS partitions on the device\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote romfs <sub-command>\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Firmware for SEEED nRF52840\nDESCRIPTION: Command to build MicroPython firmware for the SEEED XIAO NRF52 board. This step creates a firmware.uf2 file in the specified build directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/boards/SEEED_XIAO_NRF52/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmake BOARD=SEEED_XIAO_NRF52 -j5\n```\n\n----------------------------------------\n\nTITLE: Initializing Submodules for Board Build in Makefile\nDESCRIPTION: Command to initialize the correct set of submodules required for building a specific board's firmware. This example uses the SEEED_ARCH_MIX board.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/mimxrt/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make BOARD=SEEED_ARCH_MIX submodules\n```\n\n----------------------------------------\n\nTITLE: Running MicroPython Tests\nDESCRIPTION: This command runs the complete test suite for the MicroPython Unix port.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/unix/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ make test\n```\n\n----------------------------------------\n\nTITLE: ESP32-S3 SD Card Pin Configuration\nDESCRIPTION: Example of configuring an SD card with custom pins on ESP32-S3 using SD/MMC mode with 4-bit width.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.SDCard.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsd = SDCard(slot=0, width=4, sck=8, cmd=9, data=(10, 11, 12, 13))\n```\n\n----------------------------------------\n\nTITLE: Math Module Constants\nDESCRIPTION: Mathematical constants provided by the math module\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/math.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Constants\nmath.e    # base of natural logarithm\nmath.pi   # ratio of circle's circumference to diameter\n```\n\n----------------------------------------\n\nTITLE: Configuring OS Debug Output for ESP32 in MicroPython\nDESCRIPTION: Function to change the level of OS serial debug log messages on ESP32. It allows setting specific log levels and enables more detailed control over debug output.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nosdebug(uart_no, [level])\n```\n\n----------------------------------------\n\nTITLE: Creating SHA1 Hasher Object in MicroPython\nDESCRIPTION: Constructor for creating an SHA1 hasher object. Optionally accepts initial data to feed into the hash.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/hashlib.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nhashlib.sha1([data])\n```\n\n----------------------------------------\n\nTITLE: Connecting to WiPy via Serial on Linux\nDESCRIPTION: This command connects to the WiPy board via a serial connection using the `screen` utility. `/dev/ttyUSB0` represents the serial port of the USB-to-serial adapter. The `115200` parameter sets the baud rate.  The exact port name may need adjusting.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/repl.rst#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ screen /dev/ttyUSB0 115200\n```\n\n----------------------------------------\n\nTITLE: Invoking MicroPython Cross Compiler\nDESCRIPTION: Command for compiling a Python script into .mpy bytecode file using mpy-cross executable\nSOURCE: https://github.com/micropython/micropython/blob/master/mpy-cross/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ ./mpy-cross foo.py\n```\n\n----------------------------------------\n\nTITLE: Setting Up Board Configuration for MicroPython on Raspberry Pi Pico\nDESCRIPTION: Configures the board-specific settings for the MicroPython build. It sets the board type, checks for board variants, and includes the appropriate configuration files.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Set the board if it's not already set.\nif(NOT MICROPY_BOARD)\n    set(MICROPY_BOARD RPI_PICO)\nendif()\n\n# Set the board directory and check that it exists.\nif(NOT MICROPY_BOARD_DIR)\n    set(MICROPY_BOARD_DIR ${MICROPY_PORT_DIR}/boards/${MICROPY_BOARD})\nendif()\nget_filename_component(MICROPY_BOARD_DIR ${MICROPY_BOARD_DIR} ABSOLUTE)\nif(NOT EXISTS ${MICROPY_BOARD_DIR}/mpconfigboard.cmake)\n    message(FATAL_ERROR \"Invalid MICROPY_BOARD specified: ${MICROPY_BOARD}\")\nendif()\n\n# If a board variant is specified, check that it exists.\nif(MICROPY_BOARD_VARIANT)\n    if(NOT EXISTS ${MICROPY_BOARD_DIR}/mpconfigvariant_${MICROPY_BOARD_VARIANT}.cmake)\n        message(FATAL_ERROR \"Invalid MICROPY_BOARD_VARIANT specified: ${MICROPY_BOARD_VARIANT}\")\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Firmware for WeAct Studio RP2040 Board\nDESCRIPTION: This bash command demonstrates how to build MicroPython firmware for the WeAct Studio RP2040 Board with 8 MiB flash. It uses the make command with specific parameters to configure the build.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/boards/WEACTSTUDIO/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n> cd ports/rp2\n> make BOARD=WEACTSTUDIO BOARD_VARIANT=FLASH_8M submodules all  # Build the 8 MiB variant\n```\n\n----------------------------------------\n\nTITLE: Adding a Lexical Token to the MicroPython Lexer\nDESCRIPTION: Extension of the mp_token_kind_t enum in py/lexer.h to include the KW_ADD1 token required for the new 'add1' language feature.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\ntypedef enum _mp_token_kind_t {\n    ...\n    MP_TOKEN_KW_OR,\n    MP_TOKEN_KW_PASS,\n    MP_TOKEN_KW_RAISE,\n    MP_TOKEN_KW_RETURN,\n    MP_TOKEN_KW_TRY,\n    MP_TOKEN_KW_WHILE,\n    MP_TOKEN_KW_WITH,\n    MP_TOKEN_KW_YIELD,\n    MP_TOKEN_KW_ADD1,\n    ...\n} mp_token_kind_t;\n```\n\n----------------------------------------\n\nTITLE: Packing Data Into Buffer in Python\nDESCRIPTION: Packs values into an existing buffer at a specified offset according to a format string. Supports negative offsets for counting from buffer end.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/struct.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npack_into(fmt, buffer, offset, v1, v2, ...)\n```\n\n----------------------------------------\n\nTITLE: Generating SAMD51 Pin Assignment Tables with MicroPython\nDESCRIPTION: A Python script that runs on a SAMD51 board with MicroPython to query and display pin assignment information. The script uses the samd module's pininfo function to extract peripheral capabilities for each pin and formats them into readable tables showing IRQ, ADC, UART, PWM and timer assignments.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/pinout.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom samd import pininfo\nfrom machine import Pin\nimport os\n\ndef print_item(e, txt):\n    print(txt, end=\": \")\n    if e == 255:\n        print(\" - \", end=\"\")\n    else:\n        print(\"%d/%d\" % (e >> 4, e & 0x0f), end=\"\")\n\ndef print_pininfo(pin_id, name, info):\n\n    print(\"%3d\" % pin_id, end=\" \")\n    print(\"%4s %12s\" % (info[0], name), end=\"\")\n    print(\" IRQ:%2s\" % (info[1] if info[1] != 255 else \"-\"), end=\"\")\n    print(\" ADC0:%2s\" % (info[2] if info[2] != 255 else \"-\"), end=\"\")\n    if len(info) == 7:\n        print_item(info[3], \" Serial1\")\n        print_item(info[4], \" Serial2\")\n        print_item(info[5], \" PWM1\" if (info[5] >> 4) < 3 else \"   TC\")\n        print_item(info[6], \" PWM2\")\n    else:\n        print(\" ADC1:%2s\" % (info[3] if info[3] != 255 else \"-\"), end=\"\")\n        print_item(info[4], \" Serial1\")\n        print_item(info[5], \" Serial2\")\n        print_item(info[6], \" TC\")\n        print_item(info[7], \" PWM1\")\n        print_item(info[8], \" PWM2\")\n    print()\n\ndef tblkey(i):\n    name = i[1]\n    if name != \"\":\n        if len(name) < 3:\n            return \" \" + name\n        else:\n            return name\n    else:\n        return \"zzzzzzz%03d\" % i[0]\n\ndef pinnum(p):\n    return (ord(p[1]) - ord(\"A\")) * 32 + int(p[2:])\n\ndef table(num = 127, sort=True):\n    pintbl = []\n    pinlist = []\n    for name in Pin.board.__dict__.keys():\n        p = Pin(name)\n        pi = pininfo(p)\n        pintbl.append((pinnum(pi[0]), name, pi))\n        pinlist.append(p)\n    for pc in Pin.cpu.__dict__.keys():\n        p = Pin(pc)\n        pi = pininfo(p)\n        if not p in pinlist:\n           pintbl.append((pinnum(pi[0]), \"\", pi))\n    if sort:\n        pintbl.sort(key=tblkey)\n    for item in pintbl:\n        print_pininfo(item[0], item[1], item[2])\n\ntable()\n```\n\n----------------------------------------\n\nTITLE: Initializing AES Cipher in MicroPython\nDESCRIPTION: This snippet shows the initialization of an AES cipher object. It takes a key, mode, and optional initialization vector as parameters. The cipher can be used for either encryption or decryption, but not both on the same object.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/cryptolib.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n__init__(key, mode, [IV])\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython for RP2 Pico W\nDESCRIPTION: Commands to build the MicroPython firmware specifically for the Raspberry Pi Pico W board using Make.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make BOARD=RPI_PICO_W submodules\n$ make BOARD=RPI_PICO_W clean\n$ make BOARD=RPI_PICO_W\n```\n\n----------------------------------------\n\nTITLE: Concatenate SDKConfig Files\nDESCRIPTION: Concatenates all SDK configuration files specified in SDKCONFIG_DEFAULTS into a combined file (sdkconfig.combined). This combined file is then used as the default SDK configuration for the IDF build system.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/CMakeLists.txt#2025-04-21_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nfile(WRITE ${CMAKE_BINARY_DIR}/sdkconfig.combined.in \"\")\nforeach(SDKCONFIG_DEFAULT ${SDKCONFIG_DEFAULTS})\n    file(READ ${SDKCONFIG_DEFAULT} CONTENTS)\n    file(APPEND ${CMAKE_BINARY_DIR}/sdkconfig.combined.in \"${CONTENTS}\")\nendforeach()\nconfigure_file(${CMAKE_BINARY_DIR}/sdkconfig.combined.in ${CMAKE_BINARY_DIR}/sdkconfig.combined COPYONLY)\nset(SDKCONFIG_DEFAULTS ${CMAKE_BINARY_DIR}/sdkconfig.combined)\n```\n\n----------------------------------------\n\nTITLE: Configuring TinyUSB Support for MicroPython\nDESCRIPTION: Adds TinyUSB support to the MicroPython build by including the necessary header files. TinyUSB provides USB device functionality for the Raspberry Pi Pico.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\n# tinyusb helper\ntarget_include_directories(${MICROPY_TARGET} PRIVATE\n    ${MICROPY_DIR}/shared/tinyusb/\n)\n```\n\n----------------------------------------\n\nTITLE: Executing sdphost Commands for UF2 Bootloader Installation on Seeed Arch Mix Board\nDESCRIPTION: These commands use the sdphost tool to write the UF2 bootloader binary to the board's memory and initiate its execution. The first command writes the bootloader file to address 0x1000, while the second command jumps to address 0x2000 to start the bootloader.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/mimxrt/boards/SEEED_ARCH_MIX/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo ./sdphost -u 0x1fc9,0x0130 -- write-file 0x1000 tinyuf2-imxrt1050_evkb-0.21.0.bin\nsudo ./sdphost -u 0x1fc9,0x0130 -- jump-address 0x2000\n```\n\n----------------------------------------\n\nTITLE: Fast SPI Data Transfer - LCD160CR Method\nDESCRIPTION: Prepares display for RGB pixel data transfer via SPI bus. Returns an SPI object for writing 16-bit RGB values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.fast_spi(flush=True)\n```\n\n----------------------------------------\n\nTITLE: Measuring Sensor Data in MicroPython with Zephyr\nDESCRIPTION: Method to fetch a measurement sample from the sensor device and store it in the internal buffer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.zsensor.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nSensor.measure()\n```\n\n----------------------------------------\n\nTITLE: Getting Random Bits in MicroPython\nDESCRIPTION: Returns an integer with n random bits, where n must be between 0 and 32 inclusive.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/random.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ngetrandbits(n)\n```\n\n----------------------------------------\n\nTITLE: Returning a Value with Inline Assembly in MicroPython\nDESCRIPTION: A simple function that uses the @micropython.asm_thumb decorator to define an inline assembly function that returns the integer value 42. The return value is placed in register r0.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/assembler.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@micropython.asm_thumb\ndef fun():\n    movw(r0, 42)\n```\n\n----------------------------------------\n\nTITLE: Loading CA Verification Locations\nDESCRIPTION: Loads CA certificate chain for peer validation using file path or certificate data.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/ssl.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nSSLContext.load_verify_locations(cafile=None, cadata=None)\n```\n\n----------------------------------------\n\nTITLE: Writing Colors to APA102 LEDs in MicroPython\nDESCRIPTION: This code shows how to output the set colors to the LED strip using the write() method.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/apa102.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> strip.write()\n```\n\n----------------------------------------\n\nTITLE: MPRemote Configuration\nDESCRIPTION: Example configuration file showing custom command shortcuts\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ncommands = {\n    \"c33\": \"connect id:334D335C3138\", # Connect to a specific device by ID.\n    \"bl\": \"bootloader\", # Shorter alias for bootloader.\n    \"double x=4\": \"eval x*2\",  # x is an argument, with default 4\n    \"wl_scan\": [\"exec\", \"\"\"\nimport network\nwl = network.WLAN()\nwl.active(1)\nfor ap in wl.scan():\n    print(ap)\n\"\"\",], # Print out nearby WiFi networks.\n    \"wl_ipconfig\": [\n\"exec\",\n\"import network; sta_if = network.WLAN(network.WLAN.IF_STA); print(sta_if.ipconfig('addr4'))\",\n\"\"\",], # Print ip address of station interface.\n    \"test\": [\"mount\", \".\", \"exec\", \"import test\"], # Mount current directory and run test.py.\n    \"demo\": [\"run\", \"path/to/demo.py\"], # Execute demo.py on the device.\n}\n```\n\n----------------------------------------\n\nTITLE: Freezing a Single Python Module (Python)\nDESCRIPTION: Manifest code to include a single Python file as a module. This shows how to use the module() function with optional base_path parameter.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/manifest.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmodule(\"foo.py\")\n\n# With base_path\nmodule(\"foo.py\", base_path=\"src/drivers\")\n```\n\n----------------------------------------\n\nTITLE: Running MicroPython Tests in QEMU (Makefile)\nDESCRIPTION: Command to automatically run the MicroPython test suite against the QEMU firmware.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/qemu/README.md#2025-04-21_snippet_4\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make test\n```\n\n----------------------------------------\n\nTITLE: Declaring Constants in MicroPython\nDESCRIPTION: Example showing how to declare constants using the const() function from micropython module. Constants declared this way are accessible as global variables unless they begin with an underscore.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/micropython.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom micropython import const\n\nCONST_X = const(123)\nCONST_Y = const(2 * CONST_X + 1)\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 Data in MicroPython\nDESCRIPTION: The a2b_base64 function decodes base64-encoded data, ignoring invalid characters. It conforms to RFC 2045 section 6.8 and returns a bytes object.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/binascii.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\na2b_base64(data)\n```\n\n----------------------------------------\n\nTITLE: Creating UUID Objects in MicroPython BLE Module\nDESCRIPTION: Instantiates a UUID object using either a 16-bit integer value or a 128-bit UUID string. Used for BLE service and characteristic identification.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nUUID(value, /)\n```\n\n----------------------------------------\n\nTITLE: Converting Hexadecimal to Binary in MicroPython\nDESCRIPTION: The unhexlify function converts hexadecimal data to its binary representation. It takes hexadecimal data as input and returns a bytes string.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/binascii.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nunhexlify(data)\n```\n\n----------------------------------------\n\nTITLE: Creating an Oscillating Mouse Movement Pattern\nDESCRIPTION: This function creates a sinusoidal left-right mouse movement pattern. It takes parameters for the number of movements and delay between movements.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/usb_mouse.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import math\n>>> def osc(n, d):\n...   for i in range(n):\n...     hid.send((0, int(20 * math.sin(i / 10)), 0, 0))\n...     pyb.delay(d)\n...\n>>> osc(100, 50)\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython for WeAct F411 Blackpill v3.1 (25MHz) with 16MB Flash\nDESCRIPTION: This command builds MicroPython for a WeAct F411 Blackpill v3.1 board with a 25MHz crystal (default version) and a 16MB SPI flash chip. It specifies the board type and SPI flash size.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/WEACT_F411_BLACKPILL/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake -C ports/stm32 BOARD=WEACT_F411_BLACKPILL SPI_FLASH_SIZE_MB=16\n```\n\n----------------------------------------\n\nTITLE: In-Memory Data Structure Example\nDESCRIPTION: Demonstrates using uctypes to define and access in-memory data structures with pointers and floating-point values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/uctypes.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nCOORD = {\n    \"x\": 0 | uctypes.FLOAT32,\n    \"y\": 4 | uctypes.FLOAT32,\n}\n\nSTRUCT1 = {\n    \"data1\": 0 | uctypes.UINT8,\n    \"data2\": 4 | uctypes.UINT32,\n    \"ptr\": (8 | uctypes.PTR, COORD),\n}\n\nstruct1 = uctypes.struct(addr, STRUCT1, uctypes.NATIVE)\nprint(\"x:\", struct1.ptr[0].x)\n```\n\n----------------------------------------\n\nTITLE: FTP Connection to WiPy - Python\nDESCRIPTION: This snippet illustrates accessing the WiPy's internal file system through FTP. It includes the command to connect to the FTP server and guidelines for setting up the FTP client.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n$ ftp 192.168.1.1\n```\n\n----------------------------------------\n\nTITLE: Implementing Light Sleep with ESPNow in MicroPython\nDESCRIPTION: Shows how to use light sleep with ESPNow in a continuous operation. Unlike deep sleep, this allows resuming operation after sleeping without rebooting, but requires reconfiguring WiFi after each sleep cycle.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport network, machine, espnow\n\nsta, ap = wifi_reset()            # Reset wifi to AP off, STA on and disconnected\nsta.config(channel=6)\npeer = b'0\\xaa\\xaa\\xaa\\xaa\\xaa'   # MAC address of peer\ne = espnow.ESPNow()\ne.active(True)\ne.add_peer(peer)                  # Register peer on STA_IF\n\nwhile True:\n  print('Sending ping...')\n  if not e.send(peer, b'ping'):\n    print('Ping failed!')\n  sta.active(False)               # Disable the wifi before sleep\n  print('Going to sleep...')\n  machine.lightsleep(10000)       # Sleep for 10 seconds\n  sta.active(True)\n  sta.config(channel=6)           # Wifi loses config after lightsleep()\n```\n\n----------------------------------------\n\nTITLE: Setting Up Build Environment for MicroPython Unix Port\nDESCRIPTION: These commands set up the build environment for the MicroPython Unix port, including changing to the correct directory, building the cross-compiler, and updating submodules.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/unix/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cd ports/unix\n$ make -C ../../mpy-cross\n$ make submodules\n```\n\n----------------------------------------\n\nTITLE: Copying SSL/TLS Test Certificates to MicroPython Device\nDESCRIPTION: This command copies the necessary .der certificate files to a MicroPython device and sets the current time to ensure certificate validity for on-device testing.\nSOURCE: https://github.com/micropython/micropython/blob/master/tests/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote rtc --set cp multi_net/*.der net_inet/*.der :\n```\n\n----------------------------------------\n\nTITLE: Defining MicroPython Source Files for Raspberry Pi Pico\nDESCRIPTION: Specifies the source files required for building MicroPython on Raspberry Pi Pico. It includes core MicroPython files, port-specific implementations, and additional libraries.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(MICROPY_SOURCE_LIB\n    ${MICROPY_DIR}/lib/littlefs/lfs1.c\n    ${MICROPY_DIR}/lib/littlefs/lfs1_util.c\n    ${MICROPY_DIR}/lib/littlefs/lfs2.c\n    ${MICROPY_DIR}/lib/littlefs/lfs2_util.c\n    ${MICROPY_DIR}/lib/oofatfs/ff.c\n    ${MICROPY_DIR}/lib/oofatfs/ffunicode.c\n    ${MICROPY_DIR}/shared/netutils/dhcpserver.c\n    ${MICROPY_DIR}/shared/netutils/netutils.c\n    ${MICROPY_DIR}/shared/netutils/trace.c\n    ${MICROPY_DIR}/shared/readline/readline.c\n    ${MICROPY_DIR}/shared/runtime/gchelper_native.c\n    ${MICROPY_DIR}/shared/runtime/interrupt_char.c\n    ${MICROPY_DIR}/shared/runtime/mpirq.c\n    ${MICROPY_DIR}/shared/runtime/pyexec.c\n    ${MICROPY_DIR}/shared/runtime/stdout_helpers.c\n    ${MICROPY_DIR}/shared/runtime/softtimer.c\n    ${MICROPY_DIR}/shared/runtime/sys_stdio_mphal.c\n    ${MICROPY_DIR}/shared/timeutils/timeutils.c\n    ${MICROPY_DIR}/shared/tinyusb/mp_usbd.c\n    ${MICROPY_DIR}/shared/tinyusb/mp_usbd_cdc.c\n    ${MICROPY_DIR}/shared/tinyusb/mp_usbd_descriptor.c\n    ${MICROPY_DIR}/shared/tinyusb/mp_usbd_runtime.c\n)\n\nset(MICROPY_SOURCE_PORT\n    clocks_extra.c\n    datetime_patch.c\n    fatfs_port.c\n    help.c\n    machine_bitstream.c\n    machine_i2c.c\n    machine_pin.c\n    machine_rtc.c\n    machine_spi.c\n    machine_timer.c\n    main.c\n    modrp2.c\n    mphalport.c\n    mpnetworkport.c\n    mpthreadport.c\n    mutex_extra.c\n    pendsv.c\n    rp2_flash.c\n    rp2_pio.c\n    rp2_psram.c\n    rp2_dma.c\n    uart.c\n    usbd.c\n    msc_disk.c\n    mbedtls/mbedtls_port.c\n    ${CMAKE_BINARY_DIR}/pins_${MICROPY_BOARD}.c\n)\n```\n\n----------------------------------------\n\nTITLE: Include Board Configuration\nDESCRIPTION: Includes the board configuration file (mpconfigboard.cmake) and the board variant configuration file (mpconfigvariant.cmake or mpconfigvariant_${MICROPY_BOARD_VARIANT}.cmake). These files are expected to set SDKCONFIG_DEFAULTS and IDF_TARGET.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/CMakeLists.txt#2025-04-21_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(${MICROPY_BOARD_DIR}/mpconfigboard.cmake)\nif(NOT MICROPY_BOARD_VARIANT)\n    include(${MICROPY_BOARD_DIR}/mpconfigvariant.cmake OPTIONAL)\nelse()\n    include(${MICROPY_BOARD_DIR}/mpconfigvariant_${MICROPY_BOARD_VARIANT}.cmake)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Deploying MicroPython Firmware via BOSSA on Arduino Nano 33 BLE\nDESCRIPTION: This command uses the BOSSA flash programmer to deploy MicroPython firmware to the Arduino Nano 33 BLE board. It erases the flash, writes the firmware at a specific offset, and resets the board. The command assumes the board is in bootloader mode and connected as ttyACM0.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/boards/ARDUINO_NANO_33_BLE_SENSE/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbossac -e -w --offset=0x16000 --port=ttyACM0 -i -d -U -R build-arduino_nano_33_ble_sense-s140/firmware.bin\n```\n\n----------------------------------------\n\nTITLE: Checking Touch Status - LCD160CR Method\nDESCRIPTION: Method to check if the display is currently being touched. Returns a boolean value.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.is_touched()\n```\n\n----------------------------------------\n\nTITLE: Receiving Messages with ESP-NOW Protocol in Python\nDESCRIPTION: Example code showing how to receive messages using ESP-NOW protocol. Demonstrates continuous message reception until a specific end message is received.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport network\nimport espnow\n\n# A WLAN interface must be active to send()/recv()\nsta = network.WLAN(network.WLAN.IF_STA)\nsta.active(True)\nsta.disconnect()   # Because ESP8266 auto-connects to last Access Point\n\ne = espnow.ESPNow()\ne.active(True)\n\nwhile True:\n    host, msg = e.recv()\n    if msg:             # msg == None if timeout in recv()\n        print(host, msg)\n        if msg == b'end':\n            break\n```\n\n----------------------------------------\n\nTITLE: WM8960 Secondary Mode Example\nDESCRIPTION: Example showing basic initialization of WM8960 codec in secondary mode, which is the default configuration where sample rate and bit depth are controlled by the MCU.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/wm8960.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Micro_python WM8960 Codec driver\n```\n\n----------------------------------------\n\nTITLE: Accepting Arguments in Inline Assembly Functions\nDESCRIPTION: An example showing how to accept and use arguments in an inline assembly function. This function takes two parameters (r0 and r1) and adds them together, returning the result in r0.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/assembler.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@micropython.asm_thumb\ndef asm_add(r0, r1):\n    add(r0, r0, r1)\n```\n\n----------------------------------------\n\nTITLE: Getting CPU Frequency using machine Module in MicroPython for i.MXRT\nDESCRIPTION: Code snippet demonstrating how to import the machine module and query the current CPU frequency on an i.MXRT board.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport machine\n\nmachine.freq()          # get the current frequency of the CPU\n```\n\n----------------------------------------\n\nTITLE: Implementing OpenAMP Communication in MicroPython\nDESCRIPTION: Example demonstrating how to set up inter-processor communication using OpenAMP. Shows creation of an RPMsg endpoint, setting up a receive callback, initializing a remote processor, and sending messages.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/openamp.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport openamp\n\ndef ept_recv_callback(src, data):\n    print(\"Received message on endpoint\", data)\n\n# Create a new RPMsg endpoint to communicate with the remote core.\nept = openamp.Endpoint(\"vuart-channel\", callback=ept_recv_callback)\n\n# Create a RemoteProc object, load its firmware and start it.\nrproc = openamp.RemoteProc(\"virtual_uart.elf\") # Or entry point address (ex 0x081E0000)\nrproc.start()\n\nwhile True:\n    if ept.is_ready():\n        ept.send(\"data\")\n```\n\n----------------------------------------\n\nTITLE: Running MicroPython in Node.js using Promises\nDESCRIPTION: Shows how to import and use MicroPython in a Node.js environment using Promise-based syntax without async/await.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/webassembly/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport(\"micropython.mjs\").then((mp_mjs) => {\n    mp_mjs.loadMicroPython().then((mp) => {\n        mp.runPython(\"print('hello world')\");\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Command Delay\nDESCRIPTION: Command to add delay between command execution\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote sleep 0.5\n```\n\n----------------------------------------\n\nTITLE: Demonstrating String and Bytes Instances in Python\nDESCRIPTION: This snippet shows the creation of a string instance and a bytes instance in Python. It illustrates the difference between the two types of objects.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ns = 'the quick brown fox'   # A string instance\nb = b'the quick brown fox'  # A bytes instance\n```\n\n----------------------------------------\n\nTITLE: Running MicroPython Native Module Tests in QEMU (Makefile)\nDESCRIPTION: Command to run tests for selected native modules in QEMU (currently supported only for the VIRT_RV32 board).\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/qemu/README.md#2025-04-21_snippet_5\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make test_natmod\n```\n\n----------------------------------------\n\nTITLE: Getting MicroPython Compiler Information\nDESCRIPTION: Returns a string identifying the compiler used to build MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/platform.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npython_compiler()\n```\n\n----------------------------------------\n\nTITLE: BLE Event Code Constants Definition in Python\nDESCRIPTION: Definition of BLE event code constants used for handling different types of Bluetooth events like connections, disconnections, GATT operations, and scanning.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom micropython import const\n_IRQ_CENTRAL_CONNECT = const(1)\n_IRQ_CENTRAL_DISCONNECT = const(2)\n_IRQ_GATTS_WRITE = const(3)\n_IRQ_GATTS_READ_REQUEST = const(4)\n_IRQ_SCAN_RESULT = const(5)\n_IRQ_SCAN_DONE = const(6)\n_IRQ_PERIPHERAL_CONNECT = const(7)\n_IRQ_PERIPHERAL_DISCONNECT = const(8)\n_IRQ_GATTC_SERVICE_RESULT = const(9)\n_IRQ_GATTC_SERVICE_DONE = const(10)\n_IRQ_GATTC_CHARACTERISTIC_RESULT = const(11)\n_IRQ_GATTC_CHARACTERISTIC_DONE = const(12)\n_IRQ_GATTC_DESCRIPTOR_RESULT = const(13)\n_IRQ_GATTC_DESCRIPTOR_DONE = const(14)\n_IRQ_GATTC_READ_RESULT = const(15)\n_IRQ_GATTC_READ_DONE = const(16)\n_IRQ_GATTC_WRITE_DONE = const(17)\n_IRQ_GATTC_NOTIFY = const(18)\n_IRQ_GATTC_INDICATE = const(19)\n_IRQ_GATTS_INDICATE_DONE = const(20)\n_IRQ_MTU_EXCHANGED = const(21)\n_IRQ_L2CAP_ACCEPT = const(22)\n_IRQ_L2CAP_CONNECT = const(23)\n_IRQ_L2CAP_DISCONNECT = const(24)\n_IRQ_L2CAP_RECV = const(25)\n_IRQ_L2CAP_SEND_READY = const(26)\n_IRQ_CONNECTION_UPDATE = const(27)\n_IRQ_ENCRYPTION_UPDATE = const(28)\n_IRQ_GET_SECRET = const(29)\n_IRQ_SET_SECRET = const(30)\n```\n\n----------------------------------------\n\nTITLE: USB Remote Wakeup - Python\nDESCRIPTION: Method to wake up the USB host when in suspend mode, if remote wakeup feature is enabled.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.USBDevice.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nUSBDevice.remote_wakeup(self)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Drawing on LCD160CR Display\nDESCRIPTION: Demonstrates how to create an LCD160CR object, set pen colors, erase the screen, and draw a line. This shows the basic graphics capabilities of the display.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/lcd160cr_skin.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import lcd160cr\n>>> lcd = lcd160cr.LCD160CR('X')\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> lcd.set_pen(lcd.rgb(255, 0, 0), lcd.rgb(64, 64, 128))\n>>> lcd.erase()\n>>> lcd.line(10, 10, 50, 80)\n```\n\n----------------------------------------\n\nTITLE: Defining Pin Assignment Table for Minisam M4 (SAMD51)\nDESCRIPTION: This table provides a comprehensive pin assignment for the Minisam M4 board, including GPIO pins, pin names, IRQ numbers, ADC channels, and various peripheral mappings. It also specifies the default device configurations for UART, I2C, SPI, and DAC.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/pinout.rst#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n=== ==== ============ ==== ==== ==== ====== ====== ===== ===== =====\nPin GPIO Pin name     IRQ  ADC  ADC  Serial Serial  TC    PWM   PWM\n=== ==== ============ ==== ==== ==== ====== ====== ===== ===== =====\n 16 PA16           D0   0    -    -    1/0    3/1   2/0   1/0   0/4\n 17 PA17           D1   1    -    -    1/1    3/0   2/1   1/1   0/5\n 19 PA19           D3   3    -    -    1/3    3/3   3/1   1/3   0/7\n 20 PA20           D4   4    -    -    5/2    3/2   7/0   1/4   0/0\n 21 PA21           D5   5    -    -    5/3    3/3   7/1   1/5   0/1\n  2 PA02        A0_D9   2    0    -     -      -     -     -     -\n 40 PB08       A1_D10   8    2    0     -     4/0   4/0    -     -\n 41 PB09       A2_D11   9    3    1     -     4/1   4/1    -     -\n  4 PA04       A3_D12   4    4    -     -     0/0   0/0    -     -\n  5 PA05       A4_D13   5    5    -     -     0/1   0/1    -     -\n  6 PA06           A5   6    6    -     -     0/2   1/0    -     -\n  7 PA07        A6_D2   7    7    -     -     0/3   1/1    -     -\n  3 PA03         AREF   3   10    -     -      -     -     -     -\n  0 PA00       BUTTON   0    -    -     -     1/0   2/0    -     -\n 34 PB02  DOTSTAR_CLK   2   14    -     -     5/0   6/0   2/2    -\n 35 PB03 DOTSTAR_DATA   9   15    -     -     5/1   6/1    -     -\n 15 PA15          LED  15    -    -    2/3    4/3   3/1   2/1   1/3\n 16 PA16           RX   0    -    -    1/0    3/1   2/0   1/0   0/4\n 17 PA17           TX   1    -    -    1/1    3/0   2/1   1/1   0/5\n 55 PB23         MOSI   7    -    -    1/3    5/3   7/1    -     -\n 54 PB22         MISO  22    -    -    1/2    5/2   7/0    -     -\n 43 PB11      QSPI_CS  12    -    -     -     4/3   5/1   0/5   1/1\n  8 PA08      QSPI_D0   -    8    2    0/0    2/1   0/0   0/0   1/4\n  9 PA09      QSPI_D1   9    9    3    0/1    2/0   0/1   0/1   1/5\n 10 PA10      QSPI_D2  10   10    -    0/2    2/2   1/0   0/2   1/6\n 11 PA11      QSPI_D3  11   11    -    0/3    2/3   1/1   0/3   1/7\n 42 PB10     QSPI_SCK  10    -    -     -     4/2   5/0   0/4   1/0\n  1 PA01          SCK   1    -    -     -     1/1   2/1    -     -\n 13 PA13          SCL  13    -    -    2/1    4/0   2/1   0/7   1/3\n 12 PA12          SDA  12    -    -    2/0    4/1   2/0   0/6   1/2\n 30 PA30        SWCLK  14    -    -    7/2    1/2   6/0   2/0    -\n 31 PA31        SWDIO  15    -    -    7/3    1/3   6/1   2/1    -\n 24 PA24       USB_DM   8    -    -    3/2    5/2   5/0   2/2    -\n 25 PA25       USB_DP   9    -    -    3/3    5/3   5/1    -     -\n 14 PA14            -  14    -    -    2/2    4/2   3/0   2/0   1/2\n 18 PA18            -   2    -    -    1/2    3/2   3/0   1/2   0/6\n 22 PA22            -   6    -    -    3/0    5/1   4/0   1/6   0/2\n 23 PA23            -   7    -    -    3/1    5/0   4/1   1/7   0/3\n 27 PA27            -  11    -    -     -      -     -     -     -\n=== ==== ============ ==== ==== ==== ====== ====== ===== ===== =====\n```\n\n----------------------------------------\n\nTITLE: Checking out LittleFS versions with Git\nDESCRIPTION: These git commands check out specific versions of the LittleFS repository, allowing for the generation of lfs1 and lfs2 versions.  The git reset command is used to discard any local changes after the files have been copied.\nSOURCE: https://github.com/micropython/micropython/blob/master/lib/littlefs/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout v1.7.2\n```\n\nLANGUAGE: shell\nCODE:\n```\ngit reset --hard HEAD\n```\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout v2.3.0\n```\n\nLANGUAGE: shell\nCODE:\n```\ngit reset --hard HEAD\n```\n\n----------------------------------------\n\nTITLE: Setting MicroPython Target Compile Definitions\nDESCRIPTION: Defines various compilation parameters for MicroPython including memory configurations, stack sizes, and build information.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_19\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_compile_definitions(${MICROPY_TARGET} PRIVATE\n    ${MICROPY_DEF_BOARD}\n    FFCONF_H=\\\"${MICROPY_OOFATFS_DIR}/ffconf.h\\\"\n    LFS1_NO_MALLOC LFS1_NO_DEBUG LFS1_NO_WARN LFS1_NO_ERROR LFS1_NO_ASSERT\n    LFS2_NO_MALLOC LFS2_NO_DEBUG LFS2_NO_WARN LFS2_NO_ERROR LFS2_NO_ASSERT\n    PICO_FLOAT_PROPAGATE_NANS=1\n    PICO_STACK_SIZE=0x2000\n    PICO_CORE1_STACK_SIZE=0\n    PICO_MAX_SHARED_IRQ_HANDLERS=8 # we need more than the default\n    PICO_PROGRAM_NAME=\"MicroPython\"\n    PICO_NO_PROGRAM_VERSION_STRING=1 # do it ourselves in main.c\n    MICROPY_BUILD_TYPE=\"${CMAKE_C_COMPILER_ID} ${CMAKE_C_COMPILER_VERSION} ${CMAKE_BUILD_TYPE}\"\n    PICO_NO_BI_STDIO_UART=1 # we call it UART REPL\n)\n```\n\n----------------------------------------\n\nTITLE: Building Release Image for CC3200 - Bash\nDESCRIPTION: This command compiles the application image for the CC3200 board in release mode. It must be performed after the bootloader is built and is necessary for deploying the MicroPython firmware onto the board.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/cc3200/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake BTARGET=application BTYPE=release BOARD=LAUNCHXL\n```\n\n----------------------------------------\n\nTITLE: Checking WiFi Interface Status in MicroPython\nDESCRIPTION: Demonstrates how to check if the WiFi interfaces are active. This can be used to verify the current state of the WiFi connections.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_basics.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> sta_if.active()\nFalse\n>>> ap_if.active()\nTrue\n```\n\n----------------------------------------\n\nTITLE: Flashing Firmware with dfu-util for Arduino Giga\nDESCRIPTION: This command uses dfu-util to write the firmware to the Arduino Giga board. It specifies the device ID, firmware file, and necessary options for the DFU process.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/ARDUINO_GIGA/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndfu-util -w -a 0 -d 2341:035b -D build-ARDUINO_GIGA/firmware.dfu\n```\n\n----------------------------------------\n\nTITLE: Serializing Python Object to JSON String in MicroPython\nDESCRIPTION: The 'dumps' function returns a JSON string representation of a Python object. It accepts optional separators to control the formatting of the output JSON.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/json.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndumps(obj, separators=None)\n```\n\n----------------------------------------\n\nTITLE: Setting File System Size for nRF Series\nDESCRIPTION: Command to compile the nRF port with a custom file system size. This example sets the size to 256K and enables LittleFS version 2.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/README.md#2025-04-21_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nmake BOARD=PCA10056 MICROPY_VFS_LFS2=1 FS_SIZE=256K\n```\n\n----------------------------------------\n\nTITLE: Comparing Performance with tee\nDESCRIPTION: Command showing how to run benchmarks and save output to a file using the tee utility for later comparison.\nSOURCE: https://github.com/micropython/micropython/blob/master/tests/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./run-perfbench.py -p 168 100 | tee pyb-run1.txt\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Optimizations in CMake\nDESCRIPTION: Applies -O2 optimization flag to performance-critical MicroPython source files including map.c, mpz.c, and vm.c.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_16\n\nLANGUAGE: cmake\nCODE:\n```\nset_source_files_properties(\n    ${MICROPY_PY_DIR}/map.c\n    ${MICROPY_PY_DIR}/mpz.c\n    ${MICROPY_PY_DIR}/vm.c\n    PROPERTIES\n    COMPILE_OPTIONS \"-O2\"\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing RGBW NeoPixel Strip\nDESCRIPTION: Creates a NeoPixel object for an RGBW LED strip with 4 bytes per pixel\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/neopixel.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport machine, neopixel\nnp = neopixel.NeoPixel(machine.Pin(4), 8, bpp=4)\n```\n\n----------------------------------------\n\nTITLE: Receiving Data on CAN Bus in Python\nDESCRIPTION: This method receives data from the CAN bus, with parameters such as the FIFO to receive on, and an optional list as a return structure. If a list is used, it must have enough allocated memory. The method returns a tuple with message details.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.CAN.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n\n.. method:: CAN.recv(fifo, list=None, *, timeout=5000)\n\n   Receive data on the bus:\n\n     - *fifo* is an integer, which is the FIFO to receive on\n     - *list* is an optional list object to be used as the return value\n     - *timeout* is the timeout in milliseconds to wait for the receive.\n\n   Return value: A tuple containing five values.\n\n     - The id of the message.\n     - A boolean that indicates if the message ID is standard or extended.\n     - A boolean that indicates if the message is an RTR message.\n     - The FMI (Filter Match Index) value.\n     - An array containing the data.\n\n   If *list* is ``None`` then a new tuple will be allocated, as well as a new\n   bytes object to contain the data (as the fifth element in the tuple).\n\n   If *list* is not ``None`` then it should be a list object with a least five\n   elements.  The fifth element should be a memoryview object which is created\n   from either a bytearray or an array of type 'B' or 'b', and this array must\n   have enough room for at least 8 bytes.  The list object will then be\n   populated with the first four return values above, and the memoryview object\n   will be resized inplace to the size of the data and filled in with that data.\n   The same list and memoryview objects can be reused in subsequent calls to\n   this method, providing a way of receiving data without using the heap.\n   For example::\n\n        buf = bytearray(8)\n        lst = [0, 0, 0, 0, memoryview(buf)]\n        # No heap memory is allocated in the following call\n        can.recv(0, lst)\n\n```\n\n----------------------------------------\n\nTITLE: Importing and Using the ESP Module in MicroPython for ESP8266\nDESCRIPTION: Shows how to import the esp module and use it to control vendor O/S debugging messages on an ESP8266 board.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport esp\n\nesp.osdebug(None)       # turn off vendor O/S debugging messages\nesp.osdebug(0)          # redirect vendor O/S debugging messages to UART(0)\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Installation Path with mip in MicroPython\nDESCRIPTION: Example showing how to install a package to a custom directory and add it to the Python path to make it importable.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> mip.install(\"pkgname\", target=\"third-party\")\n>>> sys.path.append(\"third-party\")\n```\n\n----------------------------------------\n\nTITLE: Pre-allocating Buffers for ISR Use in MicroPython\nDESCRIPTION: Demonstrates a technique to avoid memory allocation in ISRs by using pre-allocated buffers. This function creates a bytearray during function definition rather than during execution.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/isr_rules.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef set_volume(t, buf=bytearray(3)):\n    buf[0] = 0xa5\n    buf[1] = t >> 4\n    buf[2] = 0x5a\n    return buf\n```\n\n----------------------------------------\n\nTITLE: Writing Flash Blocks in MicroPython RP2\nDESCRIPTION: Methods for writing blocks to flash memory, implementing the block device interface. Supports writing with optional offset parameter.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/rp2.Flash.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nFlash.writeblocks(block_num, buf)\nFlash.writeblocks(block_num, buf, offset)\n```\n\n----------------------------------------\n\nTITLE: Advanced HTML integration with custom output and async Python\nDESCRIPTION: Shows how to capture MicroPython output and display it in an HTML element, and demonstrates the use of top-level await and the js module in Python code.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/webassembly/README.md#2025-04-21_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html>\n  <head>\n    <script src=\"build-standard/micropython.mjs\" type=\"module\"></script>\n  </head>\n  <body>\n    <pre id=\"micropython-stdout\"></pre>\n    <script type=\"module\">\n      const stdoutWriter = (line) => {\n        document.getElementById(\"micropython-stdout\").innerText += line + \"\\n\";\n      };\n      const mp = await loadMicroPython({stdout:stdoutWriter});\n      await mp.runPythonAsync(`\n        import js\n        url = \"https://api.github.com/users/micropython\"\n        print(f\"fetching {url}...\")\n        res = await js.fetch(url)\n        json = await res.json()\n        for i in dir(json):\n          print(f\"{i}: {json[i]}\")\n      `);\n    </script>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Viewing pyboard.py Help Command Output\nDESCRIPTION: Shows the command-line help output from the pyboard.py tool, displaying all available options and parameters for using the tool to interact with MicroPython devices.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/pyboard.py.rst#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nusage: pyboard [-h] [-d DEVICE] [-b BAUDRATE] [-u USER] [-p PASSWORD]\n                   [-c COMMAND] [-w WAIT] [--follow | --no-follow] [-f]\n                   [files [files ...]]\n\nRun scripts on the pyboard.\n\npositional arguments:\n  files                 input files\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -d DEVICE, --device DEVICE\n                        the serial device or the IP address of the pyboard\n  -b BAUDRATE, --baudrate BAUDRATE\n                        the baud rate of the serial device\n  -u USER, --user USER  the telnet login username\n  -p PASSWORD, --password PASSWORD\n                        the telnet login password\n  -c COMMAND, --command COMMAND\n                        program passed in as string\n  -w WAIT, --wait WAIT  seconds to wait for USB connected board to become\n                        available\n  --follow              follow the output after running the scripts\n                        [default if no scripts given]\n  -f, --filesystem      perform a filesystem action: cp local :device | cp\n                        :device local | cat path | ls [path] | rm path | mkdir\n                        path | rmdir path\n```\n\n----------------------------------------\n\nTITLE: WiPy Boot Mode Selection - Python\nDESCRIPTION: This snippet provides an example of managing the boot sequence on the WiPy. It explains how to enter safe boot mode by manipulating the GP28 pin during reset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n>>> import wipy\n>>> wipy.heartbeat(False)\n```\n\n----------------------------------------\n\nTITLE: Installing mpremote with pip\nDESCRIPTION: Command to install the mpremote tool using pip with the --user flag to install it for the current user only.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install --user mpremote\n```\n\n----------------------------------------\n\nTITLE: Mathematical Constants in MicroPython cmath\nDESCRIPTION: Fundamental mathematical constants e and pi.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/cmath.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ne   # base of the natural logarithm\npi  # ratio of circle's circumference to diameter\n```\n\n----------------------------------------\n\nTITLE: Using Custom C Module Class in MicroPython\nDESCRIPTION: This snippet shows how to use a custom class (Timer) from the 'cexample' C module in MicroPython. It creates an instance of the Timer class, waits for 1 second using sleep_ms, and then prints the elapsed time.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/cmodules.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom cexample import Timer\nfrom time import sleep_ms\n\nwatch = Timer()\nsleep_ms(1000)\nprint(watch.time())\n# should display approximately 1000\n```\n\n----------------------------------------\n\nTITLE: USB Constants Definition - Python\nDESCRIPTION: Constants for USB HID configurations providing predefined tuples for mouse and keyboard implementations with subclass, protocol, packet length, polling interval, and report descriptor settings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npyb.hid_mouse\npyb.hid_keyboard\n```\n\n----------------------------------------\n\nTITLE: Playing a Sine Wave on AMP Audio Skin in MicroPython\nDESCRIPTION: Code to generate a sine wave buffer and play it through the DAC on the AMP audio skin. The example creates a 100-sample sine wave and outputs it at 400Hz in circular mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/amp_skin.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport math\nfrom pyb import DAC\n\n# create a buffer containing a sine-wave\nbuf = bytearray(100)\nfor i in range(len(buf)):\n    buf[i] = 128 + int(127 * math.sin(2 * math.pi * i / len(buf)))\n\n# output the sine-wave at 400Hz\ndac = DAC(1)\ndac.write_timed(buf, 400 * len(buf), mode=DAC.CIRCULAR)\n```\n\n----------------------------------------\n\nTITLE: Building and Deploying mboot Bootloader for PYBv1.0\nDESCRIPTION: Command to build and deploy the mboot bootloader to a PYBv1.0 board in factory DFU mode. The USE_MBOOT=1 flag enables mboot configuration in the build process.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/mboot/README.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ make BOARD=PYBV10 USE_MBOOT=1 clean all deploy\n```\n\n----------------------------------------\n\nTITLE: Creating MD5 Hasher Object in MicroPython\nDESCRIPTION: Constructor for creating an MD5 hasher object. Optionally accepts initial data to feed into the hash.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/hashlib.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nhashlib.md5([data])\n```\n\n----------------------------------------\n\nTITLE: Entering MicroPython Bootloader via REPL\nDESCRIPTION: Command to enter the mboot DFU bootloader mode through the MicroPython REPL interface on Pyboard D-series devices.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/PYBD_SF2/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmachine.bootloader()\n```\n\n----------------------------------------\n\nTITLE: Handling Directory Exists Error with errno in MicroPython\nDESCRIPTION: Example showing how to handle the EEXIST error when creating a directory that already exists using the errno module. Demonstrates proper error handling with OSError and errno constant comparison.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/errno.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    os.mkdir(\"my_dir\")\nexcept OSError as exc:\n    if exc.errno == errno.EEXIST:\n        print(\"Directory already exists\")\n```\n\n----------------------------------------\n\nTITLE: Building Standalone MicroPython Unix Port\nDESCRIPTION: These commands build a standalone version of MicroPython with statically linked libffi, useful for embedded or cross-compiled applications.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/unix/README.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ export MICROPY_STANDALONE=1\n$ make submodules\n$ make deplibs\n$ make\n```\n\n----------------------------------------\n\nTITLE: Defining Pin Assignment Table for Adafruit NeoKey Trinkey (SAMD21)\nDESCRIPTION: This table provides a pin assignment for the Adafruit NeoKey Trinkey board, including GPIO pins, pin names, IRQ numbers, ADC channels, and various peripheral mappings. It notes that the board does not provide access to UART, I2C, SPI or DAC.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/pinout.rst#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n=== ==== ============ ==== ==== ====== ====== ====== ======\nPin GPIO Pin name     IRQ  ADC  Serial Serial TCC/TC TCC/TC\n=== ==== ============ ==== ==== ====== ====== ====== ======\n 15 PA15     NEOPIXEL  15    -    2/3    4/3    3/1    0/5\n 30 PA30        SWCLK  10    -     -     1/2    1/0     -\n 31 PA31        SWDIO  11    -     -     1/3    1/1     -\n 18 PA18       SWITCH   2    -    1/2    3/2    3/0    0/2\n  7 PA07        TOUCH   7    7     -     0/3    1/1     -\n 24 PA24       USB_DM  12    -    3/2    5/2    5/0    1/2\n 25 PA25       USB_DP  13    -    3/3    5/3    5/1    1/3\n=== ==== ============ ==== ==== ====== ====== ====== ======\n```\n\n----------------------------------------\n\nTITLE: Configuring TinyUSB Compiler Options\nDESCRIPTION: Sets compiler options for TinyUSB source files to disable specific warnings.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_18\n\nLANGUAGE: cmake\nCODE:\n```\nset_source_files_properties(\n    ${PICO_TINYUSB_PATH}/src/portable/raspberrypi/rp2040/dcd_rp2040.c\n    ${PICO_TINYUSB_PATH}/src/portable/raspberrypi/rp2040/rp2040_usb.c\n    PROPERTIES\n    COMPILE_OPTIONS \"-Wno-error=array-bounds;-Wno-error=unused-but-set-variable\"\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Submodules for ESP8266 Port in Bash\nDESCRIPTION: This command initializes the required submodules for the ESP8266 port of MicroPython. It should be run from the root directory of the MicroPython repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ make -C ports/esp8266 submodules\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic Operations with ARM FPU Registers\nDESCRIPTION: These instructions perform basic arithmetic operations between FPU registers. They support addition, subtraction, negation, multiplication, division, and square root calculation. Registers can be identical in operations, allowing for operations like squaring a value.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_float.rst#2025-04-21_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\nvadd(Sd, Sn, Sm) \"Sd = Sn + Sm\"\nvsub(Sd, Sn, Sm) \"Sd = Sn - Sm\"\nvneg(Sd, Sm) \"Sd = -Sm\"\nvmul(Sd, Sn, Sm) \"Sd = Sn * Sm\"\nvdiv(Sd, Sn, Sm) \"Sd = Sn / Sm\"\nvsqrt(Sd, Sm) \"Sd = sqrt(Sm)\"\n```\n\n----------------------------------------\n\nTITLE: Emitter Selection for MicroPython Compiler\nDESCRIPTION: Code that selects the appropriate emitter (bytecode or native) based on the emit options for each scope.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n// Choose the emitter type.\nswitch (s->emit_options) {\n    case MP_EMIT_OPT_NATIVE_PYTHON:\n    case MP_EMIT_OPT_VIPER:\n        if (emit_native == NULL) {\n            emit_native = NATIVE_EMITTER(new)(&comp->compile_error, &comp->next_label, max_num_labels);\n        }\n        comp->emit_method_table = NATIVE_EMITTER_TABLE;\n        comp->emit = emit_native;\n        break;\n\n    default:\n        comp->emit = emit_bc;\n        comp->emit_method_table = &emit_bc_method_table;\n        break;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Pin Toggle Function\nDESCRIPTION: Example of defining a function in the REPL that toggles the state of a pin. Demonstrates line continuation and auto-indent in the REPL environment.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/repl.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> def toggle(p):\n...    p.value(not p.value())\n...    \n...    \n...    \n>>>\n```\n\n----------------------------------------\n\nTITLE: Checking UART Buffer Status in MicroPython\nDESCRIPTION: Method to check if there are any characters waiting to be read from the UART buffer\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.UART.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nuart.any()          # returns the number of characters waiting\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Fibonacci Function in ARM Assembly\nDESCRIPTION: Demonstrates a recursive implementation of the Fibonacci sequence using inline assembly. The code showcases proper register management, including saving and restoring the link register (lr) on the stack before recursive calls.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_hints_tips.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n@micropython.asm_thumb\ndef fib(r0):\n    b(START)\n    label(DOFIB)\n    push({r1, r2, lr})\n    cmp(r0, 1)\n    ble(FIBDONE)\n    sub(r0, 1)\n    mov(r2, r0) # r2 = n -1\n    bl(DOFIB)\n    mov(r1, r0) # r1 = fib(n -1)\n    sub(r0, r2, 1)\n    bl(DOFIB)   # r0 = fib(n -2)\n    add(r0, r0, r1)\n    label(FIBDONE)\n    pop({r1, r2, lr})\n    bx(lr)\n    label(START)\n    bl(DOFIB)\n\nfor n in range(10):\n    print(fib(n))\n```\n\n----------------------------------------\n\nTITLE: FAT Filesystem Class Constructor\nDESCRIPTION: Creates a FAT filesystem object that can be mounted using mount(). Takes a block device parameter for storage.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/vfs.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nVfsFat(block_dev)\n```\n\n----------------------------------------\n\nTITLE: Creating a Sensor Instance in MicroPython with Zephyr\nDESCRIPTION: Example of instantiating a Sensor object using the device name from Zephyr's devicetree.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.zsensor.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nSensor(device_name)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Interacting with I2C Interface in MicroPython\nDESCRIPTION: This snippet initializes an I2C interface using the MicroPython machine module, scans for device addresses, and reads memory from a slave device. It requires the machine module. The I2C constructor takes bus number as parameter and scan method returns detected addresses. Memory is read using readfrom_mem method, requiring device address, memory address, and data length.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/quickref.rst#2025-04-21_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import I2C\n\ni2c = I2C(0)\n\ni2c.scan()         # returns list of slave addresses\ni2c.readfrom_mem(0x50, 0x10, 2, addrsize=16)  # read 2 bytes from slave 0x50, slave memory 0x10\n```\n\n----------------------------------------\n\nTITLE: Compiling ESP8266 Firmware Locally in Bash\nDESCRIPTION: This command compiles the ESP8266 firmware locally. It should be run from the ports/esp8266 directory of the MicroPython repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ make -j BOARD=ESP8266_GENERIC\n```\n\n----------------------------------------\n\nTITLE: Conditional Module Registration\nDESCRIPTION: Example of conditionally registering a MicroPython module based on a compile-time flag.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/cmodules.rst#2025-04-21_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n#if MODULE_CEXAMPLE_ENABLED\nMP_REGISTER_MODULE(MP_QSTR_cexample, example_user_cmodule);\n#endif\n```\n\n----------------------------------------\n\nTITLE: Device Storage Query\nDESCRIPTION: Command to query device filesystem statistics similar to Unix df command\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote df\n```\n\n----------------------------------------\n\nTITLE: Using BLE.gap_pair Method in MicroPython\nDESCRIPTION: Initiates pairing with a remote BLE device. Requires io, mitm, le_secure, and bond configuration options to be set before calling.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nBLE.gap_pair(conn_handle, /)\n```\n\n----------------------------------------\n\nTITLE: Checking for Pending Messages in FIFO in Python\nDESCRIPTION: This method returns whether any messages are pending in the specified FIFO. It is used to determine if a message is waiting on the FIFO, returning True if there is one, otherwise False.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.CAN.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n\n.. method:: CAN.any(fifo)\n\n   Return ``True`` if any message waiting on the FIFO, else ``False``.\n\n```\n\n----------------------------------------\n\nTITLE: Configuring USB VCP Flow Control - Python\nDESCRIPTION: Method to configure USB VCP port flow control settings using RTS and CTS flags for read/write behavior control.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.USB_VCP.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nUSB_VCP.init(*, flow=-1)\n```\n\n----------------------------------------\n\nTITLE: Setting Up External Interrupts on pyboard in MicroPython\nDESCRIPTION: Configuring external interrupts to trigger callbacks on pin state changes. This example sets up an interrupt on the rising edge of pin Y1 with no pull resistor and defines a callback function to print a message when triggered.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/quickref.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import Pin, ExtInt\n\ncallback = lambda e: print(\"intr\")\next = ExtInt(Pin('Y1'), ExtInt.IRQ_RISING, Pin.PULL_NONE, callback)\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Unix Port with Debug Symbols\nDESCRIPTION: These commands demonstrate how to build a debuggable version of the MicroPython Unix port with different optimization levels.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/unix/README.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ make [other arguments] DEBUG=1\n$ make [other arguments] STRIP=\n$ make [other arguments] COPT=-O0 DEBUG=1\n```\n\n----------------------------------------\n\nTITLE: Retrieving QSTR Information in MicroPython\nDESCRIPTION: This snippet shows how to retrieve QSTR (interned string) information in MicroPython. This is useful for optimizing string storage in flash memory.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmicropython.qstr_info(1)\n```\n\n----------------------------------------\n\nTITLE: Flashing MicroPython Firmware on NRF52840_MDK_USB_DONGLE using nRFUtil\nDESCRIPTION: Example command for flashing MicroPython firmware on an NRF52840_MDK_USB_DONGLE board using nRFUtil. The NRFUTIL_PORT parameter specifies the serial port to which the device is connected.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/README.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nmake BOARD=NRF52840_MDK_USB_DONGLE NRFUTIL_PORT=/dev/ttyACM0 deploy\n```\n\n----------------------------------------\n\nTITLE: SPI Ethernet Configuration Example\nDESCRIPTION: Sample configuration for WIZNet W5500 SPI ethernet chip on ESP32-S3\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport machine, network\nfrom machine import Pin, SPI\n\nspi = SPI(1, sck=Pin(12), mosi=Pin(13), miso=Pin(14))\nlan = network.LAN(spi=spi, phy_type=network.PHY_W5500, phy_addr=0,\n                  cs=Pin(10), int=Pin(11))\n```\n\n----------------------------------------\n\nTITLE: Enter Bootloader\nDESCRIPTION: Command to make device enter bootloader mode\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote bootloader\n```\n\n----------------------------------------\n\nTITLE: Initializing TimerWiPy in MicroPython\nDESCRIPTION: Examples of initializing a TimerWiPy object with different modes and widths. This demonstrates how to create periodic and one-shot timers with 16-bit or 32-bit widths.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.TimerWiPy.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntim.init(Timer.PERIODIC)             # periodic 16-bit timer\ntim.init(Timer.ONE_SHOT, width=32)   # one shot 32-bit timer\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Minimal Port for Linux\nDESCRIPTION: Commands to build and run the minimal MicroPython port for the host Linux machine. This will create an executable and provide a basic working REPL.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/minimal/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make\n```\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make run\n```\n\n----------------------------------------\n\nTITLE: Flow Control Window Size Increment\nDESCRIPTION: Describes a communication flow control mechanism with an initial window size of 128 bytes, allowing up to 256 bytes to be written before waiting for additional flow control characters\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/repl.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nb\"\\x01\"\n```\n\n----------------------------------------\n\nTITLE: Testing mp_mbedtls_errors.c with a C Main Function\nDESCRIPTION: This C code is a simple main function to test the functionality of the mp_mbedtls_errors.c file, ensuring that the error strings are processed correctly.\nSOURCE: https://github.com/micropython/micropython/blob/master/lib/mbedtls_errors/README.md#2025-04-21_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n#include <stdio.h>\\n#include \"mp_mbedtls_errors.h\"\\n\\nint main() {\\n    printf(\"Test Mbedtls error string: %s\\n\", mbedtls_strerror(MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE));\\n    return 0;\\n}\n```\n\n----------------------------------------\n\nTITLE: Entering Bootloader Mode in MicroPython\nDESCRIPTION: This code snippet demonstrates how to enter bootloader mode programmatically using the MicroPython REPL. It uses the machine.bootloader() function to initiate the bootloader for firmware updates.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/boards/SIL_RP2040_SHIM/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmachine.bootloader()\n```\n\n----------------------------------------\n\nTITLE: Defining a Grammar Rule without Compile Function in C\nDESCRIPTION: Implementation of a grammar rule for the 'add1' statement without a compile function using the DEF_RULE_NC macro. Rules without compile functions must be handled by other rules that may have this rule as a node.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nDEF_RULE_NC(add1_stmt, and(2), tok(KW_ADD1), rule(testlist))\n```\n\n----------------------------------------\n\nTITLE: Updating Hash with Data in MicroPython\nDESCRIPTION: Method to feed more binary data into the hash object.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/hashlib.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nhash.update(data)\n```\n\n----------------------------------------\n\nTITLE: Popping the Smallest Item from a Heap in Python\nDESCRIPTION: This function pops and returns the smallest item from the heap. It raises an IndexError if the heap is empty. The returned item is guaranteed to be the smallest in the heap.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/heapq.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nheappop(heap)\n```\n\n----------------------------------------\n\nTITLE: Reading Flash Blocks in MicroPython RP2\nDESCRIPTION: Methods for reading blocks from flash memory, implementing the block device interface. Supports reading with optional offset parameter.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/rp2.Flash.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nFlash.readblocks(block_num, buf)\nFlash.readblocks(block_num, buf, offset)\n```\n\n----------------------------------------\n\nTITLE: Constructing Timer Objects in MicroPython\nDESCRIPTION: This snippet demonstrates the constructor of the Timer class, allowing the creation of a timer object by specifying its ID and optional initial parameters through the init method.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n.. class:: Timer(id, ...)\n\n   Construct a new timer object of the given id.  If additional\n   arguments are given, then the timer is initialised by ``init(...)``.\n   ``id`` can be 1 to 14.\n```\n\n----------------------------------------\n\nTITLE: Using Timers with Machine Module\nDESCRIPTION: This snippet shows how to use software timers with the machine.Timer class on SAMD21/SAMD51 boards. The period is in milliseconds.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/quickref.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Timer\n\ntim0 = Timer()\ntim0.init(period=5000, mode=Timer.ONE_SHOT, callback=lambda t:print(0))\n\ntim1 = Timer()\ntim1.init(period=2000, mode=Timer.PERIODIC, callback=lambda t:print(1))\n```\n\n----------------------------------------\n\nTITLE: Defining Pin Assignment Table for Adafruit QT PY (SAMD21)\nDESCRIPTION: This table provides a comprehensive pin assignment for the Adafruit QT PY board, including GPIO pins, pin names, IRQ numbers, ADC channels, and various peripheral mappings. It also specifies the default device configurations for UART, I2C, SPI, and DAC.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/pinout.rst#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n=== ==== ============ ==== ==== ====== ====== ====== ======\nPin GPIO Pin name     IRQ  ADC  Serial Serial TCC/TC TCC/TC\n=== ==== ============ ==== ==== ====== ====== ====== ======\n  2 PA02           A0   2    0     -      -      -      -\n  3 PA03           A1   3    1     -      -      -      -\n  4 PA04           A2   4    4     -     0/0    0/0     -\n  5 PA05           A3   5    5     -     0/1    0/1     -\n  7 PA07           RX   7    7     -     0/3    1/1     -\n  6 PA06           TX   6    6     -     0/2    1/0     -\n  8 PA08     FLASH_CS   -   16    0/0    2/0    0/0    1/2\n 19 PA19   FLASH_MISO   3    -    1/3    3/3    3/1    0/3\n 22 PA22   FLASH_MOSI   6    -    3/0    5/0    4/0    0/4\n 23 PA23    FLASH_SCK   7    -    3/1    5/1    4/1    0/5\n  9 PA09         MISO   9   17    0/1    2/1    0/1    1/3\n 10 PA10         MOSI  10   18    0/2    2/2    1/0    0/2\n 18 PA18       NEOPIX   2    -    1/2    3/2    3/0    0/2\n 15 PA15      NEO_PWR  15    -    2/3    4/3    3/1    0/5\n 11 PA11          SCK  11   19    0/3    2/3    1/1    0/3\n 17 PA17          SCL   1    -    1/1    3/1    2/1    0/7\n 16 PA16          SDA   0    -    1/0    3/0    2/0    0/6\n 30 PA30        SWCLK  10    -     -     1/2    1/0     -\n 31 PA31        SWDIO  11    -     -     1/3    1/1     -\n 24 PA24       USB_DM  12    -    3/2    5/2    5/0    1/2\n 25 PA25       USB_DP  13    -    3/3    5/3    5/1    1/3\n=== ==== ============ ==== ==== ====== ====== ====== ======\n```\n\n----------------------------------------\n\nTITLE: Simple Print Test Example\nDESCRIPTION: Example of a basic test file that prints a number, demonstrating the standard test structure using print statements for output comparison.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/writingtests.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef print_one():\n    print(1)\n\nprint_one()\n```\n\n----------------------------------------\n\nTITLE: Mount and Run Test Script\nDESCRIPTION: Mounts app directory and runs test script from host without copying to device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\nmpremote mount app run test.py\n```\n\n----------------------------------------\n\nTITLE: Importing _thread Module in MicroPython\nDESCRIPTION: Example of importing the experimental _thread module for multithreading support in MicroPython. This module provides similar functionality to CPython's _thread module but is not yet fully settled.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/_thread.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport _thread\n```\n\n----------------------------------------\n\nTITLE: Getting Current Thread ID in Zephyr\nDESCRIPTION: Function that returns the thread identifier for the current thread, which can be used to reference the thread in other operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncurrent_tid()\n```\n\n----------------------------------------\n\nTITLE: Listing Active VFS Mountpoints\nDESCRIPTION: Function that returns a list of tuples containing all active mountpoints and their associated filesystem objects.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/vfs.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmount()\n```\n\n----------------------------------------\n\nTITLE: Reading Temperature with DS18X20 in MicroPython\nDESCRIPTION: This code snippet demonstrates how to read temperature from DS18S20 and DS18B20 temperature sensors using the ds18x20 driver in MicroPython. It initializes the sensor, scans for devices, converts the temperature, waits for the conversion to complete, and then prints the temperature readings for each device found.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport time, ds18x20\nds = ds18x20.DS18X20(ow)\nroms = ds.scan()\nds.convert_temp()\ntime.sleep_ms(750)\nfor rom in roms:\n    print(ds.read_temp(rom))\n```\n\n----------------------------------------\n\nTITLE: Erasing ESP8266 Flash in Bash\nDESCRIPTION: This command erases the flash memory of the ESP8266 module. It should be run before installing MicroPython for the first time or as a troubleshooting measure.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ esptool.py --port /dev/ttyXXX erase_flash\n```\n\n----------------------------------------\n\nTITLE: Erasing Flash Memory on ESP32 Board with esptool.py\nDESCRIPTION: This command erases the entire flash memory of an ESP32 board using esptool.py. It's recommended before flashing MicroPython for the first time. The tool attempts to auto-detect the serial port.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/boards/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py erase_flash\n```\n\n----------------------------------------\n\nTITLE: Alternative ExtInt Object Creation in MicroPython\nDESCRIPTION: This snippet provides an alternative way to create an ExtInt object, showing the general syntax for the constructor. It includes placeholders for pin, mode, pull, and callback parameters.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.ExtInt.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nextint = pyb.ExtInt(pin, mode, pull, callback)\n```\n\n----------------------------------------\n\nTITLE: Flashing STM32 Using ST-Flash Tool\nDESCRIPTION: Commands for erasing and flashing firmware using st-flash utility. Supports both .bin and .hex file formats, with optional erase command to clear existing filesystem.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/NUCLEO_L152RE/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Optional erase to clear existing filesystem.\nst-flash erase\n\n# Flash .bin\nst-flash write firmware.bin 0x08000000\n# or, flash .hex\nst-flash --format ihex write firmware.hex\n```\n\n----------------------------------------\n\nTITLE: Initializing Classic CAN in Loopback Mode (Python)\nDESCRIPTION: Example of initializing and using a classic CAN controller in Loopback mode. It demonstrates setting up a filter, sending a message, and receiving a message.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.CAN.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyb import CAN\ncan = CAN(1, CAN.LOOPBACK)\ncan.setfilter(0, CAN.LIST16, 0, (123, 124, 125, 126))  # set a filter to receive messages with id=123, 124, 125 and 126\ncan.send('message!', 123)   # send a message with id 123\ncan.recv(0)                 # receive message on FIFO 0\n```\n\n----------------------------------------\n\nTITLE: Implementing a Critical Section in MicroPython ISR\nDESCRIPTION: This example demonstrates how to implement a critical section in MicroPython using pyb.disable_irq() and pyb.enable_irq(). It shows a timer callback function that simulates input and a main loop that processes the data while ensuring thread safety.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/isr_rules.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport pyb, micropython, array\nmicropython.alloc_emergency_exception_buf(100)\n\nclass BoundsException(Exception):\n    pass\n\nARRAYSIZE = const(20)\nindex = 0\ndata = array.array('i', 0 for x in range(ARRAYSIZE))\n\ndef callback1(t):\n    global data, index\n    for x in range(5):\n        data[index] = pyb.rng() # simulate input\n        index += 1\n        if index >= ARRAYSIZE:\n            raise BoundsException('Array bounds exceeded')\n\ntim4 = pyb.Timer(4, freq=100, callback=callback1)\n\nfor loop in range(1000):\n    if index > 0:\n        irq_state = pyb.disable_irq() # Start of critical section\n        for x in range(index):\n            print(data[x])\n        index = 0\n        pyb.enable_irq(irq_state) # End of critical section\n        print('loop {}'.format(loop))\n    pyb.delay(1)\n```\n\n----------------------------------------\n\nTITLE: Comparing Floating-Point Values in ARM Assembly\nDESCRIPTION: This instruction compares values in two FPU registers and sets the FPU condition flags. It's typically followed by transferring these flags to the APSR register to allow for conditional execution based on the comparison result.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_float.rst#2025-04-21_snippet_3\n\nLANGUAGE: assembly\nCODE:\n```\nvcmp(Sd, Sm)\n```\n\n----------------------------------------\n\nTITLE: Registering MicroPython Module\nDESCRIPTION: C code showing how to register a MicroPython module with optional conditional compilation support.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/cmodules.rst#2025-04-21_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nMP_REGISTER_MODULE(MP_QSTR_cexample, example_user_cmodule);\n```\n\n----------------------------------------\n\nTITLE: Using APA106 LED Driver with MicroPython on ESP32\nDESCRIPTION: This code snippet shows how to use the APA106 LED driver, which extends NeoPixel but uses a different color order. It demonstrates creating an APA106 driver and reading color values from a pixel.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/quickref.rst#2025-04-21_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom apa106 import APA106\nap = APA106(pin, 8)\nr, g, b = ap[0]\n```\n\n----------------------------------------\n\nTITLE: ESP32-S3 Register Definitions for MCPWM0 Control\nDESCRIPTION: This snippet provides the register addresses specific to the ESP32-S3 model for controlling the MCPWM0 peripheral. It shows how register addresses differ between ESP32 variants while maintaining similar functionality.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/tutorial/peripheral_access.rst#2025-04-21_snippet_1\n\nLANGUAGE: python3\nCODE:\n```\nDR_REG_DPORT_BASE = const(0x600C_0000)\nDPORT_PERIP_CLK_EN0_REG = const(DR_REG_DPORT_BASE + 0x0018)\nDPORT_PERIP_RST_EN0_REG = const(DR_REG_DPORT_BASE + 0x0020)\nDPORT_PWM0_CLK_EN = const(1 << 17)\nMCPWM0 = const(0x6001_E000 + 0x0004)\n...\n```\n\n----------------------------------------\n\nTITLE: CPU Register Access Example\nDESCRIPTION: Shows how to use uctypes to access CPU registers, specifically a subset of STM32F4xx WWDG block with bitfield definitions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/uctypes.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nWWDG_LAYOUT = {\n    \"WWDG_CR\": (0, {\n        \"WDGA\": 7 << uctypes.BF_POS | 1 << uctypes.BF_LEN | uctypes.BFUINT32,\n        \"T\": 0 << uctypes.BF_POS | 7 << uctypes.BF_LEN | uctypes.BFUINT32,\n    }),\n    \"WWDG_CFR\": (4, {\n        \"EWI\": 9 << uctypes.BF_POS | 1 << uctypes.BF_LEN | uctypes.BFUINT32,\n        \"WDGTB\": 7 << uctypes.BF_POS | 2 << uctypes.BF_LEN | uctypes.BFUINT32,\n        \"W\": 0 << uctypes.BF_POS | 7 << uctypes.BF_LEN | uctypes.BFUINT32,\n    }),\n}\n\nWWDG = uctypes.struct(0x40002c00, WWDG_LAYOUT)\n\nWWDG.WWDG_CFR.WDGTB = 0b10\nWWDG.WWDG_CR.WDGA = 1\nprint(\"Current counter:\", WWDG.WWDG_CR.T)\n```\n\n----------------------------------------\n\nTITLE: Setting or Querying GC Allocation Threshold in MicroPython\nDESCRIPTION: Sets or queries the additional GC allocation threshold. It triggers a collection when a specified amount of bytes have been allocated since the last collection. This function is a MicroPython extension with different semantics from CPython's set_threshold().\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/gc.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ngc.threshold([amount])\n```\n\n----------------------------------------\n\nTITLE: Configuring Mboot in mpconfigboard.mk for STM32F767\nDESCRIPTION: Example configuration in mpconfigboard.mk file for setting up Mboot on an STM32F767 board. Specifies linker files and text address for the bootloader.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/mboot/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\nLD_FILES = boards/stm32f767.ld boards/common_bl.ld\nTEXT0_ADDR = 0x08008000\n```\n\n----------------------------------------\n\nTITLE: Flashing MicroPython Firmware using dfu-util\nDESCRIPTION: This command uses dfu-util to write the MicroPython firmware to the Arduino Portenta H7 board. It specifies the device ID, firmware file, and necessary options for the flashing process.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/ARDUINO_PORTENTA_H7/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndfu-util -w -a 0 -d 2341:035b -D build-ARDUINO_PORTENTA_H7/firmware.dfu\n```\n\n----------------------------------------\n\nTITLE: Checking Thread Preemptibility in Zephyr\nDESCRIPTION: Function that checks if the current thread is preemptible (has non-negative priority value, which can be supplanted by higher or equal priority threads).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nis_preempt_thread()\n```\n\n----------------------------------------\n\nTITLE: Mount with File Injection\nDESCRIPTION: Mounts directory and enables file content injection via Ctrl-K.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\nmpremote mount app repl --inject-file demo.py\n```\n\n----------------------------------------\n\nTITLE: Configuring GPIO Input Pin with Pull-up\nDESCRIPTION: Creates a GPIO pin configured as input with pull-up resistor enabled. This is commonly used for reading digital signals with default high state.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pins.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npin = machine.Pin(0, machine.Pin.IN, machine.Pin.PULL_UP)\n```\n\n----------------------------------------\n\nTITLE: Updating Makefile for Custom Module in MicroPython Port\nDESCRIPTION: This Makefile snippet shows how to update the Makefile to include the new custom module in the build process.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/porting.rst#2025-04-21_snippet_8\n\nLANGUAGE: makefile\nCODE:\n```\nSRC_C = \\\n    main.c \\\n    modmyport.c \\\n    mphalport.c \\\n    ...\n\nSRC_QSTR += modmyport.c\n```\n\n----------------------------------------\n\nTITLE: Display Split JPEG - LCD160CR Methods\nDESCRIPTION: Methods for displaying a JPEG image split across multiple buffers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.jpeg_start(total_len)\nLCD160CR.jpeg_data(buf)\n```\n\n----------------------------------------\n\nTITLE: Analyzing Thread Statistics in Zephyr\nDESCRIPTION: Function that runs the Zephyr debug thread analyzer on the current thread and prints stack usage statistics. Requires CONFIG_THREAD_ANALYZER to be configured in the port.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nthread_analyze()\n```\n\n----------------------------------------\n\nTITLE: Deploy Firmware Using OpenOCD\nDESCRIPTION: Command to flash firmware using OpenOCD for boards with ST-LINK interface.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ make BOARD=STM32F4DISC deploy-openocd\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution: Simple If-Then (it)\nDESCRIPTION: Demonstrates the 'it' (if then) instruction for conditionally executing a single instruction based on a comparison result.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_compare.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncmp(r0, r1)\nit(eq)\nmov(r0, 100)  # Executed only if r0 == r1\n```\n\n----------------------------------------\n\nTITLE: Flashing STM32 Using DFU Utility\nDESCRIPTION: Command for flashing firmware using dfu-util tool in DFU mode. Requires the board to be in bootloader mode via BOOT0 pin or machine.bootloader() command.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/NUCLEO_L152RE/deploy.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndfu-util --alt 0 -D firmware.dfu\n```\n\n----------------------------------------\n\nTITLE: Array String Representation\nDESCRIPTION: Returns string representation of the array in format 'array(<type>, [<elements>])', where <type> is the type code and <elements> is a comma-separated list.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/array.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n__repr__()\n```\n\n----------------------------------------\n\nTITLE: Enabling Upload Mode in MicroPython\nDESCRIPTION: Python code to enable the upload mode on the board programmatically. This can be used as an alternative to manually pushing the reset button twice.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/boards/SEEED_XIAO_NRF52/deploy.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmachine.bootloader()\n```\n\n----------------------------------------\n\nTITLE: Array Extension with Iterable\nDESCRIPTION: Extends the array by appending multiple elements from an iterable object.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/array.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nextend(iterable)\n```\n\n----------------------------------------\n\nTITLE: Basic MicroPython Commands\nDESCRIPTION: Run basic Python commands in the MicroPython REPL to test the environment and ensure it is functioning properly.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/zephyr/tutorial/repl.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> print(\"hello world!\")\nhello world!\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> 1 + 2\n3\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> 1 / 2\n0.5\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> 3 * 'Zephyr'\nZephyrZephyrZephyr\n```\n\n----------------------------------------\n\nTITLE: Building Example Project\nDESCRIPTION: Command to compile the example project based on main.c, creating an executable named 'embed'\nSOURCE: https://github.com/micropython/micropython/blob/master/examples/embedding/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ make\n```\n\n----------------------------------------\n\nTITLE: Executing Multiplication and Division Instructions in ARM Assembly\nDESCRIPTION: These instructions perform multiplication with overflow handling and both signed and unsigned divisions. Familiarity with data type representation and ARM assembly environment is essential, especially for treating overflow results.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_arith.rst#2025-04-21_snippet_3\n\nLANGUAGE: Assembly\nCODE:\n```\n* mul(Rd, Rn) ``Rd = Rd * Rn``\n\nThis produces a 32 bit result with overflow lost. The result may be treated as signed or unsigned according to the definition of the operands.\n\n* sdiv(Rd, Rn, Rm) ``Rd = Rn / Rm``\n* udiv(Rd, Rn, Rm) ``Rd = Rn / Rm``\n```\n\n----------------------------------------\n\nTITLE: Configuring MicroPython Port in C\nDESCRIPTION: This C header file (mpconfigport.h) defines port-specific configurations for MicroPython, including feature flags and hardware definitions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/porting.rst#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#include <stdint.h>\n\n// Python internal features.\n#define MICROPY_ENABLE_GC                       (1)\n#define MICROPY_HELPER_REPL                     (1)\n#define MICROPY_ERROR_REPORTING                 (MICROPY_ERROR_REPORTING_TERSE)\n#define MICROPY_FLOAT_IMPL                      (MICROPY_FLOAT_IMPL_FLOAT)\n\n// Fine control over Python builtins, classes, modules, etc.\n#define MICROPY_PY_ASYNC_AWAIT                  (0)\n#define MICROPY_PY_BUILTINS_SET                 (0)\n#define MICROPY_PY_ATTRTUPLE                    (0)\n#define MICROPY_PY_COLLECTIONS                  (0)\n#define MICROPY_PY_MATH                         (0)\n#define MICROPY_PY_IO                           (0)\n#define MICROPY_PY_STRUCT                       (0)\n\n// Type definitions for the specific machine.\n\ntypedef intptr_t mp_int_t; // must be pointer size\ntypedef uintptr_t mp_uint_t; // must be pointer size\ntypedef long mp_off_t;\n\n// We need to provide a declaration/definition of alloca().\n#include <alloca.h>\n\n// Define the port's name and hardware.\n#define MICROPY_HW_BOARD_NAME \"example-board\"\n#define MICROPY_HW_MCU_NAME   \"unknown-cpu\"\n\n#define MP_STATE_PORT MP_STATE_VM\n```\n\n----------------------------------------\n\nTITLE: SPI Constants\nDESCRIPTION: This section defines constants used with the SPI implementation, including modes for initializing the SPI bus and bit ordering constants.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.SPI.rst#2025-04-21_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n.. data:: SPI.CONTROLLER\n.. data:: SPI.PERIPHERAL\n\n   for initialising the SPI bus to controller or peripheral mode\n\n.. data:: SPI.LSB\n.. data:: SPI.MSB\n\n   set the first bit to be the least or most significant bit\n```\n\n----------------------------------------\n\nTITLE: Complex Square Root Function in MicroPython\nDESCRIPTION: Square root function sqrt() for complex numbers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/cmath.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsqrt(z)  # Return the square-root of z\n```\n\n----------------------------------------\n\nTITLE: Implementing Standard Input/Output for MicroPython in C\nDESCRIPTION: This C code (mphalport.c) implements basic input and output functions for MicroPython using standard input/output streams.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/porting.rst#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n#include <unistd.h>\n#include \"py/mpconfig.h\"\n\n// Receive single character, blocking until one is available.\nint mp_hal_stdin_rx_chr(void) {\n    unsigned char c = 0;\n    int r = read(STDIN_FILENO, &c, 1);\n    (void)r;\n    return c;\n}\n\n// Send the string of given length.\nvoid mp_hal_stdout_tx_strn(const char *str, mp_uint_t len) {\n    int r = write(STDOUT_FILENO, str, len);\n    (void)r;\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling WiPy Heartbeat LED in MicroPython\nDESCRIPTION: The heartbeat() function controls the WiPy's heartbeat LED state. It can be used to either get the current state or set a new state for the LED. The function accepts and returns boolean values where True enables the LED and False disables it.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/wipy.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nheartbeat([enable])\n```\n\n----------------------------------------\n\nTITLE: Array Element Append Operation\nDESCRIPTION: Appends a single value to the end of the array, growing its size by one element.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/array.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nappend(val)\n```\n\n----------------------------------------\n\nTITLE: Configuring Mboot I2C in mpconfigboard.h\nDESCRIPTION: Example configuration in mpconfigboard.h file for setting up Mboot I2C interface. Defines I2C peripheral ID, SCL and SDA pins, and alternate function.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/mboot/README.md#2025-04-21_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n// Bootloader configuration\n#define MBOOT_I2C_PERIPH_ID 1\n#define MBOOT_I2C_SCL (pin_B8)\n#define MBOOT_I2C_SDA (pin_B9)\n#define MBOOT_I2C_ALTFUNC (4)\n```\n\n----------------------------------------\n\nTITLE: Deploying MicroPython Firmware to Arduino Opta using Make\nDESCRIPTION: This command uses the MicroPython build system to compile and deploy the firmware to the Arduino Opta board. It should be run from the 'ports/stm32' directory in the MicroPython source repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/ARDUINO_OPTA/deploy.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake BOARD=ARDUINO_OPTA deploy\n```\n\n----------------------------------------\n\nTITLE: Comparison Instruction: Basic Comparison\nDESCRIPTION: Demonstrates comparison instructions that set APSR flags without modifying registers. Supports comparing registers with immediate values or other registers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_compare.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncmp(Rn, imm8)  # Compare register with 8-bit immediate value\ncmp(Rn, Rm)   # Compare two registers\n```\n\n----------------------------------------\n\nTITLE: Building Bootloader for CC3200 with Makefile - Bash\nDESCRIPTION: This bash command uses the Makefile to build the bootloader for the CC3200 board in release mode. It is a necessary step before flashing the application image onto the CC3200.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/cc3200/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake BTARGET=bootloader BTYPE=release BOARD=LAUNCHXL\n```\n\n----------------------------------------\n\nTITLE: Using BLE.l2cap_recvinto Method in MicroPython\nDESCRIPTION: Receives data from a specified L2CAP channel into a buffer that supports the buffer protocol. Returns the number of bytes read, or available bytes if buf is None.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/bluetooth.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nBLE.l2cap_recvinto(conn_handle, cid, buf, /)\n```\n\n----------------------------------------\n\nTITLE: Reset Display - LCD160CR Method\nDESCRIPTION: Resets the display to its initial state.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.reset()\n```\n\n----------------------------------------\n\nTITLE: Implementing a Factorial Function in C for MicroPython\nDESCRIPTION: This C code defines a native MicroPython module that calculates factorials. It includes the necessary MicroPython API, implements the factorial function, and sets up the module initialization.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/natmod.rst#2025-04-21_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#include \"py/dynruntime.h\"\n\nstatic mp_int_t factorial_helper(mp_int_t x) {\n    if (x == 0) {\n        return 1;\n    }\n    return x * factorial_helper(x - 1);\n}\n\nstatic mp_obj_t factorial(mp_obj_t x_obj) {\n    mp_int_t x = mp_obj_get_int(x_obj);\n    mp_int_t result = factorial_helper(x);\n    return mp_obj_new_int(result);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(factorial_obj, factorial);\n\nmp_obj_t mpy_init(mp_obj_fun_bc_t *self, size_t n_args, size_t n_kw, mp_obj_t *args) {\n    MP_DYNRUNTIME_INIT_ENTRY\n    mp_store_global(MP_QSTR_factorial, MP_OBJ_FROM_PTR(&factorial_obj));\n    MP_DYNRUNTIME_INIT_EXIT\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Buffer Usage in MicroPython\nDESCRIPTION: Compares two approaches for reading data from hardware interfaces. The second approach reuses a pre-allocated buffer, reducing memory fragmentation and improving performance.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nwhile True:\n    var = spi.read(100)\n    # process data\n\nbuf = bytearray(100)\nwhile True:\n    spi.readinto(buf)\n    # process data in buf\n```\n\n----------------------------------------\n\nTITLE: Enabling FAT Filesystem for nRF Series\nDESCRIPTION: Command to compile the nRF port with FAT filesystem support enabled. This is necessary for using the oofatfs module.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/README.md#2025-04-21_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nmake BOARD=PCA10040 MICROPY_VFS_FAT=1\n```\n\n----------------------------------------\n\nTITLE: Building the Minimal Variant of MicroPython Unix Port\nDESCRIPTION: These commands build the minimal variant of the MicroPython Unix port, which disables most optional features and modules.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/unix/README.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ cd ports/unix\n$ make submodules\n$ make VARIANT=minimal\n```\n\n----------------------------------------\n\nTITLE: PIO Assembly Instruction Example in Python\nDESCRIPTION: Example showing how to encode a PIO set instruction using the asm_pio_encode function. The instruction sets pin 0 to value 1.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/rp2.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> rp2.asm_pio_encode(\"set(0, 1)\", 0)\n57345\n```\n\n----------------------------------------\n\nTITLE: Running MicroPython Internal Benchmarks\nDESCRIPTION: This snippet demonstrates how to run internal benchmarks for MicroPython, comparing the performance of different bytebuffer implementations. It shows the command to execute specific test cases and the expected output format.\nSOURCE: https://github.com/micropython/micropython/blob/master/tests/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ./run-internalbench.py internal_bench/bytebuf-*.py\ninternal_bench/bytebuf:\n    0.094s (+00.00%) internal_bench/bytebuf-1-inplace.py\n    0.471s (+399.24%) internal_bench/bytebuf-2-join_map_bytes.py\n    0.177s (+87.78%) internal_bench/bytebuf-3-bytarray_map.py\n1 tests performed (3 individual testcases)\n```\n\n----------------------------------------\n\nTITLE: Managing Capture Value for Timer Channel in MicroPython\nDESCRIPTION: Method for getting or setting the capture value for a timer channel. This method is primarily used when the channel is in input capture mode, though it's an alias that can also be used for compare and pulse_width functions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ntimerchannel.capture([value])\n```\n\n----------------------------------------\n\nTITLE: Loading Byte from Memory in ARM Thumb Assembly\nDESCRIPTION: Loads a single byte from memory at address [Rn + imm5] into register Rt. The loaded byte is zero-extended to 32 bits. The imm5 offset is measured in bytes.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_ldr.rst#2025-04-21_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\nldrb(Rt, [Rn, imm5])\n```\n\n----------------------------------------\n\nTITLE: Executing Negation Instruction in ARM Assembly\nDESCRIPTION: Negation flips the sign of a register's value, taking the negated operand and storing it in the destination register. It requires basic arm assembly setup with an understanding of how negation operates on integer representations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_arith.rst#2025-04-21_snippet_2\n\nLANGUAGE: Assembly\nCODE:\n```\n* neg(Rd, Rn) ``Rd = -Rn``\n```\n\n----------------------------------------\n\nTITLE: Adding os.splice() Function for Efficient Data Transfer\nDESCRIPTION: Introduces os.splice() function that allows moving data between two file descriptors without copying between kernel and user address spaces, with the requirement that one file descriptor must refer to a pipe.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nos.splice()\n```\n\n----------------------------------------\n\nTITLE: LED Pulse Loop Implementation\nDESCRIPTION: Shows how to create multiple LED pulses in sequence using a for loop.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/pwm.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> for i in range(10):\n...     pulse(led, 20)\n```\n\n----------------------------------------\n\nTITLE: Setting SPI Window - LCD160CR Method\nDESCRIPTION: Method to define the window area for SPI data writing using x, y coordinates and width/height.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.set_spi_win(x, y, w, h)\n```\n\n----------------------------------------\n\nTITLE: Finding TICKS_MAX Value\nDESCRIPTION: Example showing how to determine the TICKS_MAX value used by the port\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/time.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprint(ticks_add(0, -1))\n```\n\n----------------------------------------\n\nTITLE: Turning On LED in MicroPython\nDESCRIPTION: Turns the LED on to maximum intensity.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.LED.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nLED.on()\n```\n\n----------------------------------------\n\nTITLE: Manipulating Real-Time Clock on WiPy with MicroPython\nDESCRIPTION: This snippet illustrates the use of the Real-Time Clock (RTC) on the WiPy board, allowing initialization with specific dates and times. It shows creating an RTC alarm and setting up interrupts for wake-up operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/quickref.rst#2025-04-21_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nfrom machine import RTC\n\nrtc = RTC() # init with default time and date\nrtc = RTC(datetime=(2015, 8, 29, 9, 0, 0, 0, None)) # init with a specific time and date\nprint(rtc.now())\n\ndef alarm_handler (rtc_o):\n    pass\n    # do some non blocking operations\n    # warning printing on an irq via telnet is not\n    # possible, only via UART\n\n# create a RTC alarm that expires after 5 seconds\nrtc.alarm(time=5000, repeat=False)\n\n# enable RTC interrupts\nrtc_i = rtc.irq(trigger=RTC.ALARM0, handler=alarm_handler, wake=machine.SLEEP)\n\n# go into suspended mode waiting for the RTC alarm to expire and wake us up\nmachine.lightsleep()\n```\n\n----------------------------------------\n\nTITLE: Deploying MicroPython Firmware on Teensy 4.0 using Command-line Teensy Loader\nDESCRIPTION: This command uses the Teensy Loader CLI to deploy MicroPython firmware on a Teensy 4.0 board. It specifies the microcontroller unit, enables verbose output, and writes the firmware file to the board.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/mimxrt/boards/deploy_teensy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nteensy_loader_cli --mcu=imxrt1062 -v -w TEENSY40-<date_version_tag>.hex\n```\n\n----------------------------------------\n\nTITLE: Executing Subtraction Instructions in ARM Assembly\nDESCRIPTION: Subtraction instructions operate by deducting either immediate values or register contents, optionally considering the carry flag's state. Knowledge of condition flags and registers in ARM architecture is imperative.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_arith.rst#2025-04-21_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\n* sub(Rdn, imm8) ``Rdn = Rdn - imm8``\n* sub(Rd, Rn, imm3) ``Rd = Rn - imm3``\n* sub(Rd, Rn, Rm) ``Rd = Rn - Rm``\n* sbc(Rd, Rn) ``Rd = Rd - Rn - not(carry)``\n```\n\n----------------------------------------\n\nTITLE: Building Debug Image for CC3200 - Bash\nDESCRIPTION: This command creates a debug version of the application image for the CC3200, which is useful for development and debugging purposes. The process requires disabling optimizations within the Makefile.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/cc3200/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake BTARGET=application BTYPE=debug BOARD=LAUNCHXL\n```\n\n----------------------------------------\n\nTITLE: Hexadecimal Digest Alternative in MicroPython\nDESCRIPTION: Recommended alternative to the unimplemented hexdigest() method, using binascii.hexlify() to achieve a similar effect.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/hashlib.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nbinascii.hexlify(hash.digest())\n```\n\n----------------------------------------\n\nTITLE: Feed Watchdog Timer - LCD160CR Method\nDESCRIPTION: Manages the display's internal watchdog timer with ~30 second timeout.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.feed_wdt()\n```\n\n----------------------------------------\n\nTITLE: Makefile for Compiling Native MicroPython Module\nDESCRIPTION: This Makefile defines the build configuration for a native MicroPython module. It specifies the module name, source files, target architecture, and includes the necessary MicroPython build rules.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/natmod.rst#2025-04-21_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\nMPY_DIR = ../../..\n\nMOD = factorial\n\nSRC = factorial.c\n\nARCH = x64\n\ninclude $(MPY_DIR)/py/dynruntime.mk\n```\n\n----------------------------------------\n\nTITLE: Using continue statement in finally clause in Python 3.8\nDESCRIPTION: Demonstrates the use of a continue statement within a finally clause, which was previously illegal but is now allowed in Python 3.8. This change provides more flexibility in exception handling and control flow.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_38.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    # Some code\n    pass\nfinally:\n    continue\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython on Linux for Windows\nDESCRIPTION: Commands to install dependencies and cross-compile MicroPython for Windows on a Debian/Ubuntu system using MinGW-w64.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/windows/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install python3 build-essential gcc-mingw-w64\nmake -C ../../mpy-cross\nmake CROSS_COMPILE=i686-w64-mingw32-\n```\n\n----------------------------------------\n\nTITLE: Handling Wi-Fi and ESP-NOW Operations\nDESCRIPTION: This snippet explains configuring WLAN for reliable ESP-NOW communications when a device is also connected to a Wi-Fi network, highlighting power-saving mode impacts, channel alignment, and specific conditions to handle ESP8266 message reception.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/espnow.rst#2025-04-21_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nimport network, time, espnow\n\nsta, ap = wifi_reset()  # Reset wifi to AP off, STA on and disconnected\nsta.connect('myssid', 'mypassword')\nwhile not sta.isconnected():  # Wait until connected...\n    time.sleep(0.1)\nsta.config(pm=sta.PM_NONE)  # ..then disable power saving\n\n# Print the wifi channel used AFTER finished connecting to access point\nprint(\"Proxy running on channel:\", sta.config(\"channel\"))\ne = espnow.ESPNow(); e.active(True)\nfor peer, msg in e:\n    # Receive espnow messages and forward them to MQTT broker over wifi\n```\n\n----------------------------------------\n\nTITLE: Building the Standard MicroPython Unix Port\nDESCRIPTION: This command builds the standard variant of the MicroPython Unix port executable.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/unix/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ make\n```\n\n----------------------------------------\n\nTITLE: Math Module Special Functions\nDESCRIPTION: Examples of special mathematical functions including error functions, gamma functions, and numeric operations\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/math.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Error functions\nmath.erf(x)\nmath.erfc(x)\n\n# Gamma functions\nmath.gamma(x)\nmath.lgamma(x)\n\n# Numeric operations\nmath.ceil(x)\nmath.floor(x)\nmath.trunc(x)\nmath.copysign(x, y)\nmath.fabs(x)\nmath.frexp(x)\nmath.ldexp(x, exp)\nmath.modf(x)\nmath.fmod(x, y)\n```\n\n----------------------------------------\n\nTITLE: Sparkfun SAMD51 Thing Plus Pin Assignment Table\nDESCRIPTION: A detailed table showing pin assignments for the Sparkfun SAMD51 Thing Plus, including GPIO, pin names, IRQ, ADC, Serial, TC, and PWM information.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/pinout.rst#2025-04-21_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nSparkfun SAMD51 Thing Plus pin assignment table\n------------------------------------------------\n\n=== ==== ============ ==== ==== ==== ====== ====== ===== ===== =====\nPin GPIO Pin name     IRQ  ADC  ADC  Serial Serial  TC    PWM   PWM\n=== ==== ============ ==== ==== ==== ====== ====== ===== ===== =====\n  2 PA02           A0   2    0    -     -      -     -     -     -\n 40 PB08           A1   8    2    0     -     4/0   4/0    -     -\n 41 PB09           A2   9    3    1     -     4/1   4/1    -     -\n  4 PA04           A3   4    4    -     -     0/0   0/0    -     -\n  5 PA05           A4   5    5    -     -     0/1   0/1    -     -\n 34 PB02           A5   2   14    -     -     5/0   6/0   2/2    -\n 13 PA13           D0  13    -    -    2/1    4/0   2/1   0/7   1/3\n 12 PA12           D1  12    -    -    2/0    4/1   2/0   0/6   1/2\n  6 PA06           D4   6    6    -     -     0/2   1/0    -     -\n 15 PA15           D5  15    -    -    2/3    4/3   3/1   2/1   1/3\n 20 PA20           D6   4    -    -    5/2    3/2   7/0   1/4   0/0\n 21 PA21           D7   5    -    -    5/3    3/3   7/1   1/5   0/1\n  7 PA07           D9   7    7    -     -     0/3   1/1    -     -\n 18 PA18          D10   2    -    -    1/2    3/2   3/0   1/2   0/6\n 16 PA16          D11   0    -    -    1/0    3/1   2/0   1/0   0/4\n 19 PA19          D12   3    -    -    1/3    3/3   3/1   1/3   0/7\n 17 PA17          D13   1    -    -    1/1    3/0   2/1   1/1   0/5\n 10 PA10     FLASH_CS  10   10    -    0/2    2/2   1/0   0/2   1/6\n 11 PA11   FLASH_MISO  11   11    -    0/3    2/3   1/1   0/3   1/7\n  8 PA08   FLASH_MOSI   -    8    2    0/0    2/1   0/0   0/0   1/4\n  9 PA09    FLASH_SCK   9    9    3    0/1    2/0   0/1   0/1   1/5\n 13 PA13           RX  13    -    -    2/1    4/0   2/1   0/7   1/3\n 12 PA12           TX  12    -    -    2/0    4/1   2/0   0/6   1/2\n 43 PB11         MISO  12    -    -     -     4/3   5/1   0/5   1/1\n 44 PB12         MOSI  12    -    -    4/0     -    4/0   3/0   0/0\n 55 PB23          RXD   7    -    -    1/3    5/3   7/1    -     -\n 35 PB03        RXLED   9   15    -     -     5/1   6/1    -     -\n 45 PB13          SCK  13    -    -    4/1     -    4/1   3/1   0/1\n 23 PA23          SCL   7    -    -    3/1    5/0   4/1   1/7   0/3\n 22 PA22          SDA   6    -    -    3/0    5/1   4/0   1/6   0/2\n 30 PA30        SWCLK  14    -    -    7/2    1/2   6/0   2/0    -\n 31 PA31        SWDIO  15    -    -    7/3    1/3   6/1   2/1    -\n```\n\n----------------------------------------\n\nTITLE: Socket Constructor Example - CPython Style\nDESCRIPTION: Demonstrates the CPython 3.4 socket constructor signature that accepts keyword arguments.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/modules_preamble.txt#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsocket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)\n```\n\n----------------------------------------\n\nTITLE: Controlling flash memory operations in MicroPython Zephyr module\nDESCRIPTION: Method for performing control operations on the flash memory. It implements the ioctl function of the block protocol defined by vfs.AbstractBlockDev, allowing various control commands to be sent with arguments.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.FlashArea.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nFlashArea.ioctl(cmd, arg)\n```\n\n----------------------------------------\n\nTITLE: Defining MSC Parameters Example - Python\nDESCRIPTION: Example showing how to configure Mass Storage Class (MSC) parameters by specifying SCSI LUNs using Flash and SDCard objects.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmsc=(pyb.Flash(), pyb.SDCard())\n```\n\n----------------------------------------\n\nTITLE: Upload File to Device\nDESCRIPTION: Copies main.py from local directory to device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_40\n\nLANGUAGE: bash\nCODE:\n```\nmpremote cp main.py :\n```\n\n----------------------------------------\n\nTITLE: Uniform Random Float in MicroPython\nDESCRIPTION: Returns a random float N where a <= N <= b for a <= b, or b <= N <= a for b < a.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/random.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nuniform(a, b)\n```\n\n----------------------------------------\n\nTITLE: Constructing a FlashArea object in MicroPython Zephyr module\nDESCRIPTION: Creates a FlashArea object for accessing flash memory at a specified partition ID with a given block size. The ID values are integers corresponding to fixed flash partitions defined in the devicetree.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.FlashArea.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nFlashArea(id, block_size)\n```\n\n----------------------------------------\n\nTITLE: Setting CPU Frequency with pyb.freq in MicroPython\nDESCRIPTION: The `pyb.freq()` method sets the CPU frequency to the specified value in Hertz. This allows for dynamic adjustment of processing power and energy consumption.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/power_ctrl.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npyb.freq(30000000) # set CPU frequency to 30MHz\n```\n\n----------------------------------------\n\nTITLE: Adding Manifest to Board Definition (Makefile)\nDESCRIPTION: Configuration in mpconfigboard.mk to specify a default manifest path for a custom board. This sets the FROZEN_MANIFEST variable to point to a manifest file in the board directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/manifest.rst#2025-04-21_snippet_1\n\nLANGUAGE: makefile\nCODE:\n```\nFROZEN_MANIFEST ?= $(BOARD_DIR)/manifest.py\n```\n\n----------------------------------------\n\nTITLE: Creating Data Arrays in Assembly\nDESCRIPTION: The data directive embeds arrays of values directly in memory. It takes a size parameter followed by data values which will be stored consecutively in memory in little-endian format.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_directives.rst#2025-04-21_snippet_2\n\nLANGUAGE: assembly\nCODE:\n```\ndata(1, 2, 3, 4)\ndata(4, 2, 100000)\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython PowerPC Port with Default UART\nDESCRIPTION: Command to build the MicroPython PowerPC port with the default potato UART for microwatt.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/powerpc/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ make\n```\n\n----------------------------------------\n\nTITLE: Converting a List into a Heap in Python\nDESCRIPTION: This function converts a given list into a heap. It's an in-place operation, meaning it modifies the original list to satisfy the heap invariant without creating a new list.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/heapq.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nheapify(x)\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Cross-Compiler\nDESCRIPTION: Commands to build the MicroPython cross-compiler (mpy-cross) used for pre-compiling Python scripts to .mpy files for firmware inclusion.\nSOURCE: https://github.com/micropython/micropython/blob/master/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cd mpy-cross\n$ make\n```\n\n----------------------------------------\n\nTITLE: Installing esptool.py using pip\nDESCRIPTION: Command to install esptool.py, a tool used for flashing ESP8266 firmware, using pip package manager.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/intro.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install esptool\n```\n\n----------------------------------------\n\nTITLE: Erasing ESP8266 flash memory\nDESCRIPTION: Command to erase the entire flash memory of an ESP8266 device using esptool.py before installing new firmware.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/intro.rst#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py --port /dev/ttyUSB0 erase_flash\n```\n\n----------------------------------------\n\nTITLE: Initializing Submodules for SAMD Board\nDESCRIPTION: Command to initialize the correct set of submodules for a specific board (in this example, ADAFRUIT_ITSYBITSY_M4_EXPRESS). This step is required before building the firmware.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/samd/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make BOARD=ADAFRUIT_ITSYBITSY_M4_EXPRESS submodules\n```\n\n----------------------------------------\n\nTITLE: Compiling Without LTO for nRF Series\nDESCRIPTION: Command to compile the nRF port without Link Time Optimization (LTO) enabled. This can be useful for troubleshooting compilation issues with certain toolchains.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nmake BOARD=PCA10040 LTO=0\n```\n\n----------------------------------------\n\nTITLE: Adding Sources and Setting up Build Configuration for MicroPython\nDESCRIPTION: Finalizes the MicroPython build configuration by adding QSTR sources, setting mpy-cross flags, configuring the frozen manifest, and adding all source files to the build target. It also sets up compiler and linker options for the build.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\n# Add qstr sources for extmod and usermod, in case they are modified by components above.\nlist(APPEND MICROPY_SOURCE_QSTR\n    ${MICROPY_SOURCE_EXTMOD}\n    ${MICROPY_SOURCE_USERMOD}\n    ${MICROPY_SOURCE_BOARD}\n)\n\n# Define mpy-cross flags\nset(MICROPY_CROSS_FLAGS -march=armv6m)\n\n# Set the frozen manifest file\nif (MICROPY_USER_FROZEN_MANIFEST)\n    set(MICROPY_FROZEN_MANIFEST ${MICROPY_USER_FROZEN_MANIFEST})\nelseif (NOT MICROPY_FROZEN_MANIFEST)\n    set(MICROPY_FROZEN_MANIFEST ${MICROPY_PORT_DIR}/boards/manifest.py)\nendif()\n\ntarget_sources(${MICROPY_TARGET} PRIVATE\n    ${MICROPY_SOURCE_PY}\n    ${MICROPY_SOURCE_EXTMOD}\n    ${MICROPY_SOURCE_LIB}\n    ${MICROPY_SOURCE_DRIVERS}\n    ${MICROPY_SOURCE_PORT}\n    ${MICROPY_SOURCE_BOARD}\n)\n\ntarget_link_libraries(${MICROPY_TARGET} micropy_lib_mbedtls)\n\ntarget_link_libraries(${MICROPY_TARGET} usermod)\n\ntarget_include_directories(${MICROPY_TARGET} PRIVATE\n    ${MICROPY_INC_CORE}\n    ${MICROPY_INC_USERMOD}\n    ${MICROPY_BOARD_DIR}\n    \"${MICROPY_PORT_DIR}\"\n    \"${CMAKE_BINARY_DIR}\"\n)\n\ntarget_compile_options(${MICROPY_TARGET} PRIVATE\n    -Wall\n    -Werror\n    -g  # always include debug information in the ELF\n)\n\ntarget_link_options(${MICROPY_TARGET} PRIVATE\n    -Wl,--defsym=__micropy_c_heap_size__=${MICROPY_C_HEAP_SIZE}\n    -Wl,--wrap=dcd_event_handler\n    -Wl,--wrap=runtime_init_clocks\n)\n\nif(PICO_RP2350)\n    target_link_options(${MICROPY_TARGET} PRIVATE\n        -Wl,--defsym=__micropy_extra_stack__=4096\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Initializing ADCBlock Configuration in MicroPython\nDESCRIPTION: This method configures the ADC peripheral. The bits parameter sets the resolution of the conversion process.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.ADCBlock.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nADCBlock.init(*, bits)\n```\n\n----------------------------------------\n\nTITLE: Generating Self-Signed RSA Key/Certificate Pair for MicroPython Tests\nDESCRIPTION: These commands create a new self-signed RSA key/certificate pair using OpenSSL, then convert them to DER format for use in MicroPython SSL/TLS tests.\nSOURCE: https://github.com/micropython/micropython/blob/master/tests/README.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ openssl req -x509 -newkey rsa:2048 -keyout rsa_key.pem -out rsa_cert.pem -days 3650 -nodes -subj '/CN=micropython.local/O=MicroPython/C=AU'\n$ openssl pkey -in rsa_key.pem -out rsa_key.der -outform DER\n$ openssl x509 -in rsa_cert.pem -out rsa_cert.der -outform DER\n```\n\n----------------------------------------\n\nTITLE: Terminal Stream Duplication\nDESCRIPTION: Duplicates or switches the MicroPython REPL terminal to a given stream object with optional index parameter.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/os.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndupterm(stream_object, index=0, /)\n```\n\n----------------------------------------\n\nTITLE: Defining Pin Assignment Table for SAMD21 Xplained PRO\nDESCRIPTION: This table provides a comprehensive pin assignment for the SAMD21 Xplained PRO board, including GPIO pins, pin names, IRQ numbers, ADC channels, and various peripheral mappings. It notes that there are no pins labelled for default devices on this board, and DAC output is on pin PA02.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/samd/pinout.rst#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n=== ==== ============ ==== ==== ====== ====== ====== ======\nPin GPIO Pin name     IRQ  ADC  Serial Serial TCC/TC TCC/TC\n=== ==== ============ ==== ==== ====== ====== ====== ======\n 32 PB00    EXT1_PIN3   0    8     -     5/2   7/0     -\n 33 PB01    EXT1_PIN4   1    9     -     5/3   7/1     -\n 38 PB06    EXT1_PIN5   6   14     -      -     -      -\n 39 PB07    EXT1_PIN6   7   15     -      -     -      -\n 34 PB02    EXT1_PIN7   2   10     -     5/0   6/0     -\n 35 PB03    EXT1_PIN8   3   11     -     5/1   6/1     -\n 36 PB04    EXT1_PIN9   4   12     -      -     -      -\n 37 PB05   EXT1_PIN10   5   13     -      -     -      -\n  8 PA08   EXT1_PIN11   -   16    0/0    2/0   0/0    1/2\n  9 PA09   EXT1_PIN12   9   17    0/1    2/1   0/1    1/3\n 41 PB09   EXT1_PIN13   9    3     -     4/1   4/1     -\n 40 PB08   EXT1_PIN14   8    2     -     4/0   4/0     -\n  5 PA05   EXT1_PIN15   5    5     -     0/1   0/1     -\n  6 PA06   EXT1_PIN16   6    6     -     0/2   1/0     -\n  4 PA04   EXT1_PIN17   4    4     -     0/0   0/0     -\n  7 PA07   EXT1_PIN18   7    7     -     0/3   1/1     -\n 10 PA10    EXT2_PIN3  10   18    0/2    2/2   1/0    0/2\n 11 PA11    EXT2_PIN4  11   19    0/3    2/3   1/1    0/3\n 20 PA20    EXT2_PIN5   4    -    5/2    3/2   7/0    0/4\n 21 PA21    EXT2_PIN6   5    -    5/3    3/3   7/1    0/7\n 44 PB12    EXT2_PIN7  12    -    4/0     -    4/0    0/6\n 45 PB13    EXT2_PIN8  13    -    4/1     -    4/1    0/7\n 46 PB14    EXT2_PIN9  14    -    4/2     -    5/0     -\n 47 PB15   EXT2_PIN10  15    -    4/3     -    5/1     -\n 43 PB11   EXT2_PIN13  11    -     -     4/3   5/1    0/5\n 42 PB10   EXT2_PIN14  10    -     -     4/2   5/0    0/4\n 17 PA17   EXT2_PIN15   1    -    1/1    3/1   2/1    0/7\n 18 PA18   EXT2_PIN16   2    -    1/2    3/2   3/0    0/2\n 16 PA16   EXT2_PIN17   0    -    1/0    3/0   2/0    0/6\n 19 PA19   EXT2_PIN18   3    -    1/3    3/3   3/1    0/3\n  2 PA02    EXT3_PIN3   2    0     -      -     -      -\n  3 PA03    EXT3_PIN4   3    1     -      -     -      -\n 15 PA15    EXT3_PIN6  15    -    2/3    4/3   3/1    0/5\n 12 PA12    EXT3_PIN7  12    -    2/0    4/0   2/0    0/6\n 13 PA13    EXT3_PIN8  13    -    2/1    4/1   2/0    0/7\n 28 PA28    EXT3_PIN9   8    -     -      -     -      -\n 27 PA27   EXT3_PIN10  15    -     -      -     -      -\n 49 PB17   EXT3_PIN15   1    -    5/1     -    6/1    0/5\n 54 PB22   EXT3_PIN16   6    -     -     5/2   7/0     -\n 48 PB16   EXT3_PIN17   9    -    5/0     -    6/0    0/4\n 55 PB23   EXT3_PIN18   7    -     -     5/3   7/1     -\n 62 PB30          LED  14    -     -     5/0   0/0    1/2\n 30 PA30        SWCLK  10    -     -     1/2   1/0     -\n 31 PA31        SWDIO  11    -     -     1/3   1/1     -\n 24 PA24       USB_DM  12    -    3/2    5/2   5/0    1/2\n 25 PA25       USB_DP  13    -    3/3    5/3   5/1    1/3\n  0 PA00            -   0    -     -     1/0   2/0     -\n  1 PA01            -   1    -     -     1/1   2/1     -\n 14 PA14            -  14    -    2/2    4/2   3/0    0/4\n 22 PA22            -   6    -    3/0    5/0   4/0    0/4\n 23 PA23            -   7    -    3/1    5/1   4/1    0/5\n 63 PB31            -  15    -     -     5/1   0/1    1/3\n=== ==== ============ ==== ==== ====== ====== ====== ======\n```\n\n----------------------------------------\n\nTITLE: Building STM32 Port - Bash\nDESCRIPTION: Commands to build the STM32 port of MicroPython\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/gettingstarted.rst#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ cd ports/stm32\n$ make submodules\n$ make\n```\n\n----------------------------------------\n\nTITLE: Creating WIZNET5K Network Interface in MicroPython\nDESCRIPTION: This example demonstrates how to create a WIZNET5K network interface using specific pins on a PyBoard. It uses SPI(1) for communication, X5 for chip select, and X4 for reset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.WIZNET5K.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nnic = network.WIZNET5K(pyb.SPI(1), pyb.Pin.board.X5, pyb.Pin.board.X4)\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Module to MicroPython Port in C\nDESCRIPTION: This C code (modmyport.c) demonstrates how to add a custom module to the MicroPython port, including function definitions and module registration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/porting.rst#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n#include \"py/runtime.h\"\n\nstatic mp_obj_t myport_info(void) {\n    mp_printf(&mp_plat_print, \"info about my port\\n\");\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(myport_info_obj, myport_info);\n\nstatic const mp_rom_map_elem_t myport_module_globals_table[] = {\n    { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_myport) },\n    { MP_ROM_QSTR(MP_QSTR_info), MP_ROM_PTR(&myport_info_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(myport_module_globals, myport_module_globals_table);\n\nconst mp_obj_module_t myport_module = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&myport_module_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_myport, myport_module);\n```\n\n----------------------------------------\n\nTITLE: Install Package from GitHub\nDESCRIPTION: Installs package from specific branch of GitHub repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\nmpremote mip install github:org/repo@branch\n```\n\n----------------------------------------\n\nTITLE: Enabling Mouse Mode in boot.py\nDESCRIPTION: This modified boot.py code enables HID mouse functionality by uncommenting the relevant line that configures the USB mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/usb_mouse.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npyb.usb_mode('VCP+HID') # act as a serial device and a mouse\n```\n\n----------------------------------------\n\nTITLE: Writing blocks to flash memory in MicroPython Zephyr module\nDESCRIPTION: Methods for writing data to flash memory blocks. The methods implement the block protocol defined by vfs.AbstractBlockDev, allowing writing to a specific block number from a buffer, with an optional offset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.FlashArea.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nFlashArea.writeblocks(block_num, buf)\nFlashArea.writeblocks(block_num, buf, offset)\n```\n\n----------------------------------------\n\nTITLE: Disabling Uninitialized Warnings for Math Libraries\nDESCRIPTION: Disables uninitialized variable warnings for Pico SDK math libraries.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_17\n\nLANGUAGE: cmake\nCODE:\n```\nset_source_files_properties(\n    ${PICO_SDK_PATH}/src/rp2_common/pico_double/double_math.c\n    ${PICO_SDK_PATH}/src/rp2_common/pico_float/float_math.c\n    PROPERTIES\n    COMPILE_OPTIONS \"-Wno-error=uninitialized\"\n)\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Cross-Compiler (Makefile)\nDESCRIPTION: Command to build the MicroPython cross-compiler, which is a prerequisite for building the QEMU port.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/qemu/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make -C ../../mpy-cross\n```\n\n----------------------------------------\n\nTITLE: Removing Leading Whitespace from Bytes Object in Python\nDESCRIPTION: This code demonstrates how to remove leading whitespace from a bytes object using the lstrip() method. It's important to note that this operation creates a new bytes object, as both strings and bytes are immutable in Python.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/constrained.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfoo = b'   empty whitespace'\nfoo = foo.lstrip()\n```\n\n----------------------------------------\n\nTITLE: Array Length Operation\nDESCRIPTION: Returns the number of items in the array when called with len() function.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/array.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n__len__()\n```\n\n----------------------------------------\n\nTITLE: Installing Linux Dependencies - Bash\nDESCRIPTION: Commands to install required Linux dependencies for MicroPython development\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/gettingstarted.rst#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt-get install build-essential libffi-dev git pkg-config\n```\n\n----------------------------------------\n\nTITLE: Reading Files in MicroPython\nDESCRIPTION: Shows how to open an existing file in read mode (default) and read its contents using the read() method. The file is opened in text mode by default.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/filesystem.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nf = open('data.txt')\nf.read()\nf.close()\n```\n\n----------------------------------------\n\nTITLE: Flashing MicroPython firmware with specific SPI Flash Mode\nDESCRIPTION: Command to write MicroPython firmware to an ESP8266 device using esptool.py, with a manually set SPI Flash Mode for compatibility with certain board configurations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/intro.rst#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py --port /dev/ttyUSB0 --baud 460800 write_flash --flash_size=detect -fm dout 0 esp8266-20170108-v1.8.7.bin\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython PowerPC Port with LPC Serial UART\nDESCRIPTION: Command to build the MicroPython PowerPC port with LPC serial UART for machines like QEMU powernv.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/powerpc/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ make UART=lpc_serial\n```\n\n----------------------------------------\n\nTITLE: Using Complex Trigonometric Functions in MicroPython\nDESCRIPTION: Basic trigonometric functions cos() and sin() for complex numbers.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/cmath.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncos(z)  # Return the cosine of z\nsin(z)  # Return the sine of z\n```\n\n----------------------------------------\n\nTITLE: Configuring CYW43 Bluetooth Support for MicroPython\nDESCRIPTION: Configures Bluetooth support for the CYW43 wireless chip. This enables Bluetooth functionality when using the Pico W board with its onboard CYW43439 wireless chip, and links the appropriate BTstack transport layer if BTstack is used.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif (MICROPY_PY_BLUETOOTH_CYW43)\n    target_compile_definitions(${MICROPY_TARGET} PRIVATE\n        CYW43_ENABLE_BLUETOOTH=1\n        MICROPY_PY_BLUETOOTH_CYW43=1\n    )\n\n    if (MICROPY_BLUETOOTH_BTSTACK)\n        target_link_libraries(${MICROPY_TARGET}\n            pico_btstack_hci_transport_cyw43\n        )\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: IP Configuration Function in MicroPython\nDESCRIPTION: Function to get or set global IP-configuration parameters. Supports both IPv4 and IPv6 DNS server configuration and address type preferences. Parameters availability depends on the specific port and network interface being used.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/network.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nipconfig('param')\nipconfig(param=value, ...)\n```\n\n----------------------------------------\n\nTITLE: Defining Labels in MicroPython Assembly\nDESCRIPTION: A directive for defining labels that can be targeted by branch instructions. Labels are used as targets for branch instructions like b().\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_directives.rst#2025-04-21_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\nlabel(INNER1)\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Cross-Compiler - Bash\nDESCRIPTION: Commands to build the MicroPython cross-compiler\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/gettingstarted.rst#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ cd mpy-cross\n$ make\n```\n\n----------------------------------------\n\nTITLE: Extending Built-in Modules in Earlier MicroPython Versions\nDESCRIPTION: Shows how to extend a built-in module (e.g., 'time') with additional functionality in earlier versions of MicroPython using the 'u' prefix method.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/index.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom utime import *\n\ndef extra_method():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Hardware Abstraction Layer in C\nDESCRIPTION: This C header file (mphalport.h) provides a minimal implementation of the hardware abstraction layer for MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/porting.rst#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nstatic inline void mp_hal_set_interrupt_char(char c) {}\n```\n\n----------------------------------------\n\nTITLE: Install Package from GitLab\nDESCRIPTION: Installs package from specific branch of GitLab repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_46\n\nLANGUAGE: bash\nCODE:\n```\nmpremote mip install gitlab:org/repo@branch\n```\n\n----------------------------------------\n\nTITLE: Read Special Register in MicroPython\nDESCRIPTION: The mrs() instruction copies a special register (like IPSR or BASEPRI) to a general register. IPSR provides the exception number of an interrupt being processed or zero if none.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_misc.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nRd = special_reg\n```\n\n----------------------------------------\n\nTITLE: Getting RTC Information\nDESCRIPTION: This snippet retrieves information about the RTC's startup time and reset sources. It helps in diagnosing the RTC behavior during power cycles and resets.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.RTC.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nrtc.info()\n```\n\n----------------------------------------\n\nTITLE: Initializing Touch Sensor in Y-Position with MicroPython\nDESCRIPTION: Code example showing how to initialize the I2C bus differently when the LCD skin is in the Y-position. Uses I2C bus 2 instead of bus 1.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/lcd_skin.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> m = mpr121.MPR121(pyb.I2C(2, pyb.I2C.CONTROLLER))\n```\n\n----------------------------------------\n\nTITLE: Loading 16-bit Halfword from Memory in ARM Thumb Assembly\nDESCRIPTION: Loads a 16-bit halfword from memory at address [Rn + imm6] into register Rt. The loaded halfword is zero-extended to 32 bits. The imm6 offset is measured in bytes, allowing access to halfword-aligned values with a maximum offset of 31 halfwords.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_ldr.rst#2025-04-21_snippet_2\n\nLANGUAGE: assembly\nCODE:\n```\nldrh(Rt, [Rn, imm6])\n```\n\n----------------------------------------\n\nTITLE: Updating Thread Interruption in Python\nDESCRIPTION: This snippet shows an update to the _thread.interrupt_main function, allowing it to take an optional signal number (defaulting to signal.SIGINT).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n_thread.interrupt_main(signal_number)\nsignal.SIGINT\n```\n\n----------------------------------------\n\nTITLE: Aligning Code in Assembly\nDESCRIPTION: The align directive ensures that the following instruction or data is aligned to the specified byte boundary. Essential for ARM Thumb-2 instructions which must be 2-byte aligned.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_directives.rst#2025-04-21_snippet_3\n\nLANGUAGE: assembly\nCODE:\n```\nalign(2)\n```\n\n----------------------------------------\n\nTITLE: Importing Socket Module in MicroPython\nDESCRIPTION: This snippet demonstrates how to import the socket module in MicroPython, which is essential for network programming.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_tcp.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport socket\n```\n\n----------------------------------------\n\nTITLE: Delay and Timing Operations in MicroPython for i.MXRT\nDESCRIPTION: Code showing various timing operations available in the time module, including sleep functions at different time scales and measuring time intervals using ticks.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\ntime.sleep(1)           # sleep for 1 second\ntime.sleep_ms(500)      # sleep for 500 milliseconds\ntime.sleep_us(10)       # sleep for 10 microseconds\nstart = time.ticks_ms() # get millisecond counter\ndelta = time.ticks_diff(time.ticks_ms(), start) # compute time difference\n```\n\n----------------------------------------\n\nTITLE: Discovering Available Modules in MicroPython REPL\nDESCRIPTION: Shows how to list available built-in libraries that can be imported in MicroPython using the REPL.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nhelp('modules')\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Minimal Port for STM32 MCU\nDESCRIPTION: Commands to build the minimal MicroPython port for a Cortex-M CPU, specifically an STM32F4xx MCU. This includes cross-compilation and deployment to the MCU.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/minimal/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make CROSS=1\n```\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make CROSS=1 deploy\n```\n\n----------------------------------------\n\nTITLE: Configuring Mboot SD Card Support in mpconfigboard.h\nDESCRIPTION: Example configuration for enabling SD card support in Mboot. Defines address space, SD card address, and byte size.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/mboot/README.md#2025-04-21_snippet_4\n\nLANGUAGE: C\nCODE:\n```\n#define MBOOT_ADDRESS_SPACE_64BIT   (1)\n#define MBOOT_SDCARD_ADDR           (0x100000000ULL)\n#define MBOOT_SDCARD_BYTE_SIZE      (0x400000000ULL)\n```\n\n----------------------------------------\n\nTITLE: Installing PowerPC Cross-Compiler on Ubuntu\nDESCRIPTION: Command to install the powerpc64le-linux-gnu cross-compiler on Ubuntu 18.04.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/powerpc/README.md#2025-04-21_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ apt install gcc-powerpc64le-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Pushing an Item onto a Heap in Python\nDESCRIPTION: This function pushes an item onto a heap. It maintains the heap invariant, ensuring the first item of the list is always the smallest.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/heapq.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nheappush(heap, item)\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython for nRF52840 MDK USB Dongle\nDESCRIPTION: Command to build MicroPython for the nRF52840 MDK USB Dongle. It specifies the board type using the BOARD variable.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/nrf/boards/NRF52840_MDK_USB_DONGLE/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\nmake BOARD=nrf52840-mdk-usb-dongle\n```\n\n----------------------------------------\n\nTITLE: Retrieving Platform Information in MicroPython\nDESCRIPTION: Returns a string containing platform system name, MicroPython version, architecture, platform version, and libc details. The components are hyphen-delimited.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/platform.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nplatform()\n```\n\n----------------------------------------\n\nTITLE: Disabling Timer Callback in MicroPython\nDESCRIPTION: This snippet shows how to disable a timer callback in MicroPython by setting it to None.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/isr_rules.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntim4.callback(None)\n```\n\n----------------------------------------\n\nTITLE: Defining MicroPython Source Files for Zephyr Port\nDESCRIPTION: Specifies the source files for the Zephyr port of MicroPython, including port-specific files, shared files, and library files. These lists are used to compile the MicroPython interpreter for Zephyr.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/zephyr/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(MICROPY_SOURCE_PORT\n    main.c\n    help.c\n    machine_i2c.c\n    machine_spi.c\n    machine_pin.c\n    machine_timer.c\n    modbluetooth_zephyr.c\n    modsocket.c\n    modzephyr.c\n    modzsensor.c\n    mphalport.c\n    uart_core.c\n    zephyr_device.c\n    zephyr_storage.c\n    mpthreadport.c\n)\nlist(TRANSFORM MICROPY_SOURCE_PORT PREPEND ${MICROPY_PORT_DIR}/)\n\nset(MICROPY_SOURCE_SHARED\n    libc/printf.c\n    readline/readline.c\n    runtime/gchelper_generic.c\n    runtime/interrupt_char.c\n    runtime/mpirq.c\n    runtime/pyexec.c\n    runtime/stdout_helpers.c\n    timeutils/timeutils.c\n)\nlist(TRANSFORM MICROPY_SOURCE_SHARED PREPEND ${MICROPY_DIR}/shared/)\n\nset(MICROPY_SOURCE_LIB\n    oofatfs/ff.c\n    oofatfs/ffunicode.c\n    littlefs/lfs1.c\n    littlefs/lfs1_util.c\n    littlefs/lfs2.c\n    littlefs/lfs2_util.c\n)\nlist(TRANSFORM MICROPY_SOURCE_LIB PREPEND ${MICROPY_DIR}/lib/)\n```\n\n----------------------------------------\n\nTITLE: Installing STM32 Dependencies - Bash\nDESCRIPTION: Command to install ARM cross-compiler for STM32 port development\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/gettingstarted.rst#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt-get install gcc-arm-none-eabi libnewlib-arm-none-eabi\n```\n\n----------------------------------------\n\nTITLE: Initializing I2S in MicroPython (MIMXRT10xx_DEV)\nDESCRIPTION: This code snippet shows an example of initializing and using the I2S (Inter-IC Sound) interface in MicroPython for a MIMXRT10xx_DEV board. It involves setting up the I2S peripheral for reception mode (RX) alongside a WM8960 codec via I2C, then reading audio data from the I2S device into a buffer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import I2S, I2C, Pin\nimport wm8960\n\ni2c=I2C(0)\n\nwm=wm8960.WM8960(i2c, sample_rate=SAMPLE_RATE_IN_HZ,\n    adc_sync=wm8960.sync_dac,\n    swap=wm8960.swap_input)\n\ni2s = I2S(1, sck=Pin(\"SCK_TX\"), ws=Pin(\"WS_TX\"), sd=Pin(\"SD_RX\"),\n    mck=Pin(\"MCK),mode=I2S.RX, bts=16,format=I2S.MONO,\n    rate=32000,ibuf=10000)\ni2s.readinto(buf)          # fill buffer with audio samples from I2S device\n```\n\n----------------------------------------\n\nTITLE: Building and Running MicroPython Port\nDESCRIPTION: These bash commands demonstrate how to build and run the MicroPython port, including setting up the terminal for raw mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/porting.rst#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ stty raw opost -echo\n$ ./build/firmware.elf\n```\n\n----------------------------------------\n\nTITLE: Python REPL - Basic GC Module Usage\nDESCRIPTION: Example showing how to import and use the garbage collector module in MicroPython REPL.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/library.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n>>> import gc\n>>> gc.enable()\n>>>\n```\n\n----------------------------------------\n\nTITLE: Retrieving MicroPython libc Version Information\nDESCRIPTION: Returns a tuple containing the name of the linked libc and its version as strings.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/platform.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nlibc_ver()\n```\n\n----------------------------------------\n\nTITLE: USB Endpoint Stall Control Method\nDESCRIPTION: Method to get or set the STALL state of a device endpoint. Takes endpoint number and optional stall boolean parameter. Returns current stall state before any changes. Raises OSError if device is not active.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.USBDevice.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nUSBDevice.stall(self, ep, [stall] /)\n```\n\n----------------------------------------\n\nTITLE: Importing the LCD160CR Driver in MicroPython\nDESCRIPTION: Demonstrates how to import the LCD160CR module that provides the driver for controlling the LCD160CR display.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/lcd160cr_skin.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport lcd160cr\n```\n\n----------------------------------------\n\nTITLE: Converting Between Integer and Float Types in ARM Assembly\nDESCRIPTION: These instructions convert values between 32-bit integer and 32-bit floating-point representations. They provide the fundamental type conversion needed when processing mixed data types in assembly code.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_float.rst#2025-04-21_snippet_4\n\nLANGUAGE: assembly\nCODE:\n```\nvcvt_f32_s32(Sd, Sm) \"Sd = float(Sm)\"\nvcvt_s32_f32(Sd, Sm) \"Sd = int(Sm)\"\n```\n\n----------------------------------------\n\nTITLE: Adding Platform Function for OS Release Information\nDESCRIPTION: This snippet introduces a new function platform.freedesktop_os_release() to retrieve operating system identification from the freedesktop.org os-release standard file.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nplatform.freedesktop_os_release()\n```\n\n----------------------------------------\n\nTITLE: Enable Interrupts in MicroPython\nDESCRIPTION: The cpsie() function clears the Priority Mask Register to enable interrupts. Currently only partially implemented and ignores the flags argument.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_misc.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncpsie(flags)\n```\n\n----------------------------------------\n\nTITLE: Customizing APA102 Color Order in MicroPython\nDESCRIPTION: This code shows how to customize the color order for APA102C LEDs, which have a different RGB arrangement. It changes the order to (Red, Blue, Green, Brightness).\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/apa102.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> strip.ORDER = (0, 2, 1, 3)\n```\n\n----------------------------------------\n\nTITLE: Generating MicroPython PDF Manual\nDESCRIPTION: Command to generate a PDF version of the MicroPython manual. This requires a complete LaTeX installation with various extensions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake latexpdf\n```\n\n----------------------------------------\n\nTITLE: Compiled MicroPython Constants\nDESCRIPTION: Demonstrates how MicroPython compiles and optimizes const() declarations into direct values, eliminating variable storage overhead.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/optimizations.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nX = 1\nfoo(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Building Unix Port - Bash\nDESCRIPTION: Commands to build the Unix port of MicroPython\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/gettingstarted.rst#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ cd ports/unix\n$ make submodules\n$ make\n```\n\n----------------------------------------\n\nTITLE: Setting MicroPython and ESP32 Port Directories in CMake\nDESCRIPTION: This snippet sets the base MicroPython directory and the ESP32 port directory if they are not already defined. It then includes the common ESP32 CMake configuration file.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/main/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Set location of base MicroPython directory.\nif(NOT MICROPY_DIR)\n    get_filename_component(MICROPY_DIR ${CMAKE_CURRENT_LIST_DIR}/../../.. ABSOLUTE)\nendif()\n\n# Set location of the ESP32 port directory.\nif(NOT MICROPY_PORT_DIR)\n    get_filename_component(MICROPY_PORT_DIR ${MICROPY_DIR}/ports/esp32 ABSOLUTE)\nendif()\n\ninclude(${MICROPY_PORT_DIR}/esp32_common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Removing Files from MicroPython Filesystem to Recover from Soft Bricking\nDESCRIPTION: Commands to remove problematic files from the MicroPython filesystem when recovering from a soft-bricked state. The example shows removing main.py and listing remaining files.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/reset_boot.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport os\nos.remove('main.py')\n```\n\nLANGUAGE: python\nCODE:\n```\nimport os\nos.listdir()\n```\n\n----------------------------------------\n\nTITLE: Reading Blocks from Flash in MicroPython\nDESCRIPTION: Methods for reading blocks from the flash device. These methods implement the simple and extended block protocol defined by vfs.AbstractBlockDev.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Flash.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nFlash.readblocks(block_num, buf)\nFlash.readblocks(block_num, buf, offset)\n```\n\n----------------------------------------\n\nTITLE: Running Perfbench on Target Device\nDESCRIPTION: Command for running performance benchmarks on a firmware target using pyboard.py. Parameters include port specification, CPU frequency (N=168MHz), and heap size (M=100KB).\nSOURCE: https://github.com/micropython/micropython/blob/master/tests/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./run-perfbench.py -p -d /dev/ttyACM0 168 100\n```\n\n----------------------------------------\n\nTITLE: Clearing and Disabling CAN Filters in Python\nDESCRIPTION: This method clears and disables a specific filter bank on a CAN controller. It supports both classic CAN and CAN FD, adjusting based on the 'extframe' parameter to target either extended or standard filters.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.CAN.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n\n.. method:: CAN.clearfilter(bank, extframe=False)\n\n   Clear and disables a filter bank:\n\n   - *bank* is the classic CAN controller filter bank, or CAN FD filter index, to clear.\n   - *extframe* For CAN FD controllers, if True, clear an extended filter (configured with extframe=True),\n     otherwise the clear a standard identifier (configured with extframe=False).\n\n```\n\n----------------------------------------\n\nTITLE: Disable Interrupts in MicroPython\nDESCRIPTION: The cpsid() function sets the Priority Mask Register to disable interrupts. Currently only partially implemented and ignores the flags argument.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_misc.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncpsid(flags)\n```\n\n----------------------------------------\n\nTITLE: Defining Documentation Structure in Sphinx RST\nDESCRIPTION: A toctree directive that defines the documentation structure for MicroPython, including library documentation, reference materials, board-specific guides, and development information.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n\n    library/index.rst\n    reference/index.rst\n    genrst/index.rst\n    develop/index.rst\n    license.rst\n    pyboard/quickref.rst\n    esp8266/quickref.rst\n    esp32/quickref.rst\n    rp2/quickref.rst\n    mimxrt/quickref.rst\n    wipy/quickref.rst\n    unix/quickref.rst\n    zephyr/quickref.rst\n    renesas-ra/quickref.rst\n    samd/quickref.rst\n```\n\n----------------------------------------\n\nTITLE: Accessing Match Object Groups in Python Regular Expressions\nDESCRIPTION: Demonstrates the new ability to access match object groups using indexing syntax, which is equivalent to using the group() method. This feature allows for more concise code when working with regular expression matches.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_36.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nmo['name']  # Equivalent to mo.group('name')\n```\n\n----------------------------------------\n\nTITLE: Using Branch Instructions with Labels\nDESCRIPTION: Example showing how to use the branch instruction to jump to a previously defined label in the code.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_directives.rst#2025-04-21_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\nb(INNER1)\n```\n\n----------------------------------------\n\nTITLE: Basic LCD160CR Display Usage Example\nDESCRIPTION: Demonstrates initialization and basic usage of the LCD160CR display including orientation setting, text positioning, color configuration and touch detection.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport lcd160cr\n\nlcd = lcd160cr.LCD160CR('X')\nlcd.set_orient(lcd160cr.PORTRAIT)\nlcd.set_pos(0, 0)\nlcd.set_text_color(lcd.rgb(255, 0, 0), lcd.rgb(0, 0, 0))\nlcd.set_font(1)\nlcd.write('Hello MicroPython!')\nprint('touch:', lcd.get_touch())\n```\n\n----------------------------------------\n\nTITLE: Configuring WLAN as Station in MicroPython\nDESCRIPTION: This code snippet configures the WLAN network card as a station (STA) on a WiPy device.  It imports the `WLAN` class from the `network` module and initializes a `WLAN` object with the `mode` parameter set to `WLAN.STA`. This is a prerequisite for connecting to a network.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/wlan.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom network import WLAN\nwlan = WLAN(mode=WLAN.STA)\n```\n\n----------------------------------------\n\nTITLE: Wait for Interrupt in MicroPython\nDESCRIPTION: The wfi() instruction suspends execution in a low power state until an interrupt occurs.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_misc.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nwfi()\n```\n\n----------------------------------------\n\nTITLE: jQuery Sphinx Extension Dependency\nDESCRIPTION: Includes specific version of jQuery extension for Sphinx documentation, ensuring compatibility with documentation rendering\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/requirements.txt#2025-04-21_snippet_1\n\nLANGUAGE: requirements\nCODE:\n```\nsphinxcontrib.jquery==4.1\n```\n\n----------------------------------------\n\nTITLE: MicroPython movwt Pseudo-instruction in ARM Assembly\nDESCRIPTION: The movwt pseudo-instruction allows loading a 32-bit value into a register. The MicroPython assembler implements this by emitting a movw followed by a movt instruction.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_mov.rst#2025-04-21_snippet_1\n\nLANGUAGE: ARM Assembly\nCODE:\n```\nmovwt(Rd, imm32) \"Rd = imm32\"\n```\n\n----------------------------------------\n\nTITLE: Control Scrolling - LCD160CR Method\nDESCRIPTION: Enables or disables global scrolling functionality for all window regions.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.set_scroll(on)\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Tool\nDESCRIPTION: Commands to install the pre-commit tool on various systems. This tool is used to automatically check code formatting and commit message conventions.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\napt install pre-commit       # Ubuntu, Debian\npacman -Sy python-precommit  # Arch Linux\nbrew install pre-commit      # Brew\npip install pre-commit       # PyPI\n```\n\n----------------------------------------\n\nTITLE: Checking Python Interpreter Shutdown State\nDESCRIPTION: Shows the usage of is_finalizing() function to check if the Python interpreter is in the process of shutting down.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_35.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nis_finalizing()\n```\n\n----------------------------------------\n\nTITLE: Multiple File Copy with REPL\nDESCRIPTION: Copies multiple files to device and starts REPL session.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\nmpremote cp a.py b.py : + repl\n```\n\n----------------------------------------\n\nTITLE: Handle User Frozen Manifest\nDESCRIPTION: Saves the user-defined frozen manifest file path and overrides the default manifest if a user-defined one is provided. If no user-defined manifest is given, then it uses the default manifest in the boards directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(MICROPY_USER_FROZEN_MANIFEST ${MICROPY_FROZEN_MANIFEST})\n\nif (MICROPY_USER_FROZEN_MANIFEST)\n    set(MICROPY_FROZEN_MANIFEST ${MICROPY_USER_FROZEN_MANIFEST})\nelseif (NOT MICROPY_FROZEN_MANIFEST)\n    set(MICROPY_FROZEN_MANIFEST ${CMAKE_CURRENT_LIST_DIR}/boards/manifest.py)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Recursive Directory Copy\nDESCRIPTION: Recursively copies local directory to device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\nmpremote cp -r dir/ :\n```\n\n----------------------------------------\n\nTITLE: Creating Makefile for MicroPython Port\nDESCRIPTION: This Makefile sets up the build environment for the MicroPython port, including source files, object files, and build targets.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/porting.rst#2025-04-21_snippet_2\n\nLANGUAGE: makefile\nCODE:\n```\n# Include the core environment definitions; this will set $(TOP).\ninclude ../../py/mkenv.mk\n\n# Include py core make definitions.\ninclude $(TOP)/py/py.mk\ninclude $(TOP)/extmod/extmod.mk\n\n# Set CFLAGS and libraries.\nCFLAGS += -I. -I$(BUILD) -I$(TOP)\nLIBS += -lm\n\n# Define the required source files.\nSRC_C = \\\n    main.c \\\n    mphalport.c \\\n    shared/readline/readline.c \\\n    shared/runtime/gchelper_generic.c \\\n    shared/runtime/pyexec.c \\\n    shared/runtime/stdout_helpers.c \\\n\n# Define source files containung qstrs.\nSRC_QSTR += shared/readline/readline.c shared/runtime/pyexec.c\n\n# Define the required object files.\nOBJ = $(PY_CORE_O) $(addprefix $(BUILD)/, $(SRC_C:.c=.o))\n\n# Define the top-level target, the main firmware.\nall: $(BUILD)/firmware.elf\n\n# Define how to build the firmware.\n$(BUILD)/firmware.elf: $(OBJ)\n\t$(ECHO) \"LINK $@\"\n\t$(Q)$(CC) $(LDFLAGS) -o $@ $^ $(LIBS)\n\t$(Q)$(SIZE) $@\n\n# Include remaining core make rules.\ninclude $(TOP)/py/mkrules.mk\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project for MicroPython on Zephyr\nDESCRIPTION: Sets up the CMake project for MicroPython, specifying the minimum CMake version, finding the Zephyr package, and defining project variables. It also includes necessary CMake files for MicroPython core and extmod.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/zephyr/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.20.0)\n\nfind_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})\nproject(micropython)\n\nset(MICROPY_PORT_DIR    ${CMAKE_CURRENT_SOURCE_DIR})\nset(MICROPY_DIR         ${MICROPY_PORT_DIR}/../..)\nset(MICROPY_TARGET      micropython)\n\ninclude(${MICROPY_DIR}/py/py.cmake)\ninclude(${MICROPY_DIR}/extmod/extmod.cmake)\n```\n\n----------------------------------------\n\nTITLE: Configuring OS Debug Output for ESP8266 in MicroPython\nDESCRIPTION: Function to change the level of OS serial debug log messages on ESP8266. It enables or disables debug output on a specified UART peripheral.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nosdebug(uart_no)\n```\n\n----------------------------------------\n\nTITLE: Running Perfbench on Host System\nDESCRIPTION: Command for running performance benchmarks on the host system (unix/Windows) with N=2000 (CPU frequency approximation) and M=10000 (heap size in KB).\nSOURCE: https://github.com/micropython/micropython/blob/master/tests/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./run-perfbench.py 2000 10000\n```\n\n----------------------------------------\n\nTITLE: Basic Python Calculations in REPL\nDESCRIPTION: Examples of basic Python calculations that can be performed in the REPL, demonstrating integer addition, division, and exponentiation operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/repl.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> 1 + 2\n3\n>>> 1 / 2\n0.5\n>>> 12**34\n4922235242952026704037113243122008064\n```\n\n----------------------------------------\n\nTITLE: Adding New OS Constants in Python\nDESCRIPTION: This snippet adds new constants to the os module for macOS, including O_EVTONLY, O_FSYNC, O_SYMLINK, and O_NOFOLLOW_ANY.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nos.O_EVTONLY\nos.O_FSYNC\nos.O_SYMLINK\nos.O_NOFOLLOW_ANY\n```\n\n----------------------------------------\n\nTITLE: Checking MicroPython firmware integrity\nDESCRIPTION: Python code to check the integrity of the installed MicroPython firmware on an ESP8266 device from within the MicroPython REPL.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/intro.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nimport esp\nesp.check_fw()\n```\n\n----------------------------------------\n\nTITLE: ARM Register to Memory Store Operations\nDESCRIPTION: These ARM assembly instructions store register values to memory with different widths. str stores a full 32-bit word, strb stores a single byte (bits 0-7), and strh stores a 16-bit half word (bits 0-15). Each instruction uses different immediate offset widths, measured in bytes.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_str.rst#2025-04-21_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\nstr(Rt, [Rn, imm7]) [Rn + imm7] = Rt\n```\n\nLANGUAGE: assembly\nCODE:\n```\nstrb(Rt, [Rn, imm5]) [Rn + imm5] = Rt\n```\n\nLANGUAGE: assembly\nCODE:\n```\nstrh(Rt, [Rn, imm6]) [Rn + imm6] = Rt\n```\n\n----------------------------------------\n\nTITLE: Deinitializing Timer in MicroPython\nDESCRIPTION: This snippet defines the method to deinitialize the timer, which stops the timer and disables associated callbacks. It ensures that the timer is stopped and cleans up resources associated with the timer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Timer.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n.. method:: Timer.deinit()\n\n   Deinitialises the timer.\n\n   Disables the callback (and the associated irq).\n   Disables any channel callbacks (and the associated irq).\n   Stops the timer, and disables the timer peripheral.\n```\n\n----------------------------------------\n\nTITLE: Using the add1 Feature in MicroPython REPL\nDESCRIPTION: Example of using the hypothetical 'add1' feature in the MicroPython REPL. The feature takes an integer argument and adds 1 to it.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n>>> add1 3\n4\n>>>\n```\n\n----------------------------------------\n\nTITLE: Executing Blynk Synchronization Example\nDESCRIPTION: Runs a synchronization example script for Blynk IoT platform using MicroPython's execfile function on WiPy device\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/tutorial/blynk.rst#2025-04-21_snippet_0\n\nLANGUAGE: micropython\nCODE:\n```\n>>> execfile('sync_virtual.py')\n```\n\n----------------------------------------\n\nTITLE: Set Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the build process. Ensures that the CMake version is at least 3.12.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.12)\n```\n\n----------------------------------------\n\nTITLE: Building and Deploying MicroPython Firmware with mboot Support\nDESCRIPTION: Command to build and deploy MicroPython firmware that's compatible with the mboot bootloader. This command should be executed after the board has been put in mboot mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/mboot/README.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ make BOARD=PYBV10 USE_MBOOT=1 clean all deploy\n```\n\n----------------------------------------\n\nTITLE: Receiving and Displaying Data from TCP Server in MicroPython\nDESCRIPTION: This code shows how to continuously receive data from a TCP server and display it. It's used in the context of the Star Wars Asciimation example.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_tcp.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nwhile True:\n    data = s.recv(500)\n    print(str(data, 'utf8'), end='')\n```\n\n----------------------------------------\n\nTITLE: Checking Deep Sleep Reset Cause in MicroPython\nDESCRIPTION: Code to detect if the device has woken up from deep sleep or underwent a regular power-on/reset. Useful for implementing different behavior based on reset cause.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/powerctrl.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nif machine.reset_cause() == machine.DEEPSLEEP_RESET:\n    print('woke from a deep sleep')\nelse:\n    print('power on or hard reset')\n```\n\n----------------------------------------\n\nTITLE: Accessing Monotonic Time in MicroPython\nDESCRIPTION: Illustrates the availability of the monotonic() function for obtaining monotonic time, which is now always accessible in MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_35.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmonotonic()\n```\n\n----------------------------------------\n\nTITLE: Executing Function and Soft Reset\nDESCRIPTION: Shows how to execute a function to get program state information followed by a soft reset.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\nmpremote resume exec \"print_state_info()\" soft-reset\n```\n\n----------------------------------------\n\nTITLE: Building Firmware with Custom Manifest (Bash)\nDESCRIPTION: Command to build MicroPython firmware with a custom manifest file. The command specifies the board and path to the manifest file.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/manifest.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ make BOARD=MYBOARD FROZEN_MANIFEST=/path/to/my/project/manifest.py\n```\n\n----------------------------------------\n\nTITLE: Directory Unmounting\nDESCRIPTION: Command to unmount previously mounted local directory from device\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote umount\n```\n\n----------------------------------------\n\nTITLE: List Manipulation Functions in MicroPython C API\nDESCRIPTION: Core list manipulation functions from obj.h that demonstrate the public API interface. These functions handle creation, modification, and data retrieval for MicroPython list objects.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/publiccapi.rst#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nmp_obj_t mp_obj_new_list(size_t n, mp_obj_t *items);\nmp_obj_t mp_obj_list_append(mp_obj_t self_in, mp_obj_t arg);\nmp_obj_t mp_obj_list_remove(mp_obj_t self_in, mp_obj_t value);\nvoid mp_obj_list_get(mp_obj_t self_in, size_t *len, mp_obj_t **items);\n```\n\n----------------------------------------\n\nTITLE: Prefixing LittleFS Files with Python Script\nDESCRIPTION: This Python script prefixes LittleFS files to distinguish between different versions (lfs1, lfs2). It's executed within the LittleFS repository and generates new files with the specified prefix.\nSOURCE: https://github.com/micropython/micropython/blob/master/lib/littlefs/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npython2 ./scripts/prefix.py lfs1\n```\n\nLANGUAGE: python\nCODE:\n```\npython2 ./scripts/prefix.py lfs2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating f-string self-documenting expressions in Python 3.8\nDESCRIPTION: Shows the new f-string feature in Python 3.8 that supports '=' for self-documenting expressions and debugging. This allows developers to easily print variable names alongside their values.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_38.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = 10\ny = 20\nprint(f\"{x=} {y=}\")\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling MicroPython PowerPC Port\nDESCRIPTION: Command to cross-compile the MicroPython PowerPC port using a specified compiler prefix.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/powerpc/README.md#2025-04-21_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$ make CROSS_COMPILE=<compiler prefix>\n```\n\n----------------------------------------\n\nTITLE: Running Specific Test Sets\nDESCRIPTION: Commands showing how to run specific test directories or patterns of test files.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/writingtests.rst#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ ./run-tests.py -d basics\n$ ./run-tests.py float/builtin*.py\n```\n\n----------------------------------------\n\nTITLE: Second and Third Compiler Passes in MicroPython\nDESCRIPTION: Implementation of the second and third compiler passes that compute the Python stack size and code size for the bytecode or native code.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nfor (scope_t *s = comp->scope_head; s != NULL && comp->compile_error == MP_OBJ_NULL; s = s->next) {\n    ...\n\n    // Pass 2: Compute the Python stack size.\n    compile_scope(comp, s, MP_PASS_STACK_SIZE);\n\n    // Pass 3: Compute the code size.\n    if (comp->compile_error == MP_OBJ_NULL) {\n        compile_scope(comp, s, MP_PASS_CODE_SIZE);\n    }\n\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Flash Object for USB Mass Storage in MicroPython\nDESCRIPTION: Creates a Flash object representing the flash device presented to the USB mass storage interface. This constructor is deprecated and will be removed in a future version of MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Flash.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nFlash()\n```\n\n----------------------------------------\n\nTITLE: Update Scroll Window Parameter - LCD160CR Method\nDESCRIPTION: Updates a single parameter of a scrolling window configuration.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.set_scroll_win_param(win, param, value)\n```\n\n----------------------------------------\n\nTITLE: Installing with Implicit package.json in MicroPython\nDESCRIPTION: Examples showing how mip will automatically look for a package.json file when a directory URL is provided.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/packages.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> mip.install(\"http://example.com/x/\")\n>>> mip.install(\"github:org/repo\")  # Uses default branch of that repo\n>>> mip.install(\"github:org/repo\", version=\"branch-or-tag\")\n>>> mip.install(\"gitlab:org/repo\")  # Uses default branch of that repo\n>>> mip.install(\"gitlab:org/repo\", version=\"branch-or-tag\")\n```\n\n----------------------------------------\n\nTITLE: Creating C Module Makefile Fragment\nDESCRIPTION: Example showing how to structure a Makefile fragment (micropython.mk) for a C module, including source file declarations and compiler flags.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/cmodules.rst#2025-04-21_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\nSRC_USERMOD_C += $(EXAMPLE_MOD_DIR)/modexample.c\nSRC_USERMOD_LIB_C += $(EXAMPLE_MOD_DIR)/utils/algorithm.c\n```\n\n----------------------------------------\n\nTITLE: Configuring Board-Specific Compile Definitions\nDESCRIPTION: Sets board-specific compile definitions for RP2040 and RP2350 variants.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/CMakeLists.txt#2025-04-21_snippet_20\n\nLANGUAGE: cmake\nCODE:\n```\nif(PICO_RP2040)\n    target_compile_definitions(${MICROPY_TARGET} PRIVATE\n        PICO_RP2040_USB_DEVICE_ENUMERATION_FIX=1\n    )\nelseif(PICO_RP2350)\n    target_compile_definitions(${MICROPY_TARGET} PRIVATE\n        PICO_EMBED_XIP_SETUP=1 # to put flash into continuous read mode\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Generating mp_mbedtls_errors.c with a Shell Script\nDESCRIPTION: This shell script automates the process of generating the mp_mbedtls_errors.c source file using the modified error format template, ensuring that it works correctly with the current version of Mbedtls error defines.\nSOURCE: https://github.com/micropython/micropython/blob/master/lib/mbedtls_errors/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n#!/bin/sh\\necho \"Generating mp_mbedtls_errors.c...\"\\nperl generate_errors.pl > mp_mbedtls_errors.c\\necho \"Done generating mp_mbedtls_errors.c\"\n```\n\n----------------------------------------\n\nTITLE: MIMXRT USDHC Pin Configuration Example\nDESCRIPTION: C macro definition example for configuring USDHC1 pins on MIMXRT platform for SD card access.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.SDCard.rst#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#define MICROPY_USDHC1 \\\n    { \\\n          .cmd   = { GPIO_SD_B0_02_USDHC1_CMD}, \\\n          .clk   = { GPIO_SD_B0_03_USDHC1_CLK }, \\\n          .cd_b  = { GPIO_SD_B0_06_USDHC1_CD_B },\\\n          .data0 = { GPIO_SD_B0_04_USDHC1_DATA0 },\\\n          .data1 = { GPIO_SD_B0_05_USDHC1_DATA1 },\\\n          .data2 = { GPIO_SD_B0_00_USDHC1_DATA2 },\\\n          .data3 = { GPIO_SD_B0_01_USDHC1_DATA3 },\\\n    }\n```\n\n----------------------------------------\n\nTITLE: Adding New System Attributes in Python\nDESCRIPTION: This snippet adds new attributes to the sys module: orig_argv for original command line arguments, and stdlib_module_names for the list of standard library module names.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nsys.orig_argv\nsys.stdlib_module_names\n```\n\n----------------------------------------\n\nTITLE: Reversed iteration of dictionaries in Python 3.8\nDESCRIPTION: Shows how to iterate over a dictionary in reversed insertion order using the reversed() function, a new feature in Python 3.8. This allows for more flexible dictionary traversal.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_38.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\nfor key in reversed(my_dict):\n    print(key, my_dict[key])\n```\n\n----------------------------------------\n\nTITLE: Creating SD Card Skip File in MicroPython\nDESCRIPTION: Example of a file path that can be created to force the PyBoard to skip using the SD card during boot and always use the internal filesystem instead.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/general.rst#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n/flash/SKIPSD\n```\n\n----------------------------------------\n\nTITLE: Display File Contents\nDESCRIPTION: Shows contents of boot.py file from device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_37\n\nLANGUAGE: bash\nCODE:\n```\nmpremote cat boot.py\n```\n\n----------------------------------------\n\nTITLE: Connecting to a device with mpremote\nDESCRIPTION: Command to connect to a specific MicroPython device. The device parameter can be 'list', 'auto', 'id:<serial>', 'port:<path>', an RFC2217 URL, or a direct device path.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote connect <device>\n```\n\n----------------------------------------\n\nTITLE: Creating Directory for New MicroPython Port\nDESCRIPTION: This bash command creates a new directory for the MicroPython port in the ports directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/porting.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cd ports\n$ mkdir example_port\n```\n\n----------------------------------------\n\nTITLE: Basic Stack Operation Syntax in MicroPython\nDESCRIPTION: The basic syntax for stack operations in MicroPython, showing the general form for pushing registers onto the stack and popping them back.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_stack.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npush({regset}) # Push a set of registers onto the stack\npop({regset}) # Restore a set of registers from the stack\n```\n\n----------------------------------------\n\nTITLE: Managing USB Device State - Python\nDESCRIPTION: Method for controlling the active state of a runtime USB device, allowing enable/disable of the device detection by the host.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.USBDevice.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nUSBDevice.active(self, [value] /)\n```\n\n----------------------------------------\n\nTITLE: Installing LaTeX Dependencies for PDF Generation on Debian/Ubuntu\nDESCRIPTION: Command to install necessary LaTeX packages on Debian/Ubuntu systems for generating the MicroPython PDF manual. This is a large download (1GB+) and includes various LaTeX extensions and fonts.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\napt install texlive-latex-recommended texlive-latex-extra texlive-xetex texlive-fonts-extra cm-super xindy\n```\n\n----------------------------------------\n\nTITLE: Running Tests - Bash\nDESCRIPTION: Commands to run MicroPython test suite on Unix port and connected devices\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/gettingstarted.rst#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ cd ports/unix\n$ make test\n\n$ cd tests\n$ ./run-tests.py -t /dev/ttyACM0\n```\n\n----------------------------------------\n\nTITLE: Performing I/O Control Operations on Flash in MicroPython\nDESCRIPTION: Method for performing I/O control operations on the flash device. This method implements the simple and extended block protocol defined by vfs.AbstractBlockDev.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.Flash.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nFlash.ioctl(cmd, arg)\n```\n\n----------------------------------------\n\nTITLE: Evaluating Multiple Expressions on Different Devices\nDESCRIPTION: Demonstrates evaluating expressions 1/2 and 3/4 on two different MicroPython devices connected via /dev/ttyACM0 and /dev/ttyACM1.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\nmpremote a0 eval 1/2 a1 eval 3/4\n```\n\n----------------------------------------\n\nTITLE: Implementing Linear Probing for Hash Lookups in MicroPython\nDESCRIPTION: This code snippet shows how MicroPython implements item lookups in hash tables when collisions occur. It uses linear probing to sequentially search for items, and supports rehashing the table when it becomes too full. The code handles both search operations and adding new items when requested.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/maps.rst#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n// not yet found, keep searching in this table\npos = (pos + 1) % set->alloc;\n\nif (pos == start_pos) {\n    // search got back to starting position, so index is not in table\n    if (lookup_kind & MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {\n        if (avail_slot != NULL) {\n            // there was an available slot, so use that\n            set->used++;\n            *avail_slot = index;\n            return index;\n        } else {\n            // not enough room in table, rehash it\n            mp_set_rehash(set);\n            // restart the search for the new element\n            start_pos = pos = hash % set->alloc;\n        }\n    }\n} else {\n     return MP_OBJ_NULL;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Register Move Operations in ARM Assembly\nDESCRIPTION: These instructions move data between registers or load immediate values into registers. Immediate values are zero-extended to 32 bits, so mov(R0, 0xff) will set R0 to 255.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_mov.rst#2025-04-21_snippet_0\n\nLANGUAGE: ARM Assembly\nCODE:\n```\nmov(Rd, imm8) \"Rd = imm8\"\nmov(Rd, Rn) \"Rd = Rn\"\nmovw(Rd, imm16) \"Rd = imm16\"\nmovt(Rd, imm16) \"Rd = (Rd & 0xffff) | (imm16 << 16)\"\n```\n\n----------------------------------------\n\nTITLE: Installing Protocol Buffer Compiler on Debian/Ubuntu\nDESCRIPTION: This snippet shows the command to install the protocol buffer compiler (protoc) on Debian/Ubuntu systems. Protoc is a required dependency for building the esp-hosted driver.\nSOURCE: https://github.com/micropython/micropython/blob/master/drivers/esp-hosted/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n\"sudo apt-get install protobuf-compiler\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Makefile for MEMZIP Integration\nDESCRIPTION: Makefile configuration that sets up source files, build objects, and build rules for integrating MEMZIP into a MicroPython project. It includes source file declarations, object file specifications, and a rule to generate C files from zip archives.\nSOURCE: https://github.com/micropython/micropython/blob/master/shared/memzip/README.md#2025-04-21_snippet_0\n\nLANGUAGE: makefile\nCODE:\n```\nSRC_C += \\\n    shared/memzip/import.c \\\n    shared/memzip/lexermemzip.c \\\n    shared/memzip/memzip.c \\\n\nOBJ += $(BUILD)/memzip-files.o\n\nMAKE_MEMZIP = ../shared/memzip/make-memzip.py\n\n$(BUILD)/memzip-files.c: $(shell find ${MEMZIP_DIR} -type f)\n    @$(ECHO) \"Creating $@\"\n    $(Q)$(PYTHON) $(MAKE_MEMZIP) --zip-file $(BUILD)/memzip-files.zip --c-file $@ $(MEMZIP_DIR)\n```\n\n----------------------------------------\n\nTITLE: Correct Positional Arguments Usage\nDESCRIPTION: Example of code that works in both CPython and MicroPython using positional arguments.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/modules_preamble.txt#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport socket\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n```\n\n----------------------------------------\n\nTITLE: Using asyncio.run() in Python 3.8\nDESCRIPTION: Demonstrates the use of asyncio.run(), which has been promoted from provisional to stable API in Python 3.8. This function is used to run an asynchronous function and manage the event loop.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_38.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nasync def main():\n    print('Hello')\n    await asyncio.sleep(1)\n    print('World')\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Deprecating Pure-Python Fallback for hashlib.pbkdf2_hmac\nDESCRIPTION: The pure-Python implementation of pbkdf2_hmac in the hashlib module is being deprecated. In future versions, PBKDF2-HMAC will only be available when Python is built with OpenSSL support.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nhashlib.pbkdf2_hmac()\n```\n\n----------------------------------------\n\nTITLE: Block Memory Layout Example\nDESCRIPTION: Illustrates the memory layout of object blocks in MicroPython's heap, showing the structure with type header and object items sections.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/memorymgt.rst#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n    +++++++++++\n    +         +\n    + type    + object header\n    +         +\n    +++++++++++\n    +         + object items\n    +         +\n    +         +\n    +++++++++++\n```\n\n----------------------------------------\n\nTITLE: Disconnecting from a device\nDESCRIPTION: Command to disconnect from the currently connected MicroPython device, which also enables auto-soft-reset for subsequent connections.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ mpremote disconnect\n```\n\n----------------------------------------\n\nTITLE: Installing mpremote with pipx\nDESCRIPTION: Command to install the mpremote tool using pipx, which creates an isolated environment for the application.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ pipx install mpremote\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for C Module\nDESCRIPTION: CMake configuration example showing how to set up an INTERFACE library for a MicroPython C module and link it to the usermod target.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/cmodules.rst#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(usermod_cexample INTERFACE)\n\ntarget_sources(usermod_cexample INTERFACE\n    ${CMAKE_CURRENT_LIST_DIR}/examplemodule.c\n)\n\ntarget_include_directories(usermod_cexample INTERFACE\n    ${CMAKE_CURRENT_LIST_DIR}\n)\n\ntarget_link_libraries(usermod INTERFACE usermod_cexample)\n```\n\n----------------------------------------\n\nTITLE: Build Command for Dynamic Native Modules\nDESCRIPTION: Example command to compile a dynamic native module for a specific architecture and copy it to a MicroPython device\nSOURCE: https://github.com/micropython/micropython/blob/master/examples/natmod/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ cd features0\n$ make ARCH=armv7m\n$ mpremote cp features0.mpy :\n```\n\n----------------------------------------\n\nTITLE: USB Device Built-in Constants\nDESCRIPTION: Constants representing built-in USB descriptor configurations including NONE, DEFAULT, CDC, MSC, and CDC_MSC. Each constant contains fields for interface maximum, endpoint maximum, string maximum, and descriptor data.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/machine.USBDevice.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nUSBDevice.BUILTIN_NONE\nUSBDevice.BUILTIN_DEFAULT\nUSBDevice.BUILTIN_CDC\nUSBDevice.BUILTIN_MSC\nUSBDevice.BUILTIN_CDC_MSC\n```\n\n----------------------------------------\n\nTITLE: No Operation Instruction in MicroPython\nDESCRIPTION: The nop() instruction performs no operation and is implemented as a Python pass statement.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_misc.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npass\n```\n\n----------------------------------------\n\nTITLE: Installing Sphinx and RTD Theme for MicroPython Documentation\nDESCRIPTION: Commands to install Sphinx and the ReadTheDocs theme using pip, preferably in a virtual environment. These are prerequisites for building the MicroPython documentation locally.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install sphinx\npip install sphinx_rtd_theme\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython HTML Documentation Locally\nDESCRIPTION: Command to build the MicroPython HTML documentation in the micropython/docs directory. This generates the documentation files that can be viewed locally.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake html\n```\n\n----------------------------------------\n\nTITLE: Hello World Print Example\nDESCRIPTION: Basic REPL example showing how to print a message to the console. Demonstrates the syntax of REPL inputs and outputs.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/repl.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> print('hello esp8266!')\nhello esp8266!\n```\n\n----------------------------------------\n\nTITLE: File Update and App Import\nDESCRIPTION: Updates a file on device and imports an app module.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nmpremote cp utils/driver.py :utils/driver.py + exec \"import app\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Keyword Arguments Usage in MicroPython\nDESCRIPTION: Example of code that works in CPython but fails in MicroPython due to keyword arguments.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/modules_preamble.txt#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport socket\ns = socket.socket(type=socket.SOCK_DGRAM)\n```\n\n----------------------------------------\n\nTITLE: Implementing Minimal MicroPython Firmware in C\nDESCRIPTION: This C code implements a basic MicroPython firmware with memory allocation, runtime initialization, and a REPL loop.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/porting.rst#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include \"py/builtin.h\"\n#include \"py/compile.h\"\n#include \"py/gc.h\"\n#include \"py/mperrno.h\"\n#include \"py/stackctrl.h\"\n#include \"shared/runtime/gchelper.h\"\n#include \"shared/runtime/pyexec.h\"\n\n// Allocate memory for the MicroPython GC heap.\nstatic char heap[4096];\n\nint main(int argc, char **argv) {\n    // Initialise the MicroPython runtime.\n    mp_stack_ctrl_init();\n    gc_init(heap, heap + sizeof(heap));\n    mp_init();\n\n    // Start a normal REPL; will exit when ctrl-D is entered on a blank line.\n    pyexec_friendly_repl();\n\n    // Deinitialise the runtime.\n    gc_sweep_all();\n    mp_deinit();\n    return 0;\n}\n\n// Handle uncaught exceptions (should never be reached in a correct C implementation).\nvoid nlr_jump_fail(void *val) {\n    for (;;) {\n    }\n}\n\n// Do a garbage collection cycle.\nvoid gc_collect(void) {\n    gc_collect_start();\n    gc_helper_collect_regs_and_stack();\n    gc_collect_end();\n}\n\n// There is no filesystem so stat'ing returns nothing.\nmp_import_stat_t mp_import_stat(const char *path) {\n    return MP_IMPORT_STAT_NO_EXIST;\n}\n\n// There is no filesystem so opening a file raises an exception.\nmp_lexer_t *mp_lexer_new_from_file(qstr filename) {\n    mp_raise_OSError(MP_ENOENT);\n}\n```\n\n----------------------------------------\n\nTITLE: VFS-like Operations in MicroPython on WiPy\nDESCRIPTION: Shows how to perform VFS-like operations on WiPy, including mounting and unmounting block devices, and formatting paths.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nvfs.mount(sd, '/sd')\n```\n\n----------------------------------------\n\nTITLE: Running All mpremote Tests in Bash\nDESCRIPTION: Command to execute all mpremote tests from the appropriate directory. This command runs the test suite script.\nSOURCE: https://github.com/micropython/micropython/blob/master/tools/mpremote/tests/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n$ cd tools/mpremote/tests\n$ ./run-mpremote-tests.sh\n```\n\n----------------------------------------\n\nTITLE: Unregistering Pre-commit Git Hooks\nDESCRIPTION: Command to unregister pre-commit git hooks from the MicroPython repository if you no longer want automatic checks.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npre-commit uninstall --hook-type pre-commit --hook-type commit-msg\n```\n\n----------------------------------------\n\nTITLE: Socket Constructor Example - MicroPython Style\nDESCRIPTION: Shows the MicroPython socket constructor signature with positional-only parameters marked by trailing slash.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/modules_preamble.txt#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsocket(af=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP, /)\n```\n\n----------------------------------------\n\nTITLE: Building Documentation - Bash\nDESCRIPTION: Commands to set up Python virtual environment and build MicroPython documentation\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/gettingstarted.rst#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 -m venv env\n$ source env/bin/activate\n$ pip install -r docs/requirements.txt\n$ cd docs\n$ make html\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents in reStructuredText for MicroPython Internals\nDESCRIPTION: This code snippet defines the table of contents for the MicroPython Internals documentation using reStructuredText syntax. It specifies the maximum depth of the table and lists the various sections to be included.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 3\n\n   gettingstarted.rst\n   writingtests.rst\n   compiler.rst\n   memorymgt.rst\n   library.rst\n   optimizations.rst\n   qstr.rst\n   maps.rst\n   publiccapi.rst\n   extendingmicropython.rst\n   porting.rst\n```\n\n----------------------------------------\n\nTITLE: Running mpremote directly with pipx\nDESCRIPTION: Command to run mpremote using pipx without installing it first, passing any arguments after the command.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/mpremote.rst#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ pipx run mpremote ...args\n```\n\n----------------------------------------\n\nTITLE: Initiating Software Reset in MicroPython\nDESCRIPTION: A simple code snippet showing how to programmatically trigger a soft reset in MicroPython using the machine module.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/repl.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmachine.soft_reset()\n```\n\n----------------------------------------\n\nTITLE: Setting Native Code Location for ESP8266 in MicroPython\nDESCRIPTION: Function to set the location for executing native code on ESP8266. It controls where compiled native code from decorators like @micropython.native is placed in memory.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/esp.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nset_native_code_location(start, length)\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython Cross-Compiler\nDESCRIPTION: Command to build the MicroPython cross-compiler, which is required to pre-compile built-in Python code. This should be executed from the root directory of the repository.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/renesas-ra/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ make -C mpy-cross\n```\n\n----------------------------------------\n\nTITLE: Adding SSL Context Options in Python\nDESCRIPTION: This snippet demonstrates the addition of new SSL context options, including OP_IGNORE_UNEXPECTED_EOF, and the default setting of OP_NO_SSLv2 and OP_NO_SSLv3.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nssl.OP_IGNORE_UNEXPECTED_EOF\nssl.SSLContext.options\nssl.OP_NO_SSLv2\nssl.OP_NO_SSLv3\n```\n\n----------------------------------------\n\nTITLE: MicroPython MSBuild Configuration XML\nDESCRIPTION: XML configuration file for setting MicroPython build variants in Visual Studio using Directory.build.props.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/windows/README.md#2025-04-21_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\n<Project>\n  <PropertyGroup>\n    <PyVariant>dev</PyVariant>\n  </PropertyGroup>\n</Project>\n```\n\n----------------------------------------\n\nTITLE: Running Pre-commit Manually\nDESCRIPTION: Commands to run pre-commit manually against the MicroPython Python codebase to update file formatting on demand, with options for all files, a single file, or a folder.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npre-commit run --all-files\npre-commit run --file ./path/to/my/file\npre-commit run --file ./path/to/my/folder/*\n```\n\n----------------------------------------\n\nTITLE: reStructuredText Function Group Documentation\nDESCRIPTION: Shows how to create common documentation for multiple related functions.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_12\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. function:: foo(x)\n              bar(y)\n\n   Description common to foo() and bar().\n```\n\n----------------------------------------\n\nTITLE: Updating Socket Exception Handling in Python\nDESCRIPTION: This snippet shows that the socket.timeout exception is now an alias of TimeoutError in the socket module.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nsocket.timeout\nTimeoutError\n```\n\n----------------------------------------\n\nTITLE: Verifying Git Remote Configuration - Bash\nDESCRIPTION: Command to verify remote repository configuration showing origin and upstream\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/gettingstarted.rst#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ git remote -v\norigin       https://github.com/<your-user-name>/micropython (fetch)\norigin       https://github.com/<your-user-name>/micropython (push)\nupstream     https://github.com/micropython/micropython (fetch)\nupstream     https://github.com/micropython/micropython (push)\n```\n\n----------------------------------------\n\nTITLE: Adding os.cpu_count() Support for VxWorks RTOS\nDESCRIPTION: Extends the os.cpu_count() function to support the VxWorks real-time operating system, allowing retrieval of CPU core count on this platform.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nos.cpu_count()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating asyncio.events.AbstractEventLoop.connect_accepted_socket Method\nDESCRIPTION: Adds the missing connect_accepted_socket method to the AbstractEventLoop class in the asyncio module. This method is used for handling accepted socket connections in asynchronous event loops.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nasyncio.events.AbstractEventLoop.connect_accepted_socket\n```\n\n----------------------------------------\n\nTITLE: Reverting boot.py to Normal USB Mode\nDESCRIPTION: This code shows how to modify boot.py to return the pyboard to its normal USB mode from mouse mode by commenting out the HID configuration line.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/usb_mouse.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n#pyb.usb_mode('VCP+HID') # act as a serial device and a mouse\n```\n\n----------------------------------------\n\nTITLE: Looking Up Error Code Strings in MicroPython\nDESCRIPTION: Example showing how to use the errorcode dictionary to convert numeric error codes to their symbolic string representations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/errno.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> print(errno.errorcode[errno.EEXIST])\nEEXIST\n```\n\n----------------------------------------\n\nTITLE: Array In-Place Concatenation\nDESCRIPTION: Implements in-place concatenation of arrays using the += operator. Equivalent to extend() method.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/array.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n__iadd__(other)\n```\n\n----------------------------------------\n\nTITLE: Defining reStructuredText Table of Contents for ESP32 MicroPython Tutorial\nDESCRIPTION: This snippet defines the table of contents for the ESP32 MicroPython tutorial using reStructuredText syntax. It specifies the structure and order of the tutorial sections.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp32/tutorial/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 1\n   :numbered:\n\n   intro.rst\n   pwm.rst\n   peripheral_access.rst\n   reset.rst\n```\n\n----------------------------------------\n\nTITLE: Displaying Compiler Help Options\nDESCRIPTION: Command to show full list of available compilation options for the MicroPython cross compiler\nSOURCE: https://github.com/micropython/micropython/blob/master/mpy-cross/README.md#2025-04-21_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ ./mpy-cross -h\n```\n\n----------------------------------------\n\nTITLE: Running MicroPython REPL in QEMU (Makefile)\nDESCRIPTION: Command to start QEMU and access the MicroPython REPL directly through the emulated hardware UART.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/qemu/README.md#2025-04-21_snippet_2\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make repl\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Run-time QSTR Generation in Python\nDESCRIPTION: This code snippet shows how run-time QSTR generation occurs in MicroPython. When assigning a value to a dictionary using a variable key, MicroPython needs to create a QSTR for the value of the variable 'x' to use it in the 'load attr' bytecode.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/qstr.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfoo[x] = 3\n```\n\n----------------------------------------\n\nTITLE: Running a Single mpremote Test in Bash\nDESCRIPTION: Command to run a specific test file within the mpremote test suite. This example demonstrates how to run the filesystem test.\nSOURCE: https://github.com/micropython/micropython/blob/master/tools/mpremote/tests/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n$ ./run-mpremote-tests.sh test_filesystem.sh\n```\n\n----------------------------------------\n\nTITLE: Display JPEG - LCD160CR Method\nDESCRIPTION: Displays a JPEG image from a buffer containing complete JPEG data.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.jpeg(buf)\n```\n\n----------------------------------------\n\nTITLE: Validate Board Variant\nDESCRIPTION: Checks if the specified board variant exists and terminates the build with a fatal error if it doesn't. Ensures that the specified board variant is valid.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(MICROPY_BOARD_VARIANT)\n    if(NOT EXISTS ${MICROPY_BOARD_DIR}/mpconfigvariant_${MICROPY_BOARD_VARIANT}.cmake)\n        message(FATAL_ERROR \"Invalid MICROPY_BOARD_VARIANT specified: ${MICROPY_BOARD_VARIANT}\")\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Registering Pre-commit Git Hooks\nDESCRIPTION: Command to register git hooks for pre-commit in the MicroPython repository. This sets up automatic checks for both code and commit message formatting during git commit.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install --hook-type pre-commit --hook-type commit-msg\n```\n\n----------------------------------------\n\nTITLE: Auditing gc Module Functions\nDESCRIPTION: Adds audit hooks for three garbage collection functions: gc.get_objects, gc.get_referrers, and gc.get_referents. This allows for better monitoring and debugging of garbage collection operations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ngc.get_objects()\ngc.get_referrers()\ngc.get_referents()\n```\n\n----------------------------------------\n\nTITLE: Emitting Native Code for Unary Operations in MicroPython\nDESCRIPTION: This function emits native code for unary operations in MicroPython. It handles both Python objects and viper-typed variables, calling the appropriate function or emitting an error for unsupported operations on viper types.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nstatic void emit_native_unary_op(emit_t *emit, mp_unary_op_t op) {\n     vtype_kind_t vtype;\n     emit_pre_pop_reg(emit, &vtype, REG_ARG_2);\n     if (vtype == VTYPE_PYOBJ) {\n         emit_call_with_imm_arg(emit, MP_F_UNARY_OP, op, REG_ARG_1);\n         emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n     } else {\n         adjust_stack(emit, 1);\n         EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n             MP_ERROR_TEXT(\"unary op %q not implemented\"), mp_unary_op_method_name[op]);\n     }\n}\n```\n\n----------------------------------------\n\nTITLE: Using array.array.index Method with Start and Stop Parameters\nDESCRIPTION: Demonstrates the enhanced index method of array.array class, which now supports optional start and stop parameters for specifying the search range within the array.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\narray.array.index(value, start, stop)\n```\n\n----------------------------------------\n\nTITLE: MicroPython Reset Message Output\nDESCRIPTION: This snippet shows the console output when a soft reset is performed at the MicroPython prompt, indicating the status of the board after the reset operation.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/renesas-ra/tutorial/reset.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n    MPY: sync filesystems\n    MPY: soft reboot\n    MicroPython v1.18-293-g339aa09b8-dirty on 2022-03-26; RA6M2_EK with RA6M2\n    Type \"help()\" for more information.\n    >>>\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Dependency\nDESCRIPTION: Specifies Sphinx documentation generator with version constraint, enabling flexible documentation generation for MicroPython\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: requirements\nCODE:\n```\nsphinx~=7.2.6\n```\n\n----------------------------------------\n\nTITLE: Running MicroPython in QEMU with PTY Device (Makefile)\nDESCRIPTION: Command to start QEMU and redirect the UART to a PTY device, allowing connection via a serial terminal program.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/qemu/README.md#2025-04-21_snippet_3\n\nLANGUAGE: Makefile\nCODE:\n```\n$ make run\n```\n\n----------------------------------------\n\nTITLE: Creating Development Branch - Bash\nDESCRIPTION: Command to create and switch to a new development branch\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/gettingstarted.rst#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ git checkout -b dev-branch\n```\n\n----------------------------------------\n\nTITLE: Building MicroPython for LEGO Hub\nDESCRIPTION: Complete sequence of shell commands to build MicroPython for the LEGO Hub from source.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/LEGO_HUB_NO6/README.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ cd mpy-cross\n$ make\n$ cd ../ports/stm32\n$ make submodules\n$ make BOARD=LEGO_HUB_NO6\n```\n\n----------------------------------------\n\nTITLE: Set Scroll Text - LCD160CR Method\nDESCRIPTION: Sets the text string (max 32 characters) for scrolling in window 8.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/lcd160cr.rst#2025-04-21_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nLCD160CR.set_scroll_buf(s)\n```\n\n----------------------------------------\n\nTITLE: Generating Mbedtls Error Strings using a Perl Script\nDESCRIPTION: This snippet describes the operation of gathering Mbedtls error defines using a Perl script and generating the function mbedtls_strerror(), which can be modified for space efficiency.\nSOURCE: https://github.com/micropython/micropython/blob/master/lib/mbedtls_errors/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Perl\nCODE:\n```\n#!/usr/bin/perl\\nuse strict;\\nuse warnings;\\n\\nmy @error_defines = grep { /MBEDTLS_ERR/ } @ARGV;\\nforeach my $error (@error_defines) {\\n    print \"Generating error string for $error\\n\";\\n    # Code to handle error strings generation here\\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Uncrustify with Homebrew\nDESCRIPTION: Command to install a specific version of uncrustify using Homebrew that is compatible with MicroPython's formatting requirements.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -L https://github.com/Homebrew/homebrew-core/raw/2b07d8192623365078a8b855a164ebcdf81494a6/Formula/uncrustify.rb > uncrustify.rb && brew install uncrustify.rb && rm uncrustify.rb\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for MicroPython Tests\nDESCRIPTION: Shows the main test directory structure including key folders like basics, extmod, float, and micropython.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/writingtests.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n.\n ├── basics\n ├── extmod\n ├── float\n ├── micropython\n ├── run-tests.py\n ...\n```\n\n----------------------------------------\n\nTITLE: reStructuredText Cross-Reference Examples\nDESCRIPTION: Shows various ways to create cross-references to functions, classes, and methods in documentation.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_10\n\nLANGUAGE: restructuredtext\nCODE:\n```\n:func:`foo` - function foo in current module\n:func:`module1.foo` - function foo in module \"module1\"\n    (similarly for other referent types)\n:class:`Foo` - class Foo\n:meth:`Class.method1` - method1 in Class\n:meth:`~Class.method1` - method1 in Class, but rendered just as \"method1()\",\n    not \"Class.method1()\"\n:meth:`title <method1>` - reference method1, but render as \"title\" (use only\n    if really needed)\n:mod:`module1` - module module1\n\n`symbol` - generic xref syntax which can replace any of the above in case\n    the xref is unambiguous. If there's ambiguity, there will be a warning\n    during docs generation, which need to be fixed using one of the syntaxes\n    above\n```\n\n----------------------------------------\n\nTITLE: Adding New SSL Verification Flag in Python\nDESCRIPTION: This snippet introduces a new SSL verification flag VERIFY_X509_PARTIAL_CHAIN in the ssl module.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nssl.VERIFY_X509_PARTIAL_CHAIN\n```\n\n----------------------------------------\n\nTITLE: Set Output SDKConfig Path\nDESCRIPTION: Defines the output path for the sdkconfig file, placing it within the build directory. Helps to keep the build directory organized.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(SDKCONFIG ${CMAKE_BINARY_DIR}/sdkconfig)\n```\n\n----------------------------------------\n\nTITLE: First Compiler Pass in MicroPython\nDESCRIPTION: Implementation of the first compiler pass that determines scope for identifiers and computes the number of labels needed for emitted code.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\n// Compile pass 1.\ncomp->emit = emit_bc;\ncomp->emit_method_table = &emit_bc_method_table;\n\nuint max_num_labels = 0;\nfor (scope_t *s = comp->scope_head; s != NULL && comp->compile_error == MP_OBJ_NULL; s = s->next) {\n    if (s->emit_options == MP_EMIT_OPT_ASM) {\n        compile_scope_inline_asm(comp, s, MP_PASS_SCOPE);\n    } else {\n        compile_scope(comp, s, MP_PASS_SCOPE);\n\n        // Check if any implicitly declared variables should be closed over.\n        for (size_t i = 0; i < s->id_info_len; ++i) {\n            id_info_t *id = &s->id_info[i];\n            if (id->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {\n                scope_check_to_close_over(s, id);\n            }\n        }\n    }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Backing up LEGO Hub Firmware using Shell Commands\nDESCRIPTION: Commands to backup and restore the original LEGO Hub firmware using make commands from the stm32 ports directory.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/LEGO_HUB_NO6/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ cd ports/stm32\n$ make BOARD=LEGO_HUB_NO6 backup-hub-firmware\n```\n\n----------------------------------------\n\nTITLE: Enabling Custom C Module in MicroPython Configuration\nDESCRIPTION: This snippet shows how to enable a custom C module named 'cexample' in the MicroPython configuration. It involves adding a define statement to the appropriate configuration file, such as mpconfigport.h or mpconfigboard.h.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/cmodules.rst#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#define MODULE_CEXAMPLE_ENABLED (1)\n```\n\n----------------------------------------\n\nTITLE: Configuring Zephyr Library for MicroPython\nDESCRIPTION: Sets up the Zephyr library for MicroPython, including include directories, compile options, and compile definitions. It also specifies the source files to be compiled and links the library with the Zephyr kernel.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/zephyr/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library_named(${MICROPY_TARGET})\n\nzephyr_library_include_directories(\n    ${MICROPY_INC_CORE}\n    ${MICROPY_PORT_DIR}\n    ${CMAKE_CURRENT_BINARY_DIR}\n)\n\nzephyr_library_compile_options(\n    -std=gnu99 -fomit-frame-pointer\n)\n\nzephyr_library_compile_definitions(\n    NDEBUG\n    MP_CONFIGFILE=<${CONFIG_MICROPY_CONFIGFILE}>\n    MICROPY_HEAP_SIZE=${CONFIG_MICROPY_HEAP_SIZE}\n    FFCONF_H=\\\"${MICROPY_OOFATFS_DIR}/ffconf.h\\\"\n    MICROPY_VFS_FAT=$<BOOL:${CONFIG_MICROPY_VFS_FAT}>\n    MICROPY_VFS_LFS1=$<BOOL:${CONFIG_MICROPY_VFS_LFS1}>\n    MICROPY_VFS_LFS2=$<BOOL:${CONFIG_MICROPY_VFS_LFS2}>\n)\n\nzephyr_library_sources(${MICROPY_SOURCE_QSTR})\nzephyr_library_link_libraries(kernel)\n```\n\n----------------------------------------\n\nTITLE: Filesystem Mounting Operations\nDESCRIPTION: Legacy filesystem mounting functions and classes that have been moved to the vfs module.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/os.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nmount(fsobj, mount_point, *, readonly)\numount(mount_point)\nVfsFat(block_dev)\nVfsLfs1(block_dev, readsize=32, progsize=32, lookahead=32)\nVfsLfs2(block_dev, readsize=32, progsize=32, lookahead=32, mtime=True)\nVfsPosix(root=None)\n```\n\n----------------------------------------\n\nTITLE: Implementing os.eventfd Function for Linux\nDESCRIPTION: Adds a new function os.eventfd and related helpers to wrap the eventfd2 syscall on Linux, providing a way to create a file descriptor for event notification.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_310.rst#2025-04-21_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nos.eventfd()\n```\n\n----------------------------------------\n\nTITLE: Querying CPU Frequency in MicroPython\nDESCRIPTION: Shows how to check the current CPU frequency of the ESP8266 using the machine module. The default frequency is 80MHz.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/powerctrl.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import machine\n>>> machine.freq()\n80000000\n```\n\n----------------------------------------\n\nTITLE: Applying GPL Terms to New Programs\nDESCRIPTION: This snippet provides instructions on how to apply the GNU General Public License to a new program. It includes the necessary notices to attach to the program's source files, effectively conveying the exclusion of warranty and providing information about the GPL.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/cc3200/FreeRTOS/License/license.txt#2025-04-21_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n\"<one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License** as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\"\n```\n\n----------------------------------------\n\nTITLE: Adding Keyword Text to the MicroPython Lexer\nDESCRIPTION: Addition of the 'add1' keyword literal text to the tok_kw array in py/lexer.c. The order of keywords must match the order of tokens in the enum defined in py/lexer.h.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nstatic const char *const tok_kw[] = {\n    ...\n    \"or\",\n    \"pass\",\n    \"raise\",\n    \"return\",\n    \"try\",\n    \"while\",\n    \"with\",\n    \"yield\",\n    \"add1\",\n    ...\n};\n```\n\n----------------------------------------\n\nTITLE: Disabling Access Point Interface in MicroPython\nDESCRIPTION: Deactivates the access point interface when it's no longer needed. This can be done after successfully connecting to a WiFi network as a station.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_basics.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> ap_if.active(False)\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies Definition\nDESCRIPTION: Specifies required Python packages and their minimum versions. Includes pyserial 3.3 or higher and importlib_metadata 1.4+ for Python versions below 3.8.\nSOURCE: https://github.com/micropython/micropython/blob/master/tools/mpremote/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: pip\nCODE:\n```\npyserial >= 3.3\nimportlib_metadata >= 1.4; python_version < \"3.8\"\n```\n\n----------------------------------------\n\nTITLE: Setting PATH for ESP8266 Toolchain in Bash\nDESCRIPTION: This command adds the ESP8266 toolchain to the system PATH. It should be run after extracting the toolchain.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/README.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ export \"PATH=$HOME/espressif/xtensa-lx106-elf/bin/:$PATH\"\n```\n\n----------------------------------------\n\nTITLE: Using Software SPI in MicroPython for ESP8266\nDESCRIPTION: Shows how to use the machine.SoftSPI class to create a software-implemented SPI bus on an ESP8266 board. Demonstrates various SPI operations like reading, writing, and simultaneous read-write.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/quickref.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SoftSPI\n\n# construct an SPI bus on the given pins\n# polarity is the idle state of SCK\n# phase=0 means sample on the first edge of SCK, phase=1 means the second\nspi = SoftSPI(baudrate=100000, polarity=1, phase=0, sck=Pin(0), mosi=Pin(2), miso=Pin(4))\n\nspi.init(baudrate=200000) # set the baudrate\n\nspi.read(10)            # read 10 bytes on MISO\nspi.read(10, 0xff)      # read 10 bytes while outputting 0xff on MOSI\n\nbuf = bytearray(50)     # create a buffer\nspi.readinto(buf)       # read into the given buffer (reads 50 bytes in this case)\nspi.readinto(buf, 0xff) # read into the given buffer and output 0xff on MOSI\n\nspi.write(b'12345')     # write 5 bytes on MOSI\n\nbuf = bytearray(4)      # create a buffer\nspi.write_readinto(b'1234', buf) # write to MOSI and read from MISO into the buffer\nspi.write_readinto(buf, buf) # write buf to MOSI and read MISO back into buf\n```\n\n----------------------------------------\n\nTITLE: Initializing Software SPI in MicroPython\nDESCRIPTION: This code snippet illustrates how to set up and use a Software SPI (Serial Peripheral Interface) bus in MicroPython.  It creates a SoftSPI object with specified configurations such as baud rate, polarity, phase, and pin assignments for SCK, MOSI, and MISO.  The snippet then demonstrates various SPI operations like reading, writing, and reading into a buffer.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/mimxrt/quickref.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SoftSPI\n\n# construct a SoftSPI bus on the given pins\n# polarity is the idle state of SCK\n# phase=0 means sample on the first edge of SCK, phase=1 means the second\nspi = SoftSPI(baudrate=100000, polarity=1, phase=0, sck=Pin('D0'), mosi=Pin('D2'), miso=Pin('D4'))\n\nspi.init(baudrate=200000) # set the baudrate\n\nspi.read(10)            # read 10 bytes on MISO\nspi.read(10, 0xff)      # read 10 bytes while outputting 0xff on MOSI\n\nbuf = bytearray(50)     # create a buffer\nspi.readinto(buf)       # read into the given buffer (reads 50 bytes in this case)\nspi.readinto(buf, 0xff) # read into the given buffer and output 0xff on MOSI\n\nspi.write(b'12345')     # write 5 bytes on MOSI\n\nbuf = bytearray(4)      # create a buffer\nspi.write_readinto(b'1234', buf) # write to MOSI and read from MISO into the buffer\nspi.write_readinto(buf, buf) # write buf to MOSI and read MISO back into buf\n```\n\n----------------------------------------\n\nTITLE: Define MicroPython Project\nDESCRIPTION: Defines the MicroPython project name. This command must be called after including the IDF project CMake file.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/CMakeLists.txt#2025-04-21_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nproject(micropython)\n```\n\n----------------------------------------\n\nTITLE: Installing Uncrustify on Ubuntu/Debian\nDESCRIPTION: Command to install uncrustify v0.72 on Ubuntu versions 21.10 or 22.04LTS, and Debian versions bullseye or bookworm, which is required for MicroPython C code formatting.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\napt install uncrustify\n```\n\n----------------------------------------\n\nTITLE: Initializing and Configuring WIZNET5K Network Interface in MicroPython\nDESCRIPTION: This code snippet demonstrates how to import the network module, create a WIZNET5K network interface, check the current network configuration, and enable DHCP. It shows how to retrieve network settings such as IP address, subnet mask, gateway, and DNS server.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/boards/W5100S_EVB_PICO/readme.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import network\n>>> nic = network.WIZNET5K()\n>>> nic.ifconfig()\n('192.168.0.18', '255.255.255.0', '192.168.0.1', '8.8.8.8')\n>>> nic.dhcp(True)\n('192.168.0.10', '255.255.255.0', '192.168.0.1', '192.168.0.1')\n```\n\n----------------------------------------\n\nTITLE: MicroPython Compilation Entry Point Function\nDESCRIPTION: Implementation of mp_compile function that takes a parse tree and produces executable code. It creates a module context, compiles the parse tree to raw code, and returns a function object that executes the module.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/compiler.rst#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nmp_obj_t mp_compile(mp_parse_tree_t *parse_tree, qstr source_file, bool is_repl) {\n    // Create a context for this module, and set its globals dict.\n    mp_module_context_t *context = m_new_obj(mp_module_context_t);\n    context->module.globals = mp_globals_get();\n\n    // Compile the input parse_tree to a raw-code structure.\n    mp_compiled_module_t cm;\n    cm.context = context;\n    mp_compile_to_raw_code(parse_tree, source_file, is_repl, &cm);\n\n    // Create and return a function object that executes the outer module.\n    return mp_make_function_from_proto_fun(cm.rc, cm.context, NULL);\n}\n```\n\n----------------------------------------\n\nTITLE: Software SPI Bus in MicroPython\nDESCRIPTION: Demonstrates how to use the `machine.SoftSPI` class for software SPI (using bit-banging) in MicroPython. It covers constructing a SoftSPI bus on the given pins with specified baud rate, polarity, and phase.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/rp2/quickref.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom machine import Pin, SoftSPI\n\n# construct a SoftSPI bus on the given pins\n# polarity is the idle state of SCK\n# phase=0 means sample on the first edge of SCK, phase=1 means the second\nspi = SoftSPI(baudrate=100_000, polarity=1, phase=0, sck=Pin(0), mosi=Pin(2), miso=Pin(4))\n```\n\n----------------------------------------\n\nTITLE: Installing UF2 Bootloader on Olimex RT1011 (Bash)\nDESCRIPTION: These commands use sdphost to write the UF2 bootloader to the Olimex RT1011 board and initiate its execution. This process installs the bootloader permanently, allowing for easier future updates of MicroPython.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/mimxrt/boards/OLIMEX_RT1010/deploy_olimex.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo ./sdphost -u 0x1fc9,0x0145 -- write-file 0x20206400 tinyuf2-imxrt1010_evk-0.21.0.bin\nsudo ./sdphost -u 0x1fc9,0x0145 -- jump-address 0x20207000\n```\n\n----------------------------------------\n\nTITLE: Accessing Memory with ARM FPU Instructions\nDESCRIPTION: These instructions load and store floating-point values between FPU registers and memory. The memory address is calculated by adding a register value to an offset, which must be a multiple of 4 bytes when accessing arrays of floats.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_float.rst#2025-04-21_snippet_2\n\nLANGUAGE: assembly\nCODE:\n```\nvldr(Sd, [Rn, offset]) \"Sd = [Rn + offset]\"\nvstr(Sd, [Rn, offset]) \"[Rn + offset] = Sd\"\n```\n\n----------------------------------------\n\nTITLE: Drawing Random Rectangles on LCD160CR Display\nDESCRIPTION: A MicroPython script that draws 1000 random rectangles on the LCD display with random foreground and background colors, demonstrating more complex graphics capabilities.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/lcd160cr_skin.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom random import randint\nfor i in range(1000):\n    fg = lcd.rgb(randint(128, 255), randint(128, 255), randint(128, 255))\n    bg = lcd.rgb(randint(0, 128), randint(0, 128), randint(0, 128))\n    lcd.set_pen(fg, bg)\n    lcd.rect(randint(0, lcd.w), randint(0, lcd.h), randint(10, 40), randint(10, 40))\n```\n\n----------------------------------------\n\nTITLE: Interactive Program Notice Example\nDESCRIPTION: This snippet provides an example of the short notice that an interactive program should output when it starts in interactive mode. It includes a copyright notice, a disclaimer of warranty, and information about the program being free software.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/cc3200/FreeRTOS/License/license.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n\"Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\"\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for ESP8266 Tutorial\nDESCRIPTION: ReStructuredText markup defining the table of contents and structure for the ESP8266 MicroPython tutorial documentation. Includes section references for various hardware and software topics.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _esp8266_tutorial:\n\nMicroPython tutorial for ESP8266\n================================\n\n.. toctree::\n   :maxdepth: 1\n   :numbered:\n\n   intro.rst\n   repl.rst\n   filesystem.rst\n   network_basics.rst\n   network_tcp.rst\n   pins.rst\n   pwm.rst\n   adc.rst\n   powerctrl.rst\n   onewire.rst\n   neopixel.rst\n   apa102.rst\n   dht.rst\n   ssd1306.rst\n   nextsteps.rst\n```\n\n----------------------------------------\n\nTITLE: Formatting LittleFS Filesystem in MicroPython on ESP8266\nDESCRIPTION: This code snippet demonstrates how to format the LittleFS filesystem on an ESP8266 board running MicroPython v1.12-334 or newer. It's required when upgrading from older firmware versions to ensure compatibility with the new default filesystem.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp8266/boards/ESP8266_GENERIC/board.md#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nvfs.VfsLfs2.mkfs(bdev)\n```\n\n----------------------------------------\n\nTITLE: Defining QSTR in C for MicroPython\nDESCRIPTION: This C code snippet demonstrates how QSTRs are defined in MicroPython's C codebase. The MP_QSTR_Foo macro is used to create a QSTR for the string 'Foo', which will be interned and assigned an index in the QSTR pool.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/qstr.rst#2025-04-21_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nMP_QSTR_Foo\n```\n\n----------------------------------------\n\nTITLE: Generating QSTR Definitions in MicroPython Build Process\nDESCRIPTION: This snippet shows the format used in the MicroPython build process to generate QSTR definitions. The QDEF macro is used to create an entry in the QSTR table, associating the QSTR name with its hash and string value.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/develop/qstr.rst#2025-04-21_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nQDEF(MP_QSTR_Foo, (const byte*)\"hash\" \"Foo\")\n```\n\n----------------------------------------\n\nTITLE: Floating Point Division Example - Python\nDESCRIPTION: This code snippet demonstrates the correct usage of integer division in MicroPython on the WiPy, where floating point division is not supported. It illustrates using '//' for division to avoid errors.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> r = 4 // 2  # this will work\n>>> r = 4 / 2   # this WON'T\n```\n\n----------------------------------------\n\nTITLE: Scanning Bluetooth Devices with MicroPython on LEGO Hub\nDESCRIPTION: Code snippet demonstrating how to initialize the Bluetooth module, set up an interrupt handler, activate Bluetooth, and perform device scanning on the LEGO Hub No.7.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/LEGO_HUB_NO7/README.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import bluetooth\n>>> ble = bluetooth.BLE()\n>>> ble.irq(lambda *x: print(*x))\n>>> ble.active(1)\n>>> ble.gap_scan(2000, 625, 625)\n```\n\n----------------------------------------\n\nTITLE: Uploading MicroPython Firmware to Arduino Opta using dfu-util\nDESCRIPTION: This command uses dfu-util to upload the MicroPython firmware to the Arduino Opta board. It specifies the device ID, firmware file, and necessary flags for the upload process.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/ARDUINO_OPTA/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndfu-util -w -a 0 -d 2341:0364 -D build-ARDUINO_OPTA/firmware.dfu\n```\n\n----------------------------------------\n\nTITLE: Flashing MicroPython Firmware to ESP32 with Specific Port using esptool.py\nDESCRIPTION: Command to write the MicroPython firmware to an ESP32 board, specifying the serial port explicitly. This is useful when multiple devices are connected or automatic port detection fails.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/boards/deploy_nativeusb.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py --port PORTNAME write_flash {deploy_options[flash_offset]} ESP32_BOARD_NAME-DATE-VERSION.bin\n```\n\n----------------------------------------\n\nTITLE: Using hashlib with Known Data Size in MicroPython on WiPy\nDESCRIPTION: Illustrates how to use the hashlib module on WiPy when the total data size is known in advance, avoiding buffering limitations.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/wipy/general.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nhash = hashlib.sha1('abcd1234', 1001)    # length of the initial piece is multiple of 4 bytes\nhash.update('1234')                       # also multiple of 4 bytes\n...\nhash.update('12345')                      # last chunk may be of any length\nhash.digest()\n```\n\n----------------------------------------\n\nTITLE: Testing the LCD160CR Display with Test Program\nDESCRIPTION: Shows how to import and run the test program for the LCD160CR display. The test program demonstrates the display's features and provides a starting point for creating custom code.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/pyboard/tutorial/lcd160cr_skin.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import lcd160cr_test\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> test_all('X')\n```\n\n----------------------------------------\n\nTITLE: Entering MicroPython Bootloader Mode via REPL\nDESCRIPTION: Command to enter bootloader mode through the MicroPython REPL interface to prepare for firmware updates. After execution, the board will appear as a USB mass storage device.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/rp2/boards/deploy.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmachine.bootloader()\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution: If-Then-Else (ite)\nDESCRIPTION: Shows the 'ite' (if then else) instruction for executing one of two instructions based on a comparison result.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/reference/asm_thumb2_compare.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncmp(r0, r1)\nite(eq)\nmov(r0, 100)  # Executed if r0 == r1\nmov(r0, 200)  # Executed if r0 != r1\n```\n\n----------------------------------------\n\nTITLE: Erasing ESP32 Flash Memory using esptool.py\nDESCRIPTION: Command to erase the entire flash memory of an ESP32 board before flashing new firmware. This step is recommended when installing MicroPython for the first time.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/boards/deploy_nativeusb.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py erase_flash\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Codespell\nDESCRIPTION: Commands to install and run codespell for spell checking MicroPython code. Codespell is configured via pyproject.toml to avoid false positives.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install codespell tomli\ncodespell\n```\n\n----------------------------------------\n\nTITLE: Dual DAC Usage Example\nDESCRIPTION: Demonstrates using both DAC channels simultaneously with different frequencies and circular buffer mode.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/pyb.DAC.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndac1 = DAC(1)\ndac2 = DAC(2)\ndac1.write_timed(buf1, pyb.Timer(6, freq=100), mode=DAC.CIRCULAR)\ndac2.write_timed(buf2, pyb.Timer(7, freq=200), mode=DAC.CIRCULAR)\n```\n\n----------------------------------------\n\nTITLE: Bluetooth Device Scanning in MicroPython\nDESCRIPTION: Python code example demonstrating how to scan for BLE devices using the bluetooth module.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/LEGO_HUB_NO6/README.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import bluetooth\n>>> ble = bluetooth.BLE()\n>>> ble.irq(lambda *x: print(*x))\n>>> ble.active(1)\n>>> ble.gap_scan(2000, 625, 625)\n```\n\n----------------------------------------\n\nTITLE: Installing older version of esptool.py\nDESCRIPTION: Command to install a specific older version of esptool.py (1.0.1) which may be needed for troubleshooting or compatibility with certain setups.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/intro.rst#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npip install esptool==1.0.1\n```\n\n----------------------------------------\n\nTITLE: Accessing Coroutine Wrapper in MicroPython\nDESCRIPTION: Demonstrates the use of get_coroutine_wrapper() function to obtain the currently set wrapper for a coroutine object created by an async def function.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/differences/python_35.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nget_coroutine_wrapper()\n```\n\n----------------------------------------\n\nTITLE: Retrieving IP Configuration in MicroPython\nDESCRIPTION: Retrieves the IP address and netmask after connecting to a WiFi network. This confirms the network settings assigned to the device.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/network_basics.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> sta_if.ipconfig('addr4')\n('192.168.0.2', '255.255.255.0')\n```\n\n----------------------------------------\n\nTITLE: Retrieving Sensor Micro Values in MicroPython with Zephyr\nDESCRIPTION: Method to get the sensor measurement value in millionths (microsystem) for a specific sensor channel.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.zsensor.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nSensor.get_micros(sensor_channel)\n```\n\n----------------------------------------\n\nTITLE: Flashing MicroPython Firmware to ESP32 using esptool.py\nDESCRIPTION: Command to write the MicroPython firmware to an ESP32 board. The flash_offset parameter specifies the starting address for writing the firmware.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/esp32/boards/deploy_nativeusb.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py write_flash {deploy_options[flash_offset]} ESP32_BOARD_NAME-DATE-VERSION.bin\n```\n\n----------------------------------------\n\nTITLE: Retrieving Sensor Integer Values in MicroPython with Zephyr\nDESCRIPTION: Method to get only the integer portion of the sensor measurement value for a specific sensor channel.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/library/zephyr.zsensor.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nSensor.get_int(sensor_channel)\n```\n\n----------------------------------------\n\nTITLE: Configuring Mboot Signed and Encrypted DFU Support in mpconfigboard.mk\nDESCRIPTION: Example configuration for enabling signed and encrypted DFU support in Mboot. Adds a flag to enable packing.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/mboot/README.md#2025-04-21_snippet_6\n\nLANGUAGE: Makefile\nCODE:\n```\nMBOOT_ENABLE_PACKING = 1\n```\n\n----------------------------------------\n\nTITLE: Updating MicroPython Firmware via REPL\nDESCRIPTION: Code showing how to update the MicroPython firmware using the appupdate module from within the REPL interface.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/stm32/boards/LEGO_HUB_NO7/README.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import appupdate\n>>> appupdate.update_app(\"firmware.dfu.gz\")\n```\n\n----------------------------------------\n\nTITLE: C Struct Definition Example\nDESCRIPTION: Shows the proper way to define a struct type in MicroPython codebase using typedef.\nSOURCE: https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct _my_struct_t {\n    int member;\n    void *data;\n} my_struct_t;\n```\n\n----------------------------------------\n\nTITLE: Running MicroPython in Node.js using import\nDESCRIPTION: Demonstrates how to import and use MicroPython in a Node.js environment using ES6 import syntax and async/await.\nSOURCE: https://github.com/micropython/micropython/blob/master/ports/webassembly/README.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst mp_mjs = await import(\"micropython.mjs\");\nconst mp = await mp_mjs.loadMicroPython();\n\nmp.runPython(\"print('hello world')\");\n```\n\n----------------------------------------\n\nTITLE: Using the Toggle Function\nDESCRIPTION: Example of calling the previously defined toggle function to change the state of an LED connected to a pin.\nSOURCE: https://github.com/micropython/micropython/blob/master/docs/esp8266/tutorial/repl.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> toggle(pin)\n```\n\n----------------------------------------\n\nTITLE: Initializing Submodules for Port Dependencies\nDESCRIPTION: Commands to initialize submodules for external dependencies required by specific MicroPython ports.\nSOURCE: https://github.com/micropython/micropython/blob/master/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cd ports/name\n$ make submodules\n```"
  }
]