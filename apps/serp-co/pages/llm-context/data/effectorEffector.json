[
  {
    "owner": "effector",
    "repo": "effector",
    "content": "TITLE: Updating Array in effector Store (Correct)\nDESCRIPTION: Demonstrates the correct way to update an array within an effector store using the spread operator to maintain immutability. The store `$users` is updated when the `userAdded` event occurs, adding a new user to the array without mutating the original array.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// update array\n$users.on(userAdded, (users, newUser) => [...users, newUser]);\n```\n\n----------------------------------------\n\nTITLE: Modeling Business Logic with Effector\nDESCRIPTION: This snippet demonstrates how to model the chat page's business logic using Effector. It defines events for user actions like deleting messages, sending messages, and logging in/out.  It also defines stores for managing the application's state, such as login status, username, messages, and message text. This uses the effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\n// File: /src/pages/chat/model.ts\nimport { createEvent, createStore } from \"effector\";\n\n// And the events report just what happened\nexport const messageDeleteClicked = createEvent<Message>();\nexport const messageSendClicked = createEvent();\nexport const messageEnterPressed = createEvent();\nexport const messageTextChanged = createEvent<string>();\nexport const loginClicked = createEvent();\nexport const logoutClicked = createEvent();\n\n// At the moment, there is just raw data without any knowledge how to load\nexport const $loggedIn = createStore<boolean>(false);\nexport const $userName = createStore(\"\");\nexport const $messages = createStore<Message[]>([]);\nexport const $messageText = createStore(\"\");\n\n// Page should NOT know where the data came from.\n// That's why we just reexport them.\n// We can rewrite this code to `combine` or independent store,\n// page should NOT be changed, just because we changed the implementation\nexport const $messageDeleting = messageApi.messageDeleteFx.pending;\nexport const $messageSending = messageApi.messageSendFx.pending;\n```\n\n----------------------------------------\n\nTITLE: Updating Object in effector Store (Correct)\nDESCRIPTION: Illustrates the proper method to update an object within an effector store while preserving immutability. When the `nameChanged` event is triggered, the `$user` store is updated by creating a new object with the updated `name` property using the spread operator.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n//update object\n$user.on(nameChanged, (user, newName) => ({\n  ...user,\n  name: newName,\n}));\n```\n\n----------------------------------------\n\nTITLE: Naming Conventions for Effector Units (TypeScript)\nDESCRIPTION: This snippet demonstrates the recommended naming conventions for Effector units: `$` prefix for stores, `fx` postfix for effects, and no specific rule for events (but suggesting using past tense for events that update stores). The goal is to improve readability and searchability. It creates an effect, an event, and a store with the suggested names.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst updateUserNameFx = createEffect(() => {});\n\nconst userNameUpdated = createEvent();\n\nconst $userName = createStore(\"JS\");\n\n$userName.on(userNameUpdated, (_, newName) => newName);\n\nuserNameUpdated(\"TS\");\n```\n\n----------------------------------------\n\nTITLE: Integrating Events, Stores, and Effects - Effector (TypeScript)\nDESCRIPTION: This code demonstrates how Effector's units (Events, Stores, Effects) work together in a reactive data flow. It defines stores for superheroes and villains, events for adding new superheroes, and effects for fetching and saving data. When `getSupersFx` succeeds, it populates the `$supers` store.  When `superAdded` is triggered, the store will be updated.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/core-concepts.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect } from \"effector\";\n\n// Define our stores\nconst $supers = createStore([]);\nconst $superHeroes = $supers.map((supers) => supers.filter((sup) => sup.role === \"hero\"));\nconst $superVillains = $supers.map((supers) => supers.filter((sup) => sup.role === \"villain\"));\n\n// Create events\nconst superAdded = createEvent();\n\n// Create effects for fetching data\nconst getSupersFx = createEffect(async () => {\n  const res = await fetch(\"/server/api/supers\");\n  if (!res.ok) {\n    throw new Error(\"something went wrong\");\n  }\n  const data = await res.json();\n  return data;\n});\n\n// Create effects for saving new data\nconst saveNewSuperFx = createEffect(async (newSuper) => {\n  // Simulate saving a new super\n  await new Promise((res) => setTimeout(res, 1500));\n  return newSuper;\n});\n\n// When the data fetch is successful, set the data\n$supers.on(getSupersFx.done, ({ result }) => result);\n// Add a new super\n$supers.on(superAdded, (supers, newSuper) => [...supers, newSuper]);\n\n// Trigger the data fetch\ngetSupersFx();\n```\n\n----------------------------------------\n\nTITLE: Correct Side Effect Handling in Effector (TypeScript)\nDESCRIPTION: This snippet demonstrates the correct way to handle side effects in Effector using `createEffect` and `sample`. It defines separate effects for saving to local storage and tracking user updates, then uses `sample` to trigger these effects when the `$user` store changes. This approach promotes a more declarative and maintainable code structure.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Отдельные эффекты для сайд-эффектов\nconst saveToStorageFx = createEffect((user: User) =>\n  localStorage.setItem(\"user\", JSON.stringify(user)),\n);\n\nconst trackUpdateFx = createEffect((user: User) => api.trackUserUpdate(user));\n\n// Связываем через sample\nsample({\n  clock: $user,\n  target: [saveToStorageFx, trackUpdateFx],\n});\n\n// Для событий тоже используем sample\nsample({\n  clock: $user,\n  fn: (user) => user.id,\n  target: someEvent,\n});\n```\n\n----------------------------------------\n\nTITLE: Debugging Effector Units with Patronum (TypeScript)\nDESCRIPTION: This code demonstrates how to use the `patronum/debug` utility to debug Effector stores, events, and effects. It creates a simple event, effect, and store, then uses `debug` to log their activity to the console, providing insights into data flow and state changes.  It requires the `patronum` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect } from \"effector\";\nimport { debug } from \"patronum/debug\";\n\nconst event = createEvent();\nconst effect = createEffect().use((payload) => Promise.resolve(\"result\" + payload));\nconst $store = createStore(0)\n  .on(event, (state, value) => state + value)\n  .on(effect.done, (state) => state * 10);\n\ndebug($store, event, effect);\n\nevent(5);\neffect(\"demo\");\n```\n\n----------------------------------------\n\nTITLE: React Component\nDESCRIPTION: This snippet defines the React component (`App`) for the todo list. It uses `useUnit` and `useList` from `effector-react` to connect the component to the Effector stores and events.  The component renders the input form and the list of todos, handling user interactions and displaying validation errors.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/todo-with-validation.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst App = () => {\n  const [todo, error] = useUnit([$todo, $error]);\n  const list = useList($todos, (todo, index) => (\n    <li style={{ textDecoration: todo.completed ? \"line-through\" : \"\" }}>\n      <input type=\"checkbox\" checked={todo.completed} onChange={() => completed(index)} />\n      {todo.text}\n      <button type=\"button\" onClick={() => removed(index)} className=\"delete\">\n        x\n      </button>\n    </li>\n  ));\n  return (\n    <div>\n      <h1>Todos</h1>\n      <form>\n        <input\n          className=\"text\"\n          type=\"text\"\n          name=\"todo\"\n          value={todo}\n          onChange={(e) => changed(e.target.value)}\n        />\n        <button type=\"submit\" onClick={submit} className=\"submit\">\n          Submit\n        </button>\n        {error && <div className=\"error\">{error}</div>}\n      </form>\n\n      <ul style={{ listStyle: \"none\" }}>{list}</ul>\n    </div>\n  );\n};\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n```\n\n----------------------------------------\n\nTITLE: State transformation with combine\nDESCRIPTION: Demonstrates state transformation using the `combine` function with different signatures. It shows how to combine multiple stores into a new store with a transformed value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/combine.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const $a: Store<A>;\ndeclare const $b: Store<B>;\n\n// State transformation\n\nconst $c: Store<C> = combine({ a: $a, b: $b }, (values: { a: A; b: B }) => C);\n\nconst $c: Store<C> = combine([$a, $b], (values: [A, B]) => C);\n\nconst $c: Store<C> = combine($a, $b, (a: A, b: B) => C);\n```\n\n----------------------------------------\n\nTITLE: Creating Submit Button Component (JSX)\nDESCRIPTION: This React component `SubmitButton` renders a submit button that is disabled while the `sendFormFx` effect is pending. It uses the `useUnit` hook to subscribe to the `sendFormFx.pending` store and sets the `disabled` attribute of the button based on the value of the store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/forms.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nconst SubmitButton = (props) => {\n  const loading = useUnit(sendFormFx.pending);\n  return (\n    <button disabled={loading} type=\"submit\">\n      Submit\n    </button>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Basic createStore Example\nDESCRIPTION: Demonstrates a basic usage of `createStore` to manage a list of todos.  It shows how to update the store's state with the `.on()` method when an event is fired, and how to reset the store to its default state with the `.reset()` method.  It also illustrates how to create a derived store using the `.map()` method and observe changes using `.watch()`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createStore.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst addTodo = createEvent();\nconst clearTodoList = createEvent();\n\nconst $todos = createStore([])\n  // Will update store when addTodo is fired\n  .on(addTodo, (list, todo) => [...list, todo])\n  // Will reset store to default state when clearTodos is fired\n  .reset(clearTodoList);\n\n// Create mapped store\nconst $selectedTodos = $todos.map((todos) => {\n  return todos.filter((todo) => todo.selected);\n});\n\n// Log initial store value and each change\n$todos.watch((todos) => {\n  console.log(\"todos\", todos);\n});\n// => todos []\n\naddTodo(\"go shopping\");\n// => todos ['go shopping']\n\naddTodo(\"go to the gym\");\n// => todos ['go shopping', 'go to the gym']\n\nclearTodoList();\n// => todos []\n```\n\n----------------------------------------\n\nTITLE: Store Creation via restore Method in effector\nDESCRIPTION: Illustrates creating a store using the `restore` method, which replaces the old state with a new one when an event is called.  The `$counter` store is updated when the `nameChanged` event is triggered, setting the new name as the store's value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { restore, createEvent } from \"effector\";\n\nconst nameChanged = createEvent<string>();\n\nconst $counter = restore(nameChanged, \"\");\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Effects for Session Management in TypeScript\nDESCRIPTION: Defines Effector effects for loading, deleting, and creating user sessions. `sessionLoadFx` loads the session from local storage, `sessionDeleteFx` deletes the session, and `sessionCreateFx` creates a new session with a generated ID and name. They utilize the wait function to mimic asynchronous operations.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// File: /src/shared/api/session.ts\nconst LocalStorageKey = \"effector-example-session\";\n\n// Note, that we need explicit types definition in that case, because `JSON.parse()` returns `any`\nexport const sessionLoadFx = createEffect<void, Session | null>(async () => {\n  const source = localStorage.getItem(LocalStorageKey);\n  await wait();\n  if (!source) {\n    return null;\n  }\n  return JSON.parse(source);\n});\n\n// By default, if there are no arguments, no explicit type arguments, and no return statement provided\n// effect will have type: `Effect<void, void, Error>`\nexport const sessionDeleteFx = createEffect(async () => {\n  localStorage.removeItem(LocalStorageKey);\n  await wait();\n});\n\n// Look at the type of the `sessionCreateFx` constant.\n// It will be `Effect<void, Session, Error>` because TypeScript can infer type from `session` constant\nexport const sessionCreateFx = createEffect(async () => {\n  // I explicitly set type for the next constant, because it allows TypeScript help me\n  // If I forgot to set property, I'll see error in the place of definition\n  // Also it allows IDE to autocomplete property names\n  const session: Session = {\n    id: createOid(),\n    name: createName(),\n  };\n  localStorage.setItem(LocalStorageKey, JSON.stringify(session));\n  return session;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Parsing and Validation with Zod - Typescript\nDESCRIPTION: Implements message parsing and validation using Zod to ensure that received messages conform to the defined schema. It includes an effect to parse raw messages, events for parsed messages and validation errors, and `sample` to connect the data flow.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst parsedMessageReceived = createEvent<MessagesSchema>();\n\nconst parseFx = createEffect((message: unknown): MessagesSchema => {\n  return messagesSchema.parse(JSON.parse(typeof message === \"string\" ? message : \"{}\"));\n});\n\n// Parse the message when received\nsample({\n  clock: rawMessageReceived,\n  target: parseFx,\n});\n\n// If parsing succeeds, forward the message\nsample({\n  clock: parseFx.doneData,\n  target: parsedMessageReceived,\n});\n```\n\n----------------------------------------\n\nTITLE: Typing Effector Stores in TypeScript\nDESCRIPTION: This example demonstrates how to type Effector stores using TypeScript, showing how to either explicitly provide a type using generics or let TypeScript infer the type from the initial value. It covers primitive types and complex object types. It illustrates a derived store using `.map` which results in a Store<string> type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createStore } from \"effector\";\n\n// Basic store with primitive value\n// StoreWritable<number>\nconst $counter = createStore(0);\n\n// Store with complex object type\ninterface User {\n  id: number;\n  name: string;\n  role: \"admin\" | \"user\";\n}\n\n// StoreWritable<User>\nconst $user = createStore<User>({\n  id: 1,\n  name: \"Bob\",\n  role: \"user\",\n});\n\n// Store<string>\nconst $userNameAndRole = $user.map((user) => `User name and role: ${user.name} and ${user.role}`);\n```\n\n----------------------------------------\n\nTITLE: Combine with multiple stores and function\nDESCRIPTION: Combines multiple stores using a function to derive a new value. The function is called with the values of the stores and returns the new state. Dependencies: `Store`, `StoreWritable`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/combine.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst $a: Store<A>\nconst $b: StoreWritable<B>\nconst $c: Store<C> | StoreWritable<C>\n\n$result: Store<D> = combine(\n  $a, $b, $c, ...,\n  (a: A, b: B, c: C, ...) => result\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Stores in Effector (TypeScript)\nDESCRIPTION: Illustrates how to create derived stores in Effector using the `map` and `combine` methods. The examples show filtering a list of users based on their active status, calculating counts, and combining multiple stores into a single store. Requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, combine } from \"effector\";\n\nconst $currentUser = createStore({\n  id: 1,\n  name: \"Winnie Pooh\",\n});\nconst $users = createStore<User[]>([ ]);\n\n// Filtered list\nconst $activeUsers = $users.map((users) => users.filter((user) => user.active));\n\n// Computed value\nconst $totalUsersCount = $users.map((users) => users.length);\nconst $activeUsersCount = $activeUsers.map((users) => users.length);\n\n// Combining multiple stores\nconst $friendsList = combine($users, $currentUser, (users, currentUser) =>\n  users.filter((user) => user.friendIds.includes(currentUser.id)),\n);\n```\n\n----------------------------------------\n\nTITLE: Split with Direct Match to Store API\nDESCRIPTION: This code demonstrates using `split` to directly update a store using `createApi`. Messages are routed to different API methods of `$textContent` store based on message type. This allows to update the state of the store depending on conditions\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { split, createStore, createEvent, createApi } from \"effector\";\n\nconst messageReceived = createEvent();\n\nconst $textContent = createStore([]);\n\nsplit({\n  source: messageReceived,\n  match: {\n    text: (msg) => msg.type === \"text\",\n    audio: (msg) => msg.type === \"audio\",\n  },\n  cases: createApi($textContent, {\n    text: (list, { value }) => [...list, value],\n    audio: (list, { duration }) => [...list, `audio ${duration} ms`],\n    __: (list) => [...list, \"unknown message\"],\n  }),\n});\n\n$textContent.watch((messages) => {\n  console.log(messages);\n});\n\nmessageReceived({\n  type: \"text\",\n  value: \"Hello\",\n});\n// => ['Hello']\nmessageReceived({\n  type: \"image\",\n  imageUrl: \"...\",\n});\n// => ['Hello', 'unknown message']\nmessageReceived({\n  type: \"audio\",\n  duration: 500,\n});\n// => ['Hello', 'unknown message', 'audio 500 ms']\n```\n\n----------------------------------------\n\nTITLE: Basic Split Example\nDESCRIPTION: This code demonstrates a basic example of using the `split` function to route messages to different event handlers based on message type. It uses `createEvent` to create events, and then `split` to direct the messages to `showTextPopup`, `playAudio`, or `reportUnknownMessageTypeFx` based on the `type` property.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { split, createEffect, createEvent } from \"effector\";\nconst messageReceived = createEvent();\nconst showTextPopup = createEvent();\nconst playAudio = createEvent();\nconst reportUnknownMessageTypeFx = createEffect(({ type }) => {\n  console.log(\"unknown message:\", type);\n});\n\nsplit({\n  source: messageReceived,\n  match: {\n    text: (msg) => msg.type === \"text\",\n    audio: (msg) => msg.type === \"audio\",\n  },\n  cases: {\n    text: showTextPopup,\n    audio: playAudio,\n    __: reportUnknownMessageTypeFx,\n  },\n});\n\nshowTextPopup.watch(({ value }) => {\n  console.log(\"new message:\", value);\n});\n\nmessageReceived({\n  type: \"text\",\n  value: \"Hello\",\n});\n// => new message: Hello\nmessageReceived({\n  type: \"image\",\n  imageUrl: \"...\",\n});\n// => unknown message: image\n```\n\n----------------------------------------\n\nTITLE: Updating Store with Events in Effector (TypeScript)\nDESCRIPTION: Shows the common usage of updating an Effector store using individual events and the `on` method. It defines separate events for increment, decrement, and reset actions on a counter store.  The store subscribes to these events to handle state updates. Requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst $counter = createStore(0);\n\nconst incrementClicked = createEvent();\nconst decrementClicked = createEvent();\nconst resetClicked = createEvent();\n\n$counter\n  .on(incrementClicked, (state) => state + 1)\n  .on(decrementClicked, (state) => state - 1)\n  .reset(resetClicked);\n\n// usage\nincrement(); // 1\nreset(); // 0\n```\n\n----------------------------------------\n\nTITLE: Reading Store Value in React with useUnit\nDESCRIPTION: Demonstrates how to read the current value of an effector store within a React component using the `useUnit` hook from `effector-react`.  The `Counter` component displays the current value of the `$counter` store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useUnit } from 'effector-react'\nimport { $counter } from './model.js'\n\nconst Counter = () => {\n  const counter = useUnit($counter)\n\n  return <div>{counter}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Import useUnit from effector-react (TypeScript)\nDESCRIPTION: Imports the `useUnit` hook from the `effector-react` library. This hook is essential for connecting Effector units (stores, events, effects) to React components.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useUnit.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useUnit } from \"effector-react\";\n```\n\n----------------------------------------\n\nTITLE: Merging units into an Event (Typescript)\nDESCRIPTION: Shows the declaration and usage pattern for merging multiple units (stores, events, or effects) into a single event.  The resulting event will trigger whenever any of the input units trigger or update.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/merge.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const $store: Store<T>; // триггер\ndeclare const event: Event<T>; // триггер\ndeclare const fx: Effect<T, any>; // триггер\n\nconst result: Event<T> = merge(/*clock*/ [$store, event, fx]);\n```\n\n----------------------------------------\n\nTITLE: Effector Model Definition\nDESCRIPTION: This snippet defines the Effector model for the chat page, including events for user actions and stores for managing application state. It utilizes `createEvent` and `createStore` from Effector. The model handles actions like sending messages, deleting messages, logging in, and logging out.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\nimport { createEvent, createStore } from \"effector\";\n\n// События просто сообщают о том, что что-то произошло\nexport const messageDeleteClicked = createEvent<Message>();\nexport const messageSendClicked = createEvent();\nexport const messageEnterPressed = createEvent();\nexport const messageTextChanged = createEvent<string>();\nexport const loginClicked = createEvent();\nexport const logoutClicked = createEvent();\n\n// В данный момент есть только сырые данные без каких-либо знаний о том, как их загрузить.\nexport const $loggedIn = createStore<boolean>(false);\nexport const $userName = createStore(\"\");\nexport const $messages = createStore<Message[]>([ ]);\nexport const $messageText = createStore(\"\");\n\n// Страница НЕ должна знать, откуда пришли данные.\n// Поэтому мы просто реэкспортируем их.\n// Мы можем переписать этот код с использованием `combine` или оставить независимые хранилища,\n// страница НЕ должна меняться, просто потому что мы изменили реализацию\nexport const $messageDeleting = messageApi.messageDeleteFx.pending;\nexport const $messageSending = messageApi.messageSendFx.pending;\n```\n\n----------------------------------------\n\nTITLE: Socket.IO Client Initialization and Event Handling (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to initialize a Socket.IO client, connect to a server, and handle various events such as connection, disconnection, errors, and custom messages. It uses Effector's `createEvent` and `createEffect` to manage the socket connection and associated events. The `scopeBind` function (not defined in the snippet) is assumed to be used for correctly binding events within scopes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { io, Socket } from \"socket.io-client\";\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\nconst API_URL = \"wss://your.ws.server\";\n\n// Events\nconst connected = createEvent();\nconst disconnected = createEvent();\nconst socketError = createEvent<Error>();\n\n// Types for events\ntype ChatMessage = {\n  room: string;\n  message: string;\n  author: string;\n};\n\nconst messageSent = createEvent<ChatMessage>();\nconst messageReceived = createEvent<ChatMessage>();\nconst socketConnected = createEvent();\nconst connectSocket = createEvent();\n\nconst connectFx = createEffect((): Promise<Socket> => {\n  const socket = io(API_URL, {\n    //... your configuration\n  });\n\n  // needed for correct work with scopes\n  const scopeConnected = scopeBind(connected);\n  const scopeDisconnected = scopeBind(disconnected);\n  const scopeSocketError = scopeBind(socketError);\n  const scopeMessageReceived = scopeBind(messageReceived);\n\n  return new Promise((resolve, reject) => {\n    socket.on(\"connect\", () => {\n      scopeConnected();\n      resolve(socket);\n    });\n\n    socket.on(\"disconnect\", () => scopeDisconnected());\n    socket.on(\"connect_error\", (error) => scopeSocketError(error));\n    socket.on(\"chat message\", (msg: ChatMessage) => scopeMessageReceived(msg));\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: AsyncStorage Counter Logic using Effector\nDESCRIPTION: This JavaScript code defines the core logic for a React Native counter application using the Effector library. It initializes events for incrementing, decrementing, and resetting the counter, along with effects to fetch and update the counter value in AsyncStorage. A store manages the counter's state, and samples connect events and effects to update the store and AsyncStorage.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react-native/asyncstorage-counter.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as React from \"react\";\nimport { Text, View, StyleSheet, TouchableOpacity } from \"react-native\";\nimport AsyncStorage from \"@react-native-community/async-storage\";\n\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\nimport { useUnit } from \"effector-react\";\n\nconst init = createEvent();\nconst increment = createEvent();\nconst decrement = createEvent();\nconst reset = createEvent();\n\nconst fetchCountFromAsyncStorageFx = createEffect(async () => {\n  const value = parseInt(await AsyncStorage.getItem(\"count\"));\n  return !isNaN(value) ? value : 0;\n});\n\nconst updateCountInAsyncStorageFx = createEffect(async (count) => {\n  try {\n    await AsyncStorage.setItem(\"count\", `${count}`, (err) => {\n      if (err) console.error(err);\n    });\n  } catch (err) {\n    console.error(err);\n  }\n});\n\nconst $counter = createStore(0);\n\nsample({\n  clock: fetchCountFromAsyncStorageFx.doneData,\n  target: init,\n});\n\n$counter\n  .on(init, (state, value) => value)\n  .on(increment, (state) => state + 1)\n  .on(decrement, (state) => state - 1)\n  .reset(reset);\n\nsample({\n  clock: $counter,\n  target: updateCountInAsyncStorageFx,\n});\n\nfetchCountFromAsyncStorageFx();\n\nexport default () => {\n  const count = useUnit(counter);\n\n  return (\n    <View style={styles.container}>\n      <Text style={styles.paragraph}>{count}</Text>\n      <View style={styles.buttons}>\n        <TouchableOpacity key=\"dec\" onPress={decrement} style={styles.button}>\n          <Text style={styles.label}>-</Text>\n        </TouchableOpacity>\n        <TouchableOpacity key=\"reset\" onPress={reset} style={styles.button}>\n          <Text style={styles.label}>0</Text>\n        </TouchableOpacity>\n        <TouchableOpacity key=\"inc\" onPress={increment} style={styles.button}>\n          <Text style={styles.label}>+</Text>\n        </TouchableOpacity>\n      </View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: \"center\",\n    paddingTop: 20,\n    backgroundColor: \"#ecf0f1\",\n    padding: 8,\n  },\n  paragraph: {\n    margin: 24,\n    fontSize: 60,\n    fontWeight: \"bold\",\n    textAlign: \"center\",\n  },\n  buttons: {\n    flexDirection: \"row\",\n    alignSelf: \"center\",\n    justifyContent: \"space-between\",\n  },\n  button: {\n    marginHorizontal: 10,\n    paddingVertical: 10,\n    paddingHorizontal: 20,\n    backgroundColor: \"#4287f5\",\n    borderRadius: 5,\n  },\n  label: {\n    fontSize: 30,\n    color: \"#ffffff\",\n    fontWeight: \"bold\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Server Request Handler with Effector\nDESCRIPTION: This code demonstrates a server request handler using Effector for server-side rendering. It uses `fork` to create an isolated scope for each request, preventing data leakage between users.  It also serializes and hydrates app's state, renders the React component to a string, and constructs a complete HTML response including serialized Effector state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/server-side-rendering.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// server.tsx\nimport { renderToString } from \"react-dom/server\";\nimport { Provider } from \"effector-react\";\nimport { fork, allSettled, serialize } from \"effector\";\n\nimport { appStarted, App, $pathname } from \"./app\";\n\nexport async function handleRequest(req) {\n  // 1. create separate instance of effector's state - special `Scope` object\n  const scope = fork({\n    values: [\n      // some parts of app's state can be immediately set to relevant states,\n      // before any computations started\n      [$pathname, req.pathname],\n    ],\n  });\n\n  // 2. start app's logic - all computations will be performed according to the model's logic,\n  // as well as any required effects\n  await allSettled(appStarted, {\n    scope,\n  });\n\n  // 3. Serialize the calculated state, so it can be passed over the network\n  const storesValues = serialize(scope);\n\n  // 4. Render the app - also into some serializable version\n  const app = renderToString(\n    // by using Provider with the scope we tell the <App />, which state of the stores it should use\n    <Provider value={scope}>\n      <App />\n    </Provider>,\n  );\n\n  // 5. prepare serialized HTML response\n  //\n  // This is serialization (or network) boundary\n  // The point, where all state is stringified to be sent over the network\n  //\n  // effectors state is stored as a `<script>`, which will set the state into global object\n  // `react`'s state is stored as a part of the DOM tree.\n  return `\n    <html>\n      <head>\n        <script>\n          self._SERVER_STATE_ = ${JSON.stringify(storesValues)}\n        </script>\n        <link rel=\"stylesheet\" href=\"styles.css\" />\n        <script defer src=\"app.js\" />\n      </head>\n      <body>\n        <div id=\"app\">\n          ${app}\n        </div>\n      </body>\n    </html>\n  `;\n}\n\n```\n\n----------------------------------------\n\nTITLE: React Counter with Effector\nDESCRIPTION: This code demonstrates a React counter application managed by Effector. It defines an event `plus` to increment the counter, a store `$counter` to hold the counter's value, and a combined store `$counterCombined` to combine the counter value and formatted text. The `App` component renders the counter, a button to increment it, and displays the combined counter data using `useUnit` from `effector-react`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/counter.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { createEvent, createStore, combine } from \"effector\";\nimport { useUnit } from \"effector-react\";\n\nconst plus = createEvent();\n\nconst $counter = createStore(1);\n\nconst $counterText = $counter.map((count) => `current value = ${count}`);\nconst $counterCombined = combine({ counter: $counter, text: $counterText });\n\n$counter.on(plus, (count) => count + 1);\n\nfunction App() {\n  const counter = useUnit($counter);\n  const counterText = useUnit($counterText);\n  const counterCombined = useUnit($counterCombined);\n\n  return (\n    <div>\n      <button onClick={plus}>Plus</button>\n      <div>counter: {counter}</div>\n      <div>counterText: ${counterText}</div>\n      <div>\n        counterCombined: {counterCombined.counter}, {counterCombined.text}\n      </div>\n    </div>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n```\n\n----------------------------------------\n\nTITLE: Filtering Events with Effector's sample\nDESCRIPTION: This example demonstrates how to filter Effector events using `sample`. The `userClicked` event is filtered to create `adminClicked` which only triggers when the user's `role` is 'admin'. It also shows how to use TypeScript's type predicates to create a type-safe `typeSafeAdminClicked` event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample, createEvent } from \"effector\";\n\ntype User = { id: number; role: \"admin\" | \"user\" };\ntype Admin = { id: number; role: \"admin\" };\n\nconst userClicked = createEvent<User>();\n\n// Событие вызовется только для admin\nconst adminClicked = sample({\n  clock: userClicked,\n  filter: ({ role }) => role === \"admin\",\n});\n\n// Создаем типизированное событие\nconst typeSafeAdminClicked = sample({\n  clock: userClicked,\n  filter: (user): user is Admin => user.role === \"admin\",\n});\n```\n\n----------------------------------------\n\nTITLE: Using Effector Effects in React\nDESCRIPTION: This code demonstrates how to integrate Effector effects into a React component. It defines an effect `fetchUserFx` to fetch data from a URL. The component uses `useUnit` to subscribe to the `$user` store and the `fetchUserFx.pending` signal to display the fetched username and manage the loading state of the button. Requires Effector and Effector-React dependencies.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/effects.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { createEffect, createStore, sample } from \"effector\";\nimport { useUnit } from \"effector-react\";\n\nconst url =\n  \"https://gist.githubusercontent.com/\" +\n  \"zerobias/24bc72aa8394157549e0b566ac5059a4/raw/\" +\n  \"b55eb74b06afd709e2d1d19f9703272b4d753386/data.json\";\n\nconst loadUserClicked = createEvent();\n\nconst fetchUserFx = createEffect((url) => fetch(url).then((req) => req.json()));\n\nconst $user = createStore(null);\n\nsample({\n  clock: loadUserClicked,\n  fn: () => url,\n  target: fetchUserFx,\n});\n\n$user.on(fetchUserFx.doneData, (_, user) => user.username);\n\nconst App = () => {\n  const [user, pending] = useUnit([$user, fetchUserFx.pending]);\n  const handleUserLoad = useUnit(loadUserClicked);\n  return (\n    <div>\n      {user ? <div>current user: {user}</div> : <div>no current user</div>}\n      <button disable={pending} onClick={handleUserLoad}>\n        load user\n      </button>\n    </div>\n  );\n};\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n```\n\n----------------------------------------\n\nTITLE: Splitting event with match as Object with Stores - Effector - TypeScript\nDESCRIPTION: This snippet demonstrates using an object of stores as the `match` parameter in `split`. Each store holds a boolean value. When `postCreated` is triggered, the case whose corresponding store is `true` will be executed. If both `$isAdmin` and `$isModerator` were `true`, `createAdminPostFx` would be triggered, as it is the first in the object.  The default case `createUserPostFx` runs only if neither `$isAdmin` nor `$isModerator` is `true`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/flow-split.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst $isAdmin = createStore(false);\nconst $isModerator = createStore(false);\n\nsplit({\n  source: postCreated,\n  match: {\n    admin: $isAdmin,\n    moderator: $isModerator,\n  },\n  cases: {\n    admin: createAdminPostFx,\n    moderator: createModeratorPostFx,\n    __: createUserPostFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Guard with Store Filter (JavaScript)\nDESCRIPTION: This example demonstrates using a store as a filter in `guard`. The `target` event is only triggered when the `trigger` event occurs and the `$unlocked` store's value is true. The `$unlocked` store is managed by the `lock` and `unlock` actions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/guard.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore, createApi, guard } from \"effector\";\n\nconst trigger = createEvent();\nconst $unlocked = createStore(true);\n\nconst { lock, unlock } = createApi($unlocked, {\n  lock: () => false,\n  unlock: () => true,\n});\n\nconst target = guard(trigger, {\n  filter: $unlocked,\n});\n\ntarget.watch(console.log);\ntrigger(\"A\");\nlock();\ntrigger(\"B\"); // nothing happens\nunlock();\ntrigger(\"C\");\n```\n\n----------------------------------------\n\nTITLE: Complex Update Logic with sample in effector\nDESCRIPTION: Demonstrates how to use the `sample` method for complex state updates, enabling control over updates, dependency on multiple stores, and data transformation.  The `$filteredItems` store is updated based on the `$items` and `$filter` stores when the `updateItems` event is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, sample } from \"effector\";\n\nconst updateItems = createEvent();\n\nconst $items = createStore([1, 2, 3]);\nconst $filteredItems = createStore([]);\nconst $filter = createStore(\"even\");\n\n// sample automatically provides access to current values\n// of all connected stores at the moment the event triggers\nsample({\n  clock: updateItems,\n  source: { items: $items, filter: $filter },\n  fn: ({ items, filter }) => {\n    if (filter === \"even\") {\n      return items.filter((n) => n % 2 === 0);\n    }\n\n    return items.filter((n) => n % 2 === 1);\n  },\n  target: $filteredItems,\n});\n```\n\n----------------------------------------\n\nTITLE: Create Countdown Timer with Effector\nDESCRIPTION: This code snippet defines a function `createCountdown` that creates a countdown timer using Effector. It takes `start`, `abort`, and `timeout` as configuration parameters. The function uses Effector's `createStore`, `createEvent`, `createEffect`, and `sample` to manage the timer's state, trigger ticks, and handle aborting.  The `wait` function uses `setTimeout` to simulate the time interval. It returns an object containing the `tick` event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/common/countdown.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction createCountdown(name, { start, abort = createEvent(`${name}Reset`), timeout = 1000 }) {\n  // tick every 1 second\n  const $working = createStore(true, { name: `${name}Working` });\n  const tick = createEvent(`${name}Tick`);\n  const timerFx = createEffect(`${name}Timer`).use(() => wait(timeout));\n\n  $working.on(abort, () => false).on(start, () => true);\n\n  sample({\n    source: start,\n    filter: timerFx.pending.map((is) => !is),\n    target: tick,\n  });\n\n  sample({\n    clock: tick,\n    target: timerFx,\n  });\n\n  const willTick = sample({\n    source: timerFx.done.map(({ params }) => params - 1),\n    filter: (seconds) => seconds >= 0,\n  });\n\n  sample({\n    source: willTick,\n    filter: $working,\n    target: tick,\n  });\n\n  return { tick };\n}\n\nfunction wait(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Using Effector with React\nDESCRIPTION: This React component demonstrates how to use Effector with React using the `useUnit` hook from `effector-react`. It imports a store `$counter` and events `incremented` and `decremented` from `./counter.js` and connects them to the component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useUnit } from \"effector-react\";\nimport { createEvent, createStore } from \"effector\";\nimport { $counter, incremented, decremented } from \"./counter.js\";\n\nexport const Counter = () => {\n  const [counter, onIncremented, onDecremented] = useUnit([$counter, incremented, decremented]);\n  // or\n  const { counter, onIncremented, onDecremented } = useUnit({ $counter, incremented, decremented });\n  // or\n  const counter = useUnit($counter);\n  const onIncremented = useUnit(incremented);\n  const onDecremented = useUnit(decremented);\n\n  return (\n    <div>\n      <h1>Count: {counter}</h1>\n      <button onClick={onIncremented}>Increment</button>\n      <button onClick={onDecremented}>Decrement</button>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Triggering Effects with Application Start Event (TypeScript)\nDESCRIPTION: This code demonstrates how to trigger an effect (`initFx`) when the `appStarted` event is triggered. It showcases both the usage without and with scopes. `sample` is used to connect the event to the effect. With scopes, `allSettled` guarantees completion within a test.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample } from \"effector\";\nimport { scope } from \"./app.js\";\n\nsample({\n  clock: appStarted,\n  target: initFx,\n});\n\nappStarted();\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample, allSettled } from \"effector\";\nimport { scope } from \"./app.js\";\n\nsample({\n  clock: appStarted,\n  target: initFx,\n});\n\nallSettled(appStarted, { scope });\n```\n\n----------------------------------------\n\nTITLE: Updating Store with createApi in Effector (TypeScript)\nDESCRIPTION: Demonstrates updating an Effector store using `createApi` to define multiple update handlers in a single location.  It creates increment, decrement, and reset actions for a counter store.  This approach simplifies store management compared to creating separate events and subscriptions. Requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createApi } from \"effector\";\n\nconst $counter = createStore(0);\n\nconst { increment, decrement, reset } = createApi($counter, {\n  increment: (state) => state + 1,\n  decrement: (state) => state - 1,\n  reset: () => 0,\n});\n\n// usage\nincrement(); // 1\nreset(); // 0\n```\n\n----------------------------------------\n\nTITLE: Practical Example of Effects Usage in Effector (TypeScript)\nDESCRIPTION: This code provides a practical example of using effects in Effector for fetching and displaying user data. It uses `createStore`, `createEvent`, `createEffect`, and `sample` from Effector. The `fetchUserFx` effect fetches user data, the stores manage the ID, user data, error messages, and loading state.  The `sample` function connects the `submit` event and $id store to the effect, triggering the data fetching process.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/work-with-async.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\n// Effect for data loading\nconst fetchUserFx = createEffect(async (id: number) => {\n  const response = await fetch(`/api/user/${id}`);\n\n  if (!response.ok) {\n    // you can modify the error before it reaches fail/failData\n    throw new Error(\"User not found\");\n  }\n\n  return response.json();\n});\n\nconst setId = createEvent<number>();\nconst submit = createEvent();\n\nconst $id = createStore(0);\nconst $user = createStore<{ name: string } | null>(null);\nconst $error = createStore<string | null>(null);\nconst $isLoading = fetchUserFx.pending;\n\n$id.on(setId, (_, id) => id);\n$user.on(fetchUserFx.doneData, (_, user) => user);\n$error.on(fetchUserFx.fail, (_, { error }) => error.message);\n$error.reset(fetchUserFx.done);\n\n// Loading logic: run fetchUserFx on submit\nsample({\n  clock: submit,\n  source: $id,\n  target: fetchUserFx,\n});\n\n// Usage\nsetId(1); // Set ID\nsubmit(); // Load data\n```\n\n----------------------------------------\n\nTITLE: Transforming DOM Event to FormData (JS)\nDESCRIPTION: This snippet creates an event handler `onSubmit` that is prepended to the `sendFormFx` effect. It transforms the DOM event from the form submission into a `FormData` object, which is then passed to the `sendFormFx` effect.  This prepares the data for the asynchronous form submission.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/forms.md#_snippet_8\n\nLANGUAGE: js\nCODE:\n```\nconst onSubmit = sendFormFx.prepend((e) => new FormData(e.target));\n```\n\n----------------------------------------\n\nTITLE: Splitting event with default case - Effector - TypeScript\nDESCRIPTION: This snippet extends the basic `split` example by including a default case `__`.  If none of the specified conditions match, the `__` event is triggered. The snippet also includes `.watch` handlers to log messages to the console based on which events are triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/flow-split.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, split } from \"effector\";\n\nconst updateUserStatus = createEvent();\n\nconst { activeUserUpdated, idleUserUpdated, inactiveUserUpdated, __ } = split(updateUserStatus, {\n  activeUserUpdated: (userStatus) => userStatus === \"active\",\n  idleUserUpdated: (userStatus) => userStatus === \"idle\",\n  inactiveUserUpdated: (userStatus) => userStatus === \"inactive\",\n});\n\n__.watch((defaultStatus) => console.log(\"default case with status:\", defaultStatus));\nactiveUserUpdated.watch(() => console.log(\"active user\"));\n\nupdateUserStatus(\"whatever\");\nupdateUserStatus(\"active\");\nupdateUserStatus(\"default case\");\n\n// Console output:\n// default case with status: whatever\n// active user\n// default case with status: default case\n```\n\n----------------------------------------\n\nTITLE: Array Update Example - Typescript\nDESCRIPTION: Demonstrates how to correctly update an array stored in an effector Store by creating a new array reference using the spread operator. This ensures that effector detects the change and updates the store's state. Incorrectly mutating the array in place will not trigger an update.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n$items.on(addItem, (items, newItem) => {\n  const updatedItems = [...items];\n  // ✅ метод .push вызывается на новом массиве\n  updatedItems.push(newItem);\n  return updatedItems;\n});\n```\n\n----------------------------------------\n\nTITLE: Correct State Access via Parameters in Effector (Typescript)\nDESCRIPTION: This snippet shows the recommended way of passing store values to effects via parameters using the `sample` function, enhancing reusability and testability. It samples `$form`, `$user`, and `$settings` when `formSubmitted` occurs, and then passes the values to `submitFormFx`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// get values through parameters\nconst submitFormFx = createEffect(({ form, userId, theme }) => {});\n\n// get all necessary data through sample\nsample({\n  clock: formSubmitted,\n  source: {\n    form: $form,\n    user: $user,\n    settings: $settings,\n  },\n  fn: ({ form, user, settings }) => ({\n    form,\n    userId: user.id,\n    theme: settings.theme,\n  }),\n  target: submitFormFx,\n});\n```\n\n----------------------------------------\n\nTITLE: useUnit with Event & Store - JSX Example\nDESCRIPTION: Shows a basic Solid component using `useUnit` with Effector events and stores. The example defines an event to increment a counter, a store to hold the counter's value, and a component that uses `useUnit` to bind the store and event to the component, allowing it to display and update the count.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useUnit.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { render } from \"solid-js/web\";\nimport { createEvent, createStore, fork } from \"effector\";\nimport { useUnit, Provider } from \"effector-solid\";\n\nconst incremented = createEvent();\nconst $count = createStore(0);\n\n$count.on(incremented, (count) => count + 1);\n\nconst App = () => {\n  const [count, handleIncrement] = useUnit([$count, incremented]);\n\n  return (\n    <>\n      <p>Count: {count()}</p>\n      <button onClick={() => handleIncrement()}>Increment</button>\n    </>\n  );\n};\n\nconst scope = fork();\n\nrender(\n  () => (\n    <Provider value={scope}>\n      <App />\n    </Provider>\n  ),\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Create effect with handler (JavaScript)\nDESCRIPTION: Creates an effect named `fetchUserReposFx` using `createEffect` and defines an asynchronous handler function that fetches user repositories from the GitHub API. It then watches the `.done` event of the effect to log the results.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createEffect.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect(async ({ name }) => {\n  const url = `https://api.github.com/users/${name}/repos`;\n  const req = await fetch(url);\n  return req.json();\n});\n\nfetchUserReposFx.done.watch(({ params, result }) => {\n  console.log(result);\n});\n\nawait fetchUserReposFx({ name: \"zerobias\" });\n```\n\n----------------------------------------\n\nTITLE: Creating and using an Effect - Effector (JavaScript)\nDESCRIPTION: This code demonstrates how to create an effect using `createEffect` from Effector to handle asynchronous operations, like fetching user data from an API.  The `fetchUserFx` effect is created, and subscriptions are set up using the `done` and `fail` events to handle successful and failed results.  The effect is then triggered with a user ID.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/core-concepts.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\n// Create an effect\nconst fetchUserFx = createEffect(async (userId) => {\n  const response = await fetch(`/api/user/${userId}`);\n  return response.json();\n});\n\n// Subscribe to effect results\nfetchUserFx.done.watch(({ result }) => console.log(\"User data:\", result));\n// If effect throw error we will catch it via fail event\nfetchUserFx.fail.watch(({ error }) => console.log(\"Error occurred! \", error));\n\n// Trigger effect\nfetchUserFx(1);\n```\n\n----------------------------------------\n\nTITLE: withRegion usage example\nDESCRIPTION: Demonstrates how to use `withRegion` to define a region and associate units created within the region with a specified unit.  This allows for controlled memory management, where connections created within the callback are removed when `clearNode` is called on the region's unit.  Dependencies: `createNode`, `createEvent`, `restore`, `withRegion`, `clearNode` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/withRegion.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { createNode, createEvent, restore, withRegion, clearNode } from \"effector\";\n\nconst first = createEvent();\nconst second = createEvent();\nconst $store = restore(first, \"\");\nconst region = createNode();\n\nwithRegion(domain, () => {\n  // Следующие связи, созданные с помощью `sample`, принадлежат предоставленному юниту `domain`\n  // и будут удалены, как только будет вызван `clearNode` на `domain`.\n  sample({\n    clock: second,\n    target: first,\n  });\n});\n\n$store.watch(console.log);\n\nfirst(\"привет\");\nsecond(\"мир\");\n\nclearNode(region);\n\nsecond(\"не вызовет обновлений `$store`\");\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Effect with Inner Effects - JS\nDESCRIPTION: This JavaScript snippet illustrates the correct usage of an Effector effect that calls other effects asynchronously.  It's crucial to `await` each effect call to maintain the scope correctly. Failure to do so can lead to scope loss.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Scope.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst authUserFx = createEffect();\nconst sendMessageFx = createEffect();\n\nconst sendWithAuthFx = createEffect(async () => {\n  await authUserFx();\n  await delayFx();\n  await sendMessageFx();\n});\n```\n\n----------------------------------------\n\nTITLE: Event Filter and Map Transformation in Effector (TypeScript)\nDESCRIPTION: This code demonstrates how to use `filterMap` to filter and transform data emitted by an Effector event. It handles a scenario where an event `someHappened` emits a number, and `receivedEven` event should only trigger with the absolute value if the number is even, while avoiding direct unit calls within the filterMap.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst countReceived = createEvent<number>();\nconst eachReceived = createEvent<number>();\n\nconst receivedEven = someHappened.filterMap((count) => {\n  eachReceived(count); // THROWS!\n  return count % 2 === 0 ? Math.abs(count) : undefined;\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst countReceived = createEvent<number>();\nconst eachReceived = createEvent<number>();\n\nconst receivedEven = someHappened.filterMap((count) => {\n  return count % 2 === 0 ? Math.abs(count) : undefined;\n});\n\nsample({\n  clock: someHappened,\n  target: eachReceived,\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering Updates with `sample({ filter })` (JavaScript)\nDESCRIPTION: Demonstrates how to filter updates using the `filter` property in the `sample` function. The `filter` function determines whether the sampling should proceed based on the current state and the clock's payload.  The example simulates a money transfer scenario with balance and signature checks.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/sample.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\nconst sign = createEvent();\nconst sentMoney = createEvent();\nconst $recipientAddress = createStore(\"a23x3xd\");\nconst $balance = createStore(20000);\nconst $isSigned = createStore(false);\nconst transactionFx = createEffect(\n  ({ amountToSend, recipientAddress }) =>\n    new Promise((res) =>\n      setTimeout(res, 3000, {\n        amount: amountToSend,\n        recipientAddress,\n      }),\n    ),\n);\n\n$isSigned.on(sign, () => true).reset(transactionFx);\n$balance.on(transactionFx.doneData, (balance, { amount }) => balance - amount);\n\nsample({\n  source: {\n    recipientAddress: $recipientAddress,\n    isSigned: $isSigned,\n    balance: $balance,\n  },\n  clock: sentMoney,\n  filter: ({ isSigned, balance }, amountToSend) => isSigned && balance > amountToSend,\n  fn({ recipientAddress }, amountToSend) {\n    return { recipientAddress, amountToSend };\n  },\n  target: transactionFx,\n});\n\n$balance.watch((balance) => console.log(\"balance: \", balance));\n$isSigned.watch((isSigned) => console.log(\"is signed: \", isSigned));\n\nsign();\nsentMoney(1000);\n```\n\n----------------------------------------\n\nTITLE: Updating Store Data When Effect Completes (TypeScript)\nDESCRIPTION: This code demonstrates how to update a store with data returned by an effect upon successful completion or handle errors. It uses `createStore` and `createEffect` from effector.  It showcases how to use the `done` and `fail` events (and their `doneData` and `failData` variants) to update stores with the effect's results or error messages.  An example of using pending to track loading state is also provided.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/work-with-async.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEffect } from \"effector\";\n\nconst fetchUserNameFx = createEffect(async (userId: string) => {\n  const userData = await fetch(`/api/users/${userId}`);\n  return userData.name;\n});\n\nconst $error = createStore<string | null>(null);\nconst $userName = createStore(\"\");\nconst $isLoading = fetchUserNameFx.pending.map((isPending) => isPending);\n\n$error.reset(fetchUserNameFx.done);\n\n$userName.on(fetchUserNameFx.done, (_, { params, result }) => result);\n$error.on(fetchUserNameFx.fail, (_, { params, error }) => error.message);\n// or 🔃\n$userName.on(fetchUserNameFx.doneData, (_, result) => result);\n$error.on(fetchUserNameFx.failData, (_, error) => error.message);\n\n$isLoading.watch((isLoading) => console.log(\"Is loading:\", isLoading));\n```\n\n----------------------------------------\n\nTITLE: Basic useGate Usage with React (JavaScript)\nDESCRIPTION: This example shows how to use `useGate` within a React component to pass props to a Gate. It imports `createGate` and `useGate` from `effector-react`.  It creates a Gate called `PageGate` and uses `useGate` to connect the `props` passed to the `Home` component to the `PageGate`. The `Route` component is assumed to be from `react-router`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useGate.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createGate, useGate } from \"effector-react\";\nimport { Route } from \"react-router\";\n\nconst PageGate = createGate(\"page\");\n\nPageGate.state.watch(({ match }) => {\n  console.log(match);\n});\n\nconst Home = (props) => {\n  useGate(PageGate, props);\n\n  return <section>Home</section>;\n};\n\nconst App = () => <Route component={Home} />;\n```\n\n----------------------------------------\n\nTITLE: Complete Timer Implementation with Scope Binding - Effector\nDESCRIPTION: This snippet represents the complete timer implementation, incorporating `scopeBind` to prevent scope loss. It includes event and store creation, effect definitions, and the logic for starting, stopping, resetting the timer, showcasing the corrected usage of `scopeBind` to address the scope loss issue.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, createEvent, createStore, sample, scopeBind } from \"effector\";\n\nconst TIMEOUT = 1_000;\n\nconst timerStopped = createEvent();\nconst timerReset = createEvent();\nconst timerStarted = createEvent();\nconst tick = createEvent();\n\n// start timer\nconst startFx = createEffect(() => {\n  // bind event to scope, so our data doesn't get lost\n  const bindedTick = scopeBind(tick);\n\n  const intervalId = setInterval(() => {\n    bindedTick();\n  }, TIMEOUT);\n\n  return intervalId;\n});\n\n// stop and clean timer\nconst stopFx = createEffect((timerId: number) => {\n  clearInterval(timerId);\n});\n\n// timer count in seconds\nconst $timerCount = createStore(0)\n  .on(tick, (seconds) => seconds + 1)\n  .reset(timerReset);\n\n// timer id\nconst $timerId = createStore<null | number>(null)\n  .on(startFx.doneData, (_, timerId) => timerId)\n  .reset(stopFx.finally);\n\n// start timer logic\nsample({\n  clock: timerStarted,\n  filter: $timerId.map((timerId) => !timerId),\n  target: startFx,\n});\n\n// stop timer logic\nsample({\n  clock: timerStopped,\n  source: $timerId,\n  filter: Boolean,\n  target: stopFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Effector Test with Custom Store Values\nDESCRIPTION: This code snippet demonstrates how to set custom store values and mock an effect handler using Effector's fork API for testing. It sets an initial state where the counter is greater than 100 to simulate a scenario, also mocks function to track number of calls.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/testing.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"bad case\", async () => {\n  const MOCK_VALUE = 101;\n  const mockFunction = jest.fn();\n\n  const scope = fork({\n    values: [\n      // List of [store, mockValue] pairs\n      [$clicksCount, MOCK_VALUE],\n    ],\n    handlers: [\n      // List of [effect, mock handler] pairs\n      [\n        validateClickFx,\n        () => {\n          mockFunction();\n\n          return false;\n        },\n      ],\n    ],\n  });\n\n  expect(scope.getState($clicksCount)).toEqual(MOCK_VALUE);\n\n  await allSettled(buttonClicked, { scope });\n\n  expect(scope.getState($clicksCount)).toEqual(MOCK_VALUE);\n  expect(mockFunction).toHaveBeenCalledTimes(0);\n});\n```\n\n----------------------------------------\n\nTITLE: Message Sending Effect - TypeScript\nDESCRIPTION: This snippet defines the `messageSendFx` effect, which simulates sending a message to the server. It creates a new `Message` object with a unique ID, author, timestamp, and text. It then retrieves the message history, adds the new message, saves the updated history, and returns the newly created message. Dependencies include createOid for generating unique identifiers and messagesLoadFx for retrieving existing messages.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport const messageSendFx = createEffect(async ({ text, author }: SendMessage) => {\n  const message: Message = {\n    id: createOid(),\n    author,\n    timestamp: Date.now(),\n    text,\n  };\n  const history = await messagesLoadFx();\n  await wait();\n  saveHistory([...history, message]);\n  return message;\n});\n```\n\n----------------------------------------\n\nTITLE: Requesting Next Page with Attached Effect\nDESCRIPTION: This code demonstrates attaching an effect to multiple stores and using the combined store values as parameters for the original effect. The attached effect, `requestNextPageFx`, receives the current page and size from stores, passes them to the original effect, `requestPageFx`, and increments the page store when the original effect completes successfully.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, createStore, attach } from \"effector\";\n\nconst requestPageFx = createEffect<{ page: number; size: number }, string[]>(\n  async ({ page, size }) => {\n    console.log(\"Requested\", page);\n    return page * size;\n  },\n);\n\nconst $page = createStore(1);\nconst $size = createStore(20);\n\nconst requestNextPageFx = attach({\n  source: { page: $page, size: $size },\n  effect: requestPageFx,\n});\n\n$page.on(requestNextPageFx.done, (page) => page + 1);\n\nrequestPageFx.doneData.watch((position) => console.log(\"requestPageFx.doneData\", position));\n\nawait requestNextPageFx();\n// => Requested 1\n// => requestPageFx.doneData 20\n\nawait requestNextPageFx();\n// => Requested 2\n// => requestPageFx.doneData 40\n\nawait requestNextPageFx();\n// => Requested 3\n// => requestPageFx.doneData 60\n```\n\n----------------------------------------\n\nTITLE: Updating Stores with Event Parameters in effector\nDESCRIPTION: Shows how to update a store using event parameters by passing data to the event and using it in the handler function.  The `$user` store is updated when the `userUpdated` event is triggered, merging the event's data with the existing user object.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst userUpdated = createEvent<{ name: string }>();\n\nconst $user = createStore({ name: \"Bob\" });\n\n$user.on(userUpdated, (user, changedUser) => ({\n  ...user,\n  ...changedUser,\n}));\n\nuserUpdated({ name: \"Alice\" });\n```\n\n----------------------------------------\n\nTITLE: Split with Arrays of Units as Cases\nDESCRIPTION: This example uses `split` where cases can be arrays of effector units. If the match condition is met, all units within the matching case's array will be triggered. The `serverError` case triggers both `$error` updates and `modalToAuthorizationMethod` event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect, createEvent, createStore, sample, split } from \"effector\";\n\nconst $verificationCode = createStore(\"12345\");\nconst $error = createStore(\"\");\n\nconst modalToInputUsername = createEvent();\nconst modalToAuthorizationMethod = createEvent();\n\nconst checkVerificationCodeFx = createEffect((code) => {\n  throw \"500\";\n});\n\nsample({\n  clock: verificationCodeSubmitted,\n  source: $verificationCode,\n  target: checkVerificationCodeFx,\n});\n\nsplit({\n  source: checkVerificationCodeFx.failData,\n  match: (value) => ([\"400\", \"410\"].includes(value) ? \"verificationCodeError\" : \"serverError\"),\n  cases: {\n    verificationCodeError: $verificationCodeError,\n    serverError: [$error, modalToAuthorizationMethod],\n  },\n});\n\n$error.updates.watch((value) => console.log(\"ERROR: \" + value));\nmodalToAuthorizationMethod.watch(() =>\n  console.log(\"Modal window to the authorization method content.\"),\n);\n// => ERROR: 500\n// => Modal window to the authorization method content.\n```\n\n----------------------------------------\n\nTITLE: Create Independent Instances with fork (JavaScript)\nDESCRIPTION: Demonstrates creating two isolated instances (scopes) of an Effector application using `fork`. It shows how to update stores within each scope independently and how to retrieve the state of a store within a specific scope using `scope.getState($store)`. Dependencies include `createStore`, `createEvent`, `fork`, and `allSettled` from Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/fork.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, fork, allSettled } from \"effector\";\n\nconst inc = createEvent();\nconst dec = createEvent();\nconst $counter = createStore(0);\n\n$counter.on(inc, (value) => value + 1);\n$counter.on(dec, (value) => value - 1);\n\nconst scopeA = fork();\nconst scopeB = fork();\n\nawait allSettled(inc, { scope: scopeA });\nawait allSettled(dec, { scope: scopeB });\n\nconsole.log($counter.getState()); // => 0\nconsole.log(scopeA.getState($counter)); // => 1\nconsole.log(scopeB.getState($counter)); // => -1\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Store and Event\nDESCRIPTION: This code snippet defines an Effector store `$counter` initialized to 0 and an event `counterIncremented`. The store is updated by incrementing its value when the `counterIncremented` event is triggered. This is a basic example of state management in Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/testing.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst counterIncremented = createEvent();\n\nconst $counter = createStore(0);\n\n$counter.on(counterIncremented, (counter) => counter + 1);\n```\n\n----------------------------------------\n\nTITLE: Basic effector split Example (JavaScript)\nDESCRIPTION: Demonstrates basic usage of `effector.split` to route events to different handlers based on user properties. It defines an event `message` and then splits it into different events based on the `user` property of the incoming data, routing messages to `bob` or `alice` handlers. A default handler `guest` is provided for unmatched users.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_10\n\nLANGUAGE: js\nCODE:\n```\nimport { createEvent, split } from \"effector\";\n\nconst message = createEvent();\n\nconst messageByAuthor = split(message, {\n  bob: ({ user }) => user === \"bob\",\n  alice: ({ user }) => user === \"alice\",\n});\nmessageByAuthor.bob.watch(({ text }) => {\n  console.log(\"[bob]: \", text);\n});\nmessageByAuthor.alice.watch(({ text }) => {\n  console.log(\"[alice]: \", text);\n});\n\nmessage({ user: \"bob\", text: \"Привет\" });\n// => [bob]: Привет\nmessage({ user: \"alice\", text: \"Привет, bob\" });\n// => [alice]: Привет, bob\n\n/* кейс по умолчанию, срабатывает, если ни одно из условий не выполнено */\nconst { __: guest } = messageByAuthor;\nguest.watch(({ text }) => {\n  console.log(\"[гость]: \", text);\n});\nmessage({ user: \"незарегистрированный\", text: \"привет\" });\n// => [гость]: привет\n```\n\n----------------------------------------\n\nTITLE: Splitting store based on a store's value with clock in effector using Javascript\nDESCRIPTION: This code snippet demonstrates splitting a store based on the value of another store triggered by an event using the `split` function in effector. `$message` store is split based on the value of `$mode` store which gets updated by `selectedMessageOption` event. Each case routes the `$message` data to a corresponding effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, createEffect, split } from \"effector\";\n\nconst options = [\"save\", \"delete\", \"forward\"];\nconst $message = createStore({ id: 1, text: \"Bring me a cup of coffee, please!\" });\nconst $mode = createStore(\"\");\nconst selectedMessageOption = createEvent();\nconst saveMessageFx = createEffect(() => \"save\");\nconst forwardMessageFx = createEffect(() => \"forward\");\nconst deleteMessageFx = createEffect(() => \"delete\");\n\n$mode.on(selectedMessageOption, (mode, opt) => options.find((item) => item === opt) ?? mode);\n\nsplit({\n  source: $message,\n  clock: selectedMessageOption,\n  match: $mode,\n  cases: {\n    save: saveMessageFx,\n    delete: deleteMessageFx,\n    forward: forwardMessageFx,\n  },\n});\n\nselectedMessageOption(\"delet\"); // nothing happens\nselectedMessageOption(\"delete\");\n\n```\n\n----------------------------------------\n\nTITLE: Combining Stores into Object in Effector (TypeScript)\nDESCRIPTION: Demonstrates combining multiple stores into a single store representing a form.  The first example combines stores directly into an object. The second example combines stores and transforms their values to create a form validation store. Requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { combine } from \"effector\";\n\nconst $form = combine({\n  name: $name,\n  age: $age,\n  city: $city,\n});\n\n// or with additional transformation\nconst $formValidation = combine($name, $age, (name, age) => ({\n  isValid: name.length > 0 && age >= 18,\n  errors: {\n    name: name.length === 0 ? \"Required\" : null,\n    age: age < 18 ? \"Must be 18+\" : null,\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Hydrating Effector React App on Client (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to hydrate an Effector-React application on the client-side after server-side rendering. It retrieves the server-calculated state from `globalThis._SERVER_STATE_`, initializes an Effector scope using `fork` with the retrieved state, and then hydrates the React application using `hydrateRoot`. Finally, it triggers the `appStarted` event within the client scope to ensure consistency with the server-side execution. It depends on react, react-dom/client, effector, effector-react.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/server-side-rendering.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// client.tsx\nimport React from \"react\";\nimport { hydrateRoot } from \"react-dom/client\";\nimport { fork, allSettled } from \"effector\";\nimport { Provider } from \"effector-react\";\n\nimport { App, appStarted } from \"./app\";\n\n/**\n * 1. Find, where the server state is stored and retrieve it\n * \n * See the server handler code to find out, where it was saved in the HTML\n */\nconst effectorState = globalThis._SERVER_STATE_;\nconst reactRoot = document.querySelector(\"#app\");\n\n/**\n * 2. Initiate the client scope of effector with server-calculated values\n */\nconst clientScope = fork({\n  values: effectorState,\n});\n\n/**\n * 3. \"Hydrate\" React state in the DOM tree\n */\nhydrateRoot(\n  reactRoot,\n  <Provider value={clientScope}>\n    <App />\n  </Provider>,\n);\n\n/**\n * 4. Call the same starting event at the client\n * \n * This is optional and actually depends on how your app's logic is organized\n */\nallSettled(appStarted, { scope: clientScope });\n```\n\n----------------------------------------\n\nTITLE: Testing Effector with Custom Store Values and Effect Mocks\nDESCRIPTION: This snippet shows how to test Effector logic with custom store values and effect mocks. It initializes the `$clicksCount` store to 101 and mocks the `validateClickFx` effect to return `false` and track the number of calls. The test verifies that the count remains 101 and the effect is not called, simulating the scenario where the count is already over 100.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/testing.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"bad case\", async () => {\n  const MOCK_VALUE = 101;\n  const mockFunction = testRunner.fn();\n\n  const scope = fork({\n    values: [\n      // Список пар [store, mockValue]\n      [$clicksCount, MOCK_VALUE],\n    ],\n    handlers: [\n      // Список пар [effect, mock handler]\n      [\n        validateClickFx,\n        () => {\n          mockFunction();\n\n          return false;\n        },\n      ],\n    ],\n  });\n\n  expect(scope.getState($clicksCount)).toEqual(MOCK_VALUE);\n\n  await allSettled(buttonClicked, { scope });\n\n  expect(scope.getState($clicksCount)).toEqual(MOCK_VALUE);\n  expect(mockFunction).toHaveBeenCalledTimes(0);\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Store and Factory\nDESCRIPTION: This example shows how to create an authorized request using `attach` with a store and a factory function.  It sets up a backend request effect, a store for the authentication token, and attaches them using `mapParams` to create authorized requests.  The example also demonstrates how to use createRequest factory function to avoid code duplication.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// ./api/request.ts\nimport { createEffect, createStore } from \"effector\";\n\nexport const backendRequestFx = createEffect(async ({ token, data, resource }) => {\n  return fetch(`https://example.com/api${resource}`, {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${token}`,\n    },\n    body: JSON.stringify(data),\n  });\n});\n\nexport const $requestsSent = createStore(0);\n\n$requestsSent.on(backendRequestFx, (total) => total + 1);\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// ./api/authorized.ts\nimport { attach, createStore } from \"effector\";\n\nconst $token = createStore(\"guest_token\");\n\nexport const authorizedRequestFx = attach({\n  effect: backendRequestFx,\n  source: $token,\n  mapParams: ({ data, resource }, token) => ({ data, resource, token }),\n});\n\nexport function createRequest(resource) {\n  return attach({\n    effect: authorizedRequestFx,\n    mapParams: (data) => ({ data, resource }),\n  });\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// ./api/index.ts\nimport { createRequest } from \"./authorized\";\nimport { $requestsSent } from \"./request\";\n\nconst getUserFx = createRequest(\"/user\");\nconst getPostsFx = createRequest(\"/posts\");\n\n$requestsSent.watch((total) => {\n  console.log(`client analytics: sent ${total} requests`);\n});\n\nconst user = await getUserFx({ name: \"alice\" });\n/*\nPOST https://example.com/api/user\n{\"name\": \"alice\"}\nAuthorization: Bearer guest_token\n*/\n\n// => client analytics: sent 1 requests\n\nconst posts = await getPostsFx({ user: user.id });\n/*\nPOST https://example.com/api/posts\n{\"user\": 18329}\nAuthorization: Bearer guest_token\n*/\n\n// => client analytics: sent 2 requests\n```\n\n----------------------------------------\n\nTITLE: Update Store State with `.on()` (JavaScript)\nDESCRIPTION: Updates a store's state using the `.on()` method when a trigger event occurs.  The `$store` increments its value whenever the `changed` event is triggered, using the event's payload as the incrementor. Includes a watcher to log updated values.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst $store = createStore(0);\nconst changed = createEvent();\n\n$store.on(changed, (value, incrementor) => value + incrementor);\n\n$store.watch((value) => {\n  console.log(\"updated\", value);\n});\n\nchanged(2);\nchanged(2);\n```\n\n----------------------------------------\n\nTITLE: useList with Store Updates (JSX)\nDESCRIPTION: Illustrates how to use `useList` with a store that updates based on events. It demonstrates a simple to-do list application where items can be toggled and new items can be added.  The `useUnit` hook is used to access event handlers from effector. The list will re-render efficiently on updates.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useList.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\nimport { useList, useUnit } from \"effector-react\";\n\nconst todoSubmitted = createEvent();\nconst todoToggled = createEvent();\n\nconst $todoList = createStore([\n  { text: \"write useList example\", done: true },\n  { text: \"update readme\", done: false },\n]);\n\n$todoList.on(todoToggled, (list, id) =>\n  list.map((todo, index) => {\n    if (index === id)\n      return {\n        ...todo,\n        done: !todo.done,\n      };\n    return todo;\n  }),\n);\n\n$todoList.on(todoSubmitted, (list, text) => [...list, { text, done: false }]);\n\ntodoSubmitted.watch((e) => {\n  e.preventDefault();\n});\n\nconst TodoList = () => {\n  const [onTodoToggle] = useUnit([todoToggled]);\n  return useList($todoList, ({ text, done }, index) => {\n    const todo = done ? (\n      <del>\n        <span>{text}</span>\n      </del>\n    ) : (\n      <span>{text}</span>\n    );\n\n    return <li onClick={() => onTodoToggle(index)}>{todo}</li>;\n  });\n};\n\nconst App = () => {\n  const [onTodoSubmit] = useUnit([todoSubmitted]);\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    onTodoSubmit(e.currentTarget.elements.content.value);\n  }\n\n  return (\n    <div>\n      <h1>todo list</h1>\n      <form onSubmit={handleSubmit}>\n        <label htmlFor=\"content\">New todo</label>\n        <input type=\"text\" name=\"content\" required />\n        <input type=\"submit\" value=\"Add\" />\n      </form>\n      <ul>\n        <TodoList />\n      </ul>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Sample with Name\nDESCRIPTION: Shows how to assign a name to a sampled unit using the `name` option. This is useful for debugging and identifying units in the Effector devtools.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/sample.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, sample } from \"effector\";\n\nconst $store = createStore(null);\n\nconst sampled = sample({\n  source: $store,\n  name: \"sampled $store\",\n});\n\nconsole.log(sampled.shortName); // 'sampled foo'\n```\n\n----------------------------------------\n\nTITLE: React Counter App Component\nDESCRIPTION: This code defines a simple React-based counter app using Effector for state management. It includes Effector stores, events, and effects for fetching and saving the counter value. The component uses `useUnit` to connect the React component to Effector's state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/server-side-rendering.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// app.tsx\nimport React from \"react\";\nimport { createEvent, createStore, createEffect, sample, combine } from \"effector\";\nimport { useUnit } from \"effector-react\";\n\n// model\nexport const appStarted = createEvent();\nexport const $pathname = createStore<string | null>(null);\n\nconst $counter = createStore<number | null>(null);\n\nconst fetchUserCounterFx = createEffect(async () => {\n  await sleep(100); // in real life it would be some api request\n\n  return Math.floor(Math.random() * 100);\n});\n\nconst buttonClicked = createEvent();\nconst saveUserCounterFx = createEffect(async (count: number) => {\n  await sleep(100); // in real life it would be some api request\n});\n\nsample({\n  clock: appStarted,\n  source: $counter,\n  filter: (count) => count === null, // if count is already fetched - do not fetch it again\n  target: fetchUserCounterFx,\n});\n\nsample({\n  clock: fetchUserCounterFx.doneData,\n  target: $counter,\n});\n\nsample({\n  clock: buttonClicked,\n  source: $counter,\n  fn: (count) => count + 1,\n  target: [$counter, saveUserCounterFx],\n});\n\nconst $countUpdatePending = combine(\n  [fetchUserCounterFx.pending, saveUserCounterFx.pending],\n  (updates) => updates.some((upd) => upd === true),\n);\n\nconst $isClient = createStore(typeof document !== \"undefined\", {\n  /**\n   * Here we're explicitly telling effector, that this store, which depends on the environment,\n   * should be never included in serialization\n   * as it's should be always calculated based on actual current env\n   *\n   * This is not actually necessary, because only diff of state changes is included into serialization\n   * and this store is not going to be changed.\n   *\n   * But it is good to add this setting anyway - to highlight the intention\n   */\n  serialize: \"ignore\",\n});\n\nconst notifyFx = createEffect((message: string) => {\n  alert(message);\n});\n\nsample({\n  clock: [\n    saveUserCounterFx.done.map(() => \"Counter update is saved successfully\"),\n    saveUserCounterFx.fail.map(() => \"Could not save the counter update :(\"),\n  ],\n  // It is totally ok to have some splits in the app's logic based on current environment\n  //\n  // Here we want to trigger notification alert only at the client\n  filter: $isClient,\n  target: notifyFx,\n});\n\n// ui\nexport function App() {\n  const clickButton = useUnit(buttonClicked);\n  const { count, updatePending } = useUnit({\n    count: $counter,\n    updatePending: $countUpdatePending,\n  });\n\n  return (\n    <div>\n      <h1>Counter App</h1>\n      <h2>{updatePending ? \"Counter is updating\" : `Current count is ${count ?? \"unknown\"}`}</h2>\n      <button onClick={() => clickButton()}>Update counter</button>\n    </div>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Guard with Store Filter Example\nDESCRIPTION: Demonstrates how to use `guard` with a store as a filter.  The `fetchRequest` effect is only triggered when the `isIdle` store is true, indicating that no request is currently pending. `clickRequest` event increments `clicks` store. `guard` conditionally triggers `fetchRequest` with the latest value from the `clicks` store when `isIdle` is true.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/guard.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEffect, createEvent, guard } from \"effector\";\n\nconst clickRequest = createEvent();\nconst fetchRequest = createEffect((n) => new Promise((rs) => setTimeout(rs, 2500, n)));\n\nconst clicks = createStore(0).on(clickRequest, (x) => x + 1);\nconst requests = createStore(0).on(fetchRequest, (x) => x + 1);\n\nconst isIdle = fetchRequest.pending.map((pending) => !pending);\n\n/*\n1. при срабатывании clickRequest\n2. если значение isIdle равно true\n3. прочитать значение из clicks\n4. и вызвать с ним эффект fetchRequest\n*/\nguard({\n  clock: clickRequest /* 1 */,\n  filter: isIdle /* 2 */,\n  source: clicks /* 3 */,\n  target: fetchRequest /* 4 */,\n});\n```\n\n----------------------------------------\n\nTITLE: Using Immer for Store Updates (TypeScript)\nDESCRIPTION: This snippet illustrates how to use Immer to simplify updates to stores containing nested structures in Effector. Immer's `produce` function allows for immutable updates with mutable syntax, making it easier to modify nested objects within a store.  The example updates the theme setting within a nested user profile.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { produce } from \"immer\";\n\nconst $users = createStore<User[]>([]);\n\n$users.on(userUpdated, (users, updatedUser) =>\n  produce(users, (draft) => {\n    const user = draft.find((u) => u.id === updatedUser.id);\n    if (user) {\n      user.profile.settings.theme = updatedUser.profile.settings.theme;\n    }\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Fixing unit call from pure function - Typescript\nDESCRIPTION: Demonstrates creating new event via `createEvent` and connects events by `sample` instead of calling another event from pure function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst someHappened = createEvent<number>();\nconst another = createEvent();\nconst derived = createEvent<string>();\n\nsample({\n  clock: someHappened,\n  target: another,\n});\n\n// The same as .map(), but using `target`\nsample({\n  clock: someHappened,\n  fn: (number) => String(number),\n  target: derived,\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Effect doneData Event - Javascript\nDESCRIPTION: Demonstrates the `doneData` event of an Effector effect. It shows how to attach a watcher to the `doneData` event, which triggers after the effect has completed successfully. The watcher logs the result of the effect execution.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect((value) => value + 1);\n\nfx.doneData.watch((result) => {\n  console.log(`Эффект успешно выполнился, вернув ${result}`);\n});\n\nawait fx(2);\n// => Эффект успешно выполнился, вернув 3\n```\n\n----------------------------------------\n\nTITLE: useStore hook example (JSX)\nDESCRIPTION: Demonstrates how to use the `useStore` hook to connect a React component to an Effector store. The example creates a counter store and uses `useStore` to display the current counter value.  It also shows the usage of `useEvent` to connect event handlers to effector events.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useStore.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { useStore, useEvent } from \"effector-react\";\n\nconst $counter = createStore(0);\n\nconst { incrementClicked, decrementClicked } = createApi($counter, {\n  incrementClicked: (state) => state + 1,\n  decrementClicked: (state) => state - 1,\n});\n\nconst App = () => {\n  const counter = useStore($counter);\n  const [onIncrement, onDecrement] = useEvent([incrementClicked, decrementClicked]);\n\n  return (\n    <div>\n      {counter}\n      <button onClick={onIncrement}>Increment</button>\n      <button onClick={onDecrement}>Decrement</button>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Typing Effector Effects with Generics in TypeScript\nDESCRIPTION: This code demonstrates typing Effector effects in TypeScript using generics. Explicitly defining the parameter and return types using generics provides better type safety and clarity.  This approach avoids the need for a type assertion. The example includes asynchronous operations.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\n// Base effect\n// Effect<string, User, Error>\nconst fetchUserFx = createEffect<string, User>(async (userId) => {\n  const response = await fetch(`/api/users/${userId}`);\n  const result = await response.json();\n\n  return result;\n});\n```\n\n----------------------------------------\n\nTITLE: useUnit with Events and Store (JSX)\nDESCRIPTION: Illustrates the usage of `useUnit` with multiple Effector Events and a Store in a React component. It shows how to manage incrementing and decrementing a counter state using separate events, which are triggered by respective button clicks. The component is wrapped in a `Provider` and rendered within a `Scope`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useUnit.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore, createEvent, fork } from \"effector\";\nimport { useUnit, Provider } from \"effector-react\";\n\nconst incremented = createEvent();\nconst decremented = createEvent();\n\nconst $count = createStore(0);\n\n$count.on(incremented, (count) => count + 1);\n$count.on(decremented, (count) => count - 1);\n\nconst App = () => {\n  const count = useUnit($count);\n  const on = useUnit({ incremented, decremented });\n  // or\n  const [a, b] = useUnit([incremented, decremented]);\n\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => on.incremented()}>increment</button>\n      <button onClick={() => on.decremented()}>decrement</button>\n    </>\n  );\n};\n\nconst scope = fork();\n\nrender(\n  () => (\n    <Provider value={scope}>\n      <App />\n    </Provider>\n  ),\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Creating an Event with a specific type - Typescript\nDESCRIPTION: Demonstrates how to create an event with a defined type using `createEvent`. The type of the argument for the event must be provided as a generic type argument.  In this example, the `ItemAdded` interface defines the structure of the event's data.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\ninterface ItemAdded {\n  id: string;\n  title: string;\n}\n\nconst itemAdded = createEvent<ItemAdded>();\n```\n\n----------------------------------------\n\nTITLE: Fork with Initial Store Values (TypeScript)\nDESCRIPTION: Illustrates how to set initial store values when creating a forked scope using the `values` option.  It demonstrates three different ways to pass initial values: an array of tuples, a Map, and a plain object.  Requires `fork` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/fork.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfork({\n  values: [\n    [$user, \"alice\"],\n    [$age, 21],\n  ],\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfork({\n  values: new Map().set($user, \"alice\").set($age, 21),\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfork({\n  values: {\n    [$user.sid]: \"alice\",\n    [$age.sid]: 21,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Messages Store on Message Delete - TypeScript\nDESCRIPTION: This snippet updates the `$messages` store after a message is successfully deleted. It uses the `on` method to react to the `messageApi.messageDeleteFx.done` event. It filters the existing messages in the store, removing the message that was deleted, and sets the filtered list as the new value of the store.  It takes the `toDelete` parameter from the successful deletion effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\n$messages.on(messageApi.messageDeleteFx.done, (messages, { params: toDelete }) =>\n  messages.filter((message) => message.id !== toDelete.id),\n);\n```\n\n----------------------------------------\n\nTITLE: ToDo Creator with Effector and React\nDESCRIPTION: This TypeScript/JSX code defines a React application with two independent ToDo lists, managed using Effector. It leverages Effector's `createStore`, `createEvent`, and `sample` to manage state and side effects. The `effector-react` library's `useUnit` and `useList` hooks are used to connect Effector stores to the React component, ensuring reactive updates.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/todo-creator.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { createStore, createEvent, sample } from \"effector\";\nimport { useUnit, useList } from \"effector-react\";\n\nfunction createTodoListApi(initial: string[] = []) {\n  const insert = createEvent<string>();\n  const remove = createEvent<number>();\n  const change = createEvent<string>();\n  const reset = createEvent<void>();\n\n  const $input = createStore<string>(\"\");\n  const $todos = createStore<string[]>(initial);\n\n  $input.on(change, (_, value) => value);\n\n  $input.reset(insert);\n  $todos.on(insert, (todos, newTodo) => [...todos, newTodo]);\n\n  $todos.on(remove, (todos, index) => todos.filter((_, i) => i !== index));\n\n  $input.reset(reset);\n\n  const submit = createEvent<React.SyntheticEvent>();\n  submit.watch((event) => event.preventDefault());\n\n  sample({\n    clock: submit,\n    source: $input,\n    target: insert,\n  });\n\n  return {\n    submit,\n    remove,\n    change,\n    reset,\n    $todos,\n    $input,\n  };\n}\n\nconst firstTodoList = createTodoListApi([\"hello, world!\"]);\nconst secondTodoList = createTodoListApi([\"hello, world!\"]);\n\nfunction TodoList({ label, model }) {\n  const input = useUnit(model.$input);\n\n  const todos = useList(model.$todos, (value, index) => (\n    <li>\n      {value}{\" \"}\n      <button type=\"button\" onClick={() => model.remove(index)}>\n        Remove\n      </button>\n    </li>\n  ));\n\n  return (\n    <>\n      <h1>{label}</h1>\n      <ul>{todos}</ul>\n      <form>\n        <label>Insert todo: </label>\n        <input\n          type=\"text\"\n          value={input}\n          onChange={(event) => model.change(event.currentTarget.value)}\n        />\n        <input type=\"submit\" onClick={model.submit} value=\"Insert\" />\n      </form>\n    </>\n  );\n}\n\nfunction App() {\n  return (\n    <>\n      <TodoList label=\"First todo list\" model={firstTodoList} />\n      <TodoList label=\"Second todo list\" model={secondTodoList} />\n    </>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n```\n\n----------------------------------------\n\nTITLE: Server-Side Rendering with Effector Scopes (Client)\nDESCRIPTION: Demonstrates the client-side portion of server-side rendering (SSR) with Effector.  It shows how to hydrate the application with the serialized state received from the server using `fork` and `hydrateRoot`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// client.tsx\nimport { hydrateRoot } from \"react-dom/client\";\nimport { fork } from \"effector\";\n\nconst scope = fork({\n  values: window.INITIAL_DATA,\n});\n\nhydrateRoot(\n  document.getElementById(\"root\"),\n  <Provider value={scope}>\n    <App />\n  </Provider>,\n);\n```\n\n----------------------------------------\n\nTITLE: Avoiding `watch` for Logic in Effector (TypeScript)\nDESCRIPTION: This example illustrates the anti-pattern of using `watch` for logic, recommending `sample`, `guard`, or `effects` instead. The `watch` function should be used only for debugging.  The correct approach separates side effects into effects and connects them using `sample`. It also uses sample to forward store data to an event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// logic in watch\n$user.watch((user) => {\n  localStorage.setItem(\"user\", JSON.stringify(user));\n  api.trackUserUpdate(user);\n  someEvent(user.id);\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// separate effects for side effects\nconst saveToStorageFx = createEffect((user: User) =>\n  localStorage.setItem(\"user\", JSON.stringify(user)),\n);\n\nconst trackUpdateFx = createEffect((user: User) => api.trackUserUpdate(user));\n\n// connect through sample\nsample({\n  clock: $user,\n  target: [saveToStorageFx, trackUpdateFx],\n});\n\n// for events also use sample\nsample({\n  clock: $user,\n  fn: (user) => user.id,\n  target: someEvent,\n});\n```\n\n----------------------------------------\n\nTITLE: Basic merge usage with effector - JavaScript\nDESCRIPTION: Demonstrates basic usage of the `merge` function to combine two events (`foo` and `bar`) into a single event (`baz`). The `watch` method is used to log when the merged event is triggered. This snippet shows how events trigger the merged event and pass their payload.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/merge.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, merge } from \"effector\";\n\nconst foo = createEvent();\nconst bar = createEvent();\nconst baz = merge([foo, bar]);\nbaz.watch((v) => console.log(\"merged event triggered: \", v));\n\nfoo(1);\n// => merged event triggered: 1\nbar(2);\n// => merged event triggered: 2\n```\n\n----------------------------------------\n\nTITLE: scopeBind Callback Usage with Effector\nDESCRIPTION: This snippet illustrates how to bind an arbitrary callback function to an Effector scope using `scopeBind`. It defines a store `$history`, an event `locationChanged`, and uses `scopeBind` within `history.listen` to ensure that the callback passed to `history.listen` is executed within the correct Effector scope.  This is particularly useful for asynchronous operations where the scope might otherwise be lost.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/scopeBind.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, attach, scopeBind } from \"effector\";\n\nconst $history = createStore(history);\nconst locationChanged = createEvent();\n\nconst listenToHistoryFx = attach({\n  source: $history,\n  effect: (history) => {\n    return history.listen(\n      scopeBind((location) => {\n        locationChanged(location);\n      }),\n    );\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Timer Logic with Effector Effects\nDESCRIPTION: This code implements the core timer logic using Effector effects. It includes effects for starting and stopping the timer using `setInterval` and `clearInterval` respectively. The snippet also demonstrates the usage of stores to manage the timer's ID and the interaction between events, effects, and stores using `sample`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst TIMEOUT = 1_000;\n\nconst timerStopped = createEvent();\nconst timerReset = createEvent();\nconst timerStarted = createEvent();\nconst tick = createEvent();\n\n// start timer\nconst startFx = createEffect(() => {\n  const intervalId = setInterval(() => {\n    // here's the whole problem\n    tick();\n  }, TIMEOUT);\n\n  return intervalId;\n});\n\n// stop and clear timer\nconst stopFx = createEffect((timerId: number) => {\n  clearInterval(timerId);\n});\n\n// timer id\nexport const $timerId = createStore<null | number>(null)\n  .on(startFx.doneData, (_, timerId) => timerId)\n  .on(stopFx.finally, () => null);\n\n// start timer logic\nsample({\n  clock: timerStarted,\n  filter: $timerId.map((timerId) => !timerId),\n  target: startFx,\n});\n\n// stop timer logic\nsample({\n  clock: timerStopped,\n  source: $timerId,\n  filter: Boolean,\n  target: stopFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Messages Store on Message Send - TypeScript\nDESCRIPTION: This snippet updates the `$messages` store when a message is successfully sent using the `messageSendFx.doneData` event. It appends the new message to the existing list of messages in the store. The store updates its value when the message send effect completes successfully and provides the new message as doneData.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\n$messages.on(messageApi.messageSendFx.doneData, (messages, newMessage) => [\n  ...messages,\n  newMessage,\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating Send Message Effect - Typescript\nDESCRIPTION: Creates an Effector effect to send messages through an existing WebSocket connection. It uses `sample` to link message sending to the current socket, ensuring messages are only sent if a connection exists.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst sendMessageFx = createEffect((params: { socket: WebSocket; message: string }) => {\n  params.socket.send(params.message);\n});\n\n// Link message sending with current socket\nsample({\n  clock: messageSent,\n  source: $connection,\n  filter: Boolean, // Send only if connection exists\n  fn: (socket, message) => ({\n    socket,\n    message,\n  }),\n  target: sendMessageFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Conditional Event Triggering with sample\nDESCRIPTION: This code snippet demonstrates how to conditionally trigger an event in Effector using the `sample` function. The `actionExecuted` event will only be triggered when the `buttonClicked` event occurs and the `$isEnabled` store has a value of `true`. This makes the data flow more explicit and predictable compared to using `watch` or other handlers directly.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst buttonClicked = createEvent<void>();\nconst $isEnabled = createStore(true);\n\n// Событие сработает только если $isEnabled равно true\nsample({\n  clock: buttonClicked,\n  filter: $isEnabled,\n  target: actionExecuted,\n});\n```\n\n----------------------------------------\n\nTITLE: Typing `createApi` in TypeScript\nDESCRIPTION: This snippet shows how to use the `createApi` function in Effector with TypeScript to create events with automatically inferred types. By providing type information in the reducers (second argument), TypeScript can accurately determine the types of the generated events.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst $count = createStore(0);\n\nconst { add, sub } = createApi($count, {\n  add: (x, add: number) => x + add,\n  sub: (x, sub: number) => x - sub,\n});\n\n// add has type Event<number>\n// sub has type Event<number>\n```\n\n----------------------------------------\n\nTITLE: Creating and updating a Store - Effector (JavaScript)\nDESCRIPTION: This example illustrates how to create a store using `createStore` and update it based on an event using the `on` method. The store `$supers` holds an array of superhero objects, and the `superAdded` event is used to add new superheroes to the store. When the event is triggered, the store is updated with a new state that includes the added superhero.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/core-concepts.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\n// create event\nconst superAdded = createEvent();\n\n// create store\nconst $supers = createStore([\n  {\n    name: \"Spider-man\",\n    role: \"hero\",\n  },\n  {\n    name: \"Green goblin\",\n    role: \"villain\",\n  },\n]);\n\n// update store on event triggered\n$supers.on(superAdded, (supers, newSuper) => [...supers, newSuper]);\n\n// trigger event\nsuperAdded({\n  name: \"Rhino\",\n  role: \"villain\",\n});\n```\n\n----------------------------------------\n\nTITLE: Using Gate to Fetch and Display Todo Data\nDESCRIPTION: This code snippet demonstrates how to use the `Gate` component from `effector-react` to manage data flow between a React component (`App`) and an Effector store (`$todo`). It fetches a Todo item from a mock API using `createEffect` and updates the store. The `TodoGate` component is used to trigger the `getTodoFx` effect whenever its `id` prop changes. The `useUnit` hook is used to subscribe to the store and the loading state of the effect. Dependencies include `effector`, `effector-react`, and `react`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/gate.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEffect, sample } from \"effector\";\nimport { useUnit, createGate } from \"effector-react\";\n\n// Effect for api request\nconst getTodoFx = createEffect(async ({ id }) => {\n  const req = await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`);\n  return req.json();\n});\n\n// Our main store\nconst $todo = createStore(null);\nconst TodoGate = createGate();\n\n$todo.on(getTodoFx.doneData, (_, todo) => todo);\n\n// We call getTodoFx effect every time Gate updates its state.\nsample({ clock: TodoGate.state, target: getTodoFx });\n\nTodoGate.open.watch(() => {\n  //called each time when TodoGate is mounted\n});\nTodoGate.close.watch(() => {\n  //called each time when TodoGate is unmounted\n});\n\nfunction Todo() {\n  const [todo, loading] = useUnit([$todo, getTodoFx.pending]);\n\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!todo || Object.keys(todo).length === 0) {\n    return <div>empty</div>;\n  }\n\n  return (\n    <div>\n      <p>title: {todo.title}</p>\n      <p>id: {todo.id}</p>\n    </div>\n  );\n}\n\nconst App = () => {\n  // value which need to be accessed outside from react\n  const [id, setId] = React.useState(0);\n\n  return (\n    <>\n      <button onClick={() => setId(id + 1)}>Get next Todo</button>\n      {/*In this situation, we have the ability to simultaneously\n      render a component and make a request, rather than wait for the component*/}\n      <TodoGate id={id} />\n      <Todo />\n    </>\n  );\n};\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n```\n\n----------------------------------------\n\nTITLE: createStore with custom serialize\nDESCRIPTION: Demonstrates a custom `serialize` configuration for handling `Date` objects. It converts `Date` objects to ISO strings during serialization and parses ISO strings back to `Date` objects during deserialization.  This addresses the issue of `Date` objects not being correctly parsed by `JSON.parse` during server-side rendering.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createStore.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, serialize, fork, allSettled } from \"effector\";\n\nconst saveDate = createEvent();\nconst $date = createStore<null | Date>(null, {\n  // Date object is automatically serialized to ISO date string by JSON.stringify\n  // but it is not parsed to Date object by JSON.parse\n  // which will lead to a mismatch during server side rendering\n  //\n  // Custom `serialize` config solves this issue\n  serialize: {\n    write: (dateOrNull) => (dateOrNull ? dateOrNull.toISOString() : dateOrNull),\n    read: (isoStringOrNull) => (isoStringOrNull ? new Date(isoStringOrNull) : isoStringOrNull),\n  },\n}).on(saveDate, (_, p) => p);\n\nconst serverScope = fork();\n\nawait allSettled(saveDate, { scope: serverScope, params: new Date() });\n\nconst serverValues = serialize(serverScope);\n// `serialize.write` of `$date` store is called\n\nconsole.log(serverValues);\n// => { nq1e2rb: \"2022-11-05T15:38:53.108Z\" }\n// Date object saved as ISO string\n\nconst clientScope = fork({ values: serverValues });\n// `serialize.read` of `$date` store is called\n\nconst currentValue = clientScope.getState($date);\nconsole.log(currentValue);\n// => Date 11/5/2022, 10:40:13 PM\n// ISO date string is parsed back to Date object\n```\n\n----------------------------------------\n\nTITLE: Restore store from effect - JavaScript\nDESCRIPTION: Creates a store that is updated with the successful result of an effect. The store is initialized with a default value.  The store's value is updated when the effect completes successfully. Requires `createEffect` and `restore` from effector. Uses async/await.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/restore.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect, restore } from \"effector\";\n\nconst fx = createEffect(() => \"foo\");\nconst $store = restore(fx, \"default\");\n\n$store.watch((state) => console.log(\"state: \", state));\n// => state: default\n\nawait fx();\n// => state: foo\n```\n\n----------------------------------------\n\nTITLE: Forward Between Arrays - Effector (JavaScript)\nDESCRIPTION: This example showcases forwarding updates between arrays of units (events). When either `firstSource` or `secondSource` is triggered, both `firstTarget` and `secondTarget` are triggered with the same payload. `createEvent` from effector is required.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/forward.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, forward } from \"effector\";\n\nconst firstSource = createEvent();\nconst secondSource = createEvent();\n\nconst firstTarget = createEvent();\nconst secondTarget = createEvent();\n\nforward({\n  from: [firstSource, secondSource],\n  to: [firstTarget, secondTarget],\n});\n\nfirstTarget.watch((e) => console.log(\"first target\", e));\nsecondTarget.watch((e) => console.log(\"second target\", e));\n\nfirstSource(\"A\");\n// => first target A\n// => second target A\nsecondSource(\"B\");\n// => first target B\n// => second target B\n```\n\n----------------------------------------\n\nTITLE: Implementing Chat History Component\nDESCRIPTION: This code implements the `ChatHistory` component using `effector-react` hooks to connect to the Effector store. It retrieves the list of messages and a flag indicating if a message is being deleted, then renders the message list, providing delete functionality. It depends on `useList` and `useUnit` hooks from the effector-react library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\n// File: /src/pages/chat/page.tsx\nimport { useList, useUnit } from \"effector-react\";\nimport * as model from \"./model\";\n\n// export function ChatPage { ... }\n\nfunction ChatHistory() {\n  const [messageDeleting, onMessageDelete] = useUnit([\n    model.$messageDeleting,\n    model.messageDeleteClicked,\n  ]);\n\n  // Hook `useList` allows React not rerender messages really doesn't changed\n  const messages = useList(model.$messages, (message) => (\n    <div className=\"message-item\" key={message.timestamp}>\n      <h3>From: {message.author.name}</h3>\n      <p>{message.text}</p>\n      <button onClick={() => onMessageDelete(message)} disabled={messageDeleting}>\n        {messageDeleting ? \"Deleting\" : \"Delete\"}\n      </button>\n    </div>\n  ));\n  // We don't need `useCallback` here because we pass function to an HTML-element, not a custom component\n\n  return <div className=\"chat-history\">{messages}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Effector Split with Matching Function\nDESCRIPTION: Demonstrates using `split` with matching functions to route data based on boolean return values.  The `match` property is an object mapping case names to functions that receive data from the `source` and return a boolean.  Cases are defined with `first`, `second`, and the default `__`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>,\n  match: {\n    // функция сопоставления\n    first: (value: T) => boolean,\n    second: (value: T) => boolean\n  },\n  cases: {\n    first: Unit<T> | Unit<T>[],\n    second: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Restore stores from shape object - JavaScript\nDESCRIPTION: Creates a set of stores from an object containing initial values. Each property in the input object becomes a store initialized with the corresponding value.  Uses object destructuring to assign the resulting stores to variables. Requires `restore` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/restore.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { restore } from \"effector\";\n\nconst { foo: $foo, bar: $bar } = restore({\n  foo: \"foo\",\n  bar: 0,\n});\n\n$foo.watch((foo) => {\n  console.log(\"foo\", foo);\n});\n// => foo 'foo'\n$bar.watch((bar) => {\n  console.log(\"bar\", bar);\n});\n// => bar 0\n```\n\n----------------------------------------\n\nTITLE: Deleting Message with Effector - TypeScript\nDESCRIPTION: This snippet deletes a message using Effector. It uses `sample` to trigger the `messageApi.messageDeleteFx` effect when the `messageDeleteClicked` event occurs. The target effect handles the actual deletion logic.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nsample({\n  clock: messageDeleteClicked,\n  target: messageApi.messageDeleteFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Data Loading on Page Mount\nDESCRIPTION: This snippet demonstrates how to use Effector's `sample` function to trigger data loading effects when the `pageMounted` event is fired.  It loads both messages and user session data concurrently when the page loads.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_15\n\nLANGUAGE: ts\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\n// Не забудьте про import { sample } from \"effector\"\nimport { Message, messageApi, sessionApi } from \"shared/api\";\nimport { $session } from \"entities/session\";\n\n// export stores\n// export events\n\n// Здесь место для логики\n\n// Вы можете прочитать этот код так:\n// При загрузке страницы, одновременно вызываются загрузка сообщений и сессия пользователя\nsample({\n  clock: pageMounted,\n  target: [messageApi.messagesLoadFx, sessionApi.sessionLoadFx],\n});\n```\n\n----------------------------------------\n\nTITLE: Basic Guard Example (JavaScript)\nDESCRIPTION: This example demonstrates a basic usage of the `guard` function to conditionally trigger an effect based on a store's value. It creates an event, an effect, and two stores, and then uses `guard` to trigger the `fetchRequest` effect when the `$isIdle` store is true and the `clickRequest` event occurs.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/guard.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEffect, createEvent, guard } from \"effector\";\n\nconst clickRequest = createEvent();\nconst fetchRequest = createEffect((n) => new Promise((rs) => setTimeout(rs, 2500, n)));\n\nconst $clicks = createStore(0).on(clickRequest, (x) => x + 1);\nconst $requestsCount = createStore(0).on(fetchRequest, (x) => x + 1);\n\nconst $isIdle = fetchRequest.pending.map((pending) => !pending);\n\n/*\n1. on clickRequest\n2. if $isIdle is true\n3. take current $clicks value\n4. and call fetchRequest with it\n*/\nguard({\n  clock: clickRequest /* 1 */,\n  filter: $isIdle /* 2 */,\n  source: $clicks /* 3 */,\n  target: fetchRequest /* 4 */,\n});\n```\n\n----------------------------------------\n\nTITLE: Typing `split` before TS 5.5 using type predicates in TypeScript\nDESCRIPTION: This snippet demonstrates how to use type predicates with the `split` function (before TypeScript version 5.5) to correctly type the resulting events. Type predicates ensure that each resulting event receives data of the expected type based on the specified condition.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype UserMessage = { kind: \"user\"; text: string };\ntype WarnMessage = { kind: \"warn\"; warn: string };\n\nconst message = createEvent<UserMessage | WarnMessage>();\n\nconst { userMessage, warnMessage } = split(message, {\n  userMessage: (msg): msg is UserMessage => msg.kind === \"user\",\n  warnMessage: (msg): msg is WarnMessage => msg.kind === \"warn\",\n});\n// userMessage имеет тип Event<UserMessage>\n// warnMessage имеет тип Event<WarnMessage>\n```\n\n----------------------------------------\n\nTITLE: Updating Store on Effector Effect Completion\nDESCRIPTION: Illustrates how to update an Effector store upon the successful completion of an effect.  The effect fetches user repositories, and the store is updated with the fetched data.  The store's watcher logs the number of repositories. Requires effector package. Takes the username as input.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createEffect.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect(async ({ name }) => {\n  const url = `https://api.github.com/users/${name}/repos`;\n  const req = await fetch(url);\n  return req.json();\n});\n\nconst $repos = createStore([]).on(fetchUserReposFx.doneData, (_, repos) => repos);\n\n$repos.watch((repos) => {\n  console.log(`${repos.length} repos`);\n});\n// => 0 репозиториев\n\nawait fetchUserReposFx({ name: \"zerobias\" });\n// => 26 репозиториев\n```\n\n----------------------------------------\n\nTITLE: Array update in effector (TypeScript)\nDESCRIPTION: Demonstrates the correct way to update an array within an Effector store, ensuring immutability. It highlights the need to create a new array reference before modifying it to trigger store updates. Incorrect code sample is also provided for contrast.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n$items.on(addItem, (items, newItem) => {\n  const updatedItems = [...items];\n  // ✅ .push method is called on a new array\n  updatedItems.push(newItem);\n  return updatedItems;\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\n$items.on(addItem, (items, newItem) => {\n  // ❌ Error! The array reference remains the same, the store will not be updated\n  items.push(newItem);\n  return items;\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Stores, Events and Effects for Form Management (JS)\nDESCRIPTION: This snippet creates Effector stores, events, and effects for handling form submission and field updates. It defines an effect `sendFormFx` to simulate sending form data, a store `$form` to hold the form's state, and events `formSubmitted` and `fieldUpdate` to trigger form submission and field updates respectively. The `sample` function is used to trigger the effect when `formSubmitted` happens, passing the form data.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/forms.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst formSubmitted = createEvent();\nconst fieldUpdate = createEvent();\n\nconst sendFormFx = createEffect((params) => {\n  console.log(params);\n});\n\nconst $form = createStore({});\n\n$form.on(fieldUpdate, (form, { key, value }) => ({\n  ...form,\n  [key]: value,\n}));\n\nsample({\n  clock: formSubmitted,\n  source: $form,\n  target: sendFormFx,\n});\n```\n\n----------------------------------------\n\nTITLE: State combination with combine\nDESCRIPTION: Illustrates state combination using the `combine` function to create a new store that holds the combined state of multiple stores. The combined state can be an object or an array.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/combine.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// State combination\n\nconst $c: Store<{ a: A; b: B }> = combine({ a: $a, b: $b });\n\nconst $c: Store<[A, B]> = combine([$a, $b]);\n```\n\n----------------------------------------\n\nTITLE: Guard with Store Filter Alternative Syntax\nDESCRIPTION: Shows an example of using the alternative syntax of `guard` with a store as a filter.  The `target` event is triggered only when the `$unlocked` store is true. `createApi` is used to define `lock` and `unlock` actions that update `$unlocked` store.  Requires effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/guard.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore, createApi, guard } from \"effector\";\n\nconst trigger = createEvent();\nconst $unlocked = createStore(true);\nconst { lock, unlock } = createApi($unlocked, {\n  lock: () => false,\n  unlock: () => true,\n});\n\nconst target = guard(trigger, {\n  filter: $unlocked,\n});\n\ntarget.watch(console.log);\ntrigger(\"A\");\nlock();\ntrigger(\"B\"); // ничего не произошло\nunlock();\ntrigger(\"C\");\n```\n\n----------------------------------------\n\nTITLE: Effector Business Logic for Star Toggle\nDESCRIPTION: This snippet showcases the business logic behind a star button feature in a GitHub repository using Effector.  It defines an event for toggling the star, effects for starring and unstarring the repository, and stores to manage the star state and count.  The `sample` function is used to create reactive connections between these units.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/resources/mindset.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// repo.model.ts\n\n// Event – fact of an action\nconst repoStarToggled = createEvent();\n\n// Effects as additional reactions to events\n// (assuming effects return updated values)\nconst starRepoFx = createEffect(() => {});\nconst unstarRepoFx = createEffect(() => {});\n\n// Application state\nconst $isRepoStarred = createStore(false);\nconst $repoStarsCount = createStore(0);\n\n// Toggle star logic\nsample({\n  clock: repoStarToggled,\n  source: $isRepoStarred,\n  fn: (isRepoStarred) => !isRepoStarred,\n  target: $isRepoStarred,\n});\n\n// Send request to server when star is toggled\nsample({\n  clock: $isRepoStarred,\n  filter: (isRepoStarred) => isRepoStarred,\n  target: starRepoFx,\n});\n\nsample({\n  clock: $isRepoStarred,\n  filter: (isRepoStarred) => !isRepoStarred,\n  target: unstarRepoFx,\n});\n\n// Update the star count\nsample({\n  clock: [starRepoFx.doneData, unstarRepoFx.doneData],\n  target: $repoStarsCount,\n});\n```\n\n----------------------------------------\n\nTITLE: Attach Effect with Async Function - Store Example\nDESCRIPTION: This code demonstrates attaching an effect to a store and defines the types for the attached effect's parameters, done result, and fail result. If you want to remove any arguments from the `attachedFx` you need to just remove second argument from `effect` function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store: Store<T>;\n\nconst attachedFx: Effect<Params, Done, Fail> = attach({\n  source: $store,\n  async effect(source, params: Params): Done | Promise<Done> {},\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Form Change Handler (JS)\nDESCRIPTION: This snippet creates an event handler `handleChange` that is prepended to the `fieldUpdate` event. This handler transforms the DOM event from the input field into an object containing the `key` (field name) and `value` (field value). This transformed data is then passed to the `fieldUpdate` event, which updates the `$form` store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/forms.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst handleChange = fieldUpdate.prepend((event) => ({\n  key: event.target.name,\n  value: event.target.value,\n}));\n```\n\n----------------------------------------\n\nTITLE: Effector Form Handling with Split\nDESCRIPTION: This code snippet demonstrates form handling in Effector using effects, stores, events, `sample` for validation, and `split` for routing. It creates effects for displaying errors and submitting the form, stores for form data and errors, and an event to trigger form submission.  The `sample` function validates form fields, and `split` routes either to error display or form submission.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/flow-split.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst showFormErrorsFx = createEffect(() => {\n  // Logic to display errors\n});\nconst submitFormFx = createEffect(() => {\n  // Logic to submit the form\n});\n\nconst submitForm = createEvent();\n\nconst $form = createStore({\n  name: \"\",\n  email: \"\",\n  age: 0,\n}).on(submitForm, (_, submittedForm) => ({ ...submittedForm }));\n// Separate store for errors\nconst $formErrors = createStore({\n  name: \"\",\n  email: \"\",\n  age: \"\",\n}).reset(submitForm);\n\n// Validate fields and collect errors\nsample({\n  clock: submitForm,\n  source: $form,\n  fn: (form) => ({\n    name: !form.name.trim() ? \"Name is required\" : \"\",\n    email: !isValidEmail(form.email) ? \"Invalid email\" : \"\",\n    age: form.age < 18 ? \"Age must be 18+\" : \"\",\n  }),\n  target: $formErrors,\n});\n\n// Use split for routing based on validation results\nsplit({\n  source: $formErrors,\n  match: {\n    hasErrors: (errors) => Object.values(errors).some((error) => error !== \"\"),\n  },\n  cases: {\n    hasErrors: showFormErrorsFx,\n    __: submitFormFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Check if a value is an Effect - Effector\nDESCRIPTION: This JavaScript snippet demonstrates how to use `is.effect` to check if a given value is an Effector effect. It creates a store, event, and effect, then uses `is.effect` to determine their types.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/is.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain } from \"effector\";\n\nconst $store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\n\nis.effect($store);\n// => false\n\nis.effect(event);\n// => false\n\nis.effect(fx);\n// => true\n\nis.effect(createDomain());\n// => false\n\nis.effect(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: Combine with object and function\nDESCRIPTION: Combines multiple stores into an object and uses a function to derive a new value. The function receives an object with the stores' values and returns the new state. Dependencies: `Store`, `StoreWritable`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/combine.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst $a: Store<A>;\nconst $b: StoreWritable<B>;\nconst $c: Store<C> | StoreWritable<C>;\n\n$result: Store<D> = combine(\n  { a: $a, b: $b, c: $c },\n  ({ a, b, c }: { a: A; b: B; c: C }): D => result,\n);\n```\n\n----------------------------------------\n\nTITLE: Hydrating Effector React App from Server State (client.tsx)\nDESCRIPTION: This code snippet demonstrates how to hydrate an Effector React application on the client-side using the state computed during Server-Side Rendering (SSR). It involves extracting the serialized state from the global scope, creating a client-side Effector scope with the server's state, hydrating the React application using `hydrateRoot`, and triggering an initial event (`appStarted`). Dependencies include React, ReactDOM, Effector, and Effector React.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/server-side-rendering.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// client.tsx\nimport React from \"react\";\nimport { hydrateRoot } from \"react-dom/client\";\nimport { fork, allSettled } from \"effector\";\nimport { Provider } from \"effector-react\";\n\nimport { App, appStarted } from \"./app\";\n\n/**\n * 1. Находим, где сохранено состояние сервера, и извлекаем его.\n *\n * Смотрите код обработчика сервера, чтобы узнать, где оно было сохранено в HTML.\n */\nconst effectorState = globalThis._SERVER_STATE_;\nconst reactRoot = document.querySelector(\"#app\");\n\n/**\n * 2. Инициализируем клиентский scope effector с вычисленными на сервере значениями.\n */\nconst clientScope = fork({\n  values: effectorState,\n});\n\n/**\n * 3. \"Гидрируем\" состояние React в DOM-дереве.\n */\nhydrateRoot(\n  reactRoot,\n  <Provider value={clientScope}>\n    <App />\n  </Provider>,\n);\n\n/**\n * 4. Вызываем то же стартовое событие на клиенте.\n *\n * Это необязательно и зависит от того, как организована логика вашего приложения.\n */\nallSettled(appStarted, { scope: clientScope });\n```\n\n----------------------------------------\n\nTITLE: Guard with Function Predicate (JavaScript)\nDESCRIPTION: This example shows how to use `guard` with a function as a filter to conditionally trigger an effect. The `searchUser` effect is only triggered when the `submitForm` event's payload (user) has a length greater than 0.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/guard.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect, createEvent, guard } from \"effector\";\n\nconst submitForm = createEvent();\nconst searchUser = createEffect();\n\nguard({\n  source: submitForm,\n  filter: (user) => user.length > 0,\n  target: searchUser,\n});\n\nsubmitForm(\"\"); // nothing happens\nsubmitForm(\"alice\"); // ~> searchUser('alice')\n```\n\n----------------------------------------\n\nTITLE: Practical Sample Example\nDESCRIPTION: Demonstrates a practical example using `sample` to select a user and check if the user is an admin. It uses create derived store and event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, sample } from \"effector\";\n\ntype User = {\n  id: number;\n  role: string;\n};\n\nconst userSelected = createEvent<number>();\n\nconst $users = createStore<User[]>([ ]);\n\n// Create derived store, which will be keep selectedUser\nconst $selectedUser = sample({\n  clock: userSelected,\n  source: $users,\n  fn: (users, id) => users.find((user) => user.id === id) || null,\n});\n// $selectedUser has type Store<User | null>\n\n// Create derived event, which will fire only for admins\n// if selected user is admin, then event will fire instantly\nconst adminSelected = sample({\n  clock: userSelected,\n  source: $users,\n  // will worked only if user found and he is admin\n  filter: (users, id) => !!users.find((user) => user.id === id && user.role === \"admin\"),\n  fn: (users, id) => users[id],\n});\n// adminSelected has type Event<User>\n\nuserSelected(2);\n```\n\n----------------------------------------\n\nTITLE: Combining Stores with combine - Effector\nDESCRIPTION: Demonstrates how to combine multiple stores into one, either as an object or with an additional transformation. This uses `combine` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/manage-states.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { combine } from \"effector\";\n\nconst $form = combine({\n  name: $name,\n  age: $age,\n  city: $city,\n});\n\n// или с дополнительной трансформацией\nconst $formValidation = combine($name, $age, (name, age) => ({\n  isValid: name.length > 0 && age >= 18,\n  errors: {\n    name: name.length === 0 ? \"Required\" : null,\n    age: age < 18 ? \"Must be 18+\" : null,\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Integrating Effector with Vue\nDESCRIPTION: This Vue component demonstrates how to integrate Effector with Vue using the `useUnit` hook from `@effector-vue/composition`.  It consumes the $counter store and the incremented and decremented events.  Different ways of consuming the store and events are demonstrated.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_10\n\nLANGUAGE: html\nCODE:\n```\n<script setup>\n  import { useUnit } from \"@effector-vue/composition\";\n  import { $counter, incremented, decremented } from \"./counter.js\";\n  const [counter, onIncremented, onDecremented] = useUnit([$counter, incremented, decremented]);\n  // или\n  const { counter, onIncremented, onDecremented } = useUnit({ $counter, incremented, decremented });\n  // или\n  const counter = useUnit($counter);\n  const onIncremented = useUnit(incremented);\n  const onDecremented = useUnit(decremented);\n</script>\n\n<template>\n  <div>\n    <h1>Count: {{ counter }}</h1>\n    <button @click=\"onIncremented\">Increment</button>\n    <button @click=\"onDecremented\">Decrement</button>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Effects with Custom Errors (TypeScript)\nDESCRIPTION: This code demonstrates how to handle errors in Effector effects using custom error types. It showcases how to define a custom error class and throw it within an effect's handler function. Specifying the error type as a generic argument to createEffect enables the fail event to strongly type the error.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/work-with-async.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nclass CustomError extends Error {\n  // implementation\n}\n\nconst effect = createEffect<Params, ReturnValue, CustomError>(() => {\n  const response = await fetch(`/api/users/${userId}`);\n\n  if (!response.ok) {\n    // You can throw custom errors that will be caught by .fail handler\n    throw new CustomError(`Failed to fetch user: ${response.statusText}`);\n  }\n\n  return response.json();\n});\n```\n\n----------------------------------------\n\nTITLE: Effector Core Logic\nDESCRIPTION: This snippet defines the core Effector logic for managing the dynamic form. It includes events for submitting, adding messages, and changing field types. Effects are created for saving and loading the form state from local storage. Stores are defined to hold the form data, field types, and messages. Event handlers are used to update the stores in response to user actions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/dynamic-form-schema.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createEffect, createStore, createApi, sample } from \"effector\";\nimport { useList, useUnit } from \"effector-react\";\n\nconst submitForm = createEvent();\nconst addMessage = createEvent();\nconst changeFieldType = createEvent();\n\nconst showTooltipFx = createEffect(() => new Promise((rs) => setTimeout(rs, 1500)));\n\nconst saveFormFx = createEffect((data) => {\n  localStorage.setItem(\"form_state/2\", JSON.stringify(data, null, 2));\n});\nconst loadFormFx = createEffect(() => {\n  return JSON.parse(localStorage.getItem(\"form_state/2\"));\n});\n\nconst $fieldType = createStore(\"text\");\nconst $message = createStore(\"done\");\nconst $mainForm = createStore({});\nconst $types = createStore({\n  username: \"text\",\n  email: \"text\",\n  password: \"text\",\n});\n\nconst $fields = $types.map((state) => Object.keys(state));\n\n$message.on(addMessage, (_, message) => message);\n\n$mainForm.on(loadFormFx.doneData, (form, result) => {\n  let changed = false;\n\n  form = { ...form };\n  for (const key in result) {\n    const { value } = result[key];\n    if (value == null) continue;\n    if (form[key] === value) continue;\n    changed = true;\n    form[key] = value;\n  }\n  if (!changed) return;\n\n  return form;\n});\n\nconst mainFormApi = createApi($mainForm, {\n  upsertField(form, name) {\n    if (name in form) return;\n\n    return { ...form, [name]: \"\" };\n  },\n  changeField(form, [name, value]) {\n    if (form[name] === value) return;\n\n    return { ...form, [name]: value };\n  },\n  addField(form, [name, value = \"\"]) {\n    if (form[name] === value) return;\n\n    return { ...form, [name]: value };\n  },\n  deleteField(form, name) {\n    if (!(name in form)) return;\n    form = { ...form };\n    delete form[name];\n\n    return form;\n  },\n});\n\n$types.on(mainFormApi.addField, (state, [name, value, type]) => {\n  if (state[name] === type) return;\n\n  return { ...state, [name]: value };\n});\n$types.on(mainFormApi.deleteField, (state, name) => {\n  if (!(name in state)) return;\n  state = { ...state };\n  delete state[name];\n\n  return state;\n});\n$types.on(loadFormFx.doneData, (state, result) => {\n  let changed = false;\n\n  state = { ...state };\n  for (const key in result) {\n    const { type } = result[key];\n\n    if (type == null) continue;\n    if (state[key] === type) continue;\n    changed = true;\n    state[key] = type;\n  }\n  if (!changed) return;\n\n  return state;\n});\n\nconst changeFieldInput = mainFormApi.changeField.prepend((e) => [\n  e.currentTarget.name,\n  e.currentTarget.type === \"checkbox\" ? e.currentTarget.checked : e.currentTarget.value,\n]);\n\nconst submitField = mainFormApi.addField.prepend((e) => [\n  e.currentTarget.fieldname.value,\n  e.currentTarget.fieldtype.value === \"checkbox\"\n    ? e.currentTarget.fieldvalue.checked\n    : e.currentTarget.fieldvalue.value,\n  e.currentTarget.fieldtype.value,\n]);\n\nconst submitRemoveField = mainFormApi.deleteField.prepend((e) => e.currentTarget.field.value);\n\n$fieldType.on(changeFieldType, (_, e) => e.currentTarget.value);\n$fieldType.reset(submitField);\n\nsubmitForm.watch((e) => {\n  e.preventDefault();\n});\nsubmitField.watch((e) => {\n  e.preventDefault();\n  e.currentTarget.reset();\n});\nsubmitRemoveField.watch((e) => {\n  e.preventDefault();\n});\n\nsample({\n  clock: [submitForm, submitField, submitRemoveField],\n  source: { values: $mainForm, types: $types },\n  target: saveFormFx,\n  fn({ values, types }) {\n    const form = {};\n\n    for (const [key, value] of Object.entries(values)) {\n      form[key] = {\n        value,\n        type: types[key],\n      };\n    }\n\n    return form;\n  },\n});\n\nsample({\n  clock: addMessage,\n  target: showTooltipFx,\n});\nsample({\n  clock: submitField,\n  fn: () => \"added\",\n  target: addMessage,\n});\nsample({\n  clock: submitRemoveField,\n  fn: () => \"removed\",\n  target: addMessage,\n});\nsample({\n  clock: submitForm,\n  fn: () => \"saved\",\n  target: addMessage,\n});\n```\n\n----------------------------------------\n\nTITLE: Triggering Effects on Event in Effector (TypeScript)\nDESCRIPTION: This code shows how to trigger an effect when an event occurs, such as a form submission. It uses `createEvent`, `sample`, and `createEffect` from Effector.  The `sample` function connects the `formSubmitted` event to the `userLoginFx` effect, triggering the effect when the event occurs.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/work-with-async.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, sample, createEffect } from \"effector\";\n\nconst userLoginFx = createEffect(() => {\n  // some logic\n});\n\n// Event for data loading\nconst formSubmitted = createEvent();\n\n// Connect event with effect\nsample({\n  clock: formSubmitted, // When this triggers\n  target: userLoginFx, // Run this\n});\n\n// somewhere in application\nformSubmitted();\n```\n\n----------------------------------------\n\nTITLE: Socket.IO Connection State Management (TypeScript)\nDESCRIPTION: This code snippet demonstrates managing the Socket.IO connection state using an Effector store (`$socket`). The store is initialized to `null` and updated with the socket instance when the `connectFx` effect completes successfully. The store is reset to `null` when the `disconnected` event is triggered. It uses Effector's `createStore` and `.on` methods to manage state transitions based on events and effects.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// States\nconst $socket = createStore<Socket | null>(null)\n  .on(connectFx.doneData, (_, socket) => socket)\n  .reset(disconnected);\n```\n\n----------------------------------------\n\nTITLE: Typing `sample` with `filter` using type predicates in TypeScript\nDESCRIPTION: This snippet demonstrates how to use type predicates with the `sample` function and `filter` to refine the type of data passed to the `target`. Type predicates allow you to narrow down the type of the input based on a condition, ensuring that only data of the expected type reaches the target event. `msg is UserMessage` helps narrow down `message` type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype UserMessage = { kind: \"user\"; text: string };\ntype WarnMessage = { kind: \"warn\"; warn: string };\n\nconst message = createEvent<UserMessage | WarnMessage>();\nconst userMessage = createEvent<UserMessage>();\n\nsample({\n  clock: message,\n  filter: (msg): msg is UserMessage => msg.kind === \"user\",\n  target: userMessage,\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Message Text Store - TypeScript\nDESCRIPTION: This snippet updates the `$messageText` store with the text entered by the user. It uses the `on` method to react to the `messageTextChanged` event and update the store's value with the new text. The event passes the old state and the new text.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n$messageText.on(messageTextChanged, (_, text) => text);\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect to Store with Token in Effector (TS)\nDESCRIPTION: This snippet demonstrates how to use `attach` to create a specialized effect (`sendMessageFx`) that automatically uses an authorization token from a store (`$authToken`).  It utilizes `attach`, `createEffect`, and `createStore` from effector. The `baseSendMessageFx` needs to be defined.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attach, createEffect, createStore } from \"effector\";\n\ntype SendMessageParams = { text: string; token: string };\n\n// Базовый эффект для отправки данных\nconst baseSendMessageFx = createEffect<SendMessageParams, void>(async ({ text, token }) => {\n  await fetch(\"/api/messages\", {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${token}`,\n    },\n    body: JSON.stringify({ text }),\n  });\n});\n\n// Стор с токеном авторизации\nconst $authToken = createStore(\"default-token\");\n\n// Создаём специализированный эффект, который автоматически использует токен\nconst sendMessageFx = attach({\n  effect: baseSendMessageFx,\n  source: $authToken,\n  mapParams: (text: string, token) => ({\n    text,\n    token,\n  }),\n});\n\n// Теперь можно вызывать эффект только с текстом сообщения\nsendMessageFx(\"Hello!\"); // токен будет добавлен автоматически\n```\n\n----------------------------------------\n\nTITLE: useStoreMap with store and function (TypeScript)\nDESCRIPTION: This code block illustrates the function signature for using `useStoreMap` with a store and a selector function. The hook subscribes to the given store and applies the selector function to extract a derived value. The component re-renders only when the derived value changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useStoreMap.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nuseStoreMap(\n  $store: Store<State>,\n  fn: (state: State) => Result,\n): Result\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Form Components\nDESCRIPTION: This set of components implements the message form functionality.  `MessageForm` conditionally renders either `SendMessage` or `LoginForm` based on the login state. `SendMessage` allows logged-in users to type and send messages, while `LoginForm` prompts unauthenticated users to log in.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n// File: /src/pages/chat/page.tsx\nfunction MessageForm() {\n  const isLogged = useUnit(model.$loggedIn);\n  return isLogged ? <SendMessage /> : <LoginForm />;\n}\n\nfunction SendMessage() {\n  const [userName, messageText, messageSending] = useUnit([\n    model.$userName,\n    model.$messageText,\n    model.$messageSending,\n  ]);\n\n  const [handleLogout, handleTextChange, handleEnterPress, handleSendClick] = useUnit([\n    model.logoutClicked,\n    model.messageTextChanged,\n    model.messageEnterPressed,\n    model.messageSendClicked,\n  ]);\n\n  const handleKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    if (event.key === \"Enter\") {\n      handleEnterPress();\n    }\n  };\n\n  return (\n    <div className=\"message-form\">\n      <h3>{userName}</h3>\n      <input\n        value={messageText}\n        onChange={(event) => handleTextChange(event.target.value)}\n        onKeyPress={handleKeyPress}\n        className=\"chat-input\"\n        placeholder=\"Type a message...\"\n      />\n      <button onClick={() => handleSendClick()} disabled={messageSending}>\n        {messageSending ? \"Sending...\" : \"Send\"}\n      </button>\n      <button onClick={() => handleLogout()}>Log out</button>\n    </div>\n  );\n}\n\nfunction LoginForm() {\n  const handleLogin = useUnit(model.loginClicked);\n\n  return (\n    <div className=\"message-form\">\n      <div>Please, log in to be able to send messages</div>\n      <button onClick={() => handleLogin()}>Login as a random user</button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Effect .map() data transformation example\nDESCRIPTION: This example shows how to use the `.map()` method to create new events that are triggered after the original effect is called.  The `.map()` method transforms the effect's result and passes it to the new event. This allows decomposing dataflow to extract or transform data. The example extract and transform the name and role from the result of the effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst userUpdate = createEffect(({ name, role }) => {\n  console.log(name, role);\n});\nconst userNameUpdated = userUpdate.map(({ name }) => name); // you may decompose dataflow with .map() method\nconst userRoleUpdated = userUpdate.map(({ role }) => role.toUpperCase()); // either way you can transform data\n\nuserNameUpdated.watch((name) => console.log(`User's name is [${name}] now`));\nuserRoleUpdated.watch((role) => console.log(`User's role is [${role}] now`));\n\nawait userUpdate({ name: \"john\", role: \"admin\" });\n// => User's name is [john] now\n// => User's role is [ADMIN] now\n// => john admin\n```\n\n----------------------------------------\n\nTITLE: Import useEvent from effector-react\nDESCRIPTION: Imports the `useEvent` hook from the `effector-react` library. This is the basic import required to use the hook in a React component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useEvent.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useEvent } from \"effector-react\";\n```\n\n----------------------------------------\n\nTITLE: Effector Model Setup\nDESCRIPTION: Defines an Effector model with an event `incremented` and a store `$count`.  The store is updated when the event is triggered. This is a common pattern in Effector applications.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useUnit.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// model.js\nimport { createEvent, createStore, fork } from \"effector\";\n\nconst incremented = createEvent();\nconst $count = createStore(0);\n\n$count.on(incremented, (count) => count + 1);\n```\n\n----------------------------------------\n\nTITLE: React Components for Dynamic Form\nDESCRIPTION: This snippet implements the React components that render the dynamic form based on the Effector stores. It includes components for the main form, input fields, and field management forms. The `useFormField` hook is used to connect the React components to the Effector stores, providing the current value and type of each form field.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/dynamic-form-schema.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nloadFormFx.finally.watch(() => {\n  ReactDOM.render(<App />, document.getElementById(\"root\"));\n});\n\nfunction useFormField(name) {\n  const type = useStoreMap({\n    store: $types,\n    keys: [name],\n    fn(state, [field]) {\n      if (field in state) return state[field];\n\n      return \"text\";\n    },\n  });\n  const value = useStoreMap({\n    store: $mainForm,\n    keys: [name],\n    fn(state, [field]) {\n      if (field in state) return state[field];\n\n      return \"\";\n    },\n  });\n  mainFormApi.upsertField(name);\n\n  return [value, type];\n}\n\nfunction Form() {\n  const pending = useUnit(saveFormFx.pending);\n\n  return (\n    <form onSubmit={submitForm} data-form autocomplete=\"off\">\n      <header>\n        <h4>Form</h4>\n      </header>\n      {useList($fields, (name) => (\n        <InputField name={name} />\n      ))}\n\n      <input type=\"submit\" value=\"save form\" disabled={pending} />\n    </form>\n  );\n}\n\nfunction InputField({ name }) {\n  const [value, type] = useFormField(name);\n  let input = null;\n\n  switch (type) {\n    case \"checkbox\":\n      input = (\n        <input\n          id={name}\n          name={name}\n          value={name}\n          checked={value}\n          onChange={changeFieldInput}\n          type=\"checkbox\"\n        />\n      );\n      break;\n    case \"text\":\n    default:\n      input = <input id={name} name={name} value={value} onChange={changeFieldInput} type=\"text\" />;\n  }\n\n  return (\n    <>\n      <label htmlFor={name} style={{ display: \"block\" }}>\n        <strong>{name}</strong>\n      </label>\n      {input}\n    </>\n  );\n}\n\nfunction FieldForm() {\n  const currentFieldType = useUnit($fieldType);\n  const fieldValue =\n    currentFieldType === \"checkbox\" ? (\n      <input id=\"fieldvalue\" name=\"fieldvalue\" type=\"checkbox\" />\n    ) : (\n      <input id=\"fieldvalue\" name=\"fieldvalue\" type=\"text\" defaultValue=\"\" />\n    );\n\n  return (\n    <form onSubmit={submitField} autocomplete=\"off\" data-form>\n      <header>\n        <h4>Insert new field</h4>\n      </header>\n      <label htmlFor=\"fieldname\">\n        <strong>name</strong>\n      </label>\n      <input id=\"fieldname\" name=\"fieldname\" type=\"text\" required defaultValue=\"\" />\n      <label htmlFor=\"fieldvalue\">\n        <strong>value</strong>\n      </label>\n      {fieldValue}\n      <label htmlFor=\"fieldtype\">\n        <strong>type</strong>\n      </label>\n      <select id=\"fieldtype\" name=\"fieldtype\" onChange={changeFieldType}>\n        <option value=\"text\">text</option>\n        <option value=\"checkbox\">checkbox</option>\n      </select>\n      <input type=\"submit\" value=\"insert\" />\n    </form>\n  );\n}\n\nfunction RemoveFieldForm() {\n  return (\n    <form onSubmit={submitRemoveField} data-form>\n      <header>\n        <h4>Remove field</h4>\n      </header>\n      <label htmlFor=\"field\">\n        <strong>name</strong>\n      </label>\n      <select id=\"field\" name=\"field\" required>\n        {useList($fields, (name) => (\n          <option value={name}>{name}</option>\n        ))}\n      </select>\n      <input type=\"submit\" value=\"remove\" />\n    </form>\n  );\n}\n\nconst Tooltip = () => {\n  const [visible, text] = useUnit([showTooltipFx.pending, $message]);\n\n  return <span data-tooltip={text} data-visible={visible} />;\n};\n\nconst App = () => (\n  <>\n    <Tooltip />\n    <div id=\"app\">\n      <Form />\n      <FieldForm />\n      <RemoveFieldForm />\n    </div>\n  </>\n);\n```\n\n----------------------------------------\n\nTITLE: Fork: Set Initial State and Change Handler (TypeScript)\nDESCRIPTION: Illustrates setting initial state for a store and replacing the handler for an effect using `fork`. It demonstrates a test scenario where the value of `$friends` is verified after a request to the server. It uses `createEffect`, `createStore`, `fork`, and `allSettled` from Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/fork.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, createStore, fork, allSettled } from \"effector\";\n\nconst fetchFriendsFx = createEffect<{ limit: number }, string[]>(async ({ limit }) => {\n  /* some client-side data fetching */\n  return [];\n});\nconst $user = createStore(\"guest\");\nconst $friends = createStore([]);\n\n$friends.on(fetchFriendsFx.doneData, (_, result) => result);\n\nconst testScope = fork({\n  values: [[$user, \"alice\"]],\n  handlers: [[fetchFriendsFx, () => [\"bob\", \"carol\"]]],\n});\n\n/* trigger computations in scope and await all called effects */\nawait allSettled(fetchFriendsFx, {\n  scope: testScope,\n  params: { limit: 10 },\n});\n\n/* check value of store in scope */\nconsole.log(testScope.getState($friends));\n// => ['bob', 'carol']\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Async Effect Function (TypeScript)\nDESCRIPTION: Illustrates how to attach an effect using an asynchronous function that receives data from a source store and optional parameters. It highlights how scope is handled with async calls and suggests wrapping regular functions with `createEffect` to preserve scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n// Пример пользовательского кода без явных объявлений типов\nconst $foo = createStore(100);\nconst $bar = createStore(\"demo\");\n\nconst attachedFx = attach({\n  source: { foo: $foo, bar: $bar },\n  async effect({ foo, bar }, { baz }: { baz: boolean }) {\n    console.log(\"Попадание!\", { foo, bar, baz });\n  },\n});\n\nattachedFx({ baz: true });\n// => Попадание! { foo: 100, bar: \"demo\", baz: true }\n```\n\n----------------------------------------\n\nTITLE: Creating a React Field Component using useStoreMap (JSX)\nDESCRIPTION: This React component `Field` uses the `useStoreMap` hook to subscribe to changes in the `$form` store for a specific field. It takes the field's `name`, `type`, and `label` as props. The `useStoreMap` hook ensures that the component only re-renders when the value of the specific field it's tracking changes. The component renders an input field with the specified `name` and `type`, and binds the `handleChange` event to the `onChange` handler.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/forms.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst Field = ({ name, type, label }) => {\n  const value = useStoreMap({\n    store: $form,\n    keys: [name],\n    fn: (values) => values[name] ?? \"\",\n  });\n  return (\n    <div>\n      {label} <input name={name} type={type} value={value} onChange={handleChange} />\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Splitting event with match as Object with Functions - Effector - TypeScript\nDESCRIPTION: This example uses an object of functions as the `match` parameter. Each function must return a boolean value. When `paymentReceived` is triggered, the first function that returns `true` determines which case will be executed. This example processes payments based on amount ranges.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/flow-split.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: paymentReceived,\n  match: {\n    lowAmount: ({ amount }) => amount < 100,\n    mediumAmount: ({ amount }) => amount >= 100 && amount < 1000,\n    highAmount: ({ amount }) => amount >= 1000,\n  },\n  cases: {\n    lowAmount: processLowPaymentFx,\n    mediumAmount: processMediumPaymentFx,\n    highAmount: processHighPaymentFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Event with Payload in Effector\nDESCRIPTION: This code demonstrates how to create an Effector event that accepts a payload. The `requestReceived` event is created with a type definition specifying that it expects an object with `id` (number) and `title` (string) properties. This enforces type safety when the event is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst requestReceived = createEvent<{ id: number; title: string }>();\n\nrequestReceived({ id: 1, title: \"example\" });\n```\n\n----------------------------------------\n\nTITLE: Reading Store Value in Solid with useUnit\nDESCRIPTION: Shows how to access the value of an effector store in a Solid component using `useUnit` from `effector-solid`.  The `Counter` component retrieves the `$counter` store's value and renders it, noting that in Solid `useUnit` returns a signal.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useUnit } from 'effector-solid'\nimport { $counter } from './model.js'\n\nconst Counter = () => {\n  const counter = useUnit($counter)\n\n  return <div>{counter()}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Stores with createStore in effector\nDESCRIPTION: Illustrates how to create effector stores using the `createStore` function, including examples with initial values and explicit typing.  Stores `$counter`, `$user`, and `$posts` are initialized with different data types and initial values, demonstrating the flexibility of `createStore`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"effector\";\n\n// Create store with initial value\nconst $counter = createStore(0);\n// with explicit typing\nconst $user = createStore<{ name: \"Bob\"; age: 25 } | null>(null);\nconst $posts = createStore<Post[]>([ ]);\n```\n\n----------------------------------------\n\nTITLE: Effector Effect failData Event\nDESCRIPTION: Demonstrates how to use the `failData` event of an Effector Effect to handle rejections and errors. An effect is created that throws an error, and the `failData` event is used to log the error message.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect(async (value) => {\n  throw Error(value - 1);\n});\n\nfx.failData.watch((error) => {\n  console.log(`Execution failed with error ${error.message}`);\n});\n\nfx(2);\n// => Execution failed with error 1\n```\n\n----------------------------------------\n\nTITLE: Creating a React Form Component (JSX)\nDESCRIPTION: This React component `App` renders a form with `Field` components for `login` and `password`. The `onSubmit` handler of the form triggers the `formSubmitted` event.  This event then triggers the effect to send the form's data.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/forms.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst App = () => (\n  <form onSubmit={formSubmitted}>\n    <Field name=\"login\" label=\"Login\" />\n    <Field name=\"password\" type=\"password\" label=\"Password\" />\n    <button type=\"submit\">Submit!</button>\n  </form>\n);\n```\n\n----------------------------------------\n\nTITLE: Clearing Message Text Input - TypeScript\nDESCRIPTION: This snippet clears the `$messageText` store after a message is successfully sent. It uses the `on` method to react to the `messageSendFx` event and set the store's value to an empty string. This effectively clears the input field after sending a message.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\n$messageText.on(messageSendFx, () => \"\");\n```\n\n----------------------------------------\n\nTITLE: Combine with skipVoid option\nDESCRIPTION: Demonstrates how to use the `skipVoid` option with the `combine` function. The `skipVoid` option controls how the store handles `undefined` values.  Dependencies: `Store`, `StoreWritable`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/combine.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ncombine($a, $b, callback, { skipVoid: true });\n```\n\n----------------------------------------\n\nTITLE: Splitting event with split using predicates - Effector - TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of `split` in Effector. It creates an event `updateUserStatus` and splits it into multiple events based on user status strings using predicates. Each predicate checks if the `userStatus` matches a specific string value and triggers the corresponding event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/flow-split.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, split } from \"effector\";\n\nconst updateUserStatus = createEvent();\n\nconst { activeUserUpdated, idleUserUpdated, inactiveUserUpdated } = split(updateUserStatus, {\n  activeUserUpdated: (userStatus) => userStatus === \"active\",\n  idleUserUpdated: (userStatus) => userStatus === \"idle\",\n  inactiveUserUpdated: (userStatus) => userStatus === \"inactive\",\n});\n```\n\n----------------------------------------\n\nTITLE: Correct Declarative Effect Calls in Effector (Typescript)\nDESCRIPTION: This snippet demonstrates the correct approach to calling effects in Effector, using a declarative style with `sample`. Instead of calling events imperatively, it uses `sample` to connect the `loginFx.doneData` to update the `$user` store, redirect to dashboard, and show a welcome notification.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginFx = createEffect((params) => api.login(params));\n// Connect through sample\nsample({\n  clock: loginFx.doneData,\n  target: [\n    $user, // update store\n    redirectToDashboardFx,\n    showWelcomeNotificationFx,\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Launch from Effector\nDESCRIPTION: Imports the `launch` function and related types (`Unit`, `Node`) from the Effector library. This is necessary to use `launch` for triggering computations within Effector units.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/launch.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { launch, type Unit, type Node } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Effect calls inside Effects (Correct)\nDESCRIPTION: Demonstrates the correct way to call effects inside other effects and use `Promise.all` with effects in Effector, ensuring proper scope propagation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst authFx = createEffect(async () => {\n  // Safe - calling an effect inside an effect\n  await loginFx();\n\n  // Safe - Promise.all with effects\n  await Promise.all([loadProfileFx(), loadSettingsFx()]);\n});\n```\n\n----------------------------------------\n\nTITLE: Effect .use() method example\nDESCRIPTION: This example demonstrates how to use the `.use()` method to assign a handler function to an Effect.  The handler function is an async function that fetches user repositories from GitHub based on a provided username.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect();\n\nfetchUserReposFx.use(async (params) => {\n  console.log(\"fetchUserReposFx called with\", params);\n\n  const url = `https://api.github.com/users/${params.name}/repos`;\n  const req = await fetch(url);\n  return req.json();\n});\n\nfetchUserReposFx({ name: \"zerobias\" });\n// => fetchUserRepos called with {name: 'zerobias'}\n```\n\n----------------------------------------\n\nTITLE: Sending Message with Effector Sample - TypeScript\nDESCRIPTION: This snippet sends a message to the server using Effector's `sample` function. It merges two events, `messageEnterPressed` and `messageSendClicked`, into a single `messageSend` event. Then, it samples data from the `$session` and `$messageText` stores when `messageSend` is triggered, passing the author and message text to the `messageApi.messageSendFx` effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n// We have two different events to send message\n// Let event `messageSend` react on any of them\nconst messageSend = merge([messageEnterPressed, messageSendClicked]);\n\n// We need to take a message text and author info then send it to the effect\nsample({\n  clock: messageSend,\n  source: { author: $session, text: $messageText },\n  target: messageApi.messageSendFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Logout Functionality\nDESCRIPTION: This code implements the logout functionality. It triggers the `sessionApi.sessionDeleteFx` effect when the `logoutClicked` event occurs. Regardless of whether the deletion succeeds or fails, the `$session` store is reset to `null` after effect completion.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_19\n\nLANGUAGE: ts\nCODE:\n```\n// File: /src/pages/chat/model.ts\n// When logout clicked we need to reset session and clear our storage\nsample({\n  clock: logoutClicked,\n  target: sessionApi.sessionDeleteFx,\n});\n// In any case, failed or not, we need to reset session store\nsample({\n  clock: sessionApi.sessionDeleteFx.finally,\n  fn: () => null,\n  target: $session,\n});\n```\n\n----------------------------------------\n\nTITLE: Get store value from scope using getState\nDESCRIPTION: Shows how to retrieve the value of a store within a specific `Scope` using the `.getState()` method. This allows you to access the store's value in an isolated instance of the application.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Scope.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst scope: Scope;\nconst $value: Store<T> | StoreWritable<T>;\n\nconst value: T = scope.getState($value);\n```\n\n----------------------------------------\n\nTITLE: Using scopeBind Inside Effector Effects (TypeScript)\nDESCRIPTION: This snippet illustrates the correct usage of `scopeBind` within Effector effects to avoid scope-related errors.  `scopeBind` ensures that events and effects are executed within the correct scope, especially when dealing with asynchronous operations like `setTimeout`.  It's important to bind the event *inside* the effect, not in a callback function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/troubleshooting.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst event = createEvent();\n\n// ❌ - Do not call scopeBind inside callbacks\nconst effectFx = createEffect(() => {\n  setTimeout(() => {\n    scopeBind(event)();\n  }, 1111);\n});\n\n// ✅ - Use scopeBind inside the effect\nconst effectFx = createEffect(() => {\n  const scopeEvent = scopeBind(event);\n\n  setTimeout(() => {\n    scopeEvent();\n  }, 1111);\n});\n```\n\n----------------------------------------\n\nTITLE: Sample with Object of Stores\nDESCRIPTION: Demonstrates sampling an object of stores, where the values of all stores are combined into an object and passed to the target unit. This shows the capability to aggregate multiple stores into a single data structure using `sample`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/sample.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, sample } from \"effector\";\n\nconst trigger = createEvent();\n\nconst $a = createStore(\"A\");\nconst $b = createStore(1);\n\n// Target has type `Event<{ a: string, b: number }>`\nconst target = sample({\n  clock: trigger,\n  source: { a: $a, b: $b },\n});\n\ntarget.watch((obj) => {\n  console.log(\"sampled object\", obj);\n});\n\ntrigger();\n// => sampled object {a: 'A', b: 1}\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with `source` and `mapParams`\nDESCRIPTION: This snippet demonstrates attaching an effect to a store using the `source` option, in addition to `mapParams`. It shows how the value of the store is passed to `mapParams`, along with the payload, to transform the data before calling the original effect. If `mapParams` throws, the attached effect fails and the original is not triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst attachedFx = attach({\n  source,\n  mapParams,\n  effect: originalFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Sample with `submitForm` example\nDESCRIPTION: This example demonstrates sampling a store's state with an event trigger to create an effect's parameters. It showcases the usage of `clock`, `source`, `fn`, and `target` options within the `sample` configuration.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/sample.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\nconst submitForm = createEvent();\nconst signInFx = createEffect((params) => {\n  console.log(params);\n});\n\nconst $userName = createStore(\"john\");\n\nsample({\n  clock: submitForm /* 1 */,\n  source: $userName /* 2 */,\n  fn: (name, password) => ({ name, password }) /* 3 */,\n  target: signInFx /* 4 */,\n});\n\nsubmitForm(12345678);\n// 1. when submitForm is called with params (12345678)\n// 2. take $userName store`s state ('john')\n// 3. transform payload from event (1) and current store`s state (2)\n// 4. trigger effect signInFx with params received at the step (3)\n```\n\n----------------------------------------\n\nTITLE: Tracking Effect Execution State in Effector (TypeScript)\nDESCRIPTION: This code demonstrates how Effector automatically tracks the execution state of an effect using `pending`, `done`, `fail`, and `finally` events.  It shows how to watch these events to log the effect's status and results. The code defines an effect `fetchUserFx` and attaches watchers to its state events to log information about its execution.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/work-with-async.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst fetchUserFx = createEffect(() => {\n  /* external api call */\n});\n\nfetchUserFx.pending.watch((isPending) => console.log(\"Pending:\", isPending));\n\nfetchUserFx.done.watch(({ params, result }) => console.log(`Fetched user ${params}:`, result));\n\nfetchUserFx.finally.watch((value) => {\n  if (value.status === \"done\") {\n    console.log(\"fetchUserFx resolved \", value.result);\n  } else {\n    console.log(\"fetchUserFx rejected \", value.error);\n  }\n});\n\nfetchUserFx.fail.watch(({ params, error }) =>\n  console.error(`Failed to fetch user ${params}:`, error),\n);\n\nfetchUserFx();\n```\n\n----------------------------------------\n\nTITLE: Filtering Events with sample\nDESCRIPTION: Illustrates how to filter events using the `sample` method with a `filter` condition.  Two events, `adminClicked` and `typeSafeAdminClicked`, are created, triggered only when the `userClicked` event has a user with the role \"admin\".  The second example demonstrates type-safe filtering. It imports `sample` and `createEvent` from the `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/events.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample, createEvent } from \"effector\";\n\ntype User = { id: number; role: \"admin\" | \"user\" };\ntype Admin = { id: number; role: \"admin\" };\n\nconst userClicked = createEvent<User>();\n\n// Event will trigger only for admins\nconst adminClicked = sample({\n  clock: userClicked,\n  filter: ({ role }) => role === \"admin\",\n});\n\n// Creating type-safe event\nconst typeSafeAdminClicked = sample({\n  clock: userClicked,\n  filter: (user): user is Admin => user.role === \"admin\",\n});\n```\n\n----------------------------------------\n\nTITLE: Effector Client-Side Hydration\nDESCRIPTION: Demonstrates how to hydrate Effector stores on the client-side using the serialized state from the server.  The client-side code forks a new Effector scope and assigns the server state (obtained from the `window` object) to the `values` property of the scope's configuration. This automatically hydrates the stores with the server-side data using SIDs.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// src/client/index.ts\nimport { Provider } from \"effector-react\";\n\nconst serverState = window._SERVER_STATE_;\n\nconst clientScope = fork({\n  values: serverState, // просто назначаем серверное состояние на scope\n});\n\nclientScope.getState($lastName); // \"Doe\"\n\nhydrateApp(\n  <Provider value={clientScope}>\n    <App />\n  </Provider>,\n);\n```\n\n----------------------------------------\n\nTITLE: Combining Stores with Transformation (multiple stores, function)\nDESCRIPTION: This snippet demonstrates how to combine multiple stores using a transformation function. The function receives the values of the stores as arguments and returns a new value, which becomes the value of the resulting derived store. The function must be pure.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/combine.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst $a: Store<A>\nconst $b: StoreWritable<B>\nconst $c: Store<C> | StoreWritable<C>\n\n$result: Store<D> = combine(\n  $a, $b, $c, ...,\n  (a: A, b: B, c: C, ...) => result\n)\n```\n\n----------------------------------------\n\nTITLE: Sampling with an Array of Stores (TypeScript)\nDESCRIPTION: Demonstrates how to use an array of stores as the `source` in the `sample` function.  The `trigger` event initiates the sampling, and the `target` event receives an array containing the values from the specified stores. Typescript requires `as const` to type the store array.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/sample.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, sample } from \"effector\";\n\nconst trigger = createEvent();\n\nconst $a = createStore(\"A\");\nconst $b = createStore(1);\n\n// Target has type `Event<[string, number]>`\nconst target = sample({\n  clock: trigger,\n  source: [$a, $b] as const,\n});\n\ntarget.watch((obj) => {\n  console.log(\"sampled array\", obj);\n});\n\n// You can easily destructure arguments to set explicit names\ntarget.watch(([a, b]) => {\n  console.log(\"explicit names\", a, b);\n});\n\ntrigger();\n// => sampled array [\"A\", 1]\n// => explicit names \"A\" 1\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Effect for Asynchronous Form Submission (JS)\nDESCRIPTION: This snippet defines an Effector effect `sendFormFx` that simulates sending form data asynchronously. It takes a `FormData` object as input and returns a promise that resolves after 1 second with a message indicating successful sign-in, using the name from the form data. This simulates a network request.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/forms.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst sendFormFx = createEffect(\n  (formData) => new Promise((rs) => setTimeout(rs, 1000, `Signed in as [${formData.get(\"name\")}]`)),\n);\n```\n\n----------------------------------------\n\nTITLE: Split with Matcher Store\nDESCRIPTION: This code snippet demonstrates how to use `split` with matcher stores. The `match` field contains an object with boolean stores. The `cases` object contains units to which data is passed based on the boolean values from the stores.  If no case matches, the data is passed to `cases.__`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>\n  match: {\n    // matcher store\n    first: Store<boolean>,\n    second: Store<boolean>\n  },\n  cases: {\n    first: Unit<T> | Unit<T>[],\n    second: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a React Form Component with Uncontrolled Inputs (JSX)\nDESCRIPTION: This React component `App` renders a form with uncontrolled input fields for `name` and `password`. The `onSubmit` handler of the form calls the `submit` function, which is obtained using the `useUnit` hook with the `onSubmit` event. The Loader and SubmitButton components are also included in the form.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/forms.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nconst App = () => {\n  const submit = useUnit(onSubmit);\n  return (\n    <form\n      onSubmit={(e) => {\n        e.preventDefault();\n        submit(e);\n      }}\n    >\n      Login: <input name=\"name\" />\n      <br />\n      Password: <input name=\"password\" type=\"password\" />\n      <br />\n      <Loader />\n      <SubmitButton />\n    </form>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Filtering and Watching Events with Stores (Effector)\nDESCRIPTION: Demonstrates how to filter events and update a store based on the filtered events. Only positive numbers trigger the update of `$lastPositive`. Requires the `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst numbers = createEvent();\nconst positiveNumbers = numbers.filter({\n  fn: ({ x }) => x > 0,\n});\n\nconst $lastPositive = createStore(0).on(positiveNumbers, (n, { x }) => x);\n\n$lastPositive.watch((x) => {\n  console.log(\"последнее положительное:\", x);\n});\n\n// => последнее положительное: 0\n\nnumbers({ x: 0 });\n// нет реакции\n\nnumbers({ x: -10 });\n// нет реакции\n\nnumbers({ x: 10 });\n// => последнее положительное: 10\n```\n\n----------------------------------------\n\nTITLE: Monitoring Gate State Updates in React with Effector\nDESCRIPTION: This code initializes a Gate using `createGate` from `effector-react`. It then uses `.state.watch` to log gate state updates to the console, demonstrating how to monitor the gate's state changes when the component mounts. It also uses the `useGate` hook to connect the gate to a React component, passing initial props.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/Gate.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createGate, useGate } from \"effector-react\";\n\nconst Gate = createGate();\n\nGate.state.watch((state) => console.info(\"gate state updated\", state));\n\nfunction App() {\n  useGate(Gate, { props: \"yep\" });\n  return <div>Example</div>;\n}\n\nReactDOM.render(<App />, root);\n// => gate state updated { props: \"yep\" }\n```\n\n----------------------------------------\n\nTITLE: Rendering Message List with useList and Keys\nDESCRIPTION: This snippet uses the `useList` hook to render the list of messages. It specifies the `keys` option to ensure the component re-renders when the `messageDeleting` state changes. This is important because `useList` caches renders, and without specifying `keys`, the component wouldn't update when a message is being deleted.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_30\n\nLANGUAGE: tsx\nCODE:\n```\n// Файл: /src/pages/chat/page.tsx\nconst messages = useList(model.$messages, {\n  keys: [messageDeleting],\n  fn: (message) => (\n    <div className=\"message-item\" key={message.timestamp}>\n      <h3>From: {message.author.name}</h3>\n      <p>{message.text}</p>\n      <button onClick={() => handleMessageDelete(message)} disabled={messageDeleting}>\n        {messageDeleting ? \"Deleting\" : \"Delete\"}\n      </button>\n    </div>\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating WebSocket Connection Effect - Typescript\nDESCRIPTION: Creates an Effector effect to establish a WebSocket connection to a given URL. The effect handles connection opening, message reception, connection closing, and error handling. `scopeBind` is used to bind events to the current execution scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst connectWebSocketFx = createEffect((url: string): Promise<WebSocket> => {\n  const ws = new WebSocket(url);\n\n  const scopeDisconnected = scopeBind(disconnected);\n  const scopeRawMessageReceived = scopeBind(rawMessageReceived);\n\n  return new Promise((res, rej) => {\n    ws.onopen = () => {\n      res(ws);\n    };\n\n    ws.onmessage = (event) => {\n      scopeRawMessageReceived(event.data);\n    };\n\n    ws.onclose = () => {\n      scopeDisconnected();\n    };\n\n    ws.onerror = (err) => {\n      scopeDisconnected();\n      rej(err);\n    };\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple Events with merge\nDESCRIPTION: Demonstrates merging multiple events into a single event using the `merge` method and using `sample` with array of events. Any of the trigger events will trigger the `someActionHappened` event. It imports `createEvent` from the `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/events.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst buttonClicked = createEvent();\nconst linkClicked = createEvent();\nconst iconClicked = createEvent();\n\n// Any of these events will trigger someActionHappened\nconst anyClicked = merge([buttonClicked, linkClicked, iconClicked]);\n\nsample({\n  clock: anyClicked,\n  target: someActionHappened,\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst buttonClicked = createEvent();\nconst linkClicked = createEvent();\nconst iconClicked = createEvent();\n\n// Any of these events will trigger someActionHappened\nsample({\n  clock: [buttonClicked, linkClicked, iconClicked],\n  target: someActionHappened,\n});\n```\n\n----------------------------------------\n\nTITLE: Session Entity Definition\nDESCRIPTION: This snippet defines the session entity using Effector. It creates a store to hold the session data and a derived store to determine if the user is logged in. `$isLogged` is automatically updated whenever `$session` changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_13\n\nLANGUAGE: ts\nCODE:\n```\n// Файл: /src/entities/session/index.ts\nimport { Session } from \"shared/api\";\nimport { createStore } from \"effector\";\n\n// Сущность просто хранит сессию и некоторую внутреннюю информацию о ней\nexport const $session = createStore<Session | null>(null);\n// Когда стор `$session` обновляется, то стор `$isLogged` тоже будет обновлен\n// Они синхронизированы. Производный стор зависит от данных из исходного\nexport const $isLogged = $session.map((session) => session !== null);\n```\n\n----------------------------------------\n\nTITLE: Typing Effector Effects with Common Usage in TypeScript\nDESCRIPTION: This code demonstrates typing Effector effects in TypeScript using common usage. It shows how TypeScript infers types based on the handler function's arguments and return type without explicit generics. The example includes asynchronous operations and type assertions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\n// Base effect\n// Effect<string, User, Error>\nconst fetchUserFx = createEffect(async (userId: string) => {\n  const response = await fetch(`/api/users/${userId}`);\n  const result = await response.json();\n\n  return result as User;\n});\n```\n\n----------------------------------------\n\nTITLE: useUnit with Shape (Store and Event)\nDESCRIPTION: Demonstrates using `useUnit` with an object containing both an Effector store (`$count`) and an event (`incremented`).  This returns an object `count` (reactive value of $count) and `handleClick` (function to trigger the incremented event). This allows integrating multiple Effector units with a single `useUnit` call, streamlining the data binding process.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useUnit.md#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n// App.vue\n\n<script setup>\n  import { useUnit } from \"effector-vue/composition\";\n\n  import { $count, incremented } from \"./model.js\";\n\n  const { count, handleClick } = useUnit({ count: $count, handleClick: incremented });\n</script>\n\n<template>\n  <p>Count: {{ count }}</p>\n  <button @click=\"handleClick\">increment</button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Custom Effect Errors Typing in TypeScript\nDESCRIPTION: This example demonstrates how to define custom error types for Effector effects using the third generic parameter.  It improves error handling by explicitly specifying the structure of potential errors, making it easier to catch and handle them correctly. This example includes defining an API error interface.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Define API error types\ninterface ApiError {\n  code: number;\n  message: string;\n}\n\n// Create typed effect\nconst fetchUserFx = createEffect<string, User, ApiError>(async (userId) => {\n  const response = await fetch(`/api/users/${userId}`);\n\n  if (!response.ok) {\n    throw {\n      code: response.status,\n      message: \"Failed to fetch user\",\n    } as ApiError;\n  }\n\n  return response.json();\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Atomic Stores in Effector (TypeScript)\nDESCRIPTION: This example demonstrates the recommended approach of creating small, atomic stores in Effector, contrasting it with a large store containing multiple fields.  Atomic stores improve update efficiency and allow more targeted subscriptions. The example shows how to create several individual stores for user name, email, posts, and settings.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// ❌ Big store - any change triggers update of everything\nconst $bigStore = createStore({\nprofile: {/* many fields */},\nsettings: {/* many fields */},\nposts: [ /* many posts */ ]\n})\n\n// ✅ Atomic stores - precise updates\nconst $userName = createStore('')\nconst $userEmail = createStore('')\nconst $posts = createStore<Post[]>([])\nconst $settings = createStore<Settings>({})\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Source Stores\nDESCRIPTION: This snippet demonstrates how to attach an effect, `originalFx`, to one or more source stores.  When the attached effect, `attachedFx`, is triggered, it reads data from the source stores and triggers `originalFx` with that data. The snippet outlines the formula, arguments, returns and types for this pattern.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst attachedFx = attach({\n  source,\n  effect: originalFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Sending Message to API\nDESCRIPTION: This snippet demonstrates how to use Effector's `sample` function to send a message to the API. It combines the messageSend event, the $session and $messageText stores, and the messageApi.messageSendFx effect to send the message data. It handles strict null checks by ensuring the session is not null before sending the message.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\nsample({\n  clock: messageSend,\n  source: { author: $session, text: $messageText },\n  target: messageApi.messageSendFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Explicit Application Start Event (TypeScript)\nDESCRIPTION: This code shows how to define an event that is triggered when an application starts. This allows full control over the application lifecycle, simplified testing, predictable behavior, and the ability to manage initialization order. The `appStarted` event serves as a clear signal for application initialization.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appStarted = createEvent();\n```\n\n----------------------------------------\n\nTITLE: Sample using sourceUnit, clockUnit, fn\nDESCRIPTION: An example of using the `sample(sourceUnit, clockUnit, fn?)` form.  It demonstrates triggering an effect with data sampled from a store when an event occurs, using a combinator function to transform the data.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/sample.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\nconst submitForm = createEvent();\n\nconst signInFx = createEffect((params) => {\n  console.log(params);\n});\n\nconst $userName = createStore(\"john\");\n\nconst sampleUnit = sample(\n  $userName /* 2 */,\n  submitForm /* 1 */,\n  (name, password) => ({ name, password }) /* 3 */,\n);\n/* 4 */\nsample({\n  clock: sampleUnit,\n  target: signInFx,\n});\n\nsubmitForm(12345678);\n// 1. when submitForm is called with params (12345678)\n// 2. take $userName store`s state ('john')\n// 3. transform payload from event (1) and current store`s state (2)\n// 4. when sampleUnit (event in this case) is triggered,\n//    send it payload to effect signInFx with params received at the step (3)\n```\n\n----------------------------------------\n\nTITLE: Watch Store Updates with `.watch()` (JavaScript)\nDESCRIPTION: Attaches a watcher function to a store using the `.watch()` method.  The watcher logs the current value of the `$store` whenever it's updated due to the `add` event.  Illustrates how to observe changes in a store's state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst add = createEvent();\nconst $store = createStore(0).on(add, (state, payload) => state + payload);\n\n$store.watch((value) => console.log(`current value: ${value}`));\nadd(4);\nadd(3);\n```\n\n----------------------------------------\n\nTITLE: Correct Naming Conventions in Effector (TypeScript)\nDESCRIPTION: This snippet demonstrates the correct use of descriptive names in Effector callbacks, improving readability and maintainability. Instead of using abstract names like `value` or `data`, it uses more specific names like `users`, `newUser`, and `userData`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n$users.on(userAdded, (users, newUser) => [...users, newUser]);\n\nsample({\n  clock: buttonClicked,\n  source: $userData,\n  fn: (userData) => userData,\n  target: updateUserFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Combining Stores into an Array\nDESCRIPTION: This snippet demonstrates combining stores into a new store which contains an array with the states of the stores passed into combine. The array will contain the states in the order they are passed into combine.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/combine.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst $a: Store<A>;\nconst $b: StoreWritable<B>;\nconst $c: Store<C> | StoreWritable<C>;\n\n$result: Store<[A, B, C]> = combine([$a, $b, $c]);\n```\n\n----------------------------------------\n\nTITLE: Connecting LoggedIn and Username Stores\nDESCRIPTION: This code connects the `$loggedIn` and `$userName` stores to the `$session` store, ensuring they are updated in sync with the session state.  `$loggedIn` is directly assigned the value of `$isLogged` from the session entity and `$userName` is derived from the session name.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_20\n\nLANGUAGE: ts\nCODE:\n```\n// File: /src/pages/chat/model.ts\nimport { $isLogged, $session } from \"entities/session\";\n\n// At the moment, there is just raw data without any knowledge how to load\nexport const $loggedIn = $isLogged;\nexport const $userName = $session.map((session) => session?.name ?? \"\");\n```\n\n----------------------------------------\n\nTITLE: Typing Effector Events in TypeScript\nDESCRIPTION: This code snippet demonstrates how to type Effector events using TypeScript.  It showcases creating events with and without parameters, and how TypeScript infers the event type based on the provided generic type or absence thereof. The result is a strongly typed event that improves type safety.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\n// Event without parameters\nconst clicked = createEvent();\n// EventCallable<void>\n\n// Event with parameter\nconst userNameChanged = createEvent<string>();\n// EventCallable<string>\n\n// Event with complex parameter\nconst formSubmitted = createEvent<{ \n  username: string; \n  password: string; \n}>();\n// EventCallable<{ username: string; password: string; }>\n```\n\n----------------------------------------\n\nTITLE: User.vue: Using useStoreMap to find a user\nDESCRIPTION: This Vue component demonstrates how to use `useStoreMap` to find a specific user in a list of users stored in an Effector store. It takes an `id` as a prop and uses it as a key in the `useStoreMap` configuration.  It imports `createStore`, `useUnit` and `useStoreMap` from `effector-vue/composition`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useStoreMap.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { useUnit, useStoreMap } from \"effector-vue/composition\";\n\nconst $users = createStore([\n  {\n    id: 1,\n    name: \"Yung\",\n  },\n  {\n    id: 2,\n    name: \"Lean\",\n  },\n  {\n    id: 3,\n    name: \"Kyoto\",\n  },\n  {\n    id: 4,\n    name: \"Sesh\",\n  },\n]);\n\nexport default {\n  props: {\n    id: Number,\n  },\n  setup(props) {\n    const user = useStoreMap({\n      store: $users,\n      keys: () => props.id,\n      fn: (users, userId) => users.find(({ id }) => id === userId),\n    });\n\n    return { user };\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Business Logic for Toggling Repo Star\nDESCRIPTION: This snippet demonstrates the business logic for toggling a repository star using Effector. It includes the creation of an event (`repoStarToggled`), effects (`starRepoFx`, `unstarRepoFx`), and stores (`$isRepoStarred`, `$repoStarsCount`). The `sample` function is used to connect these units and manage state transitions based on events and effects. It also include the logic for sending a request to the server when toggling the star.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/resources/mindset.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n// repo.model.ts\n\n// событие – факт действия\nconst repoStarToggled = createEvent();\n\n// эффекты как дополнительная реакция на события\n// (предположим эффекты возвращают обновленное значение)\nconst starRepoFx = createEffect(() => {});\nconst unstarRepoFx = createEffect(() => {});\n\n// состояние приложения\nconst $isRepoStarred = createStore(false);\nconst $repoStarsCount = createStore(0);\n\n// логика переключения звездочки\nsample({\n  clock: repoStarToggled,\n  source: $isRepoStarred,\n  fn: (isRepoStarred) => !isRepoStarred,\n  target: $isRepoStarred,\n});\n\n// отправка запроса на сервер при переключении звезды\nsample({\n  clock: $isRepoStarred,\n  filter: (isRepoStarred) => isRepoStarred,\n  target: starRepoFx,\n});\n\nsample({\n  clock: $isRepoStarred,\n  filter: (isRepoStarred) => !isRepoStarred,\n  target: unstarRepoFx,\n});\n\n// обновляем счетчик\nsample({\n  clock: [starRepoFx.doneData, unstarRepoFx.doneData],\n  target: $repoStarsCount,\n});\n```\n\n----------------------------------------\n\nTITLE: Splitting event with expanded form - Effector - TypeScript\nDESCRIPTION: This snippet showcases the expanded form of the `split` method. It utilizes `source`, `match`, and `cases` to trigger different effects based on the current application mode stored in `$appMode`. When `buttonClicked` event is triggered, it performs different actions (effects) depending on whether the `$appMode` is 'user' or 'admin'. If no case matches, the `defaultActionFx` is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/flow-split.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect, split } from \"effector\";\n\nconst adminActionFx = createEffect();\nconst secondAdminActionFx = createEffect();\nconst userActionFx = createEffect();\nconst defaultActionFx = createEffect();\n// UI event\nconst buttonClicked = createEvent();\n\n// Current application mode\nconst $appMode = createStore<\"admin\" | \"user\">(\"user\");\n\n// Different actions for different modes\nsplit({\n  source: buttonClicked,\n  match: $appMode, // Logic depends on the current mode\n  cases: {\n    admin: [adminActionFx, secondAdminActionFx],\n    user: userActionFx,\n    __: defaultActionFx,\n  },\n});\n\n// Clicking the same button performs different actions\n// depending on the application mode\nbuttonClicked();\n// -> \"Performing user action\" (when $appMode = 'user')\n// -> \"Performing admin action\" (when $appMode = 'admin')\n```\n\n----------------------------------------\n\nTITLE: Import `sample` from Effector\nDESCRIPTION: Imports the `sample` function from the Effector library. This import is necessary to use the `sample` method for creating derived units.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/sample.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Creating Small Effector Stores (TypeScript)\nDESCRIPTION: This example demonstrates the recommended practice of creating small, atomic stores in Effector, contrasting it with the anti-pattern of large stores with multiple fields. Atomic stores allow for more efficient updates, targeted subscriptions, and better reactivity.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// ❌ Большой стор - любое изменение вызывает обновление всего\nconst $bigStore = createStore({\n  profile: { /* много полей */ },\n  settings: { /* много полей */ },\n  posts: [ /* много постов */ ]\n})\n\n// ✅ Атомарные сторы - точечные обновления\nconst $userName = createStore('')\nconst $userEmail = createStore('')\nconst $posts = createStore<Post[]>([])\nconst $settings = createStore<Settings>({})\n\n// Компонент подписывается только на нужные данные\nconst UserName = () => {\n  const name = useUnit($userName) // Обновляется только при изменении имени\n  return <h1>{name}</h1>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Store and Event with Sample in Effector (TS)\nDESCRIPTION: This snippet demonstrates how to create a derived store (`$selectedUser`) and a derived event (`adminSelected`) using `sample` in effector. The `$selectedUser` store holds the selected user based on a user ID. The `adminSelected` event triggers only when the selected user is an admin.  It uses `createStore`, `createEvent`, and `sample` from effector. It relies on a `$users` store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, sample } from \"effector\";\n\ntype User = {\n  id: number;\n  role: string;\n};\n\nconst userSelected = createEvent<number>();\n\nconst $users = createStore<User[]>([]);\n\n// Создаём производный стор, который будет хранить выбранного пользователя\nconst $selectedUser = sample({\n  clock: userSelected,\n  source: $users,\n  fn: (users, id) => users.find((user) => user.id === id) || null,\n});\n// $selectedUser имеет тип Store<User | null>\n\n// Создаём производное событие, которое будет срабатывать только для админов\n// если выбранный пользователь админ, то событие сработает сразу\nconst adminSelected = sample({\n  clock: userSelected,\n  source: $users,\n  // сработает только если пользователь найден и он админ\n  filter: (users, id) => !!users.find((user) => user.id === id && user.role === \"admin\"),\n  fn: (users, id) => users[id],\n});\n// adminSelected имеет тип Event<User>\n\nuserSelected(2);\n```\n\n----------------------------------------\n\nTITLE: Basic Sample Usage\nDESCRIPTION: This snippet demonstrates the basic usage of `sample` to connect a button click event to fetching user data based on a user name store.  It triggers the `fetchUserFx` effect with the current value of the `$userName` store when `buttonClicked` is called. The example relies on `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, sample, createEffect } from \"effector\";\n\nconst buttonClicked = createEvent();\n\nconst $userName = createStore(\"Bob\");\n\nconst fetchUserFx = createEffect((userName) => {\n  // logic\n});\n\n// Get current name when button is clicked\nsample({\n  clock: buttonClicked,\n  source: $userName,\n  target: fetchUserFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Merging Events with Generic Type in Effector\nDESCRIPTION: Shows how to use the generic type parameter with the `merge` function to specify the expected type of events. The example highlights the type checking feature of TypeScript, which prevents assigning an event with a different type to the merged event when a specific type is defined.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, merge } from \"effector\";\n\nconst firstEvent = createEvent<string>();\nconst secondEvent = createEvent<number>();\n\nconst merged = merge<number>([firstEvent, secondEvent]);\n//                                ^\n// Type 'EventCallable<string>' is not assignable to type 'Unit<number>'.\n\n```\n\n----------------------------------------\n\nTITLE: Saving Event Data to Store (JavaScript)\nDESCRIPTION: Demonstrates how to use `forward` to connect an event to a store, updating the store's value whenever the event is triggered. The code imports `createStore`, `createEvent`, and `forward` from effector.  It shows how the store's state changes in response to event triggers, logged via `watch`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/forward.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, forward } from \"effector\";\n\nconst $store = createStore(1);\nconst event = createEvent();\n\nforward({\n  from: event,\n  to: $store,\n});\n\n$store.watch((state) => console.log(\"store changed: \", state));\n// => store changed: 1\n\nevent(200);\n// => store changed: 200\n```\n\n----------------------------------------\n\nTITLE: Extending WebSocket Connection Effect with Error Handling - Typescript\nDESCRIPTION: Extends the WebSocket connection effect with comprehensive error handling, including a timeout mechanism.  It adds events for socket errors and incorporates `scopeBind` for error events. Includes a store to save the latest error message.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst TIMEOUT = 5_000;\n\n// Add events for errors\nconst socketError = createEvent<Error>();\n\nconst connectWebSocketFx = createEffect((url: string): Promise<WebSocket> => {\n  const ws = new WebSocket(url);\n\n  const scopeDisconnected = scopeBind(disconnected);\n  const scopeRawMessageReceived = scopeBind(rawMessageReceived);\n  const scopeSocketError = scopeBind(socketError);\n\n  return new Promise((res, rej) => {\n    const timeout = setTimeout(() => {\n      const error = new Error(\"Connection timeout\");\n\n      socketError(error);\n      reject(error);\n      socket.close();\n    }, TIMEOUT);\n\n    ws.onopen = () => {\n      clearTimeout(timeout);\n      res(ws);\n    };\n\n    ws.onmessage = (event) => {\n      scopeRawMessageReceived(event.data);\n    };\n\n    ws.onclose = () => {\n      disconnected();\n    };\n\n    ws.onerror = (err) => {\n      const error = new Error(\"WebSocket error\");\n      scopeDisconnected();\n      scopeSocketError(error);\n      rej(err);\n    };\n  });\n});\n\n// Store for error storage\nconst $error = createStore(\"\")\n  .on(socketError, (_, error) => error.message)\n  .reset(connectWebSocketFx.done);\n```\n\n----------------------------------------\n\nTITLE: Basic useEvent Usage with Event\nDESCRIPTION: Demonstrates the basic usage of `useEvent` with an Effector Event. The example shows how to create an event, store, and bind the event to a handler function within a React component. This handler is then used to trigger the event on button click.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useEvent.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport ReactDOM from \"react-dom\";\nimport { createEvent, createStore, fork } from \"effector\";\nimport { useStore, useEvent, Provider } from \"effector-react\";\n\nconst incremented = createEvent();\nconst $count = createStore(0);\n\n$count.on(incremented, (counter) => counter + 1);\n\nconst App = () => {\n  const count = useStore($count);\n  const handleIncrement = useEvent(incremented);\n\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => handleIncrement()}>increment</button>\n    </>\n  );\n};\n\nconst scope = fork();\n\nReactDOM.render(\n  <Provider value={scope}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Effect Error Handling\nDESCRIPTION: This code snippet shows how to handle errors within an Effector effect.  It demonstrates the use of `createEffect` with a specific error type, allowing TypeScript to catch incorrect error types thrown within the effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/work-with-async.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nclass CustomError extends Error {\n  // реализация\n}\n\nconst effect = createEffect<Params, ReturnValue, CustomError>(async () => {\n  const response = await fetch(`/api/users/${userId}`);\n\n  if (!response.ok) {\n    // Вы можете выбрасывать ошибки, которые будут перехвачены обработчиком .fail\n    throw new CustomError(`Не удалось загрузить пользователя: ${response.statusText}`);\n  }\n\n  return response.json();\n});\n```\n\n----------------------------------------\n\nTITLE: Sample Multiple Clocks - Typescript\nDESCRIPTION: Demonstrates how to use multiple events as `clock` for `sample`. It triggers the `saveDocumentFx` effect with the data from the `$formData` store when any of the trigger events (`saveButtonClicked`, `ctrlSPressed`, `autoSaveTriggered`) occur.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, sample } from \"effector\";\n\n// События для разных действий пользователя\nconst saveButtonClicked = createEvent();\nconst ctrlSPressed = createEvent();\nconst autoSaveTriggered = createEvent();\n\n// Общее хранилище данных\nconst $formData = createStore({ text: \"\" });\n\n// Эффект сохранения\nconst saveDocumentFx = createEffect((data: { text: string }) => {\n  // Логика сохранения\n});\n\n// Единая точка сохранения документа, которая срабатывает от любого триггера\nsample({\n  // Все эти события будут вызывать сохранение\n  clock: [saveButtonClicked, ctrlSPressed, autoSaveTriggered],\n  source: $formData,\n  target: saveDocumentFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Effect .use.getCurrent() usage example\nDESCRIPTION: This example shows how to retrieve the current handler assigned to an Effect using `.use.getCurrent()`. It demonstrates switching handlers and verifying the current handler. If no handler is set, the default error throwing handler is returned.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst handlerA = () => \"A\";\nconst handlerB = () => \"B\";\n\nconst fx = createEffect(handlerA);\n\nconsole.log(fx.use.getCurrent() === handlerA);\n// => true\n\nfx.use(handlerB);\nconsole.log(fx.use.getCurrent() === handlerB);\n// => true\n```\n\n----------------------------------------\n\nTITLE: Allowing Undefined Values in Stores - Effector\nDESCRIPTION: Demonstrates explicitly allowing `undefined` as a valid value in a store by setting `skipVoid: false` during store creation. Imports `createStore` and `createEvent` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/manage-states.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst setVoidValue = createEvent<number>();\n\n// ❌ undefined будут пропущены\nconst $store = createStore(13).on(setVoidValue, (_, voidValue) => voidValue);\n\n// ✅ undefined разрешены как значения\nconst $store = createStore(13, {\n  skipVoid: false,\n}).on(setVoidValue, (_, voidValue) => voidValue);\n\nsetVoidValue(null);\n```\n\n----------------------------------------\n\nTITLE: Event filterMap Usage with Error Example\nDESCRIPTION: Demonstrates incorrect usage of filterMap with side effects (calling an event from within the filterMap function) and provides a corrected example using `sample` to trigger the side effect outside the pure function.  Highlights the error that occurs when calling units from pure functions, and suggests using `sample` instead.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst countReceived = createEvent<number>();\nconst eachReceived = createEvent<number>();\n\nconst receivedEven = someHappened.filterMap((count) => {\n  eachReceived(count); // ВЫЗЫВАЕТ ОШИБКУ!\n  return count % 2 === 0 ? Math.abs(count) : undefined;\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst countReceived = createEvent<number>();\nconst eachReceived = createEvent<number>();\n\nconst receivedEven = someHappened.filterMap((count) => {\n  return count % 2 === 0 ? Math.abs(count) : undefined;\n});\n\nsample({\n  clock: someHappened,\n  target: eachReceived,\n});\n```\n\n----------------------------------------\n\nTITLE: Typing `createApi` in Effector with TypeScript\nDESCRIPTION: Explains how to type the events created by `createApi` by adding a type to the second argument, which represents the handlers.  This provides strong typing for the resulting events, enabling better type safety within effector stores and APIs.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst $count = createStore(0);\n\nconst { add, sub } = createApi($count, {\n  add: (x, add: number) => x + add,\n  sub: (x, sub: number) => x - sub,\n});\n\n// add имеет тип Event<number>\n// sub имеет тип Event<number>\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Token from Store - Effector (TS)\nDESCRIPTION: This code snippet demonstrates how to create a specialized effect using `attach` that automatically includes an authentication token from a store when sending messages. It defines a base effect `baseSendMessageFx` that requires a text and a token, a store `$authToken` holding the token, and a specialized effect `sendMessageFx` that takes only the text as input and retrieves the token from the store.  The `mapParams` function transforms the input text into the required parameters for the base effect, including the token.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attach, createEffect, createStore } from \"effector\";\n\ntype SendMessageParams = { text: string; token: string };\n\n// Base effect for sending data\nconst baseSendMessageFx = createEffect<SendMessageParams, void>(async ({ text, token }) => {\n  await fetch(\"/api/messages\", {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${token}`,\n    },\n    body: JSON.stringify({ text }),\n  });\n});\n\n// Store with authentication token\nconst $authToken = createStore(\"default-token\");\n\n// Create a specialized effect that automatically uses the token\nconst sendMessageFx = attach({\n  effect: baseSendMessageFx,\n  source: $authToken,\n  mapParams: (text: string, token) => ({\n    text,\n    token,\n  }),\n});\n\n// Now you can call the effect with just the message text\nsendMessageFx(\"Hello!\"); // token will be added automatically\n```\n\n----------------------------------------\n\nTITLE: Attach Effect with Async Function - Multiple Stores Example\nDESCRIPTION: This code showcases attaching an effect to multiple stores, passing their values as an object to the async effect function. The example includes userland code without explicit type declarations to demonstrate type inference capabilities. You also need to explicitly set the return type of the `effect` function if necessary.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Userland example, without explicit type declarations\nconst $foo = createStore(100);\nconst $bar = createStore(\"demo\");\n\nconst attachedFx = attach({\n  source: { foo: $foo, bar: $bar },\n  async effect({ foo, bar }, { baz }: { baz: boolean }) {\n    console.log(\"Hit!\", { foo, bar, baz });\n  },\n});\n\nattachedFx({ baz: true });\n// => Hit! { foo: 100, bar: \"demo\", baz: true }\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Store Values with fork\nDESCRIPTION: Shows how to set initial values for stores when creating a scope using the `fork` method in Effector, useful for SSR and testing.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst scope = fork({\n  values: [\n    [$store, \"value\"],\n    [$user, { id: 1, name: \"Alice\" }],\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Change state on effect completion (JavaScript)\nDESCRIPTION: Creates an effect `fetchUserReposFx` to fetch user repositories and updates a store `$repos` with the fetched data using the `.doneData` event.  The store's value is then logged to the console whenever it changes, showcasing reactive state management upon effect completion.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createEffect.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect(async ({ name }) => {\n  const url = `https://api.github.com/users/${name}/repos`;\n  const req = await fetch(url);\n  return req.json();\n});\n\nconst $repos = createStore([]).on(fetchUserReposFx.doneData, (_, repos) => repos);\n\n$repos.watch((repos) => {\n  console.log(`${repos.length} repos`);\n});\n// => 0 repos\n\nawait fetchUserReposFx({ name: \"zerobias\" });\n// => 26 repos\n```\n\n----------------------------------------\n\nTITLE: Split with Case Function\nDESCRIPTION: This code snippet demonstrates how to use `split` with a case function. The `match` field contains a function that returns a string.  The `cases` object contains units to which data is passed based on the returned string from the function. If no case matches, the data is passed to `cases.__`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>\n  // case function\n  match: (value: T) => 'first' | 'second',\n  cases: {\n    first: Unit<T> | Unit<T>[],\n    second: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Split Formula Examples\nDESCRIPTION: This snippet presents various examples of how the `split` function can be used.  It includes examples with case functions, case stores, matcher functions, and matcher stores. The snippet focuses on the structure of `source`, `match`, and `cases` parameters.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>\n  // case function\n  match: (data: T) => 'a' | 'b',\n  cases: {\n    a: Unit<T> | Unit<T>[],\n    b: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\nsplit({\n  source: Unit<T>\n  // case store\n  match: Store<'a' | 'b'>,\n  cases: {\n    a: Unit<T> | Unit<T>[],\n    b: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\nsplit({\n  source: Unit<T>\n  match: {\n    // matcher function\n    a: (data: T) => boolean,\n    // matcher store\n    b: Store<boolean>\n  },\n  cases: {\n    a: Unit<T> | Unit<T>[],\n    b: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Mapping and Watching Events with createEvent (JavaScript)\nDESCRIPTION: This example demonstrates using `.map` and `.watch` with events created using `createEvent`.  It creates an event `fullNameReceived`, then maps the full name to extract the first and last names, and then maps the first name to uppercase.  Each derived event has a watch to log the respective value to the console.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createEvent.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst fullNameReceived = createEvent();\n\nconst firstNameReceived = fullNameReceived.map((fullName) => fullName.split(\" \")[0]);\nconst lastNameReceived = fullNameReceived.map((fullName) => fullName.split(\" \")[1]);\nconst firstNameUppercaseReceived = firstNameReceived.map((firstName) => firstName.toUpperCase());\n\nfirstNameReceived.watch((firstName) => console.log(\"First name\", firstName));\nlastNameReceived.watch((lastName) => console.log(\"Last name\", lastName));\nfirstNameUppercaseReceived.watch((firstName) => console.log(\"Upper case\", firstName));\n\nfullNameReceived(\"John Doe\");\n// => First name John\n// => Last name Doe\n// => Upper case JOHN\n```\n\n----------------------------------------\n\nTITLE: useUnit with Event/Effect in Vue\nDESCRIPTION: Demonstrates how to use `useUnit` with an Effector event (`incremented`) in a Vue component. The `onClick` function returned by `useUnit` is bound to the button's click event, triggering the Effector event within the current scope. This example showcases the use of Effector events to manage state and side effects within Vue components.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useUnit.md#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n// App.vue\n\n<script setup>\n  import { useUnit } from \"effector-vue/composition\";\n\n  import { incremented, $count } from \"./model.js\";\n\n  const onClick = useUnit(incremented);\n</script>\n\n<template>\n  <button @click=\"onClick\">increment</button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Sample with Data Filtering\nDESCRIPTION: This snippet demonstrates data filtering using the `filter` parameter of `sample`. It filters form data based on age and username length before triggering an effect.  The `submitToServerFx` effect is triggered only when the form data meets the specified criteria. The example relies on `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, sample, createEffect } from \"effector\";\n\ntype UserFormData = {\n  username: string;\n  age: number;\n};\n\nconst submitForm = createEvent();\n\nconst $formData = createStore<UserFormData>({ username: \"\", age: 0 });\n\nconst submitToServerFx = createEffect((formData: UserFormData) => {\n  // logic\n});\n\nsample({\n  clock: submitForm,\n  source: $formData,\n  filter: (form) => form.age >= 18 && form.username.length > 0,\n  target: submitToServerFx,\n});\n\nsubmitForm();\n```\n\n----------------------------------------\n\nTITLE: Creating Timer Events in Effector\nDESCRIPTION: This code snippet demonstrates the creation of events in Effector for controlling a timer.  It defines events for starting, stopping, and resetting the timer, providing a clear interface for managing timer state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport const timerStopped = createEvent();\nexport const timerReset = createEvent();\nexport const timerStarted = createEvent();\n```\n\n----------------------------------------\n\nTITLE: Handling Undefined Values in Stores - Effector\nDESCRIPTION: Explains how Effector handles `undefined` values by default, skipping updates with `undefined`.  Shows how to allow `undefined` as a valid value by setting `skipVoid: false` when creating the store. Imports `createStore` and `createEvent` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/manage-states.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = createStore(0).on(event, (_, newValue) => {\n  if (newValue % 2 === 0) {\n    return;\n  }\n\n  return newValue;\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Stores with Loaded Data\nDESCRIPTION: This code uses Effector's `on` method to update the `$messages` and `$session` stores when the corresponding effects (`messageApi.messagesLoadFx` and `sessionApi.sessionLoadFx`) complete successfully. The stores are updated with the loaded data using their respective `doneData` events.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\n// File: /src/pages/chat/model.ts\n// `.doneData` is a shortcut for `.done`, because `.done` returns `{ params, result }`\n// Do not name your arguments like `state` or `payload`\n// Use explicit names of the content they contain\n$messages.on(messageApi.messagesLoadFx.doneData, (_, messages) => messages);\n\n$session.on(sessionApi.sessionLoadFx.doneData, (_, session) => session);\n```\n\n----------------------------------------\n\nTITLE: Creating a Timer Count Store in Effector\nDESCRIPTION: This code snippet creates a store in Effector to hold the timer's count. It subscribes to a `tick` event to increment the count and resets the count when the `timerReset` event is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst tick = createEvent();\n\nexport const $timerCount = createStore(0)\n  .on(tick, (seconds) => seconds + 1)\n  .reset(timerReset);\n```\n\n----------------------------------------\n\nTITLE: Check if a value is an attached Effect - Effector\nDESCRIPTION: This JavaScript snippet demonstrates how to use `is.attached` to check if a given value is an Effector effect created via the `attach` method. It also provides an example of how to use this check in a domain's `onCreateEffect` hook to prevent duplicate error logs.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/is.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createDomain, attach, is } from \"effector\";\n\nconst logFailuresDomain = createDomain();\n\nlogFailuresDomain.onCreateEffect((effect) => {\n  if (is.attached(effect)) {\n    effect.fail.watch(({ params, error }) => {\n      console.warn(`Effect \"${effect.compositeName.fullName}\" failed`, params, error);\n    });\n  }\n});\n\nconst baseRequestFx = logFailuresDomain.createEffect((path) => {\n  throw new Error(`path ${path}`);\n});\n\nconst loadDataFx = attach({\n  mapParams: () => \"/data\",\n  effect: baseRequestFx,\n});\n\nconst loadListFx = attach({\n  mapParams: () => \"/list\",\n  effect: baseRequestFx,\n});\n\nloadDataFx();\nloadListFx();\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain, attach } from \"effector\";\n\nconst $store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\n\nconst childFx = attach({\n  effect: fx,\n});\n\nis.attached(childFx);\n// => true\n\nis.attached(fx);\n// => false\n\nis.attached($store);\n// => false\n\nis.attached(event);\n// => false\n\nis.attached(createDomain());\n// => false\n\nis.attached(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: Splitting event with clock and source - Effector - TypeScript\nDESCRIPTION: This expanded form of `split` uses both `clock` and `source`. The `buttonClicked` event triggers the `split` function, and the `$currentUser` store provides the data that is passed into effects specified in cases. The `$appMode` store is used to determine which effect to run: `adminActionFx`, `secondAdminActionFx` or `userActionFx` or `defaultActionFx`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/flow-split.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Extending the previous code\n\nconst adminActionFx = createEffect((currentUser) => {\n  // ...\n});\nconst secondAdminActionFx = createEffect((currentUser) => {\n  // ...\n});\n\n// Adding a new store\nconst $currentUser = createStore({\n  id: 1,\n  name: \"Donald\",\n});\n\nconst $appMode = createStore<\"admin\" | \"user\">(\"user\");\n\nsplit({\n  clock: buttonClicked,\n  // Passing the new store as a data source\n  source: $currentUser,\n  match: $appMode,\n  cases: {\n    admin: [adminActionFx, secondAdminActionFx],\n    user: userActionFx,\n    __: defaultActionFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Sampling with Array of Units in `clock` (JavaScript)\nDESCRIPTION: Illustrates how to use an array of units (events and effects) in the `clock` field of the `sample` function.  This acts as a `merge` operation, triggering the sample when any of the units in the array are triggered. The example shows both the array and the equivalent `merge` call.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/sample.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createStore, createEvent, createEffect, sample, merge} from 'effector'\n\nconst showNotification = createEvent<string>()\nconst trigger = createEvent()\nconst fx = createEffect()\nconst $store = createStore('')\n\n// array of units in `clock`\nsample({\n  clock: [trigger, fx.doneData],\n  source: $store,\n  target: showNotification,\n})\n\n// merged unit in `clock`\nsample({\n  clock: merge([trigger, fx.doneData]),\n  source: $store,\n  target: showNotification,\n})\n```\n\n----------------------------------------\n\nTITLE: Hydrating a store with a predefined value - JavaScript\nDESCRIPTION: Demonstrates how to use the `hydrate` function to populate an Effector store with a predefined value. It creates a domain and a store within that domain, then uses `hydrate` to set the initial value of the store to 42 using the store's `sid`. Finally, it logs the store's state, which will be the hydrated value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/hydrate.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createDomain, fork, serialize, hydrate } from \"effector\";\n\nconst domain = createDomain();\nconst $store = domain.createStore(0);\n\nhydrate(domain, {\n  values: {\n    [$store.sid]: 42,\n  },\n});\n\nconsole.log($store.getState()); // 42\n```\n\n----------------------------------------\n\nTITLE: Filtering Event Payload (JS)\nDESCRIPTION: This code uses the `.filter()` method to create a new event that is triggered only when a condition is met, using data from the event. This specific example filters for numbers greater than zero, updating a store with the last positive number.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst numbers = createEvent();\nconst positiveNumbers = numbers.filter({\n  fn: ({ x }) => x > 0,\n});\n\nconst $lastPositive = createStore(0).on(positiveNumbers, (n, { x }) => x);\n\n$lastPositive.watch((x) => {\n  console.log(\"last positive:\", x);\n});\n\n// => last positive: 0\n\nnumbers({ x: 0 });\n// no reaction\n\nnumbers({ x: -10 });\n// no reaction\n\nnumbers({ x: 10 });\n// => last positive: 10\n```\n\n----------------------------------------\n\nTITLE: Inferring Event Payload Type in Effector (TypeScript)\nDESCRIPTION: This code shows how to infer the payload type of an Effector event using the `EventPayload` type utility. The example creates an event with a number payload and then extracts the payload type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst first = createEvent<number>();\n// first: Event<number>\n\nconst second = first.filterMap((count) => {\n  if (count === 0) return;\n  return count.toString();\n});\n// second: Event<string>\n```\n\n----------------------------------------\n\nTITLE: SSR Handler with Effector State Serialization\nDESCRIPTION: Demonstrates a server-side rendering handler using Effector. It creates a scope, populates stores using `allSettled`, serializes the scope's state using `serialize`, and then injects the serialized state into the HTML as a JavaScript variable. This variable will be used on the client to hydrate the state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// src/server/handler.ts\nimport { fork, allSettled, serialize } from \"effector\";\n\nimport { formValuesFilled } from \"@/features/form\";\n\nasync function handleServerRequest(req) {\n  const scope = fork(); // creates isolated container for application state\n\n  // calculates the state of the app in this scope\n  await allSettled(formValuesFilled, {\n    scope,\n    params: {\n      firstName: \"John\",\n      lastName: \"Doe\",\n    },\n  });\n\n  // extract scope values to simple js object of `{[storeSid]: storeState}`\n  const values = serialize(scope);\n\n  const serializedState = JSON.stringify(values);\n\n  return renderHtmlToString({\n    scripts: [\n      `\n        <script>\n            self._SERVER_STATE_ = ${serializedState}\n        </script>\n      `,\n    ],\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Sample with Multiple Data Sources\nDESCRIPTION: This snippet demonstrates using multiple stores as data sources with `sample`. It combines a search query and filters into a single object and passes it to an effect.  The `submitSearchFx` effect is triggered with combined data from `$searchQuery` and `$filters` stores. The example relies on `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, sample, createEffect } from \"effector\";\n\ntype SubmitSearch = {\n  query: string;\n  filters: Array<string>;\n};\n\nconst submitSearchFx = createEffect((params: SubmitSearch) => {\n  /// logic\n});\n\nconst searchClicked = createEvent();\n\nconst $searchQuery = createStore(\"\");\nconst $filters = createStore<string[]>([ ]);\n\nsample({\n  clock: searchClicked,\n  source: {\n    query: $searchQuery,\n    filters: $filters,\n  },\n  target: submitSearchFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Fixing unit call from pure function with prepend - Typescript\nDESCRIPTION: Demonstrates creating new event via `createEvent` and connects events by `sample` instead of calling another event from pure function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst someHappened = createEvent<string>();\nconst another = createEvent<number>();\nconst reversed = createEvent<number>();\n\n// The same as .prepend(), but using `sample`\nsample({\n  clock: reversed,\n  fn: (input) => String(input),\n  target: someHappened,\n});\n\nsample({\n  clock: reversed,\n  target: another,\n});\n```\n\n----------------------------------------\n\nTITLE: Splitting event with match as Store - Effector - TypeScript\nDESCRIPTION: This snippet demonstrates using a store as the `match` parameter in the `split` method.  The `$currentTab` store holds a string representing the current tab. When `pageNavigated` occurs, the corresponding effect (`loadHomeDataFx`, `loadProfileDataFx`, or `loadSettingsDataFx`) is triggered based on the value in `$currentTab`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/flow-split.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst $currentTab = createStore(\"home\");\n\nsplit({\n  source: pageNavigated,\n  match: $currentTab,\n  cases: {\n    home: loadHomeDataFx,\n    profile: loadProfileDataFx,\n    settings: loadSettingsDataFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Effect Testing with Effector\nDESCRIPTION: This code snippet demonstrates how to test an effect in Effector by mocking its handler using the fork API. It creates a scope with a custom handler for the effect, then triggers the effect using allSettled. It asserts that the effect completed successfully and that the result matches the mocked value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/testing.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fork, allSettled } from \"effector\";\nimport { getUserProjectsFx } from \"./effect.js\";\n\ntest(\"effect executes correctly\", async () => {\n  const scope = fork({\n    handlers: [\n      // List of [effect, mock handler] pairs\n      [getUserProjectsFx, () => \"user projects data\"],\n    ],\n  });\n\n  const result = await allSettled(getUserProjectsFx, { scope });\n\n  expect(result.status).toBe(\"done\");\n  expect(result.value).toBe(\"user projects data\");\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Login Functionality\nDESCRIPTION: This code implements the login functionality. It uses Effector's `sample` function to trigger the `sessionApi.sessionCreateFx` effect when the `loginClicked` event occurs. Upon successful session creation, the resulting session data is stored in the `$session` store. On failure, the session is reset to null.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_18\n\nLANGUAGE: ts\nCODE:\n```\n// File: /src/pages/chat/model.ts\n// When login clicked we need to create a new session\nsample({\n  clock: loginClicked,\n  target: sessionApi.sessionCreateFx,\n});\n// When session created, just write it to a session store\nsample({\n  clock: sessionApi.sessionCreateFx.doneData,\n  target: $session,\n});\n// If session create is failed, just reset the session\nsample({\n  clock: sessionApi.sessionCreateFx.fail,\n  fn: () => null,\n  target: $session,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Event with a nullable type - Typescript\nDESCRIPTION: Illustrates how to create an event that accepts a nullable type. This is recommended for representing empty values when intended.  The `Data | null` type indicates that the event can either carry data of type `Data` or a null value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst maybeDataReceived = createEvent<Data | null>();\n// maybeDataReceived: EventCallable<Data | null>\n```\n\n----------------------------------------\n\nTITLE: Splitting event based on string length in effector using Javascript\nDESCRIPTION: This code snippet demonstrates how to use the `split` function to divide an event stream based on the length of the string passed to the event. It creates an event `message` and splits it into `short`, `medium`, and `long` events based on the string length. Each event has a watcher that logs a message to the console.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, split } from \"effector\";\n\nconst message = createEvent();\n\nconst { short, long, medium } = split(message, {\n  short: (m) => m.length <= 5,\n  medium: (m) => m.length > 5 && m.length <= 10,\n  long: (m) => m.length > 10,\n});\n\nshort.watch((m) => console.log(`short message '${m}'`));\nmedium.watch((m) => console.log(`medium message '${m}'`));\nlong.watch((m) => console.log(`long message '${m}'`));\n\nmessage(\"Hello, Bob!\");\n// => long message 'Hello, Bob!'\n\nmessage(\"Hi!\");\n// => short message 'Hi!'\n\n```\n\n----------------------------------------\n\nTITLE: Socket.IO Message Sending (TypeScript)\nDESCRIPTION: This code snippet defines an Effector effect (`sendMessageFx`) for sending messages through a Socket.IO connection. It takes a socket instance, an event name, and a payload as input, and emits the event with the payload using `socket.emit`. The type `SocketResponse<any>` is assumed to be defined elsewhere and to represent the structure of the response from the Socket.IO server. It depends on a pre-existing Socket.IO connection.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst sendMessageFx = createEffect(\n  ({\n    socket,\n    name,\n    payload,\n  }: SocketResponse<any> & {\n    socket: Socket;\n  }) => {\n    socket.emit(name, payload);\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: `match` as Function Example in Effector split\nDESCRIPTION: This example shows how to use a function as the `match` parameter in the `split` method. The function receives the source data and returns a string, which is used as a key to select the appropriate case.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/flow-split.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nconst userActionRequested = createEvent<{ type: string; payload: any }>();\n\nsplit({\n  source: userActionRequested,\n  match: (action) => action.type, // Функция возвращает строку\n  cases: {\n    update: updateUserDataFx,\n    delete: deleteUserDataFx,\n    create: createUserDataFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Watch effect status (JavaScript)\nDESCRIPTION: Creates an effect `fetchUserReposFx` to fetch user repositories and uses the `.pending`, `.done`, `.fail`, and `.finally` properties to watch and log the different states of the effect's execution. It demonstrates how to track the pending status, successful completion, failure, and final status of an effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createEffect.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect(async ({ name }) => {\n  const url = `https://api.github.com/users/${name}/repos`;\n  const req = await fetch(url);\n  return req.json();\n});\n\nfetchUserReposFx.pending.watch((pending) => {\n  console.log(`effect is pending?: ${pending ? \"yes\" : \"no\"}`);\n});\n\nfetchUserReposFx.done.watch(({ params, result }) => {\n  console.log(params); // {name: 'zerobias'}\n  console.log(result); // resolved value\n});\n\nfetchUserReposFx.fail.watch(({ params, error }) => {\n  console.error(params); // {name: 'zerobias'}\n  console.error(error); // rejected value\n});\n\nfetchUserReposFx.finally.watch(({ params, status, result, error }) => {\n  console.log(params); // {name: 'zerobias'}\n  console.log(`handler status: ${status}`);\n\n  if (error) {\n    console.error(\"handler rejected\", error);\n  } else {\n    console.log(\"handler resolved\", result);\n  }\n});\n\nawait fetchUserReposFx({ name: \"zerobias\" });\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect for Logic Reuse - Effector (TS)\nDESCRIPTION: This code snippet demonstrates how to reuse effect logic using `attach` for different endpoints. It defines a generic `fetchDataFx` effect that takes an endpoint and a token. Two specialized effects, `fetchUsersFx` and `fetchProductsFx`, are created using `attach`, each calling `fetchDataFx` with different endpoint values and the same token from the `$authToken` store. The `mapParams` function in each `attach` call transforms the input (ignored here with `_`) into the specific parameters needed by `fetchDataFx`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst fetchDataFx = createEffect<{ endpoint: string; token: string }, any>();\n\n// Create specialized effects for different endpoints\nconst fetchUsersFx = attach({\n  effect: fetchDataFx,\n  mapParams: (_, token) => ({\n    endpoint: \"/users\",\n    token,\n  }),\n  source: $authToken,\n});\n\nconst fetchProductsFx = attach({\n  effect: fetchDataFx,\n  mapParams: (_, token) => ({\n    endpoint: \"/products\",\n    token,\n  }),\n  source: $authToken,\n});\n```\n\n----------------------------------------\n\nTITLE: Reusing Logic with Attach for Different Endpoints (TS)\nDESCRIPTION: This snippet showcases how to reuse a base effect (`fetchDataFx`) with `attach` to create specialized effects (`fetchUsersFx`, `fetchProductsFx`) for different endpoints. It shows how to configure these effects with different `endpoint` parameters and an authorization token taken from the `$authToken` store. It depends on `createEffect`, `attach`, and `$authToken` store to be already defined.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst fetchDataFx = createEffect<{ endpoint: string; token: string }, any>();\n\n// Создаём специализированные эффекты для разных эндпоинтов\nconst fetchUsersFx = attach({\n  effect: fetchDataFx,\n  mapParams: (_, token) => ({\n    endpoint: \"/users\",\n    token,\n  }),\n  source: $authToken,\n});\n\nconst fetchProductsFx = attach({\n  effect: fetchDataFx,\n  mapParams: (_, token) => ({\n    endpoint: \"/products\",\n    token,\n  }),\n  source: $authToken,\n});\n```\n\n----------------------------------------\n\nTITLE: Store .updates Example - Javascript\nDESCRIPTION: Demonstrates how to access the `updates` event of a store. The `updates` event emits the store's value whenever the store is updated. This example shows how to watch the `updates` event and log the new value to the console.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, is } from \"effector\";\n\nconst $clicksAmount = createStore(0);\nis.event($clicksAmount.updates); // true\n\n$clicksAmount.updates.watch((amount) => {\n  console.log(amount);\n});\n```\n\n----------------------------------------\n\nTITLE: Splitting event with match as Function - Effector - TypeScript\nDESCRIPTION: This example uses a function as the `match` parameter in `split`.  When `userActionRequested` is triggered, the function extracts the `type` property from the payload and uses it as the key to determine which effect to execute (`updateUserDataFx`, `deleteUserDataFx`, or `createUserDataFx`). The function's return value must be a string.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/flow-split.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst userActionRequested = createEvent<{ type: string; payload: any }>();\n\nsplit({\n  source: userActionRequested,\n  match: (action) => action.type, // The function returns a string\n  cases: {\n    update: updateUserDataFx,\n    delete: deleteUserDataFx,\n    create: createUserDataFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Extracting Store Value with `StoreValue` in Effector\nDESCRIPTION: Shows how to use the `StoreValue` type utility to extract the value type from an Effector store. It's similar to `UnitValue` but is specifically designed for stores.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, StoreValue } from \"effector\";\n\nconst $store = createStore(true);\n\ntype StoreValueType = StoreValue<typeof $store>;\n// boolean\n```\n\n----------------------------------------\n\nTITLE: Multiple Store Updates in effector\nDESCRIPTION: Illustrates how multiple stores can subscribe to the same event and a single store can subscribe to multiple events. The example shows `$lastUsedFilter` and `$filters` stores subscribing to `categoryChanged`, and `$filters` also subscribing to `searchQueryChanged` and being reset by `filtersReset`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst categoryChanged = createEvent<string>();\nconst searchQueryChanged = createEvent<string>();\nconst filtersReset = createEvent();\n\nconst $lastUsedFilter = createStore<string | null>(null);\nconst $filters = createStore({\n  category: \"all\",\n  searchQuery: \"\",\n});\n\n// subscribe two different stores to the same event\n$lastUsedFilter.on(categoryChanged, (_, category) => category);\n$filters.on(categoryChanged, (filters, category) => ({\n  ...filters,\n  category,\n}));\n\n$filters.on(searchQueryChanged, (filters, searchQuery) => ({\n  ...filters,\n  searchQuery,\n}));\n\n$filters.reset(filtersReset);\n```\n\n----------------------------------------\n\nTITLE: Binding Effector events to the current scope using scopeBind (TS)\nDESCRIPTION: This code snippet demonstrates how to correctly bind an Effector event to the current scope using `scopeBind` when dealing with external functions like `setTimeout`.  It illustrates the problem of scope loss when events are called within callbacks of external functions and provides the correct approach of using `scopeBind` to maintain the correct scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/troubleshooting.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst event = createEvent();\n\n// ❌ - так у вас событие вызовется в глобальной области видимости\nconst effectFx = createEffect(() => {\n  setTimeout(() => {\n    event();\n  }, 1000);\n});\n\n// ✅ - так у вас будет работать как ожидаемо\nconst effectFx = createEffect(() => {\n  const scopeEvent = scopeBind(event);\n  setTimeout(() => {\n    scopeEvent();\n  }, 1000);\n});\n```\n\n----------------------------------------\n\nTITLE: Simplifying Logic with Effector Action (TypeScript)\nDESCRIPTION: This example compares complex effector logic using multiple samples with the simplified approach using `effector-action`. `effector-action` allows writing imperative code within effector's declarative structure, enhancing readability. It demonstrates handling form submission with validation and side effects. It relies on the `effector-action` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample } from \"effector\";\n\nsample({\n  clock: formSubmitted,\n  source: {\n    form: $form,\n    settings: $settings,\n    user: $user,\n  },\n  filter: ({ form }) => form.isValid,\n  fn: ({ form, settings, user }) => ({\n    data: form,\n    theme: settings.theme,\n  }),\n  target: submitFormFx,\n});\n\nsample({\n  clock: formSubmitted,\n  source: $form,\n  filter: (form) => !form.isValid,\n  target: showErrorMessageFx,\n});\n\nsample({\n  clock: submitFormFx.done,\n  source: $settings,\n  filter: (settings) => settings.sendNotifications,\n  target: sendNotificationFx,\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAction } from \"effector-action\";\n\nconst submitForm = createAction({\n  source: {\n    form: $form,\n    settings: $settings,\n    user: $user,\n  },\n  target: {\n    submitFormFx,\n    showErrorMessageFx,\n    sendNotificationFx,\n  },\n  fn: (target, { form, settings, user }) => {\n    if (!form.isValid) {\n      target.showErrorMessageFx(form.errors);\n      return;\n    }\n\n    target.submitFormFx({\n      data: form,\n      theme: settings.theme,\n    });\n  },\n});\n\ncreateAction(submitFormFx.done, {\n  source: $settings,\n  target: sendNotificationFx,\n  fn: (sendNotification, settings) => {\n    if (settings.sendNotifications) {\n      sendNotification();\n    }\n  },\n});\n\nsubmitForm();\n```\n\n----------------------------------------\n\nTITLE: Creating derived Stores - Effector (TypeScript)\nDESCRIPTION: This snippet showcases how to create derived stores using the `map` method in Effector.  The `$superHeroes` and `$superVillains` stores are derived from the `$supers` store and automatically update whenever the original store changes.  This exemplifies the reactivity principle, where changes propagate automatically.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/core-concepts.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\n// Create an event\nconst superAdded = createEvent();\n\n// Create a store\nconst $supers = createStore([\n  {\n    name: \"Spider-Man\",\n    role: \"hero\",\n  },\n  {\n    name: \"Green Goblin\",\n    role: \"villain\",\n  },\n]);\n\n// Create derived stores based on $supers\nconst $superHeroes = $supers.map((supers) => supers.filter((sup) => sup.role === \"hero\"));\nconst $superVillains = $supers.map((supers) => supers.filter((sup) => sup.role === \"villain\"));\n\n// Update the store when the event is triggered\n$supers.on(superAdded, (supers, newSuper) => [...supers, newSuper]);\n\n// Add a new character\nsuperAdded({\n  name: \"Rhino\",\n  role: \"villain\",\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Domain Hook Type Definition\nDESCRIPTION: Illustrates the type definition for `onCreateDomain`, showing that it accepts a function that takes a `Domain` as input. This hook allows executing custom logic whenever a new sub-domain is created within the parent domain.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Domain.md#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\ndomain.onCreateDomain((domain) => {});\n```\n\n----------------------------------------\n\nTITLE: Creating a Derived Event with map\nDESCRIPTION: Demonstrates creating a derived event using the `map` method. The `userNameSelected` event is derived from the `userClicked` event, extracting the user's name. The example shows a typical use case where a derived event updates a store. It imports `createEvent` and `createStore` from the `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/events.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst userClicked = createEvent<{ id: number; name: string }>();\n// Creating an event that will trigger only with the user's name\nconst userNameSelected = userClicked.map(({ name }) => name);\nconst $userName = createStore(\"\").on(userNameSelected, (_, newName) => newName);\n\n// Usage\nuserClicked({ id: 1, name: \"John\" });\n// userNameSelected will get 'John'\n```\n\n----------------------------------------\n\nTITLE: Updating store with createEvent\nDESCRIPTION: Illustrates how to create an event (addNumber) and a store ($store). The store's state is updated whenever the event is triggered with a number. The example also shows how to watch the store's state for changes using $store.watch().\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createEvent.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst addNumber = createEvent();\nconst $store = createStore(0).on(addNumber, (state, number) => state + number);\n\n$store.watch((state) => {\n  console.log(\"state\", state);\n});\n// => 0\n\naddNumber(10);\n// => 10\n\naddNumber(10);\n// => 20\n\naddNumber(10);\n// => 30\n```\n\n----------------------------------------\n\nTITLE: Simplifying Updates with createApi - Effector\nDESCRIPTION: Demonstrates using `createApi` to create handlers for a store instead of creating individual events and subscribing to them. This function creates a set of events for updating the store in one place.  It imports `createStore` and `createApi` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/manage-states.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createApi } from \"effector\";\n\nconst $counter = createStore(0);\n\nconst { increment, decrement, reset } = createApi($counter, {\n  increment: (state) => state + 1,\n  decrement: (state) => state - 1,\n  reset: () => 0,\n});\n\n// Использование\nincrement(); // 1\nreset(); // 0\n```\n\n----------------------------------------\n\nTITLE: useStoreMap with config object (TypeScript)\nDESCRIPTION: This code block presents the function signature for using `useStoreMap` with a configuration object.  This config allows for specifying dependencies using the `keys` property (similar to `React.useMemo`), controlling updates with `updateFilter`, and setting `defaultValue` when `fn` returns `undefined`. It returns the `Result` of the `fn` function, or `defaultValue` if provided and `fn` returns `undefined`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useStoreMap.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nuseStoreMap({\n  store: Store<State>,\n  keys: any[],\n  fn: (state: State, keys: any[]) => Result,\n  updateFilter?: (newResult: Result, oldResult: Result) => boolean,\n  defaultValue?: Result,\n}): Result;\n```\n\n----------------------------------------\n\nTITLE: Typing Handler Function Outside Effect in TypeScript\nDESCRIPTION: This code shows how to type an Effector effect when the handler function is defined separately.  The `typeof` operator is used to extract the type of the handler function, allowing Effector to correctly type the effect. This ensures that the effect's input and output types match the handler function's signature.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst sendMessage = async (params: { text: string }) => {\n  // ...\n  return \"ok\";\n};\n\nconst sendMessageFx = createEffect<typeof sendMessage, AxiosError>(sendMessage);\n// => Effect<{text: string}, string, AxiosError>\n```\n\n----------------------------------------\n\nTITLE: Guard with Predicate Function (JavaScript)\nDESCRIPTION: This example illustrates using a predicate function as a filter in `guard`. The `target` event is only triggered when the `source` event's payload is greater than 0.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/guard.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, guard } from \"effector\";\n\nconst source = createEvent();\nconst target = guard(source, {\n  filter: (x) => x > 0,\n});\n\ntarget.watch(() => {\n  console.log(\"target called\");\n});\n\nsource(0);\n// nothing happens\nsource(1);\n// target called\n```\n\n----------------------------------------\n\nTITLE: React Component: Conditional Rendering Based on Combined Queries (JS)\nDESCRIPTION: This React component `Screen` conditionally renders its children based on a combination of screen size and orientation queries managed by Effector.  It uses `effector-react`'s `useUnit` hook to access the combined media query store and checks if the current screen state satisfies the component's specified constraints.\nSOURCE: https://github.com/effector/effector/blob/master/recipes/media-queries/README.md#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nimport {useUnit} from 'effector-react'\nimport {screenQueries} from './screenQueries'\n\nfunction orientationCheck(props, queries) {\n  //if there no constraint on orientation\n  if (!props.portrait && !props.landscape) return true\n  return (\n    (props.portrait && queries.portrait) ||\n    (props.landscape && !queries.portrait)\n  )\n}\n\nfunction screenSizeCheck(props, queries) {\n  //if there no constraint on screen size\n  if (!props.small && !props.medium && !props.large) return true\n  return (\n    (props.small && queries.small) ||\n    (props.medium && queries.medium) ||\n    (props.large && queries.large)\n  )\n}\n\nexport const Screen = props => {\n  const queries = useUnit(screenQueries)\n  const orientationAllowed = orientationCheck(props, queries)\n  const screenSizeAllowed = screenSizeCheck(props, queries)\n\n  if (orientationAllowed && screenSizeAllowed) {\n    return props.children\n  }\n\n  return null\n}\n\nScreen.defaultProps = {\n  children: null,\n  small: false,\n  medium: false,\n  large: false,\n  portrait: false,\n  landscape: false,\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Specific Message Type Event - Typescript\nDESCRIPTION: Illustrates how to use the `messageReceivedByType` function to create an event that triggers only for messages of type \"balanceChanged\".  It also shows how to use the created event with `sample` and access the message data in a type-safe way.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nsample({\n  clock: messageReceivedByType(\"balanceChanged\"),\n  fn: (message) => {\n    // TypeScript knows the structure of message\n  },\n  target: doWhateverYouWant,\n});\n```\n\n----------------------------------------\n\nTITLE: Fixing readonly event call - Typescript\nDESCRIPTION: Demonstrates creating separate event via `createEvent`, and connect them by `sample` instead of direct calling derived event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberReceived = createEvent<number>();\nconst stringifiedReceived = createEvent<string>();\n\nsample({\n  clock: numberReceived,\n  fn: (number) => String(number),\n  target: stringifiedReceived,\n});\n\nstringifiedReceived(\"123\"); // OK\n```\n\n----------------------------------------\n\nTITLE: Handling forms validation with `split` in Effector (TS)\nDESCRIPTION: This code demonstrates using `split` to handle form validation.  First, effects `showFormErrorsFx` and `submitFormFx` are created.  Stores `$form` and `$formErrors` manage the form data and validation errors, respectively. The `sample` function extracts and validates form data on `submitForm`, targeting `$formErrors`. Finally, `split` routes the data based on the presence of errors in `$formErrors`, either to display errors or submit the form. Requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/flow-split.mdx#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nconst showFormErrorsFx = createEffect(() => {\n  // логика отображение ошибки\n});\nconst submitFormFx = createEffect(() => {\n  // логика отображение ошибки\n});\n\nconst submitForm = createEvent();\n\nconst $form = createStore({\n  name: \"\",\n  email: \"\",\n  age: 0,\n}).on(submitForm, (_, submittedForm) => ({ ...submittedForm }));\n// Отдельный стор для ошибок\nconst $formErrors = createStore({\n  name: \"\",\n  email: \"\",\n  age: \"\",\n}).reset(submitForm);\n\n// Проверяем все поля и собираем все ошибки\nsample({\n  clock: submitForm,\n  source: $form,\n  fn: (form) => ({\n    name: !form.name.trim() ? \"Имя обязательно\" : \"\",\n    email: !isValidEmail(form.email) ? \"Неверный email\" : \"\",\n    age: form.age < 18 ? \"Возраст должен быть 18+\" : \"\",\n  }),\n  target: $formErrors,\n});\n\n// И только после этого используем split для маршрутизации\nsplit({\n  source: $formErrors,\n  match: {\n    hasErrors: (errors) => Object.values(errors).some((error) => error !== \"\"),\n  },\n  cases: {\n    hasErrors: showFormErrorsFx,\n    __: submitFormFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Sending Message with Type Guard - TypeScript\nDESCRIPTION: This snippet fixes a potential type error caused by `strictNullChecks` in `tsconfig.json`. It adds a `filter` to the `sample` function to ensure that the `$session` store contains a valid `Session` object (not null) before sending the message. The `filter` uses a type guard to narrow the type of `form` to `{ author: Session; text: string }`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nsample({\n  clock: messageSend,\n  source: { author: $session, text: $messageText },\n  filter: (form): form is { author: Session; text: string } => {\n    return form.author !== null;\n  },\n  target: messageApi.messageSendFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Effect with Config Object\nDESCRIPTION: Shows how to create an Effector effect using a configuration object, specifying both the handler and an optional name.  The handler fetches user repositories from GitHub. Requires effector package. Invoked with an object containing the 'name' property.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createEffect.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect({\n  name: \"fetch user repositories\",\n  async handler({ name }) {\n    const url = `https://api.github.com/users/${name}/repos`;\n    const req = await fetch(url);\n    return req.json();\n  },\n});\n\nawait fetchUserReposFx({ name: \"zerobias\" });\n```\n\n----------------------------------------\n\nTITLE: Complex Sample with Effector\nDESCRIPTION: Demonstrates a complex Effector sample with source and filters, utilizing form data, settings, and user information. It's targeting `submitFormFx` with form data and theme or `showErrorMessageFx` if the form is invalid, and `sendNotificationFx` upon `submitFormFx.done` if `sendNotifications` is enabled.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample } from \"effector\";\n\nsample({\n  clock: formSubmitted,\n  source: {\n    form: $form,\n    settings: $settings,\n    user: $user,\n  },\n  filter: ({ form }) => form.isValid,\n  fn: ({ form, settings, user }) => ({\n    data: form,\n    theme: settings.theme,\n  }),\n  target: submitFormFx,\n});\n\nsample({\n  clock: formSubmitted,\n  source: $form,\n  filter: (form) => !form.isValid,\n  target: showErrorMessageFx,\n});\n\nsample({\n  clock: submitFormFx.done,\n  source: $settings,\n  filter: (settings) => settings.sendNotifications,\n  target: sendNotificationFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Sample with derived store\nDESCRIPTION: This snippet demonstrates creating a derived store using `sample`. It creates a store `$userAge` that automatically updates when the `$currentUser` store changes, extracting the age property. It also shows the equivalent using `.map`. The example relies on `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, sample } from \"effector\";\n\nconst $currentUser = createStore({ name: \"Bob\", age: 25 });\n\n// creates a derived store that updates when source changes\nconst $userAge = sample({\n  source: $currentUser,\n  fn: (user) => user.age,\n});\n// equivalent to\nconst $userAgeViaMap = $currentUser.map((currentUser) => currentUser.age);\n```\n\n----------------------------------------\n\nTITLE: Forward Event to Store - Effector (JavaScript)\nDESCRIPTION: This example demonstrates forwarding an event's payload to update a store's value. Whenever the event is triggered, the store's value is updated with the event's payload. `createStore` and `createEvent` from effector are dependencies.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/forward.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, forward } from \"effector\";\n\nconst $store = createStore(1);\nconst event = createEvent();\n\nforward({\n  from: event,\n  to: $store,\n});\n\n$store.watch((state) => console.log(\"store changed: \", state));\n// => store changed: 1\n\nevent(200);\n// => store changed: 200\n```\n\n----------------------------------------\n\nTITLE: Sending Message to API with Null Check\nDESCRIPTION: This snippet demonstrates how to use Effector's `sample` function to send a message to the API, incorporating a type guard to ensure the session is not null. It defines a filter function that narrows the type of the session to `Session` if it's not null, preventing TypeScript errors due to strict null checks.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\nsample({\n  clock: messageSend,\n  source: { author: $session, text: $messageText },\n  filter: (form): form is { author: Session; text: string } => {\n    return form.author !== null;\n  },\n  target: messageApi.messageSendFx,\n});\n```\n\n----------------------------------------\n\nTITLE: UseGate Formula (TypeScript)\nDESCRIPTION: Demonstrates the type signature for the `useGate` hook when used with a custom Gate. It takes a `Gate<T>` and optional props of type `T` and returns void. This signature defines how `useGate` interacts with generics.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useGate.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst CustomGate: Gate<T>;\n\nuseGate(CustomGate, props?: T): void;\n```\n\n----------------------------------------\n\nTITLE: Creating Session Entity\nDESCRIPTION: This code creates an entity for managing user sessions. It defines a store `$session` to hold the session data and a derived store `$isLogged` to indicate whether a user is logged in, based on the session's presence.  It depends on the effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_13\n\nLANGUAGE: ts\nCODE:\n```\n// File: /src/entities/session/index.ts\nimport { Session } from \"shared/api\";\nimport { createStore } from \"effector\";\n\n// Entity just stores session and some internal knowledge about it\nexport const $session = createStore<Session | null>(null);\n// When store `$session` is updated, store `$isLogged` will be updated too\n// They are in sync. Derived store are depends on data from original.\nexport const $isLogged = $session.map((session) => session !== null);\n```\n\n----------------------------------------\n\nTITLE: Updating Message List After Deletion\nDESCRIPTION: This snippet demonstrates how to update the message list store ($messages) after a message is successfully deleted. It uses the done event of the messageApi.messageDeleteFx effect to filter the message list, removing the deleted message based on its ID.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\n$messages.on(messageApi.messageDeleteFx.done, (messages, { params: toDelete }) =>\n  messages.filter((message) => message.id !== toDelete.id),\n);\n```\n\n----------------------------------------\n\nTITLE: Sample with Multiple Targets\nDESCRIPTION: This snippet demonstrates using an array of units as the `target` for `sample`. It sends the same data to multiple events, effects and stores simultaneously. The example relies on `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, createEffect, sample } from \"effector\";\n\n// Create units where data will be directed\nconst userDataReceived = createEvent<User>();\nconst $lastUserData = createStore<User | null>(null);\nconst saveUserFx = createEffect<User, void>((user) => {\n  // Save user\n});\nconst logUserFx = createEffect<User, void>((user) => {\n  // Log user actions\n});\n\nconst userUpdated = createEvent<User>();\n\n// When user is updated:\n// - Save data through saveUserFx\n// - Send to logging system through logUserFx\n// - Update store $lastUserData\n// - Trigger userDataReceived event\nsample({\n  clock: userUpdated,\n  target: [saveUserFx, logUserFx, $lastUserData, userDataReceived],\n});\n```\n\n----------------------------------------\n\nTITLE: Re-exporting API Modules and Types in TypeScript\nDESCRIPTION: Demonstrates re-exporting API modules and types for convenient access and improved code organization, promoting short imports and secure refactoring.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// File: /src/shared/api/index.ts\nexport * as messageApi from \"./message\";\nexport * as sessionApi from \"./session\";\n\n// Types reexports made just for convenience\nexport type { Message } from \"./message\";\nexport type { Session } from \"./session\";\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Single Store Source\nDESCRIPTION: Illustrates how to create attached effect `attachedFx` that receives parameters from the `store` and omits the original params. The types of the `source` store and `effect` params must be the same. But the `attachedFx` will omit the type of params, it means the attached effect not requires any params at all.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst originalFx: Effect<T, Done, Fail>;\nconst $store: Store<T>;\n\nconst attachedFx: Effect<void, Done, Fail> = attach({\n  source: $store,\n  effect: originalFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Conditional Event Triggering with Effector Sample (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to conditionally trigger an event (`actionExecuted`) based on the state of a store (`$isEnabled`) when another event (`buttonClicked`) is triggered. The `sample` function is used to filter the trigger based on the store's value. If `$isEnabled` is true, then `actionExecuted` is triggered when `buttonClicked` occurs.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/events.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst buttonClicked = createEvent<void>();\nconst $isEnabled = createStore(true);\n\n// Event will trigger only if $isEnabled is true\nsample({\n  clock: buttonClicked,\n  filter: $isEnabled,\n  target: actionExecuted,\n});\n```\n\n----------------------------------------\n\nTITLE: Effector Sample with Object Source\nDESCRIPTION: Explains how to use `sample` with an object containing stores as the source.  The resulting target event will emit an object with the current values of the stores.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/sample.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, sample } from \"effector\";\nconst trigger = createEvent();\n\nconst a = createStore(\"A\");\nconst b = createStore(1);\n\n// target имеет тип `Event<{ a: string, b: number }>`\nconst target = sample({\n  clock: trigger,\n  source: { a, b },\n});\n\ntarget.watch((obj) => {\n  console.log(\"sampled object\", obj);\n});\n\ntrigger();\n// => sampled object {a: 'A', b: 1}\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with `mapParams`\nDESCRIPTION: This snippet demonstrates attaching an effect to another effect using the `mapParams` option. It shows how the payload passed to the attached effect is transformed by `mapParams` before being passed to the original effect.  If `mapParams` throws, the attached effect fails and the original is not triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst attachedFx = attach({\n  effect: originalFx,\n  mapParams,\n});\n```\n\n----------------------------------------\n\nTITLE: createWatch Configuration (TypeScript)\nDESCRIPTION: This code snippet shows the type definition for the configuration object passed to the `createWatch` function in Effector.  It specifies the structure of the config, including the `unit`, `fn`, and optional `scope` properties, and defines the return type as `Subscription`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createWatch.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ncreateWatch<T>(config: {\n  unit: Unit<T>\n  fn: (payload: T) => void\n  scope?: Scope\n}): Subscription\n```\n\n----------------------------------------\n\nTITLE: Split with Matcher Function\nDESCRIPTION: This code snippet demonstrates how to use `split` with matcher functions. The `match` field contains an object with boolean-returning functions. The `cases` object contains units to which data is passed based on the boolean return values from the functions. If no case matches, the data is passed to `cases.__`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>\n  match: {\n    // matcher function\n    first: (value: T) => boolean,\n    second: (value: T) => boolean\n  },\n  cases: {\n    first: Unit<T> | Unit<T>[],\n    second: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Incorrect State Access with getState in Effector (Typescript)\nDESCRIPTION: This snippet demonstrates the anti-pattern of using `$store.getState()` to access store values inside effects. This approach makes the effect dependent on the global store state, reducing reusability and testability. It gets `user` from `$user` and `settings` from `$settings`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst submitFormFx = createEffect((formData) => {\n  // get values through getState\n  const user = $user.getState();\n  const settings = $settings.getState();\n\n  return api.submit({\n    ...formData,\n    userId: user.id,\n    theme: settings.theme,\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Check if a value is an Event - Effector\nDESCRIPTION: This JavaScript snippet demonstrates how to use `is.event` to check if a given value is an Effector event. It creates a store, event, and effect, then uses `is.event` to determine their types.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/is.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain } from \"effector\";\n\nconst $store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\n\nis.event($store);\n// => false\n\nis.event(event);\n// => true\n\nis.event(fx);\n// => false\n\nis.event(createDomain());\n// => false\n\nis.event(fx.pending);\n// => false\n\nis.event(fx.done);\n// => true\n\nis.event($store.updates);\n// => true\n\nis.event(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: Effector Effect pending Store\nDESCRIPTION: Demonstrates how to use the `pending` store of an Effector Effect to track its loading state.  The example shows a React component that displays a loading message while the effect is pending and a completion message when it's done.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { createEffect } from \"effector\";\nimport { useUnit } from \"effector-react\";\n\nconst fetchApiFx = createEffect((ms) => new Promise((resolve) => setTimeout(resolve, ms)));\n\nfetchApiFx.pending.watch(console.log);\n\nconst Loading = () => {\n  const loading = useUnit(fetchApiFx.pending);\n\n  return <div>{loading ? \"Loading...\" : \"Load complete\"}</div>;\n};\n\nReactDOM.render(<Loading />, document.getElementById(\"root\"));\n\nfetchApiFx(3000);\n```\n\n----------------------------------------\n\nTITLE: Sample Multiple Targets - Typescript\nDESCRIPTION: Illustrates how to use an array of units in the `target` parameter of `sample`. It simultaneously triggers multiple effects (`saveUserFx`, `logUserFx`), updates a store (`$lastUserData`), and calls an event (`userDataReceived`) when the `userUpdated` event occurs.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, createEffect, sample } from \"effector\";\n\n// Создаем юниты куда будут направляться данные\nconst userDataReceived = createEvent<User>();\nconst $lastUserData = createStore<User | null>(null);\nconst saveUserFx = createEffect<User, void>((user) => {\n  // Сохраняем пользователя\n});\nconst logUserFx = createEffect<User, void>((user) => {\n  // Логируем действия с пользователем\n});\n\nconst userUpdated = createEvent<User>();\n\n// При обновлении пользователя:\n// - Сохраняем данные через saveUserFx\n// - Отправляем в систему логирования через logUserFx\n// - Обновляем стор $lastUserData\n// - Вызываем событие userDataReceived\nsample({\n  clock: userUpdated,\n  target: [saveUserFx, logUserFx, $lastUserData, userDataReceived],\n});\n```\n\n----------------------------------------\n\nTITLE: Store Creation with restore and Effect in effector\nDESCRIPTION: Demonstrates using `restore` with an effect to update a store with data from the effect's `doneData` event.  The `$newUser` store is initialized with a default value and updated with the result of the `createUserFx` effect upon successful completion.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { restore, createEffect } from \"effector\";\n\n// omit type realization\nconst createUserFx = createEffect<string, User>((id) => {\n  // effect logic\n\n  return {\n    id: 4,\n    name: \"Bob\",\n    age: 18,\n  };\n});\n\nconst $newUser = restore(createEffect, {\n  id: 0,\n  name: \"\",\n  age: -1,\n});\n\ncreateUserFx();\n\n// After successful completion of the effect\n// $newUser will be:\n// {\n// \t id: 4,\n// \t name: \"Bob\",\n// \t age: 18,\n// }\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Effects for Message Management in TypeScript\nDESCRIPTION: Defines Effector effects for loading, sending, and deleting messages. `messagesLoadFx` loads the message history, `messageSendFx` sends a new message, and `messageDeleteFx` deletes a message from the history. They all leverage the wait function to simulate network calls. Errors in `saveHistory` and `loadHistory` will trigger the `fail` event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// File: /src/shared/api/message.ts\n// Here effect defined with static types. void defines no arguments.\n// Second type argument defines a successful result type.\n// Third argument is optional and defines a failure result type.\nexport const messagesLoadFx = createEffect<void, Message[], Error>(async () => {\n  const history = loadHistory();\n  await wait();\n  return history ?? [];\n});\n\ninterface SendMessage {\n  text: string;\n  author: Author;\n}\n\n// But we can use type inferring and set arguments types in the handler defintion.\n// Hover your cursor on `messagesLoadFx` to see the inferred types:\n// `Effect<{ text: string; authorId: string; authorName: string }, void, Error>`\nexport const messageSendFx = createEffect(async ({ text, author }: SendMessage) => {\n  const message: Message = {\n    id: createOid(),\n    author,\n    timestamp: Date.now(),\n    text,\n  };\n  const history = await messagesLoadFx();\n  saveHistory([...history, message]);\n  await wait();\n});\n\n// Please, note that we will `wait()` for `messagesLoadFx` and `wait()` in the current effect\n// Also, note that `saveHistory` and `loadHistory` can throw exceptions,\n// in that case effect will trigger `messageDeleteFx.fail` event.\nexport const messageDeleteFx = createEffect(async (message: Message) => {\n  const history = await messagesLoadFx();\n  const updated = history.filter((found) => found.id !== message.id);\n  await wait();\n  saveHistory(updated);\n});\n```\n\n----------------------------------------\n\nTITLE: Example of using getState to check store value in different scopes\nDESCRIPTION: Demonstrates how to create two different scopes, trigger events in them, and then check the store's value in each scope using `.getState()`. This illustrates the isolation provided by scopes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Scope.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, fork, allSettled } from \"effector\";\n\nconst inc = createEvent();\nconst dec = createEvent();\nconst $counter = createStore(0);\n\n$counter.on(inc, (value) => value + 1);\n$counter.on(dec, (value) => value - 1);\n\nconst scopeA = fork();\nconst scopeB = fork();\n\nawait allSettled(inc, { scope: scopeA });\nawait allSettled(dec, { scope: scopeB });\n\nconsole.log($counter.getState()); // => 0\nconsole.log(scopeA.getState($counter)); // => 1\nconsole.log(scopeB.getState($counter)); // => -1\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Shape of Stores Source\nDESCRIPTION: Illustrates how to create attached effect `attachedFx` that receives parameters from the shape of stores `{a: $a, b: $b}` and omits the original params. Types of the `source` object must be the same as `originalFx` params. But the `attachedFx` will omit the type of params, it means the attached effect not requires any params at all.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst originalFx: Effect<{ a: A; b: B }, Done, Fail>;\nconst $a: Store<A>;\nconst $b: Store<B>;\n\nconst attachedFx: Effect<void, Done, Fail> = attach({\n  source: { a: $a, b: $b },\n  effect: originalFx,\n});\n```\n\n----------------------------------------\n\nTITLE: createComponent Example (JSX)\nDESCRIPTION: Demonstrates how to use `createComponent` to create a React component that displays and updates a counter based on an Effector store. It defines an Effector store `$counter` and an event `increment` and uses `createComponent` to connect the store to a React component that renders the counter value and a button to increment it. The state parameter in render function represents current value of store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/createComponent.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\nimport { createComponent } from \"effector-react\";\n\nconst increment = createEvent();\n\nconst $counter = createStore(0).on(increment, (n) => n + 1);\n\nconst MyCounter = createComponent($counter, (props, state) => (\n  <div>\n    Counter: {state}\n    <button onClick={increment}>increment</button>\n  </div>\n));\n\nconst MyOwnComponent = () => {\n  // any stuff here\n  return <MyCounter />;\n};\n```\n\n----------------------------------------\n\nTITLE: Importing from effector-vue/composition (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to import modules from effector-vue/composition. This module extends effector-vue with utilities designed for Vue's Composition API, providing a more seamless integration between Effector and Vue components. The imported modules facilitate state management and data binding within Vue components.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/module/composition.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {} from \"effector-vue/composition\";\n```\n\n----------------------------------------\n\nTITLE: Guard with Predicate Filter Example\nDESCRIPTION: Illustrates how to use `guard` with a predicate function as a filter. The `searchUser` effect is only triggered when the `submitForm` event receives a user name with a length greater than 0. Requires effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/guard.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect, createEvent, guard } from \"effector\";\n\nconst searchUser = createEffect();\nconst submitForm = createEvent();\n\nguard({\n  source: submitForm,\n  filter: (user) => user.length > 0,\n  target: searchUser,\n});\n\nsubmitForm(\"\"); // ничего не произошло\nsubmitForm(\"alice\"); // ~> searchUser('alice')\n```\n\n----------------------------------------\n\nTITLE: Sample with Multiple Triggers\nDESCRIPTION: This snippet demonstrates using an array of events as the `clock` for `sample`.  It triggers the `saveDocumentFx` effect when any of the specified events occur.  The example relies on `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, sample } from \"effector\";\n\n// Events for different user actions\nconst saveButtonClicked = createEvent();\nconst ctrlSPressed = createEvent();\nconst autoSaveTriggered = createEvent();\n\n// Common data storage\nconst $formData = createStore({ text: \"\" });\n\n// Save effect\nconst saveDocumentFx = createEffect((data: { text: string }) => {\n  // Save logic\n});\n\n// Single point for document saving that triggers from any source\nsample({\n  // All these events will trigger saving\n  clock: [saveButtonClicked, ctrlSPressed, autoSaveTriggered],\n  source: $formData,\n  target: saveDocumentFx,\n});\n```\n\n----------------------------------------\n\nTITLE: UI Component for Repo Star Button\nDESCRIPTION: This snippet shows the UI component for a repository star button using React and Effector. It imports the necessary events and stores from the business logic module (`repo.model.ts`) and uses the `useUnit` hook to connect the component to Effector's state management. The component renders a button that toggles the star state and displays the current star count. The UI component triggers the event and displays data.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/resources/mindset.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { repoStarToggled, $isRepoStarred, $repoStarsCount } from \"./repo.model.ts\";\n\nconst RepoStarButton = () => {\n  const [onStarToggle, isRepoStarred, repoStarsCount] = useUnit([\n    repoStarToggled,\n    $isRepoStarred,\n    $repoStarsCount,\n  ]);\n\n  return (\n    <div>\n      <button onClick={onStarToggle}>{isRepoStarred ? \"unstar\" : \"star\"}</button>\n      <span>{repoStarsCount}</span>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Incorrect Effector Component Usage without useUnit (TSX)\nDESCRIPTION: This snippet shows the incorrect way to use an Effector event in a React component without the `useUnit` hook.  Directly calling the event within the component's `onClick` handler can lead to scope-related issues.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/troubleshooting.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { event } from \"./model.js\";\n\nconst Component = () => {\n  return <button onClick={() => event()}></button>;\n};\n```\n\n----------------------------------------\n\nTITLE: Typing `sample` with `filter` using Boolean in TypeScript\nDESCRIPTION: This example demonstrates how to use `Boolean` with the `sample` function and `filter` to check for the existence of data. This is useful for filtering out `null` or `undefined` values from a stream of data before passing it to the `target` event. Only existing user data will be passed to `userDataSaved`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createEvent, createStore, sample } from \"effector\";\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\n// Events\nconst formSubmitted = createEvent();\nconst userDataSaved = createEvent<User>();\n\n// States\nconst $currentUser = createStore<User | null>(null);\n\n// On form submit, send data only if user exists\nsample({\n  clock: formSubmitted,\n  source: $currentUser,\n  filter: Boolean, // filter out null\n  target: userDataSaved,\n});\n\n// Now userDataSaved will only receive existing user data\n```\n\n----------------------------------------\n\nTITLE: Split function signature\nDESCRIPTION: This code shows the structure of parameters which could be passed into `split` function. It highlights that `match` param could be a function, store, or object of matchers\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({ source, match, cases });\n```\n\n----------------------------------------\n\nTITLE: Socket.IO Integration with Effector (TypeScript)\nDESCRIPTION: This code snippet sets up a Socket.IO client connection using Effector's reactive state management. It defines events for connection, disconnection, errors, and message handling, along with corresponding effects for managing the socket lifecycle and message transmission. The code uses createStore to store the socket instance and sample to trigger effects based on events.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/websocket-integration.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { io, Socket } from \"socket.io-client\";\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\nconst API_URL = \"wss://your.ws.server\";\n\n// События\nconst connected = createEvent();\nconst disconnected = createEvent();\nconst socketError = createEvent<Error>();\n\n// Типизация для событий\ntype ChatMessage = {\n  room: string;\n  message: string;\n  author: string;\n};\n\nconst messageSent = createEvent<ChatMessage>();\nconst messageReceived = createEvent<ChatMessage>();\nconst socketConnected = createEvent();\nconst connectSocket = createEvent();\n\nconst connectFx = createEffect((): Promise<Socket> => {\n  const socket = io(API_URL, {\n    //... ваша конфигурация\n  });\n\n  // нужно для корректной работы со скоупами\n  const scopeConnected = scopeBind(connected);\n  const scopeDisconnected = scopeBind(disconnected);\n  const scopeSocketError = scopeBind(socketError);\n  const scopeMessageReceived = scopeBind(messageReceived);\n\n  return new Promise((resolve, reject) => {\n    socket.on(\"connect\", () => {\n      scopeConnected();\n      resolve(socket);\n    });\n\n    socket.on(\"disconnect\", () => scopeDisconnected());\n    socket.on(\"connect_error\", (error) => scopeSocketError(error));\n    socket.on(\"chat message\", (msg: ChatMessage) => scopeMessageReceived(msg));\n  });\n});\n\nconst sendMessageFx = createEffect(\n  ({\n    socket,\n    name,\n    payload,\n  }: SocketResponse<any> & {\n    socket: Socket;\n  }) => {\n    socket.emit(name, payload);\n  },\n);\n\n// Состояния\nconst $socket = createStore<Socket | null>(null)\n  .on(connectFx.doneData, (_, socket) => socket)\n  .reset(disconnected);\n\n// инициализация подключения\nsample({\n  clock: connectSocket,\n  target: connectFx,\n});\n\n// вызываем событие после успешного подключения\nsample({\n  clock: connectSocketFx.doneData,\n  target: socketConnected,\n});\n```\n\n----------------------------------------\n\nTITLE: Fixing Unit Calls with sample (TS)\nDESCRIPTION: This code demonstrates the correct way to trigger an event from within a function that processes another event's payload using the `sample` operator. This addresses the error from calling units inside pure functions. This showcases the fix.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst someHappened = createEvent<number>();\nconst another = createEvent();\nconst derived = createEvent<string>();\n\nsample({\n  clock: someHappened,\n  target: another,\n});\n\n// The same as .map(), but using `target`\nsample({\n  clock: someHappened,\n  fn: (number) => String(number),\n  target: derived,\n});\n```\n\n----------------------------------------\n\nTITLE: Sending Message Event\nDESCRIPTION: This snippet shows how to create an event (messageSend) that triggers when either the Enter key is pressed or the Send button is clicked. It merges two events (messageEnterPressed and messageSendClicked) into a single event for sending messages.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\n// У нас есть два разных события для отправки сообщения\n// Пусть событие `messageSend` реагирует на любое из них\nconst messageSend = merge([messageEnterPressed, messageSendClicked]);\n```\n\n----------------------------------------\n\nTITLE: Session Creation Logic\nDESCRIPTION: This snippet implements the session creation logic. When the `loginClicked` event is triggered, it initiates the `sessionApi.sessionCreateFx` effect.  On successful session creation, the `$session` store is updated with the new session data. If it fails, the $session is reset to null.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\n// Когда пользователь нажимает кнопку входа, нам нужно создать новую сессию\nsample({\n  clock: loginClicked,\n  target: sessionApi.sessionCreateFx,\n});\n// Когда сессия создана, просто положите его в хранилище сессий\nsample({\n  clock: sessionApi.sessionCreateFx.doneData,\n  target: $session,\n});\n// Если создание сессии не удалось, просто сбросьте сессию\nsample({\n  clock: sessionApi.sessionCreateFx.fail,\n  fn: () => null,\n  target: $session,\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Events and Store - Typescript\nDESCRIPTION: Defines basic events and a store for managing WebSocket connection state using Effector.  It includes events for disconnection, message sending, and raw message reception, as well as a store to hold the WebSocket instance. The store is updated upon successful connection and reset upon disconnection.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\n// Events for working with socket\nconst disconnected = createEvent();\nconst messageSent = createEvent<string>();\nconst rawMessageReceived = createEvent<string>();\n\nconst $connection = createStore<WebSocket | null>(null)\n  .on(connectWebSocketFx.doneData, (_, ws) => ws)\n  .reset(disconnected);\n```\n\n----------------------------------------\n\nTITLE: Effector Effect inFlight Store\nDESCRIPTION: Illustrates how to use the `inFlight` store of an Effector Effect to track the number of currently executing effect calls. The example demonstrates how the `inFlight` store increases with each effect call and decreases upon completion.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect(() => new Promise((rs) => setTimeout(rs, 500)));\n\nfx.inFlight.watch((amount) => {\n  console.log(\"in-flight requests:\", amount);\n});\n// => 0\n\nconst req1 = fx();\n// => 1\n\nconst req2 = fx();\n// => 2\n\nawait Promise.all([req1, req2]);\n\n// => 1\n// => 0\n```\n\n----------------------------------------\n\nTITLE: Event Testing with Effector\nDESCRIPTION: This code snippet demonstrates how to test an event in Effector. It uses `createWatch` to create a subscription to the event within a forked scope and `allSettled` to trigger the event in the scope. It then asserts that the watcher function was called the expected number of times using Jest's `toHaveBeenCalledTimes` method.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/testing.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createWatch, fork } from \"effector\";\nimport { userUpdated } from \"../\";\n\ntest(\"should handle user update with scope\", async () => {\n  const scope = fork();\n  const fn = jest.fn();\n\n  // Create a watcher in the specific scope\n  const unwatch = createWatch({\n    unit: userUpdated,\n    fn,\n    scope,\n  });\n\n  // Trigger the event in scope\n  await allSettled(userUpdated, {\n    scope,\n  });\n\n  expect(fn).toHaveBeenCalledTimes(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Resetting Store State - Effector\nDESCRIPTION: Shows how to reset a store's state to its initial value using the `reset` method. It shows resetting with a single event and with an array of events.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/manage-states.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst formSubmitted = createEvent();\nconst formReset = createEvent();\n\nconst $form = createStore({ email: \"\", password: \"\" })\n  // очищаем форму при сабмите и явном сбросе\n  .reset(formReset, formSubmitted);\n  // или\n  .reset([formReset, formSubmitted]);\n```\n\n----------------------------------------\n\nTITLE: React UI Component using Effector\nDESCRIPTION: This snippet presents a React UI component that integrates with Effector to handle the star button functionality. It uses `useUnit` to connect the component to the `repoStarToggled` event and the `$isRepoStarred` and `$repoStarsCount` stores.  The component dispatches the event when the button is clicked and displays the current star state and count.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/resources/mindset.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { repoStarToggled, $isRepoStarred, $repoStarsCount } from \"./repo.model.ts\";\n\nconst RepoStarButton = () => {\n  const [onStarToggle, isRepoStarred, repoStarsCount] = useUnit([\n    repoStarToggled,\n    $isRepoStarred,\n    $repoStarsCount,\n  ]);\n\n  return (\n    <div>\n      <button onClick={onStarToggle}>{isRepoStarred ? \"unstar\" : \"star\"}</button>\n      <span>{repoStarsCount}</span>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Last Message Store - Typescript\nDESCRIPTION: Creates an Effector store to hold the last received WebSocket message.  The store updates its state whenever a new raw message is received.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst $lastMessage = createStore<string>(\"\");\n\n$lastMessage.on(rawMessageReceived, (_, newMessage) => newMessage);\n```\n\n----------------------------------------\n\nTITLE: Basic useStoreMap example with config (JSX)\nDESCRIPTION: This is an example of using the `useStoreMap` hook to efficiently render a list of users. The component re-renders a specific user only when that user's data changes in the store, by keying on the `id` of the user.  It showcases the `keys` argument usage and providing a default value if a user is not found.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useStoreMap.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { useList, useStoreMap } from \"effector-react\";\n\nconst usersRaw = [\n  {\n    id: 1,\n    name: \"Yung\",\n  },\n  {\n    id: 2,\n    name: \"Lean\",\n  },\n  {\n    id: 3,\n    name: \"Kyoto\",\n  },\n  {\n    id: 4,\n    name: \"Sesh\",\n  },\n];\n\nconst $users = createStore(usersRaw);\nconst $ids = createStore(usersRaw.map(({ id }) => id));\n\nconst User = ({ id }) => {\n  const user = useStoreMap({\n    store: $users,\n    keys: [id],\n    fn: (users, [userId]) => users.find(({ id }) => id === userId) ?? null,\n  });\n\n  return (\n    <div>\n      <strong>[{user.id}]</strong> {user.name}\n    </div>\n  );\n};\n\nconst UserList = () => {\n  return useList($ids, (id) => <User id={id} />);\n};\n\n```\n\n----------------------------------------\n\nTITLE: Mapping Event Payload (JS)\nDESCRIPTION: This code demonstrates how to decompose data flow or transform data using the `.map()` method.  It shows how to create derived events from an original event, extracting specific fields or transforming the data.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst userUpdated = createEvent();\n\n// you may decompose dataflow with .map() method\nconst userNameUpdated = userUpdated.map(({ user }) => name);\n\n// either way you can transform data\nconst userRoleUpdated = userUpdated.map((user) => user.role.toUpperCase());\n\nuserNameUpdated.watch((name) => console.log(`User's name is [${name}] now`));\nuserRoleUpdated.watch((role) => console.log(`User's role is [${role}] now`));\n\nuserUpdated({ name: \"john\", role: \"admin\" });\n// => User's name is [john] now\n// => User's role is [ADMIN] now\n```\n\n----------------------------------------\n\nTITLE: Effector Split Direct Matching\nDESCRIPTION: An example of `split` matching directly with a store. It shows how to use `createApi` to modify a store based on the message type.  The `split` function routes the messages to the appropriate API method of the `$textContent` store based on the `type` property of the incoming message.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { split, createStore, createEvent, createApi } from \"effector\";\n\nconst messageReceived = createEvent();\n\nconst $textContent = createStore([]);\n\nsplit({\n  source: messageReceived,\n  match: {\n    text: (msg) => msg.type === \"text\",\n    audio: (msg) => msg.type === \"audio\",\n  },\n  cases: createApi($textContent, {\n    text: (list, { value }) => [...list, value],\n    audio: (list, { duration }) => [...list, `аудио ${duration} мс`],\n    __: (list) => [...list, \"неизвестное сообщение\"],\n  }),\n});\n\n$textContent.watch((messages) => {\n  console.log(messages);\n});\n\nmessageReceived({\n  type: \"text\",\n  value: \"Привет\",\n});\n// => ['Привет']\nmessageReceived({\n  type: \"image\",\n  imageUrl: \"...\",\n});\n// => ['Привет', 'неизвестное сообщение']\nmessageReceived({\n  type: \"audio\",\n  duration: 500,\n});\n// => ['Привет', 'неизвестное сообщение', 'аудио 500 мс']\n```\n\n----------------------------------------\n\nTITLE: Assigning Handler to Effector Effect After Creation\nDESCRIPTION: Shows how to assign a handler to an Effector effect after its creation using the `.use()` method. The handler fetches user repositories. Requires effector package. The effect is invoked with an object containing the 'name' property.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createEffect.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect();\n\nfetchUserReposFx.use(async ({ name }) => {\n  const url = `https://api.github.com/users/${name}/repos`;\n  const req = await fetch(url);\n  return req.json();\n});\n\nawait fetchUserReposFx({ name: \"zerobias\" });\n```\n\n----------------------------------------\n\nTITLE: Using effector-react with custom Route entity\nDESCRIPTION: Illustrates how to integrate a custom `Route` entity (from a hypothetical `my-router-library`) with effector-react using the `useUnit` hook. It assumes a `createRoute` function exists and demonstrates how to access the route's parameters within a React component. Dependencies include effector-react and the custom `my-router-library`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/ecosystem-development/unit-shape-protocol.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createRoute } from \"my-router-library\";\nimport { useUnit } from \"effector-react\";\n\nconst mainPageRoute = createRoute(/* ... */);\n\nconst Component = () => {\n  const { params } = useUnit(mainPageRoute);\n\n  return <p>{params.name}</p>;\n};\n```\n\n----------------------------------------\n\nTITLE: Complete Timer Implementation with scopeBind\nDESCRIPTION: This code presents the complete timer implementation, incorporating the `scopeBind` function to ensure the `tick` event is executed within the correct scope.  It includes event definitions, effect creation for starting and stopping the timer, and stores for timer count and ID. The logic also includes `sample` calls to manage timer starting and stopping.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/advanced/work-with-scope.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, createEvent, createStore, sample, scopeBind } from \"effector\";\n\nconst TIMEOUT = 1_000;\n\nconst timerStopped = createEvent();\nconst timerReset = createEvent();\nconst timerStarted = createEvent();\nconst tick = createEvent();\n\n// запуск таймера\nconst startFx = createEffect(() => {\n  // привязываем событие к текущему активному скоупу\n  const bindedTick = scopeBind(tick);\n\n  const intervalId = setInterval(() => {\n    bindedTick();\n  }, TIMEOUT);\n\n  return intervalId;\n});\n\n// остановка и очистка таймера\nconst stopFx = createEffect((timerId: number) => {\n  clearInterval(timerId);\n});\n\n// счетчик времени в секундах\nconst $timerCount = createStore(0)\n  .on(tick, (seconds) => seconds + 1)\n  .reset(timerReset);\n\n// id таймера\nconst $timerId = createStore<null | number>(null)\n  .on(startFx.doneData, (_, timerId) => timerId)\n  .reset(stopFx.finally);\n\n// логика запуска таймера\nsample({\n  clock: timerStarted,\n  filter: $timerId.map((timerId) => !timerId),\n  target: startFx,\n});\n\n// логика остановки таймера\nsample({\n  clock: timerStopped,\n  source: $timerId,\n  filter: Boolean,\n  target: stopFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Effector Core Logic\nDESCRIPTION: This snippet defines the core logic of the todo application using Effector. It creates events for user interactions (submit, submitted, completed, changed, removed), stores for application state ($todo, $todos, $error), and an effect (validateFx) for input validation.  It also defines how the stores react to events.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/todo-with-validation.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore, createEffect, restore, combine, sample } from \"effector\";\nimport { useUnit, useList } from \"effector-react\";\n\nconst submit = createEvent();\nconst submitted = createEvent();\nconst completed = createEvent();\nconst changed = createEvent();\nconst removed = createEvent();\n\nconst validateFx = createEffect(([todo, todos]) => {\n  if (todos.some((item) => item.text === todo)) throw \"This todo is already on the list\";\n  if (!todo.trim().length) throw \"Required field\";\n  return null;\n});\n\nconst $todo = createStore(\"\");\nconst $todos = createStore([]);\nconst $error = createStore(\"\");\n\n$todo.on(changed, (_, todo) => todo);\n$error.reset(changed);\n\n$todos.on(completed, (list, index) =>\n  list.map((todo, foundIndex) => ({\n    ...todo,\n    completed: index === foundIndex ? !todo.completed : todo.completed,\n  })),\n);\n$todos.on(removed, (state, index) => state.filter((_, i) => i !== index));\n\nsample({\n  clock: submit,\n  source: [$todo, $todos],\n  target: validateFx,\n});\n\nsample({\n  clock: validateFx.done,\n  source: $todo,\n  target: submitted,\n});\n\n$todos.on(submitted, (list, text) => [...list, { text, completed: false }]);\n$todo.reset(submitted);\n\n$error.on(validateFx.failData, (_, error) => error);\n\nsubmit.watch((e) => e.preventDefault());\n```\n\n----------------------------------------\n\nTITLE: Initializing Router Model with Effector (JavaScript)\nDESCRIPTION: This snippet initializes an Effector model for managing the Next.js router. It creates events for attaching the router instance and triggering navigation. A store holds the router instance, and an effect is used to perform the navigation. It depends on 'effector' and 'next/dist/shared/lib/app-router-context.shared-runtime'.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/nextjs/router.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { attach, createEvent, createStore, sample } from 'effector'\nimport { AppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime'\n\nconst routerAttached = createEvent<AppRouterInstance>()\nconst navigationTriggered = createEvent<string>()\n\nconst $router = createStore<AppRouterInstance | null>(null).on(\n  routerAttached,\n  (_, router) => router,\n)\n\nconst navigateFx = attach({\n  source: $router,\n  effect: (router, path) => {\n    if (!router) return\n    return router.push(path)\n  },\n})\n\nsample({\n  clock: navigationTriggered,\n  target: navigateFx,\n})\n\nexport { navigationTriggered, routerAttached }\n\n```\n\n----------------------------------------\n\nTITLE: Basic Gate Usage - JavaScript\nDESCRIPTION: Demonstrates the basic usage of `createGate` in a Solid.js application.  It imports `createGate` from \"effector-solid\", creates a gate with a name, renders a component using `Gate`, and watches the gate's state for changes.  The gate receives props from the Solid component and updates its state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/createGate.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createGate } from \"effector-solid\";\nimport { render } from \"solid-js/web\";\n\nconst Gate = createGate(\"gate with props\");\n\nconst App = () => (\n  <section>\n    <Gate foo=\"bar\" />\n  </section>\n);\n\nGate.state.watch((state) => {\n  console.log(\"current state\", state);\n});\n// => current state {}\n\nconst unmount = render(() => <App />, document.getElementById(\"root\"));\n// => current state {foo: 'bar'}\n\nunmount();\n// => current state {}\n```\n\n----------------------------------------\n\nTITLE: Filtering Event Payload (TS)\nDESCRIPTION: This code shows how to use the `.filter()` method to create a new event that is triggered only when a condition is met. The example filters for even numbers.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst numberReceived = createEvent<number>();\n// numberReceived: Event<number>\n\nconst evenReceived = numberReceived.filter({\n  fn: (number) => number % 2 === 0,\n});\n// evenReceived: Event<number>\n\nevenReceived.watch(console.info);\nnumberReceived(5); // nothing\nnumberReceived(2); // => 2\n```\n\n----------------------------------------\n\nTITLE: Effector Feature Model Example\nDESCRIPTION: Presents an example of an Effector application with multiple features, each with its own stores and events. It shows how events can be triggered from different parts of the application and how stores react accordingly, without a central point of control.  It illustrates a feature for first name, last name, and a combined form model.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// src/features/first-name/model.ts\nimport { createStore, createEvent } from \"effector\";\n\nexport const firstNameChanged = createEvent<string>();\nexport const $firstName = createStore(\"\");\n\n$firstName.on(firstNameChanged, (_, firstName) => firstName);\n\n// src/features/last-name/model.ts\nimport { createStore, createEvent } from \"effector\";\n\nexport const lastNameChanged = createEvent<string>();\nexport const $lastName = createStore(\"\");\n\n$lastName.on(lastNameChanged, (_, lastName) => lastName);\n\n// src/features/form/model.ts\nimport { createEvent, sample, combine } from \"effector\";\n\nimport { $firstName, firstNameChanged } from \"@/features/first-name\";\nimport { $lastName, lastNameChanged } from \"@/features/last-name\";\n\nexport const formValuesFilled = createEvent<{ firstName: string; lastName: string }>();\n\nexport const $fullName = combine($firstName, $lastName, (first, last) => `${first} ${last}`);\n\nsample({\n  clock: formValuesFilled,\n  fn: (values) => values.firstName,\n  target: firstNameChanged,\n});\n\nsample({\n  clock: formValuesFilled,\n  fn: (values) => values.lastName,\n  target: lastNameChanged,\n});\n```\n\n----------------------------------------\n\nTITLE: Effector React App - Common Code (TypeScript)\nDESCRIPTION: This TypeScript code defines a simple counter application using Effector and React. It includes Effector stores, events, and effects for managing the counter state, fetching data, and handling user interactions. The code also demonstrates how to use `useUnit` to connect Effector units to React components and how to handle client-side specific logic.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/server-side-rendering.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// app.tsx\nimport React from \"react\";\nimport { createEvent, createStore, createEffect, sample, combine } from \"effector\";\nimport { useUnit } from \"effector-react\";\n\n// модель\nexport const appStarted = createEvent();\nexport const $pathname = createStore<string | null>(null);\n\nconst $counter = createStore<number | null>(null);\n\nconst fetchUserCounterFx = createEffect(async () => {\n  await sleep(100); // в реальной жизни это был бы какой-то API-запрос\n\n  return Math.floor(Math.random() * 100);\n});\n\nconst buttonClicked = createEvent();\nconst saveUserCounterFx = createEffect(async (count: number) => {\n  await sleep(100); // в реальной жизни это был бы какой-то API-запрос\n});\n\nsample({\n  clock: appStarted,\n  source: $counter,\n  filter: (count) => count === null, // если счетчик уже загружен – не загружать его снова\n  target: fetchUserCounterFx,\n});\n\nsample({\n  clock: fetchUserCounterFx.doneData,\n  target: $counter,\n});\n\nsample({\n  clock: buttonClicked,\n  source: $counter,\n  fn: (count) => count + 1,\n  target: [$counter, saveUserCounterFx],\n});\n\nconst $countUpdatePending = combine(\n  [fetchUserCounterFx.pending, saveUserCounterFx.pending],\n  (updates) => updates.some((upd) => upd === true),\n);\n\nconst $isClient = createStore(typeof document !== \"undefined\", {\n  /**\n   * Здесь мы явно указываем effector, что это стор, которое зависит от окружения,\n   * никогда не должно включаться в сериализацию,\n   * так как оно должно всегда вычисляться на основе текущего окружения.\n   *\n   * Это не обязательно, так как в сериализацию включается только разница изменений состояния,\n   * и этот стор не будет изменяться.\n   *\n   * Но всё же хорошо добавить эту настройку – чтобы подчеркнуть намерение.\n   */\n  serialize: \"ignore\",\n});\n\nconst notifyFx = createEffect((message: string) => {\n  alert(message);\n});\n\nsample({\n  clock: [\n    saveUserCounterFx.done.map(() => \"Обновление счетчика успешно сохранено\"),\n    saveUserCounterFx.fail.map(() => \"Не удалось сохранить обновление счетчика :(\"),\n  ],\n  // Совершенно нормально иметь некоторые ветвления в логике приложения в зависимости от текущего окружения.\n  //\n  // Здесь мы хотим вызвать уведомление только на клиенте.\n  filter: $isClient,\n  target: notifyFx,\n});\n\n// UI\nexport function App() {\n  const clickButton = useUnit(buttonClicked);\n  const { count, updatePending } = useUnit({\n    count: $counter,\n    updatePending: $countUpdatePending,\n  });\n\n  return (\n    <div>\n      <h1>Приложение-счетчик</h1>\n      <h2>\n        {updatePending ? \"Счетчик обновляется\" : `Текущее значение: ${count ?? \"неизвестно\"}`}\n      </h2>\n      <button onClick={() => clickButton()}>Обновить счетчик</button>\n    </div>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Formula for .getState()\nDESCRIPTION: A Typescript example of the `.getState` call. Demonstrates how to get a store value from a specified scope\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Scope.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst scope: Scope;\nconst $value: Store<T> | StoreWritable<T>;\n\nconst value: T = scope.getState($value);\n```\n\n----------------------------------------\n\nTITLE: Effector Effect finally Type\nDESCRIPTION: Declares the type for `effect.finally` event which is `Event<Success | Failure>`, where Success and Failure are types representing successful and failed effect execution.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ntype Success = { status: 'done'; params: Params; result: Done }\ntype Failure = { status: 'fail'; params: Params; error: Fail }\n\neffect.finally: Event<Success | Failure>;\n```\n\n----------------------------------------\n\nTITLE: Loading Messages and Session on Page Mount\nDESCRIPTION: This code uses Effector's `sample` function to trigger loading of messages and the user session when the `pageMounted` event occurs. It utilizes `messageApi.messagesLoadFx` and `sessionApi.sessionLoadFx` to perform the loading.  This ensures both operations run concurrently upon page load.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\n// File: /src/pages/chat/model.ts\n// Don't forget to import { sample } from \"effector\"\nimport { Message, messageApi, sessionApi } from \"shared/api\";\nimport { $session } from \"entities/session\";\n\n// export stores\n// export events\n\n// Here the logic place\n\n// You can read this code like:\n// When page mounted, call messages load and session load simultaneously\nsample({\n  clock: pageMounted,\n  target: [messageApi.messagesLoadFx, sessionApi.sessionLoadFx],\n});\n```\n\n----------------------------------------\n\nTITLE: Import createStore from effector\nDESCRIPTION: Imports the `createStore` function along with related types from the Effector library.  This import statement makes the `createStore` function available for creating stores, and the `Store` and `StoreWritable` types available for type annotations.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createStore.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, type Store, type StoreWritable } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Combining Stores with Transformation (array, function)\nDESCRIPTION: This snippet demonstrates combining stores using an array of stores and a transformation function.  The state from each store is read and assigned to the array in the same order.  The array is then passed to the function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/combine.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst $a: Store<A>;\nconst $b: StoreWritable<B>;\nconst $c: Store<C> | StoreWritable<C>;\n\n$result: Store<D> = combine([$a, $b, $c], ([A, B, C]): D => result);\n```\n\n----------------------------------------\n\nTITLE: Connecting Units with Sample in Effector\nDESCRIPTION: This code snippet demonstrates connecting Effector units into a single flow using the `sample` method. It initializes stores (`$supers`, `$superHeroes`, `$superVillains`), events (`superAdded`), and effects (`getSupersFx`, `saveNewSuperFx`). `sample` is used to trigger `saveNewSuperFx` when `superAdded` occurs and to trigger `getSupersFx` upon successful completion of `saveNewSuperFx`. The code simulates fetching and saving data to a server.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/core-concepts.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\nconst $supers = createStore([]);\nconst $superHeroes = $supers.map((supers) => supers.filter((sup) => sup.role === \"hero\"));\nconst $superVillains = $supers.map((supers) => supers.filter((sup) => sup.role === \"villain\"));\n\nconst superAdded = createEvent();\n\nconst getSupersFx = createEffect(async () => {\n  const res = await fetch(\"/server/api/supers\");\n  if (!res.ok) {\n    throw new Error(\"something went wrong\");\n  }\n  const data = await res.json();\n  return data;\n});\n\nconst saveNewSuperFx = createEffect(async (newSuper) => {\n  // Simulate saving a new super\n  await new Promise((res) => setTimeout(res, 1500));\n  return newSuper;\n});\n\n$supers.on(getSupersFx.done, ({ result }) => result);\n$supers.on(superAdded, (supers, newSuper) => [...supers, newSuper]);\n\n// when clock triggered called target and pass data\nsample({\n  clock: superAdded,\n  target: saveNewSuperFx,\n});\n\n// when saveNewSuperFx successfully done called getSupersFx\nsample({\n  clock: saveNewSuperFx.done,\n  target: getSupersFx,\n});\n\n// Trigger the data fetch\ngetSupersFx();\n```\n\n----------------------------------------\n\nTITLE: Reporting Clicks with sendAnalytics and prepend in Effector (TS)\nDESCRIPTION: This code demonstrates how to use the `prepend` method to transform input data before passing it to the `sendAnalytics` function.  It effectively wraps the function and provides a consistent data structure. The snippet assumes that the `sendAnalytics` function is imported from './analytics'.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sendAnalytics } from \"./analytics\";\n\nexport function reportClick(item: string) {\n  const argument = { type: \"click\", container: { items: [arg] } };\n  return sendAnalytics(argument);\n}\n```\n\n----------------------------------------\n\nTITLE: Create and Use Effector Store in JavaScript\nDESCRIPTION: This JavaScript example demonstrates how to create a store using `createStore` from Effector, and how to update and reset it using `on` and `reset` methods respectively. It also shows how to derive a new store using `map` and how to watch the store's state using `watch` method.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createStore.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst addTodo = createEvent();\nconst clearTodos = createEvent();\n\nconst $todos = createStore([])\n  .on(addTodo, (state, todo) => [...state, todo])\n  .reset(clearTodos);\n\nconst $selectedTodos = $todos.map((todos) => {\n  return todos.filter((todo) => !!todo.selected);\n});\n\n$todos.watch((state) => {\n  console.log(\"todos\", state);\n});\n```\n\n----------------------------------------\n\nTITLE: Using useStoreMap with a list\nDESCRIPTION: Demonstrates a use case of `useStoreMap` with a configuration object, focusing on efficient list rendering. It uses a store of users and extracts specific user data based on an ID, preventing unnecessary re-renders by only updating when the relevant user data changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useStoreMap.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { useUnit, useStoreMap } from \"effector-solid\";\nimport { For } from \"solid-js/web\";\n\nconst usersRaw = [\n  {\n    id: 1,\n    name: \"Yung\",\n  },\n  {\n    id: 2,\n    name: \"Lean\",\n  },\n  {\n    id: 3,\n    name: \"Kyoto\",\n  },\n  {\n    id: 4,\n    name: \"Sesh\",\n  },\n];\n\nconst $users = createStore(usersRaw);\nconst $ids = createStore(usersRaw.map(({ id }) => id));\n\nconst User = ({ id }) => {\n  const user = useStoreMap({\n    store: $users,\n    keys: [id],\n    fn: (users, [userId]) => users.find(({ id }) => id === userId) ?? null,\n  });\n\n  return (\n    <div>\n      <strong>[{user()?.id}]</strong> {user()?.name}\n    </div>\n  );\n};\n\nconst UserList = () => {\n  const ids = useUnit($ids);\n\n  return <For each={ids()}>{(id) => <User key={id} id={id} />}</For>;\n};\n\n```\n\n----------------------------------------\n\nTITLE: Backend Request Effect\nDESCRIPTION: Defines an asynchronous effect `backendRequestFx` for making API requests, including request options like method and headers.  It also defines a store `$requestsSent` to track the total number of requests sent. The store is updated on each successful request.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// ./api/request.ts\nimport { createEffect, createStore } from \"effector\";\n\nexport const backendRequestFx = createEffect(async ({ token, data, resource }) => {\n  return fetch(`https://example.com/api${resource}`, {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${token}`,\n    },\n    body: JSON.stringify(data),\n  });\n});\n\nexport const $requestsSent = createStore(0);\n\n$requestsSent.on(backendRequestFx, (total) => total + 1);\n```\n\n----------------------------------------\n\nTITLE: Store .on() Example - Javascript\nDESCRIPTION: Updates a store's state using the `.on()` method, which takes an event as a trigger and a reducer function. The reducer function calculates the new state based on the current state and the event payload. In this example, the store is incremented by the value passed to the `changed` event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst $store = createStore(0);\nconst changed = createEvent();\n\n$store.on(changed, (value, incrementor) => value + incrementor);\n\n$store.watch((value) => {\n  console.log(\"updated\", value);\n});\n\nchanged(2);\nchanged(2);\n```\n\n----------------------------------------\n\nTITLE: Practical Effect Example\nDESCRIPTION: This code snippet illustrates a practical example of using Effector effects to load user data based on an ID entered by the user. It uses stores, events, and effects to manage the data loading process and display any errors that occur. Demonstrates setting id, submitting form and updating user and error stores.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/work-with-async.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\n// Эффект для загрузки данных\nconst fetchUserFx = createEffect(async (id: number) => {\n  const response = await fetch(`/api/user/${id}`);\n\n  if (!response.ok) {\n    // можно модифицировать ошибку, прежде чем она попадет в fail/failData\n    throw new Error(\"User not found\");\n  }\n\n  return response.json();\n});\n\nconst setId = createEvent<number>();\nconst submit = createEvent();\n\nconst $id = createStore(0);\nconst $user = createStore<{ name: string } | null>(null);\nconst $error = createStore<string | null>(null);\nconst $isLoading = fetchUserFx.pending;\n\n$id.on(setId, (_, id) => id);\n$user.on(fetchUserFx.doneData, (_, user) => user);\n$error.on(fetchUserFx.fail, (_, { error }) => error.message);\n$error.reset(fetchUserFx.done);\n\n// Логика загрузки: запускаем fetchUserFx при submit\nsample({\n  clock: submit,\n  source: $id,\n  target: fetchUserFx,\n});\n\n// Использование\nsetId(1); // Устанавливаем ID\nsubmit(); // Загружаем данные\n```\n\n----------------------------------------\n\nTITLE: Correct usage of Effector events with useUnit in React (JSX)\nDESCRIPTION: This code snippet demonstrates the correct way to use Effector events in a React component using the `useUnit` hook. By passing the event to `useUnit`, the component correctly binds the event to the current scope, ensuring proper functionality and avoiding scope-related issues.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/troubleshooting.mdx#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { event } from \"./model.js\";\nimport { useUnit } from \"effector-react\";\n\nconst Component = () => {\n  const onEvent = useUnit(event);\n\n  return <button onClick={() => onEvent()}></button>;\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Effector Events (Declarative)\nDESCRIPTION: This snippet showcases the declarative approach to using Effector events with `sample`. Two events, `firstTriggered` and `secondTriggered`, are created.  `sample` is used to trigger `secondTriggered` when `firstTriggered` is invoked, establishing a sequence of events.  This demonstrates how events can be linked to create reactive workflows.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, sample } from \"effector\";\n\nconst firstTriggered = createEvent<void>();\nconst secondTriggered = createEvent<void>();\n\nsample({\n  clock: firstTriggered,\n  target: secondTriggered,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Domain and Effect (common)\nDESCRIPTION: This snippet creates an Effector domain and an effect named `exampleEffect`.  The `createDomain` function initializes a new domain, and `api.effect()` creates an effect within that domain. This effect will be used for communication between client and worker.\nSOURCE: https://github.com/effector/effector/blob/master/examples/worker-rpc/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {createDomain} from 'effector'\nexport const api = createDomain()\n\nexport const exampleEffect = api.effect()\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Gate in Effector-Vue\nDESCRIPTION: This example demonstrates how to create a gate using `createGate` in Effector-Vue and integrate it with a Vue component using `useGate` from `effector-vue/composition`. It also shows how to pass data to the gate and watch its state. The example uses Vue's composition API for setting up the component logic and passing props.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/createGate.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createGate, useGate } from \"effector-vue/composition\";\n\nconst ListGate = createGate({\n  name: \"Gate with required props\",\n});\n\nconst ListItem = {\n  template: `\n    <div>\n      {{id}}\n    </div>\n  `,\n  props: {\n    id: {\n      type: String,\n      required: true,\n    },\n  },\n  setup(props) {\n    useGate(ListGate, () => props.id);\n  },\n};\n\nconst app = {\n  template: `\n    <div>\n      <ListItem :id=\"id\" />\n    </div>\n  `,\n  components: {\n    ListItem,\n  },\n  setup() {\n    const id = ref(\"1\");\n    return { id };\n  },\n};\n\nGate.state.watch((state) => {\n  console.log(\"current state\", state);\n});\n// => current state null\n\napp.mount(\"#app\");\n// => current state 1\n\napp.unmount();\n// => current state null\n```\n\n----------------------------------------\n\nTITLE: Complete Effector Example\nDESCRIPTION: This code defines a complete Effector example with an event, store, and effect, demonstrating a counter with asynchronous validation. When a button is clicked, the code checks if the counter is less than 100 and then validates the click through a backend API. On successful validation, the counter increments; otherwise, it resets to zero.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/testing.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, createEffect, sample } from \"effector\";\n\nexport const buttonClicked = createEvent();\n\nexport const validateClickFx = createEffect(async () => {\n  /* external API call */\n});\n\nexport const $clicksCount = createStore(0);\n\nsample({\n  clock: buttonClicked,\n  source: $clicksCount,\n  filter: (count) => count < 100,\n  target: validateClickFx,\n});\n\nsample({\n  clock: validateClickFx.done,\n  source: $clicksCount,\n  fn: (count) => count + 1,\n  target: $clicksCount,\n});\n\nsample({\n  clock: validateClickFx.fail,\n  fn: () => 0,\n  target: $clicksCount,\n});\n```\n\n----------------------------------------\n\nTITLE: Effector Unit Composition with Sample (TypeScript)\nDESCRIPTION: This code demonstrates how to use Effector's `sample` method to connect events and effects. It creates stores for supers, heroes, and villains, defines events for adding supers, and effects for fetching and saving super data. The `sample` method is used to trigger the `saveNewSuperFx` effect when the `superAdded` event is triggered, and to trigger the `getSupersFx` effect when `saveNewSuperFx` completes successfully.  It simulates saving a new super using `setTimeout`. Requires the `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/core-concepts.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\nconst $supers = createStore([]);\nconst $superHeroes = $supers.map((supers) => supers.filter((sup) => sup.role === \"hero\"));\nconst $superVillains = $supers.map((supers) => supers.filter((sup) => sup.role === \"villain\"));\n\nconst superAdded = createEvent();\n\nconst getSupersFx = createEffect(async () => {\n  const res = await fetch(\"/server/api/supers\");\n  if (!res.ok) {\n    throw new Error(\"something went wrong\");\n  }\n  const data = await res.json();\n  return data;\n});\n\nconst saveNewSuperFx = createEffect(async (newSuper) => {\n  // симуляция сохранения нового супера\n  await new Promise((res) => setTimeout(res, 1500));\n  return newSuper;\n});\n\n$supers.on(getSupersFx.done, ({ result }) => result);\n$supers.on(superAdded, (supers, newSuper) => [...supers, newSuper]);\n\n// здесь мы говорим, при запуске clock вызови target и передай туда данные\nsample({\n  clock: superAdded,\n  target: saveNewSuperFx,\n});\n\n// когда эффект saveNewSuperFx завершится успешно, то вызови getSupersFx\nsample({\n  clock: saveNewSuperFx.done,\n  target: getSupersFx,\n});\n\n// вызываем загрузку данных\ngetSupersFx();\n```\n\n----------------------------------------\n\nTITLE: Correct Callback Naming in Effector (Typescript)\nDESCRIPTION: This snippet demonstrates the use of meaningful names in effector callbacks, enhancing code readability. It updates the `$users` store with the `newUser` and samples the `$userData` store to trigger the `updateUserFx` effect upon `buttonClicked`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n$users.on(userAdded, (users, newUser) => [...users, newUser]);\n\nsample({\n  clock: buttonClicked,\n  source: $userData,\n  fn: (userData) => userData,\n  target: updateUserFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Store and Event\nDESCRIPTION: This JavaScript code creates an effector store ($text) and an event (inputText) for managing text input. The store is initialized with an empty string and updated when the event is triggered. Another store $size calculates the length of $text.\nSOURCE: https://github.com/effector/effector/blob/master/packages/effector-vue/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createStore, createEvent} from 'effector'\n\nexport const inputText = createEvent()\n\nexport const $text = createStore('').on(inputText, (_, text) => text)\n\nexport const $size = $text.map(text => text.length)\n```\n\n----------------------------------------\n\nTITLE: Attaching an Effect\nDESCRIPTION: This code snippet shows how to attach an existing effect to create a new effect. The new effect, `attachedFx`, will trigger the original effect, `originalFx`, with the same parameters and finish with the same state. The types of the original and attached effects are identical.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst originalFx: Effect<Params, Done, Fail>;\n\nconst attachedFx: Effect<Params, Done, Fail> = attach({\n  effect: originalFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Effect .done event usage\nDESCRIPTION: This example shows how to subscribe to the `.done` event of an Effect. The `.done` event is triggered when the effect's handler is successfully resolved. The example logs the parameters passed to the effect and the result of the handler.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect((value) => value + 1);\n\nfx.done.watch(({ params, result }) => {\n  console.log(\"Call with params\", params, \"resolved with value\", result);\n});\n\nawait fx(2);\n// => Call with params 2 resolved with value 3\n```\n\n----------------------------------------\n\nTITLE: Extracting Event Payload with `EventPayload` in Effector\nDESCRIPTION: Illustrates the usage of `EventPayload` to extract the payload type of an Effector event. This utility is similar to `UnitValue` but specifically for events.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, EventPayload } from \"effector\";\n\nconst event = createEvent<{ id: string }>();\n\ntype EventPayloadType = EventPayload<typeof event>;\n// {id: string}\n```\n\n----------------------------------------\n\nTITLE: Timer Implementation After Scope Binding - Effector\nDESCRIPTION: This code shows the corrected implementation of the timer's start effect using `scopeBind` to ensure that the `tick` event is always called within the correct scope, preventing scope loss.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst startFx = createEffect(() => {\n  const bindedTick = scopeBind(tick);\n\n  const intervalId = setInterval(() => {\n    bindedTick();\n  }, TIMEOUT);\n\n  return intervalId;\n});\n```\n\n----------------------------------------\n\nTITLE: Typing `split` after TS 5.5 in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `split` function in Effector with TypeScript 5.5 or later. It showcases how TypeScript can infer the types of the resulting events directly without the need for explicit type predicates, simplifying the code while maintaining type safety.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype UserMessage = { kind: \"user\"; text: string };\ntype WarnMessage = { kind: \"warn\"; warn: string };\n\nconst message = createEvent<UserMessage | WarnMessage>();\n\nconst { userMessage, warnMessage } = split(message, {\n  userMessage: (msg) => msg.kind === \"user\",\n  warnMessage: (msg) => msg.kind === \"warn\",\n});\n// userMessage имеет тип Event<UserMessage>\n// warnMessage имеет тип Event<WarnMessage>\n```\n\n----------------------------------------\n\nTITLE: Defining createApi Formula in Typescript\nDESCRIPTION: This TypeScript code defines the general formula for using `createApi` to create events for updating a store.  It shows the types involved, including the store, the handlers, and the resulting events. `T` represents the store's state type, while `S` and `Q` represent the data types accepted by event1 and event2, respectively.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createApi.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const $store: Store<T>; // управляемый стор\n\nconst api: {\n  event1: Event<S>; // созданное событие-команда\n  event2: Event<Q>; // созданное событие-команда\n} = createApi(\n  /*store*/ $store,\n  /*handlers*/ {\n    event1: /*handler*/ (state: T, data: S) => T,\n    event2: /*handler*/ (state: T, data: Q) => T,\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Using withRegion in Effector\nDESCRIPTION: Demonstrates how to use `withRegion` to manage the lifecycle of units within a specified region.  Units created inside the `withRegion` callback are owned by the specified `region` node.  When `clearNode` is called on `region`, all associated links are disposed of, preventing further updates.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/withRegion.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createNode, createEvent, restore, withRegion, clearNode } from \"effector\";\n\nconst first = createEvent();\nconst second = createEvent();\nconst $store = restore(first, \"\");\nconst region = createNode();\n\nwithRegion(domain, () => {\n  // Following links created with `sample` are owned by the provided unit `domain`\n  // and will be disposed as soon as `clearNode` is called on `domain`.\n  sample({\n    clock: second,\n    target: first,\n  });\n});\n\n$store.watch(console.log);\n\nfirst(\"hello\");\nsecond(\"world\");\n\nclearNode(region);\n\nsecond(\"will not trigger updates of `$store`\");\n```\n\n----------------------------------------\n\nTITLE: Sample with Data Transformation\nDESCRIPTION: This snippet demonstrates data transformation using the `fn` parameter of `sample`.  It transforms user data into a string before updating the `$userInfo` store. The `fn` formats the name and age from the `$user` store when `buttonClicked` is triggered. The example relies on `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, sample } from \"effector\";\n\nconst buttonClicked = createEvent();\nconst $user = createStore({ name: \"Bob\", age: 25 });\nconst $userInfo = createStore(\"\");\n\nsample({\n  clock: buttonClicked,\n  source: $user,\n  fn: (user) => `${user.name} is ${user.age} years old`,\n  target: $userInfo,\n});\n```\n\n----------------------------------------\n\nTITLE: Serialize Scope States\nDESCRIPTION: Serializes the state of stores within a forked scope.  Requires `effector` and uses `createStore`, `createEvent`, `allSettled`, `fork`, and `serialize` functions. The example increments a store's value within a forked scope and then serializes the scope to get the updated store value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/serialize.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, allSettled, fork, serialize } from \"effector\";\n\nconst inc = createEvent();\nconst $store = createStore(42);\n$store.on(inc, (x) => x + 1);\n\nconst scope = fork();\n\nawait allSettled(inc, { scope });\n\nconsole.log(serialize(scope)); // => {[sid]: 43}\n```\n\n----------------------------------------\n\nTITLE: Sample return value without target - Typescript\nDESCRIPTION: Demonstrates that when `target` is not specified, the return value type depends on the passed parameters. If `filter` is not specified, and `clock` and `source` are stores, the result will be a derived store with the data type from `source`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, sample } from \"effector\";\n\nconst $store = createStore(\"\");\nconst $secondStore = createStore(0);\n\nconst $derived = sample({\n  clock: $secondStore,\n  source: $store,\n});\n// $derived будет Store<string>\n\nconst $secondDerived = sample({\n  clock: $secondStore,\n  source: $store,\n  fn: () => false,\n});\n// $secondDerived будет Store<boolean>\n```\n\n----------------------------------------\n\nTITLE: Sample without Target Return Value\nDESCRIPTION: Demonstrates `sample` usage when no `target` is specified, showing how it can return a derived store or event depending on the parameters.  Highlights the differences in return types based on the presence of `filter` and the types of `clock` and `source`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, sample } from \"effector\";\n\nconst $store = createStore(\"\");\nconst $secondStore = createStore(0);\n\nconst $derived = sample({\n  clock: $secondStore,\n  source: $store,\n});\n// $derived will be Store<string>\n\nconst $secondDerived = sample({\n  clock: $secondStore,\n  source: $store,\n  fn: () => false,\n});\n// $secondDerived will be Store<boolean>\n```\n\n----------------------------------------\n\nTITLE: Validating Effector Event with `is.event` in JavaScript\nDESCRIPTION: This snippet demonstrates how to use `is.event` to check if a given value is an Effector event. It imports necessary modules from Effector and creates a store, event, and effect for testing purposes. The snippet then calls `is.event` with different values and logs the results to the console, showing examples of when it returns true or false.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/is.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain } from \"effector\";\n\nconst store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\n\nis.event(store);\n// => false\n\nis.event(event);\n// => true\n\nis.event(fx);\n// => false\n\nis.event(createDomain());\n// => false\n\nis.event(fx.pending);\n// => false\n\nis.event(fx.done);\n// => true\n\nis.event(store.updates);\n// => true\n\nis.event(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: effector split with Stores and Effects (JavaScript)\nDESCRIPTION: Shows usage of `effector.split` in conjunction with stores and effects for managing application state and side effects. It defines a store `$message` holding a message, a store `$mode` representing the current mode, and an event `selectedMessageOption` to select a mode. The `split` function is then used to trigger different effects (`saveMessageFx`, `deleteMessageFx`, `forwardMessageFx`) based on the selected mode.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_12\n\nLANGUAGE: js\nCODE:\n```\nimport { createStore, createEvent, createEffect, split } from \"effector\";\n\nconst options = [\"save\", \"delete\", \"forward\"];\nconst $message = createStore({ id: 1, text: \"Принесите мне чашку кофе, пожалуйста!\" });\nconst $mode = createStore(\"\");\nconst selectedMessageOption = createEvent();\nconst saveMessageFx = createEffect(() => \"save\");\nconst forwardMessageFx = createEffect(() => \"forward\");\nconst deleteMessageFx = createEffect(() => \"delete\");\n\n$mode.on(selectedMessageOption, (mode, opt) => options.find((item) => item === opt) ?? mode);\n\nsplit({\n  source: $message,\n  clock: selectedMessageOption,\n  match: $mode,\n  cases: {\n    save: saveMessageFx,\n    delete: deleteMessageFx,\n    forward: forwardMessageFx,\n  },\n});\n\nselectedMessageOption(\"delete\"); // ничего не происходит\nselectedMessageOption(\"delete\");\n```\n\n----------------------------------------\n\nTITLE: Sending WebSocket Messages - TypeScript\nDESCRIPTION: This code defines an Effector effect for sending messages through the WebSocket connection. It takes an object containing the WebSocket instance and the message to send as input. The `sample` function ensures that the message is only sent if there is an active connection. Dependencies: effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/websocket-integration.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst sendMessageFx = createEffect((params: { socket: WebSocket; message: string }) => {\n  params.socket.send(params.message);\n});\n\n// Связываем отправку сообщения с текущим сокетом\nsample({\n  clock: messageSent,\n  source: $connection,\n  filter: Boolean, // Отправляем только если есть соединение\n  fn: (socket, message) => ({\n    socket,\n    message,\n  }),\n  target: sendMessageFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Sample Store to Store\nDESCRIPTION: Demonstrates sampling a store with itself as the clock, resulting in a new store. This example highlights the behavior of `sample` when both source and clock are stores.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/sample.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample } from \"effector\";\n\nconst $store = sample({ clock: $store, source: $store });\n// Result will be store, because `source` and `clock` are stores.\n```\n\n----------------------------------------\n\nTITLE: Basic split usage in Effector\nDESCRIPTION: This snippet demonstrates the basic usage of the `split` method in Effector. It creates an event `updateUserStatus` and then uses `split` to route the event to different events (`activeUserUpdated`, `idleUserUpdated`, `inactiveUserUpdated`) based on the user status.  The conditions are checked sequentially.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/flow-split.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { createEvent, split } from \"effector\";\n\nconst updateUserStatus = createEvent();\n\nconst { activeUserUpdated, idleUserUpdated, inactiveUserUpdated } = split(updateUserStatus, {\n  activeUserUpdated: (userStatus) => userStatus === \"active\",\n  idleUserUpdated: (userStatus) => userStatus === \"idle\",\n  inactiveUserUpdated: (userStatus) => userStatus === \"inactive\",\n});\n```\n\n----------------------------------------\n\nTITLE: Effector SSR Request Handler (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates a server-side request handler for an Effector-based application. It uses `effector/fork` to create isolated scopes for each request, preventing data leakage between users. The handler fetches application data, serializes the state, and renders the React component to a string, which is then included in the HTML response. The serialized state is passed to the client-side application to initialize it.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/server-side-rendering.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// server.tsx\nimport { renderToString } from \"react-dom/server\";\nimport { Provider } from \"effector-react\";\nimport { fork, allSettled, serialize } from \"effector\";\n\nimport { appStarted, App, $pathname } from \"./app\";\n\nexport async function handleRequest(req) {\n  // 1. Создаем отдельный экземпляр состояния effector – специальный объект `Scope`.\n  const scope = fork({\n    values: [\n      // некоторые части состояния приложения могут быть сразу установлены в нужные значения,\n      // до начала любых вычислений.\n      [$pathname, req.pathname],\n    ],\n  });\n\n  // 2. Запускаем логику приложения – все вычисления будут выполнены в соответствии с логикой модели,\n  // а также любые необходимые эффекты.\n  await allSettled(appStarted, {\n    scope,\n  });\n\n  // 3. Сериализуем вычисленное состояние, чтобы его можно было передать по сети.\n  const storesValues = serialize(scope);\n\n  // 4. Рендерим приложение – также в сериализуемую версию.\n  const app = renderToString(\n    // Используя Provider с scope, мы указываем <App />, какое состояние сторов использовать.\n    <Provider value={scope}>\n      <App />\n    </Provider>,\n  );\n\n  // 5. Подготавливаем сериализованный HTML-ответ.\n  //\n  // Это граница сериализации (или сети).\n  // Точка, в которой всё состояние преобразуется в строку для отправки по сети.\n  //\n  // Состояние effector сохраняется в виде `<script>`, который установит состояние в глобальный объект.\n  // Состояние `react` сохраняется как часть DOM-дерева.\n  return `\n    <html>\n      <head>\n        <script>\n          self._SERVER_STATE_ = ${JSON.stringify(storesValues)}\n        </script>\n        <link rel=\"stylesheet\" href=\"styles.css\" />\n        <script defer src=\"app.js\" />\n      </head>\n      <body>\n        <div id=\"app\">\n          ${app}\n        </div>\n      </body>\n    </html>\n  `;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Handling WebSocket Errors - TypeScript\nDESCRIPTION: This snippet extends the basic WebSocket model to include error handling. It adds an event `socketError` to capture errors, and modifies the `connectWebSocketFx` effect to handle connection timeouts and WebSocket errors.  A store `$error` is also created to store the error message. Dependencies: effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/websocket-integration.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst TIMEOUT = 5_000;\n\n// Добавляем события для ошибок\nconst socketError = createEvent<Error>();\n\nconst connectWebSocketFx = createEffect((url: string): Promise<WebSocket> => {\n  const ws = new WebSocket(url);\n\n  const scopeDisconnected = scopeBind(disconnected);\n  const scopeRawMessageReceived = scopeBind(rawMessageReceived);\n  const scopeSocketError = scopeBind(socketError);\n\n  return new Promise((res, rej) => {\n    const timeout = setTimeout(() => {\n      const error = new Error(\"Connection timeout\");\n\n      socketError(error);\n      reject(error);\n      socket.close();\n    }, TIMEOUT);\n\n    ws.onopen = () => {\n      clearTimeout(timeout);\n      res(ws);\n    };\n\n    ws.onmessage = (event) => {\n      scopeMessageReceived(event.data);\n    };\n\n    ws.onclose = () => {\n      disconnected();\n    };\n\n    ws.onerror = (err) => {\n      const error = new Error(\"WebSocket error\");\n      scopeDisconnected();\n      scopeSocketError(error);\n      rej(err);\n    };\n  });\n});\n\n// Стор для хранения ошибки\nconst $error = createStore(\"\")\n  .on(socketError, (_, error) => error.message)\n  .reset(connectWebSocketFx.done);\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions in `mapParams`\nDESCRIPTION: This example shows how to handle exceptions thrown within the `mapParams` function. When an exception occurs, the attached effect fails, and the error can be observed using `attachedFx.failData.watch`. The original effect is not executed.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, attach } from \"effector\";\n\nconst originalFx = createEffect((a: { a: number }) => a);\n\nconst attachedFx = attach({\n  effect: originalFx,\n  mapParams(a: number) {\n    throw new Error(\"custom error\");\n    return { a };\n  },\n});\n\nattachedFx.failData.watch((error) => console.log(\"attachedFx.failData\", error));\n\nattachedFx(1);\n// => attachedFx.failData\n// =>   Error: custom error\n```\n\n----------------------------------------\n\nTITLE: useUnit with Shape - JSX Example\nDESCRIPTION: Provides a Solid component example utilizing `useUnit` with a shape (an object containing events and a store) from `effector-solid/scope`. It demonstrates how to bind multiple events and a store, enabling the component to increment and decrement a counter displayed on the screen.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useUnit.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { render } from \"solid-js/web\";\nimport { createStore, createEvent, fork } from \"effector\";\nimport { useUnit, Provider } from \"effector-solid/scope\";\n\nconst incremented = createEvent();\nconst decremented = createEvent();\n\nconst $count = createStore(0)\n  .on(incremented, (count) => count + 1)\n  .on(decremented, (count) => count - 1);\n\nconst App = () => {\n  const count = useUnit($count);\n  const on = useUnit({ incremented, decremented });\n  // or\n  const [a, b] = useUnit([incremented, decremented]);\n\n  return (\n    <>\n      <p>Count: {count()}</p>\n      <button onClick={() => on.incremented()}>Increment</button>\n      <button onClick={() => on.decremented()}>Decrement</button>\n    </>\n  );\n};\n\nconst scope = fork();\n\nrender(\n  () => (\n    <Provider value={scope}>\n      <App />\n    </Provider>\n  ),\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Updating Store on Effect Completion\nDESCRIPTION: This code snippet shows how to update an Effector store with data returned by an effect upon successful completion. It uses the `on` method to listen for the `done` and `fail` events and update the store accordingly. Also uses `doneData` and `failData` for similar purposes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/work-with-async.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEffect } from \"effector\";\n\nconst fetchUserNameFx = createEffect(async (userId: string) => {\n  const userData = await fetch(`/api/users/${userId}`);\n\n  return userData.name;\n});\n\nconst $error = createStore<string | null>(null);\nconst $userName = createStore(\"\");\nconst $isLoading = fetchUserNameFx.pending.map((isPending) => isPending);\n\n$error.reset(fetchUserNameFx.done);\n\n$userName.on(fetchUserNameFx.done, (_, { params, result }) => result);\n$error.on(fetchUserNameFx.fail, (_, { params, error }) => error.message);\n// или 🔃\n$userName.on(fetchUserNameFx.doneData, (_, result) => result);\n$error.on(fetchUserNameFx.failData, (_, error) => error.message);\n\n$isLoading.watch((loading) => console.log(\"Is loading:\", loading));\n```\n\n----------------------------------------\n\nTITLE: Using the Effector Countdown Timer\nDESCRIPTION: This code snippet demonstrates how to use the `createCountdown` function to create and manage a countdown timer. It initializes events for starting and aborting the countdown.  It then attaches a `watch` handler to the `tick` event to log the remaining seconds. The example starts the countdown with an initial value and sets a timeout to abort the countdown after a specified duration.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/common/countdown.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst startCountdown = createEvent();\nconst abortCountdown = createEvent();\n\nconst countdown = createCountdown(\"simple\", {\n  start: startCountdown,\n  abort: abortCountdown,\n});\n\n// handle each tick\ncountdown.tick.watch((remainSeconds) => {\n  console.info(\"Tick. Remain seconds: \", remainSeconds);\n});\n\n// let's start\nstartCountdown(15); // 15 ticks to count down, 1 tick per second\n\n// abort after 5 second\nsetTimeout(abortCountdown, 5000);\n```\n\n----------------------------------------\n\nTITLE: Sampling from Array of Stores in Effector (JavaScript)\nDESCRIPTION: This snippet demonstrates how to use `sample` with an array of stores as the `source`.  The `sample` function is triggered by the `trigger` event, and it combines the values from the `a` and `b` stores into an array. The resulting array is then passed to the `target` event. It uses `createStore`, `createEvent`, and `sample` from the Effector library. The example shows how to watch the `target` event with destructuring.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/sample.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, sample } from \"effector\";\nconst trigger = createEvent();\n\nconst a = createStore(\"A\");\nconst b = createStore(1);\n\n// target имеет тип `Event<[string, number]>`\nconst target = sample({\n  clock: trigger,\n  source: [a, b],\n});\n\ntarget.watch((obj) => {\n  console.log(\"sampled array\", obj);\n});\n\n// Можно деструктурировать аргументы, чтобы задать явные имена\ntarget.watch(([a, b]) => {\n  console.log(\"explicit names\", a, b);\n});\n\ntrigger();\n// => sampled array [\"A\", 1]\n// => explicit names \"A\" 1\n```\n\n----------------------------------------\n\nTITLE: Store Testing with Effector\nDESCRIPTION: This code snippet demonstrates how to test a store in Effector using the fork API for state isolation and allSettled for asynchronous execution. It imports the store and event, then tests the store's initial state and its state after the event is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/testing.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { counterIncremented, $counter } from \"./counter.js\";\n\ntest(\"counter should increase by 1\", async () => {\n  const scope = fork();\n\n  expect(scope.getState($counter)).toEqual(0);\n\n  await allSettled(counterIncremented, { scope });\n\n  expect(scope.getState($counter)).toEqual(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Using getState with Scope - JS\nDESCRIPTION: This JavaScript code showcases how to use the `getState` method on a `Scope` object to retrieve the value of a store within that specific scope. This is useful for testing and accessing store values in isolated application instances.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Scope.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, fork, allSettled } from \"effector\";\n\nconst inc = createEvent();\nconst dec = createEvent();\nconst $counter = createStore(0);\n\n$counter.on(inc, (value) => value + 1);\n$counter.on(dec, (value) => value - 1);\n\nconst scopeA = fork();\nconst scopeB = fork();\n\nawait allSettled(inc, { scope: scopeA });\nawait allSettled(dec, { scope: scopeB });\n\nconsole.log($counter.getState()); // => 0\nconsole.log(scopeA.getState($counter)); // => 1\nconsole.log(scopeB.getState($counter)); // => -1\n```\n\n----------------------------------------\n\nTITLE: Triggering Navigation from an Effector Model (JavaScript)\nDESCRIPTION: This snippet illustrates how to trigger navigation from an Effector model using the `navigationTriggered` event.  It demonstrates a sample usage where navigation is triggered upon the completion of the `getUserFx` effect.  The `fn` property transforms the completion of `getUserFx` into the desired route. It depends on 'effector'.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/nextjs/router.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { sample } from 'effector';\n\n    ...\n\nsample({\n    clock: getUserFx.done,\n    fn: () => '/home',\n    target: navigationTriggered,\n});\n\n```\n\n----------------------------------------\n\nTITLE: useList with Config and Dependencies (JSX)\nDESCRIPTION: Demonstrates the usage of `useList` with a configuration object, including the `keys` property for specifying dependencies. This ensures that the list items are updated when the specified dependencies change, even if the store data itself hasn't changed.  Illustrates how to re-render list items based on external dependencies like a user's name.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useList.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport ReactDOM from \"react-dom\";\nimport { createEvent, createStore, restore } from \"effector\";\nimport { useUnit, useList } from \"effector-react\";\n\nconst renameUser = createEvent();\n\nconst $user = createStore(\"alice\");\nconst $friends = createStore([\"bob\"]);\n\n$user.on(renameUser, (_, name) => name);\n\nconst App = () => {\n  const user = useUnit($user);\n\n  return useList($friends, {\n    keys: [user],\n    fn: (friend) => (\n      <div>\n        {friend} is a friend of {user}\n      </div>\n    ),\n  });\n};\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n// => <div> bob is a friend of alice </div>\n\nsetTimeout(() => {\n  renameUser(\"carol\");\n  // => <div> bob is a friend of carol </div>\n}, 500);\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Effect with Handler\nDESCRIPTION: Demonstrates how to create an Effector effect with a handler function.  The handler fetches user repositories from GitHub based on the provided username.  It logs the result upon completion. Requires effector package. Invoked with an object containing the 'name' property.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createEffect.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect(async ({ name }) => {\n  const url = `https://api.github.com/users/${name}/repos`;\n  const req = await fetch(url);\n  return req.json();\n});\n\nfetchUserReposFx.done.watch(({ params, result }) => {\n  console.log(result);\n});\n\nawait fetchUserReposFx({ name: \"zerobias\" });\n```\n\n----------------------------------------\n\nTITLE: Using effector-react with React\nDESCRIPTION: This code demonstrates how to integrate effector with React using `effector-react`. It creates an input field that updates an effector store `$text` and displays the length of the text using the `useUnit` hook.  It relies on React and effector dependencies.\nSOURCE: https://github.com/effector/effector/blob/master/packages/effector-react/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createStore, combine, createEvent} from 'effector'\n\nimport {useUnit} from 'effector-react'\n\nconst inputText = createEvent()\n\nconst $text = createStore('').on(inputText, (_, text) => text)\n\nconst $size = $text.map(text => text.length)\n\nconst Form = () => {\n  const {text, size} = useUnit({\n    text: $text,\n    size: $size,\n  })\n  const handleTextChange = useUnit(inputText)\n\n  return (\n    <form>\n      <input\n        type=\"text\"\n        onChange={e => handleTextChange(e.currentTarget.value)}\n        value={text}\n      />\n      <p>Length: {size}</p>\n    </form>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Async Function and Source Stores\nDESCRIPTION: This code shows how to create an effect by attaching a source (store or object of stores) to an async function. The `effect` function receives the store's value and optional parameters. It also covers propagation of the scope and how to fix scope losing using `createEffect`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst attachedFx = attach({\n  source,\n  async effect(source, params) {},\n});\n```\n\n----------------------------------------\n\nTITLE: Server-Side Rendering with Effector Scopes (Server)\nDESCRIPTION: Illustrates server-side rendering (SSR) using Effector scopes. It demonstrates creating a scope, loading data, rendering the app, and serializing the state for transfer to the client.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n// server.tsx\nimport { renderToString } from \"react-dom/server\";\nimport { fork, serialize } from \"effector\";\nimport { Provider } from \"effector-react\";\nimport { $users, fetchUsersFx } from \"./model\";\n\nasync function serverRender() {\n  const scope = fork();\n\n  // Load data on the server\n  await allSettled(fetchUsersFx, { scope });\n\n  // Render the application\n  const html = renderToString(\n    <Provider value={scope}>\n      <App />\n    </Provider>,\n  );\n\n  // Serialize state for transfer to the client\n  const data = serialize(scope);\n\n  return `\n\t<html>\n\t  <body>\n\t\t<div id=\"root\">${html}</div>\n\t\t<script>window.INITIAL_DATA = ${data}</script>\n\t  </body>\n\t</html>\n`;\n}\n```\n\n----------------------------------------\n\nTITLE: Effector restore with Effect example (JavaScript)\nDESCRIPTION: This snippet shows how to create a store from the successful result of an effect using `restore`. The store's value is updated with the result of the effect when it completes successfully. It requires `createEffect` and `restore` from effector. Outputs the state to the console upon each update.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/restore.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect, restore } from \"effector\";\n\nconst fx = createEffect(() => \"foo\");\nconst $store = restore(fx, \"default\");\n\n$store.watch((state) => console.log(\"state: \", state));\n// => state: default\n\nawait fx();\n// => state: foo\n```\n\n----------------------------------------\n\nTITLE: useUnit with Event or Effect - TypeScript\nDESCRIPTION: Defines the TypeScript signatures for `useUnit` when used with Effector Events or Effects. It demonstrates how to bind an event or effect to the current scope to be used in event handlers, returning a function that triggers the unit in the current scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useUnit.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nuseUnit(event: EventCallable<T>): (payload: T) => T;\nuseUnit(effect: Effect<Params, Done, any>): (payload: Params) => Promise<Done>;\n```\n\n----------------------------------------\n\nTITLE: Effect .doneData event usage\nDESCRIPTION: This example demonstrates how to subscribe to the `.doneData` event of an Effect. The `.doneData` event is triggered by the result of the effect execution. The example logs the result of the effect's handler when it successfully resolves.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect((value) => value + 1);\n\nfx.doneData.watch((result) => {\n  console.log(`Effect was successfully resolved, returning ${result}`);\n});\n\nawait fx(2);\n// => Effect was successfully resolved, returning 3\n```\n\n----------------------------------------\n\nTITLE: Combine with array and function\nDESCRIPTION: Combines multiple stores into an array and uses a function to derive a new value. The function receives an array with the stores' values and returns the new state. Dependencies: `Store`, `StoreWritable`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/combine.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst $a: Store<A>;\nconst $b: StoreWritable<B>;\nconst $c: Store<C> | StoreWritable<C>;\n\n$result: Store<D> = combine([$a, $b, $c], ([A, B, C]): D => result);\n```\n\n----------------------------------------\n\nTITLE: Using useEvent with a list of Effector units\nDESCRIPTION: This code snippet illustrates how to use the `useEvent` hook with an array of Effector events. It binds both the `inc` and `dec` events to the component's scope, providing functions `incFn` and `decFn` to trigger respective events. The component uses `useStore` to subscribe to the `$count` store and provides increment and decrement buttons.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useEvent.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport ReactDOM from \"react-dom\";\nimport { createEvent, createStore, fork } from \"effector\";\nimport { useStore, useEvent, Provider } from \"effector-react\";\n\nconst inc = createEvent();\nconst dec = createEvent();\nconst $count = createStore(0)\n  .on(inc, (x) => x + 1)\n  .on(dec, (x) => x - 1);\n\nconst App = () => {\n  const count = useStore($count);\n  const [incFn, decFn] = useEvent([inc, dec]);\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => incFn()}>increment</button>\n      <button onClick={() => decFn()}>decrement</button>\n    </>\n  );\n};\n\nconst scope = fork();\n\nReactDOM.render(\n  <Provider value={scope}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Usage of Created Request Effects\nDESCRIPTION: Demonstrates the usage of created request effects by defining `getUserFx` and `getPostsFx` using the `createRequest` factory. The example showcases how parameters are passed, and the resulting API calls are tracked.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// ./api/index.ts\nimport { createRequest } from \"./authorized\";\nimport { $requestsSent } from \"./request\";\n\nconst getUserFx = createRequest(\"/user\");\nconst getPostsFx = createRequest(\"/posts\");\n\n$requestsSent.watch((total) => {\n  console.log(`Аналитика клиента: отправлено ${total} запросов`);\n});\n\nconst user = await getUserFx({ name: \"alice\" });\n/*\nPOST https://example.com/api/user\n{\"name\": \"alice\"}\nAuthorization: Bearer guest_token\n*/\n\n// => Аналитика клиента: отправлено 1 запросов\n\nconst posts = await getPostsFx({ user: user.id });\n/*\nPOST https://example.com/api/posts\n{\"user\": 18329}\nAuthorization: Bearer guest_token\n*/\n\n// => Аналитика клиента: отправлено 2 запросов\n```\n\n----------------------------------------\n\nTITLE: Combining Stores into an Object\nDESCRIPTION: This snippet demonstrates combining stores into a new store which contains an object with the states of the stores passed into combine.  Each property within the object will contain the state from its corresponding store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/combine.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst $a: Store<A>;\nconst $b: StoreWritable<B>;\nconst $c: Store<C> | StoreWritable<C>;\n\n$result: Store<{ a: A; b: B; c: C }> = combine({ a: $a, b: $b, c: $c });\n```\n\n----------------------------------------\n\nTITLE: useStoreMap with Config Object (TS)\nDESCRIPTION: Defines the signature of `useStoreMap` when used with a configuration object.  The config object includes the store, optional keys function, a selector function `fn` which takes state and keys, and an optional default value. The hook returns a `ComputedRef<Result>`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useStoreMap.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nuseStoreMap({\n  store: Store<State>,\n  keys?: () => Keys,\n  fn: (state: State, keys: Keys) => Result,\n  defaultValue?: Result,\n}): ComputedRef<Result>;\n```\n\n----------------------------------------\n\nTITLE: Expanded Split with Clock and Source in Effector\nDESCRIPTION: This snippet builds upon the previous example by adding a `clock` and a `source` to the expanded form of `split`. The `clock` triggers the split, and the `source` provides data to the cases. This illustrates how to pass data from a store (`$currentUser`) to different effects based on the application mode.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/flow-split.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n// дополним предыдущий код\n\nconst adminActionFx = createEffect((currentUser) => {\n  // ...\n});\nconst secondAdminActionFx = createEffect((currentUser) => {\n  // ...\n});\n\n// добавим новый стор\nconst $currentUser = createStore({\n  id: 1,\n  name: \"Donald\",\n});\n\nconst $appMode = createStore<\"admin\" | \"user\">(\"user\");\n\nsplit({\n  clock: buttonClicked,\n  // и передадим его как источник данных\n  source: $currentUser,\n  match: $appMode,\n  cases: {\n    admin: [adminActionFx, secondAdminActionFx],\n    user: userActionFx,\n    __: defaultActionFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Complex Objects with Immer (TypeScript)\nDESCRIPTION: This snippet shows how to use Immer with Effector stores to simplify updating nested data structures. Immer's `produce` function allows for immutable updates using mutable operations within a draft object, improving code readability and maintainability.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { produce } from \"immer\";\n\nconst $users = createStore<User[]>([])\n\n$users.on(userUpdated, (users, updatedUser) =>\n  produce(users, (draft) => {\n    const user = draft.find((u) => u.id === updatedUser.id);\n    if (user) {\n      user.profile.settings.theme = updatedUser.profile.settings.theme;\n    }\n  }),\n);\n\n```\n\n----------------------------------------\n\nTITLE: Using sendAnalytics.prepend for data transformation (TS)\nDESCRIPTION: This code illustrates using the `prepend` method to adapt the input of `sendAnalytics`. It defines `reportClick` as a derived event which transforms a string input into the format expected by `sendAnalytics`. Requires `sendAnalytics` to be imported.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sendAnalytics } from \"./analytics\";\n\nexport const reportClick = sendAnalytics.prepend((item: string) => {\n  return { type: \"click\", container: { items: [arg] } };\n});\n\nreportClick(\"example\");\n// reportClick triggered \"example\"\n// sendAnalytics triggered { type: \"click\", container: { items: [\"example\"] } }\n```\n\n----------------------------------------\n\nTITLE: Creating and Targeting Events (Declarative)\nDESCRIPTION: Illustrates the declarative approach to triggering events using `sample`. The example sets up a sequence where `secondTriggered` is called when `firstTriggered` is invoked.  It shows how `sample` can be used to link events.  It imports `createEvent` and `sample` from the `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/events.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, sample } from \"effector\";\n\nconst firstTriggered = createEvent<void>();\nconst secondTriggered = createEvent<void>();\n\nsample({\n  clock: firstTriggered,\n  target: secondTriggered,\n});\n```\n\n----------------------------------------\n\nTITLE: Effector Split with Matching Store\nDESCRIPTION: Shows using `split` with matching stores to conditionally route data to different units.  The `match` property is an object whose keys are case names and whose values are boolean stores.  Data is routed to the case whose store's value is `true`.  Cases are defined as `first`, `second`, and a default `__` case.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>,\n  match: {\n    // стор сопоставления\n    first: Store<boolean>,\n    second: Store<boolean>\n  },\n  cases: {\n    first: Unit<T> | Unit<T>[],\n    second: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Typing `sample` with `filter` and `fn` using type predicates in TypeScript\nDESCRIPTION: This snippet illustrates how to use type predicates with `filter` and `fn` in the `sample` function. It highlights the need to explicitly define the type of the filter parameter to allow TypeScript to correctly infer the type in `fn` after `filter`. This is necessary due to limitations in TypeScript's type inference capabilities.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype UserMessage = { kind: \"user\"; text: string };\ntype WarnMessage = { kind: \"warn\"; warn: string };\ntype Message = UserMessage | WarnMessage;\n\nconst message = createEvent<Message>();\nconst userText = createEvent<string>();\n\nsample({\n  clock: message,\n  filter: (msg: Message): msg is UserMessage => msg.kind === \"user\",\n  fn: (msg) => msg.text,\n  target: userText,\n});\n\n// userMessage has type Event<string>\n```\n\n----------------------------------------\n\nTITLE: Using Effector Effect in Worker\nDESCRIPTION: This snippet demonstrates how to use the `exampleEffect` in a worker context. It imports the effect from the common module and defines its implementation using `exampleEffect.use`. The implementation logs the message received from the client and returns a response.\nSOURCE: https://github.com/effector/effector/blob/master/examples/worker-rpc/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {exampleEffect} from './common'\n\nexampleEffect.use(message => {\n  console.log('message from client: ', message)\n  return 'hello client'\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Timer Events\nDESCRIPTION: This code defines the events needed to control a timer: `timerStopped`, `timerReset`, and `timerStarted`. These events are used to signal when the timer should be stopped, reset, or started, respectively.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/advanced/work-with-scope.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const timerStopped = createEvent();\nexport const timerReset = createEvent();\nexport const timerStarted = createEvent();\n```\n\n----------------------------------------\n\nTITLE: Split with Case Store\nDESCRIPTION: This code snippet demonstrates how to use `split` with a case store. The `match` field contains a store of type string. The `cases` object contains units to which data is passed based on the current case from the store. If no case matches, the data is passed to `cases.__`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>\n  // case store\n  match: Store<'first' | 'second'>,\n  cases: {\n    first: Unit<T> | Unit<T>[],\n    second: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Correct Prepend with Sample\nDESCRIPTION: Corrects the incorrect `prepend` usage by using `sample`. Demonstrates usage of `sample` to connect two events and perform data transformation between them.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst someHappened = createEvent<string>();\nconst another = createEvent<number>();\nconst reversed = createEvent<number>();\n\n// То же самое, что и .prepend(), но с использованием `sample`\nsample({\n  clock: reversed,\n  fn: (input) => String(input),\n  target: someHappened,\n});\n\nsample({\n  clock: reversed,\n  target: another,\n});\n```\n\n----------------------------------------\n\nTITLE: Combine with object\nDESCRIPTION: Combines multiple stores into an object.  Dependencies: `Store`, `StoreWritable`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/combine.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst $a: Store<A>;\nconst $b: StoreWritable<B>;\nconst $c: Store<C> | StoreWritable<C>;\n\n$result: Store<{ a: A; b: B; c: C }> = combine({ a: $a, b: $b, c: $c });\n```\n\n----------------------------------------\n\nTITLE: useStoreMap with Store and Selector Function (TS)\nDESCRIPTION: Defines the signature of `useStoreMap` when used with a store and a selector function.  The store is a `Store<State>`, and the selector function `fn` takes a `State` and returns a `Result`. The hook returns a `ComputedRef<Result>`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useStoreMap.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nuseStoreMap(\n  $store: Store<State>,\n  fn: (state: State) => Result,\n): ComputedRef<Result>;\n```\n\n----------------------------------------\n\nTITLE: Using scopeBind to preserve scope - JS\nDESCRIPTION: This JavaScript code demonstrates how to use `scopeBind` to ensure that an effect call within an asynchronous operation like `setInterval` is executed within the correct scope.  `scopeBind` creates a function that is bound to the current scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Scope.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst sendWithAuthFx = createEffect(async () => {\n  // Now this function can be called safely\n  // without adhering to the scope loss rules\n  const sendMessage = scopeBind(sendMessageFx);\n\n  await authUserFx();\n\n  // There is no context inside setInterval, but our function is bound\n  return setInterval(sendMessage, 500);\n});\n```\n\n----------------------------------------\n\nTITLE: Message Form Component (Login/Send)\nDESCRIPTION: This snippet implements the message form component, which dynamically renders either a login form or a send message form based on the user's login status.  It utilizes `useUnit` to connect to Effector stores and events, enabling actions like sending messages and logging in/out.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n// Файл: /src/pages/chat/page.tsx\nfunction MessageForm() {\n  const isLogged = useUnit(model.$loggedIn);\n  return isLogged ? <SendMessage /> : <LoginForm />;\n}\n\nfunction SendMessage() {\n  const [userName, messageText, messageSending] = useUnit([\n    model.$userName,\n    model.$messageText,\n    model.$messageSending,\n  ]);\n\n  const [handleLogout, handleTextChange, handleEnterPress, handleSendClick] = useUnit([\n    model.logoutClicked,\n    model.messageTextChanged,\n    model.messageEnterPressed,\n    model.messageSendClicked,\n  ]);\n\n  const handleKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    if (event.key === \"Enter\") {\n      handleEnterPress();\n    }\n  };\n\n  return (\n    <div className=\"message-form\">\n      <h3>{userName}</h3>\n      <input\n        value={messageText}\n        onChange={(event) => handleTextChange(event.target.value)}\n        onKeyPress={handleKeyPress}\n        className=\"chat-input\"\n        placeholder=\"Type a message...\"\n      />\n      <button onClick={() => handleSendClick()} disabled={messageSending}>\n        {messageSending ? \"Sending...\" : \"Send\"}\n      </button>\n      <button onClick={() => handleLogout()}>Log out</button>\n    </div>\n  );\n}\n\nfunction LoginForm() {\n  const handleLogin = useUnit(model.loginClicked);\n\n  return (\n    <div className=\"message-form\">\n      <div>Please, log in to be able to send messages</div>\n      <button onClick={() => handleLogin()}>Login as a random user</button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Local Copy of an Effect\nDESCRIPTION: This example demonstrates how to create a local copy of an effect using `attach`. The attached effect will only react to triggers emitted from the current local code, allowing for more fine-grained control over effect execution. The example showcases how both the original and attached effects can be watched and triggered independently.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, attach } from \"effector\";\n\nconst originalFx = createEffect((word: string) => {\n  console.info(\"Printed:\", word);\n});\n\nconst attachedFx = attach({ effect: originalFx });\n\noriginalFx.watch(() => console.log(\"originalFx\"));\noriginalFx.done.watch(() => console.log(\"originalFx.done\"));\n\nattachedFx.watch(() => console.log(\"attachedFx\"));\nattachedFx.done.watch(() => console.log(\"attachedFx.done\"));\n\noriginalFx(\"first\");\n// => originalFx\n// => Printed: first\n// => originalFx.done\n\nattachedFx(\"second\");\n// => attachedFx\n// => originalFx\n// Printed: second\n// => originalFx.done\n// => attachedFx.done\n```\n\n----------------------------------------\n\nTITLE: Adding sid to Store for SSR Hydration in Effector (TypeScript)\nDESCRIPTION: This snippet shows how to add a stable ID (`sid`) to an Effector store. This is crucial for proper server-side rendering (SSR) hydration.  The `sid` ensures that the store's data is correctly transferred from the server to the client.  You can either use a Babel/SWC plugin or manually assign a unique string to the `sid` property.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/troubleshooting.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = createStore(0, {\n  sid: \"unique id\",\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Factory Usage with withFactory\nDESCRIPTION: This code snippet illustrates how the Effector plugin transforms the usage of a custom factory function after being configured with the factory's import path.  The `createName` factory is wrapped with the `withFactory` helper, which assigns a unique SID to each call, ensuring that each instance of the factory has unique SIDs for its internal units.  It depends on the effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// src/shared/lib/create-name/index.ts\nexport function createName() {\n  const updateName = createEvent();\n  const $name = createStore(null, { sid: \"ffds2\" });\n\n  $name.on(updateName, (_, nextName) => nextName);\n\n  return { $name };\n}\n\n// src/feature/persons/model.ts\nimport { withFactory } from \"effector\";\nimport { createName } from \"@/shared/lib/create-name\";\n\nconst personOne = withFactory({\n  sid: \"gre24f\",\n  fn: () => createName(),\n});\nconst personTwo = withFactory({\n  sid: \"lpefgd\",\n  fn: () => createName(),\n});\n```\n\n----------------------------------------\n\nTITLE: Declarative Event Triggering with Effector\nDESCRIPTION: This code demonstrates a declarative approach to triggering an event when a store value changes using the `sample` operator. It creates a store `$login`, derives a `$loginSize` store from it, and then uses `sample` to trigger the `submitLoginSize` event whenever `$loginSize` changes. This approach is generally preferred over the imperative approach. Dependencies: effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/glossary.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, sample } from \"effector\";\n\nconst submitLoginSize = createEvent();\n\nconst $login = createStore(\"guest\");\nconst $loginSize = $login.map((login) => login.length);\n\nsample({\n  clock: $loginSize,\n  target: submitLoginSize,\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Stores, Events, and Effects in Effector (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to create stores, events, and effects using Effector's `createStore`, `createEvent`, and `createEffect` functions. It also shows how to use `is.unit` to check if a value is an Effector unit. The `effector` library must be installed.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/core-concepts.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect, is } from \"effector\";\n\nconst $counter = createStore(0);\nconst event = createEvent();\nconst fx = createEffect(() => {});\n\n// Проверка, является ли значение юнитом\nis.unit($counter); // true\nis.unit(event); // true\nis.unit(fx); // true\nis.unit({}); // false\n```\n\n----------------------------------------\n\nTITLE: Using createStoreConsumer with render props (JSX)\nDESCRIPTION: This example demonstrates how to create a simple React component that subscribes to an Effector store (`$firstName`) and displays its value using the `createStoreConsumer` function and render props. The component `FirstName` is created using `createStoreConsumer` and receives the store's current value as an argument to the render prop function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/createStoreConsumer.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { createStoreConsumer } from \"effector-react\";\n\nconst $firstName = createStore(\"Alan\");\n\nconst FirstName = createStoreConsumer($firstName);\n\nconst App = () => <FirstName>{(name) => <h1>{name}</h1>}</FirstName>;\n```\n\n----------------------------------------\n\nTITLE: useUnit with Shape (TypeScript)\nDESCRIPTION: Describes the function signature for using `useUnit` with a shape of Effector units (object or array containing stores, events, and/or effects). It returns an object/array with values of stores and functions to trigger events/effects.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useUnit.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nuseUnit({ a: Store<A>, b: Event<B>, ... }): { a: A, b: (payload: B) => B; ... }\n\nuseUnit([Store<A>, Event<B>, ... ]): [A, (payload: B) => B, ... ]\n```\n\n----------------------------------------\n\nTITLE: Using Filtered Messages - TypeScript\nDESCRIPTION: This snippet shows how to use the `messageReceivedByType` function to handle specific types of WebSocket messages. It demonstrates how to target a specific event `doWhateverYouWant` with the message of specified type. Dependencies: effector, zod.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/websocket-integration.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nsample({\n  clock: messageReceivedByType(\"balanceChanged\"),\n  fn: (message) => {\n    // Typescript знает структуру message\n  },\n  target: doWhateverYouWant,\n});\n```\n\n----------------------------------------\n\nTITLE: Serialize with onlyChanges Option (JavaScript)\nDESCRIPTION: This code demonstrates how to use the `serialize` method with the `onlyChanges` option to serialize only the stores that have been changed within a forked scope. It creates a domain, two stores, forks a scope with initial values for both stores, creates another scope where only one store's value is changed, serializes the changed scope with `onlyChanges: true`, and hydrates a client scope with the serialized data.  Requires `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/serialize.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createDomain, fork, serialize, hydrate } from \"effector\";\n\nconst app = createDomain();\n\n/** store which we want to hydrate by server */\nconst $title = app.createStore(\"dashboard\");\n\n/** store which is not used by server */\nconst $clientTheme = app.createStore(\"light\");\n\n/** scope in client app */\nconst clientScope = fork(app, {\n  values: new Map([\n    [$clientTheme, \"dark\"],\n    [$title, \"profile\"],\n  ]),\n});\n\n/** server side scope of chats page created for each request */\nconst chatsPageScope = fork(app, {\n  values: new Map([[$title, \"chats\"]]),\n});\n\n/** this object will contain only $title data\n * as $clientTheme never changed in server scope */\nconst chatsPageData = serialize(chatsPageScope, { onlyChanges: true });\nconsole.log(chatsPageData);\n// => {'-l644hw': 'chats'}\n\n/** thereby, filling values from a server will touch only relevant stores */\nhydrate(clientScope, { values: chatsPageData });\n\nconsole.log(clientScope.getState($clientTheme));\n// => dark\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing Effector Stores with SIDs\nDESCRIPTION: Illustrates how to serialize and deserialize Effector stores using `fork`, `allSettled`, and `serialize`. The `fork` creates an isolated scope. `allSettled` updates the stores within the scope. `serialize` extracts the store values with corresponding SIDs. On the client, the serialized state is parsed and used to initialize a new scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// server.ts\nasync function handlerRequest() {\n  // create isolated instance of application\n  const scope = fork();\n\n  // fill some data to stores\n  await allSettled($name, { scope, params: \"Igor\" });\n  await allSettled($age, { scope, params: 25 });\n\n  const state = JSON.serialize(serialize(scope));\n  // -> { \"name\": \"Igor\", \"age\": 25 }\n\n  return { state };\n}\n\n// Let's assume that server put the state into the HTML\nconst serverState = readServerStateFromWindow();\n\nconst scope = fork({\n  // Just parse the whole state and use it as client state\n  values: JSON.parse(serverState),\n});\n```\n\n----------------------------------------\n\nTITLE: Calling Effector Effect in Client\nDESCRIPTION: This snippet demonstrates how to call the `exampleEffect` in a client context. It imports the effect from the common module and calls it with a message 'hello worker'.  The result will be the return value of the worker's implementation of the effect, 'hello client'.\nSOURCE: https://github.com/effector/effector/blob/master/examples/worker-rpc/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {exampleEffect} from './common'\n\nawait exampleEffect('hello worker')\n// => message from client: hello worker\n// => hello client\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Event Creation in Effector Domain\nDESCRIPTION: Shows how to use `onCreateEvent` to subscribe to the creation of new events within a domain. The provided hook function is called each time `domain.createEvent()` is invoked, allowing for side effects such as logging. This is useful for debugging or applying consistent configurations to new events.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Domain.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { createDomain } from \"effector\";\n\nconst domain = createDomain();\n\ndomain.onCreateEvent((event) => {\n  console.log(\"новое событие создано\");\n});\n\nconst a = domain.createEvent();\n// => новое событие создано\n\nconst b = domain.createEvent();\n// => новое событие создано\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Argument Transformation\nDESCRIPTION: Illustrates how to transform arguments when attaching one effect to another using `mapParams`.  The example shows an original effect expecting an object with a number input, and the attached effect transforms a single number argument into the required object.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, attach } from \"effector\";\n\nconst originalFx = createEffect((a: { input: number }) => a);\n\nconst attachedFx = attach({\n  effect: originalFx,\n  mapParams(a: number) {\n    return { input: a * 100 };\n  },\n});\n\noriginalFx.watch((params) => console.log(\"originalFx started\", params));\n\nattachedFx(1);\n// => originalFx { input: 100 }\n```\n\n----------------------------------------\n\nTITLE: Combine with skipVoid example\nDESCRIPTION: This javascript example shows how to combine stores with a skipVoid configuration object to define if `undefined` is a valid value, or if the store should skip updates when `undefined` is received. Dependencies: `$a`, `$b`\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/combine.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst $withFn = combine($a, $b, (a, b) => a || b, { skipVoid: false });\n```\n\n----------------------------------------\n\nTITLE: Simulating Network Requests with a Wait Function in TypeScript\nDESCRIPTION: Defines a `wait` function that simulates network latency by pausing execution for a random amount of time (up to 1500ms) using `setTimeout` and a promise.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// File: /src/shared/lib/wait.ts\nexport function wait(timeout = Math.random() * 1500) {\n  return new Promise((resolve) => setTimeout(resolve, timeout));\n}\n```\n\n----------------------------------------\n\nTITLE: Hydrate store with a pre-defined value (JavaScript)\nDESCRIPTION: Example demonstrating how to use the `hydrate` function to populate a store with a pre-defined value within a domain.  The code creates a domain, a store within that domain, and then hydrates the store with the value `42` using the store's sid.  It then logs the state of the store to the console.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/hydrate.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createDomain, fork, serialize, hydrate } from \"effector\";\n\nconst domain = createDomain();\nconst $store = domain.createStore(0);\n\nhydrate(domain, {\n  values: {\n    [$store.sid]: 42,\n  },\n});\n\nconsole.log($store.getState()); // 42\n```\n\n----------------------------------------\n\nTITLE: Effector onCreateStore Hook Example\nDESCRIPTION: This example demonstrates how to use the `onCreateStore` hook to log a message to the console every time a new store is created in the domain.  It creates a domain and then defines a callback function that logs a message when a new store is created.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Domain.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createDomain } from \"effector\";\n\nconst domain = createDomain();\n\ndomain.onCreateStore((store) => {\n  console.log(\"new store created\");\n});\n\nconst $a = domain.createStore(null);\n// => new store created\n```\n\n----------------------------------------\n\nTITLE: useVModel with Single Effector Store in Vue 3\nDESCRIPTION: Illustrates how to use the useVModel hook with a single effector store in a Vue 3 component.  It creates a store named $user and uses the hook to bind the store's values to form inputs.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useVModel.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createApi } from \"effector\";\nimport { useVModel } from \"effector-vue/composition\";\n\nconst $user = createStore({\n  name: \"\",\n  surname: \"\",\n  skills: [\"CSS\", \"HTML\"],\n});\n\nexport default {\n  setup() {\n    const user = useVModel($user);\n\n    return { user };\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Session Deletion Logic\nDESCRIPTION: This snippet implements the session deletion logic. When the `logoutClicked` event is triggered, it initiates the `sessionApi.sessionDeleteFx` effect.  Regardless of whether the deletion is successful or not, the `$session` store is reset to null upon completion of the effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_18\n\nLANGUAGE: ts\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\n// Когда пользователь нажал на кнопку выхода, нам нужно сбросить сессию и очистить наше хранилище\nsample({\n  clock: logoutClicked,\n  target: sessionApi.sessionDeleteFx,\n});\n// В любом случае, успешно или нет, нам нужно сбросить хранилище сессий\nsample({\n  clock: sessionApi.sessionDeleteFx.finally,\n  fn: () => null,\n  target: $session,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining @@unitShape for custom entity\nDESCRIPTION: Shows how to define the `@@unitShape` property within a custom entity (in this case, a `Route` created by `createRoute`). This function should return an object representing the shape of the unit, allowing UI libraries like `effector-react` and `effector-solid` to bind to the unit's properties. It creates a Store `$params` and includes it in the shape.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/ecosystem-development/unit-shape-protocol.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createRoute(/* ... */) {\n  const $params = createStore(/* ... */);\n\n  return {\n    \"@@unitShape\": () => ({\n      params: $params,\n    }),\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Import createEffect from effector (TypeScript)\nDESCRIPTION: Imports the `createEffect` function and the `Effect` type from the Effector library. This is the basic import required to use `createEffect`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createEffect.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, type Effect } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Message Text State Management\nDESCRIPTION: This snippet demonstrates how to manage the message text state using an Effector store ($messageText) and event (messageTextChanged). The store is updated whenever the messageTextChanged event is triggered, storing the new text value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\n$messageText.on(messageTextChanged, (_, text) => text);\n```\n\n----------------------------------------\n\nTITLE: Using effector-react with effector Store\nDESCRIPTION: Demonstrates how to use an effector Store with the effector-react library's `useUnit` hook. It initializes a Store named `$value` and then uses `useUnit` to bind the store to a React component, displaying the store's value in a paragraph element. The code requires effector and effector-react dependencies.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/ecosystem-development/unit-shape-protocol.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { useUnit } from \"effector-react\";\n\nconst $value = createStore(\"Hello!\");\n\nconst Component = () => {\n  const { value } = useUnit({ value: $value });\n\n  return <p>{value}</p>;\n};\n```\n\n----------------------------------------\n\nTITLE: Typing Effects in Effector with TypeScript (Generics)\nDESCRIPTION: Shows how to type Effector effects using generics to specify input parameters, return results, and error types. Demonstrates the use of `createEffect` with an asynchronous handler function. TypeScript can infer types from the handler function or types can be provided explicitly.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\n// Базовый эффект\n// Effect<string, User, Error>\nconst fetchUserFx = createEffect<string, User>(async (userId) => {\n  const response = await fetch(`/api/users/${userId}`);\n  const result = await response.json();\n\n  return result;\n});\n```\n\n----------------------------------------\n\nTITLE: Effector Store and Event Definitions\nDESCRIPTION: Defines Effector stores and events for first name, last name, and full name, demonstrating how events update stores and how stores can be combined. This example also shows using `sample` to trigger events based on other events. The stores are automatically assigned SIDs using a plugin.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// src/features/first-name/model.ts\nimport { createStore, createEvent } from \"effector\";\n\nexport const firstNameChanged = createEvent<string>();\nexport const $firstName = createStore(\"\");\n\n$firstName.on(firstNameChanged, (_, firstName) => firstName);\n\n// src/features/last-name/model.ts\nimport { createStore, createEvent } from \"effector\";\n\nexport const lastNameChanged = createEvent<string>();\nexport const $lastName = createStore(\"\");\n\n$lastName.on(lastNameChanged, (_, lastName) => lastName);\n\n// src/features/form/model.ts\nimport { createEvent, sample, combine } from \"effector\";\n\nimport { $firstName, firstNameChanged } from \"@/features/first-name\";\nimport { $lastName, lastNameChanged } from \"@/features/last-name\";\n\nexport const formValuesFilled = createEvent<{ firstName: string; lastName: string }>();\n\nexport const $fullName = combine($firstName, $lastName, (first, last) => `${first} ${last}`);\n\nsample({\n  clock: formValuesFilled,\n  fn: (values) => values.firstName,\n  target: firstNameChanged,\n});\n\nsample({\n  clock: formValuesFilled,\n  fn: (values) => values.lastName,\n  target: lastNameChanged,\n});\n```\n\n----------------------------------------\n\nTITLE: Set handler to effect after creating (JavaScript)\nDESCRIPTION: Creates an effect `fetchUserReposFx` without an initial handler and then uses the `.use()` method to assign an asynchronous handler that fetches user repositories from the GitHub API. This demonstrates how to define an effect's handler separately from its creation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createEffect.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect();\n\nfetchUserReposFx.use(async ({ name }) => {\n  const url = `https://api.github.com/users/${name}/repos`;\n  const req = await fetch(url);\n  return req.json();\n});\n\nawait fetchUserReposFx({ name: \"zerobias\" });\n```\n\n----------------------------------------\n\nTITLE: Launch with Unit and Parameters\nDESCRIPTION: Defines the function signature for `launch` when invoked with a unit (event, effect, or store) and parameters directly.  This method is a simpler way to trigger computations within Effector units. It accepts a `Unit` or `Node` and corresponding parameters.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/launch.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nlaunch(unit: Unit | Node, params: T): void\n```\n\n----------------------------------------\n\nTITLE: useUnit with Event/Effect (TypeScript)\nDESCRIPTION: Describes the function signature for using `useUnit` with an Effector Event or Effect. It creates a function that calls the original unit but bound to a `Scope`, if one is provided via the `Provider` component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useUnit.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nuseUnit(event: EventCallable<T>): (payload: T) => T;\nuseUnit(effect: Effect<Params, Done, any>): (payload: Params) => Promise<Done>;\n```\n\n----------------------------------------\n\nTITLE: Check if a value is a Scope - Effector\nDESCRIPTION: This JavaScript snippet demonstrates how to use `is.scope` to check if a given value is an Effector scope. It creates a store, event, effect, and scope, then uses `is.scope` to determine their types.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/is.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { fork } from \"effector\";\n\nconst $store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\nconst scope = fork();\n\nis.scope(scope);\n// => true\n\nis.scope($store);\n// => false\n\nis.scope(event);\n// => false\n\nis.scope(fx);\n// => false\n\nis.scope(createDomain());\n// => false\n\nis.scope(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: Testing Effector with Custom Effect Handlers\nDESCRIPTION: This code demonstrates testing Effector logic with a custom effect handler provided via `fork`. It mocks the `validateClickFx` effect to return `true`, preventing a real API call. The test then verifies that the counter increments to 1 after the button click event is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/testing.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"main case\", async () => {\n  const scope = fork({\n    handlers: [\n      // Список пар [effect, mock handler]\n      [validateClickFx, () => true],\n    ],\n  });\n\n  expect(scope.getState($clicksCount)).toEqual(0);\n\n  await allSettled(buttonClicked, { scope });\n\n  expect(scope.getState($clicksCount)).toEqual(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Import from effector/compat\nDESCRIPTION: Imports modules from the `effector/compat` package, providing compatibility with older browsers.  This is the core functionality provided by this documentation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/module/compat.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {} from \"effector/compat\";\n```\n\n----------------------------------------\n\nTITLE: Enforcing Scope using forceScope option\nDESCRIPTION: Demonstrates how to enforce the use of Scope with modern effector-react hooks by using the forceScope option. The second parameter of `useUnit` hook checks if the Scope is passed to Provider and throws an error if it isn't.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/module/scope.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n- import { useUnit } from 'effector-react/scope'\n+ import { useUnit } from 'effector-react'\n\n\nfunction Example() {\n-  const { text } = useUnit({ text: $text })\n+  const { text } = useUnit({ text: $text }, { forceScope: true })\n\n  return <p>{text}</p>\n}\n```\n\n----------------------------------------\n\nTITLE: `match` as Object with Stores in Effector split\nDESCRIPTION: This example demonstrates using an object with stores as the `match` parameter in the `split` method. Each store in the object should contain a boolean value. The case corresponding to the store with `true` value will be executed.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/flow-split.mdx#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nconst $isAdmin = createStore(false);\nconst $isModerator = createStore(false);\n\nsplit({\n  source: postCreated,\n  match: {\n    admin: $isAdmin,\n    moderator: $isModerator,\n  },\n  cases: {\n    admin: createAdminPostFx,\n    moderator: createModeratorPostFx,\n    __: createUserPostFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Reading Store Value in Vue with useUnit\nDESCRIPTION: Demonstrates how to read the current value of an effector store within a Vue component using the `useUnit` hook from `effector-vue/composition`. The `counter` variable holds the value of the `$counter` store, accessible in the Vue template.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<script setup>\n  import { useUnit } from \"effector-vue/composition\";\n  import { $counter } from \"./model.js\";\n  const counter = useUnit($counter);\n</script>\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Events and Store - TypeScript\nDESCRIPTION: This snippet initializes the necessary events and a store for managing WebSocket connections using Effector.  It creates events for disconnection and message handling, and a store to hold the WebSocket instance, which is updated upon successful connection and reset upon disconnection. Dependencies: effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/websocket-integration.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\n// События для работы с сокетом\nconst disconnected = createEvent();\nconst messageSent = createEvent<string>();\nconst rawMessageReceived = createEvent<string>();\n\nconst $connection = createStore<WebSocket | null>(null)\n  .on(connectWebSocketFx.doneData, (_, ws) => ws)\n  .reset(disconnected);\n```\n\n----------------------------------------\n\nTITLE: Testing Effect Execution with Mock Handlers\nDESCRIPTION: This snippet shows how to test Effector effects by providing a mock handler within the `fork` configuration. It intercepts the `getUserProjectsFx` effect and provides a mock implementation that returns a predefined value. The test verifies that the effect completes successfully and returns the expected mock data.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/testing.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fork, allSettled } from \"effector\";\nimport { getUserProjectsFx } from \"./effect.js\";\n\ntest(\"effect executes correctly\", async () => {\n  const scope = fork({\n    handlers: [\n      // Список [эффект, моковый обработчик] пар\n      [getUserProjectsFx, () => \"user projects data\"],\n    ],\n  });\n\n  const result = await allSettled(getUserProjectsFx, { scope });\n\n  expect(result.status).toBe(\"done\");\n  expect(result.value).toBe(\"user projects data\");\n});\n```\n\n----------------------------------------\n\nTITLE: Triggering Socket.IO Connection Effect (TypeScript)\nDESCRIPTION: These code snippets show how to trigger the `connectFx` effect when the `connectSocket` event is triggered, and how to trigger the `socketConnected` event when the `connectSocketFx` effect is done. This is used to start the Socket.IO connection process and to signal that the connection has been established successfully. The `sample` function from Effector is used to connect events and effects.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// initialize connection\nsample({\n  clock: connectSocket,\n  target: connectFx,\n});\n\n// trigger event after successful connection\nsample({\n  clock: connectSocketFx.doneData,\n  target: socketConnected,\n});\n```\n\n----------------------------------------\n\nTITLE: Using `is.attached` to Prevent Duplicate Error Logging in JavaScript\nDESCRIPTION: This snippet demonstrates a practical use case of `is.attached` to prevent duplicate error logging for effects that were created using `attach`. It creates a domain, a base effect, and then attaches two new effects to the base effect. It uses `is.attached` within the `onCreateEffect` hook to only log failures for attached effects.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/is.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createDomain, attach, is } from \"effector\";\n\nconst logFailuresDomain = createDomain();\n\nlogFailuresDomain.onCreateEffect((effect) => {\n  if (is.attached(effect)) {\n    effect.fail.watch(({ params, error }) => {\n      console.warn(`Effect \\\"${effect.compositeName.fullName}\\\" failed`, params, error);\n    });\n  }\n});\n\nconst baseRequestFx = logFailuresDomain.createEffect((path) => {\n  throw new Error(`path ${path}`);\n});\n\nconst loadDataFx = attach({\n  mapParams: () => \"/data\",\n  effect: baseRequestFx,\n});\n\nconst loadListFx = attach({\n  mapParams: () => \"/list\",\n  effect: baseRequestFx,\n});\n\nloadDataFx();\nloadListFx();\n```\n\n----------------------------------------\n\nTITLE: Typing `is` methods as type guards in TypeScript\nDESCRIPTION: `is` methods are showcased here as TypeScript type guards, which refine the type of a unit, leading to more type-safe helper functions. In each branch of the `if` statement, TypeScript knows the specific type of `unit` due to the `is` methods.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport function getUnitType(unit: unknown) {\n  if (is.event(unit)) {\n    // here unit has Event<any> type\n    return \"event\";\n  }\n  if (is.effect(unit)) {\n    // here unit has Effect<any, any> type\n    return \"effect\";\n  }\n  if (is.store(unit)) {\n    // here unit has Store<any> type\n    return \"store\";\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Event.prepend TypeScript example\nDESCRIPTION: This code shows how to correctly use `prepend` with TypeScript by explicitly setting the type of the argument of the `fn` function, which is required.  Ensures type safety when transforming data before passing it to the original event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst original = createEvent<{ input: string }>();\n\nconst prepended = original.prepend((input: string) => ({ input }));\n//                                         ^^^^^^ here\n```\n\n----------------------------------------\n\nTITLE: Event watch Example\nDESCRIPTION: Demonstrates how to use the `watch` method to observe event triggers and log the event's payload. Shows how to unsubscribe from the event using the returned `unwatch` function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst sayHi = createEvent();\nconst unwatch = sayHi.watch((name) => console.log(`${name}, привет!`));\n\nsayHi(\"Питер\"); // => Питер, привет!\nunwatch();\n\nsayHi(\"Дрю\"); // => ничего не произошло\n```\n\n----------------------------------------\n\nTITLE: Effector Test with Mocked Handler\nDESCRIPTION: This code snippet demonstrates how to mock the server response by providing a custom handler via the fork configuration, which is useful for avoiding real server requests. The mock returns `true` regardless of the actual server response. This makes the unit test predictable and isolated.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/testing.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"main case\", async () => {\n  const scope = fork({\n    handlers: [\n      // List of [effect, mock handler] pairs\n      [validateClickFx, () => true],\n    ],\n  });\n\n  expect(scope.getState($clicksCount)).toEqual(0);\n\n  await allSettled(buttonClicked, { scope });\n\n  expect(scope.getState($clicksCount)).toEqual(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Using useEffect to Trigger Page Mount Event\nDESCRIPTION: This code utilizes the `useEffect` hook in React to trigger the `pageMounted` event when the `ChatPage` component is mounted.  This initiates the process of loading user session and messages when the page loads. This ensures that data loading begins as soon as the component renders.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\n// File: /src/pages/chat/page.tsx\nexport function ChatPage() {\n  const handlePageMount = useUnit(model.pageMounted);\n\n  React.useEffect(() => {\n    handlePageMount();\n  }, [handlePageMount]);\n\n  return (\n    <div className=\"parent\">\n      <ChatHistory />\n      <MessageForm />\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Typed `mapParams`\nDESCRIPTION: This snippet illustrates the type constraints when using `mapParams`. The return type of `mapParams` must match the input type of the original effect.  It also demonstrates handling of `void` parameters.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst originalFx: Effect<A, Done, Fail>;\n\nconst attachedFx: Effect<B, Done, Fail> = attach({\n  effect: originalFx,\n  mapParams: (params: B): A {},\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst attachedFx: Effect<void, Done, Fail> = attach({\n  effect: originalFx,\n  mapParams: (): A {},\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst attachedFx: Effect<void, Done, Fail> = attach({\n  effect: originalFx,\n  mapParams: (): A {\n    throw new AnyNonFailType(); // It can be noncompatible with `Fail` type\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Pre-Handler with prepend\nDESCRIPTION: Shows how to create an event pre-handler using `event.prepend`.  This allows transforming data before it reaches the original event. In this scenario, errors are converted into a standard error string before being passed to `showError`. It imports `createEvent` from the `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/events.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\n// Main error handling event\nconst showError = createEvent<string>();\n\n// Subscribe to error displays\nsample({\n  clock: showError,\n  target: processErrorFx, // we'll skip the effect implementation\n});\n\n// Create special events for different types of errors\nconst showNetworkError = showError.prepend((code: number) => `Network error: ${code}`);\n\nconst showValidationError = showError.prepend(\n  (field: string) => `Field ${field} is filled incorrectly`,\n);\n\n// Usage\nshowNetworkError(404); // 🔴 Error: Network error: 404\nshowValidationError(\"email\"); // 🔴 Error: Field email is filled incorrectly\n```\n\n----------------------------------------\n\nTITLE: Basic useUnit with Store and API (JavaScript)\nDESCRIPTION: Demonstrates the basic usage of `useUnit` with a Store and API in a React component. This component manages a counter state using increment and decrement events, triggered by button clicks. The example shows how to bind these events using `useUnit`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useUnit.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createApi } from \"effector\";\nimport { useUnit } from \"effector-react\";\n\nconst $counter = createStore(0);\n\nconst { incrementClicked, decrementClicked } = createApi($counter, {\n  incrementClicked: (count) => count + 1,\n  decrementClicked: (count) => count - 1,\n});\n\nconst App = () => {\n  const counter = useUnit($counter);\n  const [onIncrement, onDecrement] = useUnit([incrementClicked, decrementClicked]);\n\n  return (\n    <div>\n      {counter}\n      <button onClick={onIncrement}>Increment</button>\n      <button onClick={onDecrement}>Decrement</button>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Basic useList Example (JSX)\nDESCRIPTION: Demonstrates the basic usage of `useList` with a store containing an array of user objects. It renders a list of users without the need for explicit keys, utilizing the index as the key. The component re-renders only when the data changes, optimizing performance.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useList.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { useList } from \"effector-react\";\n\nconst $users = createStore([\n  { id: 1, name: \"Yung\" },\n  { id: 2, name: \"Lean\" },\n  { id: 3, name: \"Kyoto\" },\n  { id: 4, name: \"Sesh\" },\n]);\n\nconst App = () => {\n  // we don't need keys here any more\n  const list = useList($users, ({ name }, index) => (\n    <li>\n      [{index}] {name}\n    </li>\n  ));\n\n  return <ul>{list}</ul>;\n};\n```\n\n----------------------------------------\n\nTITLE: Serialize Forked Instance State (JavaScript)\nDESCRIPTION: This code demonstrates how to serialize the state of a forked Effector scope after an event has been triggered and settled. It creates a store, an event, forks the store, triggers the event in the forked scope, and then serializes the scope's state using the `serialize` method. The serialized state will be an object containing the updated store value, keyed by its SID. Requires `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/serialize.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, allSettled, fork, serialize } from \"effector\";\n\nconst inc = createEvent();\nconst $store = createStore(42);\n$store.on(inc, (x) => x + 1);\n\nconst scope = fork();\n\nawait allSettled(inc, { scope });\n\nconsole.log(serialize(scope)); // => {[sid]: 43}\n```\n\n----------------------------------------\n\nTITLE: Using Effector Store in Vue Component\nDESCRIPTION: This Vue component uses the useUnit hook from effector-vue to connect to the effector store $text, $size and the inputText event. It displays an input field that updates the $text store and displays the length of the text. The script is using typescript.\nSOURCE: https://github.com/effector/effector/blob/master/packages/effector-vue/README.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<script lang=\"ts\" setup>\n  import {useUnit} from 'effector-vue/composition'\n  import {$text, $size, inputText} from './model'\n\n  const text = useUnit($text)\n  const size = useUnit($size)\n\n  const handleTextChange = useUnit(inputText)\n</script>\n\n<template>\n  <form>\n    <input\n      type=\"text\"\n      @input=\"(e) => handleTextChange(e.currentTarget.value)\"\n      :value=\"text\"\n    />\n    <p>Length: {{ size }}</p>\n  </form>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Effector Effect finally Event\nDESCRIPTION: Illustrates the usage of the `.finally` event of an Effector Effect. This event is triggered regardless of whether the effect resolves successfully or rejects.  The example demonstrates how to track the status, parameters, and result/error of the effect execution.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchApiFx = createEffect(async ({ time, ok }) => {\n  await new Promise((resolve) => setTimeout(resolve, time));\n  if (ok) return `${time} ms`;\n  throw Error(`${time} ms`);\n});\n\nfetchApiFx.finally.watch((value) => {\n  switch (value.status) {\n    case \"done\":\n      console.log(\"Call with params\", value.params, \"resolved with value\", value.result);\n      break;\n    case \"fail\":\n      console.log(\"Call with params\", value.params, \"rejected with error\", value.error.message);\n      break;\n  }\n});\n\nawait fetchApiFx({ time: 100, ok: true });\n// => Call with params {time: 100, ok: true}\n//    resolved with value 100 ms\n\nfetchApiFx({ time: 100, ok: false });\n// => Call with params {time: 100, ok: false}\n//    rejected with error 100 ms\n```\n\n----------------------------------------\n\nTITLE: Create Derived Store with `.map()` (JavaScript)\nDESCRIPTION: Creates a derived store using the `.map()` method.  The derived store `$length` updates whenever the original store `$title` changes, calculating the length of the title. It includes a watcher to log the new length.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst changed = createEvent();\nconst $title = createStore(\"\").on(changed, (_, newTitle) => newTitle);\nconst $length = $title.map((title) => title.length);\n\n$length.watch((length) => {\n  console.log(\"new length\", length);\n});\n\nchanged(\"hello\");\nchanged(\"world\");\nchanged(\"hello world\");\n```\n\n----------------------------------------\n\nTITLE: Watching Store Changes with watch in effector\nDESCRIPTION: Illustrates how to subscribe to store changes using the `watch` method for debugging or integration purposes. The callback function logs the current value of the `$counter` store whenever it changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n$counter.watch((counter) => {\n  console.log(\"Counter changed:\", counter);\n});\n```\n\n----------------------------------------\n\nTITLE: createStore with updateFilter\nDESCRIPTION: Illustrates how to use the `updateFilter` option in `createStore` to prevent store updates based on a condition.  The store only updates if the new strength is greater than or equal to 400.  A `sample` is used to trigger the `veryStrongHit` event whenever the `$lastPunchStrength` store is updated.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createStore.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore, sample } from \"effector\";\n\nconst punch = createEvent();\nconst veryStrongHit = createEvent();\n\nconst $lastPunchStrength = createStore(0, {\n  // If store should be updated with strength less than 400 kg\n  // update will be skipped\n  updateFilter: (strength) => strength >= 400,\n});\n\n$lastPunchStrength.on(punch, (_, strength) => strength);\n\n// Each store update should trigger event `veryStrongHit`\nsample({ clock: $lastPunchStrength, target: veryStrongHit });\n\n// Watch on store prints initial state\n$lastPunchStrength.watch((strength) => console.log(\"Strength: %skg\", strength));\n// => Strength: 0kg\n\nveryStrongHit.watch((strength) => {\n  console.log(\"Wooow! It was very strong! %skg\", strength);\n});\n\npunch(200); // updateFilter prevented update\npunch(300); // Same here, store doesn't update, value remains `0`\npunch(500); // Yeeah! updateFilter allows store update\n// => Strength: 500kg\n// => Wooow! It was very strong! 500kg\npunch(100); // No update as well\n```\n\n----------------------------------------\n\nTITLE: Watching Events with patronum/debug\nDESCRIPTION: Demonstrates how to use `patronum/debug` to watch and log when events are triggered and their payloads. It imports `createEvent`, `sample` from `effector`, and `debug` from `patronum`.  It creates two events, links them with sample, and then attaches the debug watcher.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/events.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, sample } from \"effector\";\nimport { debug } from \"patronum\";\n\nconst firstTriggered = createEvent<void>();\nconst secondTriggered = createEvent<void>();\n\nsample({\n  clock: firstTriggered,\n  target: secondTriggered,\n});\n\ndebug(firstTriggered, secondTriggered);\n\nfirstTriggered();\n// => [event] firstTriggered undefined\n// => [event] secondTriggered undefined\n```\n\n----------------------------------------\n\nTITLE: Mapping Arguments with `attach`\nDESCRIPTION: This example demonstrates how to map arguments to an effect using `attach`. The `mapParams` function transforms the input value before passing it to the original effect.  This is useful for adapting the input to match the original effect's expected format.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, attach } from \"effector\";\n\nconst originalFx = createEffect((a: { input: number }) => a);\n\nconst attachedFx = attach({\n  effect: originalFx,\n  mapParams(a: number) {\n    return { input: a * 100 };\n  },\n});\n\noriginalFx.watch((params) => console.log(\"originalFx started\", params));\n\nattachedFx(1);\n// => originalFx { input: 100 }\n```\n\n----------------------------------------\n\nTITLE: Creating Event with TypeScript interface\nDESCRIPTION: Creates an Effector event with a specific TypeScript interface. The type argument `<ItemAdded>` defines the structure of the data the event will carry, ensuring type safety when the event is triggered and handled.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\ninterface ItemAdded {\n  id: string;\n  title: string;\n}\n\nconst itemAdded = createEvent<ItemAdded>();\n```\n\n----------------------------------------\n\nTITLE: Import useUnit from effector-solid\nDESCRIPTION: Imports the `useUnit` function from the `effector-solid` library. This allows you to bind effector stores, events, and effects to the Solid reactivity system.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useUnit.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useUnit } from \"effector-solid\";\n```\n\n----------------------------------------\n\nTITLE: Effector Sample Usage with Event and Store\nDESCRIPTION: Shows how to use `sample` with an event as the `clock` and a store as the `source`. The result will be an event, because the `clock` is not a store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/sample.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst event = sample({ clock: event, source: $store });\n// Результатом будет эвент, так как `clock` – не стор\n```\n\n----------------------------------------\n\nTITLE: Defining Message Schemas with Zod - TypeScript\nDESCRIPTION: This code defines a schema for WebSocket messages using the Zod library. It specifies two types of messages: `balanceChanged` and `reportGenerated`, each with its own specific fields and types. This schema is used to validate incoming messages and ensure type safety. Dependencies: zod.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/websocket-integration.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport const messagesSchema = z.discriminatedUnion(\"type\", [\n  z.object({\n    type: z.literal(\"balanceChanged\"),\n    balance: z.number(),\n  }),\n  z.object({\n    type: z.literal(\"reportGenerated\"),\n    reportId: z.string(),\n    reportName: z.string(),\n  }),\n]);\n\n// Получаем тип из схемы\ntype MessagesSchema = z.infer<typeof messagesSchema>;\n```\n\n----------------------------------------\n\nTITLE: Creating and Calling an Effector Event (Imperative)\nDESCRIPTION: Demonstrates how to create an event using `createEvent` and trigger it imperatively by calling it as a function.  The event `callHappened` is created and then immediately invoked.  It imports the necessary `createEvent` function from the `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/events.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst callHappened = createEvent<void>();\n\ncallHappened(); // event triggered\n```\n\n----------------------------------------\n\nTITLE: Restoring Message on Failure\nDESCRIPTION: This snippet shows how to restore the message text in the input field if sending the message fails. It uses the fail event of the messageSendFx effect to set the $messageText store to the original message text (params.text).\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\nsample({\n  clock: messageSendFx.fail,\n  fn: ({ params }) => params.text,\n  target: $messageText,\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Effect Errors Typing in Effector with TypeScript\nDESCRIPTION: Illustrates how to define custom error types for Effector effects using the third generic parameter `Fail`.  This allows for more specific error handling and better type safety when dealing with API errors or other specific error scenarios.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Определяем типы ошибок API\ninterface ApiError {\n  code: number;\n  message: string;\n}\n\n// Создаём типизированный эффект\nconst fetchUserFx = createEffect<string, User, ApiError>(async (userId) => {\n  const response = await fetch(`/api/users/${userId}`);\n\n  if (!response.ok) {\n    throw {\n      code: response.status,\n      message: \"Failed to fetch user\",\n    } as ApiError;\n  }\n\n  return response.json();\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Router Provider Component (JavaScript)\nDESCRIPTION: This snippet creates a React component that acts as a provider for the Effector router. It uses the `useRouter` hook from 'next/navigation' to access the router instance and the `useUnit` hook from 'effector-react' to attach the router to the Effector store. The component re-attaches the router on each render. It requires 'effector-react' and 'next/navigation' dependencies.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/nextjs/router.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useUnit } from 'effector-react';\nimport { useRouter } from 'next/navigation'\n\nexport function EffectorRouterProvider({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n  const attachRouter = useUnit(routerAttached)\n\n  useEffect(() => {\n    attachRouter(router)\n  }, [router, attachRouter])\n\n  return <>{children}</>\n}\n\n```\n\n----------------------------------------\n\nTITLE: Set initial state and change effect handler - TS\nDESCRIPTION: This TypeScript code provides an example of setting an initial state for a store and changing the handler for an effect within a forked scope. It simulates a test scenario where `fetchFriendsFx` fetches data and updates the `$friends` store. The forked scope is configured to use a mocked handler for `fetchFriendsFx` and an initial value for `$user`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/fork.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { createEffect, createStore, fork, allSettled } from \"effector\";\n\nconst fetchFriendsFx = createEffect<{ limit: number }, string[]>(async ({ limit }) => {\n  /* получение данных на стороне клиента */\n  return [];\n});\nconst $user = createStore(\"guest\");\nconst $friends = createStore([]);\n\n$friends.on(fetchFriendsFx.doneData, (_, result) => result);\n\nconst testScope = fork({\n  values: [[$user, \"alice\"]],\n  handlers: [[fetchFriendsFx, () => [\"bob\", \"carol\"]]],\n});\n\n/* запускаем вычисления в scope и ожидаем завершения всех вызванных effects */\nawait allSettled(fetchFriendsFx, {\n  scope: testScope,\n  params: { limit: 10 },\n});\n\n/* проверяем значение стора в scope */\nconsole.log(testScope.getState($friends));\n// => ['bob', 'carol']\n```\n\n----------------------------------------\n\nTITLE: Restore store from event - JavaScript\nDESCRIPTION: Creates a store that is updated by an event.  The store is initialized with a default value, and when the event is triggered, the store's value is updated to the event's payload. Requires `createEvent` and `restore` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/restore.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, restore } from \"effector\";\n\nconst event = createEvent();\nconst $store = restore(event, \"default\");\n\n$store.watch((state) => console.log(\"state: \", state));\n// state: default\n\nevent(\"foo\");\n// state: foo\n```\n\n----------------------------------------\n\nTITLE: Creating a store with a stable ID (sid) in Effector (TS)\nDESCRIPTION: This code snippet shows how to create an Effector store with a stable ID (`sid`). The `sid` is essential for correct data hydration during server-side rendering (SSR). It is added by passing an object with the `sid` property as the second argument to `createStore`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/troubleshooting.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = createStore(0, {\n  sid: \"unique id\",\n});\n```\n\n----------------------------------------\n\nTITLE: Create Gate with Name - TypeScript\nDESCRIPTION: Defines the type signature for `createGate` with an optional name parameter.  The name is used as the name of a created Solid component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/createGate.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ncreateGate(name): Gate\n```\n\n----------------------------------------\n\nTITLE: Extracting Event Payload Type (TypeScript)\nDESCRIPTION: Demonstrates extracting the payload type from an Effector Event using the `EventPayload` utility type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type EventPayload } from \"effector\";\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst event: Event<Payload>;\ntype Payload = EventPayload<typeof event>;\n```\n\n----------------------------------------\n\nTITLE: Create events with reducers using createApi - JS\nDESCRIPTION: Creates a store and events using `createApi`. The events `moveLeft` and `moveRight` are connected to the `$playerPosition` store, with reducers that update the store's value based on the provided offset. Dependencies: `createStore`, `createApi` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createApi.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createApi } from \"effector\";\n\nconst $playerPosition = createStore(0);\n\n// Creating events and attaching them to the store\nconst api = createApi($playerPosition, {\n  moveLeft: (pos, offset) => pos - offset,\n  moveRight: (pos, offset) => pos + offset,\n});\n\n$playerPosition.watch((pos) => {\n  console.log(\"position\", pos);\n});\n// => position 0\n\napi.moveRight(10);\n// => position 10\napi.moveLeft(5);\n// => position 5\n```\n\n----------------------------------------\n\nTITLE: Testing Store Updates with Effector\nDESCRIPTION: This code snippet demonstrates how to test store updates in Effector using `fork` to create an isolated scope and `allSettled` to trigger events and wait for their effects. It checks if the counter store increases by 1 after the `counterIncremented` event is triggered within the forked scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/testing.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { counterIncremented, $counter } from \"./counter.js\";\n\ntest(\"counter should increase by 1\", async () => {\n  const scope = fork();\n\n  expect(scope.getState($counter)).toEqual(0);\n\n  await allSettled(counterIncremented, { scope });\n\n  expect(scope.getState($counter)).toEqual(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating domains with createDomain (JavaScript)\nDESCRIPTION: This example demonstrates how to create unnamed and named domains using `createDomain`. It also shows how to create events, effects, nested domains and stores within a domain, illustrating its role in organizing application logic and state. This showcases the basic usage of effector domains.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createDomain.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createDomain } from \"effector\";\n\nconst domain = createDomain(); // Unnamed domain\nconst httpDomain = createDomain(\"http\"); // Named domain\n\nconst statusCodeChanged = httpDomain.createEvent();\nconst downloadFx = httpDomain.createEffect();\nconst apiDomain = httpDomain.createDomain(); // nested domain\nconst $data = httpDomain.createStore({ status: -1 });\n```\n\n----------------------------------------\n\nTITLE: Effector Split Source and Match\nDESCRIPTION: Illustrates the function signature of the shorter `split` function, taking only the source unit and the match object as parameters.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nsplit(source, match);\n```\n\n----------------------------------------\n\nTITLE: Fork with Effect Handlers (TypeScript)\nDESCRIPTION: Shows how to replace effect handlers when creating a forked scope using the `handlers` option. It provides three different ways to pass effect handlers: an array of tuples, a Map, and a plain object. Requires `fork` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/fork.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfork({\n  handlers: [\n    [getMessageFx, (params) => ({ id: 0, text: \"message\" })],\n    [getUserFx, async (params) => ({ name: \"alice\", age: 21 })],\n  ],\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfork({\n  handlers: new Map()\n    .set(getMessageFx, (params) => ({ id: 0, text: \"message\" }))\n    .set(getUserFx, async (params) => ({ name: \"alice\", age: 21 })),\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfork({\n  handlers: {\n    [getMessageFx.sid]: (params) => ({ id: 0, text: \"message\" }),\n    [getUserFx.sid]: async (params) => ({ name: \"alice\", age: 21 }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: combine skipVoid example\nDESCRIPTION: Demonstrates setting the `skipVoid` option when using combine.  If set to `false`, the resulting store will emit `undefined` values.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/combine.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst $withFn = combine($a, $b, (a, b) => a || b, { skipVoid: false });\n```\n\n----------------------------------------\n\nTITLE: useUnit with Store in Vue\nDESCRIPTION: Demonstrates how to use `useUnit` with an Effector store (`$count`) in a Vue component. The `count` variable returned by `useUnit` is a reactive value that automatically updates the view when the store's value changes. This showcases how to efficiently integrate Effector's state management with Vue's reactivity system.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useUnit.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n// App.vue\n\n<script setup>\n  import { useUnit } from \"effector-vue/composition\";\n\n  import { $count } from \"./model.js\";\n\n  const count = useUnit($count);\n</script>\n\n<template>\n  <p>Count: {{ count }}</p>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Importing createEvent from Effector (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to import the `createEvent` function from the Effector library in a TypeScript project. This import statement is necessary to use `createEvent` in subsequent code.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createEvent.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Merging Events with Type Constraints (TypeScript)\nDESCRIPTION: This snippet demonstrates using generics with Effector's `merge` function to specify the expected type of events being merged. If the provided events do not conform to the specified type, a TypeScript error will be raised, ensuring type safety.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, merge } from \"effector\";\n\nconst firstEvent = createEvent<string>();\nconst secondEvent = createEvent<number>();\n\nconst merged = merge<number>([firstEvent, secondEvent]);\n//                                ^\n// Type 'EventCallable<string>' is not assignable to type 'Unit<number>'.\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Stores with map - Effector\nDESCRIPTION: Illustrates how to create stores whose values depend on other store states using the `map` method.  It shows creating filtered lists and computed values. Imports `createStore` and `combine` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/manage-states.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, combine } from \"effector\";\n\nconst $currentUser = createStore({\n  id: 1,\n  name: \"Winnie Pooh\",\n});\nconst $users = createStore<User[]>([ ]);\n\n// Отфильтрованный список\nconst $activeUsers = $users.map((users) => users.filter((user) => user.active));\n\n// Вычисляемое значение\nconst $totalUsersCount = $users.map((users) => users.length);\nconst $activeUsersCount = $activeUsers.map((users) => users.length);\n\n// Комбинация нескольких сторов\nconst $friendsList = combine($users, $currentUser, (users, currentUser) =>\n  users.filter((user) => user.friendIds.includes(currentUser.id)),\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Event For Specific Message Type - Typescript\nDESCRIPTION: Creates an event that triggers only for a specific message type, leveraging TypeScript's type system to ensure type safety. It uses `sample` with a filter to narrow down the message type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ntype MessageType<T extends MessagesSchema[\"type\"]> = Extract<MessagesSchema, { type: T }>;\n\nexport const messageReceivedByType = <T extends MessagesSchema[\"type\"]>(type: T) => {\n  return sample({\n    clock: parsedMessageReceived,\n    filter: (message): message is MessageType<T> => {\n      return message.type === type;\n    },\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Store for Orientation Change (JS)\nDESCRIPTION: This code initializes an Effector store that tracks the current orientation of the screen. It creates an event `orientationChange` that is triggered when the screen orientation changes. The `$isPortrait` store is updated based on the `matches` property of the event, reflecting whether the screen is currently in portrait mode.\nSOURCE: https://github.com/effector/effector/blob/master/recipes/media-queries/README.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport {createEvent, createStore} from 'effector'\n\nconst orientationChange = createEvent()\n\nconst $isPortrait = createStore(false).on(\n  orientationChange,\n  (_, event) => event.matches,\n)\n\nconst orientationMediaQuery = window.matchMedia('(orientation: portrait)')\norientationMediaQuery.addListener(orientationChange)\n```\n\n----------------------------------------\n\nTITLE: Store .reinit Example - Javascript\nDESCRIPTION: Illustrates how to use the `reinit` event of a store to reset it to its default state. The `reinit` event can be triggered manually to revert the store to its initial value, as shown in the example.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, sample, is } from \"effector\";\n\nconst $counter = createStore(0);\nis.event($counter.reinit);\n\nconst increment = createEvent();\n\n$counter.reinit();\nconsole.log($counter.getState());\n```\n\n----------------------------------------\n\nTITLE: Splitting store with short form - Effector - TypeScript\nDESCRIPTION: This example demonstrates the short form of the `split` method, using a store as the data source. It creates a store `$repo` and splits it based on `isStarred` property. The `starredRepo` event is triggered when `repo.isStarred` is true, and `unstarredRepo` when it's false. A default case is also included. This form is useful when there are no external data dependencies.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/flow-split.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, split } from \"effector\";\n\ntype Repo = {\n  // ... other properties\n  isStarred: boolean;\n  isWatched: boolean;\n};\n\nconst toggleStar = createEvent<string>();\nconst toggleWatch = createEvent<string>();\n\nconst $repo = createStore<null | Repo>(null)\n  .on(toggleStar, (repo) => ({\n    ...repo,\n    isStarred: !repo.isStarred,\n  }))\n  .on(toggleWatch, (repo) => ({ ...repo, isWatched: !repo.isWatched }));\n\nconst { starredRepo, unstarredRepo, __ } = split($repo, {\n  starredRepo: (repo) => repo.isStarred,\n  unstarredRepo: (repo) => !repo.isStarred,\n});\n\n// Debug default case\n__.watch((repo) => console.log(\"[split toggleStar] Default case triggered with value \", repo));\n\n// Somewhere in the app\ntoggleStar();\n```\n\n----------------------------------------\n\nTITLE: Basic createGate Usage - React JSX\nDESCRIPTION: Demonstrates the basic usage of `createGate` to create a gate component in a React application.  It shows how to define a gate, render it within a component, and observe its state changes. The example includes mounting and unmounting the component to show state transitions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/createGate.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { createGate } from \"effector-react\";\n\nconst Gate = createGate(\"gate with props\");\n\nconst App = () => (\n  <section>\n    <Gate foo=\"bar\" />\n  </section>\n);\n\nGate.state.watch((state) => {\n  console.log(\"current state\", state);\n});\n// => current state {}\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n// => current state {foo: 'bar'}\n\nReactDOM.unmountComponentAtNode(document.getElementById(\"root\"));\n// => current state {}\n```\n\n----------------------------------------\n\nTITLE: Sampling with Filter Function in Effector (JavaScript)\nDESCRIPTION: This snippet illustrates how to use the `filter` option within the `sample` function for conditional event triggering.  The `transactionFx` effect is only triggered if the `isSigned` store is true and the `balance` store is greater than `amountToSend`.  The `fn` option transforms the data before passing it to `transactionFx`. It demonstrates a money transfer scenario and depends on `createStore`, `createEvent`, `createEffect`, and `sample` from the Effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/sample.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, createEffect, sample } from \"effector\";\n\nconst sign = createEvent();\nconst sentMoney = createEvent();\n\nconst $recipientAddress = createStore(\"a23x3xd\");\nconst $balance = createStore(20000);\nconst $isSigned = createStore(false);\n\nconst transactionFx = createEffect(\n  ({ amountToSend, recipientAddress }) =>\n    new Promise((res) =>\n      setTimeout(res, 3000, {\n        amount: amountToSend,\n        recipientAddress,\n      }),\n    ),\n);\n\n$isSigned.on(sign, () => true).reset(transactionFx);\n$balance.on(transactionFx.doneData, (balance, { amount }) => balance - amount);\n\nsample({\n  source: {\n    recipientAddress: $recipientAddress,\n    isSigned: $isSigned,\n    balance: $balance,\n  },\n  clock: sentMoney,\n  filter: ({ isSigned, balance }, amountToSend) => isSigned && balance > amountToSend,\n  fn({ recipientAddress }, amountToSend) {\n    return { recipientAddress, amountToSend };\n  },\n  target: transactionFx,\n});\n\n$balance.watch((balance) => console.log(\"balance: \", balance));\n$isSigned.watch((isSigned) => console.log(\"is signed: \", isSigned));\n\nsign();\nsentMoney(1000);\n```\n\n----------------------------------------\n\nTITLE: Accessing Scope with useProvidedScope in React\nDESCRIPTION: This code snippet demonstrates how to use the `useProvidedScope` hook in a React component to access the current `Scope`. The hook returns the `Scope` object or `null` if no `Scope` is provided. It's designed for library internals and not recommended for direct production use.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useProvidedScope.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst useCustomLibraryInternals = () => {\n  const scope = useProvidedScope();\n\n  // ...\n};\n```\n\n----------------------------------------\n\nTITLE: effector split with Message Length (JavaScript)\nDESCRIPTION: Illustrates how to use `effector.split` based on the length of a message. The `message` event is split into `short`, `medium`, and `long` events based on the length of the message string. Each of these events then triggers a corresponding console log.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_11\n\nLANGUAGE: js\nCODE:\n```\nimport { createEvent, split } from \"effector\";\n\nconst message = createEvent();\n\nconst { short, long, medium } = split(message, {\n  short: (m) => m.length <= 5,\n  medium: (m) => m.length > 5 && m.length <= 10,\n  long: (m) => m.length > 10,\n});\n\nshort.watch((m) => console.log(`короткое сообщение '${m}'`));\nmedium.watch((m) => console.log(`среднее сообщение '${m}'`));\nlong.watch((m) => console.log(`длинное сообщение '${m}'`));\n\nmessage(\"Привет, Боб!\");\n// => длинное сообщение 'Привет, Боб!'\n\nmessage(\"Привет!\");\n// => короткое сообщение 'Привет!'\n```\n\n----------------------------------------\n\nTITLE: Mapping Effect Data with map() - Javascript\nDESCRIPTION: Demonstrates the `map` method of Effector effects to create derived events. Two derived events are created from `updateUserFx`: `userNameUpdate` and `userRoleUpdate`. These events extract and transform specific parts of the effect's input data (name and role respectively).  The example also shows watching these events and logging when triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst updateUserFx = createEffect(({ name, role }) => {});\nconst userNameUpdate = updateUserFx.map(({ name }) => name);\nconst userRoleUpdate = updateUserFx.map(({ role }) => role.toUpperCase());\n\nuserNameUpdate.watch((name) => {\n  console.log(`Началось изменение имени пользователя на ${name}`);\n});\nuserRoleUpdate.watch((role) => {\n  console.log(`Началось изменение роли пользователя на ${role}`);\n});\n\nawait updateUserFx({ name: \"john\", role: \"admin\" });\n// => Началось изменение имени пользователя на john\n// => Началось изменение роли пользователя на ADMIN\n```\n\n----------------------------------------\n\nTITLE: Using Effector with Solid\nDESCRIPTION: This Solid component demonstrates how to use Effector with Solid using the `useUnit` hook from `effector-solid`. It imports a store `$counter` and events `incremented` and `decremented` from `./counter.js` and connects them to the component. Note that the counter value is accessed as a function call: `counter()`\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\nimport { useUnit } from \"effector-solid\";\nimport { $counter, incremented, decremented } from \"./counter.js\";\n\nconst Counter = () => {\n  const [counter, onIncremented, onDecremented] = useUnit([$counter, incremented, decremented]);\n  // or\n  const { counter, onIncremented, onDecremented } = useUnit({ $counter, incremented, decremented });\n  // or\n  const counter = useUnit($counter);\n  const onIncremented = useUnit(incremented);\n  const onDecremented = useUnit(decremented);\n\n  return (\n    <div>\n      <h1>Count: {counter()}</h1>\n      <button onClick={onIncremented}>Increment</button>\n      <button onClick={onDecremented}>Decrement</button>\n    </div>\n  );\n};\n\nexport default Counter;\n```\n\n----------------------------------------\n\nTITLE: Effector Split Basic Example\nDESCRIPTION: A basic example showcasing how `split` routes messages based on their type. It defines events for receiving messages, showing text popups, playing audio, and reporting unknown message types.  The `split` function directs messages to the appropriate event based on the `type` property.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { split, createEffect, createEvent } from \"effector\";\nconst messageReceived = createEvent();\nconst showTextPopup = createEvent();\nconst playAudio = createEvent();\nconst reportUnknownMessageTypeFx = createEffect(({ type }) => {\n  console.log(\"неизвестное сообщение:\", type);\n});\n\nsplit({\n  source: messageReceived,\n  match: {\n    text: (msg) => msg.type === \"text\",\n    audio: (msg) => msg.type === \"audio\",\n  },\n  cases: {\n    text: showTextPopup,\n    audio: playAudio,\n    __: reportUnknownMessageTypeFx,\n  },\n});\n\nshowTextPopup.watch(({ value }) => {\n  console.log(\"новое сообщение:\", value);\n});\n\nmessageReceived({\n  type: \"text\",\n  value: \"Привет\",\n});\n// => новое сообщение: Привет\nmessageReceived({\n  type: \"image\",\n  imageUrl: \"...\",\n});\n// => неизвестное сообщение: image\n```\n\n----------------------------------------\n\nTITLE: Skip Void Formula\nDESCRIPTION: Formula to describe how to use the skipVoid parameter on combine\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/combine.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ncombine($a, $b, callback, { skipVoid: true });\n```\n\n----------------------------------------\n\nTITLE: Accessing Event Short Name (TypeScript)\nDESCRIPTION: This example shows how to access the `.shortName` property of an Effector event, which contains the name of the variable the event was declared at. It demonstrates that reassigning the event to another variable does not change the shortName.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst demo = createEvent();\n// demo.shortName === 'demo'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst another = demo;\n// another.shortName === 'demo'\n```\n\n----------------------------------------\n\nTITLE: Effector Split with Store Case\nDESCRIPTION: Demonstrates using `split` with a store case to select a unit based on the store's value. The `match` property is a store holding the case name, which determines where the `source` data is routed. Cases are defined as `first`, `second`, and optionally a default `__` case.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>,\n  // стор кейса\n  match: Store<'first' | 'second'>,\n  cases: {\n    first: Unit<T> | Unit<T>[],\n    second: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Effector Effect pending Shorthand\nDESCRIPTION: Shows how Effector's `pending` property simplifies manual store creation for tracking loading state.  It demonstrates the equivalent code of creating a store and updating it based on effect triggers and completion.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect, createStore } from \"effector\";\n\nconst fetchApiFx = createEffect();\n\n// now you can use fetchApiFx.pending instead\nconst $isLoading = createStore(false)\n  .on(fetchApiFx, () => true)\n  .on(fetchApiFx.done, () => false)\n  .on(fetchApiFx.fail, () => false);\n```\n\n----------------------------------------\n\nTITLE: Merging Events with `merge` in Effector\nDESCRIPTION: Demonstrates how to merge events using the `merge` function from effector. It shows how `merge` combines events of different types and events of the same type. The result is a new event that triggers when any of the input events trigger, carrying the payload of the triggering event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, merge } from \"effector\";\n\nconst firstEvent = createEvent<string>();\nconst secondEvent = createEvent<number>();\n\nconst merged = merge([firstEvent, secondEvent]);\n// Event<string | number>\n\n// You can also combine events with the same types\nconst buttonClicked = createEvent<MouseEvent>();\nconst linkClicked = createEvent<MouseEvent>();\n\nconst anyClick = merge([buttonClicked, linkClicked]);\n// Event<MouseEvent>\n```\n\n----------------------------------------\n\nTITLE: Declaring Event Type (TS)\nDESCRIPTION: This code declares the type of an `Event` in TypeScript. This is useful when a factory or library requires an event to subscribe to its updates. It is used to specify the type of data the event will carry.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst event: Event<T>;\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Effector React Providers\nDESCRIPTION: This example demonstrates the use of multiple `<Provider />` components in a React application. Each provider is given a separate `Scope`, allowing for parallel usage of components with different scopes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/Provider.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { fork } from \"effector\";\nimport { Provider } from \"effector-react\";\nimport { App } from \"@/app\";\n\nconst scopeA = fork();\nconst scopeB = fork();\n\nconst ParallelWidgets = () => (\n  <>\n    <Provider value={scopeA}>\n      <App />\n    </Provider>\n    <Provider value={scopeB}>\n      <App />\n    </Provider>\n  </>\n);\n\n```\n\n----------------------------------------\n\nTITLE: Using Effector React Provider with Scope\nDESCRIPTION: This code snippet demonstrates how to use the `<Provider />` component to provide a `Scope` to a React component. The `useUnit` hook within the `App` component will then interact with the provided `Scope`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/Provider.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createEvent, createStore, fork } from \"effector\";\nimport { useUnit, Provider } from \"effector-react\";\nimport { render } from \"react-dom\";\n\nconst buttonClicked = createEvent();\nconst $count = createStore(0);\n\n$count.on(buttonClicked, (counter) => counter + 1);\n\nconst App = () => {\n  const [count, handleClick] = useUnit([$count, buttonClicked]);\n\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => handleClick()}>increment</button>\n    </>\n  );\n};\n\nconst myScope = fork({\n  values: [[$count, 42]],\n});\n\nrender(\n  <Provider value={myScope}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\"),\n);\n\n```\n\n----------------------------------------\n\nTITLE: Debugging Effector Units with Patronum (TypeScript)\nDESCRIPTION: This example demonstrates how to use the `patronum/debug` utility to debug Effector stores, events, and effects. The `debug` function logs the values of the units whenever they are updated or triggered, providing valuable insights into the application's state and data flow.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect } from \"effector\";\nimport { debug } from \"patronum/debug\";\n\nconst event = createEvent();\nconst effect = createEffect().use((payload) => Promise.resolve(\"result\" + payload));\nconst $store = createStore(0)\n  .on(event, (state, value) => state + value)\n  .on(effect.done, (state) => state * 10);\n\ndebug($store, event, effect);\n\nevent(5);\neffect(\"demo\");\n\n// => [store] $store 1\n// => [event] event 5\n// => [store] $store 6\n// => [effect] effect demo\n// => [effect] effect.done {\"params\":\"demo\", \"result\": \"resultdemo\"}\n// => [store] $store 60\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Effector Computation Priority\nDESCRIPTION: This example demonstrates how effector prioritizes computations, especially when dealing with side effects. The `createEffect` function updates a global `count` variable, representing a side effect. The `fx.done.watch` function observes the completion of the effect and performs another side effect. The code illustrates how effector handles these side effects in a predictable order, ensuring that `count` is updated as expected.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/computation-priority.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nlet count = 0;\nconst fx = createEffect(() => {\n  // побочный эффект 1\n  count += 1;\n});\n\nfx.done.watch(() => {\n  // побочный эффект 1 уже выполнен\n  console.log(\"ожидаем, что count будет 1\", count === 1);\n  // побочный эффект 2\n  count += 1;\n});\n\nfx();\n// побочный эффект 1 уже выполнен\n// побочный эффект 2 также уже выполнен\n// это то, что мы ожидали\n// это эффект watchmen\nconsole.log(\"ожидаем, что count будет 2\", count === 2);\n// пример, который нарушает это соглашение: setState в react\n// который откладывает любой побочный эффект на долгое время после вызова setState\n```\n\n----------------------------------------\n\nTITLE: Defining Message Interface (Typescript)\nDESCRIPTION: Defines the structure of a message object with properties for id, author (containing id and name), text, and timestamp. This interface is used to strongly type message data within the application.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/shared/api/message.ts\ninterface Author {\n  id: string;\n  name: string;\n}\n\nexport interface Message {\n  id: string;\n  author: Author;\n  text: string;\n  timestamp: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Effector onCreateEffect Hook Example\nDESCRIPTION: This example demonstrates how to use the `onCreateEffect` hook to log a message to the console every time a new effect is created in the domain.  It creates a domain and then defines a callback function that logs a message when a new effect is created.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Domain.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createDomain } from \"effector\";\n\nconst domain = createDomain();\n\ndomain.onCreateEffect((effect) => {\n  console.log(\"new effect created\");\n});\n\nconst fooFx = domain.createEffect();\n// => new effect created\n\nconst barFx = domain.createEffect();\n// => new effect created\n```\n\n----------------------------------------\n\nTITLE: Using effector-solid with useUnit in a SolidJS component\nDESCRIPTION: This code demonstrates how to use effector-solid with the useUnit hook in a SolidJS component. It creates an event (inputText) and stores ($text, $size) using effector, then connects them to a SolidJS form using useUnit.  The form updates the stores when the input changes.\nSOURCE: https://github.com/effector/effector/blob/master/packages/effector-solid/README.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {createStore, combine, createEvent} from 'effector'\n\nimport {useUnit} from 'effector-solid'\n\nconst inputText = createEvent()\n\nconst $text = createStore('').on(inputText, (_, text) => text)\n\nconst $size = createStore(0).on(inputText, (_, text) => text.length)\n\nconst Form = () => {\n  const {\n    text,\n    size\n  } = useUnit({\n    size: $size,\n    text: $text\n  })\n\n  return (\n    <form>\n      <input\n        type=\"text\"\n        onInput={e => inputText(e.currentTarget.value)}\n        value={text()}\n      />\n      <p>Length: {size}</p>\n    </form>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Event to Store\nDESCRIPTION: This code snippet demonstrates how to connect events to the counter store. The `on` method of the store is used to subscribe to the `incremented` and `decremented` events. When these events are triggered, the store's value is updated accordingly.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// counter.js\nimport { createEvent, createStore } from \"effector\";\n\nconst $counter = createStore(0);\n\nconst incremented = createEvent();\nconst decremented = createEvent();\n\n$counter.on(incremented, (counter) => counter + 1);\n$counter.on(decremented, (counter) => counter - 1);\n\n// и вызовите событие в вашем приложении\nincremented();\n// counter увеличиться на 1\ndecemented();\n// counter уменьшится на -1\ndecemented();\n// counter уменьшится на -1\n```\n\n----------------------------------------\n\nTITLE: Extracting Effect Result with `EffectResult` in Effector\nDESCRIPTION: Demonstrates how to use `EffectResult` to extract the success result type of an Effector effect. This helps define types for the data returned by the effect on success.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, EffectResult } from \"effector\";\n\nconst fx = createEffect<\n  { id: string },\n  { name: string; isAdmin: boolean },\n  { statusText: string; status: number }\n>(() => ({ name: \"Alice\", isAdmin: false }));\n\ntype EffectResultType = EffectResult<typeof fx>;\n// {name: string; isAdmin: boolean}\n```\n\n----------------------------------------\n\nTITLE: Accessing SID of Unit Created by Custom Factory\nDESCRIPTION: This code snippet shows how to access the SID of a store created by a custom factory wrapped with `withFactory`. The SID is a combination of the factory's SID and the internal unit's SID, separated by a pipe character. This ensures a globally unique identifier for each store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\npersonOne.$name.sid; // gre24f|ffds2\npersonTwo.$name.sid; // lpefgd|ffds2\n```\n\n----------------------------------------\n\nTITLE: Creating and Subscribing to an Effector Event (JavaScript)\nDESCRIPTION: This JavaScript code snippet shows how to create an Effector event using `createEvent` and subscribe to it using `watch`. When the event is triggered, the provided callback function is executed. The `effector` library is required.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/core-concepts.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\n// Создаем событие\nconst formSubmitted = createEvent();\n\n// Подписываемся на событие\nformSubmitted.watch(() => console.log(\"Форма отправлена!\"));\n\nformSubmitted();\n\n// Вывод в консоль:\n// \"Форма отправлена!\"\n```\n\n----------------------------------------\n\nTITLE: Check if a value is a Store - Effector\nDESCRIPTION: This JavaScript snippet demonstrates how to use `is.store` to check if a given value is an Effector store. It creates a store, event, and effect, then uses `is.store` to determine their types.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/is.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain } from \"effector\";\n\nconst $store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\n\nis.store($store);\n// => true\n\nis.store(event);\n// => false\n\nis.store(fx);\n// => false\n\nis.store(createDomain());\n// => false\n\nis.store(fx.pending);\n// => true\n\nis.store(fx.done);\n// => false\n\nis.store($store.updates);\n// => false\n\nis.store(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: Effect .watch() subscription example\nDESCRIPTION: This example demonstrates how to subscribe to effect calls using the `.watch()` method. A watcher function is called each time the effect is triggered, receiving the effect's payload as an argument.  The watcher logs the payload to the console.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect((params) => params);\n\nfx.watch((params) => {\n  console.log(\"effect called with value\", params);\n});\n\nawait fx(10);\n// => effect called with value 10\n```\n\n----------------------------------------\n\nTITLE: allSettled with Store and Event (TypeScript)\nDESCRIPTION: Illustrates the usage of `allSettled` with both Effector Store and Event.  It forks two scopes, initializes a store, creates an event, and then uses `allSettled` to await the completion of operations involving the store and event in both scopes. The store's value is updated, and then the changes are watched in each scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/allSettled.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst scopeA = fork();\nconst scopeB = fork();\n\nconst $store = createStore(0);\nconst inc = createEvent<number>();\n\nawait allSettled($store, { scope: scopeA, params: 5 });\nawait allSettled($store, { scope: scopeB, params: -5 });\n\n$store.watch(console.log);\n\nawait allSettled(inc, { scope: scopeA, params: 2 }); // в консоль выведется 7\nawait allSettled(inc, { scope: scopeB, params: 2 }); // в консоль выведется -3\n```\n\n----------------------------------------\n\nTITLE: Effector restore with Shape example (JavaScript)\nDESCRIPTION: This example demonstrates using `restore` to create multiple stores from an object. Each property in the object becomes a separate store with its initial value.  It requires `restore` from effector.  Each store's value is output to the console on initialization.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/restore.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { restore } from \"effector\";\n\nconst { foo: $foo, bar: $bar } = restore({\n  foo: \"foo\",\n  bar: 0,\n});\n\n$foo.watch((foo) => {\n  console.log(\"foo\", foo);\n});\n// => foo 'foo'\n$bar.watch((bar) => {\n  console.log(\"bar\", bar);\n});\n// => bar 0\n```\n\n----------------------------------------\n\nTITLE: Triggering Effect on Event\nDESCRIPTION: This code snippet demonstrates how to trigger an Effector effect when an event is fired. It uses the `sample` function to connect the event to the effect's execution.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/work-with-async.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, sample } from \"effector\";\n\nconst userLoginFx = createEffect(() => {\n  // какая-то логика\n});\n\n// Событие для загрузки данных\nconst formSubmitted = createEvent();\n\n// Связываем событие с эффектом\nsample({\n  clock: formSubmitted, // Когда сработает\n  target: userLoginFx, // Запусти это\n});\n\n// где-то в приложении\nformSubmitted();\n```\n\n----------------------------------------\n\nTITLE: Using useStore in a Vue Component - JavaScript\nDESCRIPTION: This example shows how to use the `useStore` hook within the `setup` function of a Vue component to subscribe to an Effector store and access its value. It also showcases how to integrate with `createStore` and `createApi` from effector to manage the store's state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useStore.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createApi } from \"effector\";\nimport { useStore } from \"effector-vue/composition\";\n\nconst $counter = createStore(0);\n\nconst { incremented, decremented } = createApi($counter, {\n  incremented: (count) => count + 1,\n  decremented: (count) => count - 1,\n});\n\nexport default {\n  setup() {\n    const counter = useStore($counter);\n\n    return {\n      counter,\n      incremented,\n      decremented,\n    };\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Updating an Effector Store (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates how to create an Effector store using `createStore` and update it when an event is triggered using the `on` method.  The `effector` library is required. The store holds an array of objects and is updated by adding a new object to the array when the `superAdded` event occurs.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/core-concepts.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\n// Создаем событие\nconst superAdded = createEvent();\n\n// Создаем стор\nconst $supers = createStore([\n  {\n    name: \"Человек-паук\",\n    role: \"hero\",\n  },\n  {\n    name: \"Зеленый гоблин\",\n    role: \"villain\",\n  },\n]);\n\n// Обновляем стор при срабатывании события\n$supers.on(superAdded, (supers, newSuper) => [...supers, newSuper]);\n\n// Вызываем событие\nsuperAdded({\n  name: \"Носорог\",\n  role: \"villain\",\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Source Store and mapParams\nDESCRIPTION: Creates an effect that reads values from a `source` store, passes them along with new parameters to a `mapParams` function, and then calls the `effect` with the result. If `mapParams` throws an exception, the attached effect fails.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst attachedFx = attach({\n  source,\n  mapParams,\n  effect: originalFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Split with Default Case in Effector\nDESCRIPTION: This example showcases how to use the default case (`__`) in the `split` method. If none of the specified conditions are met, the default case will be executed. It utilizes `createEvent` and `split` from Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/flow-split.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { createEvent, split } from \"effector\";\n\nconst updateUserStatus = createEvent();\n\nconst { activeUserUpdated, idleUserUpdated, inactiveUserUpdated, __ } = split(updateUserStatus, {\n  activeUserUpdated: (userStatus) => userStatus === \"active\",\n  idleUserUpdated: (userStatus) => userStatus === \"idle\",\n  inactiveUserUpdated: (userStatus) => userStatus === \"inactive\",\n});\n\n__.watch((defaultStatus) => console.log(\"default case with status:\", defaultStatus));\nactiveUserUpdated.watch(() => console.log(\"active user\"));\n\nupdateUserStatus(\"whatever\");\nupdateUserStatus(\"active\");\nupdateUserStatus(\"default case\");\n\n// Вывод в консоль:\n// default case with status: whatever\n// active user\n// default case with status: default case\n```\n\n----------------------------------------\n\nTITLE: Testing Event Triggering with Effector\nDESCRIPTION: This code snippet demonstrates how to test if an event is triggered using `createWatch` within a forked scope. It creates a mock function using `jest.fn()` and attaches it to the `userUpdated` event within a specific scope. After triggering the event, it asserts that the mock function was called once.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/testing.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createWatch, fork } from \"effector\";\nimport { userUpdated } from \"../\";\n\ntest(\"should handle user update with scope\", async () => {\n  const scope = fork();\n  const fn = jest.fn();\n\n  // Создаем watcher в конкретном scope\n  const unwatch = createWatch({\n    unit: userUpdated,\n    fn,\n    scope,\n  });\n\n  // Запускаем событие в scope\n  await allSettled(userUpdated, {\n    scope,\n  });\n\n  expect(fn).toHaveBeenCalledTimes(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Session Interface in TypeScript\nDESCRIPTION: Defines the `Session` interface representing user session data, which includes the user ID and name.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// File: /src/shared/api/session.ts\n// It is called session because it describes current user session, not the User at all.\nexport interface Session {\n  id: string;\n  name: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Create Effector Event from RxJS Observable\nDESCRIPTION: Creates an effector Event that emits values from an RxJS Observable. It utilizes `fromObservable` to convert an interval Observable emitting numbers every second into an effector Event. The event is then watched to log the emitted values.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/fromObservable.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { interval } from \"rxjs\";\nimport { fromObservable } from \"effector\";\n\n//emit value in sequence every 1 second\nconst source = interval(1000);\n\nconst event = fromObservable(source);\n\n//output: 0,1,2,3,4,5....\nevent.watch(console.log);\n```\n\n----------------------------------------\n\nTITLE: Prepending to sendAnalytics Function (Effector)\nDESCRIPTION: Demonstrates how to use `.prepend()` to wrap a function with an imperfect API.  The example transforms the input `item` before passing it to `sendAnalytics`. This is useful for adapting existing functions to fit the expected input format of `sendAnalytics`. Requires `sendAnalytics` function to be defined.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sendAnalytics } from \"./analytics\";\n\nexport const reportClick = sendAnalytics.prepend((item: string) => {\n  return { type: \"click\", container: { items: [arg] } };\n});\n\nreportClick(\"example\");\n// reportClick сработал \"example\"\n// sendAnalytics сработал с { type: \"click\", container: { items: [\"example\"] } }\n```\n\n----------------------------------------\n\nTITLE: Initializing Store and Event in Effector\nDESCRIPTION: This code snippet initializes a store `$connectStatus` with an initial value of \"close\" and creates an event `connectEv`. It then uses `sample` to update the store's value when the event is triggered. This establishes a basic reactive data flow using Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/nextjs/scope-bind.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst $connectStatus = createStore(\"close\");\nconst connectEv = createEvent();\n\nsample({\n  clock: connectEv,\n  targt: $connectStatus,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Timer Effects and Store\nDESCRIPTION: This code defines effects for starting and stopping the timer (`startFx`, `stopFx`). It also defines a store `$timerId` to hold the interval ID for clearing the interval later.  It sets up the timer logic to update a counter every second using `setInterval` and `clearInterval`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/advanced/work-with-scope.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst TIMEOUT = 1_000;\n\nconst timerStopped = createEvent();\nconst timerReset = createEvent();\nconst timerStarted = createEvent();\nconst tick = createEvent();\n\n// запуск таймера\nconst startFx = createEffect(() => {\n  const intervalId = setInterval(() => {\n    // здесь вся проблема\n    tick();\n  }, TIMEOUT);\n\n  return intervalId;\n});\n\n// остановка таймера\nconst stopFx = createEffect((timerId: number) => {\n  clearInterval(timerId);\n});\n\n// id таймера для очистки\nconst $timerId = createStore<null | number>(null)\n  .on(startFx.doneData, (_, timerId) => timerId)\n  .on(stopFx.finally, () => null);\n\nconst $timerCount = createStore(0)\n  .on(tick, (seconds) => seconds + 1)\n  .reset(timerReset);\n\n// логика запуска таймера\nsample({\n  clock: timerStarted,\n  filter: $timerId.map((timerId) => !timerId),\n  target: startFx,\n});\n\n// логика остановки таймера\nsample({\n  clock: timerStopped,\n  source: $timerId,\n  filter: Boolean,\n  target: stopFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Merging a store and an event with effector - JavaScript\nDESCRIPTION: Shows how to merge a store (`$foo`) and an event (`otherEvent`) into a single merged unit. The `merged` event is triggered by either an update to the store or when the other event is called, and its payload is then logged. This illustrates the ability to combine different unit types into one.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/merge.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore, merge } from \"effector\";\n\nconst setFoo = createEvent();\nconst otherEvent = createEvent();\n\nconst $foo = createStore(0).on(setFoo, (_, v) => v);\nconst merged = merge([$foo, otherEvent]);\n\nmerged.watch((v) => console.log(`merged event payload: ${v}`));\n\nsetFoo(999);\n// => merged event payload: 999\n\notherEvent(\"bar\");\n// => merged event payload: bar\n```\n\n----------------------------------------\n\nTITLE: Inspecting the Effector Graph\nDESCRIPTION: Demonstrates how to use `inspectGraph` to track the declarations of Effector units, factories, and regions. It logs the kind and name of each declared unit, which enables you to understand the structure of your Effector application.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/inspect.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { inspectGraph, type Declaration } from \"effector/inspect\";\n\nfunction printDeclaration(d: Declaration) {\n  console.log(`${d.kind} ${d.name}`);\n}\n\ninspectGraph({\n  fn: (d) => {\n    printDeclaration(d);\n  },\n});\n\nconst $count = createStore(0);\n// logs \"store $count\" to console\n```\n\n----------------------------------------\n\nTITLE: Basic useGate Usage Example (JSX)\nDESCRIPTION: Demonstrates a basic usage of `useGate` within a Solid.js component. It creates a `Gate`, uses `useGate` to pass props to it, and sets up a watcher on the `Gate`'s state to log match data.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useGate.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createGate, useGate } from \"effector-solid\";\nimport { Route, Routes } from \"solid-app-router\";\n\nconst PageGate = createGate(\"page\");\n\nconst Home = (props) => {\n  useGate(PageGate, props);\n  return <section>Home</section>;\n};\n\nPageGate.state.watch(({ match }) => {\n  console.log(match);\n});\n\nconst App = () => (\n  <Routes>\n    <Route element={<Home />} />\n  </Routes>\n);\n```\n\n----------------------------------------\n\nTITLE: Type definition of hydrate\nDESCRIPTION: Defines the type signature of the `hydrate` function, outlining the expected arguments: a `domainOrScope` (either a Domain or Scope) and a `values` object (either a Map of Stores to values, or an object mapping store sids to values). The function returns `void`, as it modifies the state of the stores within the provided domain or scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/hydrate.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nhydrate(domainOrScope: Domain | Scope, { values: Map<Store<any>, any> | {[sid: string]: any} }): void\n```\n\n----------------------------------------\n\nTITLE: Inspecting Events and Stores\nDESCRIPTION: Demonstrates how to use `inspect` to log messages whenever an event is triggered or a store is updated.  It captures the name, value, and kind of computation using the `Message` type from effector/inspect. This example shows out-of-scope tracking.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/inspect.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inspect, type Message } from \"effector/inspect\";\n\nimport { someEvent } from \"./app-code\";\n\nfunction logInspectMessage(m: Message) {\n  const { name, value, kind } = m;\n\n  return console.log(`[${kind}] ${name} ${value}`);\n}\n\ninspect({\n  fn: (m) => {\n    logInspectMessage(m);\n  },\n});\n\nsomeEvent(42);\n// will log something like\n// [event] someEvent 42\n// [on] 42\n// [store] $count 1337\n// ☝️ let's say that reducer adds 1295 to provided number\n//\n// and so on, any triggers\n```\n\n----------------------------------------\n\nTITLE: useUnit with Shape - TypeScript\nDESCRIPTION: Defines the TypeScript signatures for `useUnit` when used with a shape (an object or array) of Effector Events, Effects, or Stores. It illustrates how to bind multiple units to the component and returns an object or array containing accessors for stores and functions for events/effects.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useUnit.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nuseUnit({ a: Store<A>, b: Event<B>, ... }): { a: Accessor<A>, b: (payload: B) => B; ... }\n\nuseUnit([Store<A>, Event<B>, ... ]): [Accessor<A>, (payload: B) => B, ... ]\n```\n\n----------------------------------------\n\nTITLE: Creating Event Hook Type Definition\nDESCRIPTION: Illustrates the type definition for `onCreateEvent`, showing that it accepts a function that takes an `Event` as input. This hook allows executing custom logic whenever a new event is created within the domain.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Domain.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\ndomain.onCreateEvent((event) => {});\n```\n\n----------------------------------------\n\nTITLE: Merging Events in Effector (TypeScript)\nDESCRIPTION: This snippet shows how to merge multiple events into a single event using Effector's `merge` function. It demonstrates merging events with different types, resulting in a union type, and merging events with the same type, resulting in that type.  The snippet also highlights the use of generics to enforce type constraints during the merge operation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, merge } from \"effector\";\n\nconst firstEvent = createEvent<string>();\nconst secondEvent = createEvent<number>();\n\nconst merged = merge([firstEvent, secondEvent]);\n// Event<string | number>\n\n// Можно также объединять события с одинаковыми типами\nconst buttonClicked = createEvent<MouseEvent>();\nconst linkClicked = createEvent<MouseEvent>();\n\nconst anyClick = merge([buttonClicked, linkClicked]);\n// Event<MouseEvent>\n```\n\n----------------------------------------\n\nTITLE: Using useUnit with Shapes (Objects/Arrays)\nDESCRIPTION: This example demonstrates using `useUnit` with an object or array containing stores and/or events. It requires `effector`, `effector-react`, and `react-dom`. It retrieves the store value directly and wraps events with scope-bound functions for triggering them.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useUnit.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore, createEvent, fork } from \"effector\";\nimport { useUnit, Provider } from \"effector-react\";\n\nconst inc = createEvent();\nconst dec = createEvent();\n\nconst $count = createStore(0)\n  .on(inc, (x) => x + 1)\n  .on(dec, (x) => x - 1);\n\nconst App = () => {\n  const count = useUnit($count);\n  const handler = useUnit({ inc, dec });\n  // or\n  const [a, b] = useUnit([inc, dec]);\n\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => handler.inc()}>increment</button>\n      <button onClick={() => handler.dec()}>decrement</button>\n    </>\n  );\n};\n\nconst scope = fork();\n\nrender(\n  () => (\n    <Provider value={scope}>\n      <App />\n    </Provider>\n  ),\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Session Interface (Typescript)\nDESCRIPTION: Defines the structure of a user session object, containing the id and name of user.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/shared/api/session.ts\n// Это называется сессией, потому что описывает текущую сессию пользователя, а не Пользователя в целом.\nexport interface Session {\n  id: string;\n  name: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Source Store (TypeScript)\nDESCRIPTION: Shows how to attach an effect to a store, passing the store's value as a parameter to the effect.  The attached effect does not require any parameters, as it automatically uses the data from the store. Types of the store in `source` and parameters `effect` must match.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { createEffect, createStore, attach } from \"effector\";\n\nconst requestPageFx = createEffect<{ page: number; size: number }, string[]>(async ({ page, size }) => {\n  console.log(\"Запрошено\", page);\n  return page * size;\n});\n\nconst $page = createStore(1);\nconst $size = createStore(20);\n\nconst requestNextPageFx = attach({\n  source: { page: $page, size: $size },\n  effect: requestPageFx,\n});\n\n$page.on(requestNextPageFx.done, (page) => page + 1);\n\nrequestPageFx.doneData.watch((position) => console.log(\"requestPageFx.doneData\", position));\n\nawait requestNextPageFx();\n// => Запрошено 1\n// => requestPageFx.doneData 20\n\nawait requestNextPageFx();\n// => Запрошено 2\n// => requestPageFx.doneData 40\n\nawait requestNextPageFx();\n// => Запрошено 3\n// => requestPageFx.doneData 60\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with React\nDESCRIPTION: This command installs the `effector` and `effector-react` packages using npm. `effector-react` provides utilities for using Effector with React components.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-react\n```\n\n----------------------------------------\n\nTITLE: Vite Configuration for Polyfills (JavaScript)\nDESCRIPTION: Configures Vite to include necessary polyfills for older browsers when using `effector-react/compat`. This example demonstrates how to use the `@vitejs/plugin-legacy` plugin to automatically add polyfills for Promise, Object.assign, Array.prototype.flat, Map, and Set.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/module/сompat.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from \"vite\";\nimport legacy from \"@vitejs/plugin-legacy\";\n\nexport default defineConfig({\n  plugins: [\n    legacy({\n      polyfills: [\"es.promise\", \"es.object.assign\", \"es.array.flat\", \"es.map\", \"es.set\"],\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Watching failData on Effect\nDESCRIPTION: This code demonstrates how to use the `failData` property of an effector effect to observe errors. It creates an effect that throws an error and then watches the `failData` event to log the error message.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect(async (value) => {\n  throw Error(value - 1);\n});\n\nfx.failData.watch((error) => {\n  console.log(`Вызов завершился с ошибкой ${error.message}`);\n});\n\nfx(2);\n// => Вызов завершился с ошибкой 1\n```\n\n----------------------------------------\n\nTITLE: Inspect with Tracing Enabled\nDESCRIPTION: Explains how to enable tracing in the `inspect` configuration using `trace: true`. This provides a history of previous computations that led to the current one, aiding in debugging the cause of specific events.  It focuses on tracing updates to a specific store (`$count`) and logs traced messages in reverse chronological order.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/inspect.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fork, allSettled } from \"effector\";\nimport { inspect, type Message } from \"effector/inspect\";\n\nimport { someEvent, $count } from \"./app-code\";\n\nfunction logInspectMessage(m: Message) {\n  const { name, value, kind } = m;\n\n  return console.log(`[${kind}] ${name} ${value}`);\n}\n\nconst myScope = fork();\n\ninspect({\n  scope: myScope,\n  trace: true, // <- явная настройка\n  fn: (m) => {\n    if (m.kind === \"store\" && m.sid === $count.sid) {\n      m.trace.forEach((tracedMessage) => {\n        logInspectMessage(tracedMessage);\n        // ☝️ здесь мы логируем трассировку обновления конкретного стора\n      });\n    }\n  },\n});\n\nallSettled(someEvent, { scope: myScope, params: 42 });\n// [on] 42\n// [event] someEvent 42\n// ☝️ трассировки предоставляются в обратном порядке, так как мы смотрим назад во времени\n```\n\n----------------------------------------\n\nTITLE: Effector Effect Type Extraction\nDESCRIPTION: Demonstrates extracting types for Params, Result, and Error from an Effector Effect using `EffectParams`, `EffectResult`, and `EffectError` utility types.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type EffectParams, type EffectResult, type EffectError } from \"effector\";\n\nconst effect: Effect<Params, Done, Fail>;\ntype Params = EffectParams<typeof effect>;\n\nconst effect: Effect<Params, Done, Fail>;\ntype Done = EffectResult<typeof effect>;\n\nconst effect: Effect<Params, Done, Fail>;\ntype Fail = EffectError<typeof effect>;\n```\n\n----------------------------------------\n\nTITLE: Split with object-based matching\nDESCRIPTION: This demonstrates using the `split` function with direct object based matching.  The `split` function creates a new object with keys defined in `match`, each key being an event. A default event `__` is also included. Messages are routed to events based on match conditions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, split } from \"effector\";\n\nconst message = createEvent();\n\nconst messageByAuthor = split(message, {\n  bob: ({ user }) => user === \"bob\",\n  alice: ({ user }) => user === \"alice\",\n});\nmessageByAuthor.bob.watch(({ text }) => {\n  console.log(\"[bob]: \", text);\n});\nmessageByAuthor.alice.watch(({ text }) => {\n  console.log(\"[alice]: \", text);\n});\n\nmessage({ user: \"bob\", text: \"Hello\" });\n// => [bob]: Hello\nmessage({ user: \"alice\", text: \"Hi bob\" });\n// => [alice]: Hi bob\n\n/* default case, triggered if no one condition met */\nconst { __: guest } = messageByAuthor;\nguest.watch(({ text }) => {\n  console.log(\"[guest]: \", text);\n});\nmessage({ user: \"unregistered\", text: \"hi\" });\n// => [guest]: hi\n```\n\n----------------------------------------\n\nTITLE: Handling Data Loading Results\nDESCRIPTION: This snippet demonstrates how to update the Effector stores with the data loaded from the API. It uses the `.doneData` event of the effects to update the `$messages` and `$session` stores. If data loading is successful, the corresponding stores are updated with the new data.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\n// `.doneData` это сокращение для `.done`, поскольку `.done` returns `{ params, result }`\n// Постарайтесь не называть свои аргументы как `state` или `payload`\n// Используйте явные имена для содержимого\n$messages.on(messageApi.messagesLoadFx.doneData, (_, messages) => messages);\n\n$session.on(sessionApi.sessionLoadFx.doneData, (_, session) => session);\n```\n\n----------------------------------------\n\nTITLE: Using Custom Factory\nDESCRIPTION: Example of using a custom factory function to create stores with unique SIDs.  These sid's will be handled independently by serialize.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_11\n\nLANGUAGE: js\nCODE:\n```\n// ./src/statuses.js\nimport { createEffectStatus } from \"./createEffectStatus\";\nimport { fetchUserFx, fetchFriendsFx } from \"./api\";\n\nexport const $fetchUserStatus = createEffectStatus(fetchUserFx);\nexport const $fetchFriendsStatus = createEffectStatus(fetchFriendsFx);\n```\n\n----------------------------------------\n\nTITLE: Store .watch() Example - Javascript\nDESCRIPTION: Subscribes to store updates using the `.watch()` method. The watcher function is called whenever the store's value changes. This example demonstrates logging the current value of the store to the console whenever the `add` event is triggered and the store is updated.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst add = createEvent();\nconst $store = createStore(0).on(add, (state, payload) => state + payload);\n\n$store.watch((value) => console.log(`current value: ${value}`));\nadd(4);\nadd(3);\n```\n\n----------------------------------------\n\nTITLE: Creating Timer Count Store\nDESCRIPTION: This code creates a store called `$timerCount` that holds the current count of the timer.  It increments the count on the `tick` event and resets to 0 on the `timerReset` event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/advanced/work-with-scope.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst tick = createEvent();\n\nexport const $timerCount = createStore(0)\n  .on(tick, (seconds) => seconds + 1)\n  .reset(timerReset);\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in Computations\nDESCRIPTION: Shows how to use `inspect` to catch and handle errors that occur during Effector computations. This allows you to log errors and take appropriate actions when exceptions occur in pure functions, which are not allowed by Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/inspect.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninspect({\n  fn: (m) => {\n    if (m.type === \"error\") {\n      // do something about it\n      console.log(`${m.kind} ${m.name} computation has failed with ${m.error}`);\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect to a `domain`\nDESCRIPTION: This snippet demonstrates attaching an effect to a specified domain. Attaching to a domain organizes related effects and allows for centralized management.  This parameter is only applicable when the `effect` parameter is a plain function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createDomain, createStore, attach } from \"effector\";\n\nconst reportErrors = createDomain();\nconst $counter = createStore(0);\n\nconst attachedFx = attach({\n  domain: reportErrors,\n  source: $counter,\n  async effect(counter) {\n    // ...\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing createDomain from effector (TypeScript)\nDESCRIPTION: This snippet imports the `createDomain` function and the `Domain` type from the effector library.  This allows you to create and type domains within your application. `Domain` type provides type definition for domain objects.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createDomain.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createDomain, type Domain } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Serializing Single Store State (Redux)\nDESCRIPTION: Demonstrates how to serialize and deserialize the state of a single store using a hypothetical `single-store-state-manager`. The server serializes the entire store, and the client parses it.  This approach works because the single store inherently enforces unique names for each part of the state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// server.ts\nimport { createStore } from \"single-store-state-manager\";\n\nfunction handlerRequest() {\n  const store = createStore({ initialValue: null });\n\n  return {\n    // It is possible to just serialize the whole store\n    state: JSON.stringify(store.getState()),\n  };\n}\n\n// client.ts\nimport { createStore } from \"single-store-state-manager\";\n\n// Let's assume that server put the state into the HTML\nconst serverState = readServerStateFromWindow();\n\nconst store = createStore({\n  // Just parse the whole state and use it as client state\n  initialValue: JSON.parse(serverState),\n});\n```\n\n----------------------------------------\n\nTITLE: scopeBind Event Usage with Effector\nDESCRIPTION: This code snippet showcases the basic usage of `scopeBind` to bind an Effector event to a scope. It defines a store `$history`, an event `changeLocation`, and uses `scopeBind` to create a function `locationUpdate` that triggers `changeLocation` within a history listener callback, ensuring the event is properly associated with the Effector scope.  This is important when dealing with asynchronous operations like `history.listen`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/scopeBind.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, attach, scopeBind } from \"effector\";\n\nconst $history = createStore(history);\nconst initHistory = createEvent();\nconst changeLocation = createEvent<string>();\n\nconst installHistoryFx = attach({\n  source: $history,\n  effect: (history) => {\n    const locationUpdate = scopeBind(changeLocation);\n\n    history.listen((location) => {\n      locationUpdate(location);\n    });\n  },\n});\n\nsample({\n  clock: initHistory,\n  target: installHistoryFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Starting the server\nDESCRIPTION: This snippet describes how to start the server using yarn. It executes the start script defined in the project's package.json file. This command is used to run the application in a server environment, enabling server-side rendering.\nSOURCE: https://github.com/effector/effector/blob/master/examples/react-ssr/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Get Current Store State with `.getState()` (JavaScript)\nDESCRIPTION: Retrieves the current state of a store using the `.getState()` method.  The example demonstrates how to access and log the current value of the `$number` store after updates.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst add = createEvent();\n\nconst $number = createStore(0).on(add, (state, data) => state + data);\n\nadd(2);\nadd(3);\n\nconsole.log($number.getState());\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Stores in Effector (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates how to create derived stores using the `map` method of an Effector store. Derived stores depend on the original store and automatically update when the original store changes, showcasing Effector's reactivity.  The `effector` library is required.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/core-concepts.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\n// Создаем событие\nconst superAdded = createEvent();\n\n// Создаем стор\nconst $supers = createStore([\n  {\n    name: \"Человек-паук\",\n    role: \"hero\",\n  },\n  {\n    name: \"Зеленый гоблин\",\n    role: \"villain\",\n  },\n]);\n\n// Создали производные сторы, которые зависят от $supers\nconst $superHeroes = $supers.map((supers) => supers.filter((sup) => sup.role === \"hero\"));\nconst $superVillains = $supers.map((supers) => supers.filter((sup) => sup.role === \"villain\"));\n\n// Обновляем стор при срабатывании события\n$supers.on(superAdded, (supers, newSuper) => [...supers, newSuper]);\n\n// Добавляем супера\nsuperAdded({\n  name: \"Носорог\",\n  role: \"villain\",\n});\n```\n\n----------------------------------------\n\nTITLE: Create effect with nested effects\nDESCRIPTION: Creates an Effector effect that calls other effects sequentially. This illustrates the correct way to handle nested effect calls, ensuring that the context is maintained throughout the execution.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Scope.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst authUserFx = createEffect();\nconst sendMessageFx = createEffect();\n\nconst sendWithAuthFx = createEffect(async () => {\n  await authUserFx();\n  await delayFx();\n  await sendMessageFx();\n});\n```\n\n----------------------------------------\n\nTITLE: Handling WebSocket Message Validation Errors - TypeScript\nDESCRIPTION: This snippet demonstrates how to handle validation errors when parsing WebSocket messages. It creates an event `validationError` that is triggered when the `parseFx` effect fails to parse or validate a message. This allows you to handle invalid messages gracefully and prevent errors in your application. Dependencies: effector, zod.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/websocket-integration.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst validationError = createEvent<Error>();\n\n// Если парсинг не удался — обрабатываем ошибку\nsample({\n  clock: parseFx.failData,\n  target: validationError,\n});\n```\n\n----------------------------------------\n\nTITLE: Mapping Event Payload (TS)\nDESCRIPTION: This code demonstrates how to use the `.map()` method to create a new event that transforms the original event's payload. The example shows converting a number to a string. It imports `createEvent` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst first = createEvent<number>();\n// first: Event<number>\n\nconst second = first.map((count) => count.toString());\n// second: Event<string>\n```\n\n----------------------------------------\n\nTITLE: Using Store Directly with Effector and Vue\nDESCRIPTION: This code snippet demonstrates how to directly assign an Effector store to the `effector` option in a Vue component. It imports a `counter` store and assigns it to the `effector` property. This makes the store's value available in the template under the name `state`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/ComponentOptions.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { counter } from \"./stores\";\n\nnew Vue({\n  effector: counter, // would create `state` in template\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering Gate as Component in React\nDESCRIPTION: This demonstrates how to render a Gate component, passing the history object as a prop. This facilitates managing component state and conditional rendering based on the component's mounted/unmounted status.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/Gate.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n<Gate history={history} />\n```\n\n----------------------------------------\n\nTITLE: Create named effect (JavaScript)\nDESCRIPTION: Creates an effect `fetchUserReposFx` with a specified name using the config object notation in `createEffect`. It defines the handler function within the config object. It showcases assigning a descriptive name to an effect for debugging and monitoring purposes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createEffect.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect({\n  name: \"fetch user repositories\",\n  async handler({ name }) {\n    const url = `https://api.github.com/users/${name}/repos`;\n    const req = await fetch(url);\n    return req.json();\n  },\n});\n\nawait fetchUserReposFx({ name: \"zerobias\" });\n```\n\n----------------------------------------\n\nTITLE: withFactory Implementation\nDESCRIPTION: Provides a simplified implementation of the `withFactory` helper function. This function sets a global `sid` before calling the factory function and resets it afterward. This allows the Effector creator functions to access the global `sid` and append it to the unit's `sid`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nlet globalSid = null;\n\nfunction withFactory({ sid, fn }) {\n  globalSid = sid;\n\n  const result = fn();\n\n  globalSid = null;\n\n  return result;\n}\n\nfunction createStore(initialValue, { sid }) {\n  if (globalSid) {\n    sid = `${globalSid}|${sid}`;\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Effect .fail event handling\nDESCRIPTION: This example shows how to subscribe to the `.fail` event of an Effect. The `.fail` event is triggered when the effect's handler is rejected or throws an error. The example logs the parameters passed to the effect and the error message.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect(async (value) => {\n  throw Error(value - 1);\n});\n\nfx.fail.watch(({ params, error }) => {\n  console.log(\"Call with params\", params, \"rejected with error\", error.message);\n});\n\nfx(2);\n// => Call with params 2 rejected with error 1\n```\n\n----------------------------------------\n\nTITLE: Session Effects (Typescript)\nDESCRIPTION: Defines Effector effects for managing user sessions. `sessionLoadFx` loads the session from localStorage, `sessionDeleteFx` removes it, and `sessionCreateFx` creates a new session. The explicit type definition for `sessionCreateFx` ensures type safety.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/shared/api/session.ts\nconst LocalStorageKey = \"effector-example-session\";\n\n// Обратите внимание, что в этом случае требуется явное определение типов, поскольку `JSON.parse()` возвращает `any`\nexport const sessionLoadFx = createEffect<void, Session | null>(async () => {\n  const source = localStorage.getItem(LocalStorageKey);\n  await wait();\n  if (!source) {\n    return null;\n  }\n  return JSON.parse(source);\n});\n\n// По умолчанияю, если нет аргументов, не предоставлены явные аргументы типа и нет оператора `return`,\n// эффект будет иметь тип: `Effect<void, void, Error>`\nexport const sessionDeleteFx = createEffect(async () => {\n  localStorage.removeItem(LocalStorageKey);\n  await wait();\n});\n\n// Взгляните на тип переменной `sessionCreateFx`.\n// Там будет `Effect<void, Session, Error>` потому что TypeScript может вывести тип из переменной `session`\nexport const sessionCreateFx = createEffect(async () => {\n  // Я явно установил тип для следующей переменной, это позволит TypeScript помочь мне\n  // Если я забуду установить свойство, то я увижу ошибку в месте определения\n  // Это также позволяет IDE автоматически дополнять и завершать имена свойств\n  const session: Session = {\n    id: createOid(),\n    name: createName(),\n  };\n  localStorage.setItem(LocalStorageKey, JSON.stringify(session));\n  return session;\n});\n```\n\n----------------------------------------\n\nTITLE: Validating Effector Domain with `is.domain` in JavaScript\nDESCRIPTION: This snippet demonstrates how to use `is.domain` to check if a given value is an Effector domain. It imports necessary modules from Effector and creates a store, event, and effect for testing purposes. The snippet then calls `is.domain` with different values and logs the results to the console, showing examples of when it returns true or false.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/is.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain } from \"effector\";\n\nconst store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\n\nis.domain(store);\n// => false\n\nis.domain(event);\n// => false\n\nis.domain(fx);\n// => false\n\nis.domain(createDomain());\n// => true\n\nis.domain(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: allSettled Usage in Tests\nDESCRIPTION: Illustrates how to use `allSettled` in a test environment with Effector. This example involves creating an event, sampling it to trigger logic, binding it to a scope, simulating an external source update, awaiting all settled computations, and asserting the expected outcome. It uses `createEvent`, `sample`, `fork`, `scopeBind`, and `allSettled` from the Effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/allSettled.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {createEvent, sample, fork, scopeBind, allSettled} from 'effector'\n\ntest('integration with externalSource', async () => {\n  const scope = fork()\n\n  const updated = createEvent()\n\n  sample({\n    clock: updated,\n    target: someOtherLogicStart,\n  })\n\n  // 1. Subscribe event to external source\n  const externalUpdated = scopeBind(updated, {scope})\n  externalSource.listen(() => externalUpdates())\n\n  // 2. Trigger update of external source\n  externalSource.trigger()\n\n  // 3. Wait for all triggered computations in effector's scope, even though these were not triggered by effector itself\n  await allSettled(scope)\n\n  // 4. Check anything as usual\n  expect(...).toBe(...)\n})\n```\n\n----------------------------------------\n\nTITLE: Incorrect Imperative Effect Calls in Effector (Typescript)\nDESCRIPTION: This snippet illustrates an anti-pattern: calling events or effects imperatively inside other effects. It directly calls `setUser`, `redirectFx`, and `showNotification` within `loginFx`. This approach reduces testability and makes the data flow harder to track.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginFx = createEffect(async (params) => {\n  const user = await api.login(params);\n\n  // imperative calls\n  setUser(user);\n  redirectFx(\"/dashboard\");\n  showNotification(\"Welcome!\");\n\n  return user;\n});\n```\n\n----------------------------------------\n\nTITLE: Observing Event Triggers in Effector (JavaScript)\nDESCRIPTION: This code shows how to use the `watch` method to observe when an Effector event is triggered. It defines an event `sayHi` and then attaches a watcher function that logs a message to the console whenever the event is called. It also demonstrates how to unsubscribe the watcher.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst sayHi = createEvent();\nconst unwatch = sayHi.watch((name) => console.log(`${name}, hi there!`));\n\nsayHi(\"Peter\"); // => Peter, hi there!\nunwatch();\n\nsayHi(\"Drew\"); // => nothing happened\n```\n\n----------------------------------------\n\nTITLE: Deleting Message Event\nDESCRIPTION: This snippet shows how to trigger the message deletion effect (messageApi.messageDeleteFx) when the messageDeleteClicked event is fired. It uses Effector's `sample` function to connect the event to the effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\nsample({\n  clock: messageDeleteClicked,\n  target: messageApi.messageDeleteFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Event creation with type definition\nDESCRIPTION: Creates two Effector events, one with a number type and another without (void). This illustrates how to create events with and without expected arguments.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, Event } from \"effector\";\n\nconst someHappened = createEvent<number>();\n// someHappened: EventCallable<number>\nsomeHappened(1);\n\nconst anotherHappened = createEvent();\n// anotherHappened: EventCallable<void>\nanotherHappened();\n```\n\n----------------------------------------\n\nTITLE: useList Full Form Definition\nDESCRIPTION: Defines the type signature for the full form of the useList hook. It accepts a store, and a configuration object containing keys, a render function, and an optional key extraction function. The keys array allows the React component to re-render only when dependencies have changed.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useList.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useList(\n  store: Store<T[]>,\n  config: {\n    keys: any[];\n    fn: (item: T, key: React.Key) => React.ReactNode;\n    getKey?: (item: T) => React.Key;\n  },\n): React.ReactNode;\n```\n\n----------------------------------------\n\nTITLE: Import createApi from Effector\nDESCRIPTION: Imports the `createApi` function from the Effector library. This function is used to create events and connect them to a store with reducers.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createApi.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Skipping Undefined Values in Effector (TypeScript)\nDESCRIPTION: Demonstrates the default behavior of Effector, which skips updates with undefined values, and how to allow undefined as a valid value by setting `skipVoid: false` during store creation. Requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = createStore(0).on(event, (_, newValue) => {\n  if (newValue % 2 === 0) {\n    return;\n  }\n\n  return newValue;\n});\n```\n\n----------------------------------------\n\nTITLE: factories Configuration\nDESCRIPTION: Example configuring the `factories` option in the Effector Babel plugin to specify module names that export custom factory functions for creating Effector units.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"factories\": [\"path/here\"]\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Importing merge from effector - TypeScript\nDESCRIPTION: Imports the `merge` function and `Unit` type from the effector library. The `merge` function is used to combine multiple effector units into a single event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/merge.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { merge, type Unit } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Event compositeName Example\nDESCRIPTION: Explains how the `compositeName` property provides a full path of the unit, including the names of any parent scopes like domains. Demonstrates how the composite name reflects the unit's position within the effector hierarchy.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createDomain } from \"effector\";\n\nconst first = createEvent();\nconst domain = createDomain();\nconst second = domain.createEvent();\n\nconsole.log(first.compositeName);\n// => { shortName: \"first\", fullName: \"first\", path: [\"first\"] }\n\nconsole.log(second.compositeName);\n// => { shortName: \"second\", fullName: \"domain/second\", path: [\"domain\", \"second\"] }\n```\n\n----------------------------------------\n\nTITLE: Basic scopeBind usage with Event\nDESCRIPTION: This example demonstrates how to use `scopeBind` to bind an event to a scope.  It creates an event `changeLocation` and uses `scopeBind` to create a function `locationUpdate` that dispatches the event within the correct scope when called from a callback like `history.listen`. The code also illustrates how to use `attach` and `sample` to trigger the effect. The example also demonstrates the creation of a store and event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/scopeBind.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, attach, scopeBind } from \"effector\";\n\nconst $history = createStore(history);\nconst initHistory = createEvent();\nconst changeLocation = createEvent<string>();\n\nconst installHistoryFx = attach({\n  source: $history,\n  effect: (history) => {\n    const locationUpdate = scopeBind(changeLocation);\n\n    history.listen((location) => {\n      locationUpdate(location);\n    });\n  },\n});\n\nsample({\n  clock: initHistory,\n  target: installHistoryFx,\n});\n```\n\n----------------------------------------\n\nTITLE: useList Todo List Example\nDESCRIPTION: Illustrates a more complex scenario where useList is used to render a todo list.  The example incorporates event creation, store updates, and dynamic rendering based on the todo item's state (done or not done). It imports `createStore`, `createEvent` from effector and `useList` from effector-react.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useList.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\nimport { useList } from \"effector-react\";\n\nconst addTodo = createEvent();\nconst toggleTodo = createEvent();\n\nconst $todoList = createStore([\n  { text: \"write useList example\", done: true },\n  { text: \"update readme\", done: false },\n])\n  .on(toggleTodo, (list, id) =>\n    list.map((todo, i) => {\n      if (i === id)\n        return {\n          ...todo,\n          done: !todo.done,\n        };\n      return todo;\n    }),\n  )\n  .on(addTodo, (list, e) => [\n    ...list,\n    {\n      text: e.currentTarget.elements.content.value,\n      done: false,\n    },\n  ]);\n\naddTodo.watch((e) => {\n  e.preventDefault();\n});\n\nconst TodoList = () =>\n  useList($todoList, ({ text, done }, i) => {\n    const todo = done ? (\n      <del>\n        <span>{text}</span>\n      </del>\n    ) : (\n      <span>{text}</span>\n    );\n    return <li onClick={() => toggleTodo(i)}>{todo}</li>;\n  });\nconst App = () => (\n  <div>\n    <h1>todo list</h1>\n    <form onSubmit={addTodo}>\n      <label htmlFor=\"content\">New todo</label>\n      <input type=\"text\" name=\"content\" required />\n      <input type=\"submit\" value=\"Add\" />\n    </form>\n    <ul>\n      <TodoList />\n    </ul>\n  </div>\n);\n\n```\n\n----------------------------------------\n\nTITLE: Effector Custom Store Usage (JS)\nDESCRIPTION: Demonstrates how to use a custom store creator (defined elsewhere) to create an Effector store.  The Babel plugin, when configured correctly, will inject the `name` and `sid` options during compilation. Requires effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_18\n\nLANGUAGE: js\nCODE:\n```\n// src/state.js\nimport { createInputField } from \"@lib/createInputField\";\n\nconst foo = createInputField(\"-\");\n/*\n\nбудет обработано как создатель стор и скомпилировано в\n\nconst foo = createInputField('-', {\n  name: 'foo',\n  sid: 'z&si65'\n})\n\n*/\n```\n\n----------------------------------------\n\nTITLE: Creating WebSocket Connection Effect - TypeScript\nDESCRIPTION: This code defines an Effector effect for establishing a WebSocket connection. It takes a URL as input and returns a Promise that resolves with the WebSocket instance upon successful connection.  It also sets up event handlers for incoming messages, connection closure, and errors, using `scopeBind` to properly handle events within the correct scope. Dependencies: effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/websocket-integration.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst connectWebSocketFx = createEffect((url: string): Promise<WebSocket> => {\n  const ws = new WebSocket(url);\n\n  const scopeDisconnected = scopeBind(disconnected);\n  const scopeRawMessageReceived = scopeBind(rawMessageReceived);\n\n  return new Promise((res, rej) => {\n    ws.onopen = () => {\n      res(ws);\n    };\n\n    ws.onmessage = (event) => {\n      scopeRawMessageReceived(event.data);\n    };\n\n    ws.onclose = () => {\n      scopeDisconnected();\n    };\n\n    ws.onerror = (err) => {\n      scopeDisconnected();\n      rej(err);\n    };\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Create Effector Store with Custom Serialization in TypeScript\nDESCRIPTION: This TypeScript example showcases how to create an Effector store with a custom serialization configuration. It addresses the issue of Date object serialization and deserialization by providing custom `write` and `read` functions in the `serialize` option. This ensures data consistency when serializing and deserializing the store's state during server-side rendering and client-side hydration.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createStore.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { createEvent, createStore, serialize, fork, allSettled } from \"effector\";\n\nconst saveDate = createEvent();\nconst $date = createStore<null | Date>(null, {\n  // Объект Date автоматически приводится в строку ISO-даты при вызове JSON.stringify\n  // но не приводится обратно к Date при вызове JSON.parse – результатом будет та же строка ISO-даты\n  // Это приведет к расхождению состояния стора при гидрации состояния на клиенте при серверном рендеринге\n  //\n  // Кастомная конфигурация `serialize` решает эту проблему\n  serialize: {\n    write: (dateOrNull) => (dateOrNull ? dateOrNull.toISOString() : dateOrNull),\n    read: (isoStringOrNull) => (isoStringOrNull ? new Date(isoStringOrNull) : isoStringOrNull),\n  },\n}).on(saveDate, (_, p) => p);\n\nconst serverScope = fork();\n\nawait allSettled(saveDate, { scope: serverScope, params: new Date() });\n\nconst serverValues = serialize(serverScope);\n// `serialize.write` стор `$date` был вызван\n\nconsole.log(serverValues);\n// => { nq1e2rb: \"2022-11-05T15:38:53.108Z\" }\n// Объект Date из стора сохранен как ISO-дата\n\nconst clientScope = fork({ values: serverValues });\n// `serialize.read` стор `$date` был вызван\n\nconst currentValue = clientScope.getState($date);\nconsole.log(currentValue);\n// => Date 11/5/2022, 10:40:13 PM\n// Строка ISO-даты приведена обратно к объекту Date\n```\n\n----------------------------------------\n\nTITLE: Import useUnit from effector-vue\nDESCRIPTION: Imports the `useUnit` function from the `effector-vue/composition` module. This function is used to bind Effector units to Vue components.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useUnit.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useUnit } from \"effector-vue/composition\";\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Effect with Inner Effects - JS\nDESCRIPTION: This JavaScript code demonstrates an incorrect usage of Effector effects. Mixing regular asynchronous operations (like `setTimeout`) with effect calls within a single effect can lead to loss of scope.  The `setTimeout` should ideally be wrapped in its own effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Scope.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst sendWithAuthFx = createEffect(async () => {\n  await authUserFx();\n\n  // Incorrect! This should be wrapped in an effect.\n  await new Promise((resolve) => setTimeout(resolve, 80));\n\n  // Context is lost here.\n  await sendMessageFx();\n});\n```\n\n----------------------------------------\n\nTITLE: Merging Stores (Javascript)\nDESCRIPTION: Demonstrates merging two stores.  When either of the stores updates, the merged event is triggered with the new value of the store that was updated. The example uses `createStore` and `on` to manage store state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/merge.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore, merge } from \"effector\";\n\nconst setFoo = createEvent();\nconst setBar = createEvent();\n\nconst $foo = createStore(0).on(setFoo, (_, v) => v);\n\nconst $bar = createStore(100).on(setBar, (_, v) => v);\n\nconst anyUpdated = merge([$foo, $bar]);\nanyUpdated.watch((v) => console.log(`state changed to: ${v}`));\n\nsetFoo(1); // => state changed to: 1\nsetBar(123); // => state changed to: 123\n```\n\n----------------------------------------\n\nTITLE: Typing `attach` in TypeScript\nDESCRIPTION: This code shows how to type the `attach` function in Effector to enable TypeScript to infer the types of the created effect correctly. By adding a type to the first argument of `mapParams`, the `Params` generic of the resulting effect is correctly inferred.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst sendTextFx = createEffect<{ message: string }, \"ok\">(() => {\n  // ...\n\n  return \"ok\";\n});\n\nconst sendWarningFx = attach({\n  effect: sendTextFx,\n  mapParams: (warningMessage: string) => ({ message: warningMessage }),\n});\n// sendWarningFx has type Effect<{message: string}, 'ok'>\n```\n\n----------------------------------------\n\nTITLE: Using scopeBind to avoid scope loss with setInterval\nDESCRIPTION: This example demonstrates how to use `scopeBind` to safely call effects within asynchronous functions like `setInterval`. `scopeBind` creates a function bound to the scope in which it was called, preventing scope loss.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Scope.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst sendWithAuthFx = createEffect(async () => {\n  // Теперь эту функцию можно безопасно вызывать\n  // без соблюдения правил потери скоупа\n  const sendMessage = scopeBind(sendMessageFx);\n\n  await authUserFx();\n\n  // Контекста внутри setInterval нет, но наша функция привязана\n  return setInterval(sendMessage, 500);\n});\n```\n\n----------------------------------------\n\nTITLE: Effector onCreateEffect Hook Formula\nDESCRIPTION: Demonstrates the signature for the `onCreateEffect` hook.  This hook allows you to execute a callback function every time an effect is created within the domain. The callback receives the created effect as its argument.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Domain.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndomain.onCreateEffect((effect: Effect<any, any, any>) => {});\n```\n\n----------------------------------------\n\nTITLE: Watching Effect Calls with watch() - Typescript\nDESCRIPTION: Attaches an additional function with side effects that is called every time the effect is triggered. The function receives the data with which the effect was called.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fx: Effect<T, any>\n\nfx.watch(/*watcher*/ (data: T) => any)\n-> Subscription\n```\n\n----------------------------------------\n\nTITLE: Import scopeBind from Effector\nDESCRIPTION: This snippet demonstrates how to import the `scopeBind` function from the Effector library. This import is necessary to use the `scopeBind` function to bind events, effects, or arbitrary callbacks to a specific scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/scopeBind.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { scopeBind } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Creating Loading Indicator Component (JSX)\nDESCRIPTION: This React component `Loader` displays a loading indicator while the `sendFormFx` effect is pending. It uses the `useUnit` hook to subscribe to the `sendFormFx.pending` store, which is a boolean indicating whether the effect is currently in progress.  It returns a `div` element that says \"Loading...\" if the effect is pending; otherwise it returns `null`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/forms.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nconst Loader = () => {\n  //typeof loading === \"boolean\"\n  const loading = useUnit(sendFormFx.pending);\n  return loading ? <div>Loading...</div> : null;\n};\n```\n\n----------------------------------------\n\nTITLE: Typing Effects in Effector with TypeScript (Basic)\nDESCRIPTION: Shows how to type Effector effects using generics to specify input parameters, return results, and error types. Demonstrates the use of `createEffect` with an asynchronous handler function. TypeScript can infer types from the handler function or types can be provided explicitly.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\n// Базовый эффект\n// Effect<string, User, Error>\nconst fetchUserFx = createEffect(async (userId: string) => {\n  const response = await fetch(`/api/users/${userId}`);\n  const result = await response.json();\n\n  return result as User;\n});\n```\n\n----------------------------------------\n\nTITLE: Typing Stores in Effector with TypeScript\nDESCRIPTION: Explains how to type Effector stores using generics or by providing a default value during initialization.  TypeScript infers the store type from the default value if no generic type is provided. Different store types such as `Store<T>` and `StoreWritable<T>` are discussed.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"effector\";\n\n// Базовый стор с примитивным значением\n// StoreWritable<number>\nconst $counter = createStore(0);\n\n// Стор со сложным объектным типом\ninterface User {\n  id: number;\n  name: string;\n  role: \"admin\" | \"user\";\n}\n\n// StoreWritable<User>\nconst $user = createStore<User>({\n  id: 1,\n  name: \"Bob\",\n  role: \"user\",\n});\n\n// Store<string>\nconst $userNameAndRole = $user.map((user) => `User name and role: ${user.name} and ${user.role}`);\n```\n\n----------------------------------------\n\nTITLE: withRegion Formula\nDESCRIPTION: Shows the type signature of the `withRegion` method. It takes a Unit or Node and a callback function as arguments. The callback defines units owned by the provided unit.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/withRegion.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nwithRegion(unit: Unit<T> | Node, callback: () => void): void\n```\n\n----------------------------------------\n\nTITLE: Store .reset() Example - Javascript\nDESCRIPTION: Resets a store's state to its initial value using the `.reset()` method. The reset is triggered by the `reset` event. This example shows how to increment a store and then reset it back to its initial state of 0.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst increment = createEvent();\nconst reset = createEvent();\n\nconst $store = createStore(0)\n  .on(increment, (state) => state + 1)\n  .reset(reset);\n\n$store.watch((state) => console.log(\"changed\", state));\n\nincrement();\nincrement();\nreset();\n```\n\n----------------------------------------\n\nTITLE: General combine formulae\nDESCRIPTION: Different ways to use combine to derive stores\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/combine.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const $a: Store<A>;\ndeclare const $b: Store<B>;\n\n// Трансформация состояний\n\nconst $c: Store<C> = combine({ a: $a, b: $b }, (values: { a: A; b: B }) => C);\n\nconst $c: Store<C> = combine([$a, $b], (values: [A, B]) => C);\n\nconst $c: Store<C> = combine($a, $b, (a: A, b: B) => C);\n\n// Комбинирование состояний\n\nconst $c: Store<{ a: A; b: B }> = combine({ a: $a, b: $b });\n\nconst $c: Store<[A, B]> = combine([$a, $b]);\n```\n\n----------------------------------------\n\nTITLE: Effector onCreateStore Hook Formula\nDESCRIPTION: Demonstrates the signature for the `onCreateStore` hook.  This hook allows you to execute a callback function every time a store is created within the domain. The callback receives the created store as its argument.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Domain.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndomain.onCreateStore(($store: Store<any>) => {});\n```\n\n----------------------------------------\n\nTITLE: Preventing Default Form Submission (JS)\nDESCRIPTION: This snippet prevents the default HTML form submission behavior using React's event handling.  The `submitted.watch` function listens to the `formSubmitted` event and calls `e.preventDefault()` to stop the default browser form submission.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/forms.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nformSubmitted.watch((e) => {\n  e.preventDefault();\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Effect Fail Event - Javascript\nDESCRIPTION: Illustrates the `fail` event of an Effector effect. A watcher is attached to the `fail` event to log the error message and the parameters passed to the effect when the effect fails.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect(async (value) => {\n  throw Error(value - 1);\n});\n\nfx.fail.watch(({ params, error }) => {\n  console.log(\"Вызов с аргументом\", params, \"завершился с ошибкой\", error.message);\n});\n\nfx(2);\n// => Вызов с аргументом 2 завершился с ошибкой 1\n```\n\n----------------------------------------\n\nTITLE: Combining Stores, Events, and Effects in Effector (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates how to combine stores, events, and effects in Effector to create a complete reactive data flow.  It shows how an effect can fetch data, update a store, and how derived stores automatically update when the original store changes. The `effector` library is required.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/core-concepts.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect } from \"effector\";\n\n// определяем наши сторы\nconst $supers = createStore([]);\nconst $superHeroes = $supers.map((supers) => supers.filter((sup) => sup.role === \"hero\"));\nconst $superVillains = $supers.map((supers) => supers.filter((sup) => sup.role === \"villain\"));\n\n// создаем события\nconst superAdded = createEvent();\n\n// создаем эффекты для получения данных\nconst getSupersFx = createEffect(async () => {\n  const res = await fetch(\"/server/api/supers\");\n  if (!res.ok) {\n    throw new Error(\"something went wrong\");\n  }\n  const data = await res.json();\n  return data;\n});\n\n// создаем эффекты для получения данных\nconst saveNewSuperFx = createEffect(async (newSuper) => {\n  // симуляция сохранения нового супера\n  await new Promise((res) => setTimeout(res, 1500));\n  return newSuper;\n});\n\n// когда загрузка завершилась успешно, устанавливаем данные\n$supers.on(getSupersFx.done, ({ result }) => result);\n// добавляем нового супера\n$supers.on(superAdded, (supers, newSuper) => [...supers, newSuper]);\n\n// вызываем загрузку данных\ngetSupersFx();\n```\n\n----------------------------------------\n\nTITLE: Sampling event data to another event - Typescript\nDESCRIPTION: Shows how to send data from an event with an argument to an event without an argument using `sample`.  This example illustrates that it is possible to connect events with different data types.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nsample({\n  clock: withData, // Event<number>\n  target: withoutData, // Event<void>\n});\n```\n\n----------------------------------------\n\nTITLE: Inspect Graph Declarations\nDESCRIPTION: Shows how to use `inspectGraph` to monitor the declaration of Effector units. It prints the kind and name of each unit as it is declared. This is useful for understanding the structure and composition of your Effector application.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/inspect.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { inspectGraph, type Declaration } from \"effector/inspect\";\n\nfunction printDeclaration(d: Declaration) {\n  console.log(`${d.kind} ${d.name}`);\n}\n\ninspectGraph({\n  fn: (d) => {\n    printDeclaration(d);\n  },\n});\n\nconst $count = createStore(0);\n// выведет \"store $count\" в консоль\n```\n\n----------------------------------------\n\nTITLE: Effector Domain Creation Example\nDESCRIPTION: This example demonstrates how to create and use domains in Effector using the `createDomain` function. It shows the creation of unnamed and named domains, as well as the creation of events, effects, domains, and stores within a domain.  Dependencies: effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createDomain.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createDomain } from \"effector\";\n\nconst domain = createDomain(); // безымянный домен\nconst httpDomain = createDomain(\"http\"); // именованный домен\n\nconst statusCodeChanged = httpDomain.createEvent();\nconst downloadFx = httpDomain.createEffect();\nconst apiDomain = httpDomain.createDomain(); // вложенный домен\nconst $data = httpDomain.createStore({ status: -1 });\n```\n\n----------------------------------------\n\nTITLE: Import Scope type from effector\nDESCRIPTION: Imports the `Scope` type from the effector library. This allows you to define variables and parameters as a `Scope` object, which represents an isolated instance of the Effector application.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Scope.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type Scope } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Incorrect Callback Naming in Effector (Typescript)\nDESCRIPTION: This snippet shows an incorrect usage of abstract names like `value`, `data`, or `item` in effector callbacks. This makes the code harder to understand and maintain. It involves updating a `$users` store on `userAdded` event and sampling `$data` store upon `buttonClicked` event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/best-practices.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n$users.on(userAdded, (state, payload) => [...state, payload]);\n\nsample({\n  clock: buttonClicked,\n  source: $data,\n  fn: (data) => data,\n  target: someFx,\n});\n```\n\n----------------------------------------\n\nTITLE: ClearNode usage with store and event\nDESCRIPTION: This example shows how to use `clearNode` to destroy a store after an event is triggered. The `clearNode` function is called with the store as an argument, effectively removing the store and its subscriptions. The `inc` event will still be called, but the store will no longer update or log.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/clearNode.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, clearNode } from \"effector\";\n\nconst inc = createEvent();\nconst $store = createStore(0).on(inc, (x) => x + 1);\n\ninc.watch(() => console.log(\"inc called\"));\n$store.watch((x) => console.log(\"store state: \", x));\n// => store state: 0\ninc();\n// => inc called\n// => store state: 1\nclearNode($store);\ninc();\n// => inc called\n```\n\n----------------------------------------\n\nTITLE: Inspecting with a Scope\nDESCRIPTION: Illustrates how to limit computation tracking to a specific Effector scope using `fork` and `allSettled`. This ensures that only computations within the specified scope are tracked by the `inspect` function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/inspect.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fork, allSettled } from \"effector\";\nimport { inspect, type Message } from \"effector/inspect\";\n\nimport { someEvent } from \"./app-code\";\n\nfunction logInspectMessage(m: Message) {\n  const { name, value, kind } = m;\n\n  return console.log(`[${kind}] ${name} ${value}`);\n}\n\nconst myScope = fork();\n\ninspect({\n  scope: myScope,\n  fn: (m) => {\n    logInspectMessage(m);\n  },\n});\n\nsomeEvent(42);\n// ☝️ No logs! That's because tracking was restricted by myScope\n\nallSettled(someEvent, { scope: myScope, params: 42 });\n// [event] someEvent 42\n// [on] 42\n// [store] $count 1337\n```\n\n----------------------------------------\n\nTITLE: Authorized Request Effect with Store Source\nDESCRIPTION: Creates an authorized request effect by attaching to the `backendRequestFx` and using a token store as the source.  It maps the parameters to include the token from the store in the request. It also defines a `createRequest` function to generate effects bound to a specific resource.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// ./api/authorized.ts\nimport { attach, createStore } from \"effector\";\n\nconst $token = createStore(\"guest_token\");\n\nexport const authorizedRequestFx = attach({\n  effect: backendRequestFx,\n  source: $token,\n  mapParams: ({ data, resource }, token) => ({ data, resource, token }),\n});\n\nexport function createRequest(resource) {\n  return attach({\n    effect: authorizedRequestFx,\n    mapParams: (data) => ({ data, resource }),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Import useStoreMap from effector-react (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import the `useStoreMap` hook from the `effector-react` library. This import statement is necessary to use the hook in a React component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useStoreMap.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useStoreMap } from \"effector-react\";\n```\n\n----------------------------------------\n\nTITLE: Sample with Target Return Value\nDESCRIPTION: Demonstrates that if target is specified, `sample` will return that same `target`.  It returns the type `EventCallable<number>` since the target is an event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = createStore(0);\nconst submitted = createEvent();\nconst sendData = createEvent<number>();\n\n// result will have type EventCallable<number>\nconst result = sample({\n  clock: submitted,\n  source: $store,\n  target: sendData,\n});\n```\n\n----------------------------------------\n\nTITLE: useStoreMap Signature (Simple)\nDESCRIPTION: Defines the basic signature of the `useStoreMap` hook. It takes a store and a selector function as input.  The hook returns the result of the selector function applied to the store's state.  The component re-renders only if the result of the selector changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useStoreMap.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nuseStoreMap<State, Result>(\n  store: Store<State>,\n  fn: (state: State) => Result\n): Result\n```\n\n----------------------------------------\n\nTITLE: Page Mounting Event\nDESCRIPTION: This snippet adds a `pageMounted` event to the Effector model and uses a `useEffect` hook in the React component to trigger the event when the page is mounted. This allows for initializing data loading and other setup tasks when the component is rendered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\n// Файл: /src/pages/chat/page.tsx\nexport function ChatPage() {\n  const handlePageMount = useUnit(model.pageMounted);\n\n  React.useEffect(() => {\n    handlePageMount();\n  }, [handlePageMount]);\n\n  return (\n    <div className=\"parent\">\n      <ChatHistory />\n      <MessageForm />\n    </div>\n  );\n}\n```\n\nLANGUAGE: ts\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\n// Просто добавьте новое событие\nexport const pageMounted = createEvent();\n```\n\n----------------------------------------\n\nTITLE: Splitting event based on object with boolean functions in Effector (TS)\nDESCRIPTION: This code snippet demonstrates how to use effector's `split` function with an object containing boolean functions. Each function checks a condition based on the input event's data (paymentReceived). The first function that returns true determines which effect will be triggered.  It requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/flow-split.mdx#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nsplit({\n  source: paymentReceived,\n  match: {\n    lowAmount: ({ amount }) => amount < 100,\n    mediumAmount: ({ amount }) => amount >= 100 && amount < 1000,\n    highAmount: ({ amount }) => amount >= 1000,\n  },\n  cases: {\n    lowAmount: processLowPaymentFx,\n    mediumAmount: processMediumPaymentFx,\n    highAmount: processHighPaymentFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Watching finally Event on Effect\nDESCRIPTION: This code demonstrates how to use the `finally` event of an effector effect to observe both success and failure outcomes. It creates an effect that can either succeed or fail based on the `ok` parameter and then watches the `finally` event to log the outcome.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchApiFx = createEffect(async ({ time, ok }) => {\n  await new Promise((resolve) => setTimeout(resolve, time));\n  if (ok) return `${time} ms`;\n  throw Error(`${time} ms`);\n});\n\nfetchApiFx.finally.watch((value) => {\n  switch (value.status) {\n    case \"done\":\n      console.log(\"Вызов с аргументом\", value.params, \"завершён со значением\", value.result);\n      break;\n    case \"fail\":\n      console.log(\"Вызов с аргументом\", value.params, \"завершён с ошибкой\", value.error.message);\n      break;\n  }\n});\n\nawait fetchApiFx({ time: 100, ok: true });\n// => Вызов с аргументом {time: 100, ok: true}\n//    завершён со значением 100 ms\n\nfetchApiFx({ time: 100, ok: false });\n// => Вызов с аргументом {time: 100, ok: false}\n//    завершён с ошибкой 100 ms\n```\n\n----------------------------------------\n\nTITLE: Incorrect Prepend with Unit Call\nDESCRIPTION: Illustrates an incorrect usage of `.prepend`:  calling an event from inside prepend function. This will throw an error, because `prepend` function must be pure.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst someHappened = createEvent<string>();\nconst another = createEvent<number>();\n\nconst reversed = someHappened.prepend((input: number) => {\n  another(input); // ВЫЗЫВАЕТ ОШИБКУ!\n  return String(input);\n});\n```\n\n----------------------------------------\n\nTITLE: Import useGate from effector-solid (TypeScript)\nDESCRIPTION: Imports the `useGate` function from the `effector-solid` library. This import statement is necessary to use the `useGate` hook in a Solid.js component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useGate.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useGate } from \"effector-solid\";\n```\n\n----------------------------------------\n\nTITLE: Check if a value is targetable - Effector\nDESCRIPTION: This JavaScript snippet demonstrates how to use `is.targetable` to check if a given value can be used in operators target (or be called as a function in case of events).\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/is.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect } from \"effector\";\n\nconst $store = createStore(null);\nconst $mapped = $store.map((x) => x);\nconst event = createEvent();\nconst mappedEvent = event.map((x) => x);\nconst fx = createEffect();\n\nis.targetable($store);\n// => true\n\nis.targetable($mapped);\n// => false\n\nis.targetable(event);\n// => true\n\nis.targetable(mappedEvent);\n// => false\n\nis.targetable(fx);\n// => true\n```\n\n----------------------------------------\n\nTITLE: Using the Router Provider in RootLayout (JavaScript)\nDESCRIPTION: This snippet demonstrates how to use the `EffectorRouterProvider` component within the `RootLayout` component in Next.js. It wraps the children of the layout with the provider, making the Effector router accessible to the application. It requires the '@/providers/effector-router-provider' dependency.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/nextjs/router.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { EffectorRouterProvider } from '@/providers/effector-router-provider';\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html>\n      <body>\n        <EffectorRouterProvider>\n          {children}\n        </EffectorRouterProvider>\n      </body>\n    </html>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Watching Events with createWatch\nDESCRIPTION: Illustrates using `createWatch` to observe event triggers and log them. The function accepts an object as argument, which contains unit or array of units for watching and function which will be called when unit is triggered. It imports `createEvent`, `sample`, and `createWatch` from `effector`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/events.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, sample, createWatch } from \"effector\";\n\nconst firstTriggered = createEvent<void>();\nconst secondTriggered = createEvent<void>();\n\nsample({\n  clock: firstTriggered,\n  target: secondTriggered,\n});\n\nconst unwatch = createWatch({\n  unit: [firstTriggered, secondTriggered],\n  fn: (payload) => {\n    console.log(\"[event] triggered\");\n  },\n});\n\nfirstTriggered();\n// => [event] triggered\n// => [event] triggered\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple Events in Effector using sample\nDESCRIPTION: This snippet illustrates an alternative way to merge multiple Effector events using `sample` with an array of events as the `clock`.  It achieves the same result as the `merge` example, triggering `someActionHappened` when any of the `buttonClicked`, `linkClicked`, or `iconClicked` events occur.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst buttonClicked = createEvent();\nconst linkClicked = createEvent();\nconst iconClicked = createEvent();\n\n// Любое из этих событий вызовет someActionHappened\nsample({\n  clock: [buttonClicked, linkClicked, iconClicked],\n  target: someActionHappened,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing the `is` namespace from Effector\nDESCRIPTION: This snippet demonstrates how to import the `is` namespace and `Unit` type from the Effector library. The `is` namespace contains methods for checking the type of Effector units.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/is.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { is, type Unit } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Extracting Unit Value Type with UnitValue (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the `UnitValue` type utility to extract the data type from various Effector units like events, stores, and effects.  It shows how `UnitValue` can be used to define types that represent the payload of an event, the value of a store, or the parameters of an effect. The `fork` scope example shows that without type definition `UnitValue` defaults to `any`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { UnitValue, createEffect, createStore, createEvent } from \"effector\";\n\nconst event = createEvent<{ id: string; name?: string } | { id: string }>();\ntype UnitEventType = UnitValue<typeof event>;\n// {id: string; name?: string | undefined} | {id: string}\n\nconst $store = createStore([false, true]);\ntype UnitStoreType = UnitValue<typeof $store>;\n// boolean[]\n\nconst effect = createEffect<{ token: string }, any, string>(() => {});\ntype UnitEffectType = UnitValue<typeof effect>;\n// {token: string}\n\nconst scope = fork();\ntype UnitScopeType = UnitValue<typeof scope>;\n// any\n```\n\n----------------------------------------\n\nTITLE: Error: Unit Call from Pure Filter (Effector)\nDESCRIPTION: Demonstrates the error raised when attempting to trigger events from a `.filter`'s pure function and the correct way to trigger events using `sample`. It illustrates the best practice to avoid unintended side effects.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst countReceived = createEvent<number>();\nconst eachReceived = createEvent<number>();\n\nconst receivedEven = someHappened.filter({\n  fn(count) {\n    eachReceived(count); // ВЫЗЫВАЕТ ОШИБКУ!\n    return count % 2 === 0;\n  },\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst countReceived = createEvent<number>();\nconst eachReceived = createEvent<number>();\n\nconst receivedEven = someHappened.filter({\n  fn(count) {\n    return count % 2 === 0;\n  },\n});\n\nsample({\n  clock: someHappened,\n  target: eachReceived,\n});\n```\n\n----------------------------------------\n\nTITLE: Basic createStore example\nDESCRIPTION: Demonstrates the basic usage of `createStore` in Effector. It initializes a store named `$name` with a null value. This example is used to illustrate how the Effector plugin adds a `sid` to the store during code transformation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst $name = createStore(null);\n```\n\n----------------------------------------\n\nTITLE: Using createWatch without Scope (JavaScript)\nDESCRIPTION: This example demonstrates how to use `createWatch` without a specified scope. It creates an event, forks a scope (though it's not relevant), creates a watch on the event globally, and then triggers the event within the scope and also globally.  Because no scope is defined, the `fn` is invoked in both scenarios.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createWatch.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createWatch, createEvent, fork, allSettled } from \"effector\";\n\nconst changeName = createEvent();\n\nconst scope = fork();\n\nconst unwatch = createWatch({ unit: changeName, fn: console.log });\n\nawait allSettled(changeName, { scope, params: \"John\" }); // output: John\nchangeName(\"John\"); // output: John\n```\n\n----------------------------------------\n\nTITLE: Effector: Combining Media Queries into a Single Store (JS)\nDESCRIPTION: This code combines multiple media query stores into a single store `$screenQueries` using Effector's `combine` function. This allows for easy access to all media query states from a single point. The code also demonstrates how to watch this combined store and log the current state of each media query.\nSOURCE: https://github.com/effector/effector/blob/master/recipes/media-queries/README.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nimport {combine} from 'effector'\nimport {mediaMatcher} from './mediaMatcher'\n\n/* declaring queries and merge them into single store*/\n\nexport const $screenQueries = combine({\n  small: mediaMatcher('(max-width: 768px)'),\n  medium: mediaMatcher('(min-width: 769px) and (max-width: 1024px)'),\n  large: mediaMatcher('(min-width: 1025px)'),\n  portrait: mediaMatcher('(orientation: portrait)'),\n})\n\n/* using queries */\n\n$screenQueries.watch(queries => {\n  const {small, medium, large, portrait} = queries\n  console.log(`\n    is small ${small}\n    is medium ${medium}\n    is large ${large}\n    is portrait ${portrait}\n    is landscape ${!portrait}\n  `)\n})\n```\n\n----------------------------------------\n\nTITLE: Extracting Effect Parameters with `EffectParams` in Effector\nDESCRIPTION: Explains how to extract the parameter type of an Effector effect using the `EffectParams` type utility. This is useful for defining types related to effect inputs.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, EffectParams } from \"effector\";\n\nconst fx = createEffect<\n  { id: string },\n  { name: string; isAdmin: boolean },\n  { statusText: string; status: number }\n>(() => {\n  // ...\n  return { name: \"Alice\", isAdmin: false };\n});\n\ntype EffectParamsType = EffectParams<typeof fx>;\n// {id: string}\n```\n\n----------------------------------------\n\nTITLE: Import guard from effector (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to import the `guard` function from the effector library in a TypeScript environment. This import statement is necessary to use the `guard` function in your effector code.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/guard.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { guard } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Effect\nDESCRIPTION: This code creates an Effector effect `getUserProjectsFx` that simulates fetching user projects data. It uses `fetch` to make an asynchronous request to a specified endpoint and returns the JSON response. This effect is used in the effect testing example.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/testing.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst getUserProjectsFx = async () => {\n  const result = await fetch(\"/users/projects/2\");\n\n  return result.json();\n};\n```\n\n----------------------------------------\n\nTITLE: Store Creation with Skip Void Option - TypeScript\nDESCRIPTION: Illustrates store creation with the `skipVoid` option in Effector, controlling how `undefined` values are handled during updates.  If `skipVoid` is `true`, `undefined` acts as a skip signal; otherwise, it's treated as a normal value. A deprecation warning is triggered when returning undefined without specifying skipVoid.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/migration-guide-v23.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst $value = createStore(0).on(newValueReceived, (_oldValue, newValue) => newValue);\n```\n\n----------------------------------------\n\nTITLE: Connecting Events to Store in Effector\nDESCRIPTION: This code demonstrates connecting events to a store in Effector. The `on` method is used to update the `$counter` store when the `incremented` or `decremented` events are triggered. It shows a basic counter implementation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// counter.js\nimport { createEvent, createStore } from \"effector\";\n\nconst $counter = createStore(0);\n\nconst incremented = createEvent();\nconst decremented = createEvent();\n\n$counter.on(incremented, (counter) => counter + 1);\n$counter.on(decremented, (counter) => counter - 1);\n\n// and call it somewhere in your app\nincremented();\n// counter will increase by 1\ndecremented();\n// counter will decrease by -1\ndecremented();\n// counter will decrease by -1\n```\n\n----------------------------------------\n\nTITLE: Defining Chat Page View Layer\nDESCRIPTION: This code defines the view layer for the chat page using React and TypeScript. It includes components for displaying chat history and a message form. The components are placeholders initially.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n// File: /src/pages/chat/page.tsx\nexport function ChatPage() {\n  return (\n    <div className=\"parent\">\n      <ChatHistory />\n      <MessageForm />\n    </div>\n  );\n}\n\nfunction ChatHistory() {\n  return (\n    <div className=\"chat-history\">\n      <div>There will be messages list</div>\n    </div>\n  );\n}\n\nfunction MessageForm() {\n  return (\n    <div className=\"message-form\">\n      <div>There will be message form</div>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting Store State in Effector (TypeScript)\nDESCRIPTION: Illustrates how to reset an Effector store to its initial state using the `reset` method. It shows how to trigger a reset based on one or more events. Requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst formSubmitted = createEvent();\nconst formReset = createEvent();\n\nconst $form = createStore({ email: \"\", password: \"\" })\n  // Clear form on submit and on explicit reset too\n  .reset(formSubmitted, formReset)\n  // or\n  .reset([formSubmitted, formReset]);\n```\n\n----------------------------------------\n\nTITLE: Using useProvidedScope in library internals\nDESCRIPTION: Illustrates how to use the `useProvidedScope` hook within the internals of a custom library. It retrieves the current Effector Scope and can be used for advanced scenarios. Note that it's intended for library authors, not direct production code.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useProvidedScope.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst useCustomLibraryInternals = () => {\n  const scope = useProvidedScope();\n\n  // ...\n};\n```\n\n----------------------------------------\n\nTITLE: Inspect Computations within a Scope\nDESCRIPTION: Illustrates how to limit computation tracking to a specific Effector scope using the `scope` option in `inspect`.  This allows you to isolate and monitor computations within a particular execution context, like after a `fork`. The `scope` is created using `fork()` and `allSettled` is used for triggering.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/inspect.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fork, allSettled } from \"effector\";\nimport { inspect, type Message } from \"effector/inspect\";\n\nimport { someEvent } from \"./app-code\";\n\nfunction logInspectMessage(m: Message) {\n  const { name, value, kind } = m;\n\n  return console.log(`[${kind}] ${name} ${value}`);\n}\n\nconst myScope = fork();\n\ninspect({\n  scope: myScope,\n  fn: (m) => {\n    logInspectMessage(m);\n  },\n});\n\nsomeEvent(42);\n// ☝️ Нет логов! Это потому, что отслеживание было ограничено myScope\n\nallSettled(someEvent, { scope: myScope, params: 42 });\n// [event] someEvent 42\n// [on] 42\n// [store] $count 1337\n```\n\n----------------------------------------\n\nTITLE: Handling Validation Errors - Typescript\nDESCRIPTION: Handles the events when a message fails Zod validation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst validationError = createEvent<Error>();\n\n// If parsing fails, handle the error\nsample({\n  clock: parseFx.failData,\n  target: validationError,\n});\n```\n\n----------------------------------------\n\nTITLE: Create Effect with SID\nDESCRIPTION: Example demonstrating how to create an effect with a specified stable identifier (SID) in a common module. The SID is used to uniquely identify the effect across different environments.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nexport const getUser = createEffect({ sid: \"GET /user\" });\nconsole.log(getUsers.sid);\n// => GET /user\n```\n\n----------------------------------------\n\nTITLE: Testing with Effector Scopes\nDESCRIPTION: Shows an example of using Effector scopes for testing, including creating isolated scopes, executing effects, and checking state changes within the scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\ndescribe(\"auth flow\", () => {\n  it(\"should login user\", async () => {\n    // Create isolated scope for test\n    const scope = fork();\n\n    // Execute login effect\n    await allSettled(loginFx, {\n      scope,\n      params: {\n        email: \"test@example.com\",\n        password: \"123456\",\n      },\n    });\n\n    // Check state specifically in this scope\n    expect(scope.getState($user)).toEqual({\n      id: 1,\n      email: \"test@example.com\",\n    });\n  });\n\n  it(\"should handle login error\", async () => {\n    const scope = fork();\n\n    await allSettled(loginFx, {\n      scope,\n      params: {\n        email: \"invalid\",\n        password: \"123\",\n      },\n    });\n\n    expect(scope.getState($error)).toBe(\"Invalid credentials\");\n    expect(scope.getState($user)).toBeNull();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Babel Configuration for Effector Factories\nDESCRIPTION: Configures the Effector Babel plugin to recognize factory functions. This configuration enables Effector's static analysis and optimizations for code that uses factory patterns with `attach`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_12\n\nLANGUAGE: json5\nCODE:\n```\n// .babelrc\n{\n  plugins: [\n    [\n      \"effector/babel-plugin\",\n      {\n        factories: [\"src/path-to-your-entity/api/authorized\"],\n      },\n    ],\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Vite Polyfill Configuration (JavaScript)\nDESCRIPTION: This JavaScript snippet shows how to configure Vite to include necessary polyfills for older browsers when using `effector/compat`.  It uses the `@vitejs/plugin-legacy` plugin to automatically add polyfills for `Promise`, `Object.assign`, `Array.prototype.flat`, `Map`, and `Set`.  These polyfills are required to ensure compatibility with older browsers like IE11 and Chrome 47.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/module/compat.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from \"vite\";\nimport legacy from \"@vitejs/plugin-legacy\";\n\nexport default defineConfig({\n  plugins: [\n    legacy({\n      polyfills: [\"es.promise\", \"es.object.assign\", \"es.array.flat\", \"es.map\", \"es.set\"],\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Dynamically Updating Slot Content\nDESCRIPTION: This code showcases how to dynamically update the content of a slot based on an Effector store. It uses `split` to handle different states of the `$featureToggle` store and updates the `FooSlot` component with different components based on the current feature toggle value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/slots.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst updateFeatures = createEvent<string>(\"\");\nconst $featureToggle = createStore<string>(\"\");\n\nconst MyAwesomeFeature = () => <p>Look at my horse</p>;\nconst VeryAwesomeFeature = () => <p>My horse is amaizing</p>;\n\n$featureToggle.on(updateFeatures, (_, feature) => feature);\n\nsplit({\n  source: $featureToggle,\n  match: {\n    awesome: (data) => data === \"awesome\",\n    veryAwesome: (data) => data === \"veryAwesome\",\n    hideAll: (data) => data === \"hideAll\",\n  },\n  cases: {\n    awesome: api.set.prepend(() => ({\n      id: SLOTS.FOO,\n      component: MyAwesomeFeature,\n    })),\n    veryAwesome: api.set.prepend(() => ({\n      id: SLOTS.FOO,\n      component: VeryAwesomeFeature,\n    })),\n    hideAll: api.remove.prepend(() => ({ id: SLOTS.FOO })),\n  },\n});\n\n// updateFeatures('awesome'); // render MyAwesomeFeature in slot\n// updateFeatures('veryAwesome'); // render VeryAwesomeFeature in slot\n// updateFeatures('hideAll'); // render nothing in slot\n```\n\n----------------------------------------\n\nTITLE: Error: Unit Call from Pure Function (Effector)\nDESCRIPTION: Illustrates the error that occurs when attempting to call events or effects directly from pure functions within `.map()` or `.filter()`. It provides the corrected approach using `sample` operator to trigger events based on conditions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst someHappened = createEvent<number>();\nconst another = createEvent();\n\nconst derived = someHappened.map((number) => {\n  another(); // ВЫЗЫВАЕТ ОШИБКУ!\n  return String(number);\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst someHappened = createEvent<number>();\nconst another = createEvent();\nconst derived = createEvent<string>();\n\nsample({\n  clock: someHappened,\n  target: another,\n});\n\n// То же самое, что и .map(), но с использованием `target`\nsample({\n  clock: someHappened,\n  fn: (number) => String(number),\n  target: derived,\n});\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple Events in Effector using merge\nDESCRIPTION: This code demonstrates how to merge multiple Effector events into a single event using the `merge` function. The `buttonClicked`, `linkClicked`, and `iconClicked` events are merged into `anyClicked`, which triggers `someActionHappened` when any of the original events occur.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst buttonClicked = createEvent();\nconst linkClicked = createEvent();\nconst iconClicked = createEvent();\n\n// Любое из этих событий вызовет someActionHappened\nconst anyClicked = merge([buttonClicked, linkClicked, iconClicked]);\n\nsample({\n  clock: anyClicked,\n  target: someActionHappened,\n});\n```\n\n----------------------------------------\n\nTITLE: Extracting Store Type with `UnitValue` in Effector\nDESCRIPTION: Demonstrates how to use the `UnitValue` type utility to extract the data type from an Effector store.  This allows accessing the store's value type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { UnitValue, createEffect, createStore, createEvent } from \"effector\";\n\nconst $store = createStore([false, true]);\ntype UnitStoreType = UnitValue<typeof $store>;\n// boolean[]\n```\n\n----------------------------------------\n\nTITLE: Using scopeBind correctly within Effector effects (TS)\nDESCRIPTION: This code snippet demonstrates the correct usage of `scopeBind` within Effector effects to ensure that events are properly bound to the current scope. It highlights the common mistake of using `scopeBind` inside callbacks and provides the correct way to use it within the effect's main body.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/troubleshooting.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst event = createEvent();\n\n// ❌ - не вызывайте scopeBind внутри колбеков\nconst effectFx = createEffect(() => {\n  setTimeout(() => {\n    scopeBind(event)();\n  }, 1111);\n});\n\n// ✅ - используйте scopeBind внутри эффекта\nconst effectFx = createEffect(() => {\n  const scopeEvent = scopeBind(event);\n\n  setTimeout(() => {\n    scopeEvent();\n  }, 1111);\n});\n```\n\n----------------------------------------\n\nTITLE: Effector SSR Handler Example\nDESCRIPTION: Illustrates a server-side rendering handler that uses Effector scopes and SIDs to manage and serialize application state. It creates an isolated scope, populates the form values, serializes the scope's values into a simple JavaScript object, and then stringifies it for inclusion in the server response.  No direct store imports are needed as the state collection is automatic.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// src/server/handler.ts\nimport { fork, allSettled, serialize } from \"effector\";\n\nimport { formValuesFilled } from \"@/features/form\";\n\nasync function handleServerRequest(req) {\n  const scope = fork(); // создает изолированный контейнер для состояния приложения\n\n  // вычисляем состояние приложения в этом scope\n  await allSettled(formValuesFilled, {\n    scope,\n    params: {\n      firstName: \"John\",\n      lastName: \"Doe\",\n    },\n  });\n\n  // извлекаем значения scope в простой js объект `{[storeSid]: storeState}`\n  const values = serialize(scope);\n\n  const serializedState = JSON.stringify(values);\n\n  return renderHtmlToString({\n    scripts: [\n      `\n        <script>\n            self._SERVER_STATE_ = ${serializedState}\n        </script>\n      `,\n    ],\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Effector Naming Conventions (TypeScript)\nDESCRIPTION: This example shows the recommended naming conventions for Effector units: using the `$` prefix for stores, the `fx` suffix for effects, and descriptive names for events. This improves code readability and maintainability.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst updateUserNameFx = createEffect(() => {});\n\nconst userNameUpdated = createEvent();\n\nconst $userName = createStore(\"JS\");\n\n$userName.on(userNameUpdated, (_, newName) => newName);\n\nuserNameUpdated(\"TS\");\n```\n\n----------------------------------------\n\nTITLE: React Component: Conditional Rendering based on Media Queries (JSX)\nDESCRIPTION: This React component conditionally renders its children based on specified screen size and orientation constraints, leveraging the `Screen` component to manage these conditions. It expects boolean props for `landscape`, `large`, `portrait`, `small`, and `medium` to define the desired media query states.\nSOURCE: https://github.com/effector/effector/blob/master/recipes/media-queries/README.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst Button = () => (\n  <>\n    <Screen landscape large>\n      [large wide button]\n    </Screen>\n    <Screen portrait small medium>\n      [compact button]\n    </Screen>\n  </>\n)\n```\n\n----------------------------------------\n\nTITLE: Running Effector React Native on iOS simulator\nDESCRIPTION: These commands navigate to the iOS directory, install the necessary pods using CocoaPods, and then run the React Native application on the iOS simulator.  This assumes React Native and CocoaPods are already installed.\nSOURCE: https://github.com/effector/effector/blob/master/examples/effector-react-native-example/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd ios/ && pod install && cd ../\nreact-native run-ios\n```\n\n----------------------------------------\n\nTITLE: Create isolated instances with independent counter state - JS\nDESCRIPTION: This JavaScript code demonstrates how to create two isolated instances of an application using `fork`, each with its own independent counter state. It defines events to increment and decrement the counter, and a store to hold the counter's value.  `allSettled` is used to ensure all effects are resolved before retrieving the state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/fork.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { createStore, createEvent, fork, allSettled } from \"effector\";\n\nconst inc = createEvent();\nconst dec = createEvent();\nconst $counter = createStore(0);\n\n$counter.on(inc, (value) => value + 1);\n$counter.on(dec, (value) => value - 1);\n\nconst scopeA = fork();\nconst scopeB = fork();\n\nawait allSettled(inc, { scope: scopeA });\nawait allSettled(dec, { scope: scopeB });\n\nconsole.log($counter.getState()); // => 0\nconsole.log(scopeA.getState($counter)); // => 1\nconsole.log(scopeB.getState($counter)); // => -1\n```\n\n----------------------------------------\n\nTITLE: Effector Factories Configuration (JSON)\nDESCRIPTION: Configures the effector/babel-plugin to recognize custom factory functions. The `factories` option is an array of module paths. Crucial for SSR scenarios. Requires a Babel environment and effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"factories\": [\"path/here\"]\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Effector HMR Configuration (JSON)\nDESCRIPTION: Configures Hot Module Replacement (HMR) support within the effector/babel-plugin. The `hmr` option specifies the module system used by the bundler. It requires a Babel environment and is considered experimental.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n\"effector/babel-plugin\",\n  {\n    \"hmr\": \"es\"\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Effector Event Naming Convention\nDESCRIPTION: This snippet shows how to name effector events. It is important to give events meaningful names that are related to actions, rather than implementations. It shows an example of an incorrect and correct naming convention for effector events.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/resources/mindset.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n❌ const fetchData = createEvent()\n✅ const appStarted = createEvent()\n```\n\n----------------------------------------\n\nTITLE: Effector Counter with Async Validation\nDESCRIPTION: This code snippet defines an Effector counter with asynchronous validation. It includes an event `buttonClicked`, an effect `validateClickFx`, and a store `$clicksCount`. The effect is triggered when the button is clicked and the count is less than 100. The store is updated based on the success or failure of the validation effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/testing.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, createEffect, sample } from \"effector\";\n\nexport const buttonClicked = createEvent();\n\nexport const validateClickFx = createEffect(async () => {\n  /* вызов внешнего api */\n});\n\nexport const $clicksCount = createStore(0);\n\nsample({\n  clock: buttonClicked,\n  source: $clicksCount,\n  filter: (count) => count < 100,\n  target: validateClickFx,\n});\n\nsample({\n  clock: validateClickFx.done,\n  source: $clicksCount,\n  fn: (count) => count + 1,\n  target: $clicksCount,\n});\n\nsample({\n  clock: validateClickFx.fail,\n  fn: () => 0,\n  target: $clicksCount,\n});\n```\n\n----------------------------------------\n\nTITLE: Effector Split Cases With Unit Arrays\nDESCRIPTION: Shows how `split` can target an array of units for a specific case. In this example, a failed verification code triggers either the `$verificationCodeError` event or both the `$error` event and the `modalToAuthorizationMethod` event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect, createEvent, createStore, sample, split } from \"effector\";\n\nconst $verificationCode = createStore(\"12345\");\nconst $error = createStore(\"\");\n\nconst modalToInputUsername = createEvent();\nconst modalToAuthorizationMethod = createEvent();\n\nconst checkVerificationCodeFx = createEffect((code) => {\n  throw \"500\";\n});\n\nsample({\n  clock: verificationCodeSubmitted,\n  source: $verificationCode,\n  target: checkVerificationCodeFx,\n});\n\nsplit({\n  source: checkVerificationCodeFx.failData,\n  match: (value) => ([\"400\", \"410\"].includes(value) ? \"verificationCodeError\" : \"serverError\"),\n  cases: {\n    verificationCodeError: $verificationCodeError,\n    serverError: [$error, modalToAuthorizationMethod],\n  },\n});\n\n$error.updates.watch((value) => console.log(\"ОШИБКА: \" + value));\nmodalToAuthorizationMethod.watch(() =>\n  console.log(\"Модальное окно с содержимым метода авторизации.\"),\n);\n// => ОШИБКА: 500\n// => Модальное окно с содержимым метода авторизации.\n```\n\n----------------------------------------\n\nTITLE: Effector restore Import Statement (TypeScript)\nDESCRIPTION: This snippet imports the `restore` function from the Effector library.  It is a necessary prerequisite for using any of the `restore` method overloads. No specific inputs or outputs, but necessary for other snippets to function correctly.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/restore.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { restore } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Store .off() Example - Javascript\nDESCRIPTION: Removes a reducer from a store using the `.off()` method. This prevents the store from updating when the specified trigger event occurs. In this example, the reducer associated with the `changed` event is removed, so triggering `changed` will no longer update the store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore, merge } from \"effector\";\n\nconst changedA = createEvent();\nconst changedB = createEvent();\n\nconst $store = createStore(0);\nconst changed = merge([changedA, changedB]);\n\n$store.on(changed, (state, params) => state + params);\n$store.off(changed);\n```\n\n----------------------------------------\n\nTITLE: Typing event.prepend in Effector with TypeScript\nDESCRIPTION: Illustrates how to add types to events created with `event.prepend`.  The type can be added either as a generic or as a type annotation to the function argument.  The `prepend` method allows transforming data before it reaches an event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst message = createEvent<string>();\n\nconst userMessage = message.prepend((text: string) => text);\n// userMessage имеет тип EventCallable<string>\n\nconst warningMessage = message.prepend<string>((warnMessage) => warnMessage);\n// warningMessage имеет тип EventCallable<string>\n```\n\n----------------------------------------\n\nTITLE: Getting Store Value with getState() in effector\nDESCRIPTION: Demonstrates how to get the current value of a store using the `getState()` method for integration purposes. The example logs the current value of the `$counter` store, which is initialized to 0.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconsole.log($counter.getState()); // 0\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Exception Handling\nDESCRIPTION: Demonstrates how to handle exceptions thrown by the `mapParams` function when attaching an effect. The attached effect's `failData` event is watched for errors thrown in `mapParams` rather than executing the original effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, attach } from \"effector\";\n\nconst originalFx = createEffect((a: { a: number }) => a);\n\nconst attachedFx = attach({\n  effect: originalFx,\n  mapParams(a: number) {\n    throw new Error(\"custom error\");\n    return { a };\n  },\n});\n\nattachedFx.failData.watch((error) => console.log(\"attachedFx.failData\", error));\n\nattachedFx(1);\n// => attachedFx.failData\n// =>   Error: custom error\n```\n\n----------------------------------------\n\nTITLE: Using Object Syntax with Effector and Vue\nDESCRIPTION: This code snippet shows how to use the object syntax with the `effector` option to map Effector stores directly to Vue component properties. It imports a `counter` store and assigns it to the `counter` property within the `effector` object. This creates a `counter` property in the Vue template, bound to the effector store's value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/ComponentOptions.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { counter } from \"./stores\";\n\nnew Vue({\n  effector: {\n    counter, // would create `counter` in template\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Store Creation in Effector Domain\nDESCRIPTION: Demonstrates how to use `onCreateStore` to subscribe to the creation of new stores within an Effector domain. The provided hook function is invoked each time `domain.createStore()` is called, enabling actions like logging store creation events. The function takes a store as input.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Domain.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nimport { createDomain } from \"effector\";\n\nconst domain = createDomain();\n\ndomain.onCreateStore((store) => {\n  console.log(\"новый стор создан\");\n});\n\nconst $a = domain.createStore(null);\n// => новый стор создан\n```\n\n----------------------------------------\n\nTITLE: useUnit with Store - JSX Example\nDESCRIPTION: Demonstrates using `useUnit` with an Effector store in a Solid component. It defines a store for a counter, an API for incrementing and decrementing the counter, and a component that uses `useUnit` to bind the store and API to the component, allowing it to display the counter value and provide buttons to increment and decrement it.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useUnit.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore, createApi } from \"effector\";\nimport { useUnit } from \"effector-solid\";\n\nconst $counter = createStore(0);\n\nconst { incremented, decremented } = createApi($counter, {\n  incremented: (count) => count + 1,\n  decremented: (count) => count - 1,\n});\n\nconst App = () => {\n  const counter = useUnit($counter);\n  const [handleIncrement, handleDecrement] = useUnit([incremented, decremented]);\n\n  return (\n    <div>\n      {counter()}\n      <button onClick={incremented}>Increment</button>\n      <button onClick={decremented}>Decrement</button>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Importing Scope type in Typescript\nDESCRIPTION: This snippet shows how to import the `Scope` type from the `effector` library in TypeScript. This is necessary for type checking and working with `Scope` instances.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Scope.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type Scope } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Importing attach from effector (TypeScript)\nDESCRIPTION: Imports the `attach` function from the effector library. This function is used to create effects that are based on other effects and stores.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { attach } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Effector Split with Case Function\nDESCRIPTION: Illustrates using `split` with a case function to select a unit based on the result of a function applied to the source data.  The `match` property takes a function that receives data from `source` and returns a case name.  Cases are specified by name (`first`, `second`, `__`).\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>,\n  // функция кейса\n  match: (value: T) => 'first' | 'second',\n  cases: {\n    first: Unit<T> | Unit<T>[],\n    second: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Mocking Effects with fork\nDESCRIPTION: Demonstrates how to mock effects using the `handlers` property in the `fork` method in Effector for testing purposes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\n// You can also pass mocks for effects:\nconst scope = fork({\n  handlers: [\n    [effectA, async () => \"true\"],\n    [effectB, async () => ({ id: 1, data: \"mock\" })],\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: debugSids Configuration\nDESCRIPTION: Example configuring the `debugSids` option in the Effector Babel plugin to add a file path and variable name of a unit definition to a sid. Useful for debugging SSR.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"debugSids\": false\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Effector SID Example (JS)\nDESCRIPTION: Illustrates how to define a Stable ID (SID) for an effect using the `sid` configuration option. The SID remains consistent between environments, crucial for client-server interactions. Requires effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n// common.js\nimport { createEffect } from \"effector\";\n\nexport const getUser = createEffect({ sid: \"GET /user\" });\nconsole.log(getUsers.sid);\n// => GET /user\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Custom Name\nDESCRIPTION: Defines a name for the attached effect, allowing for easier identification and debugging. The name is accessible through the `shortName` property of the attached effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attach } from \"effector\";\n\nconst attachedFx = attach({\n  name: \"anotherUsefulName\",\n  source: $store,\n  async effect(source, params: Type) {\n    // ...\n  },\n});\n\nattachedFx.shortName; // \"anotherUsefulName\"\n```\n\n----------------------------------------\n\nTITLE: App.vue: Mapping IDs to User components\nDESCRIPTION: This Vue component demonstrates how to map a list of IDs to `User` components using `v-for`. It assumes that `$ids` is an Effector store containing an array of IDs. It shows the use of `useStore` and passes the ids down to the `User` component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useStoreMap.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst $ids = createStore(data.map(({ id }) => id));\n\nexport default {\n  setup() {\n    const ids = useStore($ids);\n\n    return { ids };\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Checking Unit Types with 'is' in Effector (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the `is` methods from Effector to determine the type of a unit (Event, Effect, or Store). It uses TypeScript type guards to narrow down the type of the `unit` parameter within each conditional block, enabling type-safe operations.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport function getUnitType(unit: unknown) {\n  if (is.event(unit)) {\n    // здесь юнит имеет тип Event<any>\n    return \"event\";\n  }\n  if (is.effect(unit)) {\n    // здесь юнит имеет тип Effect<any, any>\n    return \"effect\";\n  }\n  if (is.store(unit)) {\n    // здесь юнит имеет тип Store<any>\n    return \"store\";\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Effector onCreateEvent Hook Formula\nDESCRIPTION: Demonstrates the signature for the `onCreateEvent` hook. This hook allows you to execute a callback function every time an event is created within the domain. The callback receives the created event as its argument.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Domain.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndomain.onCreateEvent((event: Event<any>) => {});\n```\n\n----------------------------------------\n\nTITLE: Sample return value derived event - Typescript\nDESCRIPTION: Demonstrates other cases when `target` is not specified, the return value will be a derived event with a data type depending on `source`, which cannot be called by itself, but can be subscribed to!\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, sample } from \"effector\";\n\nconst $store = createStore(0);\n\nconst submitted = createEvent<string>();\n\nconst event = sample({\n  clock: submitted,\n  source: $store,\n});\n// event имеет тип Event<number>\n\nconst secondSampleEvent = sample({\n  clock: submitted,\n  source: $store,\n  fn: () => true,\n});\n// Event<true>\n```\n\n----------------------------------------\n\nTITLE: Mapping Event Data with .map() (Effector)\nDESCRIPTION: Illustrates how to create a derived event using `.map()`. The derived event is triggered after the original event, using the result of the provided function `fn` as its argument.  The `fn` function transforms the original event's data. Requires the `effector` library to be installed.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst first = createEvent<number>();\n// first: Event<number>\n\nconst second = first.map((count) => count.toString());\n// second: Event<string>\n```\n\n----------------------------------------\n\nTITLE: Merging effector stores with events - JavaScript\nDESCRIPTION: Illustrates how to use `merge` with stores.  Two stores, `$foo` and `$bar`, are created and updated via events.  The `merge` function combines these stores.  Any change in either store will trigger the merged event, logging the new state value. This example demonstrates how store updates trigger the merged event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/merge.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore, merge } from \"effector\";\n\nconst setFoo = createEvent();\nconst setBar = createEvent();\n\nconst $foo = createStore(0).on(setFoo, (_, v) => v);\nconst $bar = createStore(100).on(setBar, (_, v) => v);\n\nconst anyUpdated = merge([$foo, $bar]);\nanyUpdated.watch((v) => console.log(`state changed to: ${v}`));\n\nsetFoo(1); // => state changed to: 1\nsetBar(123); // => state changed to: 123\n```\n\n----------------------------------------\n\nTITLE: Effector Domain History Interface\nDESCRIPTION: Defines the `DomainHistory` interface which represents the history of units within a domain. It contains sets of stores, events, domains, and effects created within the domain.  This interface allows access to the units in the order they were created.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Domain.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DomainHistory {\n  stores: Set<Store<any>>;\n  events: Set<Event<any>>;\n  domains: Set<Domain>;\n  effects: Set<Effect<any, any, any>>;\n}\n\nconst { stores, events, domains, effects } = domain.history;\n```\n\n----------------------------------------\n\nTITLE: Import useEvent from effector-vue/ssr (TypeScript)\nDESCRIPTION: Imports the `useEvent` hook from the `effector-vue/ssr` module. This import is necessary to use the hook within a Vue component for server-side rendering.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useEvent.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useEvent } from \"effector-vue/ssr\";\n```\n\n----------------------------------------\n\nTITLE: Event filterMap Example with Array.prototype.find\nDESCRIPTION: Illustrates the use of filterMap with `Array.prototype.find` to extract a specific element from an array. The `filterMap` filters out `undefined` values returned by `find` when the element is not found.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_24\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst listReceived = createEvent<string[]>();\n\n// Array.prototype.find() возвращает `undefined`, когда элемент не найден\nconst effectorFound = listReceived.filterMap((list) => list.find((name) => name === \"effector\"));\n\neffectorFound.watch((name) => console.info(\"найден\", name));\n\nlistReceived([\"redux\", \"effector\", \"mobx\"]); // => найден effector\nlistReceived([\"redux\", \"mobx\"]);\n```\n\n----------------------------------------\n\nTITLE: Effector Effect Definition\nDESCRIPTION: This code snippet defines a simple effect using createEffect in Effector. The effect simulates fetching user projects data from a backend API. In a real application, this would involve making an actual API call, but here it's just a placeholder for demonstration purposes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/testing.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst getUserProjectsFx = async () => {\n  const result = await fetch(\"/users/projects/2\");\n\n  return result.json();\n};\n```\n\n----------------------------------------\n\nTITLE: Effector Effect pending Type\nDESCRIPTION: Declares the type for `effect.pending` store which is `Store<boolean>`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\neffect.pending: Store<boolean>;\n```\n\n----------------------------------------\n\nTITLE: Sample Store to Event\nDESCRIPTION: Demonstrates sampling a store with an event as the clock, resulting in a new event.  This showcases the behavior of `sample` when the clock is an event and the source is a store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/sample.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample } from \"effector\";\n\nconst event = sample({ clock: event, source: $store });\n// Because not all arguments are stores.\n```\n\n----------------------------------------\n\nTITLE: Watching Effect Calls with watch() - Javascript\nDESCRIPTION: Demonstrates using the `watch` method of an Effector effect to observe when the effect is triggered. A watcher function is provided, which logs the parameters passed to the effect each time it's called.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect((params) => params);\n\nfx.watch((params) => {\n  console.log(\"эффект вызван с аргументом\", params);\n});\n\nawait fx(10);\n// => эффект вызван с аргументом 10\n```\n\n----------------------------------------\n\nTITLE: CSS Styling for the Dynamic Form\nDESCRIPTION: This CSS snippet styles the dynamic form, tooltips and the overall layout of the application. It uses CSS grid for layout and provides basic styling for the form elements. The styling is applied dynamically using a `css` function that injects the CSS into the document head.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/dynamic-form-schema.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nawait loadFormFx();\n\ncss`\n  [data-tooltip]:before {\n    display: block;\n    background: white;\n    width: min-content;\n    content: attr(data-tooltip);\n    position: sticky;\n    top: 0;\n    left: 50%;\n    color: darkgreen;\n    font-family: sans-serif;\n    font-weight: 800;\n    font-size: 20px;\n    padding: 5px 5px;\n    transition: transform 100ms ease-out;\n  }\n\n  [data-tooltip][data-visible=\"true\"]:before {\n    transform: translate(0px, 0.5em);\n  }\n\n  [data-tooltip][data-visible=\"false\"]:before {\n    transform: translate(0px, -2em);\n  }\n\n  [data-form] {\n    display: contents;\n  }\n\n  [data-form] > header {\n    grid-column: 1 / span 2;\n  }\n\n  [data-form] > header > h4 {\n    margin-block-end: 0;\n  }\n\n  [data-form] label {\n    grid-column: 1;\n    justify-self: end;\n  }\n\n  [data-form] input:not([type=\"submit\"],\n  [data-form] select {\n    grid-column: 2;\n  }\n\n  [data-form] input[type=\"submit\"] {\n    grid-column: 2;\n    justify-self: end;\n    width: fit-content;\n  }\n\n  #app {\n    width: min-content;\n    display: grid;\n    grid-column-gap: 5px;\n    grid-row-gap: 8px;\n    grid-template-columns: repeat(2, 3fr);\n  }\n`;\n\nfunction css(tags, ...attrs) {\n  const value = style(tags, ...attrs);\n  const node = document.createElement(\"style\");\n  node.id = \"insertedStyle\";\n  node.appendChild(document.createTextNode(value));\n  const sheet = document.getElementById(\"insertedStyle\");\n\n  if (sheet) {\n    sheet.disabled = true;\n    sheet.parentNode.removeChild(sheet);\n  }\n  document.head.appendChild(node);\n\n  function style(tags, ...attrs) {\n    if (tags.length === 0) return \"\";\n    let result = \" \" + tags[0];\n\n    for (let i = 0; i < attrs.length; i++) {\n      result += attrs[i];\n      result += tags[i + 1];\n    }\n\n    return result;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: noDefaults Configuration\nDESCRIPTION: Example configuring the `noDefaults` option in the Effector Babel plugin for making custom unit factories with clean configuration.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"noDefaults\": false\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Import useGate from effector-vue\nDESCRIPTION: Imports the `useGate` function from the `effector-vue/composition` module. This function is used to integrate Effector Gates with Vue 3 components for managing data flow.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useGate.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useGate } from \"effector-vue/composition\";\n```\n\n----------------------------------------\n\nTITLE: API Index (Typescript)\nDESCRIPTION: Creates an index file for the API to aggregate all of the individual API calls. Also exports the types.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/shared/api/index.ts\nexport * as messageApi from \"./message\";\nexport * as sessionApi from \"./session\";\n\n// Types reexports made just for convenience\nexport type { Message } from \"./message\";\nexport type { Session } from \"./session\";\n```\n\n----------------------------------------\n\nTITLE: Using createWatch with Scope (JavaScript)\nDESCRIPTION: This example demonstrates how to use `createWatch` with a specified scope. It creates an event, forks a scope, creates a watch on the event within that scope, and then triggers the event within the scope.  Only events triggered within the specified scope will invoke the `fn` function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createWatch.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createWatch, createEvent, fork, allSettled } from \"effector\";\n\nconst changeName = createEvent();\n\nconst scope = fork();\n\nconst unwatch = createWatch({ unit: changeName, scope, fn: console.log });\n\nawait allSettled(changeName, { scope, params: \"John\" }); // output: John\nchangeName(\"John\"); // no output\n```\n\n----------------------------------------\n\nTITLE: Combining Stores with Transformation (object, function)\nDESCRIPTION: This snippet demonstrates how to combine stores using an object to map store to parameter names and a transformation function.  The state from each store is read and assigned to its corresponding field within an object.  That object is then passed into the function.  The function must be pure.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/combine.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst $a: Store<A>;\nconst $b: StoreWritable<B>;\nconst $c: Store<C> | StoreWritable<C>;\n\n$result: Store<D> = combine(\n  { a: $a, b: $b, c: $c },\n  ({ a, b, c }: { a: A; b: B; c: C }): D => result,\n);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using an Effector Effect (JavaScript)\nDESCRIPTION: This JavaScript code shows how to create an Effector effect using `createEffect` for handling asynchronous operations, such as fetching data from an API. It also demonstrates how to subscribe to the `done` and `fail` events of the effect to handle successful results and errors, respectively.  The `effector` library is required.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/core-concepts.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchUserFx = createEffect(async (userId) => {\n  const response = await fetch(`/api/user/${userId}`);\n  return response.json();\n});\n\n// Подписываемся на результат эффекта\nfetchUserFx.done.watch(({ result }) => console.log(\"Данные пользователя:\", result));\n// Если эффект выкинет ошибку, то мы отловим ее при помощи события fail\nfetchUserFx.fail.watch(({ error }) => console.log(\"Произошла ошибка! \", error));\n\n// Запускаем эффект\nfetchUserFx(1);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scope Loss in JavaScript\nDESCRIPTION: This code illustrates how scope loss can occur in JavaScript when dealing with asynchronous operations.  It demonstrates how the scope can become `undefined` after an asynchronous call, highlighting the importance of managing scope in asynchronous contexts.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// out current scope\nlet scope;\n\nfunction process() {\n  try {\n    scope = \"effector\";\n    asyncProcess();\n  } finally {\n    scope = undefined;\n    console.log(\"scope is undefined\");\n  }\n}\n\nasync function asyncProcess() {\n  console.log(\"here is ok\", scope); // effector\n\n  await 1;\n\n  // here we already lost context\n  console.log(\"but here is not ok \", scope); // undefined\n}\n\nprocess();\n\n// Output:\n// here is ok effector\n// scope is undefined\n// but here is not ok undefined\n```\n\n----------------------------------------\n\nTITLE: Deep clearNode usage with event trigger\nDESCRIPTION: This example demonstrates a \"deep\" clear, using the `deep: true` config option, which removes not only the specified node (`trigger`), but also all of its computed values and dependent units. After the `clearNode` call, neither `trigger` nor `inc` nor `$store` will react to events.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/clearNode.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, clearNode } from \"effector\";\n\nconst inc = createEvent();\nconst trigger = inc.prepend(() => {});\nconst $store = createStore(0).on(inc, (x) => x + 1);\n\ntrigger.watch(() => console.log(\"trigger called\"));\ninc.watch(() => console.log(\"inc called\"));\n$store.watch((x) => console.log(\"store state: \", x));\n// => store state: 0\ntrigger();\n// => trigger called\n// => inc called\n// => store state: 1\nclearNode(trigger, { deep: true });\ntrigger();\n// no reaction\ninc();\n// no reaction!\n// all units, which depend on trigger, are erased\n// including inc and store, because it depends on inc\n```\n\n----------------------------------------\n\nTITLE: Effector onCreateDomain Hook Example\nDESCRIPTION: This example demonstrates how to use the `onCreateDomain` hook to log a message to the console every time a new subdomain is created in the domain. It creates a domain and then defines a callback function that logs a message when a new domain is created.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Domain.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createDomain } from \"effector\";\n\nconst domain = createDomain();\n\ndomain.onCreateDomain((domain) => {\n  console.log(\"new domain created\");\n});\n\nconst a = domain.createDomain();\n// => new domain created\n\nconst b = domain.createDomain();\n// => new domain created\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with Types\nDESCRIPTION: Demonstrates the type definitions for attaching effects, ensuring type compatibility between the parameters of the attached effect and the original effect, handling cases where the attached effect is called without arguments, and highlighting potential type issues when `mapParams` throws exceptions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst originalFx: Effect<A, Done, Fail>;\n\nconst attachedFx: Effect<B, Done, Fail> = attach({\n  effect: originalFx,\n  mapParams: (params: B): A {},\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst attachedFx: Effect<void, Done, Fail> = attach({\n  effect: originalFx,\n  mapParams: (): A {},\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst attachedFx: Effect<void, Done, Fail> = attach({\n  effect: originalFx,\n  mapParams: (): A {\n    throw new AnyNonFailType(); // Это может быть несовместимо с типом `Fail`.\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: useList Basic Usage Example\nDESCRIPTION: Demonstrates a basic use case of the useList hook with a simple array of users. It renders a list of user names, each with an index, fetched from an effector store.  It imports `createStore` from effector and `useList` from effector-react.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useList.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { useList } from \"effector-react\";\n\nconst $users = createStore([\n  { id: 1, name: \"Yung\" },\n  { id: 2, name: \"Lean\" },\n  { id: 3, name: \"Kyoto\" },\n  { id: 4, name: \"Sesh\" },\n]);\n\nconst App = () => {\n  const list = useList($users, ({ name }, index) => (\n    <li>\n      [{index}] {name}\n    </li>\n  ));\n\n  return <ul>{list}</ul>;\n};\n\n```\n\n----------------------------------------\n\nTITLE: Effector SWC Plugin factories Configuration\nDESCRIPTION: This JSON snippet shows an example configuration for the `factories` option of the Effector SWC plugin. It specifies an array of module names or files to treat as custom factories, ensuring unique SIDs across the application.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"factories\": [\"./path/to/factory\", \"factory-package\"] }]\n```\n\n----------------------------------------\n\nTITLE: Composite Name Example in Effector (TypeScript)\nDESCRIPTION: This snippet shows how to access and interpret the `compositeName` property of Effector events, illustrating how it reflects the hierarchical structure of units within an application, particularly when using domains. It demonstrates the difference in `compositeName` for an event created directly and one created within a domain.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createDomain } from \"effector\";\n\nconst first = createEvent();\nconst domain = createDomain();\nconst second = domain.createEvent();\n\nconsole.log(first.compositeName);\n// => { shortName: \"first\", fullName: \"first\", path: [\"first\"] }\n\nconsole.log(second.compositeName);\n// => { shortName: \"second\", fullName: \"domain/second\", path: [\"domain\", \"second\"] }\n```\n\n----------------------------------------\n\nTITLE: Effector Factory Function Example (JS)\nDESCRIPTION: Demonstrates a typical factory function that would be identified by the `factories` configuration option of the effector/babel-plugin.  It creates and returns an Effector store. Requires effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_9\n\nLANGUAGE: js\nCODE:\n```\n// ./src/createEffectStatus.js\nimport { rootDomain } from \"./rootDomain\";\n\nexport function createEffectStatus(fx) {\n  const $status = rootDomain.createStore(\"init\").on(fx.finally, (_, { status }) => status);\n\n  return $status;\n}\n```\n\n----------------------------------------\n\nTITLE: useStoreMap Formula with Store and Function\nDESCRIPTION: Illustrates the type signature of `useStoreMap` when used with a store and a selector function.  The selector function transforms the store's state into a derived value, and the component re-renders only when this derived value changes. The accessor returned allows the Solid component to access the derived value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useStoreMap.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nuseStoreMap(\n  $store: Store<State>,\n  fn: (state: State) => Result,\n): Accessor<Result>;\n```\n\n----------------------------------------\n\nTITLE: Types of event calls - Typescript\nDESCRIPTION: Demonstrates event creation with and without generic type arguments.  This example show `someHappened` event, and `anotherHappened` event with `void` argument type by default.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, Event } from \"effector\";\n\nconst someHappened = createEvent<number>();\n// someHappened: EventCallable<number>\nsomeHappened(1);\n\nconst anotherHappened = createEvent();\n// anotherHappened: EventCallable<void>\nanotherHappened();\n```\n\n----------------------------------------\n\nTITLE: Import scopeBind from effector\nDESCRIPTION: This code snippet shows how to import the `scopeBind` function from the effector library. This import is necessary to use the `scopeBind` functionality in your application.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/scopeBind.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { scopeBind } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Creating an Effector Store\nDESCRIPTION: This code snippet demonstrates how to create a store in Effector. The `createStore` function is used to initialize a store with an initial value (0 in this case). The store, named `$counter`, holds the application state related to a counter.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"effector\";\n\nconst $counter = createStore(0);\n```\n\n----------------------------------------\n\nTITLE: Message Effects (Typescript)\nDESCRIPTION: Defines Effector effects for loading, sending, and deleting messages. `messagesLoadFx` loads message history from localStorage. `messageSendFx` sends a new message and saves it. `messageDeleteFx` deletes a message.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/shared/api/message.ts\n// Здесь эффект определен со статическими типами. Void определяет отсутствие аргументов.\n// Второй аргумент в типе определяет тип успешного результата.\n// Третий аргумент является необязательным и определяет тип неудачного результата.\nexport const messagesLoadFx = createEffect<void, Message[], Error>(async () => {\n  const history = loadHistory();\n  await wait();\n  return history ?? [];\n});\n\ninterface SendMessage {\n  text: string;\n  author: Author;\n}\n\n// Но мы можем использовать вывод типов и задавать типы аргументов в определении обработчика.\n// Наведите курсор на `messagesLoadFx`, чтобы увидеть выведенные типы:\n// `Effect<{ text: string; authorId: string; authorName: string }, void, Error>`\nexport const messageSendFx = createEffect(async ({ text, author }: SendMessage) => {\n  const message: Message = {\n    id: createOid(),\n    author,\n    timestamp: Date.now(),\n    text,\n  };\n  const history = await messagesLoadFx();\n  saveHistory([...history, message]);\n  await wait();\n});\n\n// Пожалуйста, обратите внимание, что мы будем использовать `wait()` для `messagesLoadFx` и `wait()` в текущем эффекте\n// Также, обратите внимание, что `saveHistory` и `loadHistory` могут выбрасывать исключения,\n// в этом случае эффект вызовет событие `messageDeleteFx.fail`.\nexport const messageDeleteFx = createEffect(async (message: Message) => {\n  const history = await messagesLoadFx();\n  const updated = history.filter((found) => found.id !== message.id);\n  await wait();\n  saveHistory(updated);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating and subscribing to an Event - Effector (JavaScript)\nDESCRIPTION: This snippet showcases how to create an event using `createEvent` from Effector and subscribe to it using the `watch` method. When the event is triggered, the provided callback function will be executed. This demonstrates a basic example of how events act as entry points for reactive data flows.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/core-concepts.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\n// create event\nconst formSubmitted = createEvent();\n\n// subscribe to the event\nformSubmitted.watch(() => console.log(\"Form submitted!\"));\n\n// Trigger the event\nformSubmitted();\n\n// Output:\n// \"Form submitted!\"\n```\n\n----------------------------------------\n\nTITLE: useStoreMap Example Usage\nDESCRIPTION: Demonstrates how to use `useStoreMap` to extract specific user data from a store containing a list of users. It uses the `keys` option to specify the `id` as a dependency, ensuring that the `User` component only re-renders when the data for that specific user changes.  It imports from effector, and effector-react.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useStoreMap.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { useUnit, useStoreMap } from \"effector-react\";\n\nconst data = [\n  {\n    id: 1,\n    name: \"Yung\",\n  },\n  {\n    id: 2,\n    name: \"Lean\",\n  },\n  {\n    id: 3,\n    name: \"Kyoto\",\n  },\n  {\n    id: 4,\n    name: \"Sesh\",\n  },\n];\n\nconst $users = createStore(data);\nconst $ids = createStore(data.map(({ id }) => id));\n\nconst User = ({ id }) => {\n  const user = useStoreMap({\n    store: $users,\n    keys: [id],\n    fn: (users, [userId]) => users.find(({ id }) => id === userId),\n  });\n\n  return (\n    <div>\n      <strong>[{user.id}]</strong> {user.name}\n    </div>\n  );\n};\n\nconst UserList = () => {\n  const ids = useUnit($ids);\n  return ids.map((id) => <User key={id} id={id} />);\n};\n```\n\n----------------------------------------\n\nTITLE: Watching Effector Events with createWatch\nDESCRIPTION: This snippet shows how to use `createWatch` to monitor Effector events.  It creates two events, connects them with `sample`, and then uses `createWatch` to log a message whenever either event is triggered.  `createWatch` is useful for basic debugging and logging within the application.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, sample, createWatch } from \"effector\";\n\nconst firstTriggered = createEvent<void>();\nconst secondTriggered = createEvent<void>();\n\nsample({\n  clock: firstTriggered,\n  target: secondTriggered,\n});\n\nuserClicked(\"value\");\n\nconst unwatch = createWatch({\n  unit: [firstTriggered, secondTriggered],\n  fn: (payload) => {\n    console.log(\"[event] triggered\");\n  },\n});\n\nfirstTriggered();\n\n// => [event] triggered\n// => [event] triggered\n```\n\n----------------------------------------\n\nTITLE: Effector Store and Event Definition\nDESCRIPTION: This code snippet defines a simple counter store and an event to increment the counter. It uses createStore to initialize the store and createEvent to define the event. The store is then updated when the event is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/testing.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst counterIncremented = createEvent();\n\nconst $counter = createStore(0);\n\n$counter.on(counterIncremented, (counter) => counter + 1);\n```\n\n----------------------------------------\n\nTITLE: Creating an Event with Payload\nDESCRIPTION: Shows how to create an event that accepts a single argument passed as a payload object.  The `requestReceived` event is created to handle an object containing an `id` and `title`. It imports `createEvent` from the `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/events.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst requestReceived = createEvent<{ id: number; title: string }>();\n\nrequestReceived({ id: 1, title: \"example\" });\n```\n\n----------------------------------------\n\nTITLE: Generating Usernames Using unique-names-generator in TypeScript\nDESCRIPTION: Imports `uniqueNamesGenerator` from the `unique-names-generator` library to generate random usernames for user sessions. It is configured to use names from the `starWars` dictionary.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// File: /src/shared/api/session.ts\nimport { uniqueNamesGenerator, Config, starWars } from \"unique-names-generator\";\n\nconst nameGenerator: Config = { dictionaries: [starWars] };\nconst createName = () => uniqueNamesGenerator(nameGenerator);\n```\n\n----------------------------------------\n\nTITLE: Observing Effector Effect State\nDESCRIPTION: Demonstrates how to observe the pending, done, fail, and finally states of an Effector effect. It logs messages indicating the effect's status and results/errors. Requires effector package. Takes username as input.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createEffect.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect(async ({ name }) => {\n  const url = `https://api.github.com/users/${name}/repos`;\n  const req = await fetch(url);\n  return req.json();\n});\n\nfetchUserReposFx.pending.watch((pending) => {\n  console.log(`effect is pending?: ${pending ? \"yes\" : \"no\"}`);\n});\n\nfetchUserReposFx.done.watch(({ params, result }) => {\n  console.log(params); // {name: 'zerobias'}\n  console.log(result); // разрешенное значение, результат\n});\n\nfetchUserReposFx.fail.watch(({ params, error }) => {\n  console.error(params); // {name: 'zerobias'}\n  console.error(error); //  отклоненное значение, ошибка\n});\n\nfetchUserReposFx.finally.watch(({ params, status, result, error }) => {\n  console.log(params); // {name: 'zerobias'}\n  console.log(`handler status: ${status}`);\n\n  if (error) {\n    console.log(\"handler rejected\", error);\n  } else {\n    console.log(\"handler resolved\", result);\n  }\n});\n\nawait fetchUserReposFx({ name: \"zerobias\" });\n```\n\n----------------------------------------\n\nTITLE: Remove Reducer with `.off()` (JavaScript)\nDESCRIPTION: Removes a reducer from a store using the `.off()` method.  This prevents the store from updating based on the specified trigger event (`changed`). In the example the store update is removed right after it has been defined.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore, merge } from \"effector\";\n\nconst changedA = createEvent();\nconst changedB = createEvent();\n\nconst $store = createStore(0);\nconst changed = merge([changedA, changedB]);\n\n$store.on(changed, (state, params) => state + params);\n$store.off(changed);\n```\n\n----------------------------------------\n\nTITLE: Creating Effect Hook Type Definition\nDESCRIPTION: Illustrates the type definition for `onCreateEffect`, showing that it accepts a function that takes an `Effect` as input. This hook allows executing custom logic whenever a new effect is created within the domain.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Domain.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\ndomain.onCreateEffect((effect) => {});\n```\n\n----------------------------------------\n\nTITLE: Fork with effect handlers - TS\nDESCRIPTION: This TypeScript code shows how to use the `handlers` option of the `fork` function to replace the default handlers for effects within a forked scope. It illustrates three different ways to define the handlers: using an array of tuples, a Map, or a plain object. The example showcases the array of tuples implementation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/fork.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nfork({\n  handlers: [\n    [getMessageFx, (params) => ({ id: 0, text: \"message\" })],\n    [getUserFx, async (params) => ({ name: \"alice\", age: 21 })],\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with pnpm\nDESCRIPTION: This command installs the Effector library using pnpm, a performant package manager for JavaScript.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm install effector\n```\n\n----------------------------------------\n\nTITLE: Prepending Data to Effect with prepend() - Typescript\nDESCRIPTION: Creates an event trigger to transform data before the effect is launched. When the trigger event is called, the handler function is called with the incoming data, and then the effect is called with the result of the calculation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fx: Effect<S, any>\n\nconst trigger = fx.prepend(/*fn*/(data: T) => S)\n-> Event<T>\n```\n\n----------------------------------------\n\nTITLE: Defining Message Interface in TypeScript\nDESCRIPTION: Defines the `Author` and `Message` interfaces for representing chat messages. The `Message` interface includes the message ID, author information, text content, and timestamp.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// File: /src/shared/api/message.ts\ninterface Author {\n  id: string;\n  name: string;\n}\n\nexport interface Message {\n  id: string;\n  author: Author;\n  text: string;\n  timestamp: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_15\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/vsvirydau-cl>\n            <img src=https://avatars.githubusercontent.com/u/55260532?v=4 width=\"100;\"  alt=Vasili Svirydau/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Vasili Svirydau</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Usage of Custom Factory\nDESCRIPTION: Illustrates how to use a custom factory, `createBooleanStore`, within a component. This demonstrates the context in which the SWC plugin recognizes and processes the factory.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// файл: /src/widget/user.ts\nimport { createBooleanStore } from \"../factory\";\n\nconst $boolean = createBooleanStore(); /* Рассматривается как фабрика! */\n```\n\n----------------------------------------\n\nTITLE: Using scopeBind with the safe option in Effector (TS)\nDESCRIPTION: This code snippet demonstrates how to use `scopeBind` with the `safe: true` option. When `safe` is set to `true`, it prevents errors from being thrown if the scope is not found, allowing the application to continue running even if the scope is lost.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/troubleshooting.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst scopeEvent = scopeBind(event, {\n  safe: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_38\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/gzaripov>\n        <img src=https://avatars.githubusercontent.com/u/15311091?v=4 width=\"100;\"  alt=Grigory Zaripov/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Grigory Zaripov</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_9\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/xxxxue>\n            <img src=https://avatars.githubusercontent.com/u/32764266?v=4 width=\"100;\"  alt=xxxxue/>\n            <br />\n            <sub style=\"font-size:14px\"><b>xxxxue</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Triggering Navigation from a React Component (JavaScript)\nDESCRIPTION: This snippet shows how to trigger navigation from a React component using the `navigationTriggered` event. It uses the `useUnit` hook from 'effector-react' to get the event trigger function and attaches it to a button's `onClick` handler. It requires 'effector-react' and '@/your-path-name' dependencies and needs to be a client component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/nextjs/router.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n'use client';\n\nimport { useUnit } from 'effector-react';\nimport { navigationTriggered } from '@/your-path-name';\n\n    ...\n\nexport function goToSomeRouteNameButton() {\n  const goToSomeRouteName = useUnit(navigationTriggered);\n\n  return (\n    <button onClick={() => goToSomeRouteName('/some-route-name')}>\n      do it!\n    </button>\n  );\n}\n\n\n```\n\n----------------------------------------\n\nTITLE: Sample typing with Return Event\nDESCRIPTION: Demonstrates `sample` return value when creating derived event. Return value depends on source type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/unit-composition.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, sample } from \"effector\";\n\nconst $store = createStore(0);\n\nconst submitted = createEvent<string>();\n\nconst event = sample({\n  clock: submitted,\n  source: $store,\n});\n// event has type Event<number>\n\nconst secondSampleEvent = sample({\n  clock: submitted,\n  source: $store,\n  fn: () => true,\n});\n// Event<true>\n```\n\n----------------------------------------\n\nTITLE: Testing Effector Counter Logic\nDESCRIPTION: This snippet tests the main case scenario of the Effector counter logic. It initializes a scope, asserts the initial count, triggers the button click event, and asserts that the count increments to 1. This test uses the real API backend, which should be mocked in a unit test.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/testing.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fork, allSettled } from \"effector\";\n\nimport { $clicksCount, buttonClicked, validateClickFx } from \"./model\";\n\ntest(\"main case\", async () => {\n  const scope = fork(); // 1\n\n  expect(scope.getState($clicksCount)).toEqual(0); // 2\n\n  await allSettled(buttonClicked, { scope }); // 3\n\n  expect(scope.getState($clicksCount)).toEqual(1); // 4\n});\n```\n\n----------------------------------------\n\nTITLE: forward Signature (TypeScript)\nDESCRIPTION: Illustrates the type declarations for the `forward` function, demonstrating how events, effects, and stores can be connected. It shows the different combinations of `from` and `to` parameters using events, effects, and stores as source and target units.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/forward.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const a: Event<T>\ndeclare const fxA: Effect<T, any>\ndeclare const $a: Store<T>\n\ndeclare const b: Event<T>\ndeclare const fxB: Effect<T, any>\ndeclare const $b: Store<T>\n\nforward({from: a, to: b})\nforward({\n  from: fxA,\n  to:   [b, fxB, $b]\n})\nforward({\n  from: [a, fxA, $a],\n  to:   fxB\n})\nforward({\n  from: [a, fxA, $a],\n  to:   [b, fxB, $b]\n})\n-> Subscription\n```\n\n----------------------------------------\n\nTITLE: Installing effector-vue with yarn\nDESCRIPTION: This command installs effector and effector-vue using yarn. effector provides the core state management library, while effector-vue provides Vue bindings for effector.\nSOURCE: https://github.com/effector/effector/blob/master/packages/effector-vue/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add effector effector-vue\n```\n\n----------------------------------------\n\nTITLE: Store Reducer Type Definition\nDESCRIPTION: This code defines the TypeScript type for a reducer function used with Effector stores.  It takes the current state and a payload, and returns the new state or void. Returning void or the same state (`===`) will prevent the store from updating.  Dependencies: TypeScript.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/glossary.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype StoreReducer<State, E> = (state: State, payload: E) => State | void;\ntype EventOrEffectReducer<T, E> = (state: T, payload: E) => T;\n```\n\n----------------------------------------\n\nTITLE: Fork with Domain and options - TS\nDESCRIPTION: This TypeScript code outlines the function signature for using fork with a domain and options. While the example is TBD (to be determined), it showcases how to fork a specific domain and provide initial values and handlers.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/fork.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nfork(domain: Domain, options?: { values?, handlers? }): Scope\n```\n\n----------------------------------------\n\nTITLE: Using useEvent with an object of Effector units\nDESCRIPTION: This snippet demonstrates using `useEvent` with an object containing Effector events. It binds `inc` and `dec` events, accessing them as `handlers.inc` and `handlers.dec`. Similar to the previous examples, it leverages `useStore` to get the current count and provides buttons to increment and decrement the counter, all within an `effector-react` setup.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useEvent.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport ReactDOM from \"react-dom\";\nimport { createEvent, createStore, fork } from \"effector\";\nimport { useStore, useEvent, Provider } from \"effector-react\";\n\nconst inc = createEvent();\nconst dec = createEvent();\nconst $count = createStore(0)\n  .on(inc, (x) => x + 1)\n  .on(dec, (x) => x - 1);\n\nconst App = () => {\n  const count = useStore($count);\n  const handlers = useEvent({ inc, dec });\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => handlers.inc()}>increment</button>\n      <button onClick={() => handlers.dec()}>decrement</button>\n    </>\n  );\n};\n\nconst scope = fork();\n\nReactDOM.render(\n  <Provider value={scope}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Importing createWatch from Effector (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to import the `createWatch` function from the Effector library using TypeScript.  `createWatch` is used to create subscriptions to Effector units (stores, events, effects).\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createWatch.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createWatch } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Correct Event Usage with Sample\nDESCRIPTION: Demonstrates the correct usage by connecting events using the `sample` operator. This operator ensures proper data flow and avoids the error of calling units from pure functions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst someHappened = createEvent<number>();\nconst another = createEvent();\nconst derived = createEvent<string>();\n\nsample({\n  clock: someHappened,\n  target: another,\n});\n\n// То же самое, что и .map(), но с использованием `target`\nsample({\n  clock: someHappened,\n  fn: (number) => String(number),\n  target: derived,\n});\n```\n\n----------------------------------------\n\nTITLE: Computation Priority Example\nDESCRIPTION: Demonstrates the computation priority in effector using `createEffect` and `watch`. It shows how side effects within `watch` are executed after the effect's handler and how `watch` callbacks can introduce additional side effects. The example highlights the order in which side effects are processed based on the priority queue.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/computation-priority.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nlet count = 0;\nconst fx = createEffect(() => {\n  // side effect 1\n  count += 1;\n});\n\nfx.done.watch(() => {\n  // side effect 1 already executed\n  console.log(\"expect count to be 1\", count === 1);\n  // side effect 2\n  count += 1;\n});\n\nfx();\n// side effect 1 already executed\n// side effect 2 already executed as well\n// that's what we expected to happen\n// that's watchmen effect\nconsole.log(\"expect count to be 2\", count === 2);\n// example which violated that agreement: setState in react\n// which defer any side effect long after setState call itself\n```\n\n----------------------------------------\n\nTITLE: Effector factory TypeScript Example\nDESCRIPTION: This TypeScript code defines a simple factory function `createBooleanStore` that creates an Effector store with an initial value of `true`.  It serves as an example of a custom factory that can be used with the Effector SWC plugin.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// file: /src/factory.ts\nimport { createStore } from \"effector\";\n\n/* createBooleanStore is a factory */\nexport const createBooleanStore = () => createStore(true);\n```\n\n----------------------------------------\n\nTITLE: Basic Effector Domain History Example\nDESCRIPTION: This example shows how to create a domain and add an event and a store to it. The `domain.history` property is then logged to the console, showing the sets of stores and events contained within the domain.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Domain.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createDomain } from \"effector\";\nconst domain = createDomain();\nconst eventA = domain.event();\nconst $storeB = domain.store(0);\nconsole.log(domain.history);\n// => {stores: Set{storeB}, events: Set{eventA}, domains: Set, effects: Set}\n```\n\n----------------------------------------\n\nTITLE: Import createGate and Gate type - TypeScript\nDESCRIPTION: Imports the `createGate` function and the `Gate` type from the `effector-react` library. This is necessary to create and use gates in Effector React applications.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/createGate.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createGate, type Gate } from \"effector-react\";\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_31\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/miyaokamarina>\n            <img src=https://avatars.githubusercontent.com/u/37388187?v=4 width=\"100;\"  alt=Eris/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Eris</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: `match` as Store Example in Effector split\nDESCRIPTION: This example demonstrates using a store as the `match` parameter in the `split` method. The value of the store (`$currentTab`) is used as a key to select the appropriate case.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/flow-split.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nconst $currentTab = createStore(\"home\");\n\nsplit({\n  source: pageNavigated,\n  match: $currentTab,\n  cases: {\n    home: loadHomeDataFx,\n    profile: loadProfileDataFx,\n    settings: loadSettingsDataFx,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Merging Store and Event (Javascript)\nDESCRIPTION: Illustrates merging a store and an event.  The merged event is triggered when the store updates or when the event is triggered. The watch callback receives the payload of either the store update or the event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/merge.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore, merge } from \"effector\";\n\nconst setFoo = createEvent();\nconst otherEvent = createEvent();\n\nconst $foo = createStore(0).on(setFoo, (_, v) => v);\n\nconst merged = merge([$foo, otherEvent]);\n\nmerged.watch((v) => console.log(`merged event payload: ${v}`));\n\nsetFoo(999);\n// => merged event payload: 999\n\notherEvent(\"bar\");\n// => merged event payload: bar\n```\n\n----------------------------------------\n\nTITLE: Effector noDefaults Configuration (JSON)\nDESCRIPTION: Configures the `noDefaults` option for effector/babel-plugin, which creates custom unit factories with a clean configuration. Requires a Babel environment and effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"noDefaults\": false\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Effector addLoc Configuration (JSON)\nDESCRIPTION: Configures the `addLoc` option in effector/babel-plugin, which adds location information to method calls. This is primarily used by development tools like effector-logger.  Requires a Babel environment and effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"addLoc\": false\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with npm\nDESCRIPTION: This command installs the core Effector library using the npm package manager. It is a prerequisite for using Effector in a JavaScript project.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector\n```\n\n----------------------------------------\n\nTITLE: useStoreMap Formula with Configuration Object\nDESCRIPTION: Defines the type signature of `useStoreMap` when used with a configuration object.  The config object includes a store, keys to pass to the selector, the selector function itself, and an optional `updateFilter` function to prevent unnecessary re-renders by comparing old and new results.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useStoreMap.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nuseStoreMap({\n  store: Store<State>,\n  keys: any[],\n  fn: (state: State, keys: any[]) => Result,\n  updateFilter? (newResult, oldResult) => boolean,\n}): Result;\n```\n\n----------------------------------------\n\nTITLE: createStore with SID\nDESCRIPTION: Shows how the Effector plugin transforms the basic `createStore` example by adding a `sid` option. This `sid` is a unique identifier generated by the plugin based on the source code location. This ensures stable and unique identification of the store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst $name = createStore(null, { sid: \"j3l44\" });\n```\n\n----------------------------------------\n\nTITLE: Effector Sample with Effect\nDESCRIPTION: This example shows how to create a store, an effect, and an event.  It uses sample to pass data from a store, transformed by a function, into an effect when the event is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/sample.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst $userName = createStore(\"john\");\nconst signIn = createEffect((params) => {\n  console.log(params);\n});\nconst submitForm = createEvent();\n\nsample({\n  clock: submitForm /* 1 */,\n  source: $userName /* 2 */,\n  fn: (name, password) => ({ name, password }) /* 3 */,\n  target: signIn /* 4 */,\n});\n\nsubmitForm(12345678);\n// 1. при вызове submitForm с аргументом 12345678\n// 2. прочитать значение из стора $userName ('john')\n// 3. преобразовать значение из submitForm (1) и $userName (2)\n// 4. и передать результат вычислений в эффект signIn\n```\n\n----------------------------------------\n\nTITLE: val function definition\nDESCRIPTION: Defines the `val` helper function which joins properties to a single string using template literals.  It is overloaded to accept both plain values and stores of plain values.  The return type depends on the input; if all values are plain, a string is returned, otherwise a Store<string> is returned.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nfunction val(words: TemplateStringsArray, ...values: Property[]): Store<string>\n\nfunction val(words: TemplateStringsArray, ...values: PlainProperty[]): string\n```\n\n----------------------------------------\n\nTITLE: Effector SWC Plugin HMR Configuration\nDESCRIPTION: This JSON snippet shows an example configuration for the `hmr` option of the Effector SWC plugin. It enables Hot Module Replacement (HMR) support to clean up links, subscriptions, and side effects managed by Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"hmr\": \"es\" }]\n```\n\n----------------------------------------\n\nTITLE: Effector Store and Event Sample (Declarative)\nDESCRIPTION: This JavaScript code snippet shows a declarative way of handling store updates using Effector's `sample` function. It creates a store named `login`, maps its value to `loginSize`, and then uses `sample` to trigger the `submitLoginSize` event whenever `loginSize` changes. This approach is considered more idiomatic in Effector. Requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/glossary.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { createStore, createEvent, sample } from \"effector\";\n\nconst login = createStore(\"guest\");\n\nconst loginSize = login.map((login) => login.length);\n\nconst submitLoginSize = createEvent();\n\nsample({\n  clock: loginSize,\n  target: submitLoginSize,\n});\n```\n\n----------------------------------------\n\nTITLE: Correct Event Call using sample\nDESCRIPTION: Demonstrates the correct way to derive and call the event, using the `sample` operator to connect two events by passing data from the source to the target. The `stringifiedReceived` event will receive the data as a string.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberReceived = createEvent<number>();\nconst stringifiedReceived = createEvent<string>();\n\nsample({\n  clock: numberReceived,\n  fn: (number) => String(number),\n  target: stringifiedReceived,\n});\n\nstringifiedReceived(\"123\"); // ОК\n```\n\n----------------------------------------\n\nTITLE: StoreValue Type Example - Typescript\nDESCRIPTION: Illustrates how to extract the value type of an effector Store using the `StoreValue` type utility. This is useful for defining types based on the store's state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type StoreValue } from \"effector\";\n\nconst $store: Store<Value>;\ntype Value = StoreValue<typeof $store>;\n```\n\n----------------------------------------\n\nTITLE: Sample Data Transformation - Typescript\nDESCRIPTION: Demonstrates how to transform data using the `fn` parameter of `sample`. It takes the user data from the `$user` store and transforms it into a string, which is then assigned to the `$userInfo` store. The transformation occurs when `buttonClicked` is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, sample } from \"effector\";\n\nconst buttonClicked = createEvent();\nconst $user = createStore({ name: \"Bob\", age: 25 });\nconst $userInfo = createStore(\"\");\n\nsample({\n  clock: buttonClicked,\n  source: $user,\n  fn: (user) => `${user.name} is ${user.age} years old`,\n  target: $userInfo,\n});\n```\n\n----------------------------------------\n\nTITLE: Create Name (Typescript)\nDESCRIPTION: Uses the `unique-names-generator` to create a random name.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/shared/api/session.ts\nimport { uniqueNamesGenerator, Config, starWars } from \"unique-names-generator\";\n\nconst nameGenerator: Config = { dictionaries: [starWars] };\nconst createName = () => uniqueNamesGenerator(nameGenerator);\n```\n\n----------------------------------------\n\nTITLE: Effector Sample with Alternative Syntax\nDESCRIPTION: Illustrates an alternative syntax for `sample` where the target is implicit.  It combines a store, an event, and a transformation function and then attaches the resulting sample unit to an effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/sample.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst $userName = createStore(\"john\");\nconst signIn = createEffect((params) => {\n  console.log(params);\n});\nconst submitForm = createEvent();\n\nconst sampleUnit = sample(\n  $userName /* 2 */,\n  submitForm /* 1 */,\n  (name, password) => ({ name, password }) /* 3 */,\n);\n\nsample({\n  clock: sampleUnit,\n  target: signIn /* 4 */,\n});\n\nsubmitForm(12345678);\n// 1. при вызове submitForm с аргументом 12345678\n// 2. прочитать значение из стора $userName ('john')\n// 3. преобразовать значение из submitForm (1) и $userName (2)\n// 4. и передать результат вычислений в эффект signIn\n```\n\n----------------------------------------\n\nTITLE: Import useList from effector-react (TS)\nDESCRIPTION: Imports the `useList` hook from the `effector-react` library. This hook is used for efficient rendering of list stores in React applications.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useList.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useList } from \"effector-react\";\n```\n\n----------------------------------------\n\nTITLE: Import from effector-vue/ssr\nDESCRIPTION: This code snippet shows how to import from the deprecated `effector-vue/ssr` module. Note that since effector 23.0.0, the core team recommends using the main module of `effector-vue` or `effector-vue/composition` instead.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/module/ssr.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {} from \"effector-vue/ssr\";\n```\n\n----------------------------------------\n\nTITLE: Custom Factory Function\nDESCRIPTION: Example of a custom factory function that creates an Effector store and attaches it to a domain. This function is used to demonstrate the `factories` configuration option.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_10\n\nLANGUAGE: js\nCODE:\n```\n// ./src/createEffectStatus.js\nimport { rootDomain } from \"./rootDomain\";\n\nexport function createEffectStatus(fx) {\n  const $status = rootDomain.createStore(\"init\").on(fx.finally, (_, { status }) => status);\n\n  return $status;\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_13\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/Vladislav2397>\n            <img src=https://avatars.githubusercontent.com/u/53734286?v=4 width=\"100;\"  alt=Vladislav/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Vladislav</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Import restore from effector\nDESCRIPTION: Imports the `restore` function from the Effector library. This function is used to create stores initialized with a default state and updated by events or effects.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/restore.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { restore } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Store Creation with on() method\nDESCRIPTION: This code demonstrates how to create a store and update it using the `on` method. It shows how to handle `undefined` values, which is affected by the `skipVoid` option in Effector v23.  Prior to v23, `undefined` would be treated as a skip signal, this functionality will be removed and must be explicitly managed with `skipVoid: true`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/migration-guide-v23.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst $value = createStore(0).on(newValueReceived, (_oldValue, newValue) => newValue);\n```\n\n----------------------------------------\n\nTITLE: allSettled Function Signature\nDESCRIPTION: Defines the function signatures for `allSettled` when used with an Event, Effect, or Store, and a Scope, with optional parameters. It returns a Promise that resolves when all triggered effects are complete.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/allSettled.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nallSettled<T>(unit: Event<T>, {scope: Scope, params?: T}): Promise<void>\nallSettled<T>(unit: Effect<T, Done, Fail>, {scope: Scope, params?: T}): Promise<\n  | {status: 'done'; value: Done}\n  | {status: 'fail'; value: Fail}\n>\nallSettled<T>(unit: Store<T>, {scope: Scope, params?: T}): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Reset Store State with `.reset()` (JavaScript)\nDESCRIPTION: Resets a store's state to its default value using the `.reset()` method. The `$store` is reset to 0 when the `reset` event is triggered, effectively reverting any accumulated increments. Includes a watcher to track state changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst increment = createEvent();\nconst reset = createEvent();\n\nconst $store = createStore(0)\n  .on(increment, (state) => state + 1)\n  .reset(reset);\n\n$store.watch((state) => console.log(\"changed\", state));\n\nincrement();\nincrement();\nreset();\n```\n\n----------------------------------------\n\nTITLE: ClassListArray spec example\nDESCRIPTION: Illustrates usage of `ClassListArray` in a `spec` object for managing class names.  It includes a static class name 'class-name' and a dynamic class name from `$stringStore`.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nspec({\n  classList: ['class-name', $stringStore],\n})\n```\n\n----------------------------------------\n\nTITLE: createWatch with Scope (JavaScript)\nDESCRIPTION: Demonstrates the usage of `createWatch` function with a scope.  `createWatch` is used to subscribe to the `changeName` event within a specific scope, so the callback function `console.log` is only executed when the event is triggered within that scope. Requires effector's `createWatch`, `createEvent`, `fork`, and `allSettled` functions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createWatch.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createWatch, createEvent, fork, allSettled } from \"effector\";\n\nconst changeName = createEvent();\n\nconst scope = fork();\n\nconst unwatch = createWatch({ unit: changeName, scope, fn: console.log });\n\nawait allSettled(changeName, { scope, params: \"Иван\" }); // output: Иван\nchangeName(\"Иван\"); // no output\n```\n\n----------------------------------------\n\nTITLE: Fork with Domain and Options (TypeScript)\nDESCRIPTION: Shows the deprecated usage of `fork` with a `domain` argument and optional `values` and `handlers`.  While deprecated, the example highlights the original function signature.  Requires `Domain` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/fork.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nfork(domain: Domain, options?: { values?, handlers? }): Scope\n```\n\n----------------------------------------\n\nTITLE: Mapping Effect Data with map() - Typescript\nDESCRIPTION: Creates a derived event based on the effect's data. When the effect is triggered, the handler function is called with the incoming data, and then the derived event is called with the result of the calculation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fxA: Effect<T, any>\n\nconst eventB = fxA.map(/*fn*/(data: T) => S)\n-> Event<S>\n```\n\n----------------------------------------\n\nTITLE: Import createComponent from effector-react (TypeScript)\nDESCRIPTION: Imports the `createComponent` function from the `effector-react` library. This function is used to create React components that are directly connected to Effector stores, allowing for reactive updates based on store changes. It is a deprecated feature.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/createComponent.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createComponent } from \"effector-react\";\n```\n\n----------------------------------------\n\nTITLE: Effect usage in client.js\nDESCRIPTION: Code snippet demonstrating how to use an effector's effect to communicate with a worker thread. The client posts a message to the worker with the SID and handles responses using events.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\n// client.js\nimport { createEvent } from \"effector\";\nimport { getUsers } from \"./common.js\";\n\nconst onMessage = createEvent();\n\nconst worker = new Worker(\"worker.js\");\nworker.onmessage = onMessage;\n\ngetUsers.use(\n  (userID) =>\n    new Promise((rs) => {\n      worker.postMessage({ sid: getUsers.sid, userID });\n      const unwatch = onMessage.watch(({ data}) => {\n        if (data.sid !== getUsers.sid) return;\n        unwatch();\n        rs(data.result);\n      });\n    }),\n);\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Domain Creation in Effector Domain\nDESCRIPTION: Explains how to subscribe to the creation of new domains within a parent domain using `onCreateDomain`. Each time `domain.createDomain()` is called, the specified hook function executes, allowing for side effects such as logging or applying configurations to new subdomains.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Domain.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nimport { createDomain } from \"effector\";\n\nconst domain = createDomain();\n\ndomain.onCreateDomain((domain) => {\n  console.log(\"новый домен создан\");\n});\n\nconst a = domain.createDomain();\n// => новый домен создан\n\nconst b = domain.createDomain();\n// => новый домен создан\n```\n\n----------------------------------------\n\nTITLE: Check if a value is a Domain - Effector\nDESCRIPTION: This JavaScript snippet demonstrates how to use `is.domain` to check if a given value is an Effector domain. It creates a store, event, effect, and domain, then uses `is.domain` to determine their types.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/is.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain } from \"effector\";\n\nconst $store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\n\nis.domain($store);\n// => false\n\nis.domain(event);\n// => false\n\nis.domain(fx);\n// => false\n\nis.domain(createDomain());\n// => true\n\nis.domain(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: Type Safety with Events and Sample\nDESCRIPTION: Shows how TypeScript enforces type safety when using events and operators like `sample`.  The code attempts to connect two events with incompatible types using `sample`, resulting in a TypeScript error. It imports `sample` and `createEvent` from the `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/events.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample, createEvent } from \"effector\";\n\nconst someHappened = createEvent<number>();\nconst anotherHappened = createEvent<string>();\n\nsample({\n  // @ts-expect-error error:\n  // \"clock should extend target type\";\n  // targets: { clockType: number; targetType: string; }\n  clock: someHappened,\n  target: anotherHappened,\n});\n```\n\n----------------------------------------\n\nTITLE: Import VueEffector from effector-vue\nDESCRIPTION: Imports the `VueEffector` plugin from the `effector-vue` library. This import is necessary to use the plugin in a Vue 2 application for integrating with Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/VueEffectorVue2.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { VueEffector } from \"effector-vue\";\n```\n\n----------------------------------------\n\nTITLE: Create Gate with Config - TypeScript\nDESCRIPTION: Defines the type signature for `createGate` with a configuration object. The configuration object can include `defaultState`, `domain`, and `name` properties.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/createGate.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreateGate(config): Gate\n```\n\n----------------------------------------\n\nTITLE: addNames Configuration\nDESCRIPTION: Example configuring the `addNames` option in the Effector Babel plugin to add names to units factories call. This is useful for minification and obfuscation of production builds.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"addNames\": true\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Custom store creator\nDESCRIPTION: Custom function used as store creator, used in the noDefaults example.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_18\n\nLANGUAGE: js\nCODE:\n```\n// @lib/createInputField.js\nimport { createStore } from \"effector\";\nimport { resetForm } from \"./form\";\n\nexport function createInputField(defaultState, { sid, name }) {\n  return createStore(defaultState, { sid, name }).reset(resetForm);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Domain type from Effector\nDESCRIPTION: This snippet demonstrates how to import the `Domain` type from the effector library. This allows you to use the `Domain` type in your TypeScript code for type checking and annotations.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Domain.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type Domain } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: useVModel with Store Shape in Vue 3\nDESCRIPTION: Demonstrates the usage of the useVModel hook with a shape of effector stores in a Vue 3 component.  Individual stores ($name, $surname, $skills) are combined into a model object, which is then passed to the useVModel hook.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useVModel.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createApi } from \"effector\";\nimport { useVModel } from \"effector-vue/composition\";\n\nconst $name = createStore(\"\");\nconst $surname = createStore(\"\");\nconst $skills = createStore([]);\n\nconst model = {\n  name: $name,\n  surname: $surname,\n  skills: $skills,\n};\n\nexport default {\n  setup() {\n    const user = useVModel(model);\n\n    return { user };\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Importing Inspect from Effector\nDESCRIPTION: Imports the `inspect` function from the `effector/inspect` module. This is the primary function for debugging and monitoring Effector applications.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/inspect.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inspect } from \"effector/inspect\";\n```\n\n----------------------------------------\n\nTITLE: Using useEvent with a single Effector unit\nDESCRIPTION: This code snippet demonstrates how to use the `useEvent` hook with a single Effector event. It binds the `inc` event to the component's scope and provides a function `incFn` to trigger the event. The component also uses `useStore` to subscribe to the `$count` store. The example shows incrementing a counter using `effector-react` within a React component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useEvent.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport ReactDOM from \"react-dom\";\nimport { createEvent, createStore, fork } from \"effector\";\nimport { useStore, useEvent, Provider } from \"effector-react\";\n\nconst inc = createEvent();\nconst $count = createStore(0).on(inc, (x) => x + 1);\n\nconst App = () => {\n  const count = useStore($count);\n  const incFn = useEvent(inc);\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => incFn()}>increment</button>\n    </>\n  );\n};\n\nconst scope = fork();\n\nReactDOM.render(\n  <Provider value={scope}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with a `name`\nDESCRIPTION: This snippet demonstrates attaching an effect with a custom `name`. This name can be useful for debugging and identifying effects within the application. The `shortName` property of the attached effect will reflect the provided name.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attach } from \"effector\";\n\nconst attachedFx = attach({\n  name: \"anotherUsefulName\",\n  source: $store,\n  async effect(source, params: Type) {\n    // ...\n  },\n});\n\nattachedFx.shortName; // \"anotherUsefulName\"\n```\n\n----------------------------------------\n\nTITLE: Executing BrowserStack Tests\nDESCRIPTION: This command executes the BrowserStack tests for the Effector library.  It assumes that the necessary dependencies have been installed via `yarn` or `npm`. The tests will run on real devices using BrowserStack's infrastructure.\nSOURCE: https://github.com/effector/effector/blob/master/src/compat/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn browserstack\n```\n\n----------------------------------------\n\nTITLE: Configure Vite with React and Effector Babel Plugin\nDESCRIPTION: This snippet demonstrates how to configure `vite.config.js` to use the `@vitejs/plugin-react` plugin with Babel, and to integrate the `effector/babel-plugin`. It sets up the necessary Babel options within the React plugin to enable Effector's Babel transformations.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\n// vite.config.js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\nexport default defineConfig({\n  plugins: [\n    react({\n      babel: {\n        plugins: [\"effector/babel-plugin\"],\n        // Use .babelrc files\n        babelrc: true,\n        // Use babel.config.js files\n        configFile: true,\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Effector Effect failData Type\nDESCRIPTION: Declares the type for `effect.failData` event which is `Event<Fail>`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\neffect.failData: Event<Fail>;\n```\n\n----------------------------------------\n\nTITLE: Effector noDefaults Configuration Example (JSON)\nDESCRIPTION: Provides an example of configuring the `noDefaults` option in conjunction with `importName` and `storeCreators` for effector/babel-plugin. This setup allows for highly customized store creation. Requires a Babel environment and effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n// .babelrc\n{\n  \"plugins\": [\n    [\"effector/babel-plugin\", { \"addLoc\": true }],\n    [\n      \"effector/babel-plugin\",\n      {\n        \"importName\": \"@lib/createInputField\",\n        \"storeCreators\": [\"createInputField\"],\n        \"noDefaults\": true\n      },\n      \"createInputField\"\n    ]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Event Triggering within Store.map in Effector\nDESCRIPTION: This code demonstrates an anti-pattern: triggering an event directly within a `Store.map` function. This makes it harder to reason about the application's data flow and is generally discouraged.  The recommended alternative is to use `sample`. Dependencies: effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/glossary.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst submitLoginSize = createEvent();\n\nconst $login = createStore(\"guest\");\nconst $loginSize = $login.map((login) => {\n  // no! use `sample` instead\n  submitLoginSize(login.length);\n  return login.length;\n});\n```\n\n----------------------------------------\n\nTITLE: Import useStoreMap from effector-solid\nDESCRIPTION: Imports the `useStoreMap` function from the `effector-solid` library. This function is used to subscribe to an Effector store and transform its value within a SolidJS component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useStoreMap.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useStoreMap } from \"effector-solid\";\n```\n\n----------------------------------------\n\nTITLE: Binding Event to Scope with scopeBind in Effector (TypeScript)\nDESCRIPTION: This example demonstrates how to correctly bind an Effector event to the current scope using `scopeBind` when dealing with asynchronous operations like `setTimeout`. Failing to do so can lead to the event being executed in the global scope, causing unexpected behavior. The `scopeBind` function creates a scope-bound version of the event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/troubleshooting.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst event = createEvent();\n\n// ❌ - This will execute the event in the global scope\nconst effectFx = createEffect(() => {\n  setTimeout(() => {\n    event();\n  }, 1000);\n});\n\n// ✅ - This ensures the event executes in the correct scope\nconst effectFx = createEffect(() => {\n  const scopeEvent = scopeBind(event);\n  setTimeout(() => {\n    scopeEvent();\n  }, 1000);\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering and Mapping Array Elements in Effector (TSX)\nDESCRIPTION: This example demonstrates using `filterMap` to find a specific string within an array emitted by an Effector event. It creates an event that receives an array of strings and then uses `filterMap` to extract the first occurrence of the string \"effector\".\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_24\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst listReceived = createEvent<string[]>();\n\n// Array.prototype.find() returns `undefined` when no item is found\nconst effectorFound = listReceived.filterMap((list) => list.find((name) => name === \"effector\"));\n\neffectorFound.watch((name) => console.info(\"found\", name));\n\nlistReceived([\"redux\", \"effector\", \"mobx\"]); // => found effector\nlistReceived([\"redux\", \"mobx\"]);\n```\n\n----------------------------------------\n\nTITLE: Effector Sample Usage with Store\nDESCRIPTION: Demonstrates how to use `sample` with two stores, where the result is also a store because both the `clock` and `source` are stores.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/sample.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = sample({ clock: $store, source: $store });\n// Результатом будет стор, так как `source` и `clock` являются сторами\n```\n\n----------------------------------------\n\nTITLE: factories Configuration example\nDESCRIPTION: Example configuring the `factories` option in the Effector Babel plugin to specify modules with factory functions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n// .babelrc\n{\n  \"plugins\": [\n    [\n      \"effector/babel-plugin\",\n      {\n        \"factories\": [\"src/createEffectStatus\", \"~/createCommonPending\"]\n      }\n    ]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_25\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/raidenmiro>\n            <img src=https://avatars.githubusercontent.com/u/82271383?v=4 width=\"100;\"  alt=Robert Kuzhin/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Robert Kuzhin</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Store .map() Example - Javascript\nDESCRIPTION: Creates a derived store using the `.map()` method. The derived store `$length` is updated whenever the original store `$title` changes, with the value being the length of the title. This derived store then watches for changes, logging the new length to the console.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst changed = createEvent();\nconst $title = createStore(\"\").on(changed, (_, newTitle) => newTitle);\nconst $length = $title.map((title) => title.length);\n\n$length.watch((length) => {\n  console.log(\"new length\", length);\n});\n\nchanged(\"hello\");\nchanged(\"world\");\nchanged(\"hello world\");\n```\n\n----------------------------------------\n\nTITLE: Incorrect usage of Effector events without useUnit in React (JSX)\nDESCRIPTION: This code snippet shows an incorrect way of using Effector events in a React component without the `useUnit` hook. This can lead to issues with scope and unexpected behavior.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/troubleshooting.mdx#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { event } from \"./model.js\";\n\nconst Component = () => {\n  return <button onClick={() => event()}></button>;\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Store Hook Type Definition\nDESCRIPTION: Illustrates the type definition for `onCreateStore`, showing that it accepts a function that takes a `$store` as input. This hook allows executing custom logic whenever a new store is created within the domain.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Domain.md#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\ndomain.onCreateStore(($store) => {});\n```\n\n----------------------------------------\n\nTITLE: Using Array of Units in clock with Effector (JavaScript)\nDESCRIPTION: This snippet shows how to use an array of units (events and effects) as the `clock` in the `sample` function. It demonstrates that passing an array of units to `clock` is equivalent to using `merge` to combine those units into a single event. The `showNotification` event is triggered by either the `trigger` event or the `fx.doneData` event, using the value from the `store` as the source.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/sample.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createStore, createEvent, createEffect, sample, merge} from 'effector'\n\nconst showNotification = createEvent<string>()\nconst trigger = createEvent()\nconst fx = createEffect()\nconst store = createStore('')\n\n// массив юнитов в `clock`\nsample({\n  clock: [trigger, fx.doneData],\n  source: store,\n  target: showNotification,\n})\n\n// объединённый юнит в `clock`\nsample({\n  clock: merge([trigger, fx.doneData]),\n  source: store,\n  target: showNotification,\n})\n```\n\n----------------------------------------\n\nTITLE: Inspect for Error Handling\nDESCRIPTION: Demonstrates how to use `inspect` to capture and handle errors that occur during Effector computations.  It checks for messages of type \"error\" and logs details about the failed computation, including the kind, name, and the error itself. Effector stops computations in pure functions when exceptions occur.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/inspect.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninspect({\n  fn: (m) => {\n    if (m.type === \"error\") {\n      // сделать что-то с этим\n      console.log(`${m.kind} ${m.name} computation has failed with ${m.error}`);\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Tracing Computations\nDESCRIPTION: Explains how to use the `trace` option to inspect previous computations that led to a specific event or store update. The trace provides insights into the history of computations, enabling debugging of complex interactions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/inspect.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fork, allSettled } from \"effector\";\nimport { inspect, type Message } from \"effector/inspect\";\n\nimport { someEvent, $count } from \"./app-code\";\n\nfunction logInspectMessage(m: Message) {\n  const { name, value, kind } = m;\n\n  return console.log(`[${kind}] ${name} ${value}`);\n}\n\nconst myScope = fork();\n\ninspect({\n  scope: myScope,\n  trace: true, // <- explicit setting is needed\n  fn: (m) => {\n    if (m.kind === \"store\" && m.sid === $count.sid) {\n      m.trace.forEach((tracedMessage) => {\n        logInspectMessage(tracedMessage);\n        // ☝️ here we are logging the trace of specific store update\n      });\n    }\n  },\n});\n\nallSettled(someEvent, { scope: myScope, params: 42 });\n// [on] 42\n// [event] someEvent 42\n// ☝️ traces are provided in backwards order, because we are looking back in time\n```\n\n----------------------------------------\n\nTITLE: Event Type Declaration (Effector)\nDESCRIPTION: Shows how to declare the type of an Effector Event. This is needed when a factory or library requires an event to subscribe to updates for proper integration.  The generic type `T` represents the type of data the event will carry.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst event: Event<T>;\n```\n\n----------------------------------------\n\nTITLE: importName Configuration\nDESCRIPTION: Example configuring the `importName` option in the Effector Babel plugin to specify the import names to be processed.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"importName\": [\"effector\"]\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Custom Factory Definition\nDESCRIPTION: Defines a custom factory function `createName` that encapsulates the creation of an Effector store `$name` and an event `updateName`. This factory is used to illustrate the need for wrapping custom factories to ensure unique SIDs for the inner stores.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// src/shared/lib/create-name/index.ts\nexport function createName() {\n  const updateName = createEvent();\n  const $name = createStore(null);\n\n  $name.on(updateName, (_, nextName) => nextName);\n\n  return { $name };\n}\n```\n\n----------------------------------------\n\nTITLE: spec with classList example\nDESCRIPTION: This TypeScript code demonstrates how to use the `spec` function with `classList` to dynamically add or remove CSS classes based on store values.  It also demonstrates how static class attributes and classList attributes are merged.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst $isEnabled = createStore(true)\nspec({classList: {first: true, second: $isEnabled}})\n\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst $class = createStore('active')\nspec({classList: ['size-big', $class]})\n\n```\n\nLANGUAGE: typescript\nCODE:\n```\nh('div', {\n  attr: {class: 'first second'},\n  classList: ['third'],\n  fn() {\n    spec({classList: {fourth: true}})\n  },\n})\n\n// => <div class=\"first second third fourth\"></div>\n\n```\n\n----------------------------------------\n\nTITLE: addLoc Configuration\nDESCRIPTION: Example configuring the `addLoc` option in the Effector Babel plugin to add location to methods' calls. Used by devtools, for example effector-logger.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"addLoc\": false\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Import createStoreConsumer from effector-react (TypeScript)\nDESCRIPTION: Imports the `createStoreConsumer` function from the `effector-react` library. This function is used to create a React component that subscribes to an Effector store and re-renders when the store's value changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/createStoreConsumer.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStoreConsumer } from \"effector-react\";\n```\n\n----------------------------------------\n\nTITLE: Adding Events in Effector\nDESCRIPTION: This code snippet demonstrates how to create events in Effector using the `createEvent` function.  The `incremented` and `decremented` events can be triggered to update the store. It requires the `effector` package.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst incremented = createEvent();\nconst decremented = createEvent();\n```\n\n----------------------------------------\n\nTITLE: Reinitialize Store with `.reinit` (JavaScript)\nDESCRIPTION: Reinitializes a store to its default value using the `.reinit` property. The example shows how to check that `.reinit` is an event and then reinitializes a counter store to its default value of 0.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, sample, is } from \"effector\";\n\nconst $counter = createStore(0);\nis.event($counter.reinit);\n\nconst increment = createEvent();\n\n$counter.reinit();\nconsole.log($counter.getState());\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with Vue\nDESCRIPTION: This command installs the `effector` and `effector-vue` packages using npm. `effector-vue` provides utilities for integrating Effector with Vue components.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-vue\n```\n\n----------------------------------------\n\nTITLE: Import useStore from effector-react (TypeScript)\nDESCRIPTION: Imports the `useStore` hook from the `effector-react` library. This hook allows subscribing a React component to an Effector store, triggering re-renders when the store's value changes. This hook is deprecated and `useUnit` is the preferred alternative.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useStore.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useStore } from \"effector-react\";\n```\n\n----------------------------------------\n\nTITLE: Validating Effector Scope with `is.scope` in JavaScript\nDESCRIPTION: This snippet demonstrates how to use `is.scope` to check if a given value is an Effector scope. It imports necessary modules from Effector and creates a store, event, and effect for testing purposes. It also creates a scope using `fork`. The snippet then calls `is.scope` with different values and logs the results to the console, showing examples of when it returns true or false.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/is.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { fork } from \"effector\";\n\nconst store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\nconst scope = fork();\n\nis.scope(scope);\n// => true\n\nis.scope(store);\n// => false\n\nis.scope(event);\n// => false\n\nis.scope(fx);\n// => false\n\nis.scope(createDomain());\n// => false\n\nis.scope(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: Event.prepend usage example - Javascript\nDESCRIPTION: Illustrates using `prepend` to transform data before sending it to the original event. It also demonstrates creating a new event that belongs to a domain and transforming data before the original event occurs.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst userPropertyChanged = createEvent();\n\nuserPropertyChanged.watch(({ field, value }) => {\n  console.log(`User property \"${field}\" changed to ${value}`);\n});\n\nconst changeName = userPropertyChanged.prepend((name) => ({\n  field: \"name\",\n  value: name,\n}));\nconst changeRole = userPropertyChanged.prepend((role) => ({\n  field: \"role\",\n  value: role.toUpperCase(),\n}));\n\nchangeName(\"john\");\n// => User property \"name\" changed to john\n\nchangeRole(\"admin\");\n// => User property \"role\" changed to ADMIN\n\nchangeName(\"alice\");\n// => User property \"name\" changed to alice\n```\n\n----------------------------------------\n\nTITLE: Import useProvidedScope from effector-react\nDESCRIPTION: Imports the `useProvidedScope` hook from the `effector-react` library. This hook provides access to the current Effector Scope within a React component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useProvidedScope.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useProvidedScope } from \"effector-react\";\n```\n\n----------------------------------------\n\nTITLE: clearNode Usage with Deep Removal\nDESCRIPTION: Illustrates the `deep` option in `clearNode` to destroy a unit and all its derived units. It imports `createStore`, `createEvent`, and `clearNode` from effector.  `clearNode(trigger, { deep: true })` removes `trigger`, `inc`, and `store` because they are all dependent on each other. Dependencies: effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/clearNode.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, clearNode } from \"effector\";\n\nconst inc = createEvent();\nconst trigger = inc.prepend(() => {});\nconst store = createStore(0).on(inc, (x) => x + 1);\ntrigger.watch(() => console.log(\"trigger called\"));\ninc.watch(() => console.log(\"inc called\"));\nstore.watch((x) => console.log(\"store state: \", x));\n// => store state: 0\ntrigger();\n// => trigger called\n// => inc called\n// => store state: 1\nclearNode(trigger, { deep: true });\ntrigger();\n// no reaction\ninc();\n// no reaction!\n// all units, which depend on trigger, are erased\n// including inc and store, because it depends on inc\n```\n\n----------------------------------------\n\nTITLE: Running Effector Documentation with Github Token\nDESCRIPTION: This command starts the Effector documentation project with a Github Personal Access Token. This allows the documentation to fetch commit history. The GITHUB_TOKEN environment variable must be set to a valid Github Personal Access Token.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nGITHUB_TOKEN=github_pat_REDACTED_TOKEN pnpm start\n```\n\n----------------------------------------\n\nTITLE: Usage of custom store creator\nDESCRIPTION: Example demonstrating the usage of a custom store creator function.  The babel plugin will treat this as a store creator.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_19\n\nLANGUAGE: js\nCODE:\n```\n// src/state.js\nimport { createInputField } from \"@lib/createInputField\";\n\nconst foo = createInputField(\"-\");\n/*\n\nwill be treated as store creator and compiled to\n\nconst foo = createInputField('-', {\n  name: 'foo',\n  sid: 'z&si65'\n})\n\n*/\n```\n\n----------------------------------------\n\nTITLE: Installing effector-vue with npm\nDESCRIPTION: This command installs effector and effector-vue using npm. effector provides the core state management library, while effector-vue provides Vue bindings for effector.\nSOURCE: https://github.com/effector/effector/blob/master/packages/effector-vue/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save effector effector-vue\n```\n\n----------------------------------------\n\nTITLE: createWatch with Configuration (TypeScript)\nDESCRIPTION: Defines the type signature for the `createWatch` function in effector, showcasing its configuration object.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createWatch.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreateWatch<T>(config: {\n  unit: Unit<T>\n  fn: (payload: T) => void\n  scope?: Scope\n}): Subscription\n```\n\n----------------------------------------\n\nTITLE: Effector Worker SID Usage (JS)\nDESCRIPTION: Demonstrates how to use the Stable ID (SID) generated by the Babel plugin in a worker context to handle messages and events. It requires the effector library and assumes that the `getUser` effect is defined in `common.js`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\n// worker.js\nimport { getUsers } from \"./common.js\";\n\ngetUsers.use((userID) => fetch(userID));\n\ngetUsers.done.watch(({ result }) => {\n  postMessage({ sid: getUsers.sid, result });\n});\n\nonmessage = async ({ data }) => {\n  if (data.sid !== getUsers.sid) return;\n  getUsers(data.userID);\n};\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect and Using scopeBind in Effector\nDESCRIPTION: This code snippet creates an effect `connectFx` using `attach` and `scopeBind`. It takes a service from the store `$service` as its source. Inside the effect, `scopeBind` is used to bind the `connectEv` event to the current scope. This ensures that when the service emits the 'service_start' event, the bound `connectEv` is triggered within the correct Effector scope, allowing it to access and update relevant stores or perform other scoped actions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/nextjs/scope-bind.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { attach, scopeBind } from \"effector\";\n\nconst connectFx = attach({\n  source: {\n    service: $service,\n  },\n  async effect({ service }) {\n    /**\n     * `scopeBind` will automatically derive current scope, if called inside of an Effect\n     */\n    const serviceStarted = scopeBind(connectEv);\n\n    return await service.on(\"service_start\", serviceStarted);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: createGate with Config - TypeScript\nDESCRIPTION: Shows the function signature of `createGate` when used with a configuration object. It illustrates that the function accepts an optional configuration object with properties for `defaultState`, `domain`, and `name`, and returns a `Gate<T>` instance. The `defaultState` allows initializing the gate with a default value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/createGate.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ncreateGate({ defaultState?: T, domain?: Domain, name?: string }): Gate<T>\n```\n\n----------------------------------------\n\nTITLE: Effector SWC Plugin addLoc Configuration\nDESCRIPTION: This JSON snippet shows an example configuration for the `addLoc` option of the Effector SWC plugin.  It enables including location information (file paths and line numbers) for Units and factories.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"addLoc\": false }]\n```\n\n----------------------------------------\n\nTITLE: Accessing Effect failData Event - Typescript\nDESCRIPTION: Describes the `failData` event, which triggers with the error that occurred during effect execution. Manually calling the failData event is prohibited.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fx: Effect<any, any, E>\n\nfx.failData\n-> Event<E>\n```\n\n----------------------------------------\n\nTITLE: Basic Babel Configuration (JSON)\nDESCRIPTION: Shows the most basic configuration for the effector/babel-plugin within a .babelrc file.  This configuration enables the plugin without any specific options. Requires a Babel environment.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"effector/babel-plugin\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Extract Store Value Type with `StoreValue<S>` (TypeScript)\nDESCRIPTION: Illustrates how to extract the type of a `Store`'s value using the `StoreValue<S>` type utility. This enables type-safe access to the store's data within TypeScript code.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store: Store<Value>;\ntype Value = StoreValue<typeof $store>;\n```\n\n----------------------------------------\n\nTITLE: Generating Unique Identifiers in TypeScript\nDESCRIPTION: Creates a function `createOid` to generate unique identifiers. It combines the current timestamp with a random string to ensure uniqueness.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// File: /src/shared/lib/oid.ts\nexport const createOid = () =>\n  ((new Date().getTime() / 1000) | 0).toString(16) +\n  \"xxxxxxxxxxxxxxxx\".replace(/[x]/g, () => ((Math.random() * 16) | 0).toString(16)).toLowerCase();\n```\n\n----------------------------------------\n\nTITLE: Webpack Alias Configuration (JavaScript)\nDESCRIPTION: This JavaScript snippet shows how to configure Webpack to automatically replace `effector` with `effector/compat` throughout the project. This configuration uses the `resolve.alias` option to create an alias for the `effector` module, pointing it to `effector/compat` instead.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/module/compat.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  resolve: {\n    alias: {\n      effector: \"effector/compat\",\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Import useGate from effector-react (TypeScript)\nDESCRIPTION: Imports the `useGate` hook from the `effector-react` library. This import is required to use the `useGate` hook within a React component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useGate.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useGate } from \"effector-react\";\n```\n\n----------------------------------------\n\nTITLE: Incorrect Array Update Example - Typescript\nDESCRIPTION: Illustrates an incorrect way to update an array within an effector Store. Modifying the array directly (using `push` without creating a new array) does not trigger state updates, as the reference to the array remains unchanged.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n$items.on(addItem, (items, newItem) => {\n  // ❌ ошибка! Ссылка на массив осталась та же, обновления стора не произойдёт\n  items.push(newItem);\n  return items;\n});\n```\n\n----------------------------------------\n\nTITLE: Reusable Media Query Matcher with Effector (JS)\nDESCRIPTION: This code defines a reusable function `mediaMatcher` that creates an Effector store to track whether a given media query matches the current screen state. It creates an event `queryChange` that's triggered on media query changes and updates the `$isQueryMatches` store accordingly.  This function can be used with different queries.\nSOURCE: https://github.com/effector/effector/blob/master/recipes/media-queries/README.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nimport {createEvent, createStore} from 'effector'\n\nexport function mediaMatcher(query) {\n  const queryChange = createEvent('query change')\n  const mediaQueryList = window.matchMedia(query)\n  mediaQueryList.addListener(queryChange)\n\n  const $isQueryMatches = createStore(mediaQueryList.matches).on(\n    queryChange,\n    (_, event) => event.matches,\n  )\n\n  return $isQueryMatches\n}\n\n/* declaring queries */\n\nconst small = mediaMatcher('(max-width: 768px)')\nconst medium = mediaMatcher('(min-width: 769px) and (max-width: 1024px)')\nconst large = mediaMatcher('(min-width: 1025px)')\nconst portrait = mediaMatcher('(orientation: portrait)')\n\n/* using queries */\n\nsmall.watch(isSmall => {\n  console.log('is small screen?', isSmall)\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Factory with SID\nDESCRIPTION: Illustrates how the Effector plugin adds a `sid` to the inner store within the custom factory `createName`. However, this alone is insufficient to ensure uniqueness across multiple instances of the factory.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// src/shared/lib/create-name/index.ts\nexport function createName() {\n  const updateName = createEvent();\n  const $name = createStore(null, { sid: \"ffds2\" });\n\n  $name.on(updateName, (_, nextName) => nextName);\n\n  return { $name };\n}\n```\n\n----------------------------------------\n\nTITLE: Running Effector Documentation Locally\nDESCRIPTION: These commands install dependencies and start the Effector documentation project.  It requires pnpm to be installed and sets up the necessary environment to run the documentation site.  The documentation can then be accessed through a local development server.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\npnpm start\n```\n\n----------------------------------------\n\nTITLE: Configuring addLoc Option\nDESCRIPTION: Configures the `addLoc` option of the Effector SWC plugin, enabling the inclusion of location information (file paths and line numbers) for Effector Units and factories, which can be useful when debugging.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"addLoc\": false }]\n```\n\n----------------------------------------\n\nTITLE: Handling Undefined Store Values in Effector (TypeScript)\nDESCRIPTION: This snippet demonstrates how to allow `undefined` as a valid value in an Effector store. By default, Effector skips updates with `undefined` values. Passing `{ skipVoid: false }` as the second argument to `createStore` overrides this behavior.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/troubleshooting.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = createStore(0, {\n  skipVoid: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Page Mounted Event\nDESCRIPTION: This code adds an event that triggers when the chat page is mounted in React. This event is used to initiate loading the user session and messages. This enhances page functionality and responsiveness.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_14\n\nLANGUAGE: ts\nCODE:\n```\n// File: /src/pages/chat/model.ts\n// Just add a new event\nexport const pageMounted = createEvent();\n```\n\n----------------------------------------\n\nTITLE: forceScope Configuration\nDESCRIPTION: Example showing how to configure the `forceScope` option in the Effector Babel plugin. Setting `forceScope` to `true` adds `forceScope` to all hooks from `effector-react`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n\"effector/babel-plugin\",\n  {\n    \"forceScope\": true\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Allowing Undefined Values in Effector (TypeScript)\nDESCRIPTION: Shows how to explicitly allow `undefined` as a valid value in an Effector store by setting the `skipVoid` option to `false` during store creation.  Also clarifies the use of `null` as an alternative to undefined. Requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst setVoidValue = createEvent<number>();\n\n// ❌ undefined will be skipped\nconst $store = createStore(13).on(setVoidValue, (_, voidValue) => voidValue);\n\n// ✅ undefined allowed as values\nconst $store = createStore(13, {\n  skipVoid: false,\n}).on(setVoidValue, (_, voidValue) => voidValue);\n\nsetVoidValue(null);\n```\n\n----------------------------------------\n\nTITLE: Importing Event and EventCallable types\nDESCRIPTION: Imports the `Event` and `EventCallable` types from the Effector library. These types are fundamental for working with events in Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type Event, type EventCallable } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Timer Effect without scopeBind\nDESCRIPTION: This code shows the `startFx` effect without using `scopeBind`.  The `tick` event is called directly within `setInterval`, which can lead to scope loss if the scope changes before the `tick` event is executed.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/advanced/work-with-scope.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst startFx = createEffect(() => {\n  const intervalId = setInterval(() => {\n    tick();\n  }, TIMEOUT);\n\n  return intervalId;\n});\n```\n\n----------------------------------------\n\nTITLE: Import fork and Scope from Effector (TypeScript)\nDESCRIPTION: Imports the `fork` function and the `Scope` type from the Effector library. This is a necessary first step to use `fork` for creating isolated application instances.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/fork.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fork, type Scope } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with NPM\nDESCRIPTION: This command installs the core Effector library using the npm package manager.  It is a basic installation suitable for environments that don't require framework-specific bindings.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/installation.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector\n```\n\n----------------------------------------\n\nTITLE: Implementation of withFactory Helper\nDESCRIPTION: This code snippet presents a simplified implementation of the `withFactory` helper function. It demonstrates how the helper sets a global variable (`globalSid`) before calling the factory function (`fn`) and then resets it after. Effector's unit creation functions (e.g., `createStore`) read this global variable to prepend the factory's SID to the unit's SID, ensuring uniqueness.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nlet globalSid = null;\n\nfunction withFactory({ sid, fn }) {\n  globalSid = sid;\n\n  const result = fn();\n\n  globalSid = null;\n\n  return result;\n}\n\nfunction createStore(initialValue, { sid }) {\n  if (globalSid) {\n    sid = `${globalSid}|${sid}`;\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: createAction Sample in Effector\nDESCRIPTION: Shows how to use `effector-action` to create a more readable and declarative code for complex conditional logic. It includes the setup for the action and how to handle the logic and targeting different effects based on the form validity and setting's `sendNotifications` status.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAction } from \"effector-action\";\n\nconst submitForm = createAction({\n  source: {\n    form: $form,\n    settings: $settings,\n    user: $user,\n  },\n  target: {\n    submitFormFx,\n    showErrorMessageFx,\n    sendNotificationFx,\n  },\n  fn: (target, { form, settings, user }) => {\n    if (!form.isValid) {\n      target.showErrorMessageFx(form.errors);\n      return;\n    }\n\n    target.submitFormFx({\n      data: form,\n      theme: settings.theme,\n    });\n  },\n});\n\ncreateAction(submitFormFx.done, {\n  source: $settings,\n  target: sendNotificationFx,\n  fn: (sendNotification, settings) => {\n    if (settings.sendNotifications) {\n      sendNotification();\n    }\n  },\n});\n\nsubmitForm();\n```\n\n----------------------------------------\n\nTITLE: createStore with serialize: ignore\nDESCRIPTION: Shows how to use the `serialize: ignore` option to prevent a store from being serialized when using `effector/serialize`. The `$version` store will not be included in the serialized values.  This is useful for stores that contain data that shouldn't be persisted, like UI-specific state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createStore.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore, serialize, fork, allSettled } from \"effector\";\n\nconst readPackage = createEvent();\n\nconst $name = createStore(\"\");\nconst $version = createStore(0, { serialize: \"ignore\" });\n\n$name.on(readPackage, (_, { name }) => name);\n$version.on(readPackage, (_, { version }) => version);\n\n// Watchers always called for scoped changes\n$name.watch((name) => console.log(\"name '%s'\", name));\n$version.watch((version) => console.log(\"version %s\", version));\n// => name ''\n// => version 0\n\n// Please, note, `fork()` call doesn't trigger watches\n// In the opposit of `hydrate()` call\nconst scope = fork();\n\n// By default serialize saves value only for the changed stores\n// Review `onlyChanges` option https://effector.dev/api/effector/serialize\nconst values = serialize(scope);\nconsole.log(values);\n// => {}\n\n// Let's change our stores\nawait allSettled(readPackage, {\n  scope,\n  params: { name: \"effector\", version: 22 },\n});\n// => name 'effector'\n// => version 22\n\nconst actualValues = serialize(scope);\nconsole.log(actualValues);\n// => {n74m6b: \"effector\"}\n// `$version` store has `serialize: ignore`, so it's not included\n```\n\n----------------------------------------\n\nTITLE: Serialize with onlyChanges Option\nDESCRIPTION: Serializes only the stores that have changed within a scope.  Requires `effector` and uses `createDomain`, `fork`, `serialize`, and `hydrate` functions. The example demonstrates how to hydrate client-side stores with server-side data, ensuring that only relevant stores are updated during route changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/serialize.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createDomain, fork, serialize, hydrate } from \"effector\";\n\nconst app = createDomain();\n\n/** стор, который мы хотим гидрировать с сервера */\nconst $title = app.createStore(\"dashboard\");\n\n/** стор, который не используется сервером */\nconst $clientTheme = app.createStore(\"light\");\n\n/** скоуп в клиентском приложении */\nconst clientScope = fork(app, {\n  values: new Map([\n    [$clientTheme, \"dark\"],\n    [$title, \"profile\"],\n  ]),\n});\n\n/** scope на стороне сервера для страницы чатов, созданный для каждого запроса */\nconst chatsPageScope = fork(app, {\n  values: new Map([[$title, \"chats\"]]),\n});\n\n/** этот объект будет содержать только данные $title\n * так как $clientTheme никогда не изменялся в server scope */\nconst chatsPageData = serialize(chatsPageScope, { onlyChanges: true });\nconsole.log(chatsPageData);\n// => {'-l644hw': 'chats'}\n\n/** таким образом, заполнение значений с сервера затронет только соответствующие сторы */\nhydrate(clientScope, { values: chatsPageData });\n\nconsole.log(clientScope.getState($clientTheme));\n// => dark\n```\n\n----------------------------------------\n\nTITLE: ClassListMap spec example\nDESCRIPTION: Illustrates usage of `ClassListMap` in a `spec` object for managing class names. It sets 'class-name' to true (always applied) and 'class-name-2' based on the `$booleanStore`.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nspec({\n  classList: {\n    'class-name': true,\n    'class-name-2': $booleanStore,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Effector Effect without Handler Example (JS)\nDESCRIPTION: Demonstrates an example of using an effector Effect without a handler. The babel plugin improves error messages in such cases by showing the specific effect where the error occurred. No dependencies required other than effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchFx = createEffect();\n\nfetchFx();\n\n// => no handler used in fetchFx\n```\n\n----------------------------------------\n\nTITLE: connect(Component)($store) signature\nDESCRIPTION: This signature of the connect function accepts a React component as its first argument, and returns a function that takes an effector store. It merges the store's value into the component's props. It is deprecated in favor of hooks API.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/connect.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconnect(Component)($store: Store<T>): Component\n```\n\n----------------------------------------\n\nTITLE: Extracting Effect Error with `EffectError` in Effector\nDESCRIPTION: Shows how to use the `EffectError` type utility to extract the error type of an Effector effect. This is used for defining types for the data returned by the effect on failure.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, EffectError } from \"effector\";\n\nconst fx = createEffect<\n  { id: string },\n  { name: string; isAdmin: boolean },\n  { statusText: string; status: number }\n>(() => ({ name: \"Alice\", isAdmin: false }));\n\ntype EffectErrorType = EffectError<typeof fx>;\n// {statusText: string; status: number}\n```\n\n----------------------------------------\n\nTITLE: Vite Alias Configuration (JavaScript)\nDESCRIPTION: This JavaScript snippet shows how to configure Vite to automatically replace `effector` with `effector/compat` throughout the project. Similar to Webpack, this uses the `resolve.alias` option within the Vite configuration.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/module/compat.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  resolve: {\n    alias: {\n      effector: \"effector/compat\",\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: createWatch without Scope (JavaScript)\nDESCRIPTION: Shows how to use `createWatch` without a scope.  The `createWatch` function subscribes to the `changeName` event, and the callback function `console.log` is executed every time the event is triggered, regardless of scope. Requires effector's `createWatch`, `createEvent`, `fork`, and `allSettled` functions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createWatch.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createWatch, createEvent, fork, allSettled } from \"effector\";\n\nconst changeName = createEvent();\n\nconst scope = fork();\n\nconst unwatch = createWatch({ unit: changeName, fn: console.log });\n\nawait allSettled(changeName, { scope, params: \"Иван\" }); // output: Иван\nchangeName(\"Иван\"); // output: Иван\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect within a Domain\nDESCRIPTION: Creates an effect inside a specified domain, grouping related effects and stores together. This helps in organizing and managing complex applications, especially for error handling and scoping.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createDomain, createStore, attach } from \"effector\";\n\nconst reportErrors = createDomain();\nconst $counter = createStore(0);\n\nconst attachedFx = attach({\n  domain: reportErrors,\n  source: $counter,\n  async effect(counter) {\n    // ...\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: useStore usage example with React\nDESCRIPTION: Demonstrates how to use the `useStore` hook to connect a React component to an effector store. It creates a store `$counter`, defines increment and decrement actions, and uses `useStore` to subscribe the `App` component to the `$counter` store.  The component re-renders whenever the store's value changes, updating the displayed counter value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useStore.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createStore, createApi } from \"effector\";\nimport { useStore } from \"effector-react\";\n\nconst $counter = createStore(0);\n\nconst { increment, decrement } = createApi($counter, {\n  increment: (state) => state + 1,\n  decrement: (state) => state - 1,\n});\n\nconst App = () => {\n  const counter = useStore($counter);\n  return (\n    <div>\n      {counter}\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Fixing Unit Calls inside filter with sample (TS)\nDESCRIPTION: This code demonstrates the correct way to trigger an event from within a filter function using the `sample` operator. This addresses the error from calling units inside pure functions. This showcases the fix.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst countReceived = createEvent<number>();\nconst eachReceived = createEvent<number>();\n\nconst receivedEven = someHappened.filter({\n  fn(count) {\n    return count % 2 === 0;\n  },\n});\n\nsample({\n  clock: someHappened,\n  target: eachReceived,\n});\n```\n\n----------------------------------------\n\nTITLE: Babel Plugin Module Resolver Configuration\nDESCRIPTION: This is a sample configuration for babel-plugin-module-resolver to automatically alias imports to the compat versions of effector. This avoids manual import changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/installation.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\n    [\n      \"babel-plugin-module-resolver\",\n      {\n        \"alias\": {\n          \"^effector$\": \"effector/compat\",\n          \"^effector-react$\": \"effector-react/compat\"\n        }\n      }\n    ]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Events Based on Object Properties (Effector)\nDESCRIPTION: Illustrates how to filter events based on a specific property of an object. The example filters `sneackersReceived` events to trigger `uniqueSizeReceived` only when the size is 48. Requires `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst sneackersReceived = createEvent<Sneakers>();\nconst uniqueSizeReceived = sneackersReceived.filter({\n  fn: (sneackers) => sneackers.size === 48,\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with React bindings\nDESCRIPTION: This command installs both Effector and its React bindings using npm. The effector-react package provides hooks and components for using Effector with React.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/installation.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-react\n```\n\n----------------------------------------\n\nTITLE: Validating Effector Effect with `is.effect` in JavaScript\nDESCRIPTION: This snippet demonstrates how to use `is.effect` to check if a given value is an Effector effect. It imports necessary modules from Effector and creates a store, event, and effect for testing purposes. The snippet then calls `is.effect` with different values and logs the results to the console, showing examples of when it returns true or false.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/is.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain } from \"effector\";\n\nconst store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\n\nis.effect(store);\n// => false\n\nis.effect(event);\n// => false\n\nis.effect(fx);\n// => true\n\nis.effect(createDomain());\n// => false\n\nis.effect(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: Parsing and Validating WebSocket Messages - TypeScript\nDESCRIPTION: This snippet demonstrates how to parse and validate incoming WebSocket messages against a predefined schema using Effector and Zod. It creates an effect `parseFx` that parses the message and validates it against the `messagesSchema`. Events are triggered for successful parsing (`parsedMessageReceived`) and validation failures (`validationError`). Dependencies: effector, zod.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/websocket-integration.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst parsedMessageReceived = createEvent<MessagesSchema>();\n\nconst parseFx = createEffect((message: unknown): MessagesSchema => {\n  return messagesSchema.parse(JSON.parse(typeof message === \"string\" ? message : \"{}\"));\n});\n\n// Парсим сообщение при его получении\nsample({\n  clock: rawMessageReceived,\n  target: parseFx,\n});\n\n// Если парсинг удался — отправляем сообщение дальше\nsample({\n  clock: parseFx.doneData,\n  target: parsedMessageReceived,\n});\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Effect without Inner Effects - JS\nDESCRIPTION: This JavaScript code demonstrates the correct way to define an Effector effect that performs an asynchronous operation (delay) without calling other effects internally. This ensures that the scope is properly maintained.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Scope.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst delayFx = createEffect(async () => {\n  await new Promise((resolve) => setTimeout(resolve, 80));\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting Arrays of Units (JavaScript)\nDESCRIPTION: Illustrates connecting arrays of events using `forward`, where triggering any source event updates all target events. The code imports `createEvent` and `forward` from effector. It shows that triggering either `firstSource` or `secondSource` causes both `firstTarget` and `secondTarget` to be triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/forward.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, forward } from \"effector\";\n\nconst firstSource = createEvent();\nconst secondSource = createEvent();\n\nconst firstTarget = createEvent();\nconst secondTarget = createEvent();\n\nforward({\n  from: [firstSource, secondSource],\n  to: [firstTarget, secondTarget],\n});\n\nfirstTarget.watch((e) => console.log(\"first target\", e));\nsecondTarget.watch((e) => console.log(\"second target\", e));\n\nfirstSource(\"A\");\n// => first target A\n// => second target A\nsecondSource(\"B\");\n// => first target B\n// => second target B\n```\n\n----------------------------------------\n\nTITLE: TypeScript Watcher Type Definition\nDESCRIPTION: This TypeScript code defines the type signature for a `Watcher` function. It takes an update of type `T` as input and performs a side effect. The return value is ignored, making it suitable for operations that don't require error handling or completion notifications.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/glossary.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype Watcher<T> = (update: T) => any;\n```\n\n----------------------------------------\n\nTITLE: Incorrect Abstract Naming in Effector (TypeScript)\nDESCRIPTION: This snippet demonstrates the anti-pattern of using abstract names like `value`, `data`, or `item` in callbacks. It shows how `userAdded` is handled with `state` and `payload` and how `buttonClicked` is used with `$data` named just `data` within a sample.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n$users.on(userAdded, (state, payload) => [...state, payload]);\n\nsample({\n  clock: buttonClicked,\n  source: $data,\n  fn: (data) => data,\n  target: someFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_63\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/0xflotus>\n        <img src=https://avatars.githubusercontent.com/u/26602940?v=4 width=\"100;\"  alt=0xflotus/>\n        <br />\n        <sub style=\"font-size:14px\"><b>0xflotus</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Create simple effect with async delay\nDESCRIPTION: Creates an Effector effect that introduces a delay using `setTimeout`. This example demonstrates the correct usage of effects when no nested effects are involved.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Scope.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst delayFx = createEffect(async () => {\n  await new Promise((resolve) => setTimeout(resolve, 80));\n});\n```\n\n----------------------------------------\n\nTITLE: Typing event.prepend in TypeScript\nDESCRIPTION: This snippet shows how to add types to events created using `event.prepend`. Types can be added either directly within the prepend function argument or by specifying a generic type. The example showcases how to prepend a new event by transforming its input parameter. `EventCallable<string>` is a return type for both approaches.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst message = createEvent<string>();\n\nconst userMessage = message.prepend((text: string) => text);\n// userMessage has type EventCallable<string>\n\nconst warningMessage = message.prepend<string>((warnMessage) => warnMessage);\n// warningMessage has type EventCallable<string>\n```\n\n----------------------------------------\n\nTITLE: Store Creation Example with Effector (After Transformation)\nDESCRIPTION: This code snippet shows the result of the Effector plugin transformation on the previous example. The plugin automatically adds a `sid` option with a generated unique identifier to the `createStore` call. This SID is derived from the source code location and ensures uniqueness and stability.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst $name = createStore(null, { sid: \"j3l44\" });\n```\n\n----------------------------------------\n\nTITLE: Creating Slot Factory with Effector\nDESCRIPTION: This code defines a `createSlotFactory` function that creates and manages slots. It utilizes Effector's `createApi`, `createStore`, `createEvent`, and `sample` to handle slot updates and removals.  It returns an API and a `createSlot` function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/slots.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createApi, createStore, createEvent, sample, split } from \"effector\";\nimport { useStoreMap } from \"effector-react\";\nimport React from \"react\";\n\nimport type { ReactElement, PropsWithChildren } from \"react\";\n\ntype Component<S> = (props: PropsWithChildren<S>) => ReactElement | null;\ntype Store<S> = {\n  readonly component: Component<S>;\n};\n\nfunction createSlotFactory<Id>({ slots }: { readonly slots: Record<string, Id> }) {\n  const api = {\n    remove: createEvent<{ readonly id: Id }>(),\n    set: createEvent<{ readonly id: Id; readonly component: Component<any> }>(),\n  };\n\n  function createSlot<P>({ id }: { readonly id: Id }) {\n    const defaultToStore: Store<P> = {\n      component: () => null,\n    };\n    const $slot = createStore<Store<P>>(defaultToStore);\n    const slotApi = createApi($slot, {\n      remove: (state) => ({ ...state, component: defaultToStore.component }),\n      set: (state, payload: Component<P>) => ({ ...state, component: payload }),\n    });\n    const isSlotEventCalling = (payload: { readonly id: Id }) => payload.id === id;\n\n    sample({\n      clock: api.remove,\n      filter: isSlotEventCalling,\n      target: slotApi.remove,\n    });\n\n    sample({\n      clock: api.set,\n      filter: isSlotEventCalling,\n      fn: ({ component }) => component,\n      target: slotApi.set,\n    });\n\n    function Slot(props: P = {} as P) {\n      const Component = useStoreMap({\n        store: $slot,\n        fn: ({ component }) => component,\n        keys: [],\n      });\n\n      return <Component {...props} />;\n    }\n\n    return {\n      $slot,\n    };\n  }\n\n  return {\n    api,\n    createSlot,\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Import from effector-react/scope (Deprecated)\nDESCRIPTION: Shows the import statement for the deprecated effector-react/scope module. This module enforces the use of Scope for all components.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/module/scope.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {} from \"effector-react/scope\";\n```\n\n----------------------------------------\n\nTITLE: SWC configuration with Effector SWC Plugin\nDESCRIPTION: This JSON snippet demonstrates how to configure the Effector SWC plugin in a `.swcrc` file. It adds the plugin to the `jsc.experimental.plugins` array. An empty options object `{}` is passed to the plugin.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$schema\": \"https://json.schemastore.org/swcrc\",\n  \"jsc\": {\n    \"experimental\": {\n      \"plugins\": [[\"@effector/swc-plugin\", {}]]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Import fork and Scope from Effector\nDESCRIPTION: This code imports the `fork` function and the `Scope` type from the Effector library. `fork` is used to create isolated instances of the application, and `Scope` represents the isolated scope created by `fork`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/fork.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { fork, type Scope } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Installing effector-react with yarn\nDESCRIPTION: This command installs the `effector` and `effector-react` packages using yarn. These packages are required for using effector with React components. This snippet should be run in the project directory.\nSOURCE: https://github.com/effector/effector/blob/master/packages/effector-react/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add effector effector-react\n```\n\n----------------------------------------\n\nTITLE: Updating Store via Events in effector\nDESCRIPTION: Explains how to update a store by subscribing to events using the `.on` method and resetting the store with the `.reset` method.  The `$counter` store is updated when `incremented`, `decremented`, or `resetCounter` events are triggered, demonstrating state changes and logging.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst incremented = createEvent();\nconst decremented = createEvent();\nconst resetCounter = createEvent();\n\nconst $counter = createStore(0)\n  // Increase value by 1 each time the event is called\n  .on(incremented, (counterValue) => counterValue + 1)\n  // Decrease value by 1 each time the event is called\n  .on(decremented, (counterValue) => counterValue - 1)\n  // Reset value to 0\n  .reset(resetCounter);\n\n$counter.watch((counterValue) => console.log(counterValue));\n\n// Usage\nincremented();\nincremented();\ndecremented();\n\nresetCounter();\n\n// Console output\n// 0 - output on initialization\n// 1\n// 2\n// 1\n// 0 - reset\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scope Loss\nDESCRIPTION: This example illustrates how scope can be lost in asynchronous operations. The `scope` variable is set within a `try` block, but after awaiting an asynchronous operation (`await 1`), the scope becomes `undefined`, showcasing the problem that `scopeBind` is intended to solve.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/advanced/work-with-scope.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// наш активный скоуп\nlet scope;\n\nfunction process() {\n  try {\n    scope = \"effector\";\n    asyncProcess();\n  } finally {\n    scope = undefined;\n    console.log(\"наш скоуп undefined\");\n  }\n}\n\nasync function asyncProcess() {\n  console.log(\"у нас есть скоуп\", scope); // effector\n\n  await 1;\n\n  // тут мы уже потеряли контекст\n  console.log(\"а здесь скоупа уже нет \", scope); // undefined\n}\n\nprocess();\n\n// Вывод:\n// у нас есть скоуп effector\n// наш скоуп undefined\n// а здесь скоупа уже нет undefined\n```\n\n----------------------------------------\n\nTITLE: Effector Split with Source, Match, Cases\nDESCRIPTION: Illustrates the function signature with different configurations of the match and cases arguments.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({ source, match, cases });\n```\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>,\n  // функция кейса\n  match: (data: T) => 'a' | 'b',\n  cases: {\n    a: Unit<T> | Unit<T>[],\n    b: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>,\n  // стор кейса\n  match: Store<'a' | 'b'>,\n  cases: {\n    a: Unit<T> | Unit<T>[],\n    b: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nsplit({\n  source: Unit<T>,\n  match: {\n    // функция сопоставления\n    a: (data: T) => boolean,\n    // стор сопоставления\n    b: Store<boolean>\n  },\n  cases: {\n    a: Unit<T> | Unit<T>[],\n    b: Unit<T> | Unit<T>[],\n    __?: Unit<T> | Unit<T>[]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using safe option in scopeBind (TypeScript)\nDESCRIPTION: Demonstrates how to suppress `scope not found` error in effector. Pass `{ safe: true }` as an option to `scopeBind`\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/troubleshooting.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst scopeEvent = scopeBind(event, {\n  safe: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Vue Component Template Example\nDESCRIPTION: Illustrates how to use the data bound via the `effector` option within a Vue component's template. It shows conditional rendering based on the `createPending` state and displaying the `user.name`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/VueEffector.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <div>\n    <span v-if=\"createPending\">loading...</span>\n    <p>{{ user.name }}</p>\n    ...\n    <button @click=\"create\">Create<button>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_11\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/darky>\n            <img src=https://avatars.githubusercontent.com/u/1832800?v=4 width=\"100;\"  alt=Vladislav Botvin/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Vladislav Botvin</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Using EffectorScopePlugin with Vue SSR\nDESCRIPTION: This code snippet demonstrates how to use the EffectorScopePlugin within a Vue SSR application. It imports necessary modules from 'vue' and 'effector-vue', forks an Effector scope, and then uses the EffectorScopePlugin to integrate the scope into the Vue app. The scope name is set to 'app-scope-name'.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/EffectorScopePlugin.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createSSRApp } from \"vue\";\nimport { EffectorScopePlugin } from \"effector-vue\";\nimport { fork } from \"effector\";\n\nconst app = createSSRApp(AppComponent);\nconst scope = fork();\n\napp.use(\n  EffectorScopePlugin({\n    scope,\n    scopeName: \"app-scope-name\",\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Typing `attach` in Effector with TypeScript\nDESCRIPTION: Demonstrates how to let TypeScript infer the types of the created effect by adding a type to the first argument `mapParams`. This becomes the generic `Params` of the resulting effect, promoting type safety and predictability.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst sendTextFx = createEffect<{ message: string }, \"ok\">(() => {\n  // ...\n\n  return \"ok\";\n});\n\nconst sendWarningFx = attach({\n  effect: sendTextFx,\n  mapParams: (warningMessage: string) => ({ message: warningMessage }),\n});\n// sendWarningFx имеет тип Effect<{message: string}, 'ok'>\n```\n\n----------------------------------------\n\nTITLE: Merging Events (Javascript)\nDESCRIPTION: Demonstrates merging two events into a single event. When either of the original events is triggered, the merged event is also triggered, passing the payload from the original event to the watch callback.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/merge.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, merge } from \"effector\";\n\nconst foo = createEvent();\nconst bar = createEvent();\nconst baz = merge([foo, bar]);\nbaz.watch((v) => console.log(\"merged event triggered: \", v));\n\nfoo(1);\n// => merged event triggered: 1\nbar(2);\n// => merged event triggered: 2\n```\n\n----------------------------------------\n\nTITLE: Custom Factory Wrapped with withFactory\nDESCRIPTION: Demonstrates how the Effector plugin wraps the custom factory instances with `withFactory`. This ensures that each instance receives a unique `sid`, which is then combined with the `sid` of the inner store, resolving the uniqueness issue.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// src/shared/lib/create-name/index.ts\nexport function createName() {\n  const updateName = createEvent();\n  const $name = createStore(null, { sid: \"ffds2\" });\n\n  $name.on(updateName, (_, nextName) => nextName);\n\n  return { $name };\n}\n\n// src/feature/persons/model.ts\nimport { withFactory } from \"effector\";\nimport { createName } from \"@/shared/lib/create-name\";\n\nconst personOne = withFactory({\n  sid: \"gre24f\",\n  fn: () => createName(),\n});\nconst personTwo = withFactory({\n  sid: \"lpefgd\",\n  fn: () => createName(),\n});\n```\n\n----------------------------------------\n\nTITLE: Typing `sample` with `filter` in Effector with TypeScript\nDESCRIPTION: Shows how to use type predicates in `sample`'s `filter` to narrow down the type of data passed to the `target`. This allows for more specific type handling in subsequent steps.  If simply checking for null, `Boolean` can be used as the filter.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ntype UserMessage = { kind: \"user\"; text: string };\ntype WarnMessage = { kind: \"warn\"; warn: string };\n\nconst message = createEvent<UserMessage | WarnMessage>();\nconst userMessage = createEvent<UserMessage>();\n\nsample({\n  clock: message,\n  filter: (msg): msg is UserMessage => msg.kind === \"user\",\n  target: userMessage,\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, sample } from \"effector\";\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\n// События\nconst formSubmitted = createEvent();\nconst userDataSaved = createEvent<User>();\n\n// Состояния\nconst $currentUser = createStore<User | null>(null);\n\n// При сабмите формы отправляем данные только если юзер существует\nsample({\n  clock: formSubmitted,\n  source: $currentUser,\n  filter: Boolean, // отфильтровываем null\n  target: userDataSaved,\n});\n\n// Теперь userDataSaved получит только существующие данные пользователя\n```\n\n----------------------------------------\n\nTITLE: Effector addNames Configuration (JSON)\nDESCRIPTION: Enables the `addNames` option of effector/babel-plugin to add names to unit factory calls. Useful for minification and obfuscation in production builds.  Requires a Babel environment and effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"addNames\": true\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with Solid bindings\nDESCRIPTION: This command installs Effector along with the effector-solid bindings using npm. These bindings enable the use of Effector with SolidJS applications.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/installation.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-solid\n```\n\n----------------------------------------\n\nTITLE: Access Store Default State (TypeScript)\nDESCRIPTION: Demonstrates accessing the default state of a store using the `.defaultState` property.  It logs whether the store's default state is equal to the initially defined default value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = createStore(\"DEFAULT\");\nconsole.log($store.defaultState === \"DEFAULT\");\n```\n\n----------------------------------------\n\nTITLE: Effector Store Serialization with SIDs\nDESCRIPTION: Demonstrates serializing and deserializing Effector stores using SIDs. The server-side code forks an Effector scope, populates the stores with data using `allSettled`, serializes the scope, and returns the serialized state. The client-side code then parses the state and uses it to initialize a new scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// server.ts\nasync function handlerRequest() {\n  // создаем изолированный экземпляр приложения\n  const scope = fork();\n\n  // заполняем сторы данными\n  await allSettled($name, { scope, params: \"Igor\" });\n  await allSettled($age, { scope, params: 25 });\n\n  const state = JSON.serialize(serialize(scope));\n  // -> { \"name\": \"Igor\", \"age\": 25 }\n\n  return { state };\n}\n\n// Предположим, что сервер поместил состояние в HTML\nconst serverState = readServerStateFromWindow();\n\nconst scope = fork({\n  // Просто парсим все состояние и используем его как состояние клиента\n  values: JSON.parse(serverState),\n});\n```\n\n----------------------------------------\n\nTITLE: Using Provider with Scope in React\nDESCRIPTION: Demonstrates how to use the Provider component from effector-react/scope to pass a Scope instance to a React application. The Scope is created using effector's fork function. This code shows the intended usage before the module's deprecation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/module/scope.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// main.js\nimport { fork } from \"effector\";\nimport { Provider } from \"effector-react/scope\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\nconst scope = fork();\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\n\nroot.render(\n  <Provider value={scope}>\n    <Application />\n  </Provider>,\n);\n```\n\n----------------------------------------\n\nTITLE: User.vue: Template output\nDESCRIPTION: This is the template output for the User.vue component. It displays the user's ID and name using the `user` computed property obtained from the `useStoreMap` hook.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useStoreMap.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<div>\n  <strong>[{user.id}]</strong> {user.name}\n</div>\n```\n\n----------------------------------------\n\nTITLE: Effector SWC Plugin forceScope Configuration\nDESCRIPTION: This JSON snippet shows an example configuration for the `forceScope` option of the Effector SWC plugin. It injects `forceScope: true` into all hooks or `@effector/reflect` calls to ensure your app always uses `Scope` during rendering.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"forceScope\": false }]\n```\n\n----------------------------------------\n\nTITLE: Subscription Type Definition\nDESCRIPTION: This code defines the TypeScript type for a Subscription, which is returned by functions like `forward` and `watch`. Calling the subscription or its `unsubscribe` method cancels the subscription. Dependencies: effector, TypeScript.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/glossary.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type Subscription } from \"effector\";\n```\n\nLANGUAGE: typescript\nCODE:\n```\ntype Subscription = {\n  (): void;\n  unsubscribe(): void;\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Effector SWC Plugin in .swcrc\nDESCRIPTION: Demonstrates how to add the @effector/swc-plugin to the .swcrc file. The plugin is added to the jsc.experimental.plugins array.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$schema\": \"https://json.schemastore.org/swcrc\",\n  \"jsc\": {\n    \"experimental\": {\n      \"plugins\": [[\"@effector/swc-plugin\", {}]]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Effector-Vue Component Creation\nDESCRIPTION: Demonstrates how to create a Vue component using `createComponent` from `effector-vue`.  It includes creating an Effector store, an API to update the store, and component methods that interact with the store. The component is then exported as the default export.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/createComponent.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// component.vue\nimport { createComponent } from \"effector-vue\";\n\nconst $counter = createStore(0);\nconst { update } = createApi($counter, {\n  update: (_, value: number) => value,\n});\n\nexport default createComponent(\n  {\n    name: \"Counter\",\n\n    methods: {\n      update,\n      handleClick() {\n        const value = this.$counter + 1; // this.$counter <- number ( typescript tips )\n        this.update(value);\n      },\n    },\n  },\n  { $counter },\n);\n```\n\n----------------------------------------\n\nTITLE: Filtering Messages by Type - TypeScript\nDESCRIPTION: This code provides a utility function `messageReceivedByType` to filter incoming WebSocket messages based on their type. It uses Effector's `sample` function and a type predicate to ensure that only messages of the specified type are processed. This allows you to handle different types of messages in a type-safe manner. Dependencies: effector, zod.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/websocket-integration.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ntype MessageType<T extends MessagesSchema[\"type\"]> = Extract<MessagesSchema, { type: T }>;\n\nexport const messageReceivedByType = <T extends MessagesSchema[\"type\"]>(type: T) => {\n  return sample({\n    clock: parsedMessageReceived,\n    filter: (message): message is MessageType<T> => {\n      return message.type === type;\n    },\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Babel Plugin Configuration\nDESCRIPTION: Example showing the simplest configuration for the Effector Babel plugin in a `.babelrc` file. This configuration enables the plugin without any specific options.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"effector/babel-plugin\"]\n}\n```\n\n----------------------------------------\n\nTITLE: useEvent Usage with Object\nDESCRIPTION: Illustrates the use of `useEvent` with an object containing Effector Events. The example shows how to bind multiple events to handler functions within a React component, using both object and array destructuring. The handlers are then used to trigger the events on button clicks.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useEvent.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport ReactDOM from \"react-dom\";\nimport { createStore, createEvent, fork } from \"effector\";\nimport { useStore, useEvent, Provider } from \"effector-react\";\n\nconst incremented = createEvent();\nconst decremented = createEvent();\n\nconst $count = createStore(0);\n\n$count.on(incremented, (counter) => counter + 1);\n$count.on(decremented, (counter) => counter - 1);\n\nconst App = () => {\n  const counter = useStore($count);\n  const handler = useEvent({ incremented, decremented });\n  // or\n  const [handleIncrement, handleDecrement] = useEvent([incremented, decremented]);\n\n  return (\n    <>\n      <p>Count: {counter}</p>\n      <button onClick={() => handler.incremented()}>increment</button>\n      <button onClick={() => handler.decremented()}>decrement</button>\n    </>\n  );\n};\n\nconst scope = fork();\n\nReactDOM.render(\n  <Provider value={scope}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with Vue bindings\nDESCRIPTION: This command installs Effector along with the effector-vue bindings using npm. These bindings are required for proper integration with Vue applications.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/installation.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-vue\n```\n\n----------------------------------------\n\nTITLE: Install Effector SWC Plugin using npm\nDESCRIPTION: This command installs the @effector/swc-plugin as a development dependency using npm. The -ED flags ensure it's saved as a development dependency.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -ED @effector/swc-plugin\n```\n\n----------------------------------------\n\nTITLE: Create Derived Store with `.map()` and skipVoid Option (JavaScript)\nDESCRIPTION: Creates a derived store using the `.map()` method with the `skipVoid` option set to `false`. The `skipVoid` option configures how void/undefined values are handled by the mapping function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst $length = $title.map((title) => title.length, { skipVoid: false });\n```\n\n----------------------------------------\n\nTITLE: Effector Split Import\nDESCRIPTION: Imports the `split` function from the Effector library. This import is necessary to use the `split` function in TypeScript or JavaScript code.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/split.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { split } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Events with .map in Effector\nDESCRIPTION: This snippet shows how to create a derived event using the `.map` method in Effector. The `userClicked` event is transformed into `userNameSelected` by extracting the `name` property from the user object. This demonstrates how to create specialized events from existing ones, enabling data transformation and filtering.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst userClicked = createEvent<{ id: number; name: string }>();\n// Создаем событие, которое будет срабатывать только с именем пользователя\nconst userNameSelected = userClicked.map(({ name }) => name);\nconst $userName = createStore(\"\").on(userNameSelected, (_, newName) => newName);\n\n// Примеры использования\nuserClicked({ id: 1, name: \"John\" });\n// userNameSelected получит значение 'John'\n```\n\n----------------------------------------\n\nTITLE: Correct Parameter Passing in Effector (TypeScript)\nDESCRIPTION: This snippet demonstrates the correct way to pass store values to an Effector effect using `sample`. It creates a sample that combines data from `$form`, `$user`, and `$settings` and passes the combined data to `submitFormFx` as parameters. This avoids the need for `getState`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// Получаем значения через параметры\nconst submitFormFx = createEffect(({ form, userId, theme }) => {});\n\n// Получаем все необходимые данные через sample\nsample({\n  clock: formSubmitted,\n  source: {\n    form: $form,\n    user: $user,\n    settings: $settings,\n  },\n  fn: ({ form, user, settings }) => ({\n    form,\n    userId: user.id,\n    theme: settings.theme,\n  }),\n  target: submitFormFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching Listener to Media Query List (JS)\nDESCRIPTION: This snippet demonstrates how to attach a listener to a media query list to detect changes in the media query's state.  It uses `window.matchMedia` to create a media query list and `addListener` to register a callback function that is executed when the media query's state changes.  The callback function checks the `matches` property of the event object to determine the current state of the media query.\nSOURCE: https://github.com/effector/effector/blob/master/recipes/media-queries/README.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst mediaQueryList = window.matchMedia('(orientation: portrait)')\nmediaQueryList.addListener(e => {\n  if (e.matches) {\n    // The viewport is currently in portrait orientation\n  } else {\n    // The viewport is currently in landscape orientation\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Message Send Effect\nDESCRIPTION: This snippet defines an Effector effect (messageSendFx) for sending messages. It takes the message text and author information, creates a new message object with a unique ID and timestamp, adds it to the message history, saves the updated history, and returns the new message. It simulates an asynchronous operation using `await wait()`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/shared/api/message.ts\nexport const messageSendFx = createEffect(async ({ text, author }: SendMessage) => {\n  const message: Message = {\n    id: createOid(),\n    author,\n    timestamp: Date.now(),\n    text,\n  };\n  const history = await messagesLoadFx();\n  await wait();\n  saveHistory([...history, message]);\n  return message;\n});\n```\n\n----------------------------------------\n\nTITLE: Effect State Monitoring\nDESCRIPTION: This code snippet demonstrates how to monitor the different states of an Effector effect, such as pending, done, fail, and finally. It uses the `watch` method to log messages to the console when each state changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/work-with-async.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst fetchUserFx = createEffect(() => {\n  /* вызов внешнего api */\n});\n\nfetchUserFx.pending.watch((isPending) => console.log(\"Pending:\", isPending));\n\nfetchUserFx.done.watch(({ params, result }) => console.log(`Fetched user ${params}:`, result));\n\nfetchUserFx.finally.watch((value) => {\n  if (value.status === \"done\") {\n    console.log(\"fetchUserFx resolved \", value.result);\n  } else {\n    console.log(\"fetchUserFx rejected \", value.error);\n  }\n});\n\nfetchUserFx.fail.watch(({ params, error }) =>\n  console.error(`Failed to fetch user ${params}:`, error),\n);\n\nfetchUserFx();\n```\n\n----------------------------------------\n\nTITLE: Component using useUnit with array destructuring\nDESCRIPTION: This snippet presents a more concise way to use the `useUnit` hook by leveraging array destructuring. It demonstrates subscribing to multiple stores and events at once.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/migration-guide-v23.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst Component = () => {\n  const [foo, bar, onSubmit] = useUnit([$foo, $bar, triggerSubmit]);\n};\n```\n\n----------------------------------------\n\nTITLE: HMR Configuration\nDESCRIPTION: Example showing how to configure Hot Module Replacement (HMR) in the Effector Babel plugin. The `hmr` option specifies the module system used by the bundler.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n\"effector/babel-plugin\",\n  {\n    \"hmr\": \"es\"\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Creating Contributor Table Row HTML\nDESCRIPTION: This HTML snippet creates a table row with contributor information. Each cell contains a link to the contributor's GitHub profile, their avatar image, and their username. The styling includes centering the content and setting a fixed width and height.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_4\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/Victorystick>\n        <img src=https://avatars.githubusercontent.com/u/46718977?v=4 width=\"100;\"  alt=Victor Didenko/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Victor Didenko</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_10\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/willheslam>\n            <img src=https://avatars.githubusercontent.com/u/5377213?v=4 width=\"100;\"  alt=Will Heslam/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Will Heslam</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: PlainProperty type definition\nDESCRIPTION: Defines the `PlainProperty` type, which represents the allowed types for plain DOM properties. These can be strings, numbers, null (for property deletion), or booleans.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ntype PlainProperty = string | number | null | boolean\n```\n\n----------------------------------------\n\nTITLE: Cloning the Effector Repository\nDESCRIPTION: This command clones the effector repository from GitHub to your local machine, allowing you to begin development and contribute to the project. Replace 'your-username' with your GitHub username.\nSOURCE: https://github.com/effector/effector/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit clone https://github.com/your-username/effector.git\n```\n\n----------------------------------------\n\nTITLE: Extracting Effect Error Type with EffectError (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the `EffectError` type utility to extract the error type from an Effector effect. It showcases how `EffectError` can be used to define a type that represents the data returned by an effect when it fails.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, EffectError } from \"effector\";\n\nconst fx = createEffect<\n  { id: string },\n  { name: string; isAdmin: boolean },\n  { statusText: string; status: number }\n>(() => ({ name: \"Alice\", isAdmin: false }));\n\ntype EffectErrorType = EffectError<typeof fx>;\n// {statusText: string; status: number}\n```\n\n----------------------------------------\n\nTITLE: Importing `attach` from Effector\nDESCRIPTION: This code snippet demonstrates how to import the `attach` function from the Effector library. The `attach` function is used to create new effects that are based on other effects or stores.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attach } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Vite + React Configuration for Effector (JS)\nDESCRIPTION: Configures a Vite project to use the effector/babel-plugin.  It involves installing `@vitejs/plugin-react` and adding a Babel configuration to the React plugin options. Requires Vite, React, and effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_19\n\nLANGUAGE: js\nCODE:\n```\n// vite.config.js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\nexport default defineConfig({\n  plugins: [\n    react({\n      babel: {\n        plugins: [\"effector/babel-plugin\"],\n        // Использовать .babelrc файлы\n        babelrc: true,\n        // Использовать babel.config.js файлы\n        configFile: true,\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Extracting Effect Result Type with EffectResult (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the `EffectResult` type utility to extract the success result type from an Effector effect. It showcases how `EffectResult` can be used to define a type that represents the data returned by an effect on successful completion.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, EffectResult } from \"effector\";\n\nconst fx = createEffect<\n  { id: string },\n  { name: string; isAdmin: boolean },\n  { statusText: string; status: number }\n>(() => ({ name: \"Alice\", isAdmin: false }));\n\ntype EffectResultType = EffectResult<typeof fx>;\n// {name: string; isAdmin: boolean}\n```\n\n----------------------------------------\n\nTITLE: Launching computations with effector's launch method\nDESCRIPTION: Demonstrates using the `launch` method to trigger computations within effector units like stores, events, and effects.  The `target` parameter specifies the unit to update or trigger, and `params` provides the input data. This snippet shows how to initiate computations in effector with fine-grained control, primarily useful for library developers.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/launch.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const $store: Store<T>\ndeclare const event: Event<T>\ndeclare const fx: Effect<T, any>\n\nlaunch({target: $store, params: T}): void\nlaunch({target: event, params: T}): void\nlaunch({target: fx, params: T}): void\n```\n\n----------------------------------------\n\nTITLE: Import split from effector\nDESCRIPTION: This code snippet imports the `split` function from the effector library, which is necessary to use it in the subsequent code.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/split.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { split } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Basic useEvent Example (JavaScript)\nDESCRIPTION: Demonstrates the basic usage of `useEvent` to bind an Effector event to a Vue component's event handler.  It creates an Effector event `incremented` and a store `$count`, then uses `useEvent` to create a function `onIncrement` that triggers the event.  The component exposes `onIncrement` for use in the template.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useEvent.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\nimport { useEvent } from \"effector-vue/ssr\";\n\nconst incremented = createEvent();\nconst $count = createStore(0);\n\n$count.on(incremented, (x) => x + 1);\n\nexport default {\n  setup() {\n    const counter = useStore($count);\n    const onIncrement = useEvent(incremented);\n\n    return {\n      onIncrement,\n      counter,\n    };\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: allSettled with Scope in Tests (TypeScript)\nDESCRIPTION: Shows how to use `allSettled` with an Effector Scope in a testing context to ensure all computations within the scope have completed, especially those triggered by external sources. It sets up a test scenario, binds an event to an external source, triggers the source, and then uses `allSettled` to await the completion of all computations before making assertions.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/allSettled.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {createEvent, sample, fork, scopeBind, allSettled} from 'effector'\n\ntest('интеграция с externalSource', async () => {\n  const scope = fork()\n\n  const updated = createEvent()\n\n  sample({\n    clock: updated,\n    target: someOtherLogicStart,\n  })\n\n  // 1. Подписываем событие на внешний источник\n  const externalUpdated = scopeBind(updated, {scope})\n  externalSource.listen(() => externalUpdates())\n\n  // 2. Запускаем обновление внешнего источника\n  externalSource.trigger()\n\n  // 3. Ожидаем завершения всех запущенных вычислений в области видимости effector, даже если они были запущены не самим effector\n  await allSettled(scope)\n\n  // 4. Проверяем что-либо как обычно\n  expect(...).toBe(...)\n})\n```\n\n----------------------------------------\n\nTITLE: Expanded Split Form with Effector\nDESCRIPTION: This example demonstrates the expanded form of the `split` method, which allows for more complex logic, including dependencies on external data (stores) and triggering multiple units.  It showcases how to perform different actions based on the application mode (`user` or `admin`).\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/flow-split.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { createStore, createEvent, split } from \"effector\";\n\nconst adminActionFx = createEffect();\nconst secondAdminActionFx = createEffect();\nconst userActionFx = createEffect();\nconst defaultActionFx = createEffect();\n// События для UI\nconst buttonClicked = createEvent();\n\n// Текущий режим приложения\nconst $appMode = createStore<\"admin\" | \"user\">(\"user\");\n\n// Разные события для разных режимов\nsplit({\n  source: buttonClicked,\n  match: $appMode, // Логика зависит от текущего режима\n  cases: {\n    admin: [adminActionFx, secondAdminActionFx],\n    user: userActionFx,\n    __: defaultActionFx,\n  },\n});\n\n// При клике одна и та же кнопка делает разные вещи\n// в зависимости от режима приложения\nbuttonClicked();\n// -> \"Выполняем пользовательское действие\" (когда $appMode = 'user')\n// -> \"Выполняем админское действие\" (когда $appMode = 'admin')\n```\n\n----------------------------------------\n\nTITLE: Rendering GitHub Contributor Profile with HTML\nDESCRIPTION: This HTML snippet renders a contributor's profile within a table cell. It includes the contributor's GitHub avatar, hyperlinked to their GitHub profile, and their username displayed below the avatar. The cell is styled for consistent width and height.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_6\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/senzujuju>\n        <img src=https://avatars.githubusercontent.com/u/95025705?v=4 width=\"100;\"  alt=Nikita Kungurcev/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Nikita Kungurcev</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_23\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/falkomerr>\n            <img src=https://avatars.githubusercontent.com/u/105551615?v=4 width=\"100;\"  alt=Roman Paravaev/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Roman Paravaev</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: ClassListArray type definition\nDESCRIPTION: Defines the `ClassListArray` type, which is an array of strings or stores of strings representing class names. This allows for a list of class names that can be dynamically updated.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ntype ClassListArray = Array<Store<string> | string>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_28\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/vladthelittleone>\n            <img src=https://avatars.githubusercontent.com/u/4215285?v=4 width=\"100;\"  alt=vladthelittleone/>\n            <br />\n            <sub style=\"font-size:14px\"><b>vladthelittleone</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Next.js configuration with Effector SWC Plugin\nDESCRIPTION: This JavaScript snippet shows how to configure the Effector SWC plugin in a Next.js project.  It adds the plugin to the `swcPlugins` array within the `experimental` section of `next.config.js`. An empty options object `{}` is passed to the plugin.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst nextConfig = {\n  experimental: {\n    // even if empty, pass an options object `{}` to the plugin\n    swcPlugins: [[\"@effector/swc-plugin\", {}]],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Effector Options in Vue Component\nDESCRIPTION: Demonstrates how to use the `effector` option in a Vue component to bind Effector stores and effects to the component's data and methods.  This example shows binding a store `$user` and an effect `createFx`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/VueEffector.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { $user, create, createFx } from 'model'\n\nexport default {\n  name: 'VueComponent',\n  effector: () => ({\n    user: $user,\n    createDone: createFx.done,\n    createPending: createFx.pending,\n  }),\n  watch: {\n    createDone() {\n      // do something after the effect is done\n    }\n  },\n  methods: {\n    create, // template binding\n    createFx,\n  },\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Vite legacy plugin configuration\nDESCRIPTION: Configures the Vite bundler to include legacy browser support using the `@vitejs/plugin-legacy` plugin. It specifies polyfills for Promise, Object.assign, Array.prototype.flat, Map, and Set.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/module/compat.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from \"vite\";\nimport legacy from \"@vitejs/plugin-legacy\";\n\nexport default defineConfig({\n  plugins: [\n    legacy({\n      polyfills: [\"es.promise\", \"es.object.assign\", \"es.array.flat\", \"es.map\", \"es.set\"],\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Effector in Deno\nDESCRIPTION: This example demonstrates how to import Effector directly from a CDN in a Deno environment. It imports the `createStore` function from the effector.mjs module.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/installation.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"https://cdn.jsdelivr.net/npm/effector/effector.mjs\";\n```\n\n----------------------------------------\n\nTITLE: Effector Store with Side Effect in Map (Incorrect)\nDESCRIPTION: This JavaScript code demonstrates an anti-pattern in Effector where an event is triggered directly within a store's `map` function.  This is generally discouraged as it makes the data flow harder to reason about.  It's better to use `watch` or `sample` for such side effects. Requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/glossary.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst submitLoginSize = createEvent();\n\nconst login = createStore(\"guest\");\nconst loginSize = login.map((login) => {\n  // лучше переместить этот вызов в watch или эффект\n  submitLoginSize(login.length);\n  return login.length;\n});\n```\n\n----------------------------------------\n\nTITLE: BrowserStack Environment Variables\nDESCRIPTION: These environment variables are required to authenticate with BrowserStack and run the tests. `BROWSERSTACK_USERNAME` is your BrowserStack username, and `BROWSERSTACK_ACCESS_KEY` is your access key.\nSOURCE: https://github.com/effector/effector/blob/master/src/compat/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nBROWSERSTACK_USERNAME=username\nBROWSERSTACK_ACCESS_KEY=key\n```\n\n----------------------------------------\n\nTITLE: ClassListMap type definition\nDESCRIPTION: Defines the `ClassListMap` type, which is an object mapping class names (strings) to boolean values or stores of boolean values. This allows for dynamic class toggling based on store values.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ntype ClassListMap = {[className: string]: Store<boolean> | boolean}\n```\n\n----------------------------------------\n\nTITLE: Session and User Name Store Update\nDESCRIPTION: This snippet updates the `$loggedIn` and `$userName` stores by connecting them to the session entity. The `$loggedIn` store is directly linked to the `$isLogged` store in the session entity, and the `$userName` store is derived from the `$session` store, displaying the user's name if logged in, or an empty string otherwise.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_19\n\nLANGUAGE: ts\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\nimport { $isLogged, $session } from \"entities/session\";\n\n// В данный момент есть только сырые данные без каких-либо знаний о том, как их загрузить\nexport const $loggedIn = $isLogged;\nexport const $userName = $session.map((session) => session?.name ?? \"\");\n```\n\n----------------------------------------\n\nTITLE: Watcher Type Definition\nDESCRIPTION: This code defines the TypeScript type for a watcher function. Watchers are used for side effects and are attached to Events, Stores, or Domains via `watch` or `onCreate*` hooks. The return value of a watcher is ignored. Dependencies: TypeScript.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/glossary.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntype Watcher<T> = (update: T) => any;\n```\n\n----------------------------------------\n\nTITLE: Using useUnit with Effector Store in React\nDESCRIPTION: Demonstrates how to use the `useUnit` hook from `effector-react` to connect an Effector store to a React component. It creates a simple store `$value` and displays its value in a paragraph element. The `useUnit` hook automatically subscribes the component to the store and updates the component when the store's value changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/ecosystem-development/unit-shape-protocol.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"effector\";\nimport { useUnit } from \"effector-react\";\n\nconst $value = createStore(\"Привет!\");\n\nconst Component = () => {\n  const { value } = useUnit({ value: $value });\n\n  return <p>{value}</p>;\n};\n```\n\n----------------------------------------\n\nTITLE: Using useUnit with Custom Route Entity in React\nDESCRIPTION: Illustrates how to use the `useUnit` hook with a custom `Route` entity created with a hypothetical `my-router-library`. It demonstrates how to access the `params` property of the route and display the `name` parameter. This snippet highlights the intended use case for the `@@unitShape` protocol.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/ecosystem-development/unit-shape-protocol.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createRoute } from \"my-router-library\";\nimport { useUnit } from \"effector-react\";\n\nconst mainPageRoute = createRoute(/* ... */);\n\nconst Component = () => {\n  const { params } = useUnit(mainPageRoute);\n\n  return <p>{params.name}</p>;\n};\n```\n\n----------------------------------------\n\nTITLE: Using pending Store with React\nDESCRIPTION: This code demonstrates how to use the `pending` store of an effector effect in a React component to display a loading indicator. It creates an effect and then uses the `useUnit` hook from `effector-react` to connect the `pending` store to the component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { createEffect } from \"effector\";\nimport { useUnit } from \"effector-react\";\n\nconst fetchApiFx = createEffect(async (ms) => {\n  await new Promise((resolve) => setTimeout(resolve, ms));\n});\n\nfetchApiFx.pending.watch(console.log);\n// => false\n\nconst App = () => {\n  const loading = useUnit(fetchApiFx.pending);\n  return <div>{loading ? \"Загрузка...\" : \"Загрузка завершена\"}</div>;\n};\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\nfetchApiFx(1000);\n// => true\n// => false\n```\n\n----------------------------------------\n\nTITLE: Effector SWC Plugin addNames Configuration\nDESCRIPTION: This JSON snippet shows an example configuration for the `addNames` option of the Effector SWC plugin. It enables adding names to Units when calling factories.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"addNames\": true }]\n```\n\n----------------------------------------\n\nTITLE: Short Form Split with Effector Stores\nDESCRIPTION: This snippet illustrates the short form of the `split` method, where the first argument is a unit (in this case, a store `$repo`) and the second argument is an object with cases.  It demonstrates toggling star and watch statuses for a repository, derived from a store, and splitting the flow based on the `isStarred` property.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/flow-split.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { createStore, createEvent, split } from \"effector\";\n\ntype Repo = {\n  // ... другие свойства\n  isStarred: boolean;\n  isWatched: boolean;\n};\n\nconst toggleStar = createEvent<string>();\nconst toggleWatch = createEvent<string>();\n\nconst $repo = createStore<null | Repo>(null)\n  .on(toggleStar, (repo) => ({\n    ...repo,\n    isStarred: !repo.isStarred,\n  }))\n  .on(toggleWatch, (repo) => ({ ...repo, isWatched: !repo.isWatched }));\n\nconst { starredRepo, unstarredRepo, __ } = split($repo, {\n  starredRepo: (repo) => repo.isStarred,\n  unstarredRepo: (repo) => !repo.isStarred,\n});\n\n// следим за случаем по умолчанию для дебага\n__.watch((repo) =>\n  console.log(\"[split toggleStar] Случай по умолчанию отработал со значением \", repo),\n);\n\n// где-то в приложении\ntoggleStar();\n```\n\n----------------------------------------\n\nTITLE: Migration: Removing scopeReplace from SWC plugin\nDESCRIPTION: Shows how to remove the bindings.react.scopeReplace parameter from the @effector/swc-plugin configuration during migration from effector-react/scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/module/scope.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n{\n  \"$schema\": \"https://json.schemastore.org/swcrc\",\n  \"jsc\": {\n    \"experimental\": {\n      \"plugins\": [\n        \"@effector/swc-plugin\",\n        {\n          \"bindings\": {\n            \"react\": {\n-             \"scopeReplace\": true\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_45\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/WoodenPC>\n        <img src=https://avatars.githubusercontent.com/u/25397745?v=4 width=\"100;\"  alt=Rasul />\n        <br />\n        <sub style=\"font-size:14px\"><b>Rasul </b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with pnpm\nDESCRIPTION: This command installs the core Effector library using the pnpm package manager. It provides an alternative installation method for users who prefer pnpm.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm install effector\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_7\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/Sozonov>\n        <img src=https://avatars.githubusercontent.com/u/1931637?v=4 width=\"100;\"  alt=Sozonov/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Sozonov</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: useUnit with Store - TypeScript\nDESCRIPTION: Describes the TypeScript signature for `useUnit` when used with an Effector Store. It shows how to subscribe to the store's state and returns an Accessor that provides the current value of the store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useUnit.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nuseUnit($store: Store<State>): Accessor<State>;\n```\n\n----------------------------------------\n\nTITLE: Fork with initial store values - TS\nDESCRIPTION: This TypeScript code demonstrates how to use the `values` option in the `fork` function to provide initial states for stores.  It shows three ways to pass initial values: as an array of tuples, as a Map, and as a plain object. The example shows the array of tuples approach.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/fork.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nfork({\n  values: [\n    [$user, \"alice\"],\n    [$age, 21],\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing connect from effector-react\nDESCRIPTION: This code snippet demonstrates how to import the `connect` function from the `effector-react` library. This function is used to connect effector stores to React components, though it is now deprecated.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/connect.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { connect } from \"effector-react\";\n```\n\n----------------------------------------\n\nTITLE: Effector onCreateEvent Hook Example\nDESCRIPTION: This example shows how to use the `onCreateEvent` hook to log a message to the console every time a new event is created in the domain.  It creates a domain and then defines a callback function that logs a message when a new event is created.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Domain.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createDomain } from \"effector\";\n\nconst domain = createDomain();\n\ndomain.onCreateEvent((event) => {\n  console.log(\"new event created\");\n});\n\nconst a = domain.createEvent();\n// => new event created\n\nconst b = domain.createEvent();\n// => new event created\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_26\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/Rastraponovich>\n            <img src=https://avatars.githubusercontent.com/u/58354560?v=4 width=\"100;\"  alt=Rastrapon/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Rastrapon</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Manual import change for effector-react\nDESCRIPTION: Shows how to manually change import to effector-react/compat\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/module/сompat.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n- import {useUnit} from 'effector-react'\n+ import {useUnit} from 'effector-react/compat'\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_52\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/000000armor>\n        <img src=https://avatars.githubusercontent.com/u/25207729?v=4 width=\"100;\"  alt=David/>\n        <br />\n        <sub style=\"font-size:14px\"><b>David</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Using useUnit with Stores\nDESCRIPTION: This example shows how to use `useUnit` to connect a React component to an Effector store.  It requires `effector` and `effector-react`.  The `useUnit` hook subscribes the component to the store, ensuring that the component re-renders whenever the store's value changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useUnit.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { createStore, createApi } from \"effector\";\nimport { useUnit } from \"effector-react\";\n\nconst $counter = createStore(0);\n\nconst { increment, decrement } = createApi($counter, {\n  increment: (state) => state + 1,\n  decrement: (state) => state - 1,\n});\n\nconst App = () => {\n  const counter = useUnit($counter);\n\n  return (\n    <div>\n      {counter}\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n};\n\n```\n\n----------------------------------------\n\nTITLE: Sample Multiple Sources - Typescript\nDESCRIPTION: Shows how to use multiple stores as a source for `sample`. It combines data from `$searchQuery` and `$filters` stores into a single object, which is then passed to the `submitSearchFx` effect when `searchClicked` is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, sample, createEffect } from \"effector\";\n\ntype SubmitSearch = {\n  query: string;\n  filters: Array<string>;\n};\n\nconst submitSearchFx = createEffect((params: SubmitSearch) => {\n  /// логика\n});\n\nconst searchClicked = createEvent();\n\nconst $searchQuery = createStore(\"\");\nconst $filters = createStore<string[]>([ ]);\n\nsample({\n  clock: searchClicked,\n  source: {\n    query: $searchQuery,\n    filters: $filters,\n  },\n  target: submitSearchFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Checking if value is a unit - Effector (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use the `is.unit()` method from Effector to check if a given value is a unit (Store, Event, or Effect). It imports necessary modules, creates instances of Store, Event, and Effect, and then uses `is.unit()` to verify their types.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/core-concepts.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, createEffect, is } from \"effector\";\n\nconst $counter = createStore(0);\nconst event = createEvent();\nconst fx = createEffect(() => {});\n\n// Check if value is a unit\nis.unit($counter); // true\nis.unit(event); // true\nis.unit(fx); // true\nis.unit({}); // false\n```\n\n----------------------------------------\n\nTITLE: Store Creation Example with Effector (Before Transformation)\nDESCRIPTION: This code snippet shows a basic store creation using Effector's `createStore` function, before any plugin transformations are applied.  It demonstrates a simple scenario where a store named `$name` is initialized with a `null` value. The plugins later add a unique `sid` property to this store creation.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst $name = createStore(null);\n```\n\n----------------------------------------\n\nTITLE: Incorrect usage of effects with async code\nDESCRIPTION: This snippet demonstrates the incorrect usage of effects with asynchronous operations. It shows how mixing regular asynchronous functions with Effector effects can lead to scope loss.  This example highlights the importance of wrapping all asynchronous operations within effects or using utilities like `attach`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Scope.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst sendWithAuthFx = createEffect(async () => {\n  await authUserFx();\n\n  // Неправильно! Это должно быть обернуто в эффект.\n  await new Promise((resolve) => setTimeout(resolve, 80));\n\n  // Контекст здесь теряется.\n  await sendMessageFx();\n});\n```\n\n----------------------------------------\n\nTITLE: Extracting Effect Type with `UnitValue` in Effector\nDESCRIPTION: Demonstrates how to use the `UnitValue` type utility to extract the data type from an Effector effect. This allows accessing the effect's parameters type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { UnitValue, createEffect, createStore, createEvent } from \"effector\";\n\nconst effect = createEffect<{ token: string }, any, string>(() => {});\ntype UnitEffectType = UnitValue<typeof effect>;\n// {token: string}\n```\n\n----------------------------------------\n\nTITLE: Basic useUnit with Event and Store (JSX)\nDESCRIPTION: Illustrates the basic usage of `useUnit` with an Effector Event and Store in a React component. It demonstrates how to increment a counter state using an event triggered by a button click. The component is wrapped in a `Provider` and rendered within a `Scope`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useUnit.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createEvent, createStore, fork } from \"effector\";\nimport { useUnit, Provider } from \"effector-react\";\nimport { render } from \"react-dom\";\n\nconst incrementClicked = createEvent();\nconst $count = createStore(0);\n\n$count.on(incrementClicked, (count) => count + 1);\n\nconst App = () => {\n  const [count, onIncrement] = useUnit([$count, incrementClicked]);\n\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => onIncrement()}>increment</button>\n    </>\n  );\n};\n\nconst scope = fork();\n\nrender(\n  () => (\n    <Provider value={scope}>\n      <App />\n    </Provider>\n  ),\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_55\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/mihasia20008>\n        <img src=https://avatars.githubusercontent.com/u/9918427?v=4 width=\"100;\"  alt=Alexander/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Alexander</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: HTML template for Store Shape\nDESCRIPTION: HTML template corresponding to the Javascript snippet demonstrating the `useVModel` hook with store shapes. It shows binding inputs to the state using the `v-model` directive in Vue.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useVModel.md#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<div id=\"app\">\n  <input type=\"text\" v-model=\"user.name\" />\n  <input type=\"text\" v-model=\"user.surname\" />\n\n  <div>\n    <input type=\"checkbox\" v-model=\"user.skills\" value=\"HTML\" />\n    <input type=\"checkbox\" v-model=\"user.skills\" value=\"CSS\" />\n    <input type=\"checkbox\" v-model=\"user.skills\" value=\"JS\" />\n  </div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Restoring Message Text on Failure - TypeScript\nDESCRIPTION: This snippet restores the message text in the input field if sending the message fails. It uses Effector's `sample` to react to the `messageSendFx.fail` event. It extracts the original message text from the `params` of the failed effect and sets it as the new value of the `$messageText` store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nsample({\n  clock: messageSendFx.fail,\n  fn: ({ params }) => params.text,\n  target: $messageText,\n});\n```\n\n----------------------------------------\n\nTITLE: React Component: Nesting Media Query-Based Components (JSX)\nDESCRIPTION: This JSX code shows how the `Screen` component can be nested to create more complex conditional rendering logic. The `AppLogo` component renders different content based on screen orientation and size, showcasing the flexibility of the approach.\nSOURCE: https://github.com/effector/effector/blob/master/recipes/media-queries/README.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nexport const AppLogo = ({brandName, fullLogo, squareLogo}) => (\n  <>\n    <Screen landscape>\n      <img src={fullLogo} />\n      <Screen large>{brandName}</Screen>\n    </Screen>\n    <Screen portrait>\n      <img src={squareLogo} />\n    </Screen>\n  </>\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Effect Handler with use() - Typescript\nDESCRIPTION: Defines the implementation of an effect. The handler function will be called when the effect is triggered. It accepts data with which the effect was called and returns a result or a Promise with a result.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fx: Effect<T, S>;\n\nfx.use(/*handler*/ (params: T) => S | Promise<S>);\n```\n\n----------------------------------------\n\nTITLE: Correct Declarative Effect Handling in Effector (TypeScript)\nDESCRIPTION: This snippet demonstrates the correct, declarative approach to handling side effects after an effect completes in Effector. It uses `sample` to trigger updates to `$user`, `redirectToDashboardFx`, and `showWelcomeNotificationFx` when `loginFx.doneData` emits, making the flow more manageable and testable.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginFx = createEffect((params) => api.login(params));\n// Связываем через sample\nsample({\n  clock: loginFx.doneData,\n  target: [\n    $user, // Обновляем стор\n    redirectToDashboardFx,\n    showWelcomeNotificationFx,\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: LocalStorage History Functions (Typescript)\nDESCRIPTION: Provides functions to load and save message history to localStorage. `loadHistory` retrieves the history, parsing it from JSON, while `saveHistory` serializes the provided messages to JSON and stores them.  Returns `undefined` if no data is found.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/shared/api/message.ts\nconst LocalStorageKey = \"effector-example-history\";\n\nfunction loadHistory(): Message[] | void {\n  const source = localStorage.getItem(LocalStorageKey);\n  if (source) {\n    return JSON.parse(source);\n  }\n  return undefined;\n}\nfunction saveHistory(messages: Message[]) {\n  localStorage.setItem(LocalStorageKey, JSON.stringify(messages));\n}\n```\n\n----------------------------------------\n\nTITLE: Sample Data Filtering - Typescript\nDESCRIPTION: Illustrates how to filter data using the `filter` parameter of `sample`.  It prevents the execution of the `submitToServerFx` effect unless the form data meets specific criteria (age >= 18 and username length > 0).\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, sample, createEffect } from \"effector\";\n\ntype UserFormData = {\n  username: string;\n  age: number;\n};\n\nconst submitForm = createEvent();\n\nconst $formData = createStore<UserFormData>({ username: \"\", age: 0 });\n\nconst submitToServerFx = createEffect((formData: UserFormData) => {\n  // логика\n});\n\nsample({\n  clock: submitForm,\n  source: $formData,\n  filter: (form) => form.age >= 18 && form.username.length > 0,\n  target: submitToServerFx,\n});\n\nsubmitForm();\n```\n\n----------------------------------------\n\nTITLE: Sample Usage to create derived store - Typescript\nDESCRIPTION: Shows how to create a derived store using `sample`. It takes the `age` property from the `$currentUser` store and assigns it to the `$userAge` store.  This provides a way to reactively update one store based on changes in another.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, sample } from \"effector\";\n\nconst $currentUser = createStore({ name: \"Bob\", age: 25 });\n\n// создает производный стор, который обновляется, когда source меняется\nconst $userAge = sample({\n  source: $currentUser,\n  fn: (user) => user.age,\n});\n// эквивалентно\nconst $userAgeViaMap = $currentUser.map((currentUser) => currentUser.age);\n```\n\n----------------------------------------\n\nTITLE: Attaching Effect with mapParams\nDESCRIPTION: Attaches an effect to another effect, transforming parameters using a `mapParams` function. When the attached effect is called, the parameters are transformed and passed to the original effect. If `mapParams` throws an error, the attached effect fails.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst attachedFx = attach({\n  effect: originalFx,\n  mapParams,\n});\n```\n\n----------------------------------------\n\nTITLE: Import Effect type from effector\nDESCRIPTION: Imports the Effect type from the effector library. This type represents an asynchronous operation or a function that can throw errors. This allows using `Effect` in type annotations.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type Effect } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_51\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/ayuhito>\n        <img src=https://avatars.githubusercontent.com/u/38220115?v=4 width=\"100;\"  alt=Ayu/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Ayu</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Single Store State Management Serialization (Redux)\nDESCRIPTION: Demonstrates serializing and deserializing the entire state in a single-store state management system like Redux.  It shows how the entire store's state can be serialized on the server and then parsed and used to initialize the client-side store. This approach relies on the implicit unique naming of keys within the store's object.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// server.ts\nimport { createStore } from \"single-store-state-manager\";\n\nfunction handlerRequest() {\n  const store = createStore({ initialValue: null });\n\n  return {\n    // Можно просто сериализовать весь стор\n    state: JSON.stringify(store.getState()),\n  };\n}\n\n// client.ts\nimport { createStore } from \"single-store-state-manager\";\n\n// Предположим, что сервер поместил состояние в HTML\nconst serverState = readServerStateFromWindow();\n\nconst store = createStore({\n  // Просто парсим все состояние и используем его как состояние клиента\n  initialValue: JSON.parse(serverState),\n});\n```\n\n----------------------------------------\n\nTITLE: Using `useList` with keys for UI Updates - TSX\nDESCRIPTION: This snippet demonstrates using the `useList` hook from Effector React to render a list of messages. It provides `keys` to the hook, specifically `messageDeleting`, to ensure that the UI updates correctly when the `messageDeleting` state changes. This prevents caching issues and ensures that the 'Deleting' state is properly displayed on the button.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_30\n\nLANGUAGE: tsx\nCODE:\n```\nconst messages = useList(model.$messages, {\n  keys: [messageDeleting],\n  fn: (message) => (\n    <div className=\"message-item\" key={message.timestamp}>\n      <h3>From: {message.author.name}</h3>\n      <p>{message.text}</p>\n      <button onClick={() => handleMessageDelete(message)} disabled={messageDeleting}>\n        {messageDeleting ? \"Deleting\" : \"Delete\"}\n      </button>\n    </div>\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: useList with Configuration Example\nDESCRIPTION: Demonstrates useList with the configuration object to specify dependencies for re-rendering.  It shows how to update a rendered list when a property from an external store changes. It imports `ReactDOM` from react-dom, `createEvent`, `createStore`, `restore` from effector, and `useUnit`, `useList` from effector-react.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useList.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport ReactDOM from \"react-dom\";\nimport { createEvent, createStore, restore } from \"effector\";\nimport { useUnit, useList } from \"effector-react\";\n\nconst renameUser = createEvent();\nconst $user = restore(renameUser, \"alice\");\nconst $friends = createStore([\"bob\"]);\n\nconst App = () => {\n  const user = useUnit($user);\n  return useList($friends, {\n    keys: [user],\n    fn: (friend) => (\n      <div>\n        {friend} is a friend of {user}\n      </div>\n    ),\n  });\n};\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n// => <div> bob is a friend of alice </div>\n\nsetTimeout(() => {\n  renameUser(\"carol\");\n  // => <div> bob is a friend of carol </div>\n}, 500);\n\n```\n\n----------------------------------------\n\nTITLE: Installing Effector SWC Plugin\nDESCRIPTION: This command installs the Effector SWC plugin as a development dependency. The SWC plugin enhances Effector's functionality within projects using the SWC compiler.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/installation.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -ED @effector/swc-plugin @swc/core\n```\n\n----------------------------------------\n\nTITLE: Storing Last Received Message - TypeScript\nDESCRIPTION: This snippet demonstrates how to create a store to hold the last received message from the WebSocket. It defines a store `$lastMessage` that is updated whenever a new message is received via the `messageReceived` event. Dependencies: effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/websocket-integration.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst $lastMessage = createStore(\"\");\n\n$lastMessage.on(messageReceived, (_, newMessage) => newMessage);\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_40\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/c01nd01r>\n        <img src=https://avatars.githubusercontent.com/u/3511312?v=4 width=\"100;\"  alt=Stanislav/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Stanislav</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: allSettled with Event Example (TypeScript)\nDESCRIPTION: Demonstrates how to use `allSettled` with an Effector Event to ensure all its triggered executions within a scope have completed. It forks a scope, creates an event, watches it for logging, and then uses `allSettled` to wait for the event to settle within the scope with specified parameters.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/allSettled.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst scope = fork();\nconst event = createEvent<number>();\n\nevent.watch(console.log);\n\nawait allSettled(event, { scope, params: 123 }); // в консоль выведется 123\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_36\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/ilfey>\n        <img src=https://avatars.githubusercontent.com/u/68865207?v=4 width=\"100;\"  alt=ilfey/>\n        <br />\n        <sub style=\"font-size:14px\"><b>ilfey</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Babel plugin configuration for factories\nDESCRIPTION: This snippet configures the `effector/babel-plugin` to properly handle factories. The `factories` option should include the path to the `authorized.ts` file where the factories are defined. This configuration ensures that the factory functions are correctly processed by the Babel plugin.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/attach.md#_snippet_16\n\nLANGUAGE: json5\nCODE:\n```\n// .babelrc\n{\n  plugins: [\n    [\n      \"effector/babel-plugin\",\n      {\n        factories: [\"src/path-to-your-entity/api/authorized\"],\n      },\n    ],\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Import fromObservable and Observable from effector\nDESCRIPTION: Imports the `fromObservable` function and the `Observable` type from the effector library. This is required to use `fromObservable` to convert an Observable into an effector Event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/fromObservable.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromObservable, type Observable } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_58\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/yialo>\n        <img src=https://avatars.githubusercontent.com/u/38593881?v=4 width=\"100;\"  alt=Alex Arro/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Alex Arro</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Typing `sample` with `filter` and `fn` in Effector with TypeScript\nDESCRIPTION: Explains the intricacies of using `filter` and `fn` together in `sample` and how to ensure proper type inference. Requires explicitly defining the type of the filter's parameter and using type predicates to guide TypeScript's type inference due to limitations in TypeScript's type system.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ntype UserMessage = { kind: \"user\"; text: string };\ntype WarnMessage = { kind: \"warn\"; warn: string };\ntype Message = UserMessage | WarnMessage;\n\nconst message = createEvent<Message>();\nconst userText = createEvent<string>();\n\nsample({\n  clock: message,\n  filter: (msg: Message): msg is UserMessage => msg.kind === \"user\",\n  fn: (msg) => msg.text,\n  target: userText,\n});\n\n// userMessage has type Event<string>\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_57\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/jokecodes>\n        <img src=https://avatars.githubusercontent.com/u/12380196?v=4 width=\"100;\"  alt=jokecodes/>\n        <br />\n        <sub style=\"font-size:14px\"><b>jokecodes</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Chat History Component with Effector\nDESCRIPTION: This snippet demonstrates how to use Effector with React to render the chat history. It utilizes `useUnit` and `useList` from `effector-react` to connect the component to Effector stores and events.  `useList` efficiently updates the message list, while `useUnit` connects actions and stores.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\n// Файл: /src/pages/chat/page.tsx\nimport { useList, useUnit } from \"effector-react\";\nimport * as model from \"./model\";\n\n// export function ChatPage { ... }\n\nfunction ChatHistory() {\n  const [messageDeleting, onMessageDelete] = useUnit([\n    model.$messageDeleting,\n    model.messageDeleteClicked,\n  ]);\n\n  // Хук `useList` позволяет React не перерендерить сообщения, которые действительно не изменились.\n  const messages = useList(model.$messages, (message) => (\n    <div className=\"message-item\" key={message.timestamp}>\n      <h3>From: {message.author.name}</h3>\n      <p>{message.text}</p>\n      <button onClick={() => onMessageDelete(message)} disabled={messageDeleting}>\n        {messageDeleting ? \"Deleting\" : \"Delete\"}\n      </button>\n    </div>\n  ));\n  // Здесь не нужен `useCallback` потому что мы передаем функцию в HTML-элемент, а не в кастомный компонент\n\n  return <div className=\"chat-history\">{messages}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing effector with Vue\nDESCRIPTION: This command installs both the core effector package and the effector-vue package, which provides bindings and utilities for using effector with Vue. This installation is necessary when you're building Vue applications that leverage effector for state management.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm add effector effector-vue\n```\n\n----------------------------------------\n\nTITLE: Validating Effector Store with `is.store` in JavaScript\nDESCRIPTION: This snippet demonstrates how to use `is.store` to check if a given value is an Effector store. It imports necessary modules from Effector and creates a store, event, and effect for testing purposes. The snippet then calls `is.store` with different values and logs the results to the console, showing examples of when it returns true or false.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/is.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain } from \"effector\";\n\nconst store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\n\nis.store(store);\n// => true\n\nis.store(event);\n// => false\n\nis.store(fx);\n// => false\n\nis.store(createDomain());\n// => false\n\nis.store(fx.pending);\n// => true\n\nis.store(fx.done);\n// => false\n\nis.store(store.updates);\n// => false\n\nis.store(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: Clearing Message Input Field\nDESCRIPTION: This snippet demonstrates how to clear the message input field after a message is successfully sent. It uses the messageSendFx effect to reset the $messageText store to an empty string when the message is sent.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\n$messageText.on(messageSendFx, () => \"\");\n```\n\n----------------------------------------\n\nTITLE: Creating Events with Effector\nDESCRIPTION: This snippet demonstrates how to create events using Effector's `createEvent` function. Events represent facts that occur in the application and are used to trigger changes in state and logic. The events do not contain logic themselves, but rather initiate processes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/resources/mindset.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n// Не думайте о реализации сейчас — только объявите факт\nconst searchInputChanged = createEvent();\nconst buttonClicked = createEvent();\n```\n\n----------------------------------------\n\nTITLE: Basic Sample Usage with Event, Store and Effect - Typescript\nDESCRIPTION: Demonstrates the basic usage of `sample` to connect a button click event to fetching user data from a store. The `sample` function triggers `fetchUserFx` with the value of `$userName` when `buttonClicked` is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent, sample, createEffect } from \"effector\";\n\nconst buttonClicked = createEvent();\n\nconst $userName = createStore(\"Bob\");\n\nconst fetchUserFx = createEffect((userName) => {\n  // логика\n});\n\n// При клике на кнопку получаем текущее имя\nsample({\n  clock: buttonClicked,\n  source: $userName,\n  target: fetchUserFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Effect Handler with use() - Javascript\nDESCRIPTION: Defines an effect handler using the `use` method of an Effector effect. It showcases how to define an asynchronous handler function that fetches data and returns it.  This handler is used when the effect is called.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchUserReposFx = createEffect();\n\n// ....\n\nfetchUserReposFx.use(async ({ name }) => {\n  console.log(\"fetchUserReposFx вызван для github пользователя\", name);\n\n  const url = `https://api.github.com/users/${name}/repos`;\n  const req = await fetch(url);\n  return req.json();\n});\n\nawait fetchUserReposFx({ name: \"zerobias\" });\n// => fetchUserReposFx вызван для github пользователя zerobias\n```\n\n----------------------------------------\n\nTITLE: Effector: Media Matcher Function (JS)\nDESCRIPTION: This code defines a reusable function `mediaMatcher` that creates an Effector store to track whether a given media query matches the current screen state. It returns an effector store `$isQueryMatches` representing if the media query is active.\nSOURCE: https://github.com/effector/effector/blob/master/recipes/media-queries/README.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\n//mediaMatcher.js\nimport {createEvent, createStore} from 'effector'\n\nexport function mediaMatcher(query) {\n  const queryChange = createEvent()\n  const mediaQueryList = window.matchMedia(query)\n  mediaQueryList.addListener(queryChange)\n\n  const $isQueryMatches = createStore(mediaQueryList.matches).on(\n    queryChange,\n    (_, event) => event.matches,\n  )\n\n  return $isQueryMatches\n}\n```\n\n----------------------------------------\n\nTITLE: Watching inFlight Store on Effect\nDESCRIPTION: This code demonstrates how to use the `inFlight` store of an effector effect to track the number of running effects. It creates an effect and then watches the `inFlight` store to log the current number of running requests.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect(async () => {\n  await new Promise((resolve) => setTimeout(resolve, 500));\n});\n\nfx.inFlight.watch((amount) => {\n  console.log(\"выполняется запросов:\", amount);\n});\n// => выполняется запросов: 0\n\nconst req1 = fx();\n// => выполняется запросов: 1\n\nconst req2 = fx();\n// => выполняется запросов: 2\n\nawait Promise.all([req1, req2]);\n\n// => выполняется запросов: 1\n// => выполняется запросов: 0\n```\n\n----------------------------------------\n\nTITLE: Effector restore with Event example (JavaScript)\nDESCRIPTION: This snippet demonstrates how to create a store from an event using `restore`. The store's value is updated whenever the event is triggered with a payload. It requires `createEvent` and `restore` from effector. Outputs the state to the console on each update.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/restore.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, restore } from \"effector\";\n\nconst event = createEvent();\nconst $store = restore(event, \"default\");\n\n$store.watch((state) => console.log(\"state: \", state));\n// state: default\n\nevent(\"foo\");\n// state: foo\n```\n\n----------------------------------------\n\nTITLE: noDefaults Configuration example\nDESCRIPTION: Example configuring the `noDefaults` option in the Effector Babel plugin for making custom unit factories with clean configuration.  Demonstrates how multiple plugins can be configured with different options.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n// .babelrc\n{\n  \"plugins\": [\n    [\"effector/babel-plugin\", { \"addLoc\": true }],\n    [\n      \"effector/babel-plugin\",\n      {\n        \"importName\": \"@lib/createInputField\",\n        \"storeCreators\": [\"createInputField\"],\n        \"noDefaults\": true\n      },\n      \"createInputField\"\n    ]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Launch with Configuration Object\nDESCRIPTION: Defines the function signature for `launch` when invoked with a configuration object. This method provides fine-grained control, including options for `target`, `params`, `defer`, `page`, `scope`, and `meta`. It's typically used by library developers for advanced control over computations.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/launch.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nlaunch({\n  target,\n  params,\n  defer?: boolean,\n  page?: any,\n  scope?: Scope,\n  meta?: Record<string, any>,\n}): void\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_30\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/nulladdict>\n            <img src=https://avatars.githubusercontent.com/u/26379644?v=4 width=\"100;\"  alt=roman/>\n            <br />\n            <sub style=\"font-size:14px\"><b>roman</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Effector Factory Usage TypeScript Example\nDESCRIPTION: This TypeScript code demonstrates how to use the `createBooleanStore` factory function defined in `/src/factory.ts`. The created store `$boolean` is then treated as a factory-created unit by the Effector SWC plugin.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// file: /src/widget/user.ts\nimport { createBooleanStore } from \"../factory\";\n\nconst $boolean = createBooleanStore(); /* Treated as a factory! */\n```\n\n----------------------------------------\n\nTITLE: useStoreMap Signature (with Dependencies)\nDESCRIPTION: Defines the overload of the `useStoreMap` hook that accepts a configuration object with dependencies (keys). This version is useful when the selector function depends on external values.  It also includes optional `updateFilter` and `defaultValue` options for fine-grained control over updates and default values, respectively.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useStoreMap.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nuseStoreMap<Source, Result>({  store: Store<Source>;  keys: any[];  fn: (state: Source, keys: any[]) => Result;  updateFilter?: (newResult: Result, oldResult: Result) => boolean;  defaultValue?: Result;}): Result\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_47\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/outbreak>\n        <img src=https://avatars.githubusercontent.com/u/64531?v=4 width=\"100;\"  alt=Dmitry Dudin/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Dmitry Dudin</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Typing `split` in Effector with TypeScript\nDESCRIPTION: Illustrates how to use type predicates with `split` to divide an event's type into multiple variants. This facilitates precise routing of events based on their type. From Typescript 5.5 onwards type predicates can be omitted.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ntype UserMessage = { kind: \"user\"; text: string };\ntype WarnMessage = { kind: \"warn\"; warn: string };\n\nconst message = createEvent<UserMessage | WarnMessage>();\n\nconst { userMessage, warnMessage } = split(message, {\n  userMessage: (msg): msg is UserMessage => msg.kind === \"user\",\n  warnMessage: (msg): msg is WarnMessage => msg.kind === \"warn\",\n});\n// userMessage имеет тип Event<UserMessage>\n// warnMessage имеет тип Event<WarnMessage>\n```\n\nLANGUAGE: typescript\nCODE:\n```\ntype UserMessage = { kind: \"user\"; text: string };\ntype WarnMessage = { kind: \"warn\"; warn: string };\n\nconst message = createEvent<UserMessage | WarnMessage>();\n\nconst { userMessage, warnMessage } = split(message, {\n  userMessage: (msg) => msg.kind === \"user\",\n  warnMessage: (msg) => msg.kind === \"warn\",\n});\n// userMessage имеет тип Event<UserMessage>\n// warnMessage имеет тип Event<WarnMessage>\n```\n\n----------------------------------------\n\nTITLE: Accessing Effect Done Event - Javascript\nDESCRIPTION: Illustrates the `done` event of an Effector effect. It shows how to attach a watcher to the `done` event, which triggers after the effect has completed successfully. The watcher logs both the parameters passed to the effect and the result of its execution.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fx = createEffect((value) => value + 1);\n\nfx.done.watch(({ params, result }) => {\n  console.log(\"Вызов с аргументом\", params, \"завершён со значением\", result);\n});\n\nawait fx(2);\n// => Вызов с аргументом 2 завершён со значением 3\n```\n\n----------------------------------------\n\nTITLE: Preventing Unit Calls from Pure Functions in filter (TS)\nDESCRIPTION: This code shows an example of an anti-pattern where an event or effect is called directly within a pure function of `.filter` method (like guards). This throws an error in effector 23.0.0 and later. This is the incorrect code.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst countReceived = createEvent<number>();\nconst eachReceived = createEvent<number>();\n\nconst receivedEven = someHappened.filter({\n  fn(count) {\n    eachReceived(count); // THROWS!\n    return count % 2 === 0;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: TypeScript Subscription Type Definition\nDESCRIPTION: This TypeScript code defines the type signature for a `Subscription` object. It represents a function that can be called to unsubscribe from a watcher, preventing it from receiving further updates. The `unsubscribe` method is also available for clarity.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/glossary.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype Subscription = {\n  (): void;\n  unsubscribe(): void;\n};\n```\n\n----------------------------------------\n\nTITLE: Extracting Scope Type with `UnitValue` in Effector\nDESCRIPTION: Demonstrates how to use the `UnitValue` type utility to extract the data type from an Effector scope. This is useful for accessing scope value type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { UnitValue, createEffect, createStore, createEvent } from \"effector\";\n\nconst scope = fork();\ntype UnitScopeType = UnitValue<typeof scope>;\n// any\n```\n\n----------------------------------------\n\nTITLE: fromObservable Signature - Typescript\nDESCRIPTION: Defines the type signature for the `fromObservable` function. It takes an Observable of type `T` as input and returns an Event of type `T`. This indicates that the event will emit values of the same type as the observable.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/fromObservable.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction fromObservable(stream: Observable<T>): Event<T>;\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_18\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/gitter-badger>\n            <img src=https://avatars.githubusercontent.com/u/8518239?v=4 width=\"100;\"  alt=The Gitter Badger/>\n            <br />\n            <sub style=\"font-size:14px\"><b>The Gitter Badger</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_48\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/tensenrey>\n        <img src=https://avatars.githubusercontent.com/u/67154333?v=4 width=\"100;\"  alt=Dmitry/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Dmitry</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Creating Stores with SIDs in Effector\nDESCRIPTION: Shows how to create Effector stores with manually assigned SIDs. The `createStore` function is used, and a unique string `sid` is provided in the configuration object. This SID is used to distinguish stores between different environments.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst $name = createStore(null, { sid: \"name\" });\nconst $age = createStore(null, { sid: \"age\" });\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_17\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/usmanyunusov>\n            <img src=https://avatars.githubusercontent.com/u/28816324?v=4 width=\"100;\"  alt=Usman Yunusov/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Usman Yunusov</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Effect usage in worker.js\nDESCRIPTION: Code snippet demonstrating how to use an effector's effect inside of a worker. The result is posted back to the main thread with the SID.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\n// worker.js\nimport { getUsers } from \"./common.js\";\n\ngetUsers.use((userID) => fetch(userID));\n\ngetUsers.done.watch(({ result }) => {\n  postMessage({ sid: getUsers.sid, result });\n});\n\nonmessage = async ({ data }) => {\n  if (data.sid !== getUsers.sid) return;\n  getUsers(data.userID);\n};\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_27\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/romadryud>\n            <img src=https://avatars.githubusercontent.com/u/19193036?v=4 width=\"100;\"  alt=Raman Aktsisiuk/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Raman Aktsisiuk</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Filtering Event Data with .filter() (Effector)\nDESCRIPTION: Shows how to use `.filter()` to create a derived event that is triggered only when a condition is met. The function `fn` determines whether the derived event is triggered. Requires `effector` library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst numberReceived = createEvent<number>();\n// numberReceived: Event<number>\n\nconst evenReceived = numberReceived.filter({\n  fn: (number) => number % 2 === 0,\n});\n// evenReceived: Event<number>\n\nevenReceived.watch(console.info);\nnumberReceived(5); // ничего\nnumberReceived(2); // => 2\n```\n\n----------------------------------------\n\nTITLE: Extracting Store Value Type with StoreValue (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the `StoreValue` type utility to extract the data type specifically from Effector stores. It showcases how `StoreValue` can be used to define a type that represents the value held by a store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, StoreValue } from \"effector\";\n\nconst $store = createStore(true);\n\ntype StoreValueType = StoreValue<typeof $store>;\n// boolean\n```\n\n----------------------------------------\n\nTITLE: Importing hydrate from effector\nDESCRIPTION: Imports the `hydrate` function from the Effector library. This function is crucial for hydrating store values within a specified domain or scope, typically used to restore application state on the client-side after server-side rendering.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/hydrate.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { hydrate } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_19\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/Zulcom>\n            <img src=https://avatars.githubusercontent.com/u/11247988?v=4 width=\"100;\"  alt=Simon Muravev/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Simon Muravev</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: fromObservable Usage with RxJS - Javascript\nDESCRIPTION: This example demonstrates how to use the `fromObservable` function with RxJS. It creates an observable using `interval` from RxJS and then converts it to an effector event using `fromObservable`. The event is then watched, and its values are logged to the console.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/fromObservable.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { interval } from \"rxjs\";\nimport { fromObservable } from \"effector\";\n\n//emit value in sequence every 1 second\nconst source = interval(1000);\n\nconst event = fromObservable(source);\n\n//output: 0,1,2,3,4,5....\nevent.watch(console.log);\n```\n\n----------------------------------------\n\nTITLE: SID Access After withFactory\nDESCRIPTION: Shows how to access the combined SIDs of the inner units after wrapping the custom factory with `withFactory`. The `sid` is a concatenation of the factory's `sid` and the inner unit's `sid`, separated by a pipe (`|`).\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\npersonOne.$name.sid; // gre24f|ffds2\npersonTwo.$name.sid; // lpefgd|ffds2\n```\n\n----------------------------------------\n\nTITLE: Webpack alias configuration\nDESCRIPTION: Configures Webpack to automatically replace `effector` with `effector/compat` using the `resolve.alias` option. This simplifies importing and ensures compatibility.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/module/compat.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  resolve: {\n    alias: {\n      effector: \"effector/compat\",\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Checking with Effector Events\nDESCRIPTION: This example demonstrates TypeScript's type checking when working with Effector events.  It creates two events, `someHappened` (number) and `anotherHappened` (string), and attempts to connect them with `sample`. TypeScript flags this as an error because the event types are incompatible, ensuring type safety in the Effector application.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample, createEvent } from \"effector\";\n\nconst someHappened = createEvent<number>();\nconst anotherHappened = createEvent<string>();\n\nsample({\n  // @ts-expect-error error:\n  // \"clock should extend target type\";\n  // targets: { clockType: number; targetType: string; }\n  clock: someHappened,\n  target: anotherHappened,\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering Sneakers Size (TS)\nDESCRIPTION: This example filters a stream of sneaker objects to only trigger when the size is 48. This demonstrates a practical use case for filtering events based on specific criteria.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst sneackersReceived = createEvent<Sneakers>();\nconst uniqueSizeReceived = sneackersReceived.filter({\n  fn: (sneackers) => sneackers.size === 48,\n});\n```\n\n----------------------------------------\n\nTITLE: clearNode Function Signature\nDESCRIPTION: Defines the function signature of `clearNode` in Typescript. It shows the two possible overloads: one that takes a Unit and another that takes a Unit and a configuration object with an optional `deep` property. The function returns void.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/clearNode.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nclearNode(unit: Unit): void\nclearNode(unit: Unit, config: {deep?: boolean}): void\n```\n\n----------------------------------------\n\nTITLE: Sample with data transformation and void target\nDESCRIPTION: Demonstrates using `sample` to connect an event with data to an event without data (void). It shows how data transformation can occur between events with different type signatures.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nsample({\n  clock: withData, // Event<number>\n  target: withoutData, // Event<void>\n});\n```\n\n----------------------------------------\n\nTITLE: Incorrect Imperative Calls in Effector (TypeScript)\nDESCRIPTION: This snippet illustrates the anti-pattern of making imperative calls within an Effector effect.  The `loginFx` effect directly calls `setUser`, `redirectFx`, and `showNotification` after a successful login, which is not a declarative approach.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginFx = createEffect(async (params) => {\n  const user = await api.login(params);\n\n  // Императивные вызовы\n  setUser(user);\n  redirectFx(\"/dashboard\");\n  showNotification(\"Welcome!\");\n\n  return user;\n});\n```\n\n----------------------------------------\n\nTITLE: Extracting Effect Parameters Type with EffectParams (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the `EffectParams` type utility to extract the parameter type from an Effector effect. It showcases how `EffectParams` can be used to define a type that represents the input parameters of an effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect, EffectParams } from \"effector\";\n\nconst fx = createEffect<\n  { id: string },\n  { name: string; isAdmin: boolean },\n  { statusText: string; status: number }\n>(() => {\n  // ...\n  return { name: \"Alice\", isAdmin: false };\n});\n\ntype EffectParamsType = EffectParams<typeof fx>;\n// {id: string}\n```\n\n----------------------------------------\n\nTITLE: Effector Babel Plugin Configuration\nDESCRIPTION: Shows the configuration of the Effector Babel plugin within a `.babelrc` file.  The `factories` option is used to specify the import paths of custom factories, enabling the plugin to wrap them with `withFactory` for proper SID handling.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\n    [\n      \"effector/babel-plugin\",\n      {\n        \"factories\": [\"@/shared/lib/create-name\"]\n      }\n    ]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Timer Effect with scopeBind\nDESCRIPTION: This code demonstrates the corrected version of the `startFx` effect using `scopeBind`. By binding the `tick` event to the current scope using `scopeBind(tick)`, the scope is preserved when the event is triggered within `setInterval`, preventing potential scope loss.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/advanced/work-with-scope.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst startFx = createEffect(() => {\n  const bindedTick = scopeBind(tick);\n\n  const intervalId = setInterval(() => {\n    bindedTick();\n  }, TIMEOUT);\n\n  return intervalId;\n});\n```\n\n----------------------------------------\n\nTITLE: Creating and using an Event with createEvent (JavaScript)\nDESCRIPTION: This example shows how to create a store and event using `createStore` and `createEvent` from Effector. The event `incrementBy` is used to update the `$counter` store, and `resetCounter` is used to reset it. The `.watch` method is used to log the current counter value.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/createEvent.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst incrementBy = createEvent();\nconst resetCounter = createEvent();\nconst $counter = createStore(0);\n\n$counter.on(incrementBy, (counter, number) => counter + number).reset(resetCounter);\n\n$counter.watch((counter) => {\n  console.log(\"counter is now\", counter);\n});\n// => counter is now 0\n\nincrementBy(10);\n// => counter is now 10\n\nincrementBy(10);\n// => counter is now 20\n\nincrementBy(10);\n// => counter is now 30\n\nresetCounter();\n// => counter is now 0\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_39\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/dmitryplyaskin>\n        <img src=https://avatars.githubusercontent.com/u/35658668?v=4 width=\"100;\"  alt=dmitryplyaskin/>\n        <br />\n        <sub style=\"font-size:14px\"><b>dmitryplyaskin</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Incorrect Event Call Example\nDESCRIPTION: Illustrates an incorrect usage of derived `Event` calling. The `map` method returns an `Event`, which is read-only.  Calling read-only event causes an error.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberReceived = createEvent<number>(); // EventCallable<number>\nconst stringifiedReceived = numberReceived.map((number) => String(number)); // Event<string>\n\nstringifiedReceived(\"123\"); // ВЫЗЫВАЕТ ОШИБКУ!\n```\n\n----------------------------------------\n\nTITLE: Starting Initialization with Scopes (TypeScript)\nDESCRIPTION: This snippet shows how to start the application's initialization using `appStarted` event. It demonstrates two approaches: one without scopes, triggering `initFx` directly, and another using scopes, triggering `initFx` within a specified scope using `allSettled`. This approach is beneficial for SSR.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample } from \"effector\";\nimport { scope } from \"./app.js\";\n\nsample({\n  clock: appStarted,\n  target: initFx,\n});\n\nappStarted();\n```\n\n----------------------------------------\n\nTITLE: Getting Current Effect Handler with use.getCurrent() - Javascript\nDESCRIPTION: Demonstrates retrieving the current handler function of an Effector effect using `use.getCurrent()`.  It shows how the returned handler changes when a new handler is assigned using `use()` method. This example shows how it can be used for testing.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst handlerA = () => \"A\";\nconst handlerB = () => \"B\";\n\nconst fx = createEffect(handlerA);\n\nconsole.log(fx.use.getCurrent() === handlerA);\n// => true\n\nfx.use(handlerB);\nconsole.log(fx.use.getCurrent() === handlerB);\n// => true\n```\n\n----------------------------------------\n\nTITLE: Effector onCreateDomain Hook Formula\nDESCRIPTION: Demonstrates the signature for the `onCreateDomain` hook. This hook allows you to execute a callback function every time a subdomain is created within the domain. The callback receives the created domain as its argument.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Domain.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndomain.onCreateDomain((domain) => {});\n```\n\n----------------------------------------\n\nTITLE: Integrating Effector with Solid\nDESCRIPTION: This Solid component demonstrates how to integrate Effector with Solid using the `useUnit` hook from `effector-solid`.  It consumes the $counter store and the incremented and decremented events.  Different ways of consuming the store and events are demonstrated.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\nimport { useUnit } from \"effector-solid\";\nimport { $counter, incremented, decremented } from \"./counter.js\";\n\nconst Counter = () => {\n  const [counter, onIncremented, onDecremented] = useUnit([$counter, incremented, decremented]);\n  // или\n  const { counter, onIncremented, onDecremented } = useUnit({ $counter, incremented, decremented });\n  // или\n  const counter = useUnit($counter);\n  const onIncremented = useUnit(incremented);\n  const onDecremented = useUnit(decremented);\n\n  return (\n    <div>\n      <h1>Count: {counter()}</h1>\n      <button onClick={onIncremented}>Increment</button>\n      <button onClick={onDecremented}>Decrement</button>\n    </div>\n  );\n};\n\nexport default Counter;\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with npm\nDESCRIPTION: This command installs the Effector library using npm, a package manager for JavaScript.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector\n```\n\n----------------------------------------\n\nTITLE: Manual Effector Replacement (Diff)\nDESCRIPTION: This diff snippet illustrates how to manually replace imports from `effector` with imports from `effector/compat`. This can be done in any file where Effector functions are used.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/module/compat.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n- import {createStore} from 'effector'\n+ import {createStore} from 'effector/compat'\n```\n\n----------------------------------------\n\nTITLE: useStore signature in Typescript\nDESCRIPTION: Defines the function signature for the `useStore` hook. It takes a generic `Store<T>` as input and returns a value of type `T`, which represents the store's current state. This signature illustrates how to use the hook with different types of stores.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useStore.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nuseStore(store: Store<T>): T\n```\n\n----------------------------------------\n\nTITLE: Inspecting withRegion Metadata\nDESCRIPTION: Illustrates how to access metadata provided via a region's root node using `inspectGraph`. This metadata can be used to provide additional context about the region and its contents, enabling more detailed debugging and monitoring.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/inspect.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createNode, withRegion, createStore } from \"effector\";\nimport { inspectGraph, type Declaration } from \"effector/inspect\";\n\nfunction createCustomSomething(config) {\n  const $something = createStore(0);\n\n  withRegion(createNode({ meta: { hello: \"world\" } }), () => {\n    // some code\n  });\n\n  return $something;\n}\ninspectGraph({\n  fn: (d) => {\n    if (d.type === \"region\") console.log(d.meta.hello);\n  },\n});\n\nconst $some = createCustomSomething({});\n// logs \"world\"\n```\n\n----------------------------------------\n\nTITLE: allSettled Scope Signature\nDESCRIPTION: Defines the function signature for `allSettled` when used with just a Scope.  It returns a Promise that resolves when all triggered computations within that scope are complete.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/allSettled.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nallSettled<T>(scope): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Updating Message List\nDESCRIPTION: This snippet shows how to update the message list store ($messages) when a new message is successfully sent. It uses the doneData event of the messageSendFx effect to add the new message to the end of the existing message list.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/pages/chat/model.ts\n$messages.on(messageApi.messageSendFx.doneData, (messages, newMessage) => [\n  ...messages,\n  newMessage,\n]);\n```\n\n----------------------------------------\n\nTITLE: Component using useUnit hook\nDESCRIPTION: This example demonstrates how to replace `useStore` and `useEvent` with the unified `useUnit` hook in `effector-react`. It showcases the ability to subscribe to multiple units simultaneously for batched updates.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/migration-guide-v23.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst Component = () => {\n  const foo = useUnit($foo);\n  const bar = useUnit($bar);\n  const onSubmit = useUnit(triggerSubmit);\n};\n```\n\n----------------------------------------\n\nTITLE: Simplifying Updates without createApi - Effector\nDESCRIPTION: Shows the traditional way of updating a store by creating events and subscribing to them. It imports `createStore` and `createEvent` from effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/manage-states.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst $counter = createStore(0);\n\nconst incrementClicked = createEvent();\nconst decrementClicked = createEvent();\nconst resetClicked = createEvent();\n\n$counter\n  .on(incrementClicked, (state) => state + 1)\n  .on(decrementClicked, (state) => state - 1)\n  .reset(resetClicked);\n\n// Использование\nincrement(); // 1\nreset(); // 0\n```\n\n----------------------------------------\n\nTITLE: Store .getState() Example - Javascript\nDESCRIPTION: Shows how to retrieve the current state of a store using the `.getState()` method. This method returns the current value held by the store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, createStore } from \"effector\";\n\nconst add = createEvent();\n\nconst $number = createStore(0).on(add, (state, data) => state + data);\n\nadd(2);\nadd(3);\n\nconsole.log($number.getState());\n```\n\n----------------------------------------\n\nTITLE: Effector Store and Event Watcher (Imperative)\nDESCRIPTION: This JavaScript code snippet demonstrates an imperative approach to watching a store and triggering an event when the store's value changes.  It creates a store named `login`, maps its value to `loginSize`, and then uses `loginSize.watch` to trigger the `submitLoginSize` event whenever `loginSize` changes. Requires effector library.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/glossary.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst login = createStore(\"guest\");\n\nconst loginSize = login.map((login) => login.length);\n\nconst submitLoginSize = createEvent();\n\nloginSize.watch((size) => {\n  submitLoginSize(size);\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_49\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/dskiba>\n        <img src=https://avatars.githubusercontent.com/u/28356785?v=4 width=\"100;\"  alt=Denis Skiba/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Denis Skiba</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Installing effector-solid with npm\nDESCRIPTION: This command installs effector and effector-solid using npm. Effector is a reactive state management library, and effector-solid provides bindings for SolidJS.\nSOURCE: https://github.com/effector/effector/blob/master/packages/effector-solid/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nnpm install --save effector effector-solid\n```\n\n----------------------------------------\n\nTITLE: Inspect Computations with fn\nDESCRIPTION: Demonstrates how to use `inspect` to track computations in Effector.  It logs messages about events, stores, and other triggers using a custom `logInspectMessage` function. The `fn` property configures the inspection of all computations.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/inspect.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inspect, type Message } from \"effector/inspect\";\n\nimport { someEvent } from \"./app-code\";\n\nfunction logInspectMessage(m: Message) {\n  const { name, value, kind } = m;\n\n  return console.log(`[${kind}] ${name} ${value}`);\n}\n\ninspect({\n  fn: (m) => {\n    logInspectMessage(m);\n  },\n});\n\nsomeEvent(42);\n// выведет что-то вроде\n// [event] someEvent 42\n// [on] 42\n// [store] $count 1337\n// ☝️ допустим, что редьюсер добавляет 1295 к предоставленному числу\n//\n// и так далее, любые триггеры\n```\n\n----------------------------------------\n\nTITLE: Timer Implementation Before Scope Binding - Effector\nDESCRIPTION: This code demonstrates the initial implementation of the timer's start effect, which is prone to scope loss because it directly calls the `tick` event within the `setInterval` callback.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst startFx = createEffect(() => {\n  const intervalId = setInterval(() => {\n    tick();\n  }, TIMEOUT);\n\n  return intervalId;\n});\n```\n\n----------------------------------------\n\nTITLE: Extracting Event Payload Type with EventPayload (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the `EventPayload` type utility to extract the payload type from Effector events. It shows how `EventPayload` can be used to define a type that represents the data passed to an event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, EventPayload } from \"effector\";\n\nconst event = createEvent<{ id: string }>();\n\ntype EventPayloadType = EventPayload<typeof event>;\n// {id: string}\n```\n\n----------------------------------------\n\nTITLE: Explicit App Start with Effector Event (TypeScript)\nDESCRIPTION: This example demonstrates the recommended practice of using an explicit event to start the application initialization in Effector. This approach provides better control over the application lifecycle, enables easier testing, and ensures predictable behavior.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appStarted = createEvent();\n```\n\n----------------------------------------\n\nTITLE: Creating Events in Effector\nDESCRIPTION: This snippet demonstrates how to create events in Effector. Events represent facts or occurrences and are the primary means of triggering logic within an Effector application.  They do not contain any logic themselves.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/resources/mindset.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n// Don't think about implementation yet — just declare the fact\nconst searchInputChanged = createEvent();\nconst buttonClicked = createEvent();\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with Yarn\nDESCRIPTION: This command installs the core Effector library using the Yarn package manager. Yarn is an alternative to npm, offering potentially faster and more reliable dependency management.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/installation.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn install effector\n```\n\n----------------------------------------\n\nTITLE: Manual replacement of effector import\nDESCRIPTION: Shows how to manually replace imports from `effector` to `effector/compat` to support older browsers.  This snippet is a diff format, demonstrating the before and after states.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/module/compat.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n- import {createStore} from 'effector'\n+ import {createStore} from 'effector/compat'\n```\n\n----------------------------------------\n\nTITLE: Using useUnit with Events/Effects (with Scope)\nDESCRIPTION: This example demonstrates how to use `useUnit` with events to trigger updates in a scoped environment.  It requires `effector`, `effector-react`, and `react-dom`.  The `useUnit` hook from `effector-react` is used to bind the event to the current scope, allowing the component to interact with the event within the provided scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useUnit.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createEvent, createStore, fork } from \"effector\";\nimport { useUnit, Provider } from \"effector-react\";\n\nconst inc = createEvent();\nconst $count = createStore(0).on(inc, (x) => x + 1);\n\nconst App = () => {\n  const [count, incFn] = useUnit([$count, inc]);\n\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => incFn()}>increment</button>\n    </>\n  );\n};\n\nconst scope = fork();\n\nrender(\n  () => (\n    <Provider value={scope}>\n      <App />\n    </Provider>\n  ),\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Accessing Domain History in Effector\nDESCRIPTION: Demonstrates how to access the history property of a domain to inspect the sets of stores, events, domains, and effects created within that domain. The example creates a domain, an event, and a store, then logs the domain's history to the console.  This allows inspection of the units contained within the domain.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Domain.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { createDomain } from \"effector\";\nconst domain = createDomain();\nconst eventA = domain.event();\nconst $storeB = domain.store(0);\nconsole.log(domain.history);\n// => {stores: Set{storeB}, events: Set{eventA}, domains: Set, effects: Set}\n```\n\n----------------------------------------\n\nTITLE: Handling data with derived events\nDESCRIPTION: This example shows how to create a derived event (array) from an existing event (extractPartOfArray) using the .map() method. The derived event extracts a portion of an array passed to the original event.  The example then demonstrates how to watch the derived event.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createEvent.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst extractPartOfArray = createEvent();\nconst array = extractPartOfArray.map((arr) => arr.slice(2));\n\narray.watch((part) => {\n  console.log(part);\n});\nextractPartOfArray([1, 2, 3, 4, 5, 6]);\n// => [3, 4, 5, 6]\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Events\nDESCRIPTION: This code snippet creates two events, `incremented` and `decremented`, using the `createEvent` function from Effector. These events will be used to trigger state updates in the counter store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst incremented = createEvent();\nconst decremented = createEvent();\n```\n\n----------------------------------------\n\nTITLE: Typing Effect Handler Function Outside Effect in Effector with TypeScript\nDESCRIPTION: Demonstrates how to type an Effector effect when the handler function is defined separately. This requires passing the type of the handler function to `createEffect`.  This is useful for maintaining code clarity and reusability.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst sendMessage = async (params: { text: string }) => {\n  // ...\n  return \"ok\";\n};\n\nconst sendMessageFx = createEffect<typeof sendMessage, AxiosError>(sendMessage);\n// => Effect<{text: string}, string, AxiosError>\n```\n\n----------------------------------------\n\nTITLE: Factories Configuration Example\nDESCRIPTION: Configures the `factories` option of the Effector SWC plugin, specifying a local file to be treated as a custom factory. This ensures unique SIDs across the application, particularly important for SSR.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n// конфигурация\n[\"@effector/swc-plugin\", { \"factories\": [\"./src/factory\"] }]\n```\n\n----------------------------------------\n\nTITLE: Creating a Store in Effector\nDESCRIPTION: This code snippet demonstrates how to create a store in Effector using the `createStore` function. The store `$counter` is initialized with a value of 0 and will hold the application's counter state. It requires the `effector` package.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"effector\";\n\nconst $counter = createStore(0);\n```\n\n----------------------------------------\n\nTITLE: Loading and Saving Messages to Local Storage in TypeScript\nDESCRIPTION: Implements functions to load and save message history from/to local storage.  `loadHistory` retrieves data and parses it, while `saveHistory` stringifies and saves the messages array. Uses the `LocalStorageKey` constant to store the key.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/typescript/usage-with-effector-react.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// File: /src/shared/api/message.ts\nconst LocalStorageKey = \"effector-example-history\";\n\nfunction loadHistory(): Message[] | void {\n  const source = localStorage.getItem(LocalStorageKey);\n  if (source) {\n    return JSON.parse(source);\n  }\n  return undefined;\n}\nfunction saveHistory(messages: Message[]) {\n  localStorage.setItem(LocalStorageKey, JSON.stringify(messages));\n}\n```\n\n----------------------------------------\n\nTITLE: Check if a value is a Unit - Effector\nDESCRIPTION: This JavaScript snippet demonstrates how to use `is.unit` to check if a given value is an Effector unit (Store, Event, Effect, Domain, or Scope). It creates various units and then uses `is.unit` to verify their type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/is.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain, fork } from \"effector\";\n\nconst $store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\nconst scope = fork();\n\nis.unit(scope);\n// => true\n\nis.unit($store);\n// => true\n\nis.unit(event);\n// => true\n\nis.unit(fx);\n// => true\n\nis.unit(createDomain());\n// => true\n\nis.unit(fx.pending);\n// => true\n\nis.unit(fx.done);\n// => true\n\nis.unit($store.updates);\n// => true\n\nis.unit(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: Domain History Type Definition\nDESCRIPTION: Shows the type definition of the domain.history property, which includes sets of stores, events, domains, and effects created inside the domain.  This property is read-only and provides a way to inspect the contained units.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Domain.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nconst { stores, events, domains, effects } = domain.history;\n```\n\n----------------------------------------\n\nTITLE: Custom Factory Example (After Initial Transformation)\nDESCRIPTION: This code shows the custom factory after the first transformation by the Effector plugin. A `sid` has been added to the internal store created by the factory. However, without wrapping the factory itself, multiple instances of the factory would result in the same SID for their internal stores, causing issues.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// src/shared/lib/create-name/index.ts\nexport function createName() {\n  const updateName = createEvent();\n  const $name = createStore(null, { sid: \"ffds2\" });\n\n  $name.on(updateName, (_, nextName) => nextName);\n\n  return { $name };\n}\n\n// src/feature/persons/model.ts\nimport { createName } from \"@/shared/lib/create-name\";\n\nconst personOne = createName();\nconst personTwo = createName();\n```\n\n----------------------------------------\n\nTITLE: useList Short Form Definition\nDESCRIPTION: Defines the type signature for the short form of the useList hook. It accepts a store containing an array and a render function to map each item to a React node.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector-react/useList.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useList(store: Store<T[]>, fn: (item: T, key: number) => React.ReactNode): React.ReactNode;\n```\n\n----------------------------------------\n\nTITLE: Custom Factory Usage\nDESCRIPTION: Demonstrates the usage of the custom factory `createName` to create two instances, `personOne` and `personTwo`. Without proper handling, the internal stores of these instances would have the same SIDs, leading to potential issues.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// src/feature/persons/model.ts\nimport { createName } from \"@/shared/lib/create-name\";\n\nconst personOne = createName();\nconst personTwo = createName();\n```\n\n----------------------------------------\n\nTITLE: Prepend Example with type definition\nDESCRIPTION: Demonstrates using `prepend` to transform data before triggering an event. Also shows, that you must provide argument type for the function.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst original = createEvent<{ input: string }>();\n\nconst prepended = original.prepend((input: string) => ({ input }));\n//                                         ^^^^^^ здесь\n```\n\n----------------------------------------\n\nTITLE: Vite alias configuration\nDESCRIPTION: Configures Vite to automatically replace `effector` with `effector/compat` using the `resolve.alias` option. This simplifies importing and ensures compatibility.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/module/compat.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  resolve: {\n    alias: {\n      effector: \"effector/compat\",\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an inFlight Store manually\nDESCRIPTION: This code demonstrates how to manually create an `inFlight` store using effector's `createStore` and event handlers. This pattern is replaced by using `fx.inFlight`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect, createStore } from \"effector\";\n\nconst requestFx = createEffect();\n\nconst $requestsInFlight = createStore(0)\n  .on(requestFx, (n) => n + 1)\n  .on(requestFx.done, (n) => n - 1)\n  .on(requestFx.fail, (n) => n - 1);\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Effect Creation in Effector Domain\nDESCRIPTION: Illustrates how to subscribe to the creation of new effects within a domain using `onCreateEffect`.  The specified hook function will be executed every time `domain.createEffect()` is called. This is beneficial for implementing logging or adding custom configurations to newly created effects.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Domain.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { createDomain } from \"effector\";\n\nconst domain = createDomain();\n\ndomain.onCreateEffect((effect) => {\n  console.log(\"новый эффект создан\");\n});\n\nconst fooFx = domain.createEffect();\n// => новый эффект создан\n\nconst barFx = domain.createEffect();\n// => новый эффект создан\n```\n\n----------------------------------------\n\nTITLE: Configuring forceScope Option\nDESCRIPTION: Configures the `forceScope` option of the Effector SWC plugin, which enforces the use of `Scope` during rendering in `@effector/reflect` and `effector-react` components, preventing the need for direct `/scope` imports.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"forceScope\": false }]\n```\n\n----------------------------------------\n\nTITLE: Correct Effector Component Usage with useUnit (TSX)\nDESCRIPTION: This snippet demonstrates the correct way to use an Effector event in a React component using the `useUnit` hook from `effector-react`. `useUnit` ensures that the event is properly bound to the current scope, preventing scope-related errors and ensuring consistent behavior. The returned value from `useUnit` should be used within the component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/troubleshooting.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { event } from \"./model.js\";\nimport { useUnit } from \"effector-react\";\n\nconst Component = () => {\n  const onEvent = useUnit(event);\n\n  return <button onClick={() => onEvent()}></button>;\n};\n```\n\n----------------------------------------\n\nTITLE: Webpack Alias Configuration for effector-react\nDESCRIPTION: Configures Webpack to automatically replace `effector` and `effector-react` with their respective `/compat` versions. This simplifies the process of supporting older browsers by ensuring that the compatibility versions are used throughout the project.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/module/сompat.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  resolve: {\n    alias: {\n      effector: \"effector/compat\",\n      \"effector-react\": \"effector-react/compat\",\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Effector debugSids Configuration (JSON)\nDESCRIPTION: Enables the `debugSids` option of effector/babel-plugin, adding the file path and variable name to the SID, which aids debugging SSR applications. Requires a Babel environment and effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"debugSids\": false\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Import clearNode from effector\nDESCRIPTION: This code snippet demonstrates how to import the `clearNode` function from the `effector` library. This function is used to destroy stores, events, effects, subscriptions, and domains within the Effector framework.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/clearNode.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { clearNode } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Basic Prepend example\nDESCRIPTION: Illustrates a basic usage of `prepend` in Effector.  Shows how to transform the input data before the original event is triggered.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst userPropertyChanged = createEvent();\n\nuserPropertyChanged.watch(({ field, value }) => {\n  console.log(`Свойство пользователя \"${field}\" изменилось на ${value}`);\n});\n\nconst changeName = userPropertyChanged.prepend((name) => ({\n  field: \"name\",\n  value: name,\n}));\nconst changeRole = userPropertyChanged.prepend((role) => ({\n  field: \"role\",\n  value: role.toUpperCase(),\n}));\n\nchangeName(\"john\");\n// => Свойство пользователя \"name\" изменилось на john\n\nchangeRole(\"admin\");\n// => Свойство пользователя \"role\" изменилось на ADMIN\n\nchangeName(\"alice\");\n// => Свойство пользователя \"name\" изменилось на alice\n```\n\n----------------------------------------\n\nTITLE: Using VueEffector plugin with Vue\nDESCRIPTION: Demonstrates how to register the `VueEffector` plugin with a Vue instance.  `Vue.use(VueEffector)` registers the plugin, enabling Effector integration within Vue components. Requires Vue and VueEffector to be imported first.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/VueEffectorVue2.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport Vue from \"vue\";\nimport { VueEffector } from \"effector-vue\";\n\nVue.use(VueEffector);\n```\n\n----------------------------------------\n\nTITLE: Creating a pending Store manually\nDESCRIPTION: This code demonstrates how to manually create a `pending` store using effector's `createStore` and event handlers. This pattern is replaced by using `fx.pending`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEffect, createStore } from \"effector\";\n\nconst requestFx = createEffect();\n\nconst $isRequestPending = createStore(false)\n  .on(requestFx, () => true)\n  .on(requestFx.done, () => false)\n  .on(requestFx.fail, () => false);\n```\n\n----------------------------------------\n\nTITLE: Using useGate with Gate and Props (TypeScript)\nDESCRIPTION: Describes the formula for using the `useGate` function, which takes a `Gate` and `props` as arguments. It returns void, and is used to bind props to a gate instance.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-solid/useGate.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nuseGate(Gate: Gate<Props>, props: Props): void;\n```\n\n----------------------------------------\n\nTITLE: Installing effector-react with npm\nDESCRIPTION: This command installs the `effector` and `effector-react` packages using npm.  These packages are required for using effector with React components. This snippet should be run in the project directory.\nSOURCE: https://github.com/effector/effector/blob/master/packages/effector-react/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save effector effector-react\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_14\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/VictorKolb>\n            <img src=https://avatars.githubusercontent.com/u/14196649?v=4 width=\"100;\"  alt=Victor Kolb/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Victor Kolb</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Installing Effector Vue Integration\nDESCRIPTION: This command installs the Effector Vue integration library along with the core Effector library. This is necessary for using Effector in a Vue application. Requires npm.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-vue\n```\n\n----------------------------------------\n\nTITLE: Extracting Event Type with `UnitValue` in Effector\nDESCRIPTION: Demonstrates how to use the `UnitValue` type utility to extract the data type from an Effector event. This is helpful for accessing the event's payload type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/typescript.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { UnitValue, createEffect, createStore, createEvent } from \"effector\";\n\nconst event = createEvent<{ id: string; name?: string } | { id: string }>();\ntype UnitEventType = UnitValue<typeof event>;\n// {id: string; name?: string | undefined} | {id: string}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Watch Usage in Effector (TypeScript)\nDESCRIPTION: This snippet demonstrates the incorrect use of `watch` for implementing business logic instead of debugging. It directly sets local storage, tracks user updates, and triggers events within the `watch` callback, which is discouraged in Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n$user.watch((user) => {\n  localStorage.setItem(\"user\", JSON.stringify(user));\n  api.trackUserUpdate(user);\n  someEvent(user.id);\n});\n```\n\n----------------------------------------\n\nTITLE: TypeScript Store Reducer Type Definition\nDESCRIPTION: This TypeScript code defines the type signature for a `StoreReducer` function. It takes the current state and a payload as input and returns the new state or void if no update is needed. The type `State` represents the state type, and `E` represents the payload type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/glossary.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype StoreReducer<State, E> = (state: State, payload: E) => State | void;\ntype EventOrEffectReducer<T, E> = (state: T, payload: E) => T;\n```\n\n----------------------------------------\n\nTITLE: Accessing Effect Fail Event - Typescript\nDESCRIPTION: Describes the `fail` event, which triggers with the error that occurred during effect execution and the argument passed during the call.  Manually calling the fail event is prohibited.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fx: Effect<P, any, E>\n\nfx.fail\n-> Event<{params: P; error: E}>\n```\n\n----------------------------------------\n\nTITLE: Using Effector with Vue\nDESCRIPTION: This Vue component demonstrates how to use Effector with Vue using the `useUnit` hook from `@effector-vue/composition`. It imports a store `$counter` and events `incremented` and `decremented` from `./counter.js` and connects them to the component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_10\n\nLANGUAGE: html\nCODE:\n```\n<script setup>\n  import { useUnit } from \"@effector-vue/composition\";\n  import { $counter, incremented, decremented } from \"./counter.js\";\n  const [counter, onIncremented, onDecremented] = useUnit([$counter, incremented, decremented]);\n  // or\n  const { counter, onIncremented, onDecremented } = useUnit({ $counter, incremented, decremented });\n  // or\n  const counter = useUnit($counter);\n  const onIncremented = useUnit(incremented);\n  const onDecremented = useUnit(decremented);\n</script>\n\n<template>\n  <div>\n    <h1>Count: {{ counter }}</h1>\n    <button @click=\"onIncremented\">Increment</button>\n    <button @click=\"onDecremented\">Decrement</button>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Getting Current Effect Handler with use.getCurrent() - Typescript\nDESCRIPTION: Retrieves the current implementation of an effect, typically for testing purposes. If no implementation has been set, it returns a default function that throws an error.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fx: Effect<P, D>\n\nfx.use.getCurrent()\n-> (params: P) => D\n```\n\n----------------------------------------\n\nTITLE: Debugging Effector Events with Patronum\nDESCRIPTION: This example demonstrates how to debug Effector events using the `patronum/debug` utility. It creates two events, `firstTriggered` and `secondTriggered`, connects them with `sample`, and then uses `debug` to log when each event is triggered.  The `debug` function provides insights into event executions and their payloads.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, sample } from \"effector\";\nimport { debug } from \"patronum\";\n\nconst firstTriggered = createEvent<void>();\nconst secondTriggered = createEvent<void>();\n\nsample({\n  clock: firstTriggered,\n  target: secondTriggered,\n});\n\ndebug(firstTriggered, secondTriggered);\n\nfirstTriggered();\n// => [event] firstTriggered undefined\n// => [event] secondTriggered undefined\n```\n\n----------------------------------------\n\nTITLE: Validating Effector Unit with `is.unit` in JavaScript\nDESCRIPTION: This snippet demonstrates how to use `is.unit` to check if a given value is an Effector unit (store, event, effect, domain, or scope). It imports necessary modules from Effector and creates a store, event, effect, and scope for testing purposes. The snippet then calls `is.unit` with different values and logs the results to the console, showing examples of when it returns true or false.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/is.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain, fork } from \"effector\";\n\nconst store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\nconst scope = fork();\n\nis.unit(scope);\n// => true\n\nis.unit(store);\n// => true\n\nis.unit(event);\n// => true\n\nis.unit(fx);\n// => true\n\nis.unit(createDomain());\n// => true\n\nis.unit(fx.pending);\n// => true\n\nis.unit(fx.done);\n// => true\n\nis.unit(store.updates);\n// => true\n\nis.unit(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: connect($store)(Component) signature\nDESCRIPTION: This signature of the connect function accepts an effector store as its first argument, and returns a function that takes a React component. It merges the store's value into the component's props. It is deprecated in favor of hooks API.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/connect.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconnect($store: Store<T>)(Component): Component\n```\n\n----------------------------------------\n\nTITLE: Configuring debugSids Option\nDESCRIPTION: Configures the `debugSids` option of the Effector SWC plugin, enabling the inclusion of file paths and Unit names in generated SIDs for debugging SSR issues.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"debugSids\": false }]\n```\n\n----------------------------------------\n\nTITLE: Import Effector and createEffect\nDESCRIPTION: Example demonstrating how to import `createEffect` from the `effector` library to create an effect.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { createEffect } from \"effector\";\n\nconst fetchFx = createEffect();\n\nfetchFx();\n\n// => no handler used in fetchFx\n```\n\n----------------------------------------\n\nTITLE: Validating Attached Effect with `is.attached` in JavaScript\nDESCRIPTION: This snippet demonstrates how to use `is.attached` to check if an Effector effect was created using the `attach` method. It imports necessary modules from Effector and creates a store, event, and effect for testing purposes.  It then creates an attached effect using `attach`. The snippet then calls `is.attached` with different values and logs the results to the console, showing examples of when it returns true or false.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/is.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { is, createStore, createEvent, createEffect, createDomain, attach } from \"effector\";\n\nconst $store = createStore(null);\nconst event = createEvent();\nconst fx = createEffect();\n\nconst childFx = attach({\n  effect: fx,\n});\n\nis.attached(childFx);\n// => true\n\nis.attached(fx);\n// => false\n\nis.attached($store);\n// => false\n\nis.attached(event);\n// => false\n\nis.attached(createDomain());\n// => false\n\nis.attached(null);\n// => false\n```\n\n----------------------------------------\n\nTITLE: Effector Domain Creation Signature\nDESCRIPTION: This snippet shows the signature of the `createDomain` function in Effector. It accepts an optional name as a string.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createDomain.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreateDomain(name?)\n```\n\n----------------------------------------\n\nTITLE: Effector Factories Usage Example (JS)\nDESCRIPTION: Illustrates how to use a factory function (defined elsewhere) to create multiple Effector stores. When the `factories` option is correctly configured, each store will have its own unique SID. Requires effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_10\n\nLANGUAGE: js\nCODE:\n```\n// ./src/statuses.js\nimport { createEffectStatus } from \"./createEffectStatus\";\nimport { fetchUserFx, fetchFriendsFx } from \"./api\";\n\nexport const $fetchUserStatus = createEffectStatus(fetchUserFx);\nexport const $fetchFriendsStatus = createEffectStatus(fetchFriendsFx);\n```\n\n----------------------------------------\n\nTITLE: Store .defaultState Example - Typescript\nDESCRIPTION: Demonstrates how to access the `defaultState` property of a store, which holds the initial value of the store. This allows you to inspect the initial state programmatically.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = createStore(\"DEFAULT\");\nconsole.log($store.defaultState === \"DEFAULT\");\n```\n\n----------------------------------------\n\nTITLE: Using createApi to Manage Player Position in JavaScript\nDESCRIPTION: This JavaScript example demonstrates how to use `createApi` to manage the position of a player using Effector.  It defines a store for the player's position and creates events to move the player left and right. Each handler updates the store based on input parameters. The `watch` method is used to log the player's position after each move.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createApi.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createApi } from \"effector\";\n\nconst playerPosition = createStore(0);\n\nconst api = createApi(playerPosition, {\n  moveLeft: (pos, n) => pos - n,\n  moveRight: (pos, n) => pos + n,\n});\n\nplayerPosition.watch((pos) => {\n  console.log(\"position\", pos);\n});\n// => position 0\n\napi.moveRight(10);\n// => position 10\n\napi.moveLeft(5);\n// => position 5\n```\n\n----------------------------------------\n\nTITLE: Configuring addNames Option\nDESCRIPTION: Configures the `addNames` option of the Effector SWC plugin, which adds names to Effector Units created by factories, aiding in debugging during development and testing.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"addNames\": true }]\n```\n\n----------------------------------------\n\nTITLE: createEvent usage\nDESCRIPTION: Demonstrates different ways to use createEvent:\n1.  Creating an event with no payload (Event<void>).\n2.  Creating an event with a generic type (Event<T>).\n3.  Creating an event with an optional name.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/createEvent.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nevent = createEvent() > Event<void>;\n\nevent = createEvent<T>() > Event<T>;\n\nevent = createEvent(/*name*/ \"eventName\") > Event<void>;\n```\n\n----------------------------------------\n\nTITLE: Chat Page View Layer (Initial)\nDESCRIPTION: This snippet defines the initial structure of the chat page using React and TypeScript. It includes placeholder components for chat history and message form. It serves as the basic layout for the chat application.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n// Файл: /src/pages/chat/page.tsx\nexport function ChatPage() {\n  return (\n    <div className=\"parent\">\n      <ChatHistory />\n      <MessageForm />\n    </div>\n  );\n}\n\nfunction ChatHistory() {\n  return (\n    <div className=\"chat-history\">\n      <div>Тут будет список сообщений</div>\n    </div>\n  );\n}\n\nfunction MessageForm() {\n  return (\n    <div className=\"message-form\">\n      <div>Тут будет форма сообщения</div>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing effector package\nDESCRIPTION: This command installs the core effector package using npm. It allows you to use effector for state management in your JavaScript applications. This is a foundational step for using effector in any project.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm add effector\n```\n\n----------------------------------------\n\nTITLE: Installing Effector SWC Plugin\nDESCRIPTION: Installs the @effector/swc-plugin using npm. The -ED flag installs it as a development dependency. Using the correct version is critical for compatibility with SWC and Next.js.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -ED @effector/swc-plugin\n```\n\n----------------------------------------\n\nTITLE: Access Store Updates Event with `.updates` (JavaScript)\nDESCRIPTION: Demonstrates accessing the `updates` event of a store, which represents updates to the store's state. The example verifies that `.updates` is an event and then attaches a watcher to log the updated amount.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, is } from \"effector\";\n\nconst $clicksAmount = createStore(0);\nis.event($clicksAmount.updates); // true\n\n$clicksAmount.updates.watch((amount) => {\n  console.log(amount);\n});\n```\n\n----------------------------------------\n\nTITLE: Installing VueEffector Plugin (Vue 3)\nDESCRIPTION: Installs the VueEffector plugin into a Vue 3 application using `app.use(VueEffector)`. This makes the effector option available in Vue components for binding effector stores and effects.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/VueEffector.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createApp } from \"vue\";\nimport { VueEffector } from \"effector-vue/options-vue3\";\n\nimport App from \"./App.vue\";\n\nconst app = createApp(App);\n\napp.use(VueEffector);\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with Solid bindings\nDESCRIPTION: This command installs both Effector and its Solid bindings using npm. The effector-solid package provides integration tools for using Effector with Solid.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/installation.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-solid\n```\n\n----------------------------------------\n\nTITLE: Installing Effector React Integration\nDESCRIPTION: This command installs the Effector React integration library along with the core Effector library. This is necessary for using Effector in a React application. Requires npm.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-react\n```\n\n----------------------------------------\n\nTITLE: Import withRegion from Effector\nDESCRIPTION: Imports the `withRegion` function from the Effector library. This function is used to define a region where units are owned by a specific unit or node.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/withRegion.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { withRegion } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Effector Custom Store Creator Example (JS)\nDESCRIPTION: Shows a custom store creator function, designed to be used with the `noDefaults` option of the effector/babel-plugin.  It creates a store with a specified default state and SID. Requires effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_17\n\nLANGUAGE: js\nCODE:\n```\n// @lib/createInputField.js\nimport { createStore } from \"effector\";\nimport { resetForm } from \"./form\";\n\nexport function createInputField(defaultState, { sid, name }) {\n  return createStore(defaultState, { sid, name }).reset(resetForm);\n}\n```\n\n----------------------------------------\n\nTITLE: Import Store Types in Effector (TypeScript)\nDESCRIPTION: Imports the `Store` and `StoreWritable` types from the `effector` library. This allows for type-safe usage of stores in TypeScript.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Store.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type Store, type StoreWritable } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Typing Events in Effector with TypeScript\nDESCRIPTION: Demonstrates how to type Effector events using generics.  Events can be typed with specific parameters, or default to `EventCallable<void>` if no type is provided.  Different event types such as `EventCallable<T>` and `Event<T>` are discussed.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/typescript.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\n// Событие без параметров\nconst clicked = createEvent();\n// EventCallable<void>\n\n// Событие с параметром\nconst userNameChanged = createEvent<string>();\n// EventCallable<string>\n\n// Событие со сложным параметром\nconst formSubmitted = createEvent<{  username: string;  password: string;}>();\n// EventCallable<{ username: string;password: string; }>\n```\n\n----------------------------------------\n\nTITLE: Effector Store Creation with SIDs\nDESCRIPTION: Illustrates how to create Effector stores and assign them unique SIDs (Stable Identifiers). These SIDs are used to distinguish between stores in different environments, enabling serialization and deserialization of store states. The example creates two stores, `$name` and `$age`, each with a distinct SID.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst $name = createStore(null, { sid: \"name\" });\nconst $age = createStore(null, { sid: \"age\" });\n```\n\n----------------------------------------\n\nTITLE: Inspect Graph with Region Metadata\nDESCRIPTION: Illustrates how to access metadata provided through the root node of a region using `inspectGraph`. It creates a custom function that utilizes `withRegion` to associate metadata with a region, then extracts and logs this metadata when a region declaration is inspected.  It uses `createNode` and `withRegion` to set the metadata.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/inspect.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createNode, withRegion, createStore } from \"effector\";\nimport { inspectGraph, type Declaration } from \"effector/inspect\";\n\nfunction createCustomSomething(config) {\n  const $something = createStore(0);\n\n  withRegion(createNode({ meta: { hello: \"world\" } }), () => {\n    // какой-то код\n  });\n\n  return $something;\n}\ninspectGraph({\n  fn: (d) => {\n    if (d.type === \"region\") console.log(d.meta.hello);\n  },\n});\n\nconst $some = createCustomSomething({});\n// выведет \"world\"\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with React bindings\nDESCRIPTION: This command installs Effector along with the effector-react bindings using npm. These bindings are necessary for seamless integration with React applications.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/installation.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-react\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with Solid\nDESCRIPTION: This command installs the `effector` and `effector-solid` packages using npm. `effector-solid` provides utilities for integrating Effector with Solid components.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-solid\n```\n\n----------------------------------------\n\nTITLE: Migration: Removing reactSsr from Babel plugin\nDESCRIPTION: Illustrates how to remove the reactSsr parameter from the effector/babel-plugin configuration during migration from effector-react/scope.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/module/scope.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n{\n  \"plugins\": [\n    [\n      \"effector/babel-plugin\",\n      {\n-        \"reactSsr\": true\n      }\n    ]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Effector Sample with Name\nDESCRIPTION: Demonstrates how to assign a name to the target unit created by `sample` using the `name` option.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/sample.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, sample } from \"effector\";\n\nconst foo = createStore(null);\n\nconst sampled = sample({\n  source: foo,\n  name: \"sampled foo\",\n});\n\nconsole.log(sampled.shortName); // 'sampled foo'\n```\n\n----------------------------------------\n\nTITLE: Configuring HMR Option\nDESCRIPTION: Configures the `hmr` option of the Effector SWC plugin to enable Hot Module Replacement, allowing Effector's bindings and side effects to be properly managed during development.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"hmr\": \"es\" }]\n```\n\n----------------------------------------\n\nTITLE: Starting Initialization with Scopes (TypeScript)\nDESCRIPTION: This snippet shows how to start the application's initialization using `appStarted` event within a specified scope using `allSettled`. This approach is beneficial for SSR.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample, allSettled } from \"effector\";\nimport { scope } from \"./app.js\";\n\nsample({\n  clock: appStarted,\n  target: initFx,\n});\n\nallSettled(appStarted, { scope });\n```\n\n----------------------------------------\n\nTITLE: Import from effector-react/compat in TypeScript\nDESCRIPTION: Imports symbols from the `effector-react/compat` module. This module provides compatibility for older browsers. It is intended to be used as a direct replacement for `effector-react` when legacy browser support is required.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/module/сompat.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {} from \"effector-react/compat\";\n```\n\n----------------------------------------\n\nTITLE: Creating a Pre-processor for Events with event.prepend\nDESCRIPTION: This example shows how to create a pre-processor for Effector events using `event.prepend`.  It demonstrates creating a central `showError` event and then creating specialized events like `showNetworkError` and `showValidationError` that transform their input into a string before triggering `showError`. This allows for centralized error handling with specific error types.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\n// Основное событие обработки ошибок\nconst showError = createEvent<string>();\n\n// Подписываемся на показ ошибок\nsample({\n  clock: showError,\n  target: processErrorFx, // упустим реализацию эффекта\n});\n\n// Создаем специальные события для разных типов ошибок\nconst showNetworkError = showError.prepend((code: number) => `Ошибка сети: ${code}`);\n\nconst showValidationError = showError.prepend((field: string) => `Поле ${field} заполнено неверно`);\n\n// Использование\nshowNetworkError(404); // 🔴 Ошибка: Ошибка сети: 404\nshowValidationError(\"email\"); // 🔴 Ошибка: Поле email заполнено неверно\n```\n\n----------------------------------------\n\nTITLE: Event shortName Example\nDESCRIPTION: Illustrates how the `shortName` property reflects the name of the variable to which the event is initially assigned. Shows that re-assigning the event to a different variable does not change the `shortName`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst demo = createEvent();\n// demo.shortName === 'demo'\n\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst another = demo;\n// another.shortName === 'demo'\n```\n\n----------------------------------------\n\nTITLE: Accessing Effect doneData Event - Typescript\nDESCRIPTION: Describes the `doneData` event, which triggers with the result of the effect execution.  Manually calling the doneData event is prohibited.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fx: Effect<any, D>\n\nfx.doneData\n-> Event<D>\n```\n\n----------------------------------------\n\nTITLE: Import hydrate from effector (TypeScript)\nDESCRIPTION: Imports the `hydrate` function from the effector library.  This import is necessary to use the function for rehydrating effector stores.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/hydrate.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { hydrate } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Using the Slot Factory\nDESCRIPTION: This snippet demonstrates how to use the `createSlotFactory` to create a specific slot instance. It defines a slot ID and creates a `FooSlot` component using the factory. This component is then used within another component.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/recipes/react/slots.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst SLOTS = { FOO: \"foo\" } as const;\n\nconst { api, createSlot } = createSlotFactory({ slots: SLOTS });\n\nconst { Slot: FooSlot } = createSlot({ id: SLOTS.FOO });\n\nconst ComponentWithSlot = () => (\n  <>\n    <h1>Hello, Slots!</h1>\n    <FooSlot />\n  </>\n);\n```\n\n----------------------------------------\n\nTITLE: Incorrect Event Call from Pure Function\nDESCRIPTION: Illustrates an incorrect usage: calling event from a pure function. Calling an event within a pure function like `map` is restricted in Effector. It will cause an error.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst someHappened = createEvent<number>();\nconst another = createEvent();\n\nconst derived = someHappened.map((number) => {\n  another(); // ВЫЗЫВАЕТ ОШИБКУ!\n  return String(number);\n});\n```\n\n----------------------------------------\n\nTITLE: Import inspect from effector\nDESCRIPTION: Imports the `inspect` function from the `effector/inspect` module. This is the basic import required to use the inspection features.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/inspect.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inspect } from \"effector/inspect\";\n```\n\n----------------------------------------\n\nTITLE: Import Forward from Effector\nDESCRIPTION: Imports the `forward` function and `Subscription` type from the effector library. This is necessary to use the `forward` function to connect effector units.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/forward.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { forward, type Subscription } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Importing Effector Compat Module\nDESCRIPTION: This code snippet shows how to import the compatibility module of Effector to support older browsers. It replaces the standard import with the `effector/compat` module.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/installation.mdx#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\n- import {createStore} from 'effector'\n+ import {createStore} from 'effector/compat'\n```\n\n----------------------------------------\n\nTITLE: Client-Side Effector State Hydration\nDESCRIPTION: Illustrates how to hydrate the Effector state on the client-side. It retrieves the server-side state from the `window` object, creates a new scope with the server-side values using `fork`, and then passes the scope to the `Provider` component.  The `getState` method is called to verify correct hydration.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/sids.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// src/client/index.ts\nimport { Provider } from \"effector-react\";\n\nconst serverState = window._SERVER_STATE_;\n\nconst clientScope = fork({\n  values: serverState, // simply assign server state to scope\n});\n\nclientScope.getState($lastName); // \"Doe\"\n\nhydrateApp(\n  <Provider value={clientScope}>\n    <App />\n  </Provider>,\n);\n```\n\n----------------------------------------\n\nTITLE: Imperative Event Triggering with Effector\nDESCRIPTION: This code demonstrates an imperative approach to triggering an event when a store value changes.  It creates a store `$login`, derives a `$loginSize` store from it, and then uses `watch` to trigger the `submitLoginSize` event whenever `$loginSize` changes. Dependencies: effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/explanation/glossary.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent } from \"effector\";\n\nconst submitLoginSize = createEvent();\n\nconst $login = createStore(\"guest\");\nconst $loginSize = $login.map((login) => login.length);\n\n$loginSize.watch((size) => {\n  submitLoginSize(size);\n});\n```\n\n----------------------------------------\n\nTITLE: Combine with array\nDESCRIPTION: Combines multiple stores into an array. Dependencies: `Store`, `StoreWritable`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/combine.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst $a: Store<A>;\nconst $b: StoreWritable<B>;\nconst $c: Store<C> | StoreWritable<C>;\n\n$result: Store<[A, B, C]> = combine([$a, $b, $c]);\n```\n\n----------------------------------------\n\nTITLE: Custom Factory Definition\nDESCRIPTION: Defines a custom factory function, `createBooleanStore`, that creates an Effector store. This factory is used as an example for the `factories` configuration option in the SWC plugin.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// файл: /src/factory.ts\nimport { createStore } from \"effector\";\n\n/* createBooleanStore — это фабрика */\nexport const createBooleanStore = () => createStore(true);\n```\n\n----------------------------------------\n\nTITLE: Effector SWC Plugin debugSids Configuration\nDESCRIPTION: This JSON snippet shows an example configuration for the `debugSids` option of the Effector SWC plugin. It enables appending the full file path and Unit name to generated SIDs for easier debugging of SSR issues.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"debugSids\": false }]\n```\n\n----------------------------------------\n\nTITLE: Effector Client SID Usage (JS)\nDESCRIPTION: Shows how to use the Stable ID (SID) in the client-side code, communicating with a web worker.  It requires effector and assumes the `getUsers` effect from `common.js`.  It sets up message passing with the worker based on the SID.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\n// client.js\nimport { createEvent } from \"effector\";\nimport { getUsers } from \"./common.js\";\n\nconst onMessage = createEvent();\n\nconst worker = new Worker(\"worker.js\");\nworker.onmessage = onMessage;\n\ngetUsers.use(\n  (userID) =>\n    new Promise((rs) => {\n      worker.postMessage({ sid: getUsers.sid, userID });\n      const unwatch = onMessage.watch(({ data }) => {\n        if (data.sid !== getUsers.sid) return;\n        unwatch();\n        rs(data.result);\n      });\n    }),\n);\n```\n\n----------------------------------------\n\nTITLE: Using combine function with Effector and Vue\nDESCRIPTION: This code snippet demonstrates how to use the `combine` function from Effector to combine a Vue component's data with an Effector store. It creates a derived store that concatenates the `foo` property from the component's data and the `counter` store's value. This is done within the `effector` option which automatically updates the template.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/ComponentOptions.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport Vue from \"vue\";\nimport { createStore, combine } from \"effector\";\n\nconst counter = createStore(0);\n\nnew Vue({\n  data() {\n    return {\n      foo: \"bar\",\n    };\n  },\n  effector() {\n    // would create `state` in template\n    return combine(\n      this.$store(() => this.foo),\n      counter,\n      (foo, counter) => `${foo} + ${counter}`,\n    );\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using VueSSRPlugin with Effector and Vue for SSR\nDESCRIPTION: This code demonstrates how to use the VueSSRPlugin with Effector and Vue to enable Server-Side Rendering (SSR). It imports necessary modules, creates a Vue app and an Effector scope, and then registers the plugin with the app, providing the scope and an optional scope name. Note: VueSSRPlugin is deprecated and EffectorScopePlugin is the recommended replacement.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/VueSSRPlugin.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { createSSRApp } from \"vue\";\nimport { VueSSRPlugin } from \"effector-vue/ssr\";\nimport { fork } from \"effector\";\n\nconst app = createSSRApp(AppComponent);\nconst scope = fork();\n\napp.use(\n  VueSSRPlugin({\n    scope,\n    scopeName: \"app-scope-name\",\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: App.vue: Template iterating over IDs\nDESCRIPTION: This is the template for the App.vue component. It iterates over the `ids` array obtained from the `useStore` hook and renders a `User` component for each ID, passing the ID as a prop.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useStoreMap.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<div>\n  <User v-for=\"id in ids\" :key=\"id\" :id=\"id\" />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Updating Array in effector Store (Incorrect)\nDESCRIPTION: Shows the incorrect way to update an array in an effector store, which involves directly mutating the array. This is discouraged due to effector's immutability principles and can lead to unpredictable behavior.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// update array\n$users.on(userAdded, (users, newUser) => {\n  users.push(newUser); // mutation!\n  return users;\n});\n```\n\n----------------------------------------\n\nTITLE: Vue Template\nDESCRIPTION: Basic Vue template displaying a counter value from the Effector store. It shows how to bind the store value to the template.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/createComponent.md#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<template> {{ $counter }} </template>\n```\n\n----------------------------------------\n\nTITLE: Import Store Types - Typescript\nDESCRIPTION: Imports the Store and StoreWritable types from the effector library. These types are used to define the type of a store and a writable store, respectively.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type Store, type StoreWritable } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Guard with Predicate Filter Alternative Syntax\nDESCRIPTION: Demonstrates the alternative syntax of `guard` with a predicate function as a filter. The `target` event is triggered only when the `source` event receives a value greater than 0. Requires effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/guard.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent, guard } from \"effector\";\n\nconst source = createEvent();\nconst target = guard(source, {\n  filter: (x) => x > 0,\n});\n\ntarget.watch(() => {\n  console.log(\"target вызван\");\n});\n\nsource(0);\n// ничего не произошло\nsource(1);\n// target вызван\n```\n\n----------------------------------------\n\nTITLE: HTML template for Single Effector Store\nDESCRIPTION: HTML template corresponding to the Javascript snippet demonstrating the `useVModel` hook. It shows binding inputs to the state using the `v-model` directive in Vue.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useVModel.md#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<div id=\"app\">\n  <input type=\"text\" v-model=\"user.name\" />\n  <input type=\"text\" v-model=\"user.surname\" />\n\n  <div>\n    <input type=\"checkbox\" v-model=\"user.skills\" value=\"HTML\" />\n    <input type=\"checkbox\" v-model=\"user.skills\" value=\"CSS\" />\n    <input type=\"checkbox\" v-model=\"user.skills\" value=\"JS\" />\n  </div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Using Effector Compat Import\nDESCRIPTION: This code shows how to change the import statement to use the `compat` version of Effector. This is necessary for compatibility with older browsers like IE11 and Chrome 47.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/installation.md#_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\n- import {createStore} from 'effector'\n+ import {createStore} from 'effector/compat'\n```\n\n----------------------------------------\n\nTITLE: Creating and Calling an Effector Event (Imperative)\nDESCRIPTION: This snippet demonstrates the creation of an Effector event using `createEvent` and its imperative invocation. The event `callHappened` is created and then called like a function. This is a simple example illustrating the basic event creation and calling pattern in Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/events.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst callHappened = createEvent<void>();\n\ncallHappened(); // событие вызвано\n```\n\n----------------------------------------\n\nTITLE: createGate Formula - TypeScript\nDESCRIPTION: Shows the function signature of `createGate` when used with just a name.  It highlights that the function accepts an optional name (string) and returns a `Gate<T>` instance. This gate can then be used to manage component state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/createGate.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncreateGate(name?: string): Gate<T>\n```\n\n----------------------------------------\n\nTITLE: Effector reactSsr Configuration (JSON)\nDESCRIPTION: Configures the `reactSsr` option of effector/babel-plugin, which was used to replace imports from `effector-react` with `effector-react/scope`.  This option is now deprecated. Requires a Babel environment and effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"reactSsr\": false\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Creating a store that accepts undefined values in Effector (TS)\nDESCRIPTION: This code snippet demonstrates how to create an Effector store that explicitly allows `undefined` as a value. By providing the `skipVoid: false` option in the second argument of `createStore`, the store will accept and store `undefined` values without triggering an error.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/troubleshooting.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = createStore(0, {\n  skipVoid: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Effect calls with async functions (Incorrect)\nDESCRIPTION: Illustrates an incorrect pattern where mixing effect calls with regular async functions like `setTimeout` can lead to scope loss in Effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/advanced/work-with-scope.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst authFx = createEffect(async () => {\n  await loginFx();\n\n  // Scope loss! Can't mix with regular promises\n  await new Promise((resolve) => setTimeout(resolve, 100));\n\n  // This call will be in the global scope\n  await loadProfileFx();\n});\n```\n\n----------------------------------------\n\nTITLE: Deploying with Serverless Framework\nDESCRIPTION: This command builds the client application and the lambda functions, then deploys everything to AWS Lambda using the Serverless framework. It assumes that `yarn` is installed and configured. It requires the project to be properly configured with domain name and certificate ARN.\nSOURCE: https://github.com/effector/effector/blob/master/examples/serverless-ssr/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn && yarn deploy\n```\n\n----------------------------------------\n\nTITLE: React Component Migration from useStore/useEvent to useUnit - TypeScript\nDESCRIPTION: Demonstrates how to migrate from using `useStore` and `useEvent` hooks to the unified `useUnit` hook in `effector-react`. This change allows batching of store updates, improving performance. The snippet illustrates how to replace individual hook calls with `useUnit` and how to handle multiple units at once.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/migration-guide-v23.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Component = () => {\n  const foo = useStore($foo);\n  const bar = useStore($bar);\n  const onSubmit = useEvent(triggerSubmit);\n};\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst Component = () => {\n  const foo = useUnit($foo);\n  const bar = useUnit($bar);\n  const onSubmit = useUnit(triggerSubmit);\n};\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst Component = () => {\n  const [foo, bar, onSubmit] = useUnit([$foo, $bar, triggerSubmit]);\n};\n```\n\n----------------------------------------\n\nTITLE: Reactive Form Example using Forest\nDESCRIPTION: This JavaScript code demonstrates a reactive form implementation using the Forest UI engine. It includes form model definition, event handling, and rendering using Forest's `using`, `h`, and `spec` functions. The example utilizes Effector for state management with `createStore`, `createEvent`, and `sample`.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createStore, createEvent, sample} from 'effector'\nimport {using, spec, h} from 'forest'\n\nusing(document.body, () => {\n  const {change, submit, $fields} = formModel()\n\n  h('section', () => {\n    spec({style: {width: '15em'}})\n\n    h('form', () => {\n      spec({\n        handler: {\n          config: {prevent: true},\n          on: {submit},\n        },\n        style: {\n          display: 'flex',\n          flexDirection: 'column',\n        },\n      })\n\n      h('input', {\n        attr: {placeholder: 'Username'},\n        handler: {input: change('username')},\n      })\n\n      h('input', {\n        attr: {type: 'password', placeholder: 'Password'},\n        classList: ['w-full', 'py-2', 'px-4'],\n        handler: {input: change('password')},\n      })\n\n      h('button', {\n        text: 'Submit',\n        attr: {\n          disabled: $fields.map(\n            fields => !(fields.username && fields.password),\n          ),\n        },\n      })\n    })\n\n    h('section', () => {\n      spec({style: {marginTop: '1em'}})\n      h('div', {text: 'Reactive form debug:'})\n      h('pre', {text: $fields.map(stringify)})\n    })\n  })\n})\n\nfunction formModel() {\n  const changed = createEvent()\n  const submit = createEvent()\n\n  const $fields = createStore({}).on(changed, (fields, {name, value}) => ({\n    ...fields,\n    [name]: value,\n  }))\n\n  const change = name => changed.prepend(e => ({name, value: e.target.value}))\n\n  sample({\n    source: $fields,\n    clock: submit,\n    fn: stringify,\n  }).watch(alert)\n\n  return {change, submit, $fields}\n}\n\nfunction stringify(values) {\n  return JSON.stringify(values, null, 2)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Effector SWC Plugin transformLegacyDomainMethods Configuration\nDESCRIPTION: This JSON snippet shows an example configuration for the `transformLegacyDomainMethods` option of the Effector SWC plugin. It enables transforming Unit creators in Domains, like `domain.event()` or `domain.createEffect()`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/swc-plugin.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"transformLegacyDomainMethods\": true }]\n```\n\n----------------------------------------\n\nTITLE: Effector Effect inFlight Type\nDESCRIPTION: Declares the type for `effect.inFlight` store which is `Store<number>`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Effect.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\neffect.inFlight: Store<number>;\n```\n\n----------------------------------------\n\nTITLE: Text template usage\nDESCRIPTION: This TypeScript code shows how to use the `text` function to create text nodes with dynamic content from stores. The example uses template literals and a store containing a username to display a greeting.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst $username = createStore('guest')\n\nh('h1', () => {\n  text`Hello ${$username}!`\n})\n\n```\n\n----------------------------------------\n\nTITLE: Migration: Removing scope from import path\nDESCRIPTION: Shows how to update import statements to use the main effector-react module instead of the deprecated effector-react/scope. This involves removing '/scope' from the import path.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/module/scope.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n+ import { Provider } from \"effector-react\";\n- import { Provider } from \"effector-react/scope\";\n```\n\n----------------------------------------\n\nTITLE: Create OID function (Typescript)\nDESCRIPTION: Function to generate a unique object ID. Uses timestamp and random characters\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/shared/lib/oid.ts\nexport const createOid = () =>\n  ((new Date().getTime() / 1000) | 0).toString(16) +\n  \"xxxxxxxxxxxxxxxx\".replace(/[x]/g, () => ((Math.random() * 16) | 0).toString(16)).toLowerCase();\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with Vue bindings\nDESCRIPTION: This command installs both Effector and its Vue bindings using npm. The effector-vue package provides integration tools for using Effector with Vue.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/installation.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-vue\n```\n\n----------------------------------------\n\nTITLE: Installing Effector Solid Integration\nDESCRIPTION: This command installs the Effector Solid integration library along with the core Effector library. This is necessary for using Effector in a Solid application. Requires npm.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector effector-solid\n```\n\n----------------------------------------\n\nTITLE: PropertyMap type definition\nDESCRIPTION: Defines the `PropertyMap` type, which is an object mapping string keys to `Property` values. This represents a set of DOM properties, possibly reactive.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ntype PropertyMap = {[field: string]: Property}\n```\n\n----------------------------------------\n\nTITLE: Usage of h with event handlers\nDESCRIPTION: This TypeScript code demonstrates how to use the `h` function to declare a DOM element with event handlers in Forest.  It shows adding a click handler to a button and an anchor element with `preventDefault` configuration. Requires Effector's `createEvent` function.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst click = createEvent<MouseEvent>()\n\nh('button', {\n  text: 'Click me',\n  handler: {click},\n})\n\nh('a', {\n  text: 'Click me',\n  handler: {\n    config: {prevent: true},\n    on: {click},\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Effect Done Event - Typescript\nDESCRIPTION: Describes the `done` event, which triggers with the result of the effect execution and the argument passed during the call.  Manually calling the done event is prohibited.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Effect.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fx: Effect<P, D>\n\nfx.done\n-> Event<{params: P; result: D}>\n```\n\n----------------------------------------\n\nTITLE: Configuring transformLegacyDomainMethods Option\nDESCRIPTION: Configures the `transformLegacyDomainMethods` option of the Effector SWC plugin, enabling the transformation of Unit creators in Domains, such as `domain.event()` and `domain.createEffect()`, potentially affecting unrelated code.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n[\"@effector/swc-plugin\", { \"transformLegacyDomainMethods\": true }]\n```\n\n----------------------------------------\n\nTITLE: Type Test Example\nDESCRIPTION: This JavaScript code snippet demonstrates how to add a new type test.  The `test` function defines a test case, and `expect(typecheck).toMatchInlineSnapshot()` captures type errors for the given code, generating an inline snapshot. Dependencies: Jest.\nSOURCE: https://github.com/effector/effector/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\ntest('test name', () => {\n  // any code here\n\n  expect(typecheck).toMatchInlineSnapshot()\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Effector SWC Plugin\nDESCRIPTION: This command installs the Effector SWC plugin and @swc/core as dev dependencies using npm. The SWC plugin enables additional features and optimizations when using the SWC compiler.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/installation.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -ED @effector/swc-plugin @swc/core\n```\n\n----------------------------------------\n\nTITLE: Sample return value with target - Typescript\nDESCRIPTION: Demonstrates that if `target` is specified, `sample` will return the same `target`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/essentials/unit-composition.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = createStore(0);\nconst submitted = createEvent();\nconst sendData = createEvent<number>();\n\n// result будет иметь тип EventCallable<number>\nconst result = sample({\n  clock: submitted,\n  source: $store,\n  target: sendData,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Babel Module Resolver for Effector Compat\nDESCRIPTION: This configuration snippet shows how to use babel-plugin-module-resolver to automatically replace imports of `effector` and `effector-react` with their respective compatibility modules. This is useful for projects needing IE11 support.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/installation.mdx#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\n    [\n      \"babel-plugin-module-resolver\",\n      {\n        \"alias\": {\n          \"^effector$\": \"effector/compat\",\n          \"^effector-react$\": \"effector-react/compat\"\n        }\n      }\n    ]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Import Event and EventCallable types - Typescript\nDESCRIPTION: Imports the Event and EventCallable types from the effector library. These types are fundamental for defining events in effector applications.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type Event, type EventCallable } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: useUnit with Store (TypeScript)\nDESCRIPTION: Describes the function signature for using `useUnit` with an Effector Store.  It retrieves the current value of the store and subscribes the component to updates, causing a re-render whenever the store's value changes.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useUnit.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nuseUnit($store: Store<T>): T;\n```\n\n----------------------------------------\n\nTITLE: Building the project\nDESCRIPTION: This snippet describes how to build the project using yarn. It first installs the dependencies and then executes the build script. This command is required to prepare the application for deployment or server-side rendering.\nSOURCE: https://github.com/effector/effector/blob/master/examples/react-ssr/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn && yarn build\n```\n\n----------------------------------------\n\nTITLE: Wait Function (Typescript)\nDESCRIPTION: A utility function to simulate an asynchronous operation using `setTimeout`. It returns a promise that resolves after a random timeout (up to 1500ms). Used to mimic network latency in API calls.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/typescript/usage-with-effector-react.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Файл: /src/shared/lib/wait.ts\nexport function wait(timeout = Math.random() * 1500) {\n  return new Promise((resolve) => setTimeout(resolve, timeout));\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Effector from CDN\nDESCRIPTION: This code shows how to import Effector directly from a CDN, such as jsDelivr. This approach is useful for quick prototyping or environments where package managers are not available.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/installation.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from \"https://cdn.jsdelivr.net/npm/effector/effector.mjs\";\n```\n\n----------------------------------------\n\nTITLE: Installing effector-solid with yarn\nDESCRIPTION: This command installs effector and effector-solid using yarn, another package manager. It's an alternative to npm for installing dependencies.\nSOURCE: https://github.com/effector/effector/blob/master/packages/effector-solid/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nyarn add effector effector-solid\n```\n\n----------------------------------------\n\nTITLE: Property type definition\nDESCRIPTION: Defines the `Property` type, which represents a DOM property that can be either a plain value or a store of a plain value. This allows for reactive property updates.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ntype Property = PlainProperty | Store<PlainProperty>\n```\n\n----------------------------------------\n\nTITLE: Effector Test Setup\nDESCRIPTION: This code snippet provides a basic test setup for the complete Effector example. It forks the Effector scope and confirms that initial value of counter is zero. It simulates click using `allSettled` and then asserts the expected state.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/testing.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fork, allSettled } from \"effector\";\n\nimport { $clicksCount, buttonClicked, validateClickFx } from \"./model\";\n\ntest(\"main case\", async () => {\n  const scope = fork(); // 1\n\n  expect(scope.getState($clicksCount)).toEqual(0); // 2\n\n  await allSettled(buttonClicked, { scope }); // 3\n\n  expect(scope.getState($clicksCount)).toEqual(1); // 4\n});\n```\n\n----------------------------------------\n\nTITLE: Import from Effector Compat (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import from the `effector/compat` module in TypeScript. This is the first step in using the compatibility module instead of the standard `effector` package.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/module/compat.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {} from \"effector/compat\";\n```\n\n----------------------------------------\n\nTITLE: Import withRegion from effector\nDESCRIPTION: Imports the `withRegion` function from the Effector library. This function is used to manage the lifecycle and ownership of units within a defined region.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/withRegion.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { withRegion } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Integrating Effector with React\nDESCRIPTION: This React component demonstrates how to integrate Effector with React using the `useUnit` hook from `effector-react`.  It consumes the $counter store and the incremented and decremented events.  Different ways of consuming the store and events are demonstrated.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useUnit } from \"effector-react\";\nimport { createEvent, createStore } from \"effector\";\nimport { $counter, incremented, decremented } from \"./counter.js\";\n\nexport const Counter = () => {\n  const [counter, onIncremented, onDecremented] = useUnit([$counter, incremented, decremented]);\n  // или\n  const { counter, onIncremented, onDecremented } = useUnit({ $counter, incremented, decremented });\n  // или\n  const counter = useUnit($counter);\n  const onIncremented = useUnit(incremented);\n  const onDecremented = useUnit(decremented);\n\n  return (\n    <div>\n      <h1>Count: {counter}</h1>\n      <button onClick={onIncremented}>Increment</button>\n      <button onClick={onDecremented}>Decrement</button>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Attaching an Effect directly (TypeScript)\nDESCRIPTION: Demonstrates how to attach one effect to another, creating a local copy of the original effect.  This attached effect will trigger the original effect, and any associated watchers on both effects will be notified.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/attach.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { createEffect, attach } from \"effector\";\n\nconst originalFx = createEffect((word: string) => {\n  console.info(\"Напечатано:\", word);\n});\n\nconst attachedFx = attach({ effect: originalFx });\n\noriginalFx.watch(() => console.log(\"originalFx\"));\noriginalFx.done.watch(() => console.log(\"originalFx.done\"));\n\nattachedFx.watch(() => console.log(\"attachedFx\"));\nattachedFx.done.watch(() => console.log(\"attachedFx.done\"));\n\noriginalFx(\"первый\");\n// => originalFx\n// => Напечатано: первый\n// => originalFx.done\n\nattachedFx(\"второй\");\n// => attachedFx\n// => originalFx\n// Напечатано: второй\n// => originalFx.done\n// => attachedFx.done\n```\n\n----------------------------------------\n\nTITLE: Import useStoreMap from effector-vue\nDESCRIPTION: Imports the `useStoreMap` function from the `effector-vue/composition` module. This import is necessary to use the `useStoreMap` hook in Vue components.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useStoreMap.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useStoreMap } from \"effector-vue/composition\";\n```\n\n----------------------------------------\n\nTITLE: Vite Alias Configuration for effector-react\nDESCRIPTION: Configures Vite to automatically replace `effector` and `effector-react` with their respective `/compat` versions. This simplifies the process of supporting older browsers by ensuring that the compatibility versions are used throughout the project.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/module/сompat.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  resolve: {\n    alias: {\n      effector: \"effector/compat\",\n      \"effector-react\": \"effector-react/compat\",\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_32\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/At-Sky>\n            <img src=https://avatars.githubusercontent.com/u/88156646?v=4 width=\"100;\"  alt=lightningmq/>\n            <br />\n            <sub style=\"font-size:14px\"><b>lightningmq</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Effector Factories Configuration Example (JSON)\nDESCRIPTION: Provides a real-world example of configuring the `factories` option in effector/babel-plugin.  It lists specific file paths to treat as factory functions, allowing for unique SIDs during SSR. Requires a Babel environment and effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n// .babelrc\n{\n  \"plugins\": [\n    [\n      \"effector/babel-plugin\",\n      {\n        \"factories\": [\"src/createEffectStatus\", \"~/createCommonPending\"]\n      }\n    ]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: useStore function signature (TypeScript)\nDESCRIPTION: Defines the type signature for the `useStore` hook. It takes an Effector `Store` as input and returns the current `State` of that store. The `State` type is inferred from the store itself.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/useStore.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nuseStore($store: Store<State>): State\n```\n\n----------------------------------------\n\nTITLE: Event filterMap Type Inference Example\nDESCRIPTION: Shows how the return type of the filterMap function determines the type of the resulting event. Demonstrates that explicit type definition is not required as the type is automatically inferred from the filterMap function's return type.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst first = createEvent<number>();\n// first: Event<number>\n\nconst second = first.filterMap((count) => {\n  if (count === 0) return;\n  return count.toString();\n});\n// second: Event<string>\n```\n\n----------------------------------------\n\nTITLE: Import serialize and Scope from Effector (TypeScript)\nDESCRIPTION: This code imports the `serialize` function and the `Scope` type from the Effector library.  This import statement is necessary to use the `serialize` method for serializing scope states.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/serialize.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { serialize, type Scope } from \"effector\";\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_60\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/abelsiqueira>\n        <img src=https://avatars.githubusercontent.com/u/1068752?v=4 width=\"100;\"  alt=Abel Soares Siqueira/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Abel Soares Siqueira</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Installing effector with SolidJS\nDESCRIPTION: This command installs both the core effector package and the effector-solid package, which provides bindings and utilities for using effector with SolidJS. This installation is necessary when you're building SolidJS applications that leverage effector for state management.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm add effector effector-solid\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with yarn\nDESCRIPTION: This command installs the Effector library using yarn, another package manager for JavaScript.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/get-started.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn install effector\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_54\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/Alexandrsv>\n        <img src=https://avatars.githubusercontent.com/u/15097064?v=4 width=\"100;\"  alt=Александр/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Александр</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Effector Babel Plugin Configuration\nDESCRIPTION: This JSON snippet shows the configuration for the Effector Babel plugin. It specifies that the plugin should consider `@/shared/lib/create-name` as a custom factory.  This tells the plugin to wrap the factory with the `withFactory` helper function to ensure unique SIDs for instances of the factory.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\n    [\n      \"effector/babel-plugin\",\n      {\n        \"factories\": [\"@/shared/lib/create-name\"]\n      }\n    ]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Import useVModel from effector-vue/composition\nDESCRIPTION: Imports the useVModel hook from the effector-vue/composition module. This hook is specifically designed for use in Vue 3 applications.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useVModel.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useVModel } from \"effector-vue/composition\";\n```\n\n----------------------------------------\n\nTITLE: Installing effector with React\nDESCRIPTION: This command installs both the core effector package and the effector-react package, which provides bindings and utilities for using effector with React.  This installation is necessary when you're building React applications that leverage effector for state management.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm add effector effector-react\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with npm\nDESCRIPTION: This command installs the core Effector library using npm. Effector does not mandate a specific package manager.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/installation.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install effector\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with yarn\nDESCRIPTION: This command installs the core Effector library using the yarn package manager. It provides an alternative installation method for users who prefer yarn.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/introduction/get-started.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn install effector\n```\n\n----------------------------------------\n\nTITLE: Importing useStore from effector-vue/composition - TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the `useStore` hook from the `effector-vue/composition` module. This import is necessary to use the hook within a Vue component to subscribe to an Effector store.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/useStore.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useStore } from \"effector-vue/composition\";\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_37\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/astrobot-houston>\n        <img src=https://avatars.githubusercontent.com/u/108291165?v=4 width=\"100;\"  alt=Houston (Bot)/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Houston (Bot)</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: val usage example\nDESCRIPTION: Demonstrates using the `val` helper within an `h` function call to dynamically set the `transform` attribute.  It combines a store `$store` with a plain value `a` to create a dynamic string.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst $store = createStore(10)\nconst a = 20\n\nh('g', {\n  attr: {\n    transform: val`translate(${$store} ${a})`,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Monitoring Gate Status Updates in React with Effector\nDESCRIPTION: This example uses `createGate` from `effector-react` to create a gate.  The `Gate.status.watch` function monitors whether the gate is opened (mounted) or closed (unmounted), logging the boolean value to the console. The `useGate` hook integrates the gate with a React component, triggering the status update upon mounting.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-react/Gate.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createGate, useGate } from \"effector-react\";\n\nconst Gate = createGate();\n\nGate.status.watch((opened) => console.info(\"is Gate opened?\", opened));\n// => is Gate opened? false\n\nfunction App() {\n  useGate(Gate);\n  return <div>Example</div>;\n}\n\nReactDOM.render(<App />, root);\n// => is Gate opened? true\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_50\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/hyposlasher>\n        <img src=https://avatars.githubusercontent.com/u/13961762?v=4 width=\"100;\"  alt=Dinislam Maushov/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Dinislam Maushov</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Defining @@unitShape in a Custom Route Entity\nDESCRIPTION: Shows how to define the `@@unitShape` symbol within a custom `Route` entity. This example demonstrates creating a route with a `$params` store and then defining `@@unitShape` to return an object mapping the `params` property to the `$params` store. This allows UI libraries like `effector-react` to access the underlying units of the custom entity.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/ecosystem-development/unit-shape-protocol.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createRoute(/* ... */) {\n  const $params = createStore(/* ... */);\n\n  return {\n    \"@@unitShape\": () => ({\n      params: $params,\n    }),\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Installing effector-solid with pnpm\nDESCRIPTION: This command installs effector and effector-solid using pnpm, a performant package manager. It's an alternative to npm and yarn for installing dependencies.\nSOURCE: https://github.com/effector/effector/blob/master/packages/effector-solid/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\npnpm add effector effector-solid\n```\n\n----------------------------------------\n\nTITLE: Defining Message Schemas with Zod - Typescript\nDESCRIPTION: Defines Zod schemas for two types of WebSocket messages: `balanceChanged` and `reportGenerated`.  It also derives the TypeScript type `MessagesSchema` from the Zod schema, enabling type-safe message handling.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/guides/websocket-integration.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport const messagesSchema = z.discriminatedUnion(\"type\", [\n  z.object({\n    type: z.literal(\"balanceChanged\"),\n    balance: z.number(),\n  }),\n  z.object({\n    type: z.literal(\"reportGenerated\"),\n    reportId: z.string(),\n    reportName: z.string(),\n  }),\n]);\n\n// Get type from schema\ntype MessagesSchema = z.infer<typeof messagesSchema>;\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_24\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/GTech1256>\n            <img src=https://avatars.githubusercontent.com/u/18086485?v=4 width=\"100;\"  alt=Roman/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Roman</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: reactSsr Configuration\nDESCRIPTION: Example configuring the `reactSsr` option in the Effector Babel plugin. This option is deprecated since effector 23.0.0.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/babel-plugin.md#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"reactSsr\": false\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Store .map() Skip Void Example - Javascript\nDESCRIPTION: Demonstrates the usage of the `skipVoid` option within the `.map()` method. When `skipVoid` is set to `false`, the derived store will update even if the mapping function returns `undefined` or `null`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Store.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst $length = $title.map((title) => title.length, { skipVoid: false });\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_62\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/focusbytheway>\n        <img src=https://avatars.githubusercontent.com/u/45828023?v=4 width=\"100;\"  alt=Abdukerim Radjapov/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Abdukerim Radjapov</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Creating Event with nullable type\nDESCRIPTION: Creates an Effector event that can carry either a `Data` type or `null`.  This approach is suggested for representing optional or potentially empty data.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst maybeDataReceived = createEvent<Data | null>();\n// maybeDataReceived: EventCallable<Data | null>\n```\n\n----------------------------------------\n\nTITLE: Installing Effector with PNPM\nDESCRIPTION: This command installs the core Effector library using the pnpm package manager. Pnpm is another alternative, designed to save disk space and improve installation speed.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/introduction/installation.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm install effector\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_35\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/ilya>\n        <img src=https://avatars.githubusercontent.com/u/20424922?v=4 width=\"100;\"  alt=Ilya/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Ilya</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_64\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/rachaeldawn>\n        <img src=https://avatars.githubusercontent.com/u/7696498?v=4 width=\"100;\"  alt=Rachael Dawn/>\n        <br />\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_44\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/bonkboykz>\n        <img src=https://avatars.githubusercontent.com/u/4549476?v=4 width=\"100;\"  alt=Yesset Zhussupov/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Yesset Zhussupov</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_59\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/domosedov>\n        <img src=https://avatars.githubusercontent.com/u/42298502?v=4 width=\"100;\"  alt=Aleksandr Grigorii/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Aleksandr Grigorii</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_12\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/vladmelnikov>\n            <img src=https://avatars.githubusercontent.com/u/13378944?v=4 width=\"100;\"  alt=Vladislav Melnikov/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Vladislav Melnikov</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Component using useStore and useEvent\nDESCRIPTION: This snippet illustrates a React component using `useStore` and `useEvent` hooks from `effector-react`. It shows how to subscribe to store updates and bind event triggers. These hooks are deprecated in favor of `useUnit`.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/migration-guide-v23.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Component = () => {\n  const foo = useStore($foo);\n  const bar = useStore($bar);\n  const onSubmit = useEvent(triggerSubmit);\n};\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_41\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/artlud39>\n        <img src=https://avatars.githubusercontent.com/u/84090099?v=4 width=\"100;\"  alt=artlud39/>\n        <br />\n        <sub style=\"font-size:14px\"><b>artlud39</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_21\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/belozer>\n            <img src=https://avatars.githubusercontent.com/u/1655916?v=4 width=\"100;\"  alt=Sergey Belozyorcev/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Sergey Belozyorcev</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Custom Factory Example (Initial Code)\nDESCRIPTION: This code defines a custom factory function `createName` that creates an Effector event and store. It is used to demonstrate the need for the `withFactory` helper in the Effector plugin. The file structure illustrates how the factory is defined in one module and used in another.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/explanation/sids.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// src/shared/lib/create-name/index.ts\nexport function createName() {\n  const updateName = createEvent();\n  const $name = createStore(null);\n\n  $name.on(updateName, (_, nextName) => nextName);\n\n  return { $name };\n}\n\n// src/feature/persons/model.ts\nimport { createName } from \"@/shared/lib/create-name\";\n\nconst personOne = createName();\nconst personTwo = createName();\n```\n\n----------------------------------------\n\nTITLE: Configuring Effector SWC Plugin in Next.js\nDESCRIPTION: Shows how to add the @effector/swc-plugin to the next.config.js file in a Next.js project. The plugin is added to the swcPlugins array within the experimental configuration object.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/swc-plugin.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst nextConfig = {\n  experimental: {\n    // даже если пусто, передайте объект опций `{}` в плагин\n    swcPlugins: [[\"@effector/swc-plugin\", {}]],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_34\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/nonzzz>\n            <img src=https://avatars.githubusercontent.com/u/52351095?v=4 width=\"100;\"  alt=kanno/>\n            <br />\n            <sub style=\"font-size:14px\"><b>kanno</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_46\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/edprince>\n        <img src=https://avatars.githubusercontent.com/u/7027089?v=4 width=\"100;\"  alt=Ed Prince/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Ed Prince</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_20\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/Shiyan7>\n            <img src=https://avatars.githubusercontent.com/u/57950265?v=4 width=\"100;\"  alt=Shiyan7/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Shiyan7</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_53\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/BlackPoretsky>\n        <img src=https://avatars.githubusercontent.com/u/84518407?v=4 width=\"100;\"  alt=BlackPoretsky/>\n        <br />\n        <sub style=\"font-size:14px\"><b>BlackPoretsky</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_8\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/enomado>\n            <img src=https://avatars.githubusercontent.com/u/707007?v=4 width=\"100;\"  alt=Ivan/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Ivan</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Incorrect getState Usage in Effector (TypeScript)\nDESCRIPTION: This snippet demonstrates the anti-pattern of using `$store.getState()` to access store values within an Effector effect. It shows how `submitFormFx` directly gets values from `$user` and `$settings` using `getState`, which is discouraged.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/guides/best-practices.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst submitFormFx = createEffect((formData) => {\n  // Получаем значения через getState\n  const user = $user.getState();\n  const settings = $settings.getState();\n\n  return api.submit({\n    ...formData,\n    userId: user.id,\n    theme: settings.theme,\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: HTML Table for displaying Contributors\nDESCRIPTION: This HTML snippet creates a table structure to display a list of contributors. Each cell in the table contains a link to a contributor's GitHub profile along with their avatar and username. The table cells are styled for consistent width, height, and text wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_65\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/RachaelCodes>\n            <img src=https://avatars.githubusercontent.com/u/20260686?v=4 width=\"100;\"  alt=Rachael Dawn/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Rachael Dawn</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/bigslycat>\n            <img src=https://avatars.githubusercontent.com/u/1121997?v=4 width=\"100;\"  alt=bigslycat/>\n            <br />\n            <sub style=\"font-size:14px\"><b>bigslycat</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/pgrekovich>\n            <img src=https://avatars.githubusercontent.com/u/1001687?v=4 width=\"100;\"  alt=Pavel Hrakovich/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Pavel Hrakovich</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/OlegBrony>\n            <img src=https://avatars.githubusercontent.com/u/19880334?v=4 width=\"100;\"  alt=Oleh/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Oleh</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/olejech>\n            <img src=https://avatars.githubusercontent.com/u/64708593?v=4 width=\"100;\"  alt=Oleg/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Oleg</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/mikecann>\n            <img src=https://avatars.githubusercontent.com/u/215033?v=4 width=\"100;\"  alt=Mike Cann/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Mike Cann</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/MiiZZo>\n            <img src=https://avatars.githubusercontent.com/u/58049702?v=4 width=\"100;\"  alt=Nikita Svoyachenko/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Nikita Svoyachenko</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/lud>\n            <img src=https://avatars.githubusercontent.com/u/637632?v=4 width=\"100;\"  alt=Ludovic Dem/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Ludovic Dem</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/Leniorko>\n            <img src=https://avatars.githubusercontent.com/u/26775798?v=4 width=\"100;\"  alt=Leniorko/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Leniorko</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/RubaXa>\n            <img src=https://avatars.githubusercontent.com/u/1109562?v=4 width=\"100;\"  alt=Lebedev Konstantin/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Lebedev Konstantin</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/joelbandi>\n            <img src=https://avatars.githubusercontent.com/u/15027870?v=4 width=\"100;\"  alt=Joel Bandi/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Joel Bandi</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/jsejcksn>\n            <img src=https://avatars.githubusercontent.com/u/868251?v=4 width=\"100;\"  alt=Jesse Jackson/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Jesse Jackson</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/jankeromnes>\n            <img src=https://avatars.githubusercontent.com/u/599268?v=4 width=\"100;\"  alt=Jan Keromnes/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Jan Keromnes</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/vanpav>\n            <img src=https://avatars.githubusercontent.com/u/2944759?v=4 width=\"100;\"  alt=Ivan/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Ivan</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/newbornfrontender>\n            <img src=https://avatars.githubusercontent.com/u/34810942?v=4 width=\"100;\"  alt=Infant Frontender/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Infant Frontender</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/Ilmar7786>\n            <img src=https://avatars.githubusercontent.com/u/84752977?v=4 width=\"100;\"  alt=Ilya Martynov/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Ilya Martynov</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/TerrniT>\n            <img src=https://avatars.githubusercontent.com/u/104818206?v=4 width=\"100;\"  alt=Gleb Kotovsky/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Gleb Kotovsky</b></sub>\n        </a>\n    </td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/husek>\n            <img src=https://avatars.githubusercontent.com/u/4630702?v=4 width=\"100;\"  alt=Gabriel Husek/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Gabriel Husek</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: CSS for data attributes\nDESCRIPTION: This CSS snippet shows how to select an element based on a data attribute.  The `data-button-type` attribute is used to style elements with the value 'outline'.\nSOURCE: https://github.com/effector/effector/blob/master/packages/forest/README.md#_snippet_2\n\nLANGUAGE: css\nCODE:\n```\n[data-button-type='outline'] {\n}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_29\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/rokashkovvd>\n            <img src=https://avatars.githubusercontent.com/u/166542865?v=4 width=\"100;\"  alt=Vladimir/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Vladimir</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_22\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/satyarohith>\n            <img src=https://avatars.githubusercontent.com/u/29819102?v=4 width=\"100;\"  alt=Satya Rohith/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Satya Rohith</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_33\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/leushkin>\n            <img src=https://avatars.githubusercontent.com/u/26031322?v=4 width=\"100;\"  alt=Kirill Leushkin/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Kirill Leushkin</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_42\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/ansunrisein>\n        <img src=https://avatars.githubusercontent.com/u/45604301?v=4 width=\"100;\"  alt=ansunrisein/>\n        <br />\n        <sub style=\"font-size:14px\"><b>ansunrisein</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Importing VueEffector (Vue 3)\nDESCRIPTION: Imports the VueEffector plugin from the effector-vue/options-vue3 module.  This allows the plugin to be used in a Vue 3 application.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector-vue/VueEffector.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { VueEffector } from \"effector-vue/options-vue3\";\n```\n\n----------------------------------------\n\nTITLE: Mapping and Watching Events (Effector)\nDESCRIPTION: Demonstrates how to use `.map()` to transform event data and `.watch()` to observe the event's values.  The example transforms user data to extract the name and role. Requires the `effector` library to be installed.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/Event.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createEvent } from \"effector\";\n\nconst userUpdated = createEvent();\n\n// вы можете разбить поток данных с помощью метода .map()\nconst userNameUpdated = userUpdated.map(({ user }) => name);\n\n// либо преобразовать данные\nconst userRoleUpdated = userUpdated.map((user) => user.role.toUpperCase());\n\nuserNameUpdated.watch((name) => console.log(`Имя пользователя теперь [${name}]`));\nuserRoleUpdated.watch((role) => console.log(`Роль пользователя теперь [${role}]`));\n\nuserUpdated({ name: \"john\", role: \"admin\" });\n// => Имя пользователя теперь [john]\n// => Роль пользователя теперь [ADMIN]\n```\n\n----------------------------------------\n\nTITLE: Updating README Table of Contents\nDESCRIPTION: This command uses the doctoc tool to automatically generate and update the Table of Contents in the README.md file. This helps maintain a well-organized and easily navigable document.\nSOURCE: https://github.com/effector/effector/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpx doctoc README.md\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_56\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/sanohin>\n        <img src=https://avatars.githubusercontent.com/u/14825383?v=4 width=\"100;\"  alt=Alex Anokhin/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Alex Anokhin</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_43\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/anatolykopyl>\n        <img src=https://avatars.githubusercontent.com/u/33553182?v=4 width=\"100;\"  alt=Anatoly Kopyl/>\n        <br />\n        <sub style=\"font-size:14px\"><b>Anatoly Kopyl</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Creating Contributor Link with Image and Name\nDESCRIPTION: This HTML snippet defines a link to a GitHub profile, displaying the user's avatar and name. It uses an image tag to show the avatar and a sub tag to display the username with bold styling. The link and content are centered.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_5\n\nLANGUAGE: HTML\nCODE:\n```\n<a href=https://github.com/binjospookie>\n    <img src=https://avatars.githubusercontent.com/u/8722478?v=4 width=\"100;\"  alt=Viktor Pasynok/>\n    <br />\n    <sub style=\"font-size:14px\"><b>Viktor Pasynok</b></sub>\n</a>\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Contributors in HTML Table\nDESCRIPTION: This HTML snippet displays a list of contributors using an HTML table. Each contributor is represented by their GitHub avatar, username, and a link to their GitHub profile.  The table cells are styled for alignment and word wrapping.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_61\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n    <a href=https://github.com/7iomka>\n        <img src=https://avatars.githubusercontent.com/u/18473137?v=4 width=\"100;\"  alt=7iomka/>\n        <br />\n        <sub style=\"font-size:14px\"><b>7iomka</b></sub>\n    </a>\n</td>\n```\n\n----------------------------------------\n\nTITLE: Enabling Search in Effector Documentation Locally\nDESCRIPTION: These commands enable search functionality in the Effector documentation when running locally.  First, the documentation is built without compression using COMPRESS=false.  Then, the search server is started with pnpm search:dev. Finally, Astro is started with the PUBLIC_SEARCH environment variable set to true.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nCOMPRESS=false pnpm build\npnpm search:dev\nPUBLIC_SEARCH=true pnpm dev\n```\n\n----------------------------------------\n\nTITLE: Preventing Unit Calls from Pure Functions (TS)\nDESCRIPTION: This code shows an example of an anti-pattern where an event or effect is called directly within a pure function (like a mapper or filter). This throws an error in effector 23.0.0 and later. This is the incorrect code.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/api/effector/Event.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst someHappened = createEvent<number>();\nconst another = createEvent();\n\nconst derived = someHappened.map((number) => {\n  another(); // THROWS!\n  return String(number);\n});\n```\n\n----------------------------------------\n\nTITLE: clearNode Usage with Store Destruction\nDESCRIPTION: Demonstrates how to use `clearNode` to destroy an Effector store.  It imports `createStore`, `createEvent`, and `clearNode` from effector. It creates a store and an event, then uses `clearNode` to remove the store, preventing further updates. Dependencies: effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/clearNode.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore, createEvent, clearNode } from \"effector\";\n\nconst inc = createEvent();\nconst store = createStore(0).on(inc, (x) => x + 1);\ninc.watch(() => console.log(\"inc called\"));\nstore.watch((x) => console.log(\"store state: \", x));\n// => store state: 0\ninc();\n// => inc called\n// => store state: 1\nclearNode(store);\ninc();\n// => inc called\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet generates a table row containing contributor information, including a link to their GitHub profile and their avatar image. The contributor's username is displayed below the avatar.\nSOURCE: https://github.com/effector/effector/blob/master/README.md#_snippet_16\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" style=\"word-wrap: break-word; width: 150.0; height: 150.0\">\n        <a href=https://github.com/vsviridov>\n            <img src=https://avatars.githubusercontent.com/u/221684?v=4 width=\"100;\"  alt=Vasili Sviridov/>\n            <br />\n            <sub style=\"font-size:14px\"><b>Vasili Sviridov</b></sub>\n        </a>\n    </td>\n```\n\n----------------------------------------\n\nTITLE: scopeBind usage with Callback\nDESCRIPTION: This example shows how to bind a callback function to a scope using `scopeBind`. The callback passed to `history.listen` is bound to the scope, allowing `locationChanged` event to be triggered within the correct scope when the callback is invoked.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/scopeBind.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore, attach, scopeBind } from \"effector\";\n\nconst $history = createStore(history);\nconst locationChanged = createEvent();\n\nconst listenToHistoryFx = attach({\n  source: $history,\n  effect: (history) => {\n    return history.listen(\n      scopeBind((location) => {\n        locationChanged(location);\n      }),\n    );\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Object in effector Store (Incorrect)\nDESCRIPTION: Demonstrates the incorrect approach to updating an object in an effector store by directly mutating the object. This violates effector's immutability guidelines and can cause unexpected side effects.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/en/essentials/manage-states.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// update object\n$user.on(nameChanged, (user, newName) => {\n  user.name = newName; // mutation!\n  return user;\n});\n```\n\n----------------------------------------\n\nTITLE: Effector importName Configuration (JSON)\nDESCRIPTION: Specifies the import names to be processed by the effector/babel-plugin. The `importName` option can be a string or an array of strings.  Requires a Babel environment and effector.\nSOURCE: https://github.com/effector/effector/blob/master/documentation/src/content/docs/ru/api/effector/babel-plugin.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"effector/babel-plugin\",\n  {\n    \"importName\": [\"effector\"]\n  }\n]\n```"
  }
]