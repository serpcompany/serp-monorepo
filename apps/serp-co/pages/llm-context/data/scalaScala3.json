[
  {
    "owner": "scala",
    "repo": "scala3",
    "content": "TITLE: Defining an Algebraic Data Type for Expressions in Scala 3\nDESCRIPTION: Defines a Scala 3 `enum` named `Expr` parameterized by type `A`. It represents a simple expression language with two cases: `Var` for named variables and `Apply` for function application, which recursively contains function and argument expressions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/polymorphic-function-types.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nenum Expr[A]:\n  case Var(name: String)\n  case Apply[A, B](fun: Expr[B => A], arg: Expr[B]) extends Expr[A]\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Opaque Type Alias for Logarithm in Scala\nDESCRIPTION: Defines an opaque type alias 'Logarithm' within the 'MyMath' object to provide efficient type abstraction for logarithmic values based on Double. The companion object exposes constructor methods 'apply' and 'safe', ensuring all valid logarithms are derived from positive doubles, while extension methods '+', '*', and 'toDouble' enable safe arithmetic and conversion. Requires only Scala 3 for opaque types, no special dependencies, accepts Doubles as input and outputs Logarithm or Option[Logarithm]; Logarithms can be safely operated only through the provided API.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/opaques.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject MyMath:\n\n  opaque type Logarithm = Double\n\n  object Logarithm:\n\n    // These are the two ways to lift to the Logarithm type\n\n    def apply(d: Double): Logarithm = math.log(d)\n\n    def safe(d: Double): Option[Logarithm] =\n      if d > 0.0 then Some(math.log(d)) else None\n\n  end Logarithm\n\n  // Extension methods define opaque types' public APIs\n  extension (x: Logarithm)\n    def toDouble: Double = math.exp(x)\n    def + (y: Logarithm): Logarithm = Logarithm(math.exp(x) + math.exp(y))\n    def * (y: Logarithm): Logarithm = x + y\n\nend MyMath\n```\n\n----------------------------------------\n\nTITLE: Inlining Conditional Logic Based on Constant Conditions\nDESCRIPTION: Demonstrates how the compiler simplifies code based on compile-time constants, specifically transforming an `if` statement that depends on a constant condition `Config.logging`. When `logging` is false, the entire logging block is eliminated, resulting in more efficient code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef factorial(n: BigInt): BigInt =\n  log(s\"factorial($n)\", indentSetting){\n    if n == 0 then 1\n    else n * factorial(n - 1)\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala 3 `Quotes` Trait and Extension Methods\nDESCRIPTION: Defines the central `Quotes` trait, which provides the context and primitive operations for the Scala 3 macro system, including access to the reflection API via `reflect`. It shows extension methods that become available on `Expr[T]` instances when a `Quotes` instance is implicitly available (e.g., `show`, `matches`, `value`, `valueOrAbort`, `isExprOf`, `asExprOf`). The trait internally relies on `QuoteUnpickler` and `QuoteMatching` implementations and manages the current splicing scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Quotes:\n  this: runtime.QuoteUnpickler & runtime.QuoteMatching =>\n\n  extension [T](self: Expr[T])\n    def show: String\n    def matches(that: Expr[Any]): Boolean\n    def value(using FromExpr[T]): Option[T]\n    def valueOrAbort(using FromExpr[T]): T\n  end extension\n\n  extension (self: Expr[Any])\n    def isExprOf[X](using Type[X]): Boolean\n    def asExprOf[X](using Type[X]): Expr[X]\n  end extension\n\n  // abstract object reflect ...\n```\n\n----------------------------------------\n\nTITLE: Assertion function using Functor's map method\nDESCRIPTION: Defines a testing function `assertTransformation` that verifies the transformation applied via the `map` method of a functor. Uses context bound and extension method to call `map` directly on the original value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef assertTransformation[F[_]: Functor, A, B](expected: F[B], original: F[A], mapping: A => B): Unit =\n  assert(expected == original.map(mapping))\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Enum Scala\nDESCRIPTION: Shows how to define an enumeration with parameters in Scala 3. Each case can provide arguments to the enum's constructor using an explicit extends clause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n```\n\n----------------------------------------\n\nTITLE: Example Implicit Conversion from Int to java.lang.Integer in Scala\nDESCRIPTION: Defines a given instance named int2Integer of scala.Conversion from Int to java.lang.Integer by delegating to java.lang.Integer.valueOf to enable automatic boxing of primitive int values in Scala. This conversion facilitates interoperability with Java APIs expecting java.lang.Integer.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/conversions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ngiven int2Integer: Conversion[Int, java.lang.Integer] =\n  java.lang.Integer.valueOf(_)\n```\n\n----------------------------------------\n\nTITLE: Generic Extension Methods with Type Parameters in Scala\nDESCRIPTION: Defines extension methods that are generic over a type parameter [T], allowing methods like \"second\" on lists and overloaded \"+\" with numeric constraints. Demonstrates combining extension type parameters with method type parameters, usage of type classes (Numeric), and calling such methods with specific type arguments. This requires implicit Numeric instances or using clauses for correct operation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nextension [T](xs: List[T])\n  def second = xs.tail.head\n\nextension [T: Numeric](x: T)\n  def + (y: T): T = summon[Numeric[T]].plus(x, y)\n\nextension [T](xs: List[T])\n  def sumBy[U: Numeric](f: T => U): U = ...\n\nList(\"a\", \"bb\", \"ccc\").sumBy[Int](_.length)\n\nsumBy[String](List(\"a\", \"bb\", \"ccc\"))(_.length)\n\nsumBy[String](List(\"a\", \"bb\", \"ccc\"))[Int](_.length)\n\nextension [T](x: T)(using n: Numeric[T])\n  def + (y: T): T = n.plus(x, y)\n```\n\n----------------------------------------\n\nTITLE: Complete Type Class Derivation Macro Example in Scala\nDESCRIPTION: Provides the full code combining all components: the `Eq` trait, its companion object with base instances and helper methods (`eqProduct`, `eqSum`), the `summonAll` macro, the `derived` macro (handling both product and sum types), and an example usage object (`Macro3`) with the `===` extension method and the `eqGen` inline given to trigger derivation. Includes example types `Person` and `Opt` for demonstration.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation-macro.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.deriving.*\nimport scala.quoted.*\n\n\ntrait Eq[T]:\n   def eqv(x: T, y: T): Boolean\n\nobject Eq:\n   given Eq[String] with\n      def eqv(x: String, y: String) = x == y\n\n   given Eq[Int] with\n      def eqv(x: Int, y: Int) = x == y\n\n   def eqProduct[T](body: (T, T) => Boolean): Eq[T] =\n      new Eq[T]:\n         def eqv(x: T, y: T): Boolean = body(x, y)\n\n   def eqSum[T](body: (T, T) => Boolean): Eq[T] =\n      new Eq[T]:\n         def eqv(x: T, y: T): Boolean = body(x, y)\n\n   def summonAll[T: Type](using Quotes): List[Expr[Eq[_]]] =\n      Type.of[T] match\n         case '[String *: tpes] => '{ summon[Eq[String]] } :: summonAll[tpes]\n         case '[Int *: tpes]    => '{ summon[Eq[Int]] }    :: summonAll[tpes]\n         case '[tpe *: tpes]    => derived[tpe] :: summonAll[tpes]\n         case '[EmptyTuple]     => Nil\n\n   given derived[T: Type](using q: Quotes): Expr[Eq[T]] =\n      import quotes.reflect.*\n\n      val ev: Expr[Mirror.Of[T]] = Expr.summon[Mirror.Of[T]].get\n\n      ev match\n         case '{ $m: Mirror.ProductOf[T] { type MirroredElemTypes = elementTypes }} =>\n            val elemInstances = summonAll[elementTypes]\n            val eqProductBody: (Expr[T], Expr[T]) => Expr[Boolean] = (x, y) =>\n               elemInstances.zipWithIndex.foldLeft(Expr(true: Boolean)) {\n                  case (acc, (elem, index)) =>\n                     val e1 = '{$x.asInstanceOf[Product].productElement(${Expr(index)})} \n                     val e2 = '{$y.asInstanceOf[Product].productElement(${Expr(index)})} \n\n                     '{ $acc && $elem.asInstanceOf[Eq[Any]].eqv($e1, $e2) }\n               }\n            '{ eqProduct((x: T, y: T) => ${eqProductBody('x, 'y)}) }\n\n         case '{ $m: Mirror.SumOf[T] { type MirroredElemTypes = elementTypes }} =>\n            val elemInstances = summonAll[elementTypes]\n            val eqSumBody: (Expr[T], Expr[T]) => Expr[Boolean] = (x, y) =>\n               val ordx = '{ $m.ordinal($x) }\n               val ordy = '{ $m.ordinal($y) }\n\n               val elements = Expr.ofList(elemInstances)\n               '{ $ordx == $ordy && $elements($ordx).asInstanceOf[Eq[Any]].eqv($x, $y) }\n\n         '{ eqSum((x: T, y: T) => ${eqSumBody('x, 'y)}) }\n   end derived\nend Eq\n\nobject Macro3:\n   extension [T](inline x: T)\n      inline def === (inline y: T)(using eq: Eq[T]): Boolean = eq.eqv(x, y)\n\n   inline given eqGen[T]: Eq[T] = ${ Eq.derived[T] }\n\ncase class Person(name: String, age: Int)\n\nenum Opt[+T]:\n   case Sm(t: T)\n   case Nn\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Opaque Type Aliases in Scala 3\nDESCRIPTION: This snippet demonstrates the creation of an opaque type alias 'Logarithm' within object 'MyMath', including companion object methods for construction ('apply', 'safe') and extension methods ('toDouble', '+', '*') for the opaque type. It shows how to instantiate and perform operations with the opaque type, emphasizing scope-based type abstraction and restrictions on invalid operations outside 'MyMath'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/opaques.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject MyMath:\n\n  opaque type Logarithm = Double\n\n  object Logarithm:\n\n    def apply(d: Double): Logarithm = math.log(d)\n\n    def safe(d: Double): Option[Logarithm] =\n      if d > 0.0 then Some(math.log(d)) else None\n\n  end Logarithm\n\n  extension (x: Logarithm)\n    def toDouble: Double = math.exp(x)\n    def + (y: Logarithm): Logarithm = Logarithm(math.exp(x) + math.exp(y))\n    def * (y: Logarithm): Logarithm = x + y\n\nend MyMath\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Main Method with @main\nDESCRIPTION: Defines an executable program using the `@main` annotation in Scala 3. The method signature dictates the expected command-line arguments, which are automatically parsed. This example demonstrates parsing an integer, a required string, and optional varargs strings. It requires the Scala 3 compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/main-functions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n@main def happyBirthday(age: Int, name: String, others: String*) =\n  val suffix =\n    age % 100 match\n    case 11 | 12 | 13 => \"th\"\n    case _ =>\n      age % 10 match\n        case 1 => \"st\"\n        case 2 => \"nd\"\n        case 3 => \"rd\"\n        case _ => \"th\"\n  val bldr = new StringBuilder(s\"Happy $age$suffix birthday, $name\")\n  for other <- others do bldr.append(\" and \").append(other)\n  bldr.toString\n```\n\n----------------------------------------\n\nTITLE: Defining a Renderer with Dependency Injection using 'using' in Scala 3\nDESCRIPTION: This snippet defines a trait 'RenderingContext' and a class 'Renderer' that depends on an implicit 'RenderingContext' using Scala 3's 'using' clause. It initializes an instance of 'Renderer', illustrating dependency injection and context passing in Scala 3. Dependencies include the 'RenderingContext' trait and the 'Renderer' class.\nSOURCE: https://github.com/scala/scala3/blob/main/scaladoc-testcases/docs/_docs/index.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait RenderingContext\nclass Renderer(using RenderingContext)\nval renderer: Renderer = Renderer()\n```\n\n----------------------------------------\n\nTITLE: Defining Methods and Companion Object Constructor for Option Enum in Scala\nDESCRIPTION: Defines the Option enum with cases Some and None, adding an isDefined method that pattern matches on this enum instance to return a Boolean. Also includes a companion object implementing an apply method that returns None if input is null, otherwise Some, leveraging Scala's null handling and factory method pattern. This extends enums with behavior and auxiliary constructors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/adts.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nenum Option[+T]:\n  case Some(x: T)\n  case None\n\n  def isDefined: Boolean = this match\n    case None => false\n    case _    => true\n\nobject Option:\n\n  def apply[T >: Null](x: T): Option[T] =\n    if x == null then None else Some(x)\n\nend Option\n```\n\n----------------------------------------\n\nTITLE: Defining ConfigDependent type alias\nDESCRIPTION: Creates a type alias `ConfigDependent` representing functions from `Config` to a result `Result`. Facilitates monadic composition of environment-dependent computations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ntype ConfigDependent[Result] = Config => Result\n```\n\n----------------------------------------\n\nTITLE: Defining and Pattern Matching with Vararg Splices in Scala 3\nDESCRIPTION: This snippet demonstrates how to declare vararg splices using the new postfix `*` syntax in Scala 3, and how to pattern match against lists including vararg patterns. It showcases the improved syntax, replacing the old `: _*` syntax, and illustrates the use of `xs*` in pattern matching for binding remaining elements. Dependencies include standard Scala collections and pattern matching features; the input is an array converted to a list, and outputs depend on pattern matching results.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/vararg-splices.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval arr = Array(0, 1, 2, 3)\nval lst = List(arr*)                   // vararg splice argument\nlst match\n  case List(0, 1, xs*) => println(xs)  // binds xs to Seq(2, 3)\n  case List(1, _*) =>                  // wildcard pattern\n```\n\n----------------------------------------\n\nTITLE: Defining an Implicit Conversion-Based Ordering in Scala Using scala.Conversion\nDESCRIPTION: This snippet shows how to define an implicit Ordering for an arbitrary type T by using an implicit Conversion from T to S and an existing Ordering for S. It requires importing scala.language.implicitConversions and having implicit instances of Conversion[T, S] and Ordering[S] in scope. The implicit def ordT provides an Ordering[T] by delegating comparison to ordS, converting T to S first. The example also defines a class A and an implicit Conversion from A to Int, allowing Ordering[A] to be derived using Ordering[Int].\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/implicit-conversions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.implicitConversions\nimplicit def ordT[T, S](\n    implicit conv: Conversion[T, S],\n             ordS: Ordering[S]\n   ): Ordering[T] =\n   // `ordS` compares values of type `S`, but we can convert from `T` to `S`\n  (x: T, y: T) => ordS.compare(x, y)\n\nclass A(val x: Int) // The type for which we want an `Ordering`\n\n// Convert `A` to a type for which an `Ordering` is available:\nimplicit val AToInt: Conversion[A, Int] = _.x\n\nimplicitly[Ordering[Int]] // Ok, exists in the standard library\nimplicitly[Ordering[A]] // Ok, will use the implicit conversion from\n                        // `A` to `Int` and the `Ordering` for `Int`.\n```\n\n----------------------------------------\n\nTITLE: Generating type class instances with 'derives' clause in Scala 3\nDESCRIPTION: This code demonstrates how to use the 'derives' clause in Scala 3 when defining algebraic data types like 'Tree' to automatically generate given instances for type classes such as 'Eq', 'Ordering', and 'Show'. It shows how the compiler derives implementations using the 'derived' method, simplifying boilerplate for common patterns.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nenum Tree[T] derives Eq, Ordering, Show:\n  case Branch(left: Tree[T], right: Tree[T])\n  case Leaf(elem: T)\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Anonymous Context Parameters in Scala\nDESCRIPTION: A 'maximum' function that takes a list and finds the maximum value, using an unnamed context parameter of type Ord[T].\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef maximum[T](xs: List[T])(using Ord[T]): T =\n  xs.reduceLeft(max)\n```\n\n----------------------------------------\n\nTITLE: Applying Flow Typing with Null Checks in Scala 3\nDESCRIPTION: Demonstrates how Scala 3's flow typing refines the type of a `String | Null` variable after a non-null check (`!= null`) or an assertion (`assert`). It shows the type becomes `String` within the 'then' branch or after the assertion, and reverts outside the scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nval s: String | Null = ???\nif s != null then\n  // s: String\n\n// s: String | Null\n\nassert(s != null)\n// s: String\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif s == null then\n  // s: String | Null\nelse\n  // s: String\n```\n\n----------------------------------------\n\nTITLE: Defining Postconditions with Context Functions and Extension Methods in Scala\nDESCRIPTION: This snippet defines a zero-overhead abstraction for postconditions using opaque type aliases, context function types, and extension methods. It declares an opaque type `WrappedResult[T]`, a method `result` to access the wrapped value, and an extension method `ensuring` that asserts a condition expressed as a context function requiring `WrappedResult[T]`. This ensures the result can be referenced transparently inside the condition, enabling concise and efficient postcondition checks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/context-functions.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject PostConditions:\n  opaque type WrappedResult[T] = T\n\n  def result[T](using r: WrappedResult[T]): T = r\n\n  extension [T](x: T)\n    def ensuring(condition: WrappedResult[T] ?=> Boolean): T =\n      assert(condition(using x))\n      x\nend PostConditions\n\nimport PostConditions.{ensuring, result}\n\nval s = List(1, 2, 3).sum.ensuring(result == 6)\n```\n\n----------------------------------------\n\nTITLE: Defining the ToExpr Type Class for Value Lifting in Scala\nDESCRIPTION: Shows the definition of the `ToExpr[T]` type class trait. Implementations of this trait provide the logic for converting a runtime value of type `T` into its quoted `Expr[T]` representation, requiring a `Quotes` context. Depends on `scala.quoted.*`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ntrait ToExpr[T]:\n  def apply(x: T)(using Quotes): Expr[T]\n```\n\n----------------------------------------\n\nTITLE: Defining Union Types and Pattern Matching in Scala\nDESCRIPTION: Defines a `trait ID` and `case class` types (`UserName`, `Password`) extending it. It then shows a function `help` that accepts a parameter with the union type `UserName | Password` and pattern matches on it to handle the specific types. This illustrates a common use case for Union Types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/union-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ID\ncase class UserName(name: String) extends ID\ncase class Password(hash: Hash) extends ID\n\ndef help(id: UserName | Password) =\n  val user = id match\n    case UserName(name) => lookupName(name)\n    case Password(hash) => lookupPassword(hash)\n  ...\n\n```\n\n----------------------------------------\n\nTITLE: Example of Type Class Traits with Self Type `Self` in Scala\nDESCRIPTION: Defines several type class traits utilizing an abstract `Self` type member to represent the implementing type. Demonstrates how to express constraints and operations with minimal type parameters, enhancing compositionality and clarity when working with type classes. Includes traits like `Ord`, `SemiGroup`, `Monoid`, `Functor`, and `Monad`, as well as a `ParserCombinator`, illustrating advanced patterns using self types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/typeclasses.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Ord:\n  type Self\n\ntrait SemiGroup:\n  type Self\n  extension (x: Self) def combine(y: Self): Self\n\ntrait Monoid extends SemiGroup:\n  def unit: Self\nobject Monoid:\n  def unit[M](using m: Monoid { type Self = M}): M\n\ntrait Functor:\n  type Self[A]\n  extension [A](x: Self[A]) def map[B](f: A => B): Self[B]\n\ntrait Monad extends Functor:\n  def pure[A](x: A): Self[A]\n  extension [A](x: Self[A])\n    def flatMap[B](f: A => Self[B]): Self[B]\n    def map[B](f: A => B) = x.flatMap(f `andThen` pure)\n\ndef reduce[A: Monoid](xs: List[A]): A =\n  xs.foldLeft(Monoid.unit)(_ `combine` _)\n\ntrait ParserCombinator:\n  type Self\n  type Input\n  type Result\n  extension (self: Self)\n    def parse(input: Input): Option[Result] = ...\n\ndef combine[A: ParserCombinator, B: ParserCombinator { type Input = A.Input }]: ... \n```\n\n----------------------------------------\n\nTITLE: Concrete Match Types Syntax in Scala 3 EBNF\nDESCRIPTION: Defines the concrete syntax of match types in Scala 3 using EBNF. Match types consist of an infix type followed by 'match' and a series of type case clauses. Each clause matches a pattern and associates it with a type, supporting conditional type selection syntax in Scala.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_7\n\nLANGUAGE: ebnf\nCODE:\n```\nMatchType             ::=  InfixType ‘match’ <<< TypeCaseClauses >>>\nTypeCaseClauses       ::=  TypeCaseClause { TypeCaseClause }\nTypeCaseClause        ::=  ‘case’ (InfixType | ‘_’) ‘=>’ Type [semi]\n```\n\n----------------------------------------\n\nTITLE: Defining the SemiGroup and Monoid traits\nDESCRIPTION: Defines the `SemiGroup` and `Monoid` traits as type classes with extension methods for combining values and providing a neutral element, respectively. These serve as foundational abstractions for associative binary operations and identities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait SemiGroup[T]:\n  extension (x: T) def combine(y: T): T\n\ntrait Monoid[T] extends SemiGroup[T]:\n  def unit: T\n```\n\n----------------------------------------\n\nTITLE: Defining the Functor type class with map extension method\nDESCRIPTION: Defines a `Functor` trait with a `map` method utilizing extension syntax, allowing transformation of values inside context `F[_]`. This pattern facilitates writing generic mapping logic for any functorial type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Functor[F[_]]:\n  extension [A](x: F[A])\n    def map[B](f: A => B): F[B]\n```\n\n----------------------------------------\n\nTITLE: Implementing Functor Instance for List in Scala\nDESCRIPTION: Provides a `given` instance of the `Functor` type class for the `List` type constructor. It implements the required `map` method by delegating the call to the pre-existing `map` method defined on Scala's standard `List` type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Functor[List] with\n  def map[A, B](x: List[A], f: A => B): List[B] =\n    x.map(f) // List already has a `map` method\n```\n\n----------------------------------------\n\nTITLE: Defining an Algebraic Data Type with derives Clause in Scala\nDESCRIPTION: Defines an enum called Tree with two cases (Branch and Leaf) and a derives clause specifying automatic generation of Eq, Ordering, and Show type class instances. This requires the type classes Eq, Ordering, and Show to be in scope with the appropriate derived machinery. The enum models recursive tree data with parameterized element type T, and outputs instances for equality, ordering, and pretty-printing automatically via Scala 3's derivation facilities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nenum Tree[T] derives Eq, Ordering, Show:\n  case Branch(left: Tree[T], right: Tree[T])\n  case Leaf(elem: T)\n```\n\n----------------------------------------\n\nTITLE: Examples of Scala 3's New Control Syntax\nDESCRIPTION: Provides sample Scala 3 code snippets demonstrating the new control syntax features such as optional parentheses in if, while, for, and try expressions. Highlights the syntax's simplicity and flexibility with minimal syntax clutter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/control-syntax.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nif x < 0 then\n  \"negative\"\nelse if x == 0 then\n  \"zero\"\nelse\n  \"positive\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif x < 0 then -x else x\n```\n\nLANGUAGE: Scala\nCODE:\n```\nwhile x >= 0 do x = f(x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor x <- xs if x > 0\nyield x * x\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  x <- xs\n  y <- ys\ndo\n  println(x + y)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntry body\ncatch case ex: IOException => handle\n```\n\n----------------------------------------\n\nTITLE: Calling Functions with Implicit Context Arguments in Scala\nDESCRIPTION: Examples of calling the max function without explicitly providing the context argument, letting the compiler infer it.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nmax(2, 3)\nmax(List(1, 2, 3), Nil)\n```\n\n----------------------------------------\n\nTITLE: Simulating Implicit Conversion with Scala 3 Given Conversion (Full Syntax)\nDESCRIPTION: Defines a given instance of `scala.Conversion[String, Token]` using the full syntax with an `apply` method. This is the recommended Scala 3 way to provide implicit conversions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\ngiven stringToToken: Conversion[String, Token]:\n  def apply(str: String): Token = KeyWord(str)\n```\n\n----------------------------------------\n\nTITLE: Declaring a Trait as Transparent in Scala\nDESCRIPTION: Shows how to declare a trait as `transparent`. When a common supertype trait is marked `transparent`, Scala 3's type inference prioritizes inferring the more precise Union Type rather than widening to the supertype, as demonstrated in subsequent examples.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/union-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntransparent trait ID\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Inline Values and Methods in Scala\nDESCRIPTION: Demonstrates the definition of an `inline val` (`Config.logging`) which acts as a compile-time constant, and an `inline def` (`Logger.log`) whose body is guaranteed to be inlined at the call site. The example shows how an `if` statement using the `inline val` can be optimized away during compilation based on the constant's value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Config:\n  inline val logging = false\n\nobject Logger:\n\n  private var indent = 0\n\n  inline def log[T](msg: String, indentMargin: =>Int)(op: => T): T =\n    if Config.logging then\n      println(s\"${\"  \" * indent}start $msg\")\n      indent += indentMargin\n      val result = op\n      indent -= indentMargin\n      println(s\"${\"  \" * indent}$msg = $result\")\n      result\n    else op\nend Logger\n```\n\n----------------------------------------\n\nTITLE: Defining a Hybrid Enum/ADT (Color)\nDESCRIPTION: This example demonstrates a hybrid definition combining simple enum values with a parameterized case within the same `enum` construct. The `Color` enum takes a value parameter `rgb` in its definition. The cases `Red`, `Green`, and `Blue` extend `Color` with specific `rgb` values, while the `Mix` case is parameterized, allowing for arbitrary `rgb` values. This shows the flexibility of Scala 3 enums.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/adts.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n  case Mix(mix: Int) extends Color(mix)\n```\n\n----------------------------------------\n\nTITLE: Declaring Implicit Values and Methods in Scala\nDESCRIPTION: This snippet demonstrates the strict requirement in Scala 3 that implicit values and method result types be explicitly declared, except for those inside local blocks where inference is still allowed. It shows both correct and incorrect declarations and highlights the resulting error messages. Dependencies include the presence of a Context type definition, and the main input is the declaration of members within a class or a local value. The key output is compile-time errors for missing explicit types in implicits outside local blocks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/implicit-resolution.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass C {\n\n  val ctx: Context = ...        // ok\n\n  /*!*/ implicit val x = ...    // error: type must be given explicitly\n\n  /*!*/ implicit def y = ...    // error: type must be given explicitly\n}\nval y = {\n  implicit val ctx = this.ctx // ok\n  ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Examples of Invoking a Kind-Polymorphic Function in Scala\nDESCRIPTION: Shows multiple valid invocations of the function 'f' defined with any-kinded type parameter 'T <: AnyKind'. The examples illustrate that the type argument passed to 'f' can be a standard type (e.g., Int), a unary type constructor (e.g., List), a binary type constructor (e.g., Map), or an anonymous lambda type constructor (e.g., [X] =>> String). These demonstrate the flexibility gained from kind polymorphism, allowing functions to accept type parameters of varied kinds seamlessly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/kind-polymorphism.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nf[Int]\nf[List]\nf[Map]\nf[[X] =>> String]\n```\n\n----------------------------------------\n\nTITLE: Optional Braces for Function Arguments in Scala 3\nDESCRIPTION: This series of Scala code snippets shows how to use a colon in place of braces for function arguments and multi-line lambdas, a syntax available in Scala 3.3 and later. The examples demonstrate using a colon to open an indented block for the argument to a function or infix operator. No specific imports are required; examples rely on method definitions and lambda expressions. Inputs can be values for function arguments, and outputs are determined by the respective blocks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ntimes(10):\n  println(\"ah\")\n  println(\"ha\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\ncredentials `++`:\n  val file = Path.userHome / \".credentials\"\n  if file.exists\n  then Seq(Credentials(file))\n  else Seq()\n```\n\nLANGUAGE: Scala\nCODE:\n```\nxs.map:\n  x =>\n    val y = x - 1\n    y * y\n```\n\nLANGUAGE: Scala\nCODE:\n```\nxs.map: x =>\n  val y = x - 1\n  y * y\n```\n\nLANGUAGE: Scala\nCODE:\n```\nxs.foldLeft(0): (x, y) =>\n  x + y\n```\n\n----------------------------------------\n\nTITLE: Defining Anonymous Alias Given Instances in Scala\nDESCRIPTION: This demonstrates defining alias `given` instances without explicit names. The first example shows a simple anonymous alias, and the second shows one that depends on a context parameter (`config: Config`) via a `using` clause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/givens.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Position = enclosingTree.position\ngiven (using config: Config): Factory = MemoizingFactory(config)\n```\n\n----------------------------------------\n\nTITLE: Creating Concise Implicit Conversion Instance Using Alias in Scala\nDESCRIPTION: This snippet shows a short-form syntax for defining an implicit conversion from String to Token using a given Conversion alias. The instance leverages KeyWord's constructor as a function, providing a concise and idiomatic Scala 3 way of expressing the conversion. Dependencies include the Token and KeyWord classes, and the instance will be automatically picked up by the compiler where appropriate.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/conversions.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Conversion[String, Token] = new KeyWord(_)\n```\n\n----------------------------------------\n\nTITLE: Implementing Parser Combinators with Type Classes in Scala 3\nDESCRIPTION: Defines a parser combinator framework using type classes with dependent types for inputs and results. Shows how the new Scala 3 type class syntax allows for clean expression of complex type relationships between combinators, using associated types for input and result types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/typeclasses.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n/** A parser combinator */\ntrait Combinator:\n  type Self\n\n  type Input\n  type Result\n\n  extension (self: Self)\n    /** Parses and returns an element from input `in` */\n    def parse(in: Input): Option[Result]\nend Combinator\n\ncase class Apply[I, R](action: I => Option[R])\ncase class Combine[A, B](a: A, b: B)\n\ngiven [I, R] => Apply[I, R] is Combinator:\n  type Input = I\n  type Result = R\n  extension (self: Apply[I, R])\n    def parse(in: I): Option[R] = self.action(in)\n\ngiven [A: Combinator, B: Combinator { type Input = A.Input }]\n    => Combine[A, B] is Combinator:\n  type Input = A.Input\n  type Result = (A.Result, B.Result)\n  extension (self: Combine[A, B])\n    def parse(in: Input): Option[Result] =\n      for\n        x <- self.a.parse(in)\n        y <- self.b.parse(in)\n      yield (x, y)\n```\n\n----------------------------------------\n\nTITLE: Defining Type Alias for Reader Monad Function Type in Scala\nDESCRIPTION: Defines a type alias `ConfigDependent[Result]` as shorthand for the function type `Config => Result`. This alias simplifies the type signatures when defining and implementing the Monad instance for functions depending on `Config`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\ntype ConfigDependent[Result] = Config => Result\n```\n\n----------------------------------------\n\nTITLE: Translation of Recursive Extension Methods in Scala\nDESCRIPTION: Shows the translated form of the recursive `position` extension method. The compiler converts it into a regular method where the receiver `s` is passed as the first parameter, including in the recursive call `position(s)(ch, n + 1)`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ndef position(s: String)(ch: Char, n: Int): Int =\n  if n < s.length && s(n) != ch then position(s)(ch, n + 1)\n  else n\n```\n\n----------------------------------------\n\nTITLE: Implementing Standard Type Classes with Instance Givens in Scala 3\nDESCRIPTION: Defines several standard type classes (Ord, Show, SemiGroup, Monoid, Functor, Monad) with associated instance implementations for Int, List, and Reader. The example also includes usage patterns demonstrating extension methods and context bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/typeclasses.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n  // Type classes\n\n  trait Ord:\n    type Self\n    extension (x: Self)\n      def compareTo(y: Self): Int\n      def < (y: Self): Boolean = compareTo(y) < 0\n      def > (y: Self): Boolean = compareTo(y) > 0\n      def <= (y: Self): Boolean = compareTo(y) <= 0\n      def >= (y: Self): Boolean = compareTo(y) >= 0\n      def max(y: Self): Self = if x < y then y else x\n\n  trait Show:\n    type Self\n    extension (x: Self) def show: String\n\n  trait SemiGroup:\n    type Self\n    extension (x: Self) def combine(y: Self): Self\n\n  trait Monoid extends SemiGroup:\n    def unit: Self\n\n  trait Functor:\n    type Self[A] // Here, Self is a type constructor with parameter A\n    extension [A](x: Self[A]) def map[B](f: A => B): Self[B]\n\n  trait Monad extends Functor:\n    def pure[A](x: A): Self[A]\n    extension [A](x: Self[A])\n      def flatMap[B](f: A => Self[B]): Self[B]\n      def map[B](f: A => B) = x.flatMap(f `andThen` pure)\n\n  // Instances\n\n  given Int is Ord:\n    extension (x: Int)\n      def compareTo(y: Int) =\n        if x < y then -1\n        else if x > y then +1\n        else 0\n\n  given [T: Ord] => List[T] is Ord:\n    extension (xs: List[T]) def compareTo(ys: List[T]): Int =\n      (xs, ys) match\n      case (Nil, Nil) => 0\n      case (Nil, _) => -1\n      case (_, Nil) => +1\n      case (x :: xs1, y :: ys1) =>\n        val fst = x.compareTo(y)\n        if (fst != 0) fst else xs1.compareTo(ys1)\n\n  given List is Monad:\n    extension [A](xs: List[A])\n      def flatMap[B](f: A => List[B]): List[B] =\n        xs.flatMap(f)\n    def pure[A](x: A): List[A] =\n      List(x)\n\n  type Reader[Ctx] = [X] =>> Ctx => X\n\n  given [Ctx] => Reader[Ctx] is Monad:\n    extension [A](r: Ctx => A)\n      def flatMap[B](f: A => Ctx => B): Ctx => B =\n        ctx => f(r(ctx))(ctx)\n    def pure[A](x: A): Ctx => A =\n      ctx => x\n\n  // Usages\n\n  extension (xs: Seq[String])\n    def longestStrings: Seq[String] =\n      val maxLength = xs.map(_.length).max\n      xs.filter(_.length == maxLength)\n\n  extension [M[_]: Monad, A](xss: M[M[A]])\n    def flatten: M[A] =\n      xss.flatMap(identity)\n\n  def maximum[T: Ord](xs: List[T]): T =\n    xs.reduce(_ `max` _)\n\n  given descending: [T: Ord] => T is Ord:\n    extension (x: T) def compareTo(y: T) = T.compareTo(y)(x)\n\n  def minimum[T: Ord](xs: List[T]) =\n    maximum(xs)(using descending)\n```\n\n----------------------------------------\n\nTITLE: Defining Monoid and SemiGroup Type Classes in Scala\nDESCRIPTION: Defines the `SemiGroup` and `Monoid` type class traits in Scala 3. `SemiGroup` requires a `combine` operation implemented via an extension method. `Monoid` extends `SemiGroup` and adds a `unit` element, representing an identity value for the combine operation. These traits specify contracts for types that support associative combination.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait SemiGroup[T]:\n  extension (x: T) def combine (y: T): T\n\ntrait Monoid[T] extends SemiGroup[T]:\n  def unit: T\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Given Instances in Scala 3\nDESCRIPTION: This snippet defines a type class trait `Ord[T]` with comparison operations and provides two given instances: one for `Int` and a generic one for `List[T]` where `T` has an `Ord[T]`. It demonstrates use of context bounds `[T: Ord]` which require an implicit `Ord[T]` to be available for constructing `Ord[List[T]]`. The code illustrates how to create reusable, type-specific comparison logic via givens.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/givens.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Ord[T]:\n  def compare(x: T, y: T): Int\n  extension (x: T)\n    def < (y: T) = compare(x, y) < 0\n    def > (y: T) = compare(x, y) > 0\n\ngiven intOrd: Ord[Int]:\n  def compare(x: Int, y: Int) =\n    if x < y then -1 else if x > y then +1 else 0\n\ngiven listOrd[T: Ord]: Ord[List[T]]:\n\n  def compare(xs: List[T], ys: List[T]): Int = (xs, ys) match\n    case (Nil, Nil) => 0\n    case (Nil, _) => -1\n    case (_, Nil) => +1\n    case (x :: xs1, y :: ys1) =>\n      val fst = summon[Ord[T]].compare(x, y)\n      if fst != 0 then fst else compare(xs1, ys1)\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Syntax Rules - EBNF - Scala 3\nDESCRIPTION: This snippet provides a set of EBNF grammar rules defining where and how the new 'extension' construct fits into the syntactic structure of Scala 3. The rules show how Extension nodes are included in BlockStat, TemplateStat, and TopStat, and detail the grammar for single and collective extension methods as well as their method bodies. Key structural parameters include DefTypeParamClause, UsingParamClause, and DefParam, which together configure parameterization and contextual type dependencies for extension methods. This formalism is intended to guide language tooling, parsers, and interpreters rather than serve as executable code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_10\n\nLANGUAGE: EBNF\nCODE:\n```\nBlockStat         ::=  ... | Extension\nTemplateStat      ::=  ... | Extension\nTopStat           ::=  ... | Extension\nExtension         ::=  ‘extension’ [DefTypeParamClause] {UsingParamClause}\n                       ‘(’ DefParam ‘)’ {UsingParamClause} ExtMethods\nExtMethods        ::=  ExtMethod | [nl] <<< ExtMethod {semi ExtMethod} >>>\nExtMethod         ::=  {Annotation [nl]} {Modifier} ‘def’ DefDef\n```\n\n----------------------------------------\n\nTITLE: Conditionally Summoning Givens using summonFrom (Pattern-Bound Given) (Scala)\nDESCRIPTION: This snippet presents an alternative implementation of `setFor[T]` using `scala.compiletime.summonFrom`. It utilizes a pattern-bound given (`case given Ordering[T]`) to implicitly capture the summoned `Ordering` instance when creating the `TreeSet`, avoiding an explicit `using` clause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.summonFrom\nimport scala.collection.immutable.{HashSet, TreeSet}\n\ninline def setFor[T]: Set[T] = summonFrom {\n  case given Ordering[T] => new TreeSet[T]\n  case _                 => new HashSet[T]\n}\n```\n\n----------------------------------------\n\nTITLE: Example usage of varargs method for summing integers\nDESCRIPTION: Illustrates how to define and invoke a method with variable arguments (`Int*`) in Scala 3, demonstrating both direct argument passing and sequence expansion syntax (`: _*`). It also shows that passing a list directly without expansion causes a type mismatch, clarifying usage constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(xs: Int*) = xs.foldLeft(0)((x, y) => x + y)\n\nsum(1, 2, 3, 4)\nsum(List(1, 2, 3, 4): _*)\n\n// this does not typecheck:\nsum(List(1, 2, 3, 4))\n```\n\n----------------------------------------\n\nTITLE: Partial Application with Eta Expansion in Scala\nDESCRIPTION: This snippet shows how a method 'm' with multiple parameter lists can be automatically eta-expanded or partially applied in Scala 3. Assigning 'm' to 'f1' yields a function expecting the first parameter list, while 'f2' is the result of partially applying the first list. This demonstrates the flexibility of eta expansion with curried methods. Dependencies: None beyond standard Scala. Parameters: 'x' (Boolean), 'y' (String), 'z' (Int). Returns: List[Int].\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/eta-expansion-spec.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef m(x: Boolean, y: String)(z: Int): List[Int]\nval f1 = m\nval f2 = m(true, \"abc\")\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional Given with Parameter Scala 3\nDESCRIPTION: Defines a given `Factory` that is available only if a `Config` instance can be provided. The `(config: Config)` section indicates a context parameter requirement: the given `Factory` can be synthesized provided a given `config` of type `Config` is available in the implicit scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/more-givens.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ngiven (config: Config) => Factory = MemoizingFactory(config)\n```\n\n----------------------------------------\n\nTITLE: Example of a Scala Class with val and var Parameters in Scala\nDESCRIPTION: Demonstrates how val and var parameters in a Scala class generate accessor and setter methods automatically. Requires Scala environment. The class C has one plain parameter x, one val parameter y which has an immutable accessor, and one var parameter z with both getter and setter. Shows class instantiation and mutation via setter. Inputs: constructor arguments. Output: instance with accessible members reflecting val/var behavior.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass C(x: Int, val y: String, var z: List[String])\nval c = new C(1, \"abc\", List())\nc.z = c.y :: c.z\n```\n\n----------------------------------------\n\nTITLE: Using Context Parameters with Traits in Scala 3\nDESCRIPTION: Illustrates trait definitions using context parameters in Scala 3. 'ImpliedGreeting' requires an implicit context parameter 'iname' of type 'ImpliedName', which it uses in its 'msg' method. Shows 'ImpliedFormalGreeting' overriding 'msg'. The class 'F' demonstrates implicit trait extension with correct passing of context parameters, highlighting Scala's implicit expansions and compliance with initialization rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\ntrait ImpliedGreeting(using val iname: ImpliedName):\n  def msg = s\"How are you, $iname\"\n\ncase class ImpliedName(name: String):\n  override def toString = name\n\ntrait ImpliedFormalGreeting extends ImpliedGreeting:\n  override def msg = s\"How do you do, $iname\"\n\nclass F(using iname: ImpliedName) extends ImpliedFormalGreeting\n```\n\n----------------------------------------\n\nTITLE: Generating Derived Instances for Type Classes in Scala\nDESCRIPTION: Shows how given instances for Eq, Ordering, and Show type classes are generated for the Tree algebraic data type using the derives clause. These instances rely on the type parameter T having its own type class instances and use the derived method provided in each type class's companion object. The approach expects the type classes to provide a derived method and demonstrates the shape of compiler-generated implicits.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ngiven [T: Eq]       : Eq[Tree[T]]       = Eq.derived\ngiven [T: Ordering] : Ordering[Tree[T]] = Ordering.derived\ngiven [T: Show]     : Show[Tree[T]]     = Show.derived\n```\n\n----------------------------------------\n\nTITLE: Implementing Functor instance for List\nDESCRIPTION: Provides a given `Functor` instance for `List`, leveraging the existing `map` method of `List`. Includes extension method syntax, enabling `list.map(f)` directly without explicit summon.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Functor[List]:\n  extension [A](xs: List[A])\n    def map[B](f: A => B): List[B] = xs.map(f)\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Conversions as Implied Instances of 'scala.Conversion'\nDESCRIPTION: Defines implicit conversions using implied instances of 'scala.Conversion', specifying how to convert from one type to another. Demonstrates modern syntax and approach to implicit conversions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nimplied for Conversion[String, Token] {\n  def apply(str: String): Token = new KeyWord(str)\n}\n```\n\n----------------------------------------\n\nTITLE: General Syntax of Scala 3 Export Clauses\nDESCRIPTION: Presents the general format for an `export` clause in Scala 3. It consists of a stable path identifier (`path`) followed by one or more selectors (`sel_1, ..., sel_n`) enclosed in braces, defining which members are aliased.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_3\n\nLANGUAGE: Syntax\nCODE:\n```\nexport path . { sel_1, ..., sel_n }\n```\n\n----------------------------------------\n\nTITLE: Mapping List of Tuples with Shorthand Syntax (Scala)\nDESCRIPTION: Provides an equivalent shorthand syntax for the parameter untupling example. The `_ + _` represents a lambda function `(x, y) => x + y`, which is implicitly applied to the elements of each tuple in the list `xs` via parameter untupling.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/parameter-untupling.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nxs.map(_ + _)\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Given Instance in Scala 3\nDESCRIPTION: Defines a parameterized given instance `listOrd` for `Ord[List[T]]` that depends on an implicit `Ord[T]`. This demonstrates how to define contextual values in Scala 3 that require other contextual parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ngiven listOrd: [T] => (ord: Ord[T]) => Ord[List[T]] { ... }\n```\n\n----------------------------------------\n\nTITLE: Importing Given Instances By Type in Scala 3\nDESCRIPTION: Illustrates how given instances can be imported selectively by their type using `given T` syntax, allowing precise import of given instances conforming to the specified types. Includes examples with single and multiple type parameters and with wildcard type arguments for parameterized types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/contextual/given-imports.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport A.given TC\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport A.{given T1, ..., given Tn}\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject Instances:\n  given intOrd: Ordering[Int] = ...\n  given listOrd[T: Ordering]: Ordering[List[T]] = ...\n  given ec: ExecutionContext = ...\n  given im: Monoid[Int] = ...\n\nimport Instances.{given Ordering[?], given ExecutionContext}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport Instances.{im, given Ordering[?]}\n```\n\n----------------------------------------\n\nTITLE: Using Inline Conditionals to Enforce Compile-Time Constant Conditions in Scala 3\nDESCRIPTION: Defines an inline method with an inline if-then-else expression whose condition must be a compile-time constant. This ensures that the conditional is simplified at compile time to the selected branch, causing a compilation error if the condition is not constant. The example accepts an integer delta and branches to increaseBy or decreaseBy accordingly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ninline def update(delta: Int) =\n  inline if delta >= 0 then increaseBy(delta)\n  else decreaseBy(-delta)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala `NonEmptyTuple` and the `*:` Cons Operator\nDESCRIPTION: Defines the `scala.NonEmptyTuple` sealed trait for tuples with at least one element, extending `Tuple`. It provides an `apply` method for element access. The `*:` sealed abstract class represents the cons operation (prepending an element `H` to a tail tuple `T`), extending `NonEmptyTuple`. The `*:` companion object provides an `unapply` method for pattern matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n/** Tuple of arbitrary non-zero arity */\nsealed trait NonEmptyTuple extends Tuple:\n  /** Get the i-th element of this tuple. */\n  inline def apply[This >: this.type <: NonEmptyTuple](n: Int): Elem[This, n.type] = ...\n  ...\n\nsealed abstract class *:[+H, +T <: Tuple] extends NonEmptyTuple\n\nobject `*:` :\n  def unapply[H, T <: Tuple](x: H *: T): (H, T) = (x.head, x.tail)\n```\n\n----------------------------------------\n\nTITLE: Modeling State Machine Constraints with Evidence Using Scala\nDESCRIPTION: Defines a basic state machine composed of 'On' and 'Off' states. The machine enforces that 'turnedOn' is only callable when the current state is 'Off' using an IsOff[S] contextual evidence, demonstrated with given and constraints. Dependencies include 'scala.annotation.implicitNotFound'. Main parameters enforce compile-time state. This code illustrates compile-only evidence to restrict method calls based on type and is not reliant on erased constructs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait State\nfinal class On extends State\nfinal class Off extends State\n\n@implicitNotFound(\"State must be Off\")\nclass IsOff[S <: State]\nobject IsOff:\n  given isOff: IsOff[Off] = new IsOff[Off]\n\nclass Machine[S <: State]:\n  def turnedOn(using IsOff[S]): Machine[On] = new Machine[On]\n\nval m = new Machine[Off]\nm.turnedOn\nm.turnedOn.turnedOn // ERROR\n//                 ^\n//                  State must be Off\n```\n\n----------------------------------------\n\nTITLE: Usage Restrictions for Erased Parameters in Scala\nDESCRIPTION: Demonstrates the restrictions on using erased parameters in computations, showing they can only be passed to other erased parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef methodWithErasedInt1(erased i: Int): Int =\n  i + 42 // ERROR: can not use i\n\ndef methodWithErasedInt2(erased i: Int): Int =\n  methodWithErasedInt1(i) // OK\n```\n\n----------------------------------------\n\nTITLE: Defining Operators Using Extension Methods in Scala\nDESCRIPTION: Provides examples of defining symbolic operators (`<`, `+:`), including right-associative ones, and infix operators (`min`) using the extension method syntax for various types. It also shows the corresponding invocation syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nextension (x: String)\n  def < (y: String): Boolean = ...\nextension (x: Elem)\n  def +: (xs: Seq[Elem]): Seq[Elem] = ...\nextension (x: Number)\n  infix def min (y: Number): Number = ...\n\n\"ab\" < \"c\"\n1 +: List(2, 3)\nx min 3\n```\n\n----------------------------------------\n\nTITLE: Defining and Using By-Name Context Parameters in Scala\nDESCRIPTION: Defines a `Codec` trait and provides `given` instances for `Int` and `Option[T]`. The `optionCodec` uses a by-name context parameter `ev: => Codec[T]` to defer the search for the inner type's codec until it's actually needed (e.g., only when the option is `Some`), preventing potential divergence and unnecessary evaluation. The example then summons a `Codec[Option[Int]]` and uses its `write` method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/by-name-context-parameters.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Codec[T]:\n  def write(x: T): Unit\n\ngiven intCodec: Codec[Int] = ???\n\ngiven optionCodec: [T] => (ev: => Codec[T]) => Codec[Option[T]]:\n  def write(xo: Option[T]) = xo match\n    case Some(x) => ev.write(x)\n    case None =>\n\nval s = summon[Codec[Option[Int]]]\n\ns.write(Some(33))\ns.write(None)\n```\n\n----------------------------------------\n\nTITLE: Transparent Inline Method Returning a Singleton Type in Scala\nDESCRIPTION: Demonstrates a `transparent inline` method `zero` returning `Int`. Because it's transparent and always returns the constant `0`, the compiler refines the return type of a call `zero` to the singleton type `0`. This allows subsequent operations like `zero + 1` to be correctly typed as having the singleton type `1`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ntransparent inline def zero: Int = 0\n\nval one: 1 = zero + 1\n```\n\n----------------------------------------\n\nTITLE: Defining Traits, Classes, Objects, and Enums with Optional Braces in Scala 3\nDESCRIPTION: This set of code examples demonstrates the new syntax for template bodies in Scala 3, where class, trait, object, enum, package, and new-instance bodies can be defined using indentation and a colon instead of braces. The examples showcase how to structure multiple top-level or nested definitions using the new colon-and-indent region. No external dependencies are needed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ntrait A:\n  def f: Int\n\nclass C(x: Int) extends A:\n  def f = x\n\nobject O:\n  def f = 3\n\nenum Color:\n  case Red, Green, Blue\n\nnew A:\n  def f = 3\n\npackage p:\n  def a = 1\n\npackage q:\n  def b = 2\n```\n\n----------------------------------------\n\nTITLE: Implementing a Derived Method for Type Class Auto-Derivation in Scala\nDESCRIPTION: Shows the canonical derived method pattern for supporting automatic type class instance generation via derives. The method expects an implicit Mirror.Of[T] for the target type T and returns an instance of the type class TC[T]. Implementations can use the Mirror capabilities and may be inline or involve metaprogramming. The sample snippet assumes scala.deriving.Mirror and the trait or class TC[_] are available.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.deriving.Mirror\n\ninline def derived[T](using Mirror.Of[T]): TC[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Defining the Eq Type Class in Scala\nDESCRIPTION: Defines a simple generic type class `Eq[T]` with a single abstract method `eqv` that checks if two instances of type `T` are equivalent.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait Eq[T]:\n  def eqv(x: T, y: T): Boolean\n```\n\n----------------------------------------\n\nTITLE: Defining a Higher-Kinded Functor Type Class in Scala\nDESCRIPTION: This code defines a classic higher-kinded Functor type class that abstracts over a type constructor F[_]. The Functor provides a 'map' function that transforms values inside the context of F from type A to type B. The snippet assumes no dependencies, but expects F to be a type of kind * -> *, and is intended for generic functional programming. Inputs are the function f and the container, and the output is the mapped container.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nclass Functor[F[_]] {\n   def map[A, B](f: A => B): F[A] => F[B]\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking Generic Code Generation Functions in Scala\nDESCRIPTION: Illustrates calling the `singletonListExpr` and `emptyListExpr` functions. These calls rely on implicitly available `Type[T]` instances, such as the compiler-provided `Type.of[String]` or a `Type[Option[U]]` derived from an available `Type[U]`. Assumes `singletonListExpr`, `emptyListExpr`, and necessary `Type` instances are in scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval list1: Expr[List[String]] =\n  singletonListExpr('{\"hello\"}) // requires a given `Type[Sting]`\nval list0: Expr[List[Option[T]]] =\n  emptyListExpr[Option[U]] // requires a given `Type[Option[U]]`\n```\n\n----------------------------------------\n\nTITLE: Extending Multiple Traits Including a Parameterized One in Scala 3\nDESCRIPTION: Illustrates a class `GreetFormally` extending both the `FormalGreeting` trait and the parameterized `Greeting` trait. The necessary argument (\"Bob\") is passed to the `Greeting` trait during the class definition. The implementation prints the message generated by the overridden `msg` method from `FormalGreeting`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/trait-parameters.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass GreetFormally extends FormalGreeting, Greeting(\"Bob\"):\n  println(msg)\n```\n\n----------------------------------------\n\nTITLE: Extending Case Class Hierarchies in Scala 3\nDESCRIPTION: This snippet exemplifies the extension of a sealed trait hierarchy by defining additional case classes in the same or different source files. The snippet shows how extensibility can be controlled using the `sealed` modifier to restrict external subclassing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Number(x: Int) extends Expr\n```\n\n----------------------------------------\n\nTITLE: Equivalent Manual Implementation of Postcondition Checking in Scala\nDESCRIPTION: Illustrates the equivalent hand-written code to the `ensuring` extension method, showing an explicit variable `result` storing the computation and an assertion on the condition, followed by returning `result`. This clarifies the zero-overhead nature of the abstraction.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/context-functions.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval s =\n  val result = List(1, 2, 3).sum\n  assert(result == 6)\n  result\n```\n\n----------------------------------------\n\nTITLE: Defining Collective Generic Extensions with `using` Clauses in Scala\nDESCRIPTION: Demonstrates defining collective extension methods (`smallest`, `smallestIndices`) for a generic type `List[T]`, incorporating both type parameters (`[T]`) and a `using` clause (`Ordering[T]`) within the collective extension block.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nextension [T](xs: List[T])(using Ordering[T])\n  def smallest(n: Int): List[T] = xs.sorted.take(n)\n  def smallestIndices(n: Int): List[Int] =\n    val limit = smallest(n).max\n    xs.zipWithIndex.collect { case (x, i) if x <= limit => i }\n```\n\n----------------------------------------\n\nTITLE: Infix extension method `#:` for lazy list construction in Scala 3\nDESCRIPTION: This snippet adds an extension method `#:` to create a lazy list by prepending an element to an existing lazy list without evaluating the tail. The method takes a call-by-name parameter `xs1`, capturing any side effects, and constructs a `LzyCons` with the element and a thunk returning the tail. It enables concise and effect-aware list building syntax similar to `::`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_29\n\nLANGUAGE: Scala\nCODE:\n```\nextension [A](x: A)\n  def #:(xs1: => LzyList[A]^): LzyList[A]^{xs1} =\n    LzyCons(x, () => xs1)\n```\n\n----------------------------------------\n\nTITLE: Using Flow-Sensitive Typing for Null Checks in Scala 3\nDESCRIPTION: Illustrates flow-sensitive type analysis in Scala 3 when explicit nulls are enabled. Inside the `if` block where `s` is checked for non-nullity (`s != null`), the compiler refines its type from `String|Null` to `String`, allowing safe access to `String` members within that scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval s: String|Null = ???\n\nif (s != null) {\n  // s: String\n}\nelse {\n  // s: String|Null\n}\n```\n\n----------------------------------------\n\nTITLE: Expansion of Value Definitions with No-Variable Patterns in Scala\nDESCRIPTION: Illustrates the expansion of a Scala value definition `val p = e` where the pattern `p` binds no variables. This expansion results in simply matching the expression `e` against the pattern `p` and discarding the result (`=> ()`), typically used for asserting that `e` matches `p` or for side effects within the pattern match.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n´e´ match { case ´p´ => () }\n```\n\n----------------------------------------\n\nTITLE: Overriding Methods in Scala 3 Traits\nDESCRIPTION: Defines a trait 'FormalGreeting' that extends the previously defined 'Greeting' trait and overrides the 'msg' method to produce a formal greeting message. Demonstrates that when a class extends 'FormalGreeting', it must also extend 'Greeting' with an argument to satisfy Scala 3 initialization rules. Shows example class 'GreetBobFormally' illustrating this.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\ntrait FormalGreeting extends Greeting:\n  override def msg = s\"How do you do, $name\"\n\nclass GreetBobFormally extends FormalGreeting, Greeting(\"Bob\")\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Traits with Context Parameters in Scala\nDESCRIPTION: This comprehensive snippet shows how to define a trait (`ImpliedGreeting`) that uses a context parameter instead of a direct constructor parameter, along with supporting types and derived traits. It demonstrates how context parameters provide flexibility in inheritance, as seen in class `F`'s definition. Dependencies: case class `ImpliedName`, trait `ImpliedGreeting`, derived trait `ImpliedFormalGreeting`. Parameters: context parameter `iname` supplied implicitly via `using`. Input: `ImpliedName`, Output: greeting messages. Limitation: context parameters require Scala 3's implicit/context parameter mechanisms.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/trait-parameters.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ncase class ImpliedName(name: String):\n  override def toString = name\n\ntrait ImpliedGreeting(using val iname: ImpliedName):\n  def msg = s\"How are you, $iname\"\n\ntrait ImpliedFormalGreeting extends ImpliedGreeting:\n  override def msg = s\"How do you do, $iname\"\n\nclass F(using iname: ImpliedName) extends ImpliedFormalGreeting\n```\n\n----------------------------------------\n\nTITLE: Exploiting Bad Type Bounds with Functions in Scala\nDESCRIPTION: Defines two functions, `f` and `g`, that exploit a type member `p.T` assumed to have bad bounds (`Any <: T <: Nothing`). Function `f` uses the lower bound to cast `Any` to `p.T`, and `g` uses the upper bound to cast `p.T` to `Nothing`. Composing them (`g(f(x))`) effectively allows converting any expression to type `Nothing`, breaking type soundness.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-02-17-scaling-dot-soundness.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Any): p.T = x\ndef g(x: p.T): Nothing = x\n```\n\n----------------------------------------\n\nTITLE: Implementing Scala Derived Eq Method\nDESCRIPTION: Implements the core `derived` method for the `Eq` type class using Scala 3's `inline` features and `Mirror`. It takes a `Mirror.Of[T]` implicitly, lazily collects required element instances via `summonInstances`, and then uses an `inline match` on the `Mirror` to dispatch to structure-specific handlers (`eqSum`, `eqProduct`). This method is inlined at call sites.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.deriving.Mirror\n\ninline def derived[T](using m: Mirror.Of[T]): Eq[T] = \n  lazy val elemInstances = summonInstances[T, m.MirroredElemTypes] // (1)\n  inline m match                                                   // (2)\n    case s: Mirror.SumOf[T]     => eqSum(s, elemInstances)\n    case p: Mirror.ProductOf[T] => eqProduct(p, elemInstances)\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Peano Numbers with `TypeTest` Givens in Scala\nDESCRIPTION: Defines an abstract structure for Peano numbers using a `Peano` trait with abstract types (`Nat`, `Zero`, `Succ`) and operations. Crucially, it declares `given` instances for `TypeTest[Nat, Zero]` and `TypeTest[Nat, Succ]`, which are required for safely distinguishing between `Zero` and `Succ` subtypes of `Nat` at runtime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.*\n\ntrait Peano:\n  type Nat\n  type Zero <: Nat\n  type Succ <: Nat\n\n  def safeDiv(m: Nat, n: Succ): (Nat, Nat)\n\n  val Zero: Zero\n\n  val Succ: SuccExtractor\n  trait SuccExtractor:\n    def apply(nat: Nat): Succ\n    def unapply(succ: Succ): Some[Nat]\n\n  given typeTestOfZero: TypeTest[Nat, Zero]\n  given typeTestOfSucc: TypeTest[Nat, Succ]\n```\n\n----------------------------------------\n\nTITLE: Defining Collective Extension Methods with Braces and Type Parameters in Scala\nDESCRIPTION: Alternative syntax using curly braces for collective extensions, supporting multiple methods in the block. Example shows methods to compute smallest n elements and smallest indices in a generic list with an Ordering constraint provided via a using clause on the extension. Demonstrates comprehensive grouping with extensions having multiple methods and context parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nextension (ss: Seq[String]) {\n\n  def longestStrings: Seq[String] = {\n    val maxLength = ss.map(_.length).max\n    ss.filter(_.length == maxLength)\n  }\n\n  def longestString: String = longestStrings.head\n}\n\nextension [T](xs: List[T])(using Ordering[T])\n  def smallest(n: Int): List[T] = xs.sorted.take(n)\n  def smallestIndices(n: Int): List[Int] =\n    val limit = smallest(n).max\n    xs.zipWithIndex.collect { case (x, i) if x <= limit => i }\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Enum in Scala\nDESCRIPTION: Demonstrates the basic syntax for defining an enumeration `Color` with simple cases `Red`, `Green`, and `Blue`. This creates a `sealed` class `Color`, and the cases are members of its companion object.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n```\n\n----------------------------------------\n\nTITLE: Abstract Peano Numbers Definition in Scala\nDESCRIPTION: Defines an abstract `Peano` trait using path-dependent types for `Nat`, `Zero`, and `Succ`. It includes abstract methods and values, and importantly, provides `given` instances for `TypeTest[Nat, Zero]` and `TypeTest[Nat, Succ]` to enable safe pattern matching on these abstract types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.*\n\ntrait Peano:\n  type Nat\n  type Zero <: Nat\n  type Succ <: Nat\n\n  def safeDiv(m: Nat, n: Succ): (Nat, Nat)\n\n  val Zero: Zero\n\n  val Succ: SuccExtractor\n  trait SuccExtractor:\n    def apply(nat: Nat): Succ\n    def unapply(succ: Succ): Some[Nat]\n\n  given typeTestOfZero: TypeTest[Nat, Zero]\n  given typeTestOfSucc: TypeTest[Nat, Succ]\n```\n\n----------------------------------------\n\nTITLE: Example usage of `tabulate`: creating a list of squares with effect handling in Scala 3\nDESCRIPTION: This snippet defines a `LimitExceeded` exception and a `squares` function that generates a lazy list of square numbers from 0 to 9. The generator can throw an exception, illustrating effectful computation and lazy evaluation with effect bounds. The function demonstrates effect polymorphism via `CanThrow`, requiring effect tracking for potential exceptions during list realization.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_31\n\nLANGUAGE: Scala\nCODE:\n```\nclass LimitExceeded extends Exception\n\ndef squares(n: Int)(using ct: CanThrow[LimitExceeded]) =\n  tabulate(10): i =>\n    if i > 9 then throw LimitExceeded()\n    i * i\n```\n\n----------------------------------------\n\nTITLE: Implementing State Machine with Inline Erased Value Matching in Scala\nDESCRIPTION: Shows a purely inline/compile-time implementation of the state machine using 'erasedValue' and inline pattern matching. Requires 'scala.compiletime.*' and defines transitions using transparent inline methods, triggering compile-time errors for invalid state changes. Inputs are captured via type-level matching, and outputs are new machine state instances or compile-time errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.compiletime.*\n\nsealed trait State\nfinal class On extends State\nfinal class Off extends State\n\nclass Machine[S <: State]:\n  transparent inline def turnOn(): Machine[On] =\n    inline erasedValue[S] match\n      case _: Off => new Machine[On]\n      case _: On  => error(\"Turning on an already turned on machine\")\n\n  transparent inline def turnOff(): Machine[Off] =\n    inline erasedValue[S] match\n      case _: On  => new Machine[Off]\n      case _: Off => error(\"Turning off an already turned off machine\")\n\nobject Machine:\n  def newMachine(): Machine[Off] =\n    println(\"newMachine\")\n    new Machine[Off]\nend Machine\n\n@main def test =\n  val m = Machine.newMachine()\n  m.turnOn()\n  m.turnOn().turnOff()\n  m.turnOn().turnOn() // error: Turning on an already turned on machine\n```\n\n----------------------------------------\n\nTITLE: Defining Config type and functions\nDESCRIPTION: Introduces a `Config` trait and example functions `compute` and `show` that depend on `Config`. Demonstrates functions needing access to shared environment/state.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Config\n// ...\n def compute(i: Int)(config: Config): String = ???\n def show(str: String)(config: Config): Unit = ???\n```\n\n----------------------------------------\n\nTITLE: Examples of Legal Scala 3 Type Definitions\nDESCRIPTION: Provides example legal type member definitions illustrating type aliasing and bounded abstract types in Scala 3. These examples also demonstrate desugaring of parameterized types into type lambdas with variance annotations. No external dependencies required besides a Scala 3 compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ntype IntList = List[Integer]\ntype T <: Comparable[T]\ntype Two[A] = Tuple2[A, A] // desugars to Two = [A] =>> Tuple2[A, A]\ntype MyCollection[+X] <: Iterable[X] // desugars to MyCollection <: [+X] =>> Iterable[X]\n```\n\n----------------------------------------\n\nTITLE: State Machine with Erased Evidence and Compile-Time Guarantees in Scala\nDESCRIPTION: Provides a refined state machine example where both evidence and evidence providers are marked as erased to ensure they have no runtime presence. Implements both 'turnedOn' and 'turnedOff' using erased evidence for compile-time state transitions. Requires 'scala.annotation.implicitNotFound' for error messages and properly marked evidence instances. Demonstrates that erased parameters are mandatory for compile-time constraint checking, but are omitted at runtime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.implicitNotFound\n\nsealed trait State\nfinal class On extends State\nfinal class Off extends State\n\n@implicitNotFound(\"State must be Off\")\nclass IsOff[S <: State]\nobject IsOff:\n  // will not be called at runtime for turnedOn, the\n  // compiler will only require that this evidence exists\n  given IsOff[Off] = new IsOff[Off]\n\n@implicitNotFound(\"State must be On\")\nclass IsOn[S <: State]\nobject IsOn:\n  // will not exist at runtime, the compiler will only\n  // require that this evidence exists at compile time\n  erased given IsOn[On] = new IsOn[On]\n\nclass Machine[S <: State] private ():\n  // ev will disappear from both functions\n  def turnedOn(using erased ev: IsOff[S]): Machine[On] = new Machine[On]\n  def turnedOff(using erased ev: IsOn[S]): Machine[Off] = new Machine[Off]\n\nobject Machine:\n  def newMachine(): Machine[Off] = new Machine[Off]\n\n@main def test =\n  val m = Machine.newMachine()\n  m.turnedOn\n  m.turnedOn.turnedOff\n\n  // m.turnedOff\n  //            ^\n  //            State must be On\n\n  // m.turnedOn.turnedOn\n  //                    ^\n  //                    State must be Off\n```\n\n----------------------------------------\n\nTITLE: Core Type and Dominance Relations (Conceptual Summary)\nDESCRIPTION: Defines the concepts of core types, type dominance, and related properties used by the Scala 3 compiler during implicit resolution. Explains how the core type simplifies types for comparison, and how dominance relates to type equivalence, complexity, and the structure of type constructors. The definitions are crucial for divergence detection and implicit search termination.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/07-implicits.md#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Creating Instance - Universal Apply - Scala\nDESCRIPTION: Demonstrates the Scala 3 syntax for creating instances of concrete classes using direct application of the class name, eliminating the need for the `new` keyword. This functionality is enabled by automatically generated `apply` methods in a companion object. The example shows how to instantiate the standard `StringBuilder` class with and without initial arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/creator-applications.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass StringBuilder(s: String):\n  def this() = this(\"\")\n\nStringBuilder(\"abc\")  // old: new StringBuilder(\"abc\")\nStringBuilder()       // old: new StringBuilder()\n```\n\n----------------------------------------\n\nTITLE: Enum Definition Example for Planet in Scala 3\nDESCRIPTION: Defines a parameterized enum 'Planet' where each enum case extends this base with specific parameters for mass and radius. Includes additional private constants and methods calculating gravitational surface characteristics illustrating enum extensibility with methods and fields.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nenum Planet(mass: Double, radius: Double):\n  case Mercury extends Planet(3.303e+23, 2.4397e6)\n  case Venus   extends Planet(4.869e+24, 6.0518e6)\n  case Earth   extends Planet(5.976e+24, 6.37814e6)\n  case Mars    extends Planet(6.421e+23, 3.3972e6)\n  case Jupiter extends Planet(1.9e+27,   7.1492e7)\n  case Saturn  extends Planet(5.688e+26, 6.0268e7)\n  case Uranus  extends Planet(8.686e+25, 2.5559e7)\n  case Neptune extends Planet(1.024e+26, 2.4746e7)\n\n  private inline val G = 6.67300E-11\n  def surfaceGravity = G * mass / (radius * radius)\n  def surfaceWeight(otherMass: Double) = otherMass * surfaceGravity\nend Planet\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Option ADT using Scala 3 Enum\nDESCRIPTION: This snippet shows the simplest way to define an `Option` Algebraic Data Type using a Scala 3 `enum`. It includes a covariant type parameter `T`, a parameterized case `Some(x: T)`, and a non-parameterized case `None`. This syntax is a shorthand for defining a base class and case classes/objects extending it.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/adts.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nenum Option[+T]:\n  case Some(x: T)\n  case None\n```\n\n----------------------------------------\n\nTITLE: Starting REPL with sbt and Scala Shell - Bash\nDESCRIPTION: Provides two approaches for launching the Scala 3 interactive REPL: using the sbt build tool and invoking the 'repl' command inside the sbt console, or directly launching the Scala shell from the terminal. Both require prior compilation and build setup.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/getting-started.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\n> repl\nWelcome to Scala.next (pre-alpha)  (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_101).\nType in expressions to have them evaluated.\nType :help for more information.\nscala>\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ scala\n```\n\n----------------------------------------\n\nTITLE: Using context bounds with combineAll function\nDESCRIPTION: Defines a generic `combineAll` function that combines a list of elements `T` using an implicit `Monoid[T]`, accessed via context bound `[T: Monoid]`. Uses `foldLeft` with the `unit` as initial value to aggregate the list.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef combineAll[T: Monoid](xs: List[T]): T =\n  xs.foldLeft(implicitly[Monoid[T]].unit)(_.combine(_))\n```\n\n----------------------------------------\n\nTITLE: Monad instance for Option type\nDESCRIPTION: Defines a `given` `Monad` for `Option`, implementing `pure` to wrap a value in `Some`, and `flatMap` to apply a function if the option is `Some`, otherwise returning `None`. Uses pattern matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ngiven optionMonad: Monad[Option]:\n  def pure[A](x: A): Option[A] = Option(x)\n  extension [A](xo: Option[A])\n    def flatMap[B](f: A => Option[B]): Option[B] = xo match\n      case Some(x) => f(x)\n      case None => None\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Enum Scala\nDESCRIPTION: Illustrates the basic syntax for defining an enumeration with a set of named values in Scala 3. This creates a sealed class and its case values as members of a companion object.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized Trait in Scala 3\nDESCRIPTION: Defines a Scala 3 trait named `Greeting` that accepts a `val` parameter `name` of type String. It includes a method `msg` that uses this parameter to construct a greeting string.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/trait-parameters.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Greeting(val name: String):\n  def msg = s\"How are you, $name\"\n```\n\n----------------------------------------\n\nTITLE: Defining General Extension Method Syntax in Scala\nDESCRIPTION: Illustrates the various clauses and parameters that can be present in a Scala 3 extension method definition, highlighting optional type clauses, using clauses, explicit parameters (leftParam and rightParam), and trailing parameters. This snippet shows the full possible signature structure before considering associativity.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/right-associative-extension-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n  extension [T]                               // <-- leftTyParams\n            (using a: A, b: B)(using c: C)    // <-- leadingUsing\n            (x: X)                            // <-- leftParam\n            (using d: D)                      // <-- trailingUsing\n    def +:: [U]                               // <-- rightTyParams\n            (y: Y)                            // <-- rightParam\n            (using e: E)(z: Z)                // <-- rest\n```\n\n----------------------------------------\n\nTITLE: Importing Parameterized Givens and Specific Types in Scala 3\nDESCRIPTION: This code imports givens of a parameterized type (such as Ordering[?]) and another type (ExecutionContext) from an object containing a range of given instances. The dependencies are that the instances must be defined in the source object (e.g., Instances). This approach enables importing subsets of contextual instances that match specific type parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/given-imports.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport Instances.{given Ordering[?], given ExecutionContext}\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Structural Given with Named Context Parameter Scala 3\nDESCRIPTION: Similar to the previous example, this defines a structural given for `Ord[List[T]]` parameterized by type `T` and requiring a given `Ord[T]`. This snippet explicitly names the context parameter as `ord` using the `(ord: Ord[T]) =>` syntax, which can improve clarity when the context parameter is used within the given's implementation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/more-givens.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ngiven listOrd: [T] => (ord: Ord[T]) => Ord[List[T]]:\n  ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Java-Compatible Enum in Scala\nDESCRIPTION: Demonstrates the new support for Java-compatible enumerations in Scala. Users can extend `java.lang.Enum` to create enums that can be easily used from Java code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-06-11-16th-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nenum A extends java.lang.Enum[A] {\n  case MONDAY, TUESDAY, SATURDAY\n}\n```\n\n----------------------------------------\n\nTITLE: Desugaring Parameterized Opaque Type Aliases in Scala 3\nDESCRIPTION: Shows how parameterized opaque type aliases are converted to unparameterized opaque type aliases by placing the parameter list as type lambdas on the lower and upper bounds and alias type. The code distinguishes cases where the lower bound conforms to `Nothing` or not and reflects appropriate desugaring. Prerequisites include understanding opaque types and type lambdas.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ntype ´t´[´\\mathit{tps}¬¬´] >: ´L´ <: ´H´ = ´T´\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype ´t´ >: Nothing <: [´\\mathit{tps'}¬¬´] =>> ´H´ = [´\\mathit{tps'}¬¬´] =>> ´T´\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype ´t´ >: [´\\mathit{tps'}¬¬´] =>> ´L´ <: [´\\mathit{tps'}¬¬´] =>> ´H´ = [´\\mathit{tps'}¬¬´] =>> ´T´\n```\n\n----------------------------------------\n\nTITLE: Defining an Implicit Conversion from Int to java.lang.Integer in Scala\nDESCRIPTION: This snippet defines an implicit method that converts values of type Int to java.lang.Integer to enable interoperability with Java APIs requiring java.lang.Integer. It requires importing scala.language.implicitConversions to suppress compiler warnings about implicit conversions. The function takes an Int parameter and returns it cast as java.lang.Integer using asInstanceOf. This allows Scala Int values to be automatically converted when passed to methods expecting java.lang.Integer.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/implicit-conversions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.implicitConversions\nimplicit def int2Integer(x: Int): java.lang.Integer =\n  x.asInstanceOf[java.lang.Integer]\n```\n\n----------------------------------------\n\nTITLE: Example: Implementing Conditional Given for `Show` Typeclass in Scala 3\nDESCRIPTION: Provides a complete example defining a `Show` typeclass trait with an extension method `show`. It then implements `given` instances for `String` and `Int`, and a conditional `given` instance for tuples `(A, B)` using the new experimental `=>` syntax. The main method demonstrates its usage.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\ntrait Show[-A] with\n  def (a: A) show: String\n\ngiven Show[String] = x => x\ngiven Show[Int]    = _.toString\n\ngiven [A,B]: (Show[A], Show[B]) => Show[(A,B)] =\n  (a,b) => s\"(${a.show}, ${b.show})\"\n\n@main def ShowPair =\n  println((1 -> \"one\").show) // (1, \"one\")\n```\n\n----------------------------------------\n\nTITLE: Getting Default Values by Type using erasedValue (Scala)\nDESCRIPTION: This snippet defines a transparent inline function `defaultValue[T]` that uses `scala.compiletime.erasedValue` in an inline match expression. It determines the default value for primitive types (`Byte`, `Char`, `Int`, etc.) based solely on the type `T` provided at compile time, returning `Some(defaultValue)` or `None` if no default is defined.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.erasedValue\n\ntransparent inline def defaultValue[T] =\n  inline erasedValue[T] match\n    case _: Byte    => Some(0: Byte)\n    case _: Char    => Some(0: Char)\n    case _: Short   => Some(0: Short)\n    case _: Int     => Some(0)\n    case _: Long    => Some(0L)\n    case _: Float   => Some(0.0f)\n    case _: Double  => Some(0.0d)\n    case _: Boolean => Some(false)\n    case _: Unit    => Some(())\n    case _          => None\n```\n\n----------------------------------------\n\nTITLE: Defining Case Classes Without Explicit Supertype in Scala\nDESCRIPTION: Defines `case class` types (`UserName`, `Password`) without specifying an explicit supertype. This implies their common superclass is `Object`. This setup is used to demonstrate that the compiler infers the Union Type when the common superclass (`Object`) is considered transparent, as shown in the subsequent REPL example.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/union-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class UserName(name: String)\ncase class Password(hash: Hash)\n\n```\n\n----------------------------------------\n\nTITLE: Class Definitions for TypeComparer Approximation Example (Scala)\nDESCRIPTION: Defines the basic classes `Expr[T]` and `IntList extends Expr[Int]`. These definitions serve as the foundation for explaining how `TypeComparer` approximates types (e.g., treating `IntList` as `Expr[Int]`) during subtype checks relevant to GADT constraint inference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/gadts.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass Expr[T]\nclass IntList extends Expr[Int]\n```\n\n----------------------------------------\n\nTITLE: Defining a GADT for Expressions in Scala\nDESCRIPTION: Defines a classic GADT example, an `enum Expr[T]`, representing typed expressions. It includes cases for Integer literals (`Expr[Int]`), Boolean literals (`Expr[Boolean]`), and conditional expressions (`Expr[T]`), showcasing how type parameters constrain the structure.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/gadts.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nenum Expr[T] {\n  case IntLit(value: Int) extends Expr[Int]\n  case BoolLit(value: Boolean) extends Expr[Boolean]\n  case IfExpr(\n    cond: Expr[Boolean],\n    when: Expr[T],\n    otherwise: Expr[T],\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Translating Multi-Generator For Loop in Scala 3\nDESCRIPTION: Illustrates the recursive translation rule for a Scala 3 `for` loop with multiple enumerators starting with two generators (`for (p <- e; p' <- e'; ...) e''`). The first generator is translated into a `foreach` call on the source expression `e`, recursively processing the remaining enumerators.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nfor (´p´ <- ´e´; ´p'´ <- ´e'; ...´) ´e''´\n\n// is translated to\n\n´e´.foreach { case ´p´ => for (´p'´ <- ´e'; ...´) ´e''´ }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Universal Equality Problem in Scala\nDESCRIPTION: Shows how universal equality can lead to type safety issues during refactoring, where comparing values of incompatible types still typechecks but produces unexpected results.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval x = ... // of type T\nval y = ... // of type S, but should be T\nx == y      // typechecks, will always yield false\n```\n\n----------------------------------------\n\nTITLE: Extension Methods Defined in Class and Companion Object with Given Instances in Scala\nDESCRIPTION: Example where extension methods are defined in companion objects and given instances, allowing their invocation based on implicit scope rules. Illustrates extension method availability through types and givens in the implicit scope, enabling calls like flatten or operator `<` on List types with appropriate type constraints like Ordering.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nclass List[T]:\n  ...\nobject List:\n  ...\n  extension [T](xs: List[List[T]])\n    def flatten: List[T] = xs.foldLeft(List.empty[T])(_ ++ _)\n\n  given [T: Ordering] => Ordering[List[T]]:\n    extension (xs: List[T])\n      def < (ys: List[T]): Boolean = ...\nend List\n\n// extension method available since it is in the implicit scope\n// of List[List[Int]]\nList(List(1, 2), List(3, 4)).flatten\n\n// extension method available since it is in the given Ordering[List[T]],\n// which is itself in the implicit scope of List[Int]\nList(1, 2) < List(3)\n```\n\n----------------------------------------\n\nTITLE: Selective Summoning of Implicits Using summonFrom in Scala\nDESCRIPTION: Shows how to selectively summon implicit instances in a functional style using `scala.compiletime.summonFrom`. The construct takes a pattern matching block that attempts to summon implicits by type or by given instances, returning the corresponding value on the first successful match. This example uses summonFrom to return a TreeSet if an Ordering is available for type T, otherwise a HashSet. It resolves compile-time implicit prioritization without inheritance hierarchies. Requires importing `summonFrom` from scala.compiletime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/compiletime-ops.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.summonFrom\n\ninline def setFor[T]: Set[T] = summonFrom {\n  case ord: Ordering[T] => new TreeSet[T]()(using ord)\n  case _                => new HashSet[T]\n}\n\n// Alternative syntax using given pattern\ninline def setFor[T]: Set[T] = summonFrom {\n  case given Ordering[T] => new TreeSet[T]\n  case _                 => new HashSet[T]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dotty via Homebrew\nDESCRIPTION: Instructions for installing Dotty using the Homebrew package manager, showing both fresh installation and update commands.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-07-06-ninth-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nbrew install lampepfl/brew/dotty\n```\n\n----------------------------------------\n\nTITLE: Using Transparent Inline Match for Recursive Type-Based Computation in Scala 3\nDESCRIPTION: Demonstrates transparent inline matching on an algebraic data type (ADT) representing natural numbers encoded with Church encoding. The method toInt recursively matches on Nat to compute an integer literal, with the final result inferred to have a precise singleton type. This example highlights how transparent inline and inline match enable compile-time computation and type refinement.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ntrait Nat\ncase object Zero extends Nat\ncase class Succ[N <: Nat](n: N) extends Nat\n\ntransparent inline def toInt(n: Nat): Int =\n  inline n match\n    case Zero     => 0\n    case Succ(n1) => toInt(n1) + 1\n\ninline val natTwo = toInt(Succ(Succ(Zero)))\nval intTwo: 2 = natTwo\n```\n\n----------------------------------------\n\nTITLE: Calling Functions with Explicit Context Arguments in Scala\nDESCRIPTION: Demonstrates how to explicitly pass a context argument 'intOrd' to the max function using the 'using' keyword.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nmax(2, 3)(using intOrd)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Indentation with Braces and Parentheses in Scala 3\nDESCRIPTION: This Scala code snippet illustrates the rules for determining the assumed indentation width within multi-line regions enclosed by braces and parentheses. It shows how the indentation of the first token that starts a new line after an opening brace/parenthesis or the indentation of the enclosing region is used, and how indentation changes for nested blocks like function arguments and expressions within parentheses.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n{\n  val x = 4\n  f(x: Int, y =>\n    x * (\n      y + 1\n    ) +\n    (x +\n    x)\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Example of top-level definitions in Scala 3\nDESCRIPTION: Demonstrates new conventions in Scala 3, where definitions like types, vals, defs, and extension methods are declared at the top level within a package, eliminating the need for package objects. This supports a more straightforward file structure and definition scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/dropped-features/package-objects.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage p\n\ntype Labelled[T] = (String, T)\nval a: Labelled[Int] = (\"count\", 1)\ndef b = a._2\n\ncase class C()\n\nextension (x: C) def pair(y: C) = (x, y)\n```\n\n----------------------------------------\n\nTITLE: Extension Method Visibility and Applicability Rules in Scala\nDESCRIPTION: Demonstrates making extension methods visible and applicable in different contexts through inheritance, imports, and given instances. Shows how extensions can be grouped in traits and objects, how extension methods get imported and inherited, and how applicable scope rules enable their use. Requires understanding of Scala 3 implicit and given semantics for proper usage.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntrait IntOps:\n  extension (i: Int) def isZero: Boolean = i == 0\n\n  extension (i: Int) def safeMod(x: Int): Option[Int] =\n    // extension method defined in same scope IntOps\n    if x.isZero then None\n    else Some(i % x)\n\nobject IntOpsEx extends IntOps:\n  extension (i: Int) def safeDiv(x: Int): Option[Int] =\n    // extension method brought into scope via inheritance from IntOps\n    if x.isZero then None\n    else Some(i / x)\n\ntrait SafeDiv:\n  import IntOpsEx.* // brings safeDiv and safeMod into scope\n\n  extension (i: Int) def divide(d: Int): Option[(Int, Int)] =\n    // extension methods imported and thus in scope\n    (i.safeDiv(d), i.safeMod(d)) match\n      case (Some(d), Some(r)) => Some((d, r))\n      case _ => None\n\ngiven ops1: IntOps()  // brings safeMod into scope\n\n1.safeMod(2)\n```\n\n----------------------------------------\n\nTITLE: Implementing Eq.derived using Mirror and Inline Match in Scala\nDESCRIPTION: Implements the `derived` method within the `Eq` companion object as an inline given instance. It uses `Mirror.Of[T]` to introspect the type `T`, `summonAll` to get instances for element types, and an `inline match` to dispatch to `eqSum` for sum types or `eqProduct` for product types at compile time.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.deriving.Mirror\n\ninline given derived[T](using m: Mirror.Of[T]): Eq[T] =\n  val elemInstances = summonAll[m.MirroredElemTypes]           // (1)\n  inline m match                                               // (2)\n    case s: Mirror.SumOf[T]     => eqSum(s, elemInstances)\n    case p: Mirror.ProductOf[T] => eqProduct(p, elemInstances)\n```\n\n----------------------------------------\n\nTITLE: Hybrid Enum Example Combining Fixed Values and Parameterized Case in Scala\nDESCRIPTION: Defines a Color enum with a constructor parameter rgb representing an integer color code. It includes three singleton cases Red, Green, Blue with fixed rgb values and an additional case Mix which takes a parameter mix of type Int, allowing creation of mixed colors. This example shows how enums can simultaneously contain both fixed enum values and cases with parameters, providing flexibility.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/adts.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n  case Mix(mix: Int) extends Color(mix)\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Export Clauses in Scala 3\nDESCRIPTION: Defines several classes (`BitMap`, `InkJet`, `Printer`, `Scanner`) and uses a `Copier` class to showcase `export` clauses. It demonstrates exporting specific members (`scanUnit.scan`) and using wildcard (`*`) and omitting/renaming (`status as _`) selectors to create aliases for members of internal `Printer` and `Scanner` instances, thereby exposing functionality via composition.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass BitMap\nclass InkJet\n\nclass Printer:\n  type PrinterType\n  def print(bits: BitMap): Unit = ???\n  def status: List[String] = ???\n\nclass Scanner:\n  def scan(): BitMap = ???\n  def status: List[String] = ???\n\nclass Copier:\n  private val printUnit = new Printer { type PrinterType = InkJet }\n  private val scanUnit = new Scanner\n\n  export scanUnit.scan\n  export printUnit.{status as _, *}\n\n  def status: List[String] = printUnit.status ++ scanUnit.status\n```\n\n----------------------------------------\n\nTITLE: Defining the Conversion abstract class in Scala 3\nDESCRIPTION: Definition of the Conversion abstract class from the standard library that replaces function types for implicit conversions in Scala 3. This class extends Function1 and is annotated with @java.lang.FunctionalInterface.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-conversions-spec.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\n@java.lang.FunctionalInterface\nabstract class Conversion[-T, +U] extends Function1[T, U]:\n  def apply(x: T): U\n```\n\n----------------------------------------\n\nTITLE: Definition of scala.Conversion abstract class in Scala 3\nDESCRIPTION: This snippet presents the definition of the `Conversion` abstract class in Scala's standard library, illustrating it extends `Function1[T, U]` with an `apply` method, used as the core type for implicit view conversions between types T and U.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/implicit-conversions-spec.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage scala\n@java.lang.FunctionalInterface\nabstract class Conversion[-T, +U] extends Function1[T, U]:\n  def apply(x: T): U\n```\n\n----------------------------------------\n\nTITLE: Example of runtime code generation and evaluation in Scala 3 staging\nDESCRIPTION: This Scala code demonstrates creating a staged function `power3` that calculates a value raised to the third power, evaluated at runtime using `staging.run`. It sets up the staging compiler, constructs an expression representing the function, prints its source form with `show`, and applies the function to an input. This showcases how runtime code synthesis and inspection are performed within the staging framework.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/staging.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.quoted.*\n\n// make available the necessary compiler for runtime code generation\ngiven staging.Compiler = staging.Compiler.make(getClass.getClassLoader)\n\nval power3: Double => Double = staging.run {\n  val stagedPower3: Expr[Double => Double] =\n    '{ (x: Double) => ${ unrolledPowerCode('x, 3) } }\n  println(stagedPower3.show) // Prints \"((x: scala.Double) => x.*(x.*(x)))\"\n  stagedPower3\n}\n\npower3.apply(2.0) // Returns 8.0\n```\n\n----------------------------------------\n\nTITLE: Using Functor Instance with summon in Scala\nDESCRIPTION: Defines a generic test method `assertTransformation` that requires a `Functor` instance for the type constructor `F` using a context bound (`F[_]: Functor`). It explicitly fetches the `Functor` instance using `summon[Functor[F]]` to call its `map` method for the assertion.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef assertTransformation[F[_]: Functor, A, B](expected: F[B], original: F[A], mapping: A => B): Unit =\n  assert(expected == summon[Functor[F]].map(original, mapping))\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Operator Precedence with Singleton Types (Scala)\nDESCRIPTION: This example illustrates that type-level operations defined in `scala.compiletime.ops` respect standard operator precedence rules. The type `1 + 2 * 3` is correctly evaluated by the compiler to the singleton type `7`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.ops.int.*\nval x: 1 + 2 * 3 = 7\n```\n\n----------------------------------------\n\nTITLE: Converting Type-Level Peano Numbers to Integers using constValue (Scala)\nDESCRIPTION: This snippet demonstrates an inline function `toIntC` that uses `scala.compiletime.constValue` to recursively convert a type representing a Peano number (using singleton integer types and `scala.compiletime.ops.int.S` for successor) into its corresponding runtime `Int` value during compilation. The result for type `2` is assigned to `ctwo`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.constValue\nimport scala.compiletime.ops.int.S\n\ntransparent inline def toIntC[N]: Int =\n  inline constValue[N] match\n    case 0        => 0\n    case _: S[n1] => 1 + toIntC[n1]\n\ninline val ctwo = toIntC[2]\n```\n\n----------------------------------------\n\nTITLE: Generating Unrolled Power Calculation Code with Quotes and Splices in Scala\nDESCRIPTION: Defines the `unrolledPowerCode` function which takes an `Expr[Double]` representing a variable `x` and an integer `n`. It recursively constructs and returns an `Expr[Double]` representing the code `x * x * ... * x` (n times) using Scala 3's quote and splice mechanism. Requires an implicit `Quotes` context and the `scala.quoted` import.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.quoted.*\ndef unrolledPowerCode(x: Expr[Double], n: Int)(using Quotes): Expr[Double] =\n  if n == 0 then '{ 1.0 }\n  else if n == 1 then x\n  else '{ $x * ${ unrolledPowerCode(x, n-1) } }\n```\n\n----------------------------------------\n\nTITLE: Inferring complex arguments via context parameters\nDESCRIPTION: Provides examples of functions 'descending' and 'minimum' that rely on context parameters of type 'Ord[T]', demonstrating how to pass compiler-inferred or explicitly provided context instances across multiple functions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/using-clauses.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef descending[T](using asc: Ord[T]): Ord[T] = new Ord[T]:\n  def compare(x: T, y: T) = asc.compare(y, x)\n\ndef minimum[T](xs: List[T])(using Ord[T]) =\n  maximum(xs)(using descending)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nminimum(xs)\nmaximum(xs)(using descending)\nmaximum(xs)(using descending(using listOrd))\nmaximum(xs)(using descending(using listOrd(using intOrd)))\n```\n\n----------------------------------------\n\nTITLE: Optimizing Power Calculation Macro using Expr.unapply (Unlifting) in Scala\nDESCRIPTION: Defines the `powerCode` function which inspects its `Expr[Int]` argument `n` using the `Expr.unapply` extractor (`case Expr(m)`). If `n` is a known constant value at compile time, it's unlifted into `m`, and optimized code is generated using `unrolledPowerCode`. Otherwise, code invoking a runtime `power` function is generated. Requires `scala.quoted.*`, `unrolledPowerCode`, a runtime `power` function, and a `using Quotes` context.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef powerCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] =\n  n match\n    case Expr(m) => // it is a constant: unlift code n='{m} into number m\n      unrolledPowerCode(x, m)\n    case _ => // not known: call power at run-time\n      '{ power($x, $n) }\n```\n\n----------------------------------------\n\nTITLE: Defining a max function with a context parameter using 'using' clause\nDESCRIPTION: Defines a generic max function that uses a context parameter of type Ord[T] to compare elements, enabling the function to work with any ordering. Demonstrates passing the context explicitly or relying on inference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/using-clauses.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef max[T](x: T, y: T)(using ord: Ord[T]): T =\n  if ord.compare(x, y) < 0 then y else x\n```\n\n----------------------------------------\n\nTITLE: Converting Peano Type to Integer Value using erasedValue (Scala)\nDESCRIPTION: Defines a transparent inline function `toIntT` that converts a type `N` representing a Peano number (using `Zero` and `Succ` types) into its corresponding integer value at compile time. It uses `scala.compiletime.erasedValue[N]` within an inline match to inspect the type structure recursively.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// Assuming Nat, Zero, Succ are defined elsewhere\ntrait Nat\nobject Zero extends Nat\ncase class Succ[N <: Nat](n: N) extends Nat\n\ntransparent inline def toIntT[N <: Nat]: Int =\n  inline scala.compiletime.erasedValue[N] match\n    case _: Zero.type => 0\n    case _: Succ[n] => toIntT[n] + 1\n\ninline val two = toIntT[Succ[Succ[Zero.type]]]\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution with Function Values Having Inferred Parameter Types in Scala 3 - Scala\nDESCRIPTION: Illustrates Scala 3's capability to resolve overloaded methods that accept function values with missing parameter types in the first argument list. The overloaded methods differ by the type of the first argument and the corresponding function parameter types. Calls with underspecified function literals (e.g., `_.toUpperCase` and `_ * 2`) are correctly inferred and resolved in Scala 3, which was a limitation in Scala 2. This requires Scala 3's updated overloading rules allowing known types to be used for function values, referencing SLS §6.26.3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/overload-resolution.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Int, f2: Int => Int) = f2(x)\ndef f(x: String, f2: String => String) = f2(x)\nf(\"a\", _.toUpperCase)\nf(2, _ * 2)\n```\n\n----------------------------------------\n\nTITLE: Implementing Implicit Monoids Using Abstract Classes and Objects in Scala\nDESCRIPTION: This code demonstrates how to define an abstract Monoid class extending a SemiGroup, with two concrete implicit object instances for String and Int types. It shows how to create reusable, type-specific operations using implicit objects to enable type inference and automatic injection of required behavior. To use this code, a SemiGroup trait or class must be declared elsewhere in the project; the code works with generic types and expects String and Int to be the operational domains.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/07-implicits.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Monoid[A] extends SemiGroup[A] {\n  def unit: A\n  def add(x: A, y: A): A\n}\nobject Monoids {\n  implicit object stringMonoid extends Monoid[String] {\n    def add(x: String, y: String): String = x.concat(y)\n    def unit: String = \"\"\n  }\n  implicit object intMonoid extends Monoid[Int] {\n    def add(x: Int, y: Int): Int = x + y\n    def unit: Int = 0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using @targetName for Extension Method Alias in Scala\nDESCRIPTION: Shows how to apply the `@targetName` annotation to a Scala extension method (`++=`) to define an alternative name (`append`) for bytecode generation. This facilitates interoperability with other JVM languages, while the original symbolic name (`++=`) remains the only valid identifier for usage within Scala code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/targetName.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.targetName\n\nobject VecOps:\n  extension [T](xs: Vec[T])\n    @targetName(\"append\")\n    def ++= [T] (ys: Vec[T]): Vec[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Overriding Methods with Inline Definitions in Scala\nDESCRIPTION: Illustrates how inline methods (`f`, `g` in class `B`) can implement or override non-inline methods (from abstract class `A`). Both direct invocations on an instance of `B` (which are inlined) and dynamic invocations through a reference of type `A` produce the same results, indicating that inline methods can also support runtime dispatch when overriding.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nabstract class A:\n  def f: Int\n  def g: Int = f\n\nclass B extends A:\n  inline def f = 22\n  override inline def g = f + 11\n\nval b = new B\nval a: A = b\n// inlined invocatons\nassert(b.f == 22)\nassert(b.g == 33)\n// dynamic invocations\nassert(a.f == 22)\nassert(a.g == 33)\n```\n\n----------------------------------------\n\nTITLE: Handling Variance in Scala 3 Enum Cases (View)\nDESCRIPTION: This snippet presents a more complex example demonstrating how to handle variance correctly in parameterized enum cases. It defines a `View` enum with contravariant (`-T`) and covariant (`+U`) type parameters, extending the function type `T => U`. The `Refl` case requires its own non-variant type parameter `R` to correctly type the function `f: R => R`, illustrating how compiler inference works and how explicit type parameter declaration is sometimes necessary to resolve variance issues.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/adts.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nenum View[-T, +U] extends (T => U):\n  case Refl[R](f: R => R) extends View[R, R]\n\n  final def apply(t: T): U = this match\n    case refl: Refl[r] => refl.f(t)\n```\n\n----------------------------------------\n\nTITLE: Defining Type Alias Eq for Reflexive Equality using CanEqual[T, T] in Scala\nDESCRIPTION: This snippet defines a type alias `Eq[-T]` for `CanEqual[T, T]`. This alias simplifies the expression of requiring reflexive equality (i.e., allowing comparison of two instances of the same type `T`). The text notes that this alias is most effective under `-language:strictEquality`, where the universal `CanEqual[Any, Any]` instance is absent, making `Eq[T]` a meaningful constraint for type `T`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\ntype Eq[-T] = CanEqual[T, T]\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Anonymous Function Syntax in Scala\nDESCRIPTION: The syntax for defining an anonymous function using pattern matching case clauses without a prior match keyword. This is a core Scala feature for creating concise function literals.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\n{ case ´p_1´ => ´b_1´ ... case ´p_n´ => ´b_n´ }\n```\n\n----------------------------------------\n\nTITLE: Implementing Monad Instance for Option in Scala\nDESCRIPTION: Provides a `given` instance named `optionMonad` for the `Monad` type class for the `Option` type constructor. `pure` is implemented using `Option(x)`. The `flatMap` extension method uses pattern matching: if the `Option` is `Some(x)`, it applies the function `f`; otherwise, it returns `None`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\ngiven optionMonad: Monad[Option] with\n  def pure[A](x: A): Option[A] =\n    Option(x)\n  extension [A](xo: Option[A])\n    def flatMap[B](f: A => Option[B]): Option[B] = xo match\n      case Some(x) => f(x)\n      case None => None\n```\n\n----------------------------------------\n\nTITLE: Creating a Builder Pattern with Context Functions in Scala\nDESCRIPTION: Example showing the table construction syntax using the builder pattern, demonstrating the intention of the pattern without implementation details.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n  table {\n    row {\n      cell(\"top left\")\n      cell(\"top right\")\n    }\n    row {\n      cell(\"bottom left\")\n      cell(\"bottom right\")\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Redefining Functor Type Class with Extension Method in Scala\nDESCRIPTION: Redefines the `Functor` type class trait using an `extension` method for `map`. This approach allows calling `map` directly on instances of `F[A]` (e.g., `myList.map(f)`), providing a more object-oriented syntax when a `Functor[F]` instance is in scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Functor[F[_]]:\n  extension [A](x: F[A])\n    def map[B](f: A => B): F[B]\n```\n\n----------------------------------------\n\nTITLE: Implementing Builder Pattern Methods with Context Functions\nDESCRIPTION: Definition of table, row, and cell methods using context function types to enable clean syntax without explicit parameter passing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n  def table(init: Table ?=> Unit) =\n    given t: Table = Table()\n    init\n    t\n\n  def row(init: Row ?=> Unit)(using t: Table) =\n     given r: Row = Row()\n     init\n     t.add(r)\n\n  def cell(str: String)(using r: Row) =\n     r.add(new Cell(str))\n```\n\n----------------------------------------\n\nTITLE: Valid Chained Method Calls with Leading Dot and Indentation in Scala 3\nDESCRIPTION: This snippet shows valid usage of non-matching indentation when beginning a line with a dot, which is an exception to strict indentation matching rules. It demonstrates how Scala 3 permits certain stylistic chaining of methods where lines starting with '.' can be less strictly indented if they differ by more than one space. No dependencies are needed, and the snippet assumes the presence of a value 'xs'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nxs.map: x =>\n    x + 1\n  .filter: x =>\n    x > 0\n```\n\n----------------------------------------\n\nTITLE: Explanation of Given Instance Initialization and Syntax\nDESCRIPTION: This snippet details the overall syntax for defining given instances in Scala 3, including optional naming, conditional clauses, and implementation forms (alias or structural). It emphasizes the syntax elements, such as `GivenDef`, `GivenSig`, and `GivenImpl`, and discusses different forms like default, alias, and conditional givens. The rules for on-demand initialization and multiple forms of definition are also summarized.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/givens.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Basic Extractor Pattern Matching in Scala\nDESCRIPTION: Illustrates a pattern match using an extractor (`Y(n)`). A runtime type test is performed on the argument `y` when the extractor's parameter type (`Y`) is not a subtype of the scrutinee type (`X`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n(x: X) match\n  case y @ Y(n) =>\n\nobject Y:\n  def unapply(x: Y): Some[Int] = ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Monoid instance for Int\nDESCRIPTION: Provides a given instance for `Monoid[Int]`, defining addition as the combine operation and zero as the identity. Allows aggregation of integers in a generic manner.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Monoid[Int]:\n  extension (x: Int) def combine(y: Int): Int = x + y\n  def unit: Int = 0\n```\n\n----------------------------------------\n\nTITLE: Swapping 'extends' Syntax with 'with' in Class Declarations\nDESCRIPTION: Highlights the new syntax using 'extends' with commas instead of 'with' for multiple inherited traits or classes, simplifying class declarations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nA extends B, C { ... }\n```\n\n----------------------------------------\n\nTITLE: Extending Traits with Parameters in Scala 3\nDESCRIPTION: Demonstrates the extension of a trait having a constructor parameter 'name'. Shows illegal multiple inheritance passing different parameters and how Scala 3 enforces rules to avoid ambiguity. Includes an example with class 'C' extending 'Greeting' and an illegal class 'D' that attempts multiple extensions with conflicting parameters. The code throws an error due to ambiguous parameter passing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\ntrait Greeting(val name: String):\n  def msg = s\"How are you, $name\"\n\nclass C extends Greeting(\"Bob\")\n\nclass D extends C, Greeting(\"Bill\") // error\n\n@main def greet = println(D().msg)\n```\n\n----------------------------------------\n\nTITLE: Importing Givens By Type in Scala 3\nDESCRIPTION: This example shows how to import only those given instances that conform to a specified type from another object, enhancing import specificity. It assumes that the source object (e.g., A) contains given instances of the type (e.g., TC). Useful when you want selective type-safe control over which givens are available in the current scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/given-imports.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport A.given TC\n```\n\n----------------------------------------\n\nTITLE: Basic Type Ascription Pattern Matching in Scala\nDESCRIPTION: Demonstrates a standard pattern match using explicit type ascription (`: Y`). A runtime class test is performed here if `Y` is a concrete type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n(x: X) match\n  case y: Y =>\n```\n\n----------------------------------------\n\nTITLE: Indentation Misalignment Causing Parsing Error for Else Branch - Scala\nDESCRIPTION: This snippet shows a parsing error caused by the 'else' branch being indented less than expected relative to the preceding 'then' branch's indentation, violating the indentation token alignment rules. The compiler expects the 'else' token to align with a prior indentation level, otherwise an error is raised. It illustrates how optional braces rely on strict indentation matching in conditional statements.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nif x < 0 then\n    -x\n  else   // error: `else` does not align correctly\n    x\n```\n\n----------------------------------------\n\nTITLE: Using Scala Type-Level Arithmetic for Compile-Time Checks\nDESCRIPTION: Demonstrates the new `scala.compiletime.ops.int` package for performing integer arithmetic at the type level in Scala. Shows a valid type assignment (`val x: 2 + 3 = 5`) and an invalid one (`val y: 3 * 4 + 1 = 12`) which results in a compile-time error due to the type mismatch (`13` vs `12`). Useful for verifying calculations or constraints at compile time.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-02-05-22nd-dotty-milestone-release.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.compiletime.ops.int._\n\nval x: 2 + 3 = 5  // OK\nval y: 3 * 4 + 1 = 12  // error\n```\n\n----------------------------------------\n\nTITLE: Imperative Matrix Multiplication Using Arrays in Scala3 - Scala\nDESCRIPTION: Implements matrix multiplication imperatively using nested `while` loops and mutable variables. The code initializes an output array and accumulates products of corresponding elements from input arrays using index-based access and update. It demonstrates typical imperative looping and side-effect usage in Scala arrays.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\ndef matmul(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {\n  val zss: Array[Array[Double]] = new Array(xss.length, yss(0).length)\n  var i = 0\n  while (i < xss.length) {\n    var j = 0\n    while (j < yss(0).length) {\n      var acc = 0.0\n      var k = 0\n      while (k < yss.length) {\n        acc = acc + xss(i)(k) * yss(k)(j)\n        k += 1\n      }\n      zss(i)(j) = acc\n      j += 1\n    }\n    i += 1\n  }\n  zss\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Generic Tuple Operations in Scala 3\nDESCRIPTION: This series of Scala REPL commands demonstrates experimental generic methods on tuples like `head`, `tail`, `*:` (prepend), and `++` (concatenate). It shows creating a heterogeneous tuple, accessing its head and tail, prepending an element, and concatenating tuples. These operations exhibit enhanced type-safe tuple manipulations enabled by Dotty's support for generic tuples.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-10-10-10th-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nscala> val t0 = (1, \"2\", 3L)\nval t0: (Int, String, Long) = (1,2,3)\n\nscala> val head = t0.head\nval head: Int = 1\n\nscala> val tail = t0.tail\nval tail: (String, Long) = (2,3)\n\nscala> val t1 = 0.0 *: t0\nval t1: (Double, Int, String, Long) = (0.0,1,2,3)\n\nscala> val t2 = t0 ++ t0\nval t2: (Int, String, Long, Int, String, Long) = (1,2,3,1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Type Class Derivation with 'derived' Method\nDESCRIPTION: Explains that traits or classes can specify a static 'derived' method to enable type class derivation via the 'derives' clause, reducing boilerplate for common patterns.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ndef derived[T] given Generic[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized Given Instance in Scala 3 - Scala\nDESCRIPTION: Shows how to define a parameterized given instance listOrd for Ord[List[T]] in Scala 3, using a contextual parameter 'ord: Ord[T]'. Requires Ord trait and support for generic contextual abstraction. Takes a context-provided ordering for T and yields an ordering for List[T].\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ngiven listOrd[T](using ord: Ord[T]): Ord[List[T]] with { ... }\n```\n\n----------------------------------------\n\nTITLE: Match Types with Upper Bounds in Scala 3\nDESCRIPTION: Demonstrates how to define a match type with an upper bound, which constrains the resulting type. This example shows a Concat type for tuple concatenation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/match-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntype Concat[Xs <: Tuple, +Ys <: Tuple] <: Tuple = Xs match\n  case EmptyTuple => Ys\n  case x *: xs => x *: Concat[xs, Ys]\n```\n\n----------------------------------------\n\nTITLE: Using Tracked Members for Precise Type Inference\nDESCRIPTION: Demonstrates how the 'tracked' modifier can be used with class members to force the most precise type inference, preserving singleton types for values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/modularity.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntrait F:\n  tracked val a: Int\n  tracked val b: Int\n\nclass N extends F:\n  val a = 22 // a.type =:= 22\n  val b: Int = 22 // b.type =:= Int\n  tracked val c = 22 // c.type =:= 22\n```\n\n----------------------------------------\n\nTITLE: Using the 'Pair' Extractor in a Match Expression (Scala)\nDESCRIPTION: Demonstrates using the custom `Pair` extractor object within a Scala `match` expression. It matches a `Tuple2` instance `x`, deconstructs it into `i` and `s` using `Pair.unapply`, and then uses `Pair.apply` to create a new tuple.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval x = (1, 2)\nval y = x match {\n  case Pair(i, s) => Pair(s + i, i * i)\n}\n```\n\n----------------------------------------\n\nTITLE: Variadic Extractor (unapplySeq) for Sequence Pattern Matching in Scala\nDESCRIPTION: Implements a variadic extractor returning Option[Seq[Char]] to allow deconstructing strings into individual characters during pattern matching. This enables concise expressing of sequence patterns, such as extracting the first four characters from a string. The main dependency is the use of Scala's Option and standard library collection conversions. Input is a string, and output matches on specific character positions; sequence must have the expected minimum length, else falls to default case.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/pattern-matching.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nobject CharList:\n  def unapplySeq(s: String): Option[Seq[Char]] = Some(s.toList)\n\n\"example\" match\n  case CharList(c1, c2, c3, c4, _, _, _) =>\n    println(s\"$c1,$c2,$c3,$c4\")\n  case _ =>\n    println(\"Expected *exactly* 7 characters!\")\n\n// e,x,a,m\n```\n\n----------------------------------------\n\nTITLE: Adding Methods and Companion Object to Option ADT\nDESCRIPTION: This snippet extends the `Option` enum definition to include a method (`isDefined`) and defines an accompanying companion object. The companion object includes an `apply` method that acts as a convenient constructor, demonstrating how enums can have associated logic and factory methods, similar to case classes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/adts.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nenum Option[+T]:\n  case Some(x: T)\n  case None\n\n  def isDefined: Boolean = this match\n    case None => false\n    case _    => true\n\nobject Option:\n\n  def apply[T >: Null](x: T): Option[T] =\n    if x == null then None else Some(x)\n\nend Option\n```\n\n----------------------------------------\n\nTITLE: Renaming and Excluding Imports - Scala\nDESCRIPTION: This example showcases the new 'as' syntax for renaming or excluding imports in Scala 3. It shows how to rename imported members (e.g., 'min as minimum'), exclude members by renaming to '_', and how brace syntax is now optional for single renamings. These features allow for aliasing or hiding specific imports, improving code clarity and controlling namespace collisions. The example is valid only in Scala 3, and the required prerequisite is understanding of imports and object/package structures.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/imports.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport A.{min as minimum, `*` as multiply}\nimport Predef.{augmentString as _, *}     // imports everything except augmentString\nimport scala.annotation as ann\nimport java as j\n```\n\n----------------------------------------\n\nTITLE: Method Chaining on Nullable Java Return Types in Scala 3\nDESCRIPTION: Illustrates how the `UncheckedNull` alias (used internally when handling Java types under `-Yexplicit-nulls`) facilitates safe method chaining on potentially null values returned from Java methods. This avoids the need for verbose nested null checks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval s2: String = someJavaMethod().trim().substring(2).toLowerCase()\n```\n\n----------------------------------------\n\nTITLE: Using Expr.summon for Conditional Implicit Summoning in Scala Macros\nDESCRIPTION: Illustrates the usage of `Expr.summon[Ordering[T]]` inside a macro implementation (`setForExpr`). The macro attempts to summon an `Ordering[T]` implicitly. Based on the result (`Some(ord)` or `None`), it conditionally generates code to create either a `TreeSet[T]` (using the summoned ordering) or a `HashSet[T]`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\ninline def setFor[T]: Set[T] =\n  ${ setForExpr[T] }\n\ndef setForExpr[T: Type]()(using Quotes): Expr[Set[T]] =\n  Expr.summon[Ordering[T]] match\n    case Some(ord) =>\n      '{ new TreeSet[T]()($ord) }\n    case _ =>\n      '{ new HashSet[T] }\n```\n\n----------------------------------------\n\nTITLE: Combining Generic Extensions and Method Type Parameters in Scala\nDESCRIPTION: Illustrates an extension method `sumBy` on a generic type `List[T]` which itself has a type parameter `U` with a context bound (`Numeric[U]`). This allows the method to operate generically based on a function provided by the caller.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nextension [T](xs: List[T])\n  def sumBy[U: Numeric](f: T => U): U = ...\n```\n\n----------------------------------------\n\nTITLE: Using Erased Modifiers for Compile-Time Type Constraints in Scala\nDESCRIPTION: Illustrates the use of the `erased` modifier in Scala 3 to mark parameters as compile-time only and remove them during compilation. The example defines a List class with a flatten method that uses an implicit erased evidence parameter `ev` to constrain the element type, ensuring flatten is only available for nested lists. The erased parameter does not exist in the runtime code, promoting safer and more optimized code generation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-03-05-seventh-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass List[X] {\n  def flatten[Y](implicit erased ev: X <:< List[Y]): List[Y] = {\n    val buffer = new mutable.ListBuffer[Y]\n    this.foreach(e => buffer ++= e.asInstanceOf[List[Y]])\n    buffer.toList\n  }\n}\n\nList(List(1, 2), List(3)).flatten // List(1, 2, 3)\nList(1, 2, 3).flatten             // error: Cannot prove that Int <:< List[Y]\n```\n\n----------------------------------------\n\nTITLE: Defining a Given Instance in Scala 3 - Scala\nDESCRIPTION: Defines a given instance named intOrd for the Ord[Int] type class in Scala 3 using the 'given' keyword and a structural extension. Requires Ord trait and the contextual abstraction features of Scala 3. No parameters are involved; the output is an implicit ordering for Int.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ngiven intOrd: Ord[Int] with { ... }\n```\n\n----------------------------------------\n\nTITLE: Examples of Box Comparison with CanEqual\nDESCRIPTION: Demonstrations of the Box class with derived CanEqual instances, showing which comparisons are allowed (when element types are comparable) and which are rejected.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nnew Box(1) == new Box(1L)   // ok since there is an instance for `CanEqual[Int, Long]`\nnew Box(1) == new Box(\"a\")  // error: can't compare\nnew Box(1) == 1             // error: can't compare\n```\n\n----------------------------------------\n\nTITLE: Defining Arithmetic Term Classes in Scala\nDESCRIPTION: Defines an abstract class hierarchy for arithmetic terms with type parameters. The hierarchy includes literal integers, successor operation, zero check, and conditional expressions, each carrying their result type as a type parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Term[T]\ncase class Lit(x: Int) extends Term[Int]\ncase class Succ(t: Term[Int]) extends Term[Int]\ncase class IsZero(t: Term[Int]) extends Term[Boolean]\ncase class If[T](c: Term[Boolean],\n                 t1: Term[T],\n                 t2: Term[T]) extends Term[T]\n```\n\n----------------------------------------\n\nTITLE: Using Typeable Alias with Context Bound in Scala\nDESCRIPTION: Demonstrates using the `Typeable` alias with a context bound (`[T: Typeable]`). This allows performing a runtime type check (`case x: T`) on an expression of type `Any` within the function body, relying on the implicit `Typeable[T]` instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef f[T: Typeable]: Boolean =\n  \"abc\" match\n    case x: T => true\n    case _ => false\n\nf[String] // true\nf[Int] // false\n```\n\n----------------------------------------\n\nTITLE: Show Anonymous Function Examples - Scala\nDESCRIPTION: This Scala snippet provides several examples of anonymous function syntax. It includes the identity function, curried function composition, a simple summation function, a function with an empty parameter list that modifies external state, and a function that ignores its argument using the wildcard _.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_45\n\nLANGUAGE: scala\nCODE:\n```\nx => x\n```\n\nLANGUAGE: scala\nCODE:\n```\nf => g => x => f(g(x))\n```\n\nLANGUAGE: scala\nCODE:\n```\n(x: Int, y: Int) => x + y\n```\n\nLANGUAGE: scala\nCODE:\n```\n() => { count += 1; count }\n```\n\nLANGUAGE: scala\nCODE:\n```\n_ => 5\n```\n\n----------------------------------------\n\nTITLE: Defining Transparent Inline Given Macro in Scala\nDESCRIPTION: This snippet defines an `inline` and `transparent` given macro named `mkAnnotations`. The macro body `${...}` must produce a value of a subtype of `Annotations[A, T]`. Being `transparent` allows the result type to be the specific subtype produced by the macro, aiding static analysis and optimization.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/givens.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntransparent inline given mkAnnotations[A, T]: Annotations[A, T] = ${\n  // code producing a value of a subtype of Annotations\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Companion Object Methods for Scala 3 Case Classes\nDESCRIPTION: This Scala snippet illustrates the default companion object automatically generated for a case class. It defines the `apply` method to create new instances and the `unapply` method for pattern matching. The snippet explains type and parameter substitutions and conditions for method omission if methods or companion objects already exist. It also covers special cases for empty parameter lists and repeated parameter handling.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nobject ´c´ {\n  def apply[´\\mathit{tps}\\,´](´\\mathit{ps}_1´)...(´\\mathit{ps}_n´): ´c´[´\\mathit{tps}\\,´] = new ´c´[´\\mathit{Ts}\\,´](´\\mathit{xs}_1´)...(´\\mathit{xs}_n´)\n  def unapply[´\\mathit{tps}\\,´](´x´: ´c´[´\\mathit{tps}\\,´]) =\n    if (x eq null) scala.None\n    else scala.Some(´x.\\mathit{xs}_{11}, ... , x.\\mathit{xs}_{1k}´)\n}\n```\n\n----------------------------------------\n\nTITLE: Kind Projector Syntax in Scala 3\nDESCRIPTION: Example of using the kind projector syntax in Scala 3 with the -Ykind-projector flag, showing implementations of the Functor type class for different type constructors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-02-05-22nd-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// Fix #7139: Implement kind-projector compatibility #7775\n// With -Ykind-projector\n\ntrait Functor[F[_]]\n  def map[A, B](fa: F[A], f: A => B): F[B]\n\nobject eitherFunctor extends Functor[Either[Int, *]]\n  def map[A, B](fa: Either[Int, A], f: A => B): Either[Int, B] = fa match\n    case Right(x) => Right(f(x))\n    case Left(x) => Left(x)\n\nobject functionFunctor extends Functor[Int => *]\n  def map[A, B](fa: Int => A, f: A => B): Int => B =\n    fa andThen f\n\nobject tupleFunctor extends Functor[λ[x => (x, x)]]\n  def map[A, B](fa: (A, A), f: A => B): (B, B) = fa match\n    case (a1, a2) => (f(a1), f(a2))\n\n@main def Test =\n  val tpl = (1, 2)\n  val squared = tupleFunctor.map(tpl, a => a * a)\n  println(squared)  // (1,4)\n```\n\n----------------------------------------\n\nTITLE: Representing Existential Type with Wildcards in Scala\nDESCRIPTION: This snippet demonstrates an existential type using wildcards (`_`) which remains supported in Scala 3, unlike `forSome` existential types. The compiler treats this type as a refined type, where the first type parameter is upper-bounded by `AnyRef` and the second is an alias for `Int`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/existential-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nMap[_ <: AnyRef, Int]\n```\n\n----------------------------------------\n\nTITLE: Defining Infix Operators with the `infix` Modifier in Scala 3\nDESCRIPTION: Demonstrates how to define alphanumeric methods as infix operators using the `infix` modifier inside a Scala trait with example usages including normal methods, symbolic operators with @targetName, and mixed invocation styles. It explains that the `infix` modifier enables the method to be used as an infix operator, with a demonstration that symbolic operators do not require `infix` but benefit from @targetName annotations for legibility and interoperability.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/operators.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.targetName\n\ntrait MultiSet[T]:\n\n  infix def union(other: MultiSet[T]): MultiSet[T]\n\n  def difference(other: MultiSet[T]): MultiSet[T]\n\n  @targetName(\"intersection\")\n  def *(other: MultiSet[T]): MultiSet[T]\n\nend MultiSet\n\nval s1, s2: MultiSet[Int]\n\ns1 union s2         // OK\ns1 `union` s2       // also OK but unusual\ns1.union(s2)        // also OK\n\ns1.difference(s2)   // OK\ns1 `difference` s2  // OK\ns1 difference s2    // gives a deprecation warning\n\ns1 * s2             // OK\ns1 `*` s2           // also OK, but unusual\ns1.*(s2)            // also OK, but unusual\n```\n\n----------------------------------------\n\nTITLE: Enforcing Type-Safe Equality with Strict Equality in Scala 3\nDESCRIPTION: This snippet demonstrates Scala 3's strict equality mode via scala.language.strictEquality, which causes compile-time errors when comparing incompatible opaque types. Requires Scala 3 and the import of the strictEquality feature. This prevents accidental comparisons between semantically incompatible units like Meter and Second.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/matchable.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.strictEquality\nMeter(10) == Second(10)\n```\n\n----------------------------------------\n\nTITLE: Selective and Wildcard Imports from Objects - Scala\nDESCRIPTION: The following code illustrates importing specific members with or without wildcards, including importing a member literally named '*'. It defines object 'A' with methods named '*' and 'min', then demonstrates how to import only the '*' method using backticks or all members using the wildcard syntax. These techniques require Scala 3 and are used when you want fine-grained import control for object members.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/imports.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject A:\n  def * = ...\n  def min = ...\n\nobject B:\n  import A.`*`   // imports just `*`\n\nobject C:\n  import A.*     // imports everything in A\n```\n\n----------------------------------------\n\nTITLE: Unary Unapply Method for Case Classes with Empty Parameter List in Scala\nDESCRIPTION: This snippet shows the special `unapply` method signature generated for case classes that contain an empty parameter list. In such cases, `unapply` returns a Boolean indicating non-nullity instead of an `Option` type. This method improves pattern matching semantics for parameterless case classes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\ndef unapply[´\\mathit{tps}\\,´](´x´: ´c´[´\\mathit{tps}\\,´]) = x ne null\n```\n\n----------------------------------------\n\nTITLE: Performing Compile-Time Operations on Singleton Types (Scala)\nDESCRIPTION: This snippet demonstrates using types from the `scala.compiletime.ops` package to perform operations on singleton types at compile time. It shows boolean conjunction (`&&`) and integer multiplication (`*`) where the results (`true` and `15`) are computed by the compiler and become part of the resulting type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.ops.int.*\nimport scala.compiletime.ops.boolean.*\n\nval conjunction: true && true = true\nval multiplication: 3 * 5 = 15\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Scala 3 Union Types in Scala\nDESCRIPTION: Demonstrates defining two case classes UserName and Password, and a method `help` that takes a union type parameter (UserName | Password). Inside the method, pattern matching discriminates the actual type to call specific lookup functions. This snippet illustrates how union types enable writing functions that accept multiple alternative types safely and idiomatically in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/new-types/union-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class UserName(name: String)\ncase class Password(hash: Hash)\n\ndef help(id: UserName | Password) =\n  val user = id match\n    case UserName(name) => lookupName(name)\n    case Password(hash) => lookupPassword(hash)\n  ...\n```\n\n----------------------------------------\n\nTITLE: Running SemanticDB Tests - Scala 3 Compiler - Bash\nDESCRIPTION: This set of bash commands demonstrates how to run the SemanticDB test suite in the Scala 3 compiler using sbt. The process regenerates and verifies expect files for symbol occurrence and metadata tests. Dependencies include semanticdb tooling and the Scala 3 codebase.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\nsbt:scala3> scala3-compiler-bootstrapped/testOnly\n  dotty.tools.dotc.semanticdb.SemanticdbTests\n```\n\n----------------------------------------\n\nTITLE: Identifying Source Incompatibilities with Named Tuples in Scala3\nDESCRIPTION: This segment describes how certain syntax patterns are now interpreted as named tuples rather than traditional assignments or arguments in Scala3. It includes code examples demonstrating these reinterpretations, emphasizing that such constructs may lead to non-idiomatic code or unexpected behavior due to changes in parsing rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/named-tuples.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nvar age: Int\n(age = 1)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass C:\n  infix def f(age: Int)\nval c: C\n```\n\nLANGUAGE: Scala\nCODE:\n```\nc f (age = 1)\n```\n\n----------------------------------------\n\nTITLE: Adding Pair Creation via Implicit Wrapper\nDESCRIPTION: Illustrates an implicit wrapper provided by `Predef` that adds a `->` method to `Any`. This infix method is commonly used to create pairs (2-element tuples), often for constructing Maps or simply grouping two values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\ndef -> [B](y: B): (A, B) = (x, y)\n```\n\n----------------------------------------\n\nTITLE: Defining Transparent vs Non-Transparent Inline Methods in Scala 3\nDESCRIPTION: Shows the syntax and difference between a regular inline method and a transparent inline method in Scala 3. Transparent inline methods influence type checking and must be expanded during that phase, whereas regular inline methods are expanded after typing. Demonstrates how transparent inline methods can affect implicit search behavior with transparent inline givens.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ninline def f1: T = ...\ntransparent inline def f2: T = (...): T\n```\n\n----------------------------------------\n\nTITLE: Disambiguating Overloaded Functions with @targetName (Scala)\nDESCRIPTION: This Scala code demonstrates how using @targetName on one of two functions that would otherwise clash (due to identical erased parameter types) eliminates the naming error. One function (taking a by-name String) is annotated with @targetName(\"f_string\"), while another (taking a by-name Int) is not; the resulting bytecode includes distinct implementation names 'f_string' and 'f'. This approach allows overloading methods with otherwise conflicting erased types, avoiding compile-time errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/targetName.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n@targetName(\"f_string\")\ndef f(x: => String): Int = x.length\ndef f(x: => Int): Int = x + 1  // OK\n```\n\n----------------------------------------\n\nTITLE: Importing TASTy Reflect Extension Methods in Scala Macros - Scala\nDESCRIPTION: This snippet shows the previous method for importing TASTy Reflect features in Scala macros. By importing with 'import qctx.tasty.{ _, given }', it brings extension methods and context instances into scope. The 'qctx' must be in scope as a QuoteContext, and the import is necessary for accessing methods like 'app.fun' and 'app.args' in TASTy trees. The dependencies include the presence of a QuoteContext and an appropriate macro implementation context.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-03-18-23rd-dotty-milestone-release.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n// OLD CODE\nimport qctx.tasty.{ _, given }\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Companion Object for an Enum in Scala\nDESCRIPTION: Shows how to define an explicit companion object `Planet` for the `Planet` enum. This example includes a `main` method that calculates weights on different planets based on user input provided as command-line arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject Planet:\n  def main(args: Array[String]) =\n    val earthWeight = args(0).toDouble\n    val mass = earthWeight / Earth.surfaceGravity\n    for p <- values do\n      println(s\"Your weight on $p is ${p.surfaceWeight(mass)}\")\nend Planet\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala `PartialFunction` Class\nDESCRIPTION: Defines the `scala.PartialFunction` class, a subclass of `Function1`. It represents functions that are not defined for all inputs, using the `isDefinedAt` method to check domain membership. It's used in desugaring pattern matching anonymous functions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass PartialFunction[-A, +B] extends Function1[A, B] {\n  def isDefinedAt(x: A): Boolean\n\n  ... // various derived methods\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Implicit Conversion from String to Token using Scala given\nDESCRIPTION: Demonstrates defining a given instance of scala.Conversion for converting a String to a Token by implementing the apply method that constructs a new KeyWord from the input string. It enables implicit conversion from String to Token where applicable by the compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/conversions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ngiven Conversion[String, Token] with\n  def apply(str: String): Token = new KeyWord(str)\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized Enum in Scala\nDESCRIPTION: Illustrates how to define an enum `Color` with a parameter `rgb` (an `Int`). Each case (`Red`, `Green`, `Blue`) extends the base enum and provides a specific value for the parameter using an `extends` clause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n```\n\n----------------------------------------\n\nTITLE: Creating implicit Ordering for a type using Conversion in Scala\nDESCRIPTION: This example shows how to leverage the Conversion trait to define an Ordering for a custom type, based on existing Orderings for other types. It demonstrates how to convert a custom type A to Int and then use the standard Int ordering to compare A instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-conversions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.implicitConversions\nimplicit def ordT[T, S](\n    implicit conv: Conversion[T, S],\n             ordS: Ordering[S]\n   ): Ordering[T] =\n   // `ordS` compares values of type `S`, but we can convert from `T` to `S`\n  (x: T, y: T) => ordS.compare(x, y)\n\nclass A(val x: Int) // The type for which we want an `Ordering`\n\n// Convert `A` to a type for which an `Ordering` is available:\nimplicit val AToInt: Conversion[A, Int] = _.x\n\nimplicitly[Ordering[Int]] // Ok, exists in the standard library\nimplicitly[Ordering[A]] // Ok, will use the implicit conversion from\n                        // `A` to `Int` and the `Ordering` for `Int`.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Indentation Error in If-Else in Scala\nDESCRIPTION: This Scala snippet shows an improperly indented statement after a brace-delimited block, resulting in a compile-time error. It highlights the enforcement of indentation rules, where statements must not start to the left of the previous indented block after an opening brace. No imports or external dependencies are required. The input involves an 'if' condition and outputs a warning or error due to bad indentation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nif (x < 0) {\n  println(1)\n  println(2)\n\nprintln(\"done\")  // error: indented too far to the left\n```\n\n----------------------------------------\n\nTITLE: Extension Method Resolution via Direct Scope in Scala\nDESCRIPTION: Illustrates Rule 1 for extension method resolution: methods are applicable if visible by simple name through definition, inheritance, or import. The example shows `isZero` used within the defining trait `IntOps`, `safeDiv` used via inheritance in `IntOpsEx`, and both `safeDiv` and `safeMod` used via import in `SafeDiv`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ntrait IntOps:\n  extension (i: Int) def isZero: Boolean = i == 0\n\n  extension (i: Int) def safeMod(x: Int): Option[Int] =\n    // extension method defined in same scope IntOps\n    if x.isZero then None\n    else Some(i % x)\n\nobject IntOpsEx extends IntOps:\n  extension (i: Int) def safeDiv(x: Int): Option[Int] =\n    // extension method brought into scope via inheritance from IntOps\n    if x.isZero then None\n    else Some(i / x)\n\ntrait SafeDiv:\n  import IntOpsEx.* // brings safeDiv and safeMod into scope\n\n  extension (i: Int) def divide(d: Int): Option[(Int, Int)] =\n    // extension methods imported and thus in scope\n    (i.safeDiv(d), i.safeMod(d)) match\n      case (Some(d), Some(r)) => Some((d, r))\n      case _ => None\n```\n\n----------------------------------------\n\nTITLE: Short-Circuiting Flow-Sensitive Typing for Null Checks in Scala 3\nDESCRIPTION: Demonstrates flow-sensitive typing in conjunction with the short-circuiting behavior of the `&&` operator. In the expression `s != null && s.length > 0`, the variable `s` (initially `String|Null`) is refined to `String` for the evaluation of the second part (`s.length > 0`) because the first part (`s != null`) must be true for the second part to be evaluated.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval s: String|Null = ???\n\nif (s != null && s.length > 0) // s: String in `s.length > 0`\n```\n\n----------------------------------------\n\nTITLE: Declaring a Class that Derives CanEqual\nDESCRIPTION: Shows how to declare a class T that derives the CanEqual type class, which will restrict equality comparisons to only allow comparing T with T.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass T derives CanEqual\n```\n\n----------------------------------------\n\nTITLE: Significant Indentation Syntax Example\nDESCRIPTION: Example of significant indentation syntax that allows writing Scala code without braces, relying on indentation for structure.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nenum Day:\n  case Monday, Tuesday, Wednesdey, Thursday, Friday, Saturday, Sunday\n  def isWeekend: Boolean = this match\n    case Saturday | Sunday => true\n    case _ => false\n\ngiven as scala.util.FromString[Day]:\n  def fromString(str: String): Day =\n    try Day.valueOf(str)\n    catch\n      case _: IllegalArgumentException =>\n        throw new IllegalArgumentException(s\"$str is not a valid day\")\n\n@main def test(day: Day) =\n  if day.isWeekend then\n    println(\"Today is a weekend\")\n    println(\"I will rest\")\n  else\n    println(\"Today is a workday\")\n    println(\"I will work\")\n```\n\n----------------------------------------\n\nTITLE: Using Bounded Opaque Permission Types in a User Class in Scala\nDESCRIPTION: Demonstrates defining a 'User' object that employs the Access module's opaque permission types. 'Item' wraps Permissions, with an extension for combining items, and multiple assertions verify correct set operations using the Access API. This code relies on prior Access object definitions and enforces correct use of bounded opaque types and extension methods for permissions management. Expects inputs as permissions constants; outputs are validated via Scala assert statements.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/opaques.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject User:\n  import Access.*\n\n  case class Item(rights: Permissions)\n  extension (item: Item)\n    def +(other: Item): Item = Item(item.rights & other.rights)\n\n  val roItem = Item(Read)  // OK, since Permission <: Permissions\n  val woItem = Item(Write)\n  val rwItem = Item(ReadWrite)\n  val noItem = Item(NoPermission)\n\n  assert(!roItem.rights.is(ReadWrite))\n  assert(roItem.rights.isOneOf(ReadOrWrite))\n\n  assert(rwItem.rights.is(ReadWrite))\n  assert(rwItem.rights.isOneOf(ReadOrWrite))\n\n  assert(!noItem.rights.is(ReadWrite))\n  assert(!noItem.rights.isOneOf(ReadOrWrite))\n\n  assert((roItem + woItem).rights.is(ReadWrite))\nend User\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Delegate Instance in Scala\nDESCRIPTION: Illustrates how to define a generic `delegate` instance, such as for `Ord[List[T]]`. It shows how to include a `given` clause to specify required dependencies (here, an `Ord[T]` instance) for the delegate definition.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-06-11-16th-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndelegate ListOrd[T] for Ord[List[T]] given (ord: Ord[T]) {\n```\n\n----------------------------------------\n\nTITLE: Using Enum Companion Object Utility Methods in Scala\nDESCRIPTION: Demonstrates the usage of utility methods provided by the enum's companion object: `valueOf` to get a case by name, `values` to get an array of all cases, and `fromOrdinal` to get a case by its ordinal index.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> Color.valueOf(\"Blue\")\nval res0: Color = Blue\nscala> Color.values\nval res1: Array[Color] = Array(Red, Green, Blue)\nscala> Color.fromOrdinal(0)\nval res2: Color = Red\n```\n\n----------------------------------------\n\nTITLE: Implementing Peano Numbers with Concrete `TypeTest` Instances in Scala\nDESCRIPTION: Provides a concrete implementation (`PeanoInt`) of the abstract `Peano` trait using `Int` as the underlying type for `Nat`. It defines the `given` `TypeTest` instances (`typeTestOfZero`, `typeTestOfSucc`) required by the trait, implementing their `unapply` methods with appropriate runtime checks based on the integer value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nobject PeanoInt extends Peano:\n  type Nat  = Int\n  type Zero = Int\n  type Succ = Int\n\n  def safeDiv(m: Nat, n: Succ): (Nat, Nat) = (m / n, m % n)\n\n  val Zero: Zero = 0\n\n  val Succ: SuccExtractor = new:\n    def apply(nat: Nat): Succ = nat + 1\n    def unapply(succ: Succ) = Some(succ - 1)\n\n  def typeTestOfZero: TypeTest[Nat, Zero] = new:\n    def unapply(x: Nat): Option[x.type & Zero] =\n      if x == 0 then Some(x) else None\n\n  def typeTestOfSucc: TypeTest[Nat, Succ] = new:\n    def unapply(x: Nat): Option[x.type & Succ] =\n      if x > 0 then Some(x) else None\n```\n\n----------------------------------------\n\nTITLE: Definition of error (Scala)\nDESCRIPTION: Shows the definition of the `scala.compiletime.error` inline method. This method is used within inline methods or macros to generate custom compile-time error messages. The `msg` parameter must be a compile-time constant string.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ninline def error(inline msg: String): Nothing\n```\n\n----------------------------------------\n\nTITLE: Compiler Warning for Non-Exhaustive Match (Without runtimeChecked)\nDESCRIPTION: Shows the exhaustivity warning ([E029]) issued by the Scala 3 compiler when `.runtimeChecked` is *not* used on the `weekDay` match expression from the previous example. The compiler correctly identifies the missing cases (`Some(Sat)`, `Some(Sun)`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/runtimeChecked.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// warning in example 2 when we don't add `.runtimeChecked`.\n-- [E029] Pattern Match Exhaustivity Warning: ----------------------------------\n6 |weekDay match\n  |^^^^^^^\n  |match may not be exhaustive.\n  |\n  |It would fail on pattern case: Some(Sat), Some(Sun)\n```\n\n----------------------------------------\n\nTITLE: Using HOAS Patterns for Lambda Extraction in Scala 3 Quotes\nDESCRIPTION: Demonstrates Higher-Order Abstract Syntax patterns for safely extracting lambda expressions from quoted code without causing variable extrusion issues.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\n'{ ((x: Int) => x + 1).apply(2) } match\n  case '{ ((y: Int) => $f(y): Int).apply($z: Int) } =>\n    // f may contain references to `x` (replaced by `$y`)\n    // f = '{ (y: Int) => $y + 1 }\n    Expr.betaReduce('{ $f($z)}) // generates '{ 2 + 1 }\n```\n\n----------------------------------------\n\nTITLE: Defining the Base Scala `Tuple` Trait and Companion Object\nDESCRIPTION: Defines the base `scala.Tuple` sealed trait, the superclass for all tuples, extending `Product`. It includes the `*:` operator for prepending elements. The companion object `Tuple` provides utility types like `Elem` to access elements by index.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n/** Superclass of all tuples. */\nsealed trait Tuple extends Product:\n  /** Return a new tuple by prepending the element to `this` tuple. */\n  inline def *: [H, This >: this.type <: Tuple] (x: H): H *: This = ...\n  ...\n\nobject Tuple:\n  /** Type of the element at position N in the tuple X. */\n  type Elem[X <: Tuple, N <: Int] = ...\n  ...\n```\n\n----------------------------------------\n\nTITLE: Defining Type Members Using EBNF Syntax\nDESCRIPTION: Specifies the formal grammar rules for defining type members in Scala 3, including abstract type members, type aliases, and opaque type aliases. It outlines how these definitions can include optional type parameter clauses and bounds. Dependencies include understanding EBNF notation and Scala type system basics. Inputs are syntactic forms representing type definitions; outputs are their parseable structures.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_11\n\nLANGUAGE: ebnf\nCODE:\n```\nDcl             ::=  ‘type’ {nl} TypeDcl\nTypeDcl         ::=  id [TypeParamClause] [‘>:’ Type] [‘<:’ Type]\nDef             ::=  ‘type’ {nl} TypeDef\n                  |  ‘opaque‘ ‘type’ {nl} OpaqueTypeDef\nTypeDef         ::=  id [TypeParamClause] ‘=’ Type\n                  |  id [TypeParamClause] ‘<:’ Type ‘=’ MatchType\nOpaqueTypeDef   ::=  id [TypeParamClause] [‘>:’ Type] [‘<:’ Type] ‘=’ Type\n```\n\n----------------------------------------\n\nTITLE: Compiling/Running Staging Code with scalac/scala\nDESCRIPTION: Demonstrates how to compile and run Scala code utilizing runtime staging directly with the `scalac` and `scala` command-line tools. The crucial `-with-compiler` flag must be provided to both commands to include the necessary compiler components at runtime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/staging.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nscalac -with-compiler -d out Test.scala\nscala -with-compiler -classpath out Test\n```\n\n----------------------------------------\n\nTITLE: Defining the ExprMap Trait for Expression Transformation in Scala\nDESCRIPTION: Defines the `ExprMap` trait with abstract `transform` and concrete `transformChildren` methods. This trait provides a foundation for implementing custom transformations on Scala expression trees (`Expr[T]`) within macros, allowing recursive modification of sub-expressions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\ntrait ExprMap:\n  def transform[T](e: Expr[T])(using Type[T])(using Quotes): Expr[T]\n  def transformChildren[T](e: Expr[T])(using Type[T])(using Quotes): Expr[T] =\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala 3 `Type` Abstract Class\nDESCRIPTION: Shows the definition of the abstract class `Type[T <: AnyKind]`, representing quoted types `T` in Scala 3 macros. This class, implemented internally by the compiler, wraps the AST of a type and a `Scope` object. The `AnyKind` upper bound allows representation of higher-kinded types. The `Underlying` type alias provides access to the represented type `T` and is primarily used for internal encoding.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Type[T <: AnyKind] private[scala]:\n  type Underlying = T\n```\n\n----------------------------------------\n\nTITLE: Using Wildcard Arguments with Question Mark Syntax in Scala 3\nDESCRIPTION: Examples demonstrating the new syntax for wildcard arguments in types using question marks (?) instead of underscores (_). Shows simple and bounded wildcard usage in generic types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/wildcards.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nList[?]\nMap[? <: AnyRef, ? >: Null]\n```\n\n----------------------------------------\n\nTITLE: Assignment Operator Expansion in Scala3 - Scala\nDESCRIPTION: Demonstrates how assignment operators ending in '=' (except some exceptions) can be expanded into assignments. For example, `l += r` is reinterpreted as `l = l + r` if the left-hand expression `l` does not define member `+=` and the expanded assignment is type-correct. This allows syntactic sugar for composed assignment operations ensuring `l` is only evaluated once.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\n´l´ = ´l´ + ´r´\n```\n\n----------------------------------------\n\nTITLE: Explicit Usage of `TypeTest` in Scala Pattern Matching\nDESCRIPTION: Demonstrates how an explicitly provided `TypeTest[X, Y]` instance (`tt`) can be used within a pattern match via its `unapply` method (`case tt(x)`). This allows performing type tests on abstract types `X` and `Y`, requiring the `TypeTest` instance as a `using` parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef f[X, Y](x: X)(using tt: TypeTest[X, Y]): Option[Y] = x match\n  case tt(x @ Y(1)) => Some(x)\n  case tt(x) => Some(x)\n  case _ => None\n```\n\n----------------------------------------\n\nTITLE: Example Scala 3 Try-Catch with Pattern Matching Handler\nDESCRIPTION: Illustrates the common structure of a `catch` handler in Scala 3 using a pattern matching anonymous function. This allows handling different types of exceptions (`p_1`, ..., `p_n`) with specific logic (`b_1`, ..., `b_n`) within separate `case` clauses.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_42\n\nLANGUAGE: scala\nCODE:\n```\n{ case ´p_1´ => ´b_1´ ... case ´p_n´ => ´b_n´ }\n```\n\n----------------------------------------\n\nTITLE: Defining an Opaque Immutable Array Type with Scala 3\nDESCRIPTION: Defines an opaque type alias IArray representing immutable arrays backed by mutable Array types. It exposes extension methods for length and apply but not update, aiming to provide immutability at the type level. The opaque type hides the mutable implementation but pattern matching can bypass this.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/matchable.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nopaque type IArray[+T] = Array[? <: T]\n```\n\n----------------------------------------\n\nTITLE: Defining a Method with 'into' Modifier on Curried Parameter - Scala\nDESCRIPTION: Shows a method definition with the 'into' modifier applied to a parameter in a curried (multiple parameter lists) method. The method expects an Int and then a value convertible to Text, enabling implicit conversion for the second argument only. Input is an Int and a convertible value for Text; output is Unit.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Int)(y: into Text): Unit\n```\n\n----------------------------------------\n\nTITLE: Current versus new desugaring for yielding last generator in Scala\nDESCRIPTION: This snippet displays the difference between the current and improved compiler desugaring for for-comprehensions that yield the last generator variable. The new approach eliminates a redundant map call if the comprehension returns the variable unmodified, resulting in more efficient code. No additional dependencies are required; this applies to standard Scala collections and for-comprehension syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/preview/better-fors.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  a <- List(1, 2, 3)\n} yield a\n```\n\nLANGUAGE: Scala\nCODE:\n```\nList(1, 2, 3).map(a => a)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nList(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Implementing Matrix Multiplication using Scala 3 For Comprehensions\nDESCRIPTION: Defines a Scala 3 function `matmul` for matrix multiplication using `Array[Array[Double]]`. It first transposes the second matrix (`yss`) using the `transpose` function. Then, nested `for` comprehensions iterate through the rows of the first matrix (`xs`) and the rows of the transposed second matrix (`yst`), calculating the scalar product for each pair using `scalprod`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\ndef matmul(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {\n  val ysst = transpose(yss)\n  for (xs <- xss) yield\n    for (yst <- ysst) yield\n      scalprod(xs, yst)\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Control Syntax Rules and Patterns\nDESCRIPTION: Details the specific rules for omitting parentheses and braces in Scala 3 control expressions. Explains syntax flexibility for if, while, for, and catch blocks, including conditions and enumerator expressions, and notes the syntax's impact on code clarity.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/control-syntax.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Simulating Parameterless Given Instance with Scala 2 Implicit Object\nDESCRIPTION: Defines an implicit object `intOrd` extending `Ord[Int]`. This is the Scala 2 equivalent of a parameterless Scala 3 given instance, used for providing an implicit value or capability.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit object intOrd extends Ord[Int] { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining Type Class Similarity with Infix Methods\nDESCRIPTION: This snippet illustrates defining a type class `Semigroup` with an infix extension method `combine`. It shows implicit instances for `Int` and `List[T]`, enabling syntax like `x.combine(y)` for combining values within the implicit scope. This simplifies the pattern of encoding type classes in Dotty.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-01-21-12th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Semigroup[T] {\n  def (x: T) combine (y: T): T\n}\nimplicit val IntSemigroup: Semigroup[Int] = new {\n   def (x: Int) combine (y: Int): Int = x + y\n}\nimplicit def ListSemigroup[T]: Semigroup[List[T]] = new {\n   def (x: List[T]) combine (y: List[T]): List[T] = x ::: y\n}\n1.combine(2) // == 3\nList(1,2).combine(List(3,4)) // == List(1,2,3,4)\n```\n\n----------------------------------------\n\nTITLE: Declaring Non-Nullable Types in Scala with Explicit Nulls\nDESCRIPTION: Demonstrates that with the `-Yexplicit-nulls` flag enabled, assigning `null` to a standard reference type like `String` results in a compile-time error because reference types are non-nullable by default.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval x: String = null // error: found `Null`, but required `String`\n```\n\n----------------------------------------\n\nTITLE: Mechanism of deriving type class instances for parameterized types in Scala 3\nDESCRIPTION: This conceptual code explains the pattern for deriving instances where the type class 'TC' takes a type constructor parameter, and the data type 'DerivingType' has type parameters. It shows the general shape of the derived given, emphasizing the use of type bounds and the 'derived' method to produce type class instances for complex types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ngiven [...] => TC[DerivingType[T_1, ..., T_N]] = TC.derived\n```\n\n----------------------------------------\n\nTITLE: Definition of the CanEqual Type Class\nDESCRIPTION: Shows the core implementation of the CanEqual trait and its companion object from the Scala standard library, including the 'derived' object that serves as a base instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\nimport annotation.implicitNotFound\n\n@implicitNotFound(\"Values of types ${L} and ${R} cannot be compared with == or !=\")\nsealed trait CanEqual[-L, -R]\n\nobject CanEqual:\n  object derived extends CanEqual[Any, Any]\n```\n\n----------------------------------------\n\nTITLE: Scala 3 project creation command with staging enabled\nDESCRIPTION: This shell command initializes a new Scala 3 project configured for staging by using the provided sbt template `scala/scala3-staging.g8`. It ensures all dependencies are set up correctly and that the project is prepared for multi-stage programming with subsequent project build instructions. Dependencies should include `org.scala-lang %% scala3-staging` for code staging features.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/staging.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nsbt new scala/scala3-staging.g8\n```\n\n----------------------------------------\n\nTITLE: Conditional Expression Syntax and Semantics in Scala3 - EBNF\nDESCRIPTION: Specifies the syntax for conditional 'if-else' expressions allowing both classic `if (expr) expr else expr` and new `if expr then expr else expr` forms. Describes type expectations for condition and branches, evaluation strategy, harmonization of branch types, and role of optional else branch with default unit value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_27\n\nLANGUAGE: ebnf\nCODE:\n```\nExpr1          ::=  ‘if’ ‘(’ Expr ‘)’ {nl} Expr [[semi] ‘else’ Expr]\n                 |  ‘if‘ Expr ‘then‘ Expr [[semi] ‘else‘ Expr]\n```\n\n----------------------------------------\n\nTITLE: Experimental Signatures and Parameters in Scala 3\nDESCRIPTION: Explains that the signatures of experimental defs, vals, vars, givens, and types—as well as parameters in constructors—are themselves experimental scopes. Passing experimental classes or types as parameters to non-experimental functions or constructors results in errors. Declaring the parameters and enclosing method or class as experimental allows references.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/experimental-defs.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.experimental\n\n@experimental def x = 2\n@experimental class A\n@experimental type X\n@experimental type Y = Int\n@experimental opaque type Z = Int\n\ndef test1(\n  p1: A, // error: class A is marked @experimental and therefore ...\n  p2: List[A], // error: class A is marked @experimental and therefore ...\n  p3: X, // error: type X is marked @experimental and therefore ...\n  p4: Y, // error: type Y is marked @experimental and therefore ...\n  p5: Z, // error: type Z is marked @experimental and therefore ...\n  p6: Any = x // error: def x is marked @experimental and therefore ...\n): A = ??? // error: class A is marked @experimental and therefore ...\n\n@experimental def test2(\n  p1: A,\n  p2: List[A],\n  p3: X,\n  p4: Y,\n  p5: Z,\n  p6: Any = x\n): A = ???\n\nclass Test1(\n  p1: A, // error\n  p2: List[A], // error\n  p3: X, // error\n  p4: Y, // error\n  p5: Z, // error\n  p6: Any = x // error\n) {}\n\n@experimental class Test2(\n  p1: A,\n  p2: List[A],\n  p3: X,\n  p4: Y,\n  p5: Z,\n  p6: Any = x\n) {}\n\ntrait Test1(\n  p1: A, // error\n  p2: List[A], // error\n  p3: X, // error\n  p4: Y, // error\n  p5: Z, // error\n  p6: Any = x // error\n) {}\n\n@experimental trait Test2(\n  p1: A,\n  p2: List[A],\n  p3: X,\n  p4: Y,\n  p5: Z,\n  p6: Any = x\n) {}\n```\n\n----------------------------------------\n\nTITLE: Java Interoperability: Basic Type Patching\nDESCRIPTION: Illustrates how the Scala compiler patches types from Java classes when explicit nulls are enabled. Java reference types (`String`) become nullable union types (`String | Null`) in Scala, while Java primitive types (`int`) remain unchanged (`Int`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_6\n\nLANGUAGE: java\nCODE:\n```\n// Java definition\nclass C {\n  String s;\n  int x;\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Equivalent Scala signature with explicit nulls\nclass C:\n  val s: String | Null\n  val x: Int\n```\n\n----------------------------------------\n\nTITLE: Defining LzyList Trait with Capture Annotations in Scala\nDESCRIPTION: Base trait for lazy lists where only the tail part is lazy, using capture annotation on the tail method to indicate it may capture the same references as the list itself.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\ntrait LzyList[+A]:\n  def isEmpty: Boolean\n  def head: A\n  def tail: {this} LzyList[A]\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Scala 3 Preview Feature\nDESCRIPTION: This snippet demonstrates how to define a feature as a preview feature using the `@preview` annotation within a compilation unit enabled with the `-preview` flag. It also shows how a non-preview definition within the same unit can use the preview feature, illustrating the non-viral nature of calling such definitions from other scopes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/preview-defs.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n//> using options -preview\npackage scala.stdlib\nimport scala.annotation.internal.preview\n\n@preview def previewFeature: Unit = ()\n\n// Can be used in non-preview scope\ndef usePreviewFeature = previewFeature\n```\n\n----------------------------------------\n\nTITLE: Implement kind polymorphism using a specialized type parameter\nDESCRIPTION: This snippet showcases defining functions with type parameters that can accept multiple kinds via the special supertype 'AnyKind'. It enables writing generic functions adaptable to various type constructors like 'Int', 'List', or 'Map', supporting experimental kind polymorphism with the compiler flag '-Ykind-polymorphism'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-04-27-eighth-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef f[T <: AnyKind] = ..\n```\n\nLANGUAGE: Scala\nCODE:\n```\nf[Int]\nf[List]\nf[Map]\nf[[X] =>> String]\n```\n\n----------------------------------------\n\nTITLE: Defining a Polymorphic Function Type in Scala\nDESCRIPTION: Shows the syntax for defining polymorphic function types (PFTs). The syntax `[T] => FunctionType` allows functions to be universally quantified over a type parameter locally, enabling more expressive type definitions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-06-11-16th-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n[T <: AnyVal] => List[T] => List[(T, T)]\n```\n\n----------------------------------------\n\nTITLE: Declaring Erased Definitions and Parameters in Scala\nDESCRIPTION: Illustrates the syntax for applying the `erased` soft modifier to various definitions in Scala 3, including vals, defs, method parameters, function literals, function types, and class definitions. This modifier indicates that the marked element will be removed during compilation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs-spec.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nerased val x = ...\nerased def f = ...\n\ndef g(erased x: Int) = ...\n\n(erased x: Int, y: Int) => ...\ndef h(x: (Int, erased Int) => Int) = ...\n\nclass K(erased x: Int) { ... }\nerased class E {}\n```\n\n----------------------------------------\n\nTITLE: Simple State Machine with Compile-time State Validation in Scala\nDESCRIPTION: Demonstrates a state machine implementation with compile-time state validation using context parameters, showing the motivation for erased definitions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait State\nfinal class On extends State\nfinal class Off extends State\n\n@implicitNotFound(\"State must be Off\")\nclass IsOff[S <: State]\nobject IsOff:\n  given isOff: IsOff[Off] = new IsOff[Off]\n\nclass Machine[S <: State]:\n  def turnedOn(using IsOff[S]): Machine[On] = new Machine[On]\n\nval m = new Machine[Off]\nm.turnedOn\nm.turnedOn.turnedOn // ERROR\n//                 ^\n//                  State must be Off\n```\n\n----------------------------------------\n\nTITLE: Extending a Parameterized Trait with Another Trait in Scala 3\nDESCRIPTION: Shows how a trait `FormalGreeting` extends the parameterized trait `Greeting`. When a trait extends another parameterized trait, it must *not* pass arguments. This trait overrides the `msg` method to provide a different greeting format.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/trait-parameters.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait FormalGreeting extends Greeting:\n  override def msg = s\"How do you do, $name\"\n```\n\n----------------------------------------\n\nTITLE: Testing a Macro that Displays Syntax Tree Information - Scala\nDESCRIPTION: This snippet presents a test application for the 'showTree' macro in Scala. It defines a local function 'f' that squares an integer, creates a value 'x', and prints the macro's output when applied to 'f(x)'. No additional dependencies are required beyond those for the macro definition; input is hardcoded. Output is sent to standard output, demonstrating the macro's reflection capabilities in a main method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-03-18-23rd-dotty-milestone-release.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n@main def Test =\n  def f(x: Int) = x * x\n  val x = 10\n  println(showTree(f(x)))\n```\n\n----------------------------------------\n\nTITLE: Using Clauses in Function Parameters in Scala 3 - Scala\nDESCRIPTION: Defines a generic max function in Scala 3 using a using clause to supply an ordering for type T contextually. Requires Ord type class and Scala 3's contextual parameter feature. Accepts two Ts and a contextual Ord[T]; returns the larger of the two.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef max[T](x: T, y: T)(using ord: Ord[T]): T\n```\n\n----------------------------------------\n\nTITLE: Desugaring Structural Instance Creation: Explicit Parent and Anonymous Class in Scala\nDESCRIPTION: This snippet shows the first-level desugaring of a structural instance creation in Scala. Here, the new object is explicitly an instance of 'AnyRef' augmented with a new method. No special dependencies are needed. The output is functionally identical to the previous snippet, further clarifying how the structural type instance is implemented.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nnew AnyRef{ def getName() = \"aaron\" }\n```\n\n----------------------------------------\n\nTITLE: Relaxed Override Checks for Java Methods in Scala\nDESCRIPTION: Illustrates the flexibility allowed when a Scala class overrides a Java method (e.g., `String f(String x)`) with explicit nulls enabled. Scala methods can choose to accept/return nullable (`String | Null`) or non-nullable (`String`) types in various combinations, allowing for gradual adoption or stricter contracts, though some combinations might introduce runtime unsoundness if not handled carefully.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\n// Overriding Java's 'String f(String x)'\n\ndef f(x: String | Null): String | Null // Most direct translation\n\ndef f(x: String): String | Null // Stricter input, nullable output\n\ndef f(x: String | Null): String // Nullable input, stricter output (potentially unsound)\n\ndef f(x: String): String // Stricter input and output (potentially unsound)\n```\n\n----------------------------------------\n\nTITLE: Creating a Binary Type Constructor with Type Lambda in Scala\nDESCRIPTION: Demonstrates how to define a binary type constructor using a type lambda that takes type parameters X and Y and maps them to Map[Y, X], effectively reversing the order of type parameters in the resulting Map type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n[X, Y] =>> Map[Y, X]\n```\n\n----------------------------------------\n\nTITLE: Defining Enums with Simplified Syntax in Scala\nDESCRIPTION: Demonstrates how to define Algebraic Data Types (ADTs) using the revised enum syntax in Scala 3 (Dotty). It contrasts the earlier complex enum class and companion object syntax with the simplified enum case-based approach, which treats enum cases as class constructors and allows methods on the enum itself. The example models an Option type with Some and None cases and an isDefined method implemented via pattern matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-03-05-seventh-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nenum class Option[+T] {\n   def isDefined: Boolean\n}\n\nobject Option {\n  case Some[+T](x: T) {\n     def isDefined = true\n  }\n  case None {\n     def isDefined = false\n  }\n\n  def apply[T](x: T): Option[T] = if (x == null) None else Some(x)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nenum Option[+T] {\n  case Some(x: T)\n  case None\n\n  def isDefined: Boolean = this match {\n    case None => false\n    case Some(_) => true\n  }\n}\n\nobject Option {\n  def apply[T](x: T): Option[T] = if (x == null) None else Some(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Class with class context parameter as a member\nDESCRIPTION: Defines classes with class-level context parameters, where specifying a 'given' member can cause ambiguity unless handled properly. Demonstrates how class parameters can be made available as 'given' instances and imported for use.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/using-clauses.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass GivenIntBox(using val givenInt: Int):\n  def n = summon[Int]\n\nclass GivenIntBox2(using givenInt: Int):\n  given Int = givenInt\n  //def n = summon[Int]     // ambiguous\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval b = GivenIntBox(using 23)\nimport b.given\nsummon[Int]  // 23\n\nimport b.*\n//givenInt   // Not found\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Multiple Healed Types to Type Holes\nDESCRIPTION: Illustrates the transformation process for multiple healed type aliases within a quote. Each healed type is replaced by an indexed type hole (`<< idx; ... >>`) to capture the necessary information for unpickling.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\n'{ type T1 = t1.Underlying; type Tn = tn.Underlying; ... }\n// with holes\n'{ type T1 = << 0; ... >>; type Tn = << n-1; ... >>; ... }\n```\n\n----------------------------------------\n\nTITLE: Implementing Monad Instance for ConfigDependent Type in Scala\nDESCRIPTION: Provides a `given` instance `configDependentMonad` implementing `Monad` for the `ConfigDependent` type alias (which represents `Config => Result`). `pure(x)` returns a function that ignores the config and yields `x`. `flatMap` implements function composition, threading the `config` through both the initial function `x` and the subsequent function produced by `f`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\ngiven configDependentMonad: Monad[ConfigDependent] with\n\n  def pure[A](x: A): ConfigDependent[A] =\n    config => x\n\n  extension [A](x: ConfigDependent[A])\n    def flatMap[B](f: A => ConfigDependent[B]): ConfigDependent[B] =\n      config => f(x(config))(config)\n\nend configDependentMonad\n```\n\n----------------------------------------\n\nTITLE: Experimental Overriding Rules in Scala 3\nDESCRIPTION: Explains the rule that overriding members must be experimental if the original member is experimental, and must be non-experimental if the original is non-experimental. This prevents binary incompatibilities caused by accidental introduction of experimental features in overrides. Illustrated via a diff snippet.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/experimental-defs.md#_snippet_9\n\nLANGUAGE: diff\nCODE:\n```\nclass A:\n  def f: Any = 1\nclass B extends A:\n-  @experimental def f: Int = 2\n```\n\n----------------------------------------\n\nTITLE: Applying Type Annotations in Scala - Suspendable Annotation Example\nDESCRIPTION: This Scala snippet demonstrates annotating a type with '@suspendable', adding metadata to influence downstream compilation or macro processing. The feature requires defining or importing the relevant annotation class ('@suspendable') in scope. No special inputs or outputs beyond standard type declarations and annotation resolution.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nString @suspendable\n```\n\n----------------------------------------\n\nTITLE: Simulating Parameterized Given Instance with Scala 2 Implicit Class (Part 1)\nDESCRIPTION: Defines a class `listOrd` in Scala 2 that takes an implicit parameter `ord: Ord[T]`. This class is the first part of simulating parameterized Scala 3 given instances using Scala 2's implicit mechanisms.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass listOrd[T](implicit ord: Ord[T]) extends Ord[List[T]] { ... }\n```\n\n----------------------------------------\n\nTITLE: Creating Multi-Line String Literal in Scala\nDESCRIPTION: Demonstrates the basic syntax for creating a multi-line string literal in Scala using triple quotes (\"\"\"). Newlines and indentation within the quotes are preserved in the resulting string. Standard escape sequences are generally not processed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\n\"\"\"the present string\nspans three\nlines.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Enum Utility Methods Scala (REPL)\nDESCRIPTION: Shows how to use the utility methods provided on the enum's companion object in the Scala REPL: `valueOf` to get a case by name, `values` to get all cases, and `fromOrdinal` to get a case by its integer ordinal.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nscala> Color.valueOf(\"Blue\")\nval res0: Color = Blue\nscala> Color.values\nval res1: Array[Color] = Array(Red, Green, Blue)\nscala> Color.fromOrdinal(0)\nval res2: Color = Red\n```\n\n----------------------------------------\n\nTITLE: Explicit Extends Clauses for Option Enum Cases in Scala\nDESCRIPTION: Shows an explicit form of the previous Option enum, adding extends clauses to its cases. Some explicitly extends Option[T], while None extends Option[Nothing] to indicate its bottom type parent. This clarifies variance handling and how the parent type of enum cases is inferred or specified to satisfy type constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/adts.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nenum Option[+T]:\n  case Some(x: T) extends Option[T]\n  case None       extends Option[Nothing]\n```\n\n----------------------------------------\n\nTITLE: Using Given Clauses to Define Inferable Parameters\nDESCRIPTION: Examples of functions using 'given' for implied parameters emphasize the new syntax for context-dependent functions. The 'max' function showcases how 'given' makes implicit parameters explicit, enabling flexible invocation syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef max[T](x: T, y: T) given (ord: Ord[T]): T = ...\n\nmax(2, 3) given IntOrd\nmax(List(1, 2, 3), Nil)\nmax(2, 3)\n```\n\n----------------------------------------\n\nTITLE: Specializing Types Inside Logical Conditions - Scala\nDESCRIPTION: This snippet exhibits type specialization in logical conditionals, showing that within short-circuiting conditions, Scala 3 treats variables as non-null in sub-expressions following null checks. It highlights nuanced flow typing, helping developers write concise and type-safe null-handling code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nval s: String | Null = ???\n\nif s != null && s.length > 0 then // s: String in `s.length > 0`\n  // s: String\n\nif s == null || s.length > 0 then // s: String in `s.length > 0`\n  // s: String | Null\nelse\n  // s: String\n\n```\n\n----------------------------------------\n\nTITLE: Creating Alias Givens for Shared Instances\nDESCRIPTION: This snippet demonstrates alias givens where a given instance is defined as an alias for a specific expression, such as a singleton `ForkJoinPool` for an `ExecutionContext`. The alias is initialized once, thread-safely, on first access, and subsequent uses share the same instance. Alias givens can also be unnamed, thus simplifying reuse and ensuring consistent shared resources.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/givens.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ngiven global: ExecutionContext = ForkJoinPool()\n\n// Example of an anonymous alias given\ngiven Position = enclosingTree.position\n```\n\n----------------------------------------\n\nTITLE: Assigning a Method Reference as a Function Value in Scala\nDESCRIPTION: This snippet demonstrates how the Scala 3 compiler automatically eta-expands a method reference when assigning it to a val. The method 'm' takes two parameters of type Int and String. When assigned to 'f', the method is automatically converted into a function of the appropriate arity. No additional syntax or type ascription is needed in Scala 3. Dependencies: None beyond standard Scala. Parameters: 'x' (Int), 'y' (String). Returns: the result of the method. Limitations: '???' throws NotImplementedError at runtime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/eta-expansion-spec.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef m(x: Int, y: String) = ???\nval f = m // becomes: val f = (x: Int, y: String) => m(x, y)\n```\n\n----------------------------------------\n\nTITLE: Using `as` for Pattern Bindings in Scala 3 - Scala\nDESCRIPTION: Demonstrates the new syntax in Scala 3.0.0-M1 to replace the `@` symbol with `as` in pattern bindings within match expressions. This change improves readability and will become the preferred syntax from Scala 3.1.0 onward. The snippet shows the difference between the older `y @ Bar(z)` and the newer `y as Bar(z)` pattern matching syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-11-09-scala3-m1.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nx match {\n  case Foo(y @ Bar(z)) => println(y)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nx match {\n  case Foo(y as Bar(z)) => println(y)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Extension Methods in Scala\nDESCRIPTION: Demonstrates defining extension methods for generic types. It shows adding a `second` method to `List[T]` and a generic `+` operator for any type `T` that has a `Numeric` type class instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nextension [T](xs: List[T])\n  def second = xs.tail.head\n\nextension [T: Numeric](x: T)\n  def + (y: T): T = summon[Numeric[T]].plus(x, y)\n```\n\n----------------------------------------\n\nTITLE: Relationship Between `inline` and `@inline` Annotation\nDESCRIPTION: Explanation of the difference between the `inline` modifier and the `@inline` annotation, emphasizing that `inline` guarantees expansion at compile time and supports recursive and inline arguments, whereas `@inline` is only a compiled backend hint without guarantees.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Extending an Open Class in Scala\nDESCRIPTION: Defines `EncryptedWriter`, a class extending the `open` class `Writer` in Scala. It demonstrates overriding the `send` method to add encryption logic before calling the parent's `send` method, showing how to utilize the extension contract.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/open-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// File EncryptedWriter.scala\npackage p\n\nclass EncryptedWriter[T: Encryptable] extends Writer[T]:\n  override def send(x: T) = super.send(encrypt(x))\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Type Alias Expansion Using Type Members in Scala\nDESCRIPTION: Illustrates how simple polymorphic type aliases are expanded into monomorphic aliases by converting type parameters into type members on the right-hand side, maintaining the order and relation between parameters. Limitations include cases where type parameters don't correspond to members on the RHS type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntype Pair[T] = Tuple2[T, T]\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Tuple2[T1, T2] ...\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype Pair = Tuple2 { type Tuple2$T2 = Tuple2$T1 }\n```\n\n----------------------------------------\n\nTITLE: Using Transparent Inline Methods for Precise Return Types in Scala\nDESCRIPTION: Introduces `transparent inline` methods. The `choose` method returns type `A`, but because it's `transparent`, the compiler refines the static type of the call based on the actual branch taken during inlining. `choose(true)` has static type `A`, while `choose(false)` has static type `B`, allowing `obj2.m` to compile.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nclass A\nclass B extends A:\n  def m = true\n\ntransparent inline def choose(b: Boolean): A =\n  if b then new A else new B\n\nval obj1 = choose(true)  // static type is A\nval obj2 = choose(false) // static type is B\n\n// obj1.m // compile-time error: `m` is not defined on `A`\nobj2.m    // OK\n```\n\n----------------------------------------\n\nTITLE: Using summonInline for Delayed Implicit Summoning with Custom Error Messages in Scala\nDESCRIPTION: Defines a transparent inline function `summonInlineCheck` that uses pattern matching on an inline parameter to selectively summon implicits via `scala.compiletime.summonInline`. This approach delays implicit lookup until inlining and produces custom implicit-not-found errors annotated on traits `Missing1` and `Missing2`. Cases 1 and 2 cause compile-time errors with specified messages while others successfully summon an existing implicit. Requires importing `summonInline` and `implicitNotFound` annotation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/compiletime-ops.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.summonInline\nimport scala.annotation.implicitNotFound\n\n@implicitNotFound(\"Missing One\")\ntrait Missing1\n\n@implicitNotFound(\"Missing Two\")\ntrait Missing2\n\ntrait NotMissing\ngiven NotMissing = ???\n\ntransparent inline def summonInlineCheck[T <: Int](inline t : T) : Any =\n  inline t match\n    case 1 => summonInline[Missing1]\n    case 2 => summonInline[Missing2]\n    case _ => summonInline[NotMissing]\n\nval missing1 = summonInlineCheck(1) // error: Missing One\nval missing2 = summonInlineCheck(2) // error: Missing Two\nval notMissing : NotMissing = summonInlineCheck(3)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Templates (Classes, Objects, Traits) in EBNF\nDESCRIPTION: Specifies the EBNF grammar rule for `TmplDef`, which defines the top-level syntax for class, object, and trait definitions in Scala, including the optional `case` keyword for classes and objects.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_0\n\nLANGUAGE: EBNF\nCODE:\n```\nTmplDef          ::= [‘case’] ‘class’ ClassDef\n                  |  [‘case’] ‘object’ ObjectDef\n                  |  ‘trait’ TraitDef\n```\n\n----------------------------------------\n\nTITLE: Desugared Matrix Multiplication Using Method Calls in Scala3 - Scala\nDESCRIPTION: An expanded version of the matrix multiplication code showing how array accesses `xss(i)(k)` and updates `zss(i)(j) = acc` are desugared into `apply` and `update` method calls, e.g., `xss.apply(i).apply(k)` and `zss.apply(i).update(j, acc)`. This demonstrates how Scala translates syntactic sugar for array indexing and element updates into method invocations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\ndef matmul(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {\n  val zss: Array[Array[Double]] = new Array(xss.length, yss.apply(0).length)\n  var i = 0\n  while (i < xss.length) {\n    var j = 0\n    while (j < yss.apply(0).length) {\n      var acc = 0.0\n      var k = 0\n      while (k < yss.length) {\n        acc = acc + xss.apply(i).apply(k) * yss.apply(k).apply(j)\n        k += 1\n      }\n      zss.apply(i).update(j, acc)\n      j += 1\n    }\n    i += 1\n  }\n  zss\n}\n```\n\n----------------------------------------\n\nTITLE: EBNF Grammar for Scala Compilation Units\nDESCRIPTION: Defines the Extended Backus-Naur Form (EBNF) grammar for a Scala compilation unit (`CompilationUnit`), which consists of optional package clauses followed by top-level statements (`TopStatSeq`). Top-level statements include template definitions, imports, packagings, or package objects.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/09-top-level-definitions.md#_snippet_0\n\nLANGUAGE: EBNF\nCODE:\n```\nCompilationUnit  ::=  {‘package’ QualId semi} TopStatSeq\nTopStatSeq       ::=  TopStat {semi TopStat}\nTopStat          ::=  {Annotation} {Modifier} TmplDef\n                   |  Import\n                   |  Packaging\n                   |  PackageObject\n                   |                    \nQualId           ::=  id {‘.’ id}\n```\n\n----------------------------------------\n\nTITLE: Using qualified private modifiers in Scala 3\nDESCRIPTION: Shows how to use qualified private modifiers to control access scope. The example demonstrates private[Outer], private[innerpkg], and private[outerpkg] modifiers to restrict method access to different scopes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\npackage outerpkg.innerpkg\nclass Outer {\n  class Inner {\n    private[Outer] def f()\n    private[innerpkg] def g()\n    private[outerpkg] def h()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Type-safe Pattern Bindings in Scala 3\nDESCRIPTION: Demonstrates compile-time validation of pattern bindings to ensure type safety. The example shows an error when attempting to bind a pattern with a more specific type than the expression.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-05-23-15th-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval xs: List[Any] = List(1, 2, 3)\nval (x: String) :: _ = xs   // error: pattern's type String is more specialized\n                            // than the right hand side expression's type Any\n```\n\n----------------------------------------\n\nTITLE: Defining a Lazy Val in Scala 3\nDESCRIPTION: A simple example showing how to define a lazy val in a Scala class. This is the basic syntax that developers write in their code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/lazy-vals-init.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Foo {\n  lazy val bar = <RHS>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Context Function Type Alias in Scala\nDESCRIPTION: Defines a type alias `Executable[T]` as a context function type that takes an implicit ExecutionContext and returns a value of type T. This example illustrates the use of context parameters via `?=>`. Requires Scala's standard library including scala.concurrent.ExecutionContext.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/context-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.ExecutionContext\n\ntype Executable[T] = ExecutionContext ?=> T\n```\n\n----------------------------------------\n\nTITLE: Java Interoperability: Type Parameter Patching\nDESCRIPTION: Shows that type parameters (`T`) in Java methods are considered nullable when imported into Scala with explicit nulls, resulting in a return type of `T | Null`. This reflects Java's behavior where type parameters can be null.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_7\n\nLANGUAGE: java\nCODE:\n```\n// Java definition\nclass C<T> { T foo() { return null; } }\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Equivalent Scala signature with explicit nulls\nclass C[T] { def foo(): T | Null }\n```\n\n----------------------------------------\n\nTITLE: Defining a Method with 'into' Modifier on Parameter - Scala\nDESCRIPTION: Shows how to define a method with the 'into' modifier in Scala 3, allowing implicit conversions for the parameter type without extra imports. The '++' method accepts any argument convertible to 'IterableOnce[A]'. Requires only standard Scala 3; input is a value of a convertible type, output is a List of type A.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef ++ (elems: into IterableOnce[A]): List[A]\n```\n\n----------------------------------------\n\nTITLE: Importing Specific Member vs. Wildcard in Scala 3\nDESCRIPTION: Illustrates how to differentiate between importing a specific member named `*` and using the `*` wildcard import. Using backticks around the member name (` `*` `) imports the literal member `*`, while using `.*` performs a wildcard import of all members.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/imports.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject A:\n  def * = ...\n  def min = ...\n\nobject B:\n  import A.`*`   // imports just `*`\n\nobject C:\n  import A.*     // imports everything in A\n```\n\n----------------------------------------\n\nTITLE: Implementing SummonAll Macro Helper in Scala\nDESCRIPTION: Implements the `summonAll` macro helper used by `Eq.derived`. It recursively traverses the tuple type `T` (representing elements of a product or sum). It summons base `Eq` instances for primitive types (`String`, `Int`) and recursively calls `derived` for other element types, returning a list of quoted `Eq` instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation-macro.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef summonAll[T: Type](using Quotes): List[Expr[Eq[_]]] =\n   Type.of[T] match\n      case '[String *: tpes] => '{ summon[Eq[String]] } :: summonAll[tpes]\n      case '[Int *: tpes]    => '{ summon[Eq[Int]] }    :: summonAll[tpes]\n      case '[tpe *: tpes]    => derived[tpe] :: summonAll[tpes]\n      case '[EmptyTuple]     => Nil\n```\n\n----------------------------------------\n\nTITLE: Treatment of `Singleton` as a Type Class in Scala\nDESCRIPTION: Introduces a `Singleton` trait intended to replace the problematic union type bounds that claim `self.type | other.type <: Singleton`. By defining `Singleton` as a type class, the compiler can treat singleton types precisely without the unsound subtyping behavior. Supports syntax like `def f[X: Singleton](x: X) = ...`, enabling safe and exact singleton type operations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/typeclasses.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Singleton:\n  type Self\n```\n\n----------------------------------------\n\nTITLE: Using reflectiveSelectable to enable Java reflection on unrelated classes\nDESCRIPTION: This snippet demonstrates applying 'reflectiveSelectable' to enable structural member access, such as 'close' method, on unrelated Java classes like FileInputStream and Channel. It uses Java reflection for dynamic method invocation, particularly for interoperation with external libraries lacking common superinterfaces.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.Selectable.reflectiveSelectable\n\ndef autoClose(f: Closeable)(op: Closeable => Unit): Unit =\n  try op(f) finally f.close()\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Values in Scala 3\nDESCRIPTION: This snippet defines an inline value `logging` in the `Config` object, which acts as a compile-time constant. It demonstrates that inline values are treated as constants, and their right-hand side must be a constant expression, enabling compile-time inlining and optimization.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject Config:\n  inline val logging = false\n```\n\n----------------------------------------\n\nTITLE: Explanation of method application rules and applicability conditions\nDESCRIPTION: Provides a thorough overview of how method applications are evaluated in Scala 3, including type checking, compatibility requirements, handling of named and repeated arguments, and the behavior of evaluation order. It details conditions for method applicability, including type conformance for parameters, result types, and special handling for value and by-name parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Defining Functor Type Class with map Method in Scala\nDESCRIPTION: Defines the `Functor` type class trait using a type parameter `F[_]`, representing a type constructor (like `List`, `Option`). It requires a `map` method which takes a value of type `F[A]` and a function `A => B`, and returns a value of type `F[B]`, effectively mapping the function over the structure `F`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Functor[F[_]]:\n  def map[A, B](x: F[A], f: A => B): F[B]\n```\n\n----------------------------------------\n\nTITLE: Wildcard Import using * in Scala 3\nDESCRIPTION: Demonstrates the new syntax for wildcard imports in Scala 3. The asterisk (`*`) character is now used to import all accessible members from a package or object, replacing the underscore (`_`) used in previous versions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/imports.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.*  // imports everything in the annotation package\n```\n\n----------------------------------------\n\nTITLE: Applying Flow Typing Within Short-Circuiting Conditions in Scala 3\nDESCRIPTION: Shows that flow typing can specialize the type of a variable *within* a condition, leveraging the short-circuiting behavior of `&&` and `||`. In `s != null && s.length > 0`, `s` is known to be `String` when evaluating `s.length > 0`. A similar refinement applies for `||`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nval s: String | Null = ???\n\nif s != null && s.length > 0 then // s: String in `s.length > 0`\n  // s: String\n\nif s == null || s.length > 0 then // s: String in `s.length > 0`\n  // s: String | Null\nelse\n  // s: String\n```\n\n----------------------------------------\n\nTITLE: Implementing Monad Instance for List in Scala\nDESCRIPTION: Provides a `given` instance named `listMonad` for the `Monad` type class for the `List` type constructor. `pure` is implemented by creating a single-element list. The `flatMap` extension method delegates to the standard `List.flatMap` method. The `map` method is inherited from the `Monad` trait.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ngiven listMonad: Monad[List] with\n  def pure[A](x: A): List[A] =\n    List(x)\n  extension [A](xs: List[A])\n    def flatMap[B](f: A => List[B]): List[B] =\n      xs.flatMap(f) // rely on the existing `flatMap` method of `List`\n```\n\n----------------------------------------\n\nTITLE: Opaque Type Alias Defined Inside an Object in Scala 3\nDESCRIPTION: Illustrates defining an opaque type alias named T inside an object o, where inside the scope of the object the alias is equal to R, demonstrating mutual subtyping and transparent aliasing behavior within the object's scope. Provides a code example showing an opaque alias for Int and a function using the alias type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/opaques-details.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject o:\n  opaque type T = Int\n  val x: Int = id(2)\ndef id(x: o.T): o.T = x\n```\n\n----------------------------------------\n\nTITLE: Composing TupledFunctions with Arbitrary Arity in Scala\nDESCRIPTION: Provides an extension method compose on a function F that composes it with another function G, both supporting arbitrary arities and tupled forms. It uses implicit TupledFunction instances to convert both functions to tupled versions, composes them, and then returns a composed tupled function of type GArgs => R. The method supports composing functions whose arguments and return types themselves may be tuples, enabling complex function chaining beyond fixed arities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/tupled-function.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n/** Composes two instances of TupledFunction into a new TupledFunction, with this function applied last.\\n *\\n *  @tparam F a function type\\n *  @tparam G a function type\\n *  @tparam FArgs the tuple type with the same types as the function arguments of F and return type of G\\n *  @tparam GArgs the tuple type with the same types as the function arguments of G\\n *  @tparam R the return type of F\\n */\\nextension [F, G, FArgs <: Tuple, GArgs <: Tuple, R](f: F)\\n  def compose(g: G)(using tg: TupledFunction[G, GArgs => FArgs], tf: TupledFunction[F, FArgs => R]): GArgs => R = {\\n  (x: GArgs) => tf.tupled(f)(tg.tupled(g)(x))\\n}\n```\n\n----------------------------------------\n\nTITLE: Java Interoperability: Nested Generics Patching\nDESCRIPTION: Demonstrates how patching applies to nested Java generics. The outermost type becomes nullable (`Box[T] | Null`), and methods within the generic type also return nullable types (`T | Null`), ensuring soundness even if the outer container is not null.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_8\n\nLANGUAGE: java\nCODE:\n```\n// Java definition\nclass Box<T> { T get(); }\nclass BoxFactory<T> { Box<T> makeBox(); }\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Equivalent Scala signature with explicit nulls\nclass Box[T] { def get(): T | Null }\nclass BoxFactory[T] { def makeBox(): Box[T] | Null }\n```\n\n----------------------------------------\n\nTITLE: Simulating Value Alias Given Instance with Scala 2 Implicit Lazy Val\nDESCRIPTION: Defines an implicit lazy val `global` of type `ExecutionContext` initialized with a `ForkJoinContext`. This is the Scala 2 equivalent of making a value implicitly available using a lazy implicit val.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nfinal implicit lazy val global: ExecutionContext = new ForkJoinContext()\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Equality with Language Feature Import\nDESCRIPTION: Shows how to enable the strictEquality language feature to disable the fallback canEqualAny instance, enforcing strict type-checking for equality comparisons.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.strictEquality\n```\n\n----------------------------------------\n\nTITLE: Defining the FromExpr Type Class for Value Unlifting in Scala\nDESCRIPTION: Shows the definition of the `FromExpr[T]` type class trait. Implementations of this trait provide the logic for attempting to extract a constant runtime value of type `T` from its `Expr[T]` representation via the `unapply` method, requiring a `Quotes` context. Depends on `scala.quoted.*`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ntrait FromExpr[T]:\n  def unapply(x: Expr[T])(using Quotes): Option[T]\n```\n\n----------------------------------------\n\nTITLE: Illustrating Aliasing Impact on Initialization Monotonicity in Scala\nDESCRIPTION: This Scala snippet demonstrates how aliasing can violate the monotonicity principle. By assigning `this` (an uninitialized `FileReporter` object) to `ctx.typer.reporter`, an object that was previously considered transitively initialized (`ctx`) now holds a reference to an uninitialized object. This breaks the rule that initialization state should not go backward or decrease reachability to initialized objects.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/safe-initialization.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait Reporter:\n  def report(msg: String): Unit\n\nclass FileReporter(ctx: Context) extends Reporter:\n  ctx.typer.reporter = this                // ctx now reaches an uninitialized object\n  val file: File = new File(\"report.txt\")\n  def report(msg: String) = file.write(msg)\n```\n\n----------------------------------------\n\nTITLE: Basic Type Parameter Inference Example in Scala\nDESCRIPTION: Demonstrates a simple pattern match against a List[a] where 'a' is inferred as an abstract type with no bounds since List[a] conforms to Any for any type argument.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nval x: Any\nx match {\n  case y: List[a] => ...\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Indentation Configuration and Source Code Rewrites\nDESCRIPTION: Explains default indentation settings, options for disabling indentation, and mechanisms for source code transformation between brace-based and indentation-based syntax using compiler flags.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nSignificant indentation is enabled by default. It can be turned off via `-no-indent`, `-old-syntax`, or `-source 3.0-migration`. The compiler can rewrite brace syntax to indentation (`-rewrite -indent`) or vice versa (`-rewrite -no-indent`), often requiring multiple invocations when switching between syntax styles. The rewriting respects new or old syntax styles and maintains code structure accordingly.\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala Selectable Marker Trait\nDESCRIPTION: This snippet shows the definition of the `scala.Selectable` marker trait in the Scala standard library. Types extending this trait (either directly or via implicit conversion/extension methods) can support structural type access via the `selectDynamic` and `applyDynamic` methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types-spec.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Selectable extends Any\n```\n\n----------------------------------------\n\nTITLE: Comparing Specificity Between Method and Value with apply in Scala\nDESCRIPTION: This snippet, presented within a comment asking a question, illustrates a specific case in overloading resolution involving a method `f(x: Int)` and a value `f` that has an `apply` method taking an `Int`. It highlights how Scala determines specificity and chooses between a method definition and a value definition that can be invoked like a method (via `apply`) when both share the same name.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_53\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Int)\nval f: { def apply(x: Int) }\nf(1)\n```\n\n----------------------------------------\n\nTITLE: Defining Splicing Rules for Symmetric Metaprogramming Calculus\nDESCRIPTION: Defines the splicing rules (`==>`) which describe how terms are reduced when potentially involved in a splice (`~t`). This includes the key rule for reducing a splice of a quote (`~’u ==> u`) and context rules for splicing under lambda abstractions, applications, and other splices.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/simple-smp.md#_snippet_2\n\nLANGUAGE: Formal Calculus\nCODE:\n```\n                        ~’u  ==>  u\n\n                         t1  ==>  t2\n               -------------------------------\n               (x: T) => t1  ==>  (x: T) => t2\n\n                         t1  ==>  t2\n                       ---------------\n                       t1 t  ==>  t2 t\n\n                         t1  ==>  t2\n                       ---------------\n                       u t1  ==>  u t2\n\n                         t1  -->  t2\n                        -------------\n                        ~t1  ==>  ~t2\n```\n\n----------------------------------------\n\nTITLE: Synthesizing Name for Anonymous Parameterless Given Instance (Scala 3)\nDESCRIPTION: Shows the compiler-synthesized name `given_Ord_Int` for an anonymous given instance implementing `Ord[Int]` in Scala 3. This illustrates the default naming convention when no explicit name is provided.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ngiven given_Ord_Int: Ord[Int] { ... }\n```\n\n----------------------------------------\n\nTITLE: Running the TASTy Inspector with a Custom Inspector Instance (Scala)\nDESCRIPTION: Demonstrates how to run the TastyInspector to process a list of TASTy files by instantiating the custom Inspector class. The example lists a single TASTy file path, calls TastyInspector.inspectTastyFiles with the file list and new MyInspector instance to start inspection. This snippet highlights the usage pattern for executing TASTy analysis programs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/tasty-inspect.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject Test:\n   def main(args: Array[String]): Unit =\n      val tastyFiles = List(\"foo/Bar.tasty\")\n      TastyInspector.inspectTastyFiles(tastyFiles)(new MyInspector)\n```\n\n----------------------------------------\n\nTITLE: Capture Checking of Classes and Constructor Parameters in Scala\nDESCRIPTION: Demonstrates how classes capture capabilities passed via constructor parameters or used locally. The Logger class retains its FileSystem capability as a field, so instances have capture sets reflecting this. Also shows usage of @constructorOnly annotation to mark capabilities which are only used during construction and not retained, allowing safe omission from capture sets in the class type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nclass Logger(using fs: FileSystem):\n  def log(s: String): Unit = ... summon[FileSystem] ...\n\ndef test(xfs: FileSystem): Logger^{xfs} =\n  Logger(xfs)\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport annotation.constructorOnly\n\nclass NullLogger(using @constructorOnly fs: FileSystem):\n  ...\ndef test2(using fs: FileSystem): NullLogger = NullLogger() // OK\n```\n\n----------------------------------------\n\nTITLE: Generated Scala Code for @main Method\nDESCRIPTION: Provides an equivalent representation of the boilerplate code automatically generated by the Scala 3 compiler for a `@main` method. This code includes a standard static `main(args: Array[String])` method that uses `scala.util.CommandLineParser` to parse arguments and call the user's `@main` method, including error handling for parsing issues. This code is generated by the compiler and not written directly by the user.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/main-functions.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nfinal class happyBirthday:\n  import scala.util.CommandLineParser as CLP\n  <static> def main(args: Array[String]): Unit =\n    try\n      happyBirthday(\n        CLP.parseArgument[Int](args, 0),\n        CLP.parseArgument[String](args, 1),\n        CLP.parseRemainingArguments[String](args, 2))\n    catch\n      case error: CLP.ParseError => CLP.showError(error)\n```\n\n----------------------------------------\n\nTITLE: Running tests that compile code from TASTy files in Scala 3 using sbt\nDESCRIPTION: Command to run compilation tests with the additional mode that enables compiling from `.tasty` files instead of source code. This helps verify that the compiler correctly handles TASTy inputs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\n> testCompilation --from-tasty\n```\n\n----------------------------------------\n\nTITLE: Defining Monad Type Class Extending Functor in Scala\nDESCRIPTION: Defines the `Monad` type class trait, which extends `Functor`. It adds two core operations: `pure` (lifting a value `A` into the monadic context `F[A]`) and `flatMap` (sequencing operations where the function returns a monadic value `A => F[B]`). It also provides a default implementation for `map` in terms of `flatMap` and `pure`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Monad[F[_]] extends Functor[F]:\n\n  /** The unit value for a monad */\n  def pure[A](x: A): F[A]\n\n  extension [A](x: F[A])\n    /** The fundamental composition operation */\n    def flatMap[B](f: A => F[B]): F[B]\n\n    /** The `map` operation can now be defined in terms of `flatMap` */\n    def map[B](f: A => B) = x.flatMap(f.andThen(pure))\n\nend Monad\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Object Definition and Lazy Instantiation Example\nDESCRIPTION: Defines how object definitions in Scala 3 correlate to lazy val instantiations combining multiple base classes with optional bodies. Explains thread-safe lazy initialization semantics and the special case for top-level objects becoming static fields. Includes a Scala example demonstrating the use of a companion object 'Point' providing a static-like member 'origin' alongside the abstract class 'Point'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Point {\n  val x: Double\n  val y: Double\n  def isOrigin = (x == 0.0 && y == 0.0)\n}\nobject Point {\n  val origin = new Point() { val x = 0.0; val y = 0.0 }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of explicit main method in Scala\nDESCRIPTION: Shows how to define an explicit main method in Scala for command-line argument processing, replacing the deprecated App approach. Highlights the need for explicit main for better control and compatibility.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/delayed-init.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject Hello:\n  def main(args: Array[String]) =\n    println(s\"Hello, ${args(0)}\")\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Capability Classes in Scala\nDESCRIPTION: Shows how to define a capability class (`FileSystem`) using the `@capability` annotation, which implies a capture set of `{*}`. It also demonstrates how a class (`Logger`) can use this capability via a `using` clause and how a local variable (`l`) can be typed with a specific capture set (`{fs}`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport annotation.capability\n\n@capability class FileSystem\n\nclass Logger(using FileSystem):\n  def log(s: String): Unit = ???\n\ndef test(using fs: FileSystem) =\n  val l: {fs} Logger = Logger()\n  ...\n```\n\n----------------------------------------\n\nTITLE: Builder Pattern Using Context Functions in Scala\nDESCRIPTION: Defines classes Table, Row, and Cell to model a nested table structure where hierarchy is expressed using context functions to reduce boilerplate. The `table`, `row`, and `cell` methods utilize context function types to implicitly pass context objects, allowing clean DSL-like construction without explicit parameter passing. Key dependencies include scala.collection.mutable.ArrayBuffer for internal collections.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/context-functions.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\nclass Table:\n  val rows = new ArrayBuffer[Row]\n  def add(r: Row): Unit = rows += r\n  override def toString = rows.mkString(\"Table(\", \", \", \")\")\n\nclass Row:\n  val cells = new ArrayBuffer[Cell]\n  def add(c: Cell): Unit = cells += c\n  override def toString = cells.mkString(\"Row(\", \", \", \")\")\n\ncase class Cell(elem: String)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef table(init: Table ?=> Unit) =\n  given t: Table = Table()\n  init\n  t\n\ndef row(init: Row ?=> Unit)(using t: Table) =\n  given r: Row = Row()\n  init\n  t.add(r)\n\ndef cell(str: String)(using r: Row) =\n  r.add(new Cell(str))\n```\n\nLANGUAGE: scala\nCODE:\n```\ntable { ($t: Table) ?=>\n\n  row { ($r: Row) ?=>\n    cell(\"top left\")(using $r)\n    cell(\"top right\")(using $r)\n  }(using $t)\n\n  row { ($r: Row) ?=>\n    cell(\"bottom left\")(using $r)\n    cell(\"bottom right\")(using $r)\n  }(using $t)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Multiple Context Bounds and Using Clause in Scala\nDESCRIPTION: Illustrates a function definition with multiple context bounds (`: C1`, `: C2`, `: C3`) on different type parameters (`T`, `U`) alongside an existing explicit `using` clause. This shows how context bounds are integrated with other parameter lists.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-bounds.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef f[T: C1 : C2, U: C3](x: T)(using y: U, z: V): R\n```\n\n----------------------------------------\n\nTITLE: Compiler Expansion of Deferred Givens in Traits and Classes - Scala\nDESCRIPTION: This expanded version of the previous snippet shows how the Scala 3.6 compiler interprets traits and classes with deferred givens. It makes explicit the usage of 'compiletime.deferred' in the trait's given member and details the override in the class constructor that provides the required given. All key parameters are shown, and the use of the 'override' modifier is highlighted. This code illustrates the automatic and explicit provision of deferred givens by subclasses or by the compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/deferred-givens.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Sorted:\n  type Element\n  given Ord[Element] = compiletime.deferred\n\nclass SortedSet[A](using ord: Ord[A]) extends Sorted:\n  type Element = A\n  override given Ord[Element] = ord\n```\n\n----------------------------------------\n\nTITLE: Assignment Expression Syntax and Semantics in Scala3 - EBNF and Scala\nDESCRIPTION: Describes assignment expressions including direct assignments to identifiers, prefix operator assignments, and assignments involving method application. Explains how assignments to parameterless methods with setters are interpreted as setter method calls. Also describes how assignments involving applications on the left are interpreted as calls to the 'update' method, supporting syntax like `f(args) = e`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_24\n\nLANGUAGE: ebnf\nCODE:\n```\nExpr1        ::=  [SimpleExpr ‘.’] id ‘=’ Expr\n               |  PrefixOperator SimpleExpr ‘=’ Expr\n               |  SimpleExpr1 ArgumentExprs ‘=’ Expr\n```\n\n----------------------------------------\n\nTITLE: Annotated Expression Syntax in Scala3 - EBNF\nDESCRIPTION: Defines annotated expressions, where an expression is followed by one or more annotations prefixed by '@'. These annotations attach metadata to the expression that can be used for various purposes such as optimization or tooling.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_23\n\nLANGUAGE: ebnf\nCODE:\n```\nExpr1              ::=  PostfixExpr ‘:’ Annotation {Annotation}\n```\n\n----------------------------------------\n\nTITLE: Using Implicit Parameters in Scala 2 Function Definitions - Scala\nDESCRIPTION: Equivalent to a Scala 3 using clause, this defines max in Scala 2 using implicit parameters for the ordering. Takes two values and an implicit Ord[T]; returns the maximum according to the given implicit ordering. Shows the old-style contextual abstraction for migration purposes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ndef max[T](x: T, y: T)(implicit ord: Ord[T]): T\n```\n\n----------------------------------------\n\nTITLE: Replacing package objects with top-level definitions in Scala 3\nDESCRIPTION: This snippet demonstrates how to define various values, types, and extension methods directly at the top level within a package, eliminating the need for package objects. It illustrates defining a type alias, value, method, case class, and extension method outside of a package object.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/package-objects.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage p\n\ntype Labelled[T] = (String, T)\nval a: Labelled[Int] = (\"count\", 1)\ndef b = a._2\n\ncase class C()\n\nextension (x: C) def pair(y: C) = (x, y)\n```\n\n----------------------------------------\n\nTITLE: Using infix modifier with methods and types in Scala 3\nDESCRIPTION: Demonstrates valid and invalid use of the infix modifier with methods. The infix modifier requires methods to have exactly one non-receiver parameter and can be applied to types with exactly two type parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ninfix def op1(x: S): R             // ok\ninfix def op2[T](x: T)(y: S): R    // ok\ninfix def op3[T](x: T, y: S): R    // error: two parameters\nextension (x: A)\n  infix def op4(y: B): R          // ok\n  infix def op5(y1: B, y2: B): R  // error: two parameters\n```\n\nLANGUAGE: scala\nCODE:\n```\ninfix type op[X, Y]\n```\n\n----------------------------------------\n\nTITLE: Creating a CanEqual Given Instance for Type T\nDESCRIPTION: Demonstrates explicit definition of a CanEqual given instance that allows values of type T to be compared only with other values of the same type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ngiven CanEqual[T, T] = CanEqual.derived\n```\n\n----------------------------------------\n\nTITLE: Implementing Matrix Transpose using Scala 3 For Comprehensions\nDESCRIPTION: Defines a Scala 3 function `transpose` that computes the transpose of a given matrix (represented as `Array[Array[A]]`). It uses nested `for` comprehensions. The outer loop iterates through column indices, and the inner loop iterates through the rows (`xs <- xss`) to collect elements at the current column index `i`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\ndef transpose[A](xss: Array[Array[A]]) = {\n  for (i <- Array.range(0, xss(0).length)) yield\n    for (xs <- xss) yield xs(i)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Scala Stable Identifier Patterns in Match Expressions\nDESCRIPTION: Illustrates the usage of stable identifier patterns and a variable pattern within a Scala `match` expression inside a class `C`. Demonstrates how patterns referencing `c.x`, ``y`` (using backticks for a lower-case identifier), and `Z` match specific constant values defined within the class, while a simple `x` pattern matches any value and shadows the outer `x` parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass C { c =>\n  val x = 42\n  val y = 27\n  val Z = 8\n  def f(x: Int) = x match {\n    case c.x => 1  // matches 42\n    case `y` => 2  // matches 27\n    case Z   => 3  // matches 8\n    case x   => 4  // matches any value\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Monoid Companion Object Helper in Scala\nDESCRIPTION: Defines a companion object `Monoid` with an `apply` method. This method uses a `using` clause (context function parameter) to implicitly summon the `Monoid[T]` instance in scope. This provides a convenient way to retrieve the type class instance without explicitly calling `summon`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject Monoid:\n  def apply[T](using m: Monoid[T]) = m\n```\n\n----------------------------------------\n\nTITLE: Simulating Implicit Conversion with Scala 3 Given Conversion (Shorthand)\nDESCRIPTION: Defines a given instance of `scala.Conversion[String, Token]` using a concise shorthand syntax with a lambda `KeyWord(_)`. This provides an implicit conversion in Scala 3 using less verbose syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\ngiven stringToToken: Conversion[String, Token] = KeyWord(_)\n```\n\n----------------------------------------\n\nTITLE: Example of a Scala Class with a Private Constructor in Scala\nDESCRIPTION: Illustrates defining a class with a private primary constructor making it instantiable only within its companion object. The companion object provides a controlled factory method depending on credentials. Inputs include credentials checked against Admin; output is a Sensitive instance or exception. Dependencies include a Certificate type and SecurityViolationException class. This pattern restricts class instantiation to controlled contexts.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nobject Sensitive {\n  def makeSensitive(credentials: Certificate): Sensitive =\n    if (credentials == Admin) new Sensitive()\n    else throw new SecurityViolationException\n}\nclass Sensitive private () {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Providing a Direct CanEqual Instance\nDESCRIPTION: Demonstrates how to create a CanEqual instance explicitly, allowing values of type T to be compared only with other values of type T.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ngiven CanEqual[T, T] = CanEqual.derived\n```\n\n----------------------------------------\n\nTITLE: Anonymous Implied Instances and Implied Alias Instances\nDESCRIPTION: Illustrates definitions of implied instances without explicit names and aliasing implied instances with 'implied ctx for ... = ...'. These features enhance flexibility and code clarity when managing implied contexts.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimplied for Ord[Int] { ... }\n\nimplied ctx for ExecutionContext = currentThreadPool().context\n```\n\n----------------------------------------\n\nTITLE: Creating Nullable Types with Union Types in Scala 3\nDESCRIPTION: This example demonstrates how to create nullable types using union types when explicit nulls are enabled. The String | Null syntax explicitly indicates that the variable can hold either a String or null.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval x: String | Null = null // ok\n```\n\n----------------------------------------\n\nTITLE: Implementing a Comparable Trait in Scala with Type Constraints\nDESCRIPTION: This Scala trait defines a type-safe comparer for objects implementing the `Comparable` interface. It enforces a type parameter constraint ensuring recursive relationship for comparison, provides an abstract less-than operator `<`, and concrete implementations of other relational operators using the abstract method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Comparable[T <: Comparable[T]] { self: T =>\n  def < (that: T): Boolean\n  def <=(that: T): Boolean = this < that || this == that\n  def > (that: T): Boolean = that < this\n  def >=(that: T): Boolean = that <= this\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Java-Compatible Enum in Scala\nDESCRIPTION: Demonstrates how to define a Scala enum `Color` that is compatible with Java enums by extending `java.lang.Enum[Color]`. The type parameter must match the enum type itself. No constructor arguments need to be passed to the superclass.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nenum Color extends Enum[Color] { case Red, Green, Blue }\n```\n\n----------------------------------------\n\nTITLE: Invariant Behavior of Opaque Type Aliases in Scala\nDESCRIPTION: This Scala code defines an opaque type alias `O[X] = List[X]`. It clarifies that opaque types like `O` are considered invariant by default, regardless of the variance of their right-hand side (`List[X]` is covariant). This contrasts with transparent aliases, which infer variance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas-spec.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nopaque type O[X] = List[X]\n```\n\n----------------------------------------\n\nTITLE: Handling Recursive Calls within Extension Methods in Scala\nDESCRIPTION: Shows a recursive extension method `position`. When `position` calls itself recursively within its body, the compiler automatically interprets `position(ch, n + 1)` as a call on the receiver instance `s`, effectively rewriting it to `s.position(ch, n + 1)`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nextension (s: String)\n  def position(ch: Char, n: Int): Int =\n    if n < s.length && s(n) != ch then position(ch, n + 1)\n    else n\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Inspector Class for Scala 3 TASTy Inspection (Scala)\nDESCRIPTION: Shows how to create a custom Inspector by extending the scala.tasty.inspector.Inspector trait. The inspect method provides access to a list of TASTy files represented by the Tasty wrapper using the Quotes context, allowing extraction and processing of the abstract syntax tree (AST) via tasty.ast. This is designed for users intending to analyze or transform the TASTy typed trees with the Scala 3 metaprogramming reflection API.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/tasty-inspect.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.quoted.*\nimport scala.tasty.inspector.*\n\nclass MyInspector extends Inspector:\n   def inspect(using Quotes)(tastys: List[Tasty[quotes.type]]): Unit =\n      import quotes.reflect.*\n      for tasty <- tastys do\n         val tree = tasty.ast\n         // Do something with the tree\n```\n\n----------------------------------------\n\nTITLE: Using Pattern-Bound Given Instances Scala 3\nDESCRIPTION: Illustrates how given instances can be bound within patterns in Scala 3. The first example shows anonymous `Context` instances being bound as givens during iteration in a `for` comprehension. The second example demonstrates binding a named `Context` given `ctx` when matching against a tuple element in a `match` expression.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/more-givens.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nfor given Context <- applicationContexts do\n\npair match\n  case (ctx @ given Context, y) => ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Match Type for Element Extraction\nDESCRIPTION: This Scala snippet defines a simple match type `Elem[X]` that extracts element types from various data structures, such as `String`, `Array[t]`, and `Iterable[t]`. It demonstrates how match types enable type-level computation based on the structure of `X`. The examples show how different types reduce to specific element types, illustrating the reduction process and subtype relationships.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/match-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntype Elem[X] = X match\n  case String => Char\n  case Array[t] => t\n  case Iterable[t] => t\n```\n\n----------------------------------------\n\nTITLE: Compiler Step: Conceptual Local Given for By-Name Synthesis in Scala\nDESCRIPTION: Illustrates a conceptual intermediate step in the Scala 3 compiler's synthesis of arguments for by-name context parameters. It shows the generation of a temporary local `given` instance (`lv`) of the required type (`T`), which acts as a placeholder to manage potential inference loops during the search. This is not literal user-written code but represents compiler logic.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/by-name-context-parameters.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ngiven lv: T = ???\n```\n\n----------------------------------------\n\nTITLE: Specifying Scala Template Structure in EBNF\nDESCRIPTION: Provides EBNF grammar rules for the internal structure of class and trait templates. It defines components like early definitions (`EarlyDefs`), parent lists (`ClassParents`, `TraitParents`), the template body (`TemplateBody`) containing statements and optional self type (`SelfType`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_1\n\nLANGUAGE: EBNF\nCODE:\n```\nClassTemplate   ::=  [EarlyDefs] ClassParents [TemplateBody]\nTraitTemplate   ::=  [EarlyDefs] TraitParents [TemplateBody]\nClassParents    ::=  Constr {‘with’ AnnotType}\nTraitParents    ::=  AnnotType {‘with’ AnnotType}\nTemplateBody    ::=  [nl] ‘{’ [SelfType] TemplateStat {semi TemplateStat} ‘}’\nSelfType        ::=  id [‘:’ Type] ‘=>’\n                 |   this ‘:’ Type ‘=>’\n```\n\n----------------------------------------\n\nTITLE: Alternative Eq Derivation using Shapeless 3 in Scala\nDESCRIPTION: Illustrates an alternative approach to defining the `Eq.derived` method using the Shapeless 3 library. It defines `eqSum` and `eqProduct` using Shapeless's `K0.CoproductInstances` and `K0.ProductInstances`, and then combines them via `K0.Generic`'s `derive` method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ngiven eqSum[A](using inst: => K0.CoproductInstances[Eq, A]): Eq[A] with\n  def eqv(x: A, y: A): Boolean = inst.fold2(x, y)(false)(\n    [t] => (eqt: Eq[t], t0: t, t1: t) => eqt.eqv(t0, t1)\n  )\n\ngiven eqProduct[A](using inst: K0.ProductInstances[Eq, A]): Eq[A] with\n  def eqv(x: A, y: A): Boolean = inst.foldLeft2(x, y)(true: Boolean)(\n    [t] => (acc: Boolean, eqt: Eq[t], t0: t, t1: t) =>\n      Complete(!eqt.eqv(t0, t1))(false)(true)\n  )\n\ninline def derived[A](using gen: K0.Generic[A]): Eq[A] =\n  gen.derive(eqProduct, eqSum)\n```\n\n----------------------------------------\n\nTITLE: Explicit Self-Type Annotation for Capture Set in Scala\nDESCRIPTION: Shows how to explicitly declare the capture set for a class's `this` type using a self-type annotation (`self: {a, b} D => ...`). This overrides the inferred capture set.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nclass C:\n  self: {a, b} D => ...\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Closure Approximation in Scala 3 Overload Resolution - Scala\nDESCRIPTION: Describes how pattern matching closures are treated as function values in overload resolution. The pattern matching closure `{ case P1 => B1 ... case P_n => B_n }` is expanded to a function value `x => x match { case P1 => B1 ... case P_n => B_n }`, and approximated with a wildcard function type `? => ?`. This technical detail supports function value inference in overloaded calls with pattern matching syntax in the first argument list.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/overload-resolution.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n{ case P1 => B1 ... case P_n => B_n }\n```\n\nLANGUAGE: scala\nCODE:\n```\nx => x match { case P1 => B1 ... case P_n => B_n }\n```\n\n----------------------------------------\n\nTITLE: Defining a 'Pair' Extractor Object in Scala\nDESCRIPTION: Defines a Scala object `Pair` that acts as an extractor for `Tuple2`. It provides an `apply` method for construction and an `unapply` method that takes a `Tuple2` and returns an `Option[Tuple2[A, B]]`, enabling its use in pattern matching to deconstruct tuples.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nobject Pair {\n  def apply[A, B](x: A, y: B) = Tuple2(x, y)\n  def unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Using erasedValue for Type-level Conditional Compilation and Default Values in Scala\nDESCRIPTION: Illustrates the use of `scala.compiletime.erasedValue[T]` to perform compile-time type matching and definition of a defaultValue function for primitive types. The `erasedValue` function does not produce runtime values but allows pattern matching over erased types at compile time. The code defines default zero values for various primitive types and returns None otherwise. Additionally, it defines a type-level Peano number to integer value converter `toIntT` using erasedValue. Inputs are compile-time type parameters; outputs are optional default values or integers resolved at compile time. Requires import of erasedValue from scala.compiletime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/compiletime-ops.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef erasedValue[T]: T\n\nimport scala.compiletime.erasedValue\n\ntransparent inline def defaultValue[T] =\n  inline erasedValue[T] match\n    case _: Byte    => Some(0: Byte)\n    case _: Char    => Some(0: Char)\n    case _: Short   => Some(0: Short)\n    case _: Int     => Some(0)\n    case _: Long    => Some(0L)\n    case _: Float   => Some(0.0f)\n    case _: Double  => Some(0.0d)\n    case _: Boolean => Some(false)\n    case _: Unit    => Some(())\n    case _          => None\n\nval dInt: Some[Int] = defaultValue[Int]\nval dDouble: Some[Double] = defaultValue[Double]\nval dBoolean: Some[Boolean] = defaultValue[Boolean]\nval dAny: None.type = defaultValue[Any]\n\ntransparent inline def toIntT[N <: Nat]: Int =\n  inline scala.compiletime.erasedValue[N] match\n    case _: Zero.type => 0\n    case _: Succ[n] => toIntT[n] + 1\n\ninline val two = toIntT[Succ[Succ[Zero.type]]]\n```\n\n----------------------------------------\n\nTITLE: Declaring a Pure Function Type Enforcing No Exception Capability - Scala\nDESCRIPTION: Defines a pure function type signature for a variant of map, named pureMap, that enforces that its argument function does not throw exceptions or have side effects by disallowing it from capturing any capabilities. This signature uses a hypothetical pure function arrow (->) to represent purity constraints on the argument function, illustrating a way to limit capabilities in higher-order functions. It requires language-level support for pure types which is a proposed extension.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/canthrow.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n  def pureMap(f: A -> B): List[B]\n```\n\n----------------------------------------\n\nTITLE: Alternative Pure Lazy List Map Implementation in Scala\nDESCRIPTION: Example of how a lazy list implementation could be designed to only accept pure functions for operations like map, which would not require capture annotations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\nextension [A](xs: LzyList[A])\n  def map[B](f: A -> B): LzyList[B] = ...\n```\n\n----------------------------------------\n\nTITLE: Mapping Tuples with Pattern Matching in Scala (Old Syntax)\nDESCRIPTION: This snippet demonstrates the traditional way to process a list of tuples using the 'map' function combined with pattern matching. The 'case (x, y)' syntax decomposes each tuple into individual variables 'x' and 'y' for computation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling-spec.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nxs.map {\n  case (x, y) => x + y\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Block Expression Syntax Using EBNF in Scala\nDESCRIPTION: This EBNF snippet lays out the valid forms for block expressions and their internal structure. BlockExpr can be a brace-enclosed sequence of case clauses or a general block, while 'Block' consists of statements and an optional result expression. No dependencies or inputs are needed, as this defines parser-level structure.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_14\n\nLANGUAGE: EBNF\nCODE:\n```\nBlockExpr  ::=  ‘{’ CaseClauses ‘}’\n             |  ‘{’ Block ‘}’\nBlock      ::=  BlockStat {semi BlockStat} [ResultExpr]\n```\n\n----------------------------------------\n\nTITLE: Implementing Inline Overrides in Scala 3\nDESCRIPTION: Illustrates the usage of the `inline override` feature introduced in Dotty 0.24.0-RC1. An abstract class `A` defines a method `f`, which is then overridden using `inline override` in the subclass `B`. A main function demonstrates its usage.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-04-29-24th-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nabstract class A:\n  def f(x: Int) = s\"Foo $x\"\n\nclass B extends A:\n  inline override def f(x: Int) = s\"Bar $x\"\n\n@main def Test =\n  val b = B()\n  println(b.f(22))\n  val a: A = b\n  println(a.f(22))\n```\n\n----------------------------------------\n\nTITLE: Simulating Reference Alias Given Instance with Scala 2 Implicit Method\nDESCRIPTION: Defines an implicit method `given_Context` that returns the `ctx` value. This is the Scala 2 equivalent of making an existing reference implicitly available using an implicit method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nfinal implicit def given_Context = ctx\n```\n\n----------------------------------------\n\nTITLE: Inline `summonInline` for Compile-Time Type Class Resolution in Scala 3\nDESCRIPTION: This code illustrates how to use `summonInline` within inline methods to resolve type class instances at compile time, avoiding runtime errors when implicit values are missing. The pattern ensures `X` is known at expansion site, enhancing macro metaprogramming capabilities and type safety. Dependencies include `scala.compiletime.summonInline`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-03-18-23rd-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.compiletime.summonInline\n\ninline def lookup[X] =\n  val x = summonInline[X]\n  println(s\"x = $x\")\n\n@main def Test =\n  given Int = 10\n  lookup[Int]\n```\n\n----------------------------------------\n\nTITLE: Defining Alias Given Instance for Value in Scala 3\nDESCRIPTION: Defines an alias given instance named `global` that points to a specific value of type `ExecutionContext` created using `new ForkJoinContext()`. This Scala 3 syntax makes the value implicitly available under the name `global`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ngiven global: ExecutionContext = new ForkJoinContext()\n```\n\n----------------------------------------\n\nTITLE: Correct Position of 'given' Clause in Scala 3\nDESCRIPTION: Shows the correct way to define a function with a 'given' clause, which must come after all normal parameter lists.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-05-23-15th-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimplied for String = \"foo\"\ndef f(x: Int)(z: Int) given (y: String) = x + z\nf(1)(3)\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect-Dependent Functions and Compositions - Scala\nDESCRIPTION: Implements an abstract dependent function class Fun parameterized by input and output types, with an abstract member Eff representing an effect subtype. The apply method returns a dependent function on Eff implicits. It defines concrete effect classes CanThrow and CanIO, with corresponding given instances. Several higher-order functions are implemented: map applies a Fun to a list with effect-dependent context, mapFn builds a curried function with effect dependency, and compose/composeFn provide function composition respecting effects. The example concludes with a main test to assert correctness. This snippet requires Scala 3 dependent function, context function, and effect capabilities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/dependent-function-types-spec.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait Effect\n\n// Type X => Y\nabstract class Fun[-X, +Y]:\n  type Eff <: Effect\n  def apply(x: X): Eff ?=> Y\n\nclass CanThrow extends Effect\nclass CanIO extends Effect\n\ngiven ct: CanThrow = new CanThrow\ngiven ci: CanIO = new CanIO\n\nclass I2S extends Fun[Int, String]:\n  type Eff = CanThrow\n  def apply(x: Int) = x.toString\n\nclass S2I extends Fun[String, Int]:\n  type Eff = CanIO\n  def apply(x: String) = x.length\n\n// def map(f: A => B)(xs: List[A]): List[B]\ndef map[A, B](f: Fun[A, B])(xs: List[A]): f.Eff ?=> List[B] =\n  xs.map(f.apply)\n\n// def mapFn[A, B]: (A => B) -> List[A] -> List[B]\ndef mapFn[A, B]: (f: Fun[A, B]) => List[A] => f.Eff ?=> List[B] =\n  f => xs => map(f)(xs)\n\n// def compose(f: A => B)(g: B => C)(x: A): C\ndef compose[A, B, C](f: Fun[A, B])(g: Fun[B, C])(x: A):\n  f.Eff ?=> g.Eff ?=> C =\n  g(f(x))\n\n// def composeFn: (A => B) -> (B => C) -> A -> C\ndef composeFn[A, B, C]:\n  (f: Fun[A, B]) => (g: Fun[B, C]) => A => f.Eff ?=> g.Eff ?=> C =\n  f => g => x => compose(f)(g)(x)\n\n@main def test =\n  val i2s = new I2S\n  val s2i = new S2I\n\n  assert(mapFn(i2s)(List(1, 2, 3)).mkString == \"123\")\n  assert(composeFn(i2s)(s2i)(22) == 2)\n```\n\n----------------------------------------\n\nTITLE: Output of Inline Override Example in Scala 3\nDESCRIPTION: Shows the console output produced by running the Scala code example that demonstrates `inline override`. Both calls to method `f` print \"Bar 22\", confirming that the inline overridden method in the subclass `B` is executed, even when the object reference is typed as the superclass `A`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-04-29-24th-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nBar 22\nBar 22\n```\n\n----------------------------------------\n\nTITLE: Compiler Expansion: Summon Call with By-Name Context Parameter in Scala\nDESCRIPTION: Demonstrates the conceptual expansion of the `summon` call for `Codec[Option[Int]]` in the provided example. It shows the compiler resolving the `optionCodec` and explicitly passing `intCodec` as the argument for the using clause. This illustrates the result of the synthesis process for a non-recursive case where a local given instance (`lv`) was not required.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/by-name-context-parameters.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval s = summon[Test.Codec[Option[Int]]](\n  optionCodec[Int](using intCodec)\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Staging Dependency in build.sbt (Scala)\nDESCRIPTION: Specifies the required library dependency to be added to a `build.sbt` file for enabling runtime multi-stage programming capabilities in a Scala 3 project. It adds the `scala3-staging` artifact.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/staging.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"org.scala-lang\" %% \"scala3-staging\" % scalaVersion.value\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Anonymous Function EBNF Syntax\nDESCRIPTION: EBNF syntax definition for block expressions containing case clauses, used to define pattern matching anonymous functions in Scala.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_27\n\nLANGUAGE: ebnf\nCODE:\n```\nBlockExpr ::= '{' CaseClauses '}'\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Types Syntax in EBNF\nDESCRIPTION: Defines the EBNF grammar for Scala 3 parameterized types. These types consist of a type constructor followed by a list of type arguments, which can be concrete types or wildcard type arguments (`?`) with optional bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_12\n\nLANGUAGE: ebnf\nCODE:\n```\nParameterizedType ::=  Type ‘[‘ TypeArgs ‘]‘\nTypeArgs          ::=  TypeArg {‘,‘ TypeArg}\nTypeArg           ::=  Type\n                    |  WilcardTypeArg\nWildcardTypeArg   ::=  ‘?‘ TypeBounds\n```\n\n----------------------------------------\n\nTITLE: Implementing Classes with Scala Intersection Types\nDESCRIPTION: Shows the implementation requirement for a class `C` that inherits from multiple traits (`A` and `B`) forming an intersection type. The class `C` must provide a concrete implementation for any common members, like `children`, ensuring its type matches the intersection type (`List[A & B]`) derived from the parent traits.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/intersection-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass C extends A, B:\n  def children: List[A & B] = ???\n```\n\n----------------------------------------\n\nTITLE: Declaring Implicit Values and Methods with Explicit Types in Scala 3 Scala\nDESCRIPTION: Demonstrates the requirement that implicit values and implicit methods must have explicit type annotations in Scala 3, except for local block values where type inference remains allowed. The snippet clarifies permitted versus disallowed declarations accompanied by compiler error indications, emphasizing stricter static typing for implicit declarations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-resolution.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n  class C {\n\n    val ctx: Context = ...        // ok\n\n    /*!*/ implicit val x = ...    // error: type must be given explicitly\n\n    /*!*/ implicit def y = ...    // error: type must be given explicitly\n  }\n  val y = {\n    implicit val ctx = this.ctx // ok\n    ...\n  }\n```\n\n----------------------------------------\n\nTITLE: Using @into Annotation for Retrofitting Scala 2 Library Code - Scala\nDESCRIPTION: Demonstrates how the '@into' annotation can be used in method definitions to retrofit Scala 2 code so that arguments receive Scala 3-style implicit conversions. The example covers the '++' and 'flatMap' methods, marking their parameters to allow conversions without language imports. Inputs/outputs match the respective method types, and the feature requires importing 'scala.annotation.into'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef ++ (elems: IterableOnce[A] @into): List[A]\ndef flatMap[B](f: A => IterableOnce[B] @into): List[B]\n```\n\n----------------------------------------\n\nTITLE: Utility methods for handling nullable types in NullOpsDecorator.scala\nDESCRIPTION: Provides extension methods for 'Type' objects to strip nulls, check nullability, and assist in nullability-related operations. Functions include 'stripNull' to remove Null from unions, 'isNullableUnion' to detect nullable unions, and 'isNullableAfterErasure' to determine nullability post type erasure. These utilities support precise null handling in Scala's type system.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/explicit-nulls.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef stripNull: Type = ...\n def isNullableUnion: Boolean = ...\n def isNullableAfterErasure: Boolean = ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependent Typing with Match Types in Scala 3\nDESCRIPTION: Shows how to use match types to create dependently typed methods. The example implements the value-level counterpart to the LeafElem type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/match-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef leafElem[X](x: X): LeafElem[X] = x match\n  case x: String      => x.charAt(0)\n  case x: Array[t]    => leafElem(x(0))\n  case x: Iterable[t] => leafElem(x.head)\n  case x: AnyVal      => x\n```\n\n----------------------------------------\n\nTITLE: Illegal @targetName Creating Name Clash with Inherited Method in Scala\nDESCRIPTION: Presents a scenario where defining a method `g` in subclass `B` with `@targetName(\"f\")` causes a name clash with the inherited method `f` from superclass `A`. Although the original source names (`g` and `f`) differ, their target names become identical (`f`), leading to a compilation error due to conflicting signatures after erasure.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/targetName.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport annotation.targetName\nclass A:\n  def f(): Int = 1\nclass B extends A:\n  @targetName(\"f\") def g(): Int = 2\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Test in Scala Pattern Matching\nDESCRIPTION: Illustrates a basic pattern match scenario in Scala where an explicit runtime type test is performed using the `y: Y` syntax. This is one case where the compiler needs to check the type at runtime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n(x: X) match\n  case y: Y =>\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Lexical Syntax with EBNF Grammar - EBNF\nDESCRIPTION: This code snippet provides the EBNF grammar for the lexical classification of Scala 3, specifying tokens such as whitespace, identifiers, literals, and escape sequences. It introduces rules for character classes including Unicode categories, printable characters, escape sequences, operators, and identifier formats. No runtime dependencies are required, but familiarity with EBNF notation and Unicode categories is expected. Input for this grammar includes source code text; output is the tokenization of valid Scala 3 sequences. Limitations include its informal role—EBNF here serves as reference and is not directly executable.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/syntax.md#_snippet_0\n\nLANGUAGE: EBNF\nCODE:\n```\nwhiteSpace       ::=  ‘\\u0020’ | ‘\\u0009’ | ‘\\u000D’ | ‘\\u000A’\nupper            ::=  ‘A’ | ... | ‘Z’ | ‘$’ and any character in Unicode categories Lu, Lt or Nl,\n                      and any character in Unicode categories Lo and Lm that doesn\\'t have\n                      contributory property Other_Lowercase\nlower            ::=  ‘a’ | ... | ‘z’ | ‘_’ and any character in Unicode category Ll,\n                      and any character in Unicode categories Lo or Lm that has contributory\n                      property Other_Lowercase\nletter           ::=  upper | lower\ndigit            ::=  ‘0’ | ... | ‘9’\nparen            ::=  ‘(’ | ‘)’ | ‘[’ | ‘]’ | ‘{’ | ‘}’\ndelim            ::=  ‘`’ | ‘\\'’ | ‘\"’ | ‘.’ | ‘;’ | ‘,’\nopchar           ::=  ‘!’ | ‘#’ | ‘%’ | ‘&’ | ‘*’ | ‘+’ | ‘-’ | ‘/’ | ‘:’ |\n                      ‘<’ | ‘=’ | ‘>’ | ‘?’ | ‘@’ | ‘\\\\’ | ‘^’ | ‘|’ | ‘~’\n                      and any character in Unicode categories Sm or So\nprintableChar    ::=  all characters in [\\u0020, \\u007E] inclusive\nUnicodeEscape    ::=  ‘\\\\’ ‘u’ {‘u’} hexDigit hexDigit hexDigit hexDigit\nhexDigit         ::=  ‘0’ | ... | ‘9’ | ‘A’ | ... | ‘F’ | ‘a’ | ... | ‘f’\ncharEscapeSeq    ::=  ‘\\\\’ (‘b’ | ‘t’ | ‘n’ | ‘f’ | ‘r’ | ‘\"’ | ‘\\'’ | ‘\\\\’)\nescapeSeq        ::=  UnicodeEscape | charEscapeSeq\n\nop               ::=  opchar {opchar}\nvarid            ::=  lower idrest\nboundvarid       ::=  varid\n                   |  ‘`’ varid ‘`’\nplainid          ::=  alphaid\n                   |  op\nid               ::=  plainid\n                   |  ‘`’ { charNoBackQuoteOrNewline | escapeSeq } ‘`’\nidrest           ::=  {letter | digit} [‘_’ op]\nquoteId          ::=  ‘\\'’ alphaid\nspliceId         ::=  ‘$’ alphaid ;\n\nintegerLiteral   ::=  (decimalNumeral | hexNumeral | binaryNumeral) [‘L’ | ‘l’]\ndecimalNumeral   ::=  ‘0’ | digit [{digit | ‘_’} digit]\nhexNumeral       ::=  ‘0’ (‘x’ | ‘X’) hexDigit [{hexDigit | ‘_’} hexDigit]\nbinaryNumeral    ::=  ‘0’ (‘b’ | ‘B’) binaryDigit [{binaryDigit | ‘_’} binaryDigit]\n\nfloatingPointLiteral\n                 ::=  [decimalNumeral] ‘.’ digit [{digit | ‘_’} digit] [exponentPart] [floatType]\n                   |  decimalNumeral exponentPart [floatType]\n                   |  decimalNumeral floatType\nexponentPart     ::=  (‘E’ | ‘e’) [‘+’ | ‘-’] digit [{digit | ‘_’} digit]\nfloatType        ::=  ‘F’ | ‘f’ | ‘D’ | ‘d’\n\nbooleanLiteral   ::=  ‘true’ | ‘false’\n\ncharacterLiteral ::=  ‘\\'’ (charNoQuoteOrNewline | escapeSeq) ‘\\'’\n\nstringLiteral    ::=  ‘\"’ {stringElement} ‘\"’\n                   |  ‘\"\"\"’ multiLineChars ‘\"\"\"’\nstringElement    ::=  charNoDoubleQuoteOrNewline\n                   |  escapeSeq\nmultiLineChars   ::=  {[‘\"’] [‘\"’] charNoDoubleQuote} {‘\"’}\n\ninterpolatedString\n                 ::=  alphaid ‘\"’ {[‘\\\\’] interpolatedStringPart | ‘\\\\\\\\’ | ‘\\\\\"’} ‘\"’\n                   |  alphaid ‘\"\"\"’ {[‘\"’] [‘\"’] char \\ (‘\"’ | ‘\\$’) | escape} {‘\"’} ‘\"\"\"’\ninterpolatedStringPart\n                 ::= printableChar \\ (‘\"’ | ‘$’ | ‘\\\\’) | escape\nescape           ::=  ‘\\$\\$’\n                   |  ‘\\$\"’\n                   |  ‘\\$’ alphaid\n                   |  ‘\\$’ BlockExpr\nalphaid          ::=  upper idrest\n                   |  varid\n\ncomment          ::=  ‘/*’ “any sequence of characters; nested comments are allowed” ‘*/’\n                   |  ‘//’ “any sequence of characters up to end of line”\n\nnl               ::=  “new line character”\nsemi             ::=  ‘;’ |  nl {nl}\n```\n\n----------------------------------------\n\nTITLE: Declaring Qualified Private Field in Scala 3\nDESCRIPTION: This Scala code snippet demonstrates how to declare a private field with an explicit qualifier for the enclosing class to ensure the field is accessible via reflection. This approach is recommended as a workaround for the removal of private[this], which previously guaranteed field generation. The example defines a class 'C' with a parameter 'x' and a qualified private val 'field' that calculates a derived value. It also shows a dependent val 'retained' computed from 'field'. The snippet highlights the importance of qualifying private members with the class name when reflection access is needed after the deprecation of private[this].\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/this-qualifier.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass C(x: Int):\n  private[C] val field = x + 1\n    // [C] needed if `field` is to be accessed through reflection\n  val retained = field * field\n```\n\n----------------------------------------\n\nTITLE: Implementing a Type-Safe Evaluator in Scala\nDESCRIPTION: A type-safe evaluator function for arithmetic terms that uses pattern matching. The function demonstrates how type parameters of enclosing methods can acquire new bounds through pattern matching for type safety.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\ndef eval[T](t: Term[T]): T = t match {\n  case Lit(n)        => n\n  case Succ(u)       => eval(u) + 1\n  case IsZero(u)     => eval(u) == 0\n  case If(c, u1, u2) => eval(if (eval(c)) u1 else u2)\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding Expressions to Context Function Literals in Scala\nDESCRIPTION: Illustrates how expressions expected to have a context function type are implicitly expanded to context function literals with arbitrary parameter names, allowing usage of the context parameters inside the expression. This shows compiler behavior for rewriting expressions to context function types before typechecking.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/context-functions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n(x_1: T1, ..., x_n: Tn) ?=> E\n```\n\n----------------------------------------\n\nTITLE: Scala 3 NamedTuple.From Type for Extracting Named Tuple Types from Case Classes\nDESCRIPTION: Describes the From type in NamedTuple object, which converts case classes and certain types into their corresponding named tuple types by extracting their fields. It illustrates usage with a City case class to produce a named tuple of field names and types, enabling dynamic field access via selectDynamic.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/named-tuples.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntype From[T] <: AnyNamedTuple\n```\n\n----------------------------------------\n\nTITLE: Calculating Scalar Product using Scala 3 For Loop and Zip\nDESCRIPTION: Defines a Scala 3 function `scalprod` that calculates the scalar (dot) product of two vectors (`Array[Double]`). It uses a `for` loop combined with `zip` to iterate over pairs of corresponding elements (`(x, y)`). The products `x * y` are accumulated imperatively in the `acc` variable.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\ndef scalprod(xs: Array[Double], ys: Array[Double]) = {\n  var acc = 0.0\n  for ((x, y) <- xs zip ys) acc = acc + x * y\n  acc\n}\n```\n\n----------------------------------------\n\nTITLE: Refining Read-only Mode for Capture Set in Scala Type Member\nDESCRIPTION: This snippet refines the capture set of a type member to be explicitly read-only by adding the .rd annotation in a subclass. It demonstrates how updating the mode affects subcapturing and bounds-checking between super and subclass types. Inputs are refined capture sets for the type member; output is a corrected type definition that aligns with read-only subcapture rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass B extends A:\n  type T <: Object^{x.rd}.rd\n```\n\n----------------------------------------\n\nTITLE: Defining By-Name Types in Scala 3 EBNF\nDESCRIPTION: This EBNF rule represents by-name types, indicated as '=> Type', used for by-name term parameters in Scala. By-name types enable call-by-need semantics in method parameter lists and as type arguments. They can only appear in specific contexts (method parameter types or parameterized types). No dependencies besides standard EBNF formalism.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_21\n\nLANGUAGE: ebnf\nCODE:\n```\nByNameType  ::=  ‘=>‘ Type\n```\n\n----------------------------------------\n\nTITLE: Implementing Monoid Instances for String and Int in Scala\nDESCRIPTION: Provides `given` instances for the `Monoid` type class for `String` and `Int`. The `String` instance uses concatenation for `combine` and an empty string for `unit`. The `Int` instance uses addition for `combine` and zero for `unit`. These instances allow `String` and `Int` to be used polymorphically where a `Monoid` is expected.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Monoid[String] with\n  extension (x: String) def combine (y: String): String = x.concat(y)\n  def unit: String = \"\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Monoid[Int] with\n  extension (x: Int) def combine (y: Int): Int = x + y\n  def unit: Int = 0\n```\n\n----------------------------------------\n\nTITLE: Demonstrate Type Harmonization - Scala\nDESCRIPTION: This Scala snippet provides an example demonstrating type harmonization. It shows a collection initialization with mixed literal types (Double, Int, Double), where the Int literal 6 is harmonized (converted) to 6.0 to ensure a consistent element type (Double) for the collection, which would otherwise be inferred as AnyVal.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_48\n\nLANGUAGE: scala\nCODE:\n```\nscala.collection.mutable.ArrayBuffer(5.4, 6, 6.4)\n```\n\n----------------------------------------\n\nTITLE: Invalid Covariant Type Parameter in Contravariant Position\nDESCRIPTION: Example showing illegal use of a covariant type parameter in a contravariant position (method parameter).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Sequence[+A] {\n  def append(x: Sequence[A]): Sequence[A]\n                  // **** error: illegal variance:\n                  // `A' occurs in contravariant position.\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Scala Quoted Staging Compiler in Scala\nDESCRIPTION: This snippet demonstrates how to create an instance of the `staging.Compiler` for run-time multi-stage programming in Scala 3. It requires a Java `ClassLoader` to manage dependencies and load generated code. The code imports necessary components and defines a `given` instance of `Compiler`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.quoted.staging.*\ngiven Compiler = Compiler.make(getClass.getClassLoader)\n```\n\n----------------------------------------\n\nTITLE: Defining Reader Monad Type Alias using Type Lambda in Scala\nDESCRIPTION: Defines the `ConfigDependent` type alias using Scala 3's type lambda syntax: `[Result] =>> Config => Result`. This directly represents the type constructor that takes a `Result` type and produces a `Config => Result` function type, suitable for defining higher-kinded type class instances like `Monad`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\ntype ConfigDependent = [Result] =>> Config => Result\n```\n\n----------------------------------------\n\nTITLE: Error Cases When Misusing Opaque Logarithm Types in Scala\nDESCRIPTION: Illustrates common compile-time errors that occur when trying to directly assign or operate on Logarithm opaque values as if they were Doubles or combining them with mismatched types, emphasizing type separation. The code highlights Scala 3's opaque type enforcement: Logarithm and Double are not interchangeable outside their defining scope, and standard numeric operators are unavailable except via explicit API.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/opaques.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval d: Double = l       // error: found: Logarithm, required: Double\nval l2: Logarithm = 1.0 // error: found: Double, required: Logarithm\nl * 2                   // error: found: Int(2), required: Logarithm\nl / l2                  // error: `/` is not a member of Logarithm\n```\n\n----------------------------------------\n\nTITLE: Defining Alias Given Instance for Reference in Scala 3\nDESCRIPTION: Defines an alias given instance for the type `Context` (without a name) that references an existing value `ctx`. This is Scala 3 syntax to make an existing value implicitly available based on its type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval ctx: Context\ngiven Context = ctx\n```\n\n----------------------------------------\n\nTITLE: Applying Local Type Inference in Scala 3 for Method Invocation - Scala\nDESCRIPTION: Shows an example of local type inference applied to generic method invocations involving the methods `cons` and `nil`. It demonstrates how types are inferred for type parameters based on argument types and expected result types, utilizing constraint solving to find minimal or maximal types that satisfy subtyping constraints. Dependencies include the Scala standard library and the covariant property of the List class. Inputs are invocations of generic methods with or without explicit type arguments; outputs are the inferred type arguments determining the final instantiated method types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_54\n\nLANGUAGE: scala\nCODE:\n```\ndef cons[A](x: A, xs: List[A]): List[A] = x :: xs\ndef nil[B]: List[B] = Nil\n\nval xs = cons(1, nil)\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Overriding Incompatibility\nDESCRIPTION: Demonstrates the new Scala 3 rule where a method defined with `()` cannot override or be overridden by a method defined without parameters. Overriding methods must now match parameter lists exactly, unless they override methods from Java or Scala 2.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/auto-apply.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass A:\n  def next(): Int\n\nclass B extends A:\n  def next: Int // overriding error: incompatible type\n```\n\n----------------------------------------\n\nTITLE: Auto-Boxing Primitive Types with Implicit Conversion in Scala\nDESCRIPTION: This snippet defines an implicit conversion from Int to java.lang.Integer using a given Conversion instance in the style of Scala 3. It demonstrates the auto-boxing pattern commonly provided by the Predef package, using Java's Integer.valueOf method to perform the boxing. This conversion enables seamless interoperability between Scala's primitive types and Java's boxed counterparts.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/conversions.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ngiven int2Integer: Conversion[Int, java.lang.Integer] =\n  java.lang.Integer.valueOf(_)\n```\n\n----------------------------------------\n\nTITLE: Executing Scala 3 Script from Command Line\nDESCRIPTION: This command demonstrates how to execute a Scala 3 source file containing an '@main' annotated definition directly from the command line, passing arguments to the annotated method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-12-18-scala3-m3.md#_snippet_9\n\nLANGUAGE: Bash\nCODE:\n```\n$ scala Main.scala World\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Pair Class in Scala\nDESCRIPTION: Provides a simple definition for a generic `Pair` class with two type parameters `A` and `B`, covariant (+) in both. It has fields `x` and `y` and accessor methods `fst` and `snd`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nclass Pair[+A, +B](x: A, y: B):\n  def fst: A = x\n  def snd: B = y\n```\n\n----------------------------------------\n\nTITLE: Equivalent Function Calls with Multiple Context Clauses in Scala\nDESCRIPTION: Shows how multiple 'using' clauses are matched left-to-right with different equivalent ways to call function 'f'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nf(global)\nf(global)(using ctx)\nf(global)(using ctx)(using sym, kind)\n```\n\n----------------------------------------\n\nTITLE: Eta Expansion with Implicit Parameters in Scala\nDESCRIPTION: This snippet demonstrates eta expansion for methods with an implicit parameter list in Scala 3. The method 'foo' requires an Int and an implicit Double, and returns a Float. An implicit value 'bla' of type Double is defined and will be automatically provided by the compiler. Assigning 'foo' to 'bar' yields a function from Int to Float. Dependencies: Requires a visible implicit Double in scope. Parameters: 'x' (Int). Returns: Float.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/eta-expansion-spec.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef foo(x: Int)(implicit p: Double): Float = ???\nimplicit val bla: Double = 1.0\n\nval bar = foo // val bar: Int => Float = ...\n```\n\n----------------------------------------\n\nTITLE: Ambiguous conversions example in Scala 3\nDESCRIPTION: Example showing how Scala 3 handles ambiguous implicit conversions differently from Scala 2. In Scala 2, by-value parameters take precedence over by-name parameters, but Scala 3 reports an ambiguity error.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-conversions-spec.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimplicit def conv1(x: Int): String = x.toString\nimplicit def conv2(x: => Int): String = x.toString\n\nval x: String = 0 // Compiles in Scala2 (uses `conv1`),\n                  // type error in Scala 3 because of ambiguity.\n```\n\n----------------------------------------\n\nTITLE: Example of Scala Class with Multiple Constructors in Scala\nDESCRIPTION: Shows how to define a Scala class with primary and auxiliary constructors chaining calls as per canonical constructor rules. The LinkedList[A] class has a primary constructor and two auxiliary constructors for convenience. Parameters include head and tail elements. Input: constructor arguments; output: initialized linked list objects. Demonstrates use of this() invocation and member initialization in auxiliary constructors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nclass LinkedList[A]() {\n  var head: A = _\n  var tail: LinkedList[A] = null\n  def this(head: A) = { this(); this.head = head }\n  def this(head: A, tail: LinkedList[A]) = { this(head); this.tail = tail }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Extractor Method Signatures in Scala\nDESCRIPTION: Shows the possible signatures for extractor methods (`unapply`, `unapplySeq`) used in pattern matching. The example demonstrates both basic and advanced forms, including support for generics, multiple using clauses, and an implicit clause for greater flexibility. Required prerequisites are an understanding of Scala's extractor pattern and method signature syntax. The expected input is an instance to extract from, and output is a value representing whether or how to extract.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/pattern-matching.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef unapply(x: T): U\ndef unapplySeq(x: T): U\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef unapply[A, B](using C)(using D)(x: T)(using E)(using F)(implicit y: G): U = ???\n```\n\n----------------------------------------\n\nTITLE: Tracking Flow Typing for Mutable Variables in Scala 3\nDESCRIPTION: Illustrates how flow typing can track the nullability of local mutable variables (`var`) within a method scope, provided they are not assigned in closures. The type of `xs` is refined to `C` inside the `while xs != null` loop, but assignments (like `xs = xs.next`) can change its tracked nullability.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(val x: Int, val next: C | Null)\n\nvar xs: C | Null = C(1, C(2, null))\n// xs is trackable, since all assignments are in the same method\nwhile xs != null do\n  // xs: C\n  val xsx: Int = xs.x\n  val xscpy: C = xs\n  xs = xscpy // since xscpy is non-null, xs still has type C after this line\n  // xs: C\n  xs = xs.next // after this assignment, xs can be null again\n  // xs: C | Null\n```\n\n----------------------------------------\n\nTITLE: Eta-Expansion from Method Type to Function Type in Scala 3 - Scala\nDESCRIPTION: Illustrates the eta-expansion mechanism which converts a method-typed expression into a function-typed expression. This process extracts maximal sub-expressions and replaces them with fresh identifiers, then builds a lambda function with fresh parameter names for each argument type. Eta-expansion preserves call-by-name parameter semantics in the transformation. No specific prerequisites beyond standard Scala syntax are required. Inputs include a method-typed expression `e`; output is an equivalent function-typed expression with preserved semantics.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_56\n\nLANGUAGE: scala\nCODE:\n```\n{ val `x_1` = `e_1`;\n  ...\n  val `x_m` = `e_m`;\n  (`y_1: T_1, ..., y_n: T_n`) => `e'`(`y_1, ..., y_n`)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Method with Custom Main Annotation in Scala\nDESCRIPTION: Example of a method annotated with a custom @myMain annotation that sums numbers. The method declares parameters including a default parameter and varargs, along with documentation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/main-annotation.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n/** Sum all the numbers\n *\n *  @param first Fist number to sum\n *  @param rest The rest of the numbers to sum\n */\n@myMain def sum(first: Int, second: Int = 0, rest: Int*): Int = first + second + rest.sum\n```\n\n----------------------------------------\n\nTITLE: Updating Dotty via Homebrew\nDESCRIPTION: Command to update an existing Homebrew installation of Dotty to the latest version.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-10-16-fourth-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nbrew upgrade dotty\n```\n\n----------------------------------------\n\nTITLE: Upgrading Dotty via Homebrew (Shell)\nDESCRIPTION: Provides the shell command to update an existing Homebrew installation of the Dotty compiler to the latest available version. This command is used when Dotty has already been installed via Homebrew and a newer release is available in the tap.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-12-01-fifth-dotty-milestone-release.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nbrew upgrade dotty\n```\n\n----------------------------------------\n\nTITLE: Defining Operator Extension Methods in Scala\nDESCRIPTION: Illustrates how to define operator-style extension methods for various types using Scala 3 extension syntax. Operators like `<`, `+:`, and `min` are implemented as extension methods with parameters. The snippet shows infix usage for operator-like method calls with custom behavior. Dependencies include the definition of types Elem and Number, and the operator methods must properly implement expected semantics.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nextension (x: String)\n  def < (y: String): Boolean = ...\nextension (x: Elem)\n  def +: (xs: Seq[Elem]): Seq[Elem] = ...\nextension (x: Number)\n  infix def min (y: Number): Number = ...\n\n\"ab\" < \"c\"\n1 +: List(2, 3)\nx min 3\n```\n\n----------------------------------------\n\nTITLE: Defining Top-Level and Definition Syntax in Scala 3 (EBNF)\nDESCRIPTION: This EBNF snippet formalizes the syntax for value, variable, method, type, class, trait, object, enum, given, extension, packaging, and compilation unit definitions in Scala 3. It captures structure and composition of declarations, signatures, template composition, and enum/extension/given/class/object forms, including handling for modifiers, inheritance, template bodies, and block-level structure. Key parameters include names, parameter blocks, types, inheritance, and template content. Used for implementing or validating high-level program structure in Scala 3 parsers. Output is a complete parse definition for top-level and nested declaration forms. Assumes adherence to previous grammar constructs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/syntax.md#_snippet_7\n\nLANGUAGE: EBNF\nCODE:\n```\nRefineDcl         ::=  ‘val’ ValDcl\n                    |  ‘var’ ValDcl\n                    |  ‘def’ DefDcl\n                    |  ‘type’ {nl} TypeDef\nValDcl            ::=  ids ‘:’ Type\nDefDcl            ::=  DefSig ‘:’ Type\n\nDef               ::=  ‘val’ PatDef\n                    |  ‘var’ PatDef\n                    |  ‘def’ DefDef\n                    |  ‘type’ {nl} TypeDef\n                    |  TmplDef\nPatDef            ::=  ids [‘:’ Type] [‘=’ Expr]\n                    |  Pattern2 [‘:’ Type] [‘=’ Expr]                           PatDef(_, pats, tpe?, expr)\nDefDef            ::=  DefSig [‘:’ Type] [‘=’ Expr]                             DefDef(_, name, paramss, tpe, expr)\n                    |  ‘this’ ConstrParamClauses [DefImplicitClause] ‘=’ ConstrExpr     DefDef(_, <init>, vparamss, EmptyTree, expr | Block)\nDefSig            ::=  id [DefParamClauses] [DefImplicitClause]\nTypeDef           ::=  id [HkTypeParamClause] {FunParamClause} TypeAndCtxBounds   TypeDefTree(_, name, tparams, bound\n                       [‘=’ Type]\n\nTmplDef           ::=  ([‘case’] ‘class’ | ‘trait’) ClassDef\n                    |  [‘case’] ‘object’ ObjectDef\n                    |  ‘enum’ EnumDef\n                    |  ‘given’ (GivenDef | OldGivenDef)\nClassDef          ::=  id ClassConstr [Template]                                ClassDef(mods, name, tparams, templ)\nClassConstr       ::=  [ClsTypeParamClause] [ConstrMods] ClsParamClauses        with DefDef(_, <init>, Nil, vparamss, EmptyTree, EmptyTree) as first stat\nConstrMods        ::=  {Annotation} [AccessModifier]\nObjectDef         ::=  id [Template]                                            ModuleDef(mods, name, template)  // no constructor\nEnumDef           ::=  id ClassConstr InheritClauses EnumBody\n\nGivenDef          ::=  [id ':'] GivenSig\nGivenSig          ::=  GivenImpl\n                    |  '(' ')' '=>' GivenImpl\n                    |  GivenConditional '=>' GivenSig\nGivenImpl         ::=  GivenType ([‘=’ Expr] | TemplateBody)\n                    |  ConstrApps TemplateBody\nGivenConditional  ::=  DefTypeParamClause\n                    |  DefTermParamClause\n                    |  '(' FunArgTypes ')'\n                    |  GivenType\nGivenType         ::=  AnnotType1 {id [nl] AnnotType1}\n\nOldGivenDef       ::=  [OldGivenSig] (AnnotType [‘=’ Expr] | StructuralInstance) -- syntax up to Scala 3.5, to be deprecated in the future\nOldGivenSig       ::=  [id] [DefTypeParamClause] {UsingParamClause} ‘:’          -- one of `id`, `DefTypeParamClause`, `UsingParamClause` must be present\nStructuralInstance ::=  ConstrApp {‘with’ ConstrApp} [‘with’ WithTemplateBody]\n\nExtension         ::=  ‘extension’ [DefTypeParamClause] {UsingParamClause}\n                       ‘(’ DefTermParam ‘)’ {UsingParamClause} ExtMethods\nExtMethods        ::=  ExtMethod | [nl] <<< ExtMethod {semi ExtMethod} >>>\nExtMethod         ::=  {Annotation [nl]} {Modifier} ‘def’ DefDef\n                    |  Export\nTemplate          ::=  InheritClauses [TemplateBody]\nInheritClauses    ::=  [‘extends’ ConstrApps] [‘derives’ QualId {‘,’ QualId}]\nConstrApps        ::=  ConstrApp ({‘,’ ConstrApp} | {‘with’ ConstrApp})\nConstrApp         ::=  SimpleType1 {Annotation} {ParArgumentExprs}\nConstrExpr        ::=  SelfInvocation\n                    |  <<< SelfInvocation {semi BlockStat} >>>\nSelfInvocation    ::=  ‘this’ ArgumentExprs {ArgumentExprs}\n\nWithTemplateBody  ::=  <<< [SelfType] TemplateStat {semi TemplateStat} >>>\nTemplateBody      ::=  :<<< [SelfType] TemplateStat {semi TemplateStat} >>>\nTemplateStat      ::=  Import\n                    |  Export\n                    |  {Annotation [nl]} {Modifier} Def\n                    |  Extension\n                    |  Expr1\n                    |  EndMarker\n                    |\nSelfType          ::=  id [‘:’ InfixType] ‘=>’                                  ValDef(_, name, tpt, _)\n                    |  ‘this’ ‘:’ InfixType ‘=>’\n\nEnumBody          ::=  :<<< [SelfType] EnumStat {semi EnumStat} >>>\nEnumStat          ::=  TemplateStat\n                    |  {Annotation [nl]} {Modifier} EnumCase\nEnumCase          ::=  ‘case’ (id ClassConstr [‘extends’ ConstrApps]] | ids)\n\nTopStats          ::=  TopStat {semi TopStat}\nTopStat           ::=  Import\n                    |  Export\n                    |  {Annotation [nl]} {Modifier} Def\n                    |  Extension\n                    |  Packaging\n                    |  PackageObject\n                    |  EndMarker\n                    |\nPackaging         ::=  ‘package’ QualId :<<< TopStats >>>\nPackageObject     ::=  ‘package’ ‘object’ ObjectDef\n\nCompilationUnit   ::=  {‘package’ QualId semi} TopStats\n```\n\n----------------------------------------\n\nTITLE: Evaluating Indentation Violations in Scala 3 - Scala\nDESCRIPTION: This snippet illustrates a violation of Scala 3's first indentation rule where a statement is incorrectly indented left of the previous statement within a brace-delimited block. The compiler flags such cases as errors for missing closing braces. No external dependencies; demonstrates input as a conditional block with misplaced println statements causing indentation error outputs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nif (x < 0) {\n  println(1)\n  println(2)\n\nprintln(\"done\")  // error: indented too far to the left\n```\n\n----------------------------------------\n\nTITLE: Adding Another Overload Causing Ambiguity in Scala\nDESCRIPTION: Introduces a third overloaded definition for `f` that takes parameters of types (`B`, `A`). With this addition, calling `f(a, a)` becomes ambiguous because both `def f(x: A, y: B)` and `def f(x: B, y: A)` are applicable, and neither is more specific than the other according to Scala's specificity rules for these argument types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_52\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: B, y: A) = ...\n```\n\n----------------------------------------\n\nTITLE: Idiomatic Scala Method Calls Without Parentheses\nDESCRIPTION: Demonstrates the idiomatic Scala style that follows the uniform access principle, allowing property-like methods to be called without parentheses.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/auto-apply.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nxs.toString.length\n```\n\n----------------------------------------\n\nTITLE: Translating Conditional Generators in Scala 3 For Comprehensions\nDESCRIPTION: Shows the initial translation step for Scala 3 `for` expressions where a conditional generator (`case p <- e`) is rewritten. It becomes a standard generator (`p <- e`) followed by a call to `withFilter`, ensuring that only elements matching the pattern `p` are processed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\n´p´ <- ´e´.withFilter { case ´p´ => true; case _ => false }\n```\n\n----------------------------------------\n\nTITLE: Applying Context Functions with Given Parameters in Scala\nDESCRIPTION: Demonstrates defining a function `f` with a context function type `ExecutionContext ?=> Int`, showing usage with both explicit and inferred context parameters. Introduces the keyword `given` for defining an implicit ExecutionContext instance. Input is an integer parameter, and output is an integer computed in a context aware of the ExecutionContext.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/context-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ngiven ec: ExecutionContext = ...\n\ndef f(x: Int): ExecutionContext ?=> Int = ...\n\n// calling with explicit context\nf(2)(using ec)   \n// calling with inferred context\nf(2)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Context-Free Syntax Structures - EBNF\nDESCRIPTION: This code snippet provides EBNF grammar rules for context-free structures in Scala 3, detailing construction of literals, identifiers, type declarations, and paths. It shows how higher-level language constructs like types, function types, match types, refinements, and bounds are composed and inter-related. The rules are interdependent, demonstrating recursion and nesting common to language grammars. Prerequisites for understanding include familiarity with EBNF and general parser principles; inputs are token streams and output is successful phrase-level parsing in conformance with Scala 3. Intended for language or tooling implementers—not for direct use in applications.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/syntax.md#_snippet_3\n\nLANGUAGE: EBNF\nCODE:\n```\nSimpleLiteral     ::=  [‘-’] integerLiteral\n                    |  [‘-’] floatingPointLiteral\n                    |  booleanLiteral\n                    |  characterLiteral\n                    |  stringLiteral\nLiteral           ::=  SimpleLiteral\n                    |  interpolatedStringLiteral\n                    |  symbolLiteral\n                    |  ‘null’\n\nQualId            ::=  id {‘.’ id}\nids               ::=  id {‘,’ id}\n\nSimpleRef         ::=  id\n                    |  [id ‘.’] ‘this’\n                    |  [id ‘.’] ‘super’ [ClassQualifier] ‘.’ id\n\nClassQualifier    ::=  ‘[’ id ‘]’\n\nType              ::=  FunType\n                    |  TypTypeParamClause ‘=>>’ Type\n                    |  MatchType\n                    |  InfixType\nFunType           ::=  FunTypeArgs (‘=>’ | ‘?=>’) Type\n                    |  TypTypeParamClause '=>' Type\nFunTypeArgs       ::=  InfixType\n                    |  ‘(’ [ FunArgTypes ] ‘)’\n                    |  FunParamClause\nFunParamClause    ::=  ‘(’ TypedFunParam {‘,’ TypedFunParam } ‘)’\nTypedFunParam     ::=  id ‘:’ Type\nMatchType         ::=  InfixType `match` <<< TypeCaseClauses >>>\nInfixType         ::=  RefinedType {id [nl] RefinedType}\nRefinedType       ::=  AnnotType {[nl] Refinement}\nAnnotType         ::=  SimpleType {Annotation}\n\nSimpleType        ::=  SimpleLiteral\n                    |  ‘?’ TypeBounds\n                    |  id\n                    |  Singleton ‘.’ id\n                    |  Singleton ‘.’ ‘type’\n                    |  ‘(’ [Types] ‘)’\n                    |  Refinement\n                    |  SimpleType TypeArgs\n                    |  SimpleType ‘#’ id\nSingleton         ::=  SimpleRef\n                    |  SimpleLiteral\n                    |  Singleton ‘.’ id\n\nFunArgType        ::=  Type\n                    |  ‘=>’ Type\nFunArgTypes       ::=  FunArgType { ‘,’ FunArgType }\nParamType         ::=  [‘=>’] ParamValueType\nParamValueType    ::=  Type [‘*’]\nTypeArgs          ::=  ‘[’ Types ‘]’\nRefinement        ::=  :<<< [RefineDcl] {semi [RefineDcl]} >>>\nTypeBounds        ::=  [‘>:’ Type] [‘<:’ Type]\nTypeAndCtxBounds  ::=  TypeBounds [':' ContextBounds]\nContextBounds     ::=  ContextBound\n                    |  ContextBound ':' ContextBounds         -- to be deprecated\n                    |  '{' ContextBound {',' ContextBound} '}'\nContextBound      ::=  Type ['as' id]\nTypes             ::=  Type {‘,’ Type}\n```\n\n----------------------------------------\n\nTITLE: Dependent Typing with Match Types in Method Definition\nDESCRIPTION: This code provides a dependently typed Scala method `leafElem[X](x: X): LeafElem[X]`, where the return type is a match type `LeafElem[X]`. The method pattern matches on the input `x` to return specific element types, with the return type inferred from the match type. The example illustrates how match types enable precise, dependently typed methods that adapt their return types based on input patterns.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/match-types.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef leafElem[X](x: X): LeafElem[X] = x match\n  case x: String      => x.charAt(0)\n  case x: Array[t]    => leafElem(x(0))\n  case x: Iterable[t] => leafElem(x.head)\n  case x: AnyVal      => x\n```\n\n----------------------------------------\n\nTITLE: Defining Classes for Parameterized Type Examples in Scala\nDESCRIPTION: Defines several Scala classes (`TreeMap`, `List`, `I`, `F`, `S`, `G`) used as examples in demonstrating well-formed and ill-formed parameterized types. These classes illustrate features like type bounds (`<:`), variance (`+`), higher-kinded types (`M[A]`), and specific type constraints (`K <: String`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nclass TreeMap[A <: Comparable[A], B] { ... }\nclass List[+A] { ... }\nclass I extends Comparable[I] { ... }\n\nclass F[M[A], X] { ... } // M[A] desugars to M <: [A] =>> Any\nclass S[K <: String] { ... }\nclass G[M[Z <: I], I] { ... } // M[Z <: I] desugars to M <: [Z <: I] =>> Any\n```\n\n----------------------------------------\n\nTITLE: EBNF Syntax for Scala Floating Point Literals\nDESCRIPTION: This snippet presents the EBNF grammar for floating point literals in Scala, detailing decimal numerals with fractional parts, optional exponent parts, and optional float-type suffixes. It identifies the valid structure for floating point constants, including notation for exponent and suffix.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_11\n\nLANGUAGE: EBNF\nCODE:\n```\nfloatingPointLiteral  ::=  [decimalNumeral] ‘.’ digit [{digit | ‘_’} digit] [exponentPart] [floatType]\n                        |  decimalNumeral exponentPart [floatType]\n                        |  decimalNumeral floatType\nexponentPart          ::=  (‘E’ | ‘e’) [‘+’ | ‘-’] digit [{digit | ‘_’} digit]\n```\n\n----------------------------------------\n\nTITLE: Defining a Type Alias in Scala\nDESCRIPTION: Demonstrates defining a type alias `T` to `String` within a specific scope in Scala. This example is used to illustrate potential inconsistencies when the same type member is defined differently elsewhere, leading to unsoundness.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-02-17-scaling-dot-soundness.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype T = String\n```\n\n----------------------------------------\n\nTITLE: Defining Syntax of Symmetric Metaprogramming Calculus\nDESCRIPTION: Specifies the grammar for terms (`t`), simple terms (`u`), values (`v`), and types (`T`) within the simplified two-phase metaprogramming calculus. It defines basic constructs like variables, lambdas, applications, quotes (`’t`), and splices (`~t`), restricting the calculus to two stages.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/simple-smp.md#_snippet_0\n\nLANGUAGE: Formal Calculus\nCODE:\n```\nTerms         t  ::=  x                 variable\n                      (x: T) => t       lambda\n                      t t               application\n                      ’t                quote\n                      ~t                splice\n\nSimple terms  u  ::=  x  |  (x: T) => u  |  u u\n\nValues        v  ::=  (x: T) => t       lambda\n                      ’u                quoted value\n\nTypes         T  ::=  A                 base type\n                      T -> T            function type\n                      ’T                quoted type\n```\n\n----------------------------------------\n\nTITLE: Using @unchecked with runtimeChecked for Type Tests\nDESCRIPTION: Shows how to combine `runtimeChecked` on the scrutinee with the `@unchecked` annotation on a type argument *within* a pattern (`::[Int @unchecked]`). This combination suppresses both the exhaustivity warning (handled by `runtimeChecked`) and the unchecked type test warning (handled by `@unchecked`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/runtimeChecked.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> xs.runtimeChecked match {\n     |   case is: ::[Int @unchecked] => is.head\n     | }\nval res1: Int = 1\n```\n\n----------------------------------------\n\nTITLE: Monotonicity Violation in Initialization via Aliasing in Scala\nDESCRIPTION: This Scala example demonstrates how monotonicity can be violated by aliasing a partially initialized object. The `FileReporter` class assigns itself to a field (`ctx.typer.reporter`) outside its own fully initialized scope, exposing partially constructed state and violating the monotonicity principle. Dependencies include traits, constructor arguments, and field assignments in Scala 3. The illustration explains how such aliased references can cause unsafe access to uninitialized fields, which the checker rejects.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/safe-initialization.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntrait Reporter:\n  def report(msg: String): Unit\n\nclass FileReporter(ctx: Context) extends Reporter:\n  ctx.typer.reporter = this                // ctx now reaches an uninitialized object\n  val file: File = new File(\"report.txt\")\n  def report(msg: String) = file.write(msg)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Function Argument Conversion in flatMap - Scala\nDESCRIPTION: Provides an interactive REPL example where a List invokes 'flatMap' with a function whose return value is implicitly converted, showing the utilization of the 'into' modifier in function result context. Input is a List of Int, output is a List of Char; relies on availability of implicit conversion from String to Iterable[Char].\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val xs = List(1, 2, 3)\nscala> xs.flatMap(x => x.toString * x)\nval res2: List[Char] = List(1, 2, 2, 3, 3, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining Legal Pattern Types in Scala 3\nDESCRIPTION: Example class and type definitions used to demonstrate legal pattern types in Match Types, including invariant, covariant, and contravariant type classes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nclass Inv[A]\nclass Cov[+A]\nclass Contra[-A]\n\nclass Base {\n  type Y\n}\n\ntype YExtractor[t] = Base { type Y = t }\ntype ZExtractor[t] = Base { type Z = t }\n\ntype IsSeq[t <: Seq[Any]] = t\n```\n\n----------------------------------------\n\nTITLE: Mapping Structural Member Access and Method Calls to Selectable Methods in Scala\nDESCRIPTION: This snippet explains the transformation rules for structural member access and method calls on values of structural types. Accesses to value members are rewritten to selectDynamic calls with the member name, cast to the expected type. Method calls are rewritten to applyDynamic calls, optionally including Class tag parameters if the second form of applyDynamic is used. It clarifies the handling of dependent method types and points out that implicit conversions or extension methods can provide selectDynamic/applyDynamic implementations even if the static type does not extend Selectable.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types-spec.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nv.selectDynamic(\"a\").asInstanceOf[U]\n```\n\nLANGUAGE: scala\nCODE:\n```\nv.applyDynamic(\"a\")(a11, ..., a1n, ..., aN1, ..., aNn).asInstanceOf[R]\n```\n\nLANGUAGE: scala\nCODE:\n```\nv.applyDynamic(\"a\", c11, ..., c1n, ..., cN1, ... cNn)(a11, ..., a1n, ..., aN1, ..., aNn).asInstanceOf[R]\n```\n\n----------------------------------------\n\nTITLE: Transitivity in Implicit Specificity Based on Inheritance Depth Scala\nDESCRIPTION: Shows a scenario where previous rules for determining more specific implicits based on companion class inheritance violated transitivity, causing order-dependent ambiguity errors. The code defines classes and objects with givens in different inheritance relations to illustrate these rules and their refinements ensuring stable, transitive specificity comparisons.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-resolution.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n  class A extends B\n  object A { given a ... }\n  class B\n  object B extends C { given b ... }\n  class C { given c }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Multi-Argument List Overload Resolution (Scala)\nDESCRIPTION: This Scala code defines two overloaded methods `f` that differ only in the type of the parameter in their second argument list. It then shows a call `f(3)(\"\")` which successfully resolves to the `f` overload accepting `(y: String)` in the second list in Scala 3, whereas Scala 2 would report an ambiguity. This illustrates Scala 3's enhanced overload resolution that considers subsequent parameter lists.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/overload-resolution.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Int)(y: String): Int = 0\ndef f(x: Int)(y: Int): Int = 0\n\nf(3)(\"\")     // ok\n```\n\n----------------------------------------\n\nTITLE: Instantiating Higher-Kinded Types with Type Arguments in Scala\nDESCRIPTION: This snippet illustrates how to instantiate a higher-kinded type 'Rep' with a concrete type argument in Scala 3. The expansion rewrites 'Rep[String]' into a refined type that binds a type argument to a type member, using Scala's type member syntax. No external dependencies are required, but understanding of type members and type projection is expected. The input is a type application like 'Rep[String]', and the output is its representation as a type refinement for use with projection operators.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nRep[String]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nRep { type $hkArg$0 = String } # Apply\n```\n\n----------------------------------------\n\nTITLE: SBT Commands for Scala 3 Compilation, Running, and Testing\nDESCRIPTION: This section lists SBT commands essential for developing with Scala 3, including compiling source files, running classes, testing, and generating documentation. Commands like 'scalac' for compilation, 'scala' for execution, and specialized test commands facilitate project development and quality assurance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/cheatsheet.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nsbt\n```\n\nLANGUAGE: Shell\nCODE:\n```\n`scala3/scalac`\n```\n\nLANGUAGE: Shell\nCODE:\n```\n`scala3/scala`\n```\n\nLANGUAGE: Shell\nCODE:\n```\nscalac ../issues/Playground.scala\n```\n\nLANGUAGE: Shell\nCODE:\n```\nscala Playground\n```\n\nLANGUAGE: Shell\nCODE:\n```\n`repl`\n```\n\nLANGUAGE: Shell\nCODE:\n```\nscala3/scalac -print-tasty Foo.tasty\n```\n\nLANGUAGE: Shell\nCODE:\n```\n`scala3-bootstrapped/test`\n```\n\nLANGUAGE: Shell\nCODE:\n```\n`scala3-bootstrapped/publishLocal`\n```\n\nLANGUAGE: Shell\nCODE:\n```\ntestOnly dotty.tools.dotc.CompilationTests -- *pos\n```\n\nLANGUAGE: Shell\nCODE:\n```\ntestCompilation sample\n```\n\nLANGUAGE: Shell\nCODE:\n```\nscala3-compiler/Test/runMain dotty.tools.printTypes\n```\n\nLANGUAGE: Shell\nCODE:\n```\n`scaladoc/generateScalaDocumentation`\n```\n\nLANGUAGE: Shell\nCODE:\n```\n`scaladoc/generateReferenceDocumentation`\n```\n\n----------------------------------------\n\nTITLE: Defining Scala isEmpty/get Type Structure (R) for Fixed-Arity Extractors\nDESCRIPTION: Defines the structural type `R` required for the return type `U` or a type `S` derived from it in fixed-arity extractors that use the `isEmpty` and `get` methods to signal match success/failure and provide the extracted value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntype R = {\n  def isEmpty: Boolean\n  def get: S\n}\n```\n\n----------------------------------------\n\nTITLE: Using @main Annotation for Simplified Entry Points\nDESCRIPTION: New simplified way to define program entry points using @main annotation in Scala 3, eliminating the need for object wrapper and args parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n@main def test: Unit = println(s\"Hello World\")\n```\n\n----------------------------------------\n\nTITLE: Defining Enums with Value-Parameterized Cases in Scala 3 - Scala\nDESCRIPTION: Demonstrates the final API for enumerations in Scala 3.0.0-M1, showing enums with value-parameterized cases. The example defines an `Opt` enum with cases `Sm` taking a value parameter and `Nn` as a singleton case. The companion objects for case classes now generate precise `apply` and `copy` methods with exact subtype signatures. However, expressions return the widened enum type unless explicitly typed. The snippet also notes that `values` and `valueOf` methods are only available when enums contain exclusively singleton cases, with `fromOrdinal` provided for singleton lookup when mixed cases exist.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-11-09-scala3-m1.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nenum Opt[+T] {\n  case Sm(value: T)\n  case Nn\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject Sm {\n  ...\n  def apply[T](value: T): Sm[T]\n  ...\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> Sm(23)\nval res0: Opt[Int] = Sm(23)\n\nscala> val sm: Sm[23] = Sm(23)\nval sm: Opt.Sm[23] = Sm(23)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> Opt.values\n1 |Opt.values\n  |^^^^^^^^^^\n  |value values is not a member of object Opt.\n  |Although class Opt is an enum, it has non-singleton cases,\n  |meaning a values array is not defined\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> Opt.fromOrdinal(1)\nval res1: Opt[?] = Nn\n```\n\n----------------------------------------\n\nTITLE: Implementing Indentation Width Representation in Scala 3\nDESCRIPTION: This Scala code snippet provides a concrete implementation of the concept of \"indentation widths\" discussed in the text. It defines an `enum` `IndentWidth` with cases `Run` (single character sequence) and `Conc` (concatenated sequences). It includes methods for comparing indentation widths (`<=`, `<`) and a `toString` representation. A companion `object` provides factory methods for creating `Run` instances with caching and a `Zero` instance. This implementation represents the comparison rules described conceptually earlier.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nenum IndentWidth:\n  case Run(ch: Char, n: Int)\n  case Conc(l: IndentWidth, r: Run)\n\n  def <= (that: IndentWidth): Boolean = this match\n    case Run(ch1, n1) =>\n      that match\n        case Run(ch2, n2) => n1 <= n2 && (ch1 == ch2 || n1 == 0)\n        case Conc(l, r)   => this <= l\n    case Conc(l1, r1) =>\n      that match\n        case Conc(l2, r2) => l1 == l2 && r1 <= r2\n        case _            => false\n\n  def < (that: IndentWidth): Boolean =\n    this <= that && !(that <= this)\n\n  override def toString: String =\n    this match\n      case Run(ch, n) =>\n        val kind = ch match\n          case ' '  => \"space\"\n          case '\\t' => \"tab\"\n          case _    => s\"'$ch'-character\"\n        val suffix = if n == 1 then \"\" else \"s\"\n        s\"$n $kind$suffix\"\n      case Conc(l, r) =>\n        s\"$l, $r\"\n\nobject IndentWidth:\n  private inline val MaxCached = 40\n\n  private val spaces = IArray.tabulate(MaxCached + 1)(new Run(' ', _))\n  private val tabs = IArray.tabulate(MaxCached + 1)(new Run('\\t', _))\n\n  def Run(ch: Char, n: Int): Run =\n    if n <= MaxCached && ch == ' ' then\n      spaces(n)\n    else if n <= MaxCached && ch == '\\t' then\n      tabs(n)\n    else\n      new Run(ch, n)\n  end Run\n\n  val Zero = Run(' ', 0)\nend IndentWidth\n```\n\n----------------------------------------\n\nTITLE: Implementing FromExpr for Option Type in Scala 3\nDESCRIPTION: Creates a type class instance that enables pattern matching on quoted Option expressions, extracting the inner value using nested FromExpr instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\ngiven OptionFromExpr: [T: {Type, FromExpr}] => FromExpr[Option[T]]:\n  def unapply(x: Expr[Option[T]])(using Quotes): Option[Option[T]] =\n    x match\n      case '{ Some( ${Expr(x)} ) } => Some(Some(x))\n      case '{ None } => Some(None)\n      case _ => None\n```\n\n----------------------------------------\n\nTITLE: Scala 'erased' modifier syntax and usage examples\nDESCRIPTION: This snippet illustrates the syntax and placement of the 'erased' modifier within Scala 3 code, including variable, method, parameter, class, and trait definitions. It demonstrates how 'erased' can be applied in different contexts and the corresponding code structure.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs-spec.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nerased val x = ...\nerased def f = ...\n\ndef g(erased x: Int) = ...\n\n(erased x: Int) => ...\n\ndef h(x: (erased Int) => Int) = ...\n\nclass K(erased x: Int) { ... }\n\nerased class E {}\n```\n\n----------------------------------------\n\nTITLE: Example Scala 3 For Comprehension: Finding Prime Sum Pairs\nDESCRIPTION: Provides an example Scala 3 `for` comprehension using curly braces syntax. It generates all pairs of numbers (i, j) such that 1 <= j < i < n and their sum (i + j) is prime, according to the `isPrime` function. It utilizes multiple generators (`<-`) and a guard (`if`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\nfor  { i <- 1 until n\n       j <- 1 until i\n       if isPrime(i+j)\n} yield (i, j)\n```\n\n----------------------------------------\n\nTITLE: Defining Type and Value Parameter Syntax in Scala 3 (EBNF)\nDESCRIPTION: This EBNF snippet specifies the structure of type and value parameter clauses for Scala 3 classes, definitions, and types. It outlines syntax for class/definition type parameters (including annotations, variance, and kinds), parameter clauses (including implicit/using/inline/erased modifiers), and related constructs like parameter bounds, modifiers, and how they map to their internal representations. The snippet helps implement parsers and validators for Scala 3's advanced type and parameter system. Inputs are sequences of tokens per the Scala grammar; output is a valid parse structure or AST. Assumes familiarity with EBNF, Scala notation, and language-specific keywords.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/syntax.md#_snippet_5\n\nLANGUAGE: EBNF\nCODE:\n```\nClsTypeParamClause::=  ‘[’ ClsTypeParam {‘,’ ClsTypeParam} ‘]’\nClsTypeParam      ::=  {Annotation} [‘+’ | ‘-’]                                 TypeDef(Modifiers, name, tparams, bounds)\n                       id [HkTypeParamClause] TypeAndCtxBounds                  Bound(below, above, context)\n\nDefTypeParamClause::=  [nl] ‘[’ DefTypeParam {‘,’ DefTypeParam} ‘]’\nDefTypeParam      ::=  {Annotation} id [HkTypeParamClause] TypeAndCtxBounds\n\nTypTypeParamClause::=  ‘[’ TypTypeParam {‘,’ TypTypeParam} ‘]’\nTypTypeParam      ::=  {Annotation} (id | ‘_’) [HkTypeParamClause] TypeBounds\n\nHkTypeParamClause ::=  ‘[’ HkTypeParam {‘,’ HkTypeParam} ‘]’\nHkTypeParam       ::=  {Annotation} [‘+’ | ‘-’] (id  | ‘_’) [HkTypeParamClause]\n                       TypeBounds\n\nClsParamClauses   ::=  {ClsParamClause} [[nl] ‘(’ [‘implicit’] ClsParams ‘)’]\nClsParamClause    ::=  [nl] ‘(’ ClsParams ‘)’\n                    |  [nl] ‘(’ ‘using’ (ClsParams | FunArgTypes) ‘)’\nClsParams         ::=  ClsParam {‘,’ ClsParam}\nClsParam          ::=  {Annotation}                                             ValDef(mods, id, tpe, expr) -- point of mods on val/var\n                       [{Modifier} (‘val’ | ‘var’)] Param\n\nDefParamClauses   ::=  DefParamClause { DefParamClause } -- and two DefTypeParamClause cannot be adjacent\nDefParamClause    ::=  DefTypeParamClause\n                    |  DefTermParamClause\n                    |  UsingParamClause\nConstrParamClauses::=  ConstrParamClause {ConstrParamClause}\nConstrParamClause ::=  DefTermParamClause\n                    |  UsingParamClause\nDefTermParamClause::=  [nl] ‘(’ [DefTermParams] ‘)’\nUsingParamClause  ::=  [nl] ‘(’ ‘using’ (DefTermParams | FunArgTypes) ‘)’\nDefImplicitClause ::=  [nl] ‘(’ ‘implicit’ DefTermParams ‘)’\n\nDefTermParams     ::= DefTermParam {‘,’ DefTermParam}\nDefTermParam      ::= {Annotation} [`erased`] [‘inline’] Param                    ValDef(mods, id, tpe, expr) -- point of mods at id.\nParam             ::=  id ‘:’ ParamType [‘=’ Expr]\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized Java-Compatible Enum in Scala\nDESCRIPTION: Shows how to define a Scala enum that is compatible with Java and includes parameters. This allows enum cases to hold associated data, similar to enums in Java with instance fields.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-06-11-16th-dotty-milestone-release.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nenum B(val gravity: Double) extends java.lang.Enum[B] {\n  case EARTH extends B(9.8)\n  case JUPITER extends B(100)\n  case MOON extends B(4.3)\n  case Foo extends B(10)\n}\n```\n\n----------------------------------------\n\nTITLE: Quote Pattern Matching Traits and Unapply Methods in Scala\nDESCRIPTION: This snippet defines the core traits and methods used internally by the Scala 3 compiler for quote pattern matching. `QuoteMatching` contains `ExprMatch` and `TypeMatch` objects, each with an `unapply` method. These `unapply` methods are the extractors used to match quoted expressions and types against patterns, returning captured variables (like splices) in a tuple. They require an explicit `Expr[Any]` representing the pattern itself as a `given` parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntrait Quotes:\n  self: runtime.QuoteMatching & ...  =>\n  ...\n\ntrait QuoteMatching:\n  object ExprMatch:\n    def unapply[TypeBindings <: Tuple, Tup <: Tuple]\n               (scrutinee: Expr[Any])\n               (using pattern: Expr[Any]): Option[Tup] = ...\n  object TypeMatch:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Error Message for Missing Parentheses in Scala 3\nDESCRIPTION: Displays the error message in Scala 3 when trying to call a nullary method without the required parentheses, showing how auto-application is no longer supported.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/auto-apply.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nnext\n^^^^\nmethod next must be called with () argument\n```\n\n----------------------------------------\n\nTITLE: Defining a GADT for Subtyping Constraints in Scala\nDESCRIPTION: Introduces an `enum SUB[-S, +T]` with a single case `Refl[U]`. Matching on `Refl` introduces a subtyping constraint `S <: T` (specifically, that `U <: U` implies `S <: T` due to variance).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/gadts.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nenum SUB[-S, +T] {\n  case Refl[U]() extends SUB[U, U]\n}\n```\n\n----------------------------------------\n\nTITLE: EBNF Grammar for Basic Definitions in Scala 3\nDESCRIPTION: Provides the Extended Backus-Naur Form (EBNF) grammar rules for various basic definitions allowed in Scala 3. This includes pattern/variable definitions (`PatVarDef`), function definitions (`FunDef`), type definitions (`TypeDef`), opaque type definitions (`OpaqueTypeDef`), and template definitions (`TmplDef`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nPatVarDef   ::=  ‘val’ PatDef\n              |  ‘var’ VarDef\nDef         ::=  PatVarDef\n              |  ‘def’ FunDef\n              |  ‘type’ {nl} TypeDef\n              |  ‘opaque‘ ‘type‘ {nl} OpaqueTypeDef\n              |  TmplDef\n```\n\n----------------------------------------\n\nTITLE: Formal Grammar for Scala 3 Method Syntax\nDESCRIPTION: Presents the formal BNF-like grammar rules defining the structure of method declarations and definitions (DefDcl, DefDef, DefSig) in Scala 3. It details the permitted sequence and structure of type, term, and using parameter clauses (DefParamClauses), including the constraint that type parameter clauses cannot be adjacent.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/generalized-method-syntax.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nDefDcl            ::=  DefSig ‘:’ Type\nDefDef            ::=  DefSig [‘:’ Type] ‘=’ Expr\nDefSig            ::=  id [DefParamClauses] [DefImplicitClause]\nDefParamClauses   ::=  DefParamClause { DefParamClause } -- and two DefTypeParamClause cannot be adjacent\nDefParamClause    ::=  DefTypeParamClause\n                    |  DefTermParamClause\n                    |  UsingParamClause\nDefTypeParamClause::=  [nl] ‘[’ DefTypeParam {‘,’ DefTypeParam} ‘]’\nDefTypeParam      ::=  {Annotation} id [HkTypeParamClause] TypeParamBounds\nDefTermParamClause::=  [nl] ‘(’ [DefTermParams] ‘)’\nUsingParamClause  ::=  [nl] ‘(’ ‘using’ (DefTermParams | FunArgTypes) ‘)’\nDefImplicitClause ::=  [nl] ‘(’ ‘implicit’ DefTermParams ‘)’\nDefTermParams     ::=  DefTermParam {‘,’ DefTermParam}\nDefTermParam      ::=  {Annotation} [‘inline’] Param\nParam             ::=  id ‘:’ ParamType [‘=’ Expr]\n```\n\n----------------------------------------\n\nTITLE: Multiple Extension Methods with Boilerplate in Scala 3\nDESCRIPTION: Example showing the boilerplate when defining multiple extension methods for a type, where each method requires repeating the type and parameter name.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-02-05-22nd-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef (x: Int) toPower (n: Int): Int = ???\ndef (x: Int) squared = ???\ndef (x: Int) asBinaryString = ???\n```\n\n----------------------------------------\n\nTITLE: Nested Splice Desugaring in Scala\nDESCRIPTION: This is the conceptual method signature representing how nested splice operators (`$`) are desugared by the Scala 3 compiler. It is used instead of the top-level `splice` to explicitly pass the `Quotes` context `q` from the outer quote, ensuring the nested splice operates within the correct scope and maintains the correct staging level.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef nestedSplice[T](q: Quotes)(x: q.Nested ?=> Expr[T]): T\n```\n\n----------------------------------------\n\nTITLE: Type Erasure in Pattern Matching in Scala\nDESCRIPTION: Illustrates type erasure in pattern matching where List[String] is erased to List[_] at runtime, which can lead to potential unchecked warnings due to runtime type information limitations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nval x: Any\nx match {\n  case y: List[String] => ...\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Match Expressions Using Infix Operator Syntax in Scala 3\nDESCRIPTION: Demonstrates the new syntax introduced in Dotty 0.21.0-RC1 where `match` can be treated as a left-associative, alphanumeric, infix operator. This allows the result of one match expression to be directly passed as the scrutinee to a subsequent match expression.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nxs match {\n  case Nil => \"empty\"\n  case x :: xs1 => \"nonempty\"\n} match {\n  case \"empty\" => 0\n  case \"nonempty\" => 1\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Definition Example for Option Algebraic Data Type in Scala 3\nDESCRIPTION: Presents a generic enum 'Option' parameterized by covariant type T, modeling an algebraic data type with two cases: 'Some', parameterized by a value of type T, and 'None', a singleton case. This illustrates simple and parameterized enum case usage for ADTs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nenum Option[+T]:\n  case Some(x: T)\n  case None\n```\n\n----------------------------------------\n\nTITLE: Assigning Invalid BigFloat Literal and Resulting Error in Scala\nDESCRIPTION: Example of assigning a literal with a too-large exponent to a BigFloat. The macro-based fromDigits will produce a descriptive compile-time error indicating the issue. Requires all previous macro machinery in place. Input: val x: BigFloat = 1234.45e3333333333; Output: compile-time error.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval x: BigFloat = 1234.45e3333333333\n```\n\n----------------------------------------\n\nTITLE: Equivalent Function Calls with Inferred Arguments in Scala\nDESCRIPTION: Different equivalent ways to call the 'minimum' function with varying levels of explicit context arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nminimum(xs)\nmaximum(xs)(using descending)\nmaximum(xs)(using descending(using intOrd))\n```\n\n----------------------------------------\n\nTITLE: Declaring Root Type Member as Read-only in Scala\nDESCRIPTION: Demonstrates updating the root class to use a read-only mode in a type member's capture set, specifically removing an exclusive capability to allow for the necessary subcapture relationship. This is required when parent classes' capture sets must match a subclass's read-only requirements. Inputs are class type member capture sets; outputs are corrected declarations to ensure subcapture works across the hierarchy.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass A:\n  type T <: Object^{x.rd}.rd\n```\n\n----------------------------------------\n\nTITLE: Desugaring Context Function Literal to Instance in Scala\nDESCRIPTION: This Scala snippet demonstrates how a context function literal `(x1: T1, ..., xn: Tn) ?=> e` is evaluated. It shows the desugared form as an instance creation of the corresponding `ContextFunctionN` trait, implementing the `apply` method with the specified context parameters and body `e`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions-spec.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nnew scala.ContextFunctionN[T1, ..., Tn, T]:\n  def apply(using x1: T1, ..., xn: Tn): T = e\n```\n\n----------------------------------------\n\nTITLE: Using Scala XML Interpolated String Pattern Matching\nDESCRIPTION: Shows an example of using an `xml\"...\"` interpolated string as a pattern within a `case` clause. This pattern is designed to match an XML structure, and it binds variables (`$linktext`) embedded within the interpolated string to corresponding parts of the matched XML value (of type `Node`). Requires the implicit `XMLinterpolation` and extractor defined previously.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ncase xml\"\"\"\n      <body>\n        <a href = \"some link\"> $linktext </a>\n      </body>\n     \"\"\" => ...\n```\n\n----------------------------------------\n\nTITLE: Box Comparison Examples with CanEqual\nDESCRIPTION: Demonstrates valid and invalid comparisons using the CanEqual instance for Box, showing how type safety is enforced.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nnew Box(1) == new Box(1L)   // ok since there is an instance for `CanEqual[Int, Long]`\nnew Box(1) == new Box(\"a\")  // error: can't compare\nnew Box(1) == 1             // error: can't compare\n```\n\n----------------------------------------\n\nTITLE: Inline Method with Inline Parameters\nDESCRIPTION: This snippet demonstrates the use of inline parameters that propagate constant expressions into inline methods, enabling further compile-time reductions. The example `funkyAssertEquals` shows how parameters marked `inline` can be optimized when called with constant expressions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ninline def funkyAssertEquals(actual: Double, expected: =>Double, inline delta: Double): Unit =\n  if (actual - expected).abs > delta then\n    throw new AssertionError(s\"difference between ${expected} and ${actual} was larger than ${delta}\")\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution with Multiple Argument Lists in Scala 3 - Scala\nDESCRIPTION: Demonstrates Scala 3's improved overload resolution that takes all argument lists into account rather than just the first. It allows overloaded functions with different parameter types in multiple argument lists to be resolved correctly, which was ambiguous in Scala 2. The code shows two function definitions with the same first argument list but differing second lists and their valid invocations. This snippet requires Scala 3 and illustrates the modification to overloading as per SLS §6.26.3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/overload-resolution.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Int)(y: String): Int = 0\ndef f(x: Int)(y: Int): Int = 0\n\nf(3)(\"\")     // ok\n```\n\n----------------------------------------\n\nTITLE: Scala syntax change for type parameters of extension methods\nDESCRIPTION: Demonstrates the new syntax for defining extension methods with type parameters, where the type parameters must precede the method name, aligning with the general rule of parameter order. The example shows how to declare an extension method with type parameter `T` for `List[T]` and contrasts it with the previous syntax. This change aims to enhance consistency and readability when defining extension methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-11-04-20th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef [T](xs: List[T]) append (ys: List[T]): List[T] = ...\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef (xs: List[T]) append [T] (ys: List[T]): List[T] = ...\n```\n\nLANGUAGE: Scala\nCODE:\n```\ngiven [T](xs: List[T])\n  def append (ys: List[T]): List[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Implementing `derived` using `Mirror` in Scala 3\nDESCRIPTION: Illustrates the typical signature for a `derived` method within a type class's companion object, used for automatic type class instance derivation. It uses an `inline` definition and requires a `using` (context) parameter of type `Mirror.Of[T]` (or a subtype) to access the structural information of type `T` provided by its compiler-generated Mirror, enabling the generic implementation of the type class instance `TC[T]`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.deriving.Mirror\n\ninline def derived[T](using Mirror.Of[T]): TC[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Visibility of Givens in Package and Object Scope in Scala\nDESCRIPTION: This code demonstrates how package prefixes no longer contribute to the implicit lookup scope in Scala 3. It defines given instances for types A and B in different scopes and notes their visibility for type C, showing that only givens defined in the same or nested scope are included in the search. The snippet assumes definitions of types A, B, and C, and illustrates the key constraint that givens in the package are invisible outside the package via an object reference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/implicit-resolution.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\npackage p\n\ngiven a: A = A()\n\nobject o:\n  given b: B = B()\n  type C\n\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dependencies for Multiple Context Parameters in Scala\nDESCRIPTION: Defines a Universe object with nested context parameters that depend on each other for use with multiple using clauses.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nobject global extends Universe { type Context = ... }\ngiven ctx : global.Context { type Symbol = ...; type Kind = ... }\ngiven sym : ctx.Symbol\ngiven kind: ctx.Kind\n```\n\n----------------------------------------\n\nTITLE: Member Selection Safety Check with Nullable Types in Scala 3\nDESCRIPTION: This example shows that member selection on nullable types is prevented by the compiler. The trim method cannot be called directly on a String | Null type without first checking for nullity.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nx.trim // error: trim is not member of String | Null\n```\n\n----------------------------------------\n\nTITLE: Givens, Old-Style Implicits, and Import Migration Rules in Scala 3\nDESCRIPTION: This snippet outlines migration strategies and import selectors that handle both given and old-style implicits. While not a runnable code snippet, it explains that given selectors can import both types of contextual abstractions during Scala 3.0, with warnings and errors phased in over subsequent versions. The content informs developers about the transition path and legacy compatibility constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/given-imports.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n/*\nA given import selector also brings old style implicits into scope. \nWarnings/errors for old-style implicits via `*` imports begin in Scala 3.1+. \nUse `given` selectors for explicit migration.\n*/\n```\n\n----------------------------------------\n\nTITLE: Defining Enum Companion Object Scala\nDESCRIPTION: Shows how to define an explicit companion object for an enum in Scala 3. The companion object can contain methods and values, and can access enum cases and their members.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nobject Planet:\n  def main(args: Array[String]) =\n    val earthWeight = args(0).toDouble\n    val mass = earthWeight / Earth.surfaceGravity\n    for p <- values do\n      println(s\"Your weight on $p is ${p.surfaceWeight(mass)}\")\nend Planet\n```\n\n----------------------------------------\n\nTITLE: Marking an Enum Case as Deprecated in Scala\nDESCRIPTION: Demonstrates how to mark the `Pluto` enum case as deprecated using the `@deprecated` annotation, providing a reason. This will generate warnings when `Pluto` is used outside the enum's definition scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\n enum Planet(mass: Double, radius: Double):\n   ...\n   case Neptune extends Planet(1.024e+26, 2.4746e7)\n-  case Pluto   extends Planet(1.309e+22, 1.1883e3)\n+\n+  @deprecated(\"refer to IAU definition of planet\")\n+  case Pluto extends Planet(1.309e+22, 1.1883e3)\n end Planet\n```\n\n----------------------------------------\n\nTITLE: Type extractor 'OrNull' for handling nullable unions in Scala\nDESCRIPTION: Defines an extractor object 'OrNull' used to decompose nullable union types into their non-nullable component in Scala's type system. It's used within pattern matching to extract the inner type from a union that may include Null, aiding in nullability analysis.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/explicit-nulls.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase OrNull(tp1) => // if tp is a nullable union: tp1 | Null\n```\n\n----------------------------------------\n\nTITLE: Querying Implicit Scope with `summonFrom` in Scala 3\nDESCRIPTION: Shows how to use `compiletime.summonFrom` in Scala 3 to conditionally execute code based on the presence of specific types in the implicit (given) scope. This replaces the previous `given` matches feature and must be used within an `inline` method or definition. The example demonstrates choosing between logic for `String` or `Int` based on which is available as a `given`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-09-23-19th-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport compiletime.summonFrom\n\ngiven Int = 10\n\n@main inline def Test = summonFrom {\n  case str: String => println(s\"String $str\")\n  case int: Int => println(s\"Int $int\")  // Int 10\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic `Eq` Instance for String Comparisons\nDESCRIPTION: Provides a concrete example of an implicit `Eq` instance definition. `eqString` specifies that `String` values can only be compared with other `String` values, restricting universal comparison for this type. It relies on a predefined `Eq` object likely used as a factory or singleton marker.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-05-05-multiversal-equality.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimplicit def eqString: Eq[String, String] = Eq\n```\n\n----------------------------------------\n\nTITLE: Decompiling Class File with TASTY Frontend (Shell)\nDESCRIPTION: Provides the shell command to decompile a Dotty-compiled class file using the TASTY frontend. This command takes a classpath and classname as arguments and outputs the decompiled Scala code from the TASTY representation embedded in the class file. It requires the Dotty compiler (`dotc`) to be installed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-12-01-fifth-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndotc -decompile -classpath <classpath> <classname>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Mismatch without Explicit Tupling in Scala 3\nDESCRIPTION: Demonstrates that parameter untupling is applied based on the expected function type, not by converting function types. Passing a function value `combiner` of type `(Int, Int) => Int` directly to `xs.map` results in a type mismatch because `map` expects a function compatible with `((Int, Int)) => Int`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval combiner: (Int, Int) => Int = _ + _\nxs.map(combiner)     // Type Mismatch\n```\n\n----------------------------------------\n\nTITLE: Defining Type Application Syntax Using EBNF in Scala\nDESCRIPTION: This snippet uses EBNF notation to define the grammar for type applications in Scala 3 expressions: a 'SimpleExpr' may be immediately followed by 'TypeArgs' to form a type application. The snippet serves to formalize Scala's type application parsing rule. No dependencies are required; this is grammatical documentation and does not execute as code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_11\n\nLANGUAGE: EBNF\nCODE:\n```\nSimpleExpr    ::=  SimpleExpr TypeArgs\n```\n\n----------------------------------------\n\nTITLE: Generated Export Aliases in Scala\nDESCRIPTION: Shows the resulting aliases that are generated from export clauses. The export creates final methods and type aliases that delegate to the original members.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/export.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfinal def scan(): BitMap            = scanUnit.scan()\nfinal def print(bits: BitMap): Unit = printUnit.print(bits)\nfinal type PrinterType              = printUnit.PrinterType\n```\n\n----------------------------------------\n\nTITLE: Standard Compiler Plugin Implementation - Scala\nDESCRIPTION: This snippet defines a standard compiler plugin (`DivideZero`) for Scala 3, which flags integer division by zero as a compile-time error. The plugin extends `StandardPlugin` and registers a single phase (`DivideZeroPhase`) that overrides `transformApply` to detect problematic patterns in the AST. Dependencies include the Scala 3 compiler plugin API and its internal classes. Parameters of interest include plugin options (`initialize`) and the compilation phases' order (`runsAfter`, `runsBefore`). The plugin expects integer division operations in source code and outputs compile-time errors when detecting a divisor of zero; it must be used in nightly or compatible Scala 3 builds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/compiler-plugins.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\npackage dividezero\n\nimport dotty.tools.dotc.ast.Trees.*\nimport dotty.tools.dotc.ast.tpd\nimport dotty.tools.dotc.core.Constants.Constant\nimport dotty.tools.dotc.core.Contexts.Context\nimport dotty.tools.dotc.core.Decorators.*\nimport dotty.tools.dotc.core.StdNames.*\nimport dotty.tools.dotc.core.Symbols.*\nimport dotty.tools.dotc.plugins.{PluginPhase, StandardPlugin}\nimport dotty.tools.dotc.transform.{Pickler, Staging}\n\nclass DivideZero extends StandardPlugin:\n  val name: String = \"divideZero\"\n  override val description: String = \"divide zero check\"\n\n  override def initialize(options: List[String])(using Context): List[PluginPhase] =\n    (new DivideZeroPhase) :: Nil\n\nclass DivideZeroPhase extends PluginPhase:\n  import tpd.*\n\n  val phaseName = \"divideZero\"\n\n  override val runsAfter = Set(Pickler.name)\n  override val runsBefore = Set(Staging.name)\n\n  override def transformApply(tree: Apply)(implicit ctx: Context): Tree =\n    tree match\n      case Apply(Select(rcvr, nme.DIV), List(Literal(Constant(0))))\n      if rcvr.tpe <:< defn.IntType =>\n        report.error(\"dividing by zero\", tree.pos)\n      case _ =>\n        ()\n    tree\nend DivideZeroPhase\n```\n\n----------------------------------------\n\nTITLE: Accessing Scala 3 Preview Features from Non-Preview Scope\nDESCRIPTION: This snippet illustrates the rules for accessing definitions related to preview features from a compilation unit that is *not* enabled with the `-preview` flag. It shows that a non-preview definition which transitively uses a preview feature can be called, but directly referencing a definition marked with `@preview` from outside a preview scope results in a compile-time error.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/preview-defs.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef usePreviewFeatureTransitively = scala.stdlib.usePreviewFeature\ndef usePreviewFeatureDirectly = scala.stdlib.previewFeature // error - referring to preview definition outside preview scope\n```\n\n----------------------------------------\n\nTITLE: Constructor Definitions Formal Grammar in EBNF for Scala 3\nDESCRIPTION: Defines the grammar rules for Scala auxiliary constructor definitions including parameter clauses, constructor expressions as self invocations or blocks with self invocations. Requirements include understanding of constructor invocation semantics and EBNF notation. Inputs are constructor syntax patterns; outputs are syntactically valid auxiliary constructors. Constraints ensure prevention of infinite constructor invocation cycles.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_12\n\nLANGUAGE: ebnf\nCODE:\n```\nFunDef         ::= ‘this’ ParamClause ParamClauses\n                   (‘=’ ConstrExpr | [nl] ConstrBlock)\nConstrExpr     ::= SelfInvocation\n                |  ConstrBlock\nConstrBlock    ::= ‘{’ SelfInvocation {semi BlockStat} ’}’\nSelfInvocation ::= ‘this’ ArgumentExprs {ArgumentExprs}\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Constructor Pattern Syntax (EBNF)\nDESCRIPTION: Presents the EBNF rule for `SimplePattern` representing constructor patterns. This rule, `StableId ‘(’ [Patterns] ‘)’`, shows how a stable identifier (typically a case class name) followed by parenthesized sub-patterns is used to match objects created by that constructor and destructure them into components.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_10\n\nLANGUAGE: ebnf\nCODE:\n```\nSimplePattern   ::=  StableId ‘(’ [Patterns] ‘)’\n```\n\n----------------------------------------\n\nTITLE: Implementing eqProduct for Product Types in Scala\nDESCRIPTION: Defines the `eqProduct` helper function which creates an `Eq[T]` instance for product types (like case classes). It takes a `Mirror.ProductOf[T]` and a list of `Eq` instances for the fields. The `eqv` implementation iterates over the elements (fields) of both product instances and their corresponding `Eq` instances, checking pairwise equality using the `check` helper.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.deriving.Mirror\n\ndef eqProduct[T](p: Mirror.ProductOf[T], elems: List[Eq[_]]): Eq[T] =\n  new Eq[T]:\n    def eqv(x: T, y: T): Boolean =\n      iterator(x).zip(iterator(y)).zip(elems.iterator).forall {  // (5)\n        case ((x, y), elem) => check(elem)(x, y)\n      }\n```\n\n----------------------------------------\n\nTITLE: Defining Classes with Formal Grammar in EBNF\nDESCRIPTION: Specifies the formal grammar rules for Scala class definitions, including the structure of class parameters, annotations, access modifiers, and optional inheritance templates. Dependencies include familiarity with EBNF syntax and Scala core concepts such as classes and annotations. Expected input is the class declaration token sequence; output is an abstract syntax tree compliant with this grammar. Limitations include that this is a syntactical specification and does not include semantic checks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_8\n\nLANGUAGE: ebnf\nCODE:\n```\nTmplDef           ::=  ‘class’ ClassDef\nClassDef          ::=  id [TypeParamClause] {Annotation}\n                       [AccessModifier] ClassParamClauses ClassTemplateOpt\nClassParamClauses ::=  {ClassParamClause}\n                       [[nl] ‘(’ implicit ClassParams ’)’]\nClassParamClause  ::=  [nl] ‘(’ [ClassParams] ’)’\nClassParams       ::=  ClassParam {‘,’ ClassParam}\nClassParam        ::=  {Annotation} {Modifier} [(‘val’ | ‘var’)]\n                       id [‘:’ ParamType] [‘=’ Expr]\nClassTemplateOpt  ::=  ‘extends’ ClassTemplate | [[‘extends’] TemplateBody]\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Quote Type Healing Example\nDESCRIPTION: Demonstrates the 'type healing' process for references to external types within a quote. It shows that a type parameter reference `T` is replaced by an internal type alias `U` pointing to `t.Underlying`, preparing it for further transformation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\n'{ List.empty[T] }\n// type healed to\n'{ type U = t.Underlying; List.empty[U] }\n```\n\n----------------------------------------\n\nTITLE: Using Derived Eq Instances via Extension Method in Scala\nDESCRIPTION: Defines an `===` extension method that uses an implicit `Eq[T]` instance (potentially derived by the macro) to compare two values of type `T`, providing a convenient syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation-macro.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nextension [T](inline x: T)\n   inline def === (inline y: T)(using eq: Eq[T]): Boolean = eq.eqv(x, y)\n```\n\n----------------------------------------\n\nTITLE: Previous desugaring of for-comprehensions with pure aliases in Scala\nDESCRIPTION: This snippet shows how for-comprehensions with aliases were previously desugared by the Scala compiler. A comprehension with a generator and a following alias is transformed into a map call that wraps the generator and alias into a tuple, followed by another map to extract and combine them. This approach incurs additional allocations and method calls, making it less efficient.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/preview/better-fors.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  a <- doSth(arg)\n  b = a\n} yield a + b\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndoSth(arg).map { a =>\n  val b = a\n  (a, b)\n}.map { case (a, b) =>\n  a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Collective Extension Methods Syntax in Scala 3\nDESCRIPTION: New syntax for collective extension methods that reduces boilerplate by defining multiple methods for a type in a single block, demonstrated with list operations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-02-05-22nd-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nextension listOps on [T](xs: List[T]) {\n  def second = xs.tail.head\n  def third: T = xs.tail.tail.head\n}\n\nval list = List(1, 2, 3)\nprintln(s\"Second: ${list.second}\")  // 2\nprintln(s\"Third: ${list.third}\")  // 3\n```\n\n----------------------------------------\n\nTITLE: Bit Structure Representation for Scala 3 Compiler Flags\nDESCRIPTION: Visually represents the internal bit layout of Scala 3 compiler flags, which are `Long` values encapsulated by the `FlagSet` value class. Specific bits indicate whether a flag is applicable to types, terms, or both. This example shows placeholder bits for the flag itself and the term/type validity indicators.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/dotc-scalac.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n000..0001000..01\n        ^     ^^\n        flag  | \\\n              |  valid for term\n              valid for type\n```\n\n----------------------------------------\n\nTITLE: Defining and Importing Givens in Scala 3\nDESCRIPTION: This snippet demonstrates the definition of a type class, the creation of a given instance, and various import statements to selectively import regular members and given instances from an object. Dependencies include an understanding of Scala 3 given/using and import mechanisms. Inputs and outputs depend on the presence of type class instances; the snippet focuses on namespace control and instance visibility.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/given-imports.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject A:\n  class TC\n  given tc: TC = ???\n  def f(using TC) = ???\n\nobject B:\n  import A.*\n  import A.given\n  ...\n```\n\n----------------------------------------\n\nTITLE: Detecting Uninitialized Field Access via Function Capture in Scala\nDESCRIPTION: This Scala snippet shows an initialization issue involving functions that capture references to fields or methods. The parent class `Parent` has a function field `f` that captures `this.message`. The child class `Child` overrides `message` to return `b`, but `b` is not yet initialized when `f` is called during the `Child`'s initialization (`val a = f()`). The checker flags `b` as being accessed before initialization.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/safe-initialization.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Parent:\n  val f: () => String = () => this.message\n  def message: String\n\nclass Child extends Parent:\n  val a = f()\n  val b = \"hello\"           // error\n  def message: String = b\n```\n\n----------------------------------------\n\nTITLE: Sorting Function Using Implicit Conversions\nDESCRIPTION: Defines a `sort` method that sorts a list of elements of type `A` by requiring an implicit conversion `A => Ordered[A]`. When applied to a list of lists of integers, the compiler infers the implicit conversions through nested implicit parameters, facilitating recursive sorting. The example demonstrates implicit argument passing and inference in a nested context.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/07-implicits.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef sort[A](xs: List[A])(implicit a2ordered: A => Ordered[A]) = ...\n\nsort(yss)\n```\n\n----------------------------------------\n\nTITLE: Manual TypeTest Instance Creation in Scala\nDESCRIPTION: Provides an example of manually creating a `TypeTest` instance for concrete types (`Any`, `String`). This demonstrates how the `unapply` method performs the runtime check (in this case, a standard `case s: String`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval tt: TypeTest[Any, String] =\n  new TypeTest[Any, String]:\n    def unapply(s: Any): Option[s.type & String] = s match\n      case s: String => Some(s)\n      case _ => None\n\nf[AnyRef, String](\"acb\")(using tt)\n```\n\n----------------------------------------\n\nTITLE: Inferring Complex Context Arguments in Scala\nDESCRIPTION: Shows how to create and pass a derived context parameter 'descending' that transforms an existing Ord[T] instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef descending[T](using asc: Ord[T]): Ord[T] = new Ord[T]:\n  def compare(x: T, y: T) = asc.compare(y, x)\n\ndef minimum[T](xs: List[T])(using Ord[T]) =\n  maximum(xs)(using descending)\n```\n\n----------------------------------------\n\nTITLE: Null-Adjusting Java Fields and Methods for Scala Interop - Scala\nDESCRIPTION: This Scala code shows the result of translating a Java class with a reference (String) and a value (Int) field into Scala, following nullification rules. The reference type `String` is made nullable while the value type `Int` is left as-is, exemplifying Scala 3's compiler logic for interoperating with Java reference and value types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nclass C:\n  val s: String?\n  val x: Int\n\n```\n\n----------------------------------------\n\nTITLE: Using Match Types with Examples of Type Reduction\nDESCRIPTION: Demonstrates how match types reduce to different types based on their input types. Shows concrete examples of the Elem type applied to various types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/match-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nElem[String]       =:=  Char\nElem[Array[Int]]   =:=  Int\nElem[List[Float]]  =:=  Float\nElem[Nil.type]     =:=  Nothing\n```\n\n----------------------------------------\n\nTITLE: Implicit TypeTest Pattern Matching in Scala (Compiler Synth)\nDESCRIPTION: Shows the equivalent code to the explicit `TypeTest` usage (Snippet 4) when the compiler automatically synthesizes the `TypeTest` call. If a contextual `TypeTest[X, Y]` is available, the compiler transforms `case x: Y` and `case x @ Y(_)` into `tt(x)` equivalents.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef f[X, Y](x: X)(using TypeTest[X, Y]): Option[Y] = x match\n  case x @ Y(1) => Some(x)\n  case x: Y => Some(x)\n  case _ => None\n```\n\n----------------------------------------\n\nTITLE: Defining Internal Scala Types Grammar Using EBNF\nDESCRIPTION: This snippet defines the abstract grammar for internal types in Scala, representing a desugared and simplified form of concrete types for semantic processing. It includes constructs such as designator types, parameterized types, union and intersection types, recursive types, and skolem types. Dependencies include a mechanism for desugaring concrete types into these internal forms. Input consists of parsed concrete type trees; output is the normalized internal type representations used during type checking and compilation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_1\n\nLANGUAGE: EBNF\nCODE:\n```\nType              ::=  ‘AnyKind‘\n                    |  ‘Nothing‘\n                    |  TypeLambda\n                    |  DesignatorType\n                    |  ParameterizedType\n                    |  ThisType\n                    |  SuperType\n                    |  LiteralType\n                    |  ByNameType\n                    |  AnnotatedType\n                    |  RefinedType\n                    |  RecursiveType\n                    |  RecursiveThis\n                    |  UnionType\n                    |  IntersectionType\n                    |  MatchType\n                    |  SkolemType\n\nTypeLambda        ::=  ‘[’ TypeParams ’]’ ‘=>>’ Type\nTypeParams        ::=  TypeParam {‘,’ TypeParam}\nTypeParam         ::=  ParamVariance id TypeBounds\nParamVariance     ::=  ε | ‘+’ | ‘-’\n\nDesignatorType    ::=  Prefix ‘.’ id\nPrefix            ::=  Type\n                    |  PackageRef\n                    |  ε\nPackageRef        ::=  id {‘.’ id}\n\nParameterizedType ::=  Type ‘[’ TypeArgs ’]’\nTypeArgs          ::=  TypeArg {‘,’ TypeArg}\nTypeArg           ::=  Type\n                    |  WilcardTypeArg\nWildcardTypeArg   ::=  ‘?’ TypeBounds\n\nThisType          ::=  classid ‘.’ ‘this‘\nSuperType         ::=  classid ‘.’ ‘super‘ ‘[’ classid ’]’\nLiteralType       ::=  SimpleLiteral\nByNameType        ::=  ‘=>’ Type\nAnnotatedType     ::=  Type Annotation\n\nRefinedType       ::=  Type ‘{’ Refinement ’}’\nRefinement        ::=  ‘type’ id TypeAliasOrBounds\n                    |  ‘def’ id ‘:’ TypeOrMethodic\n                    |  ‘val’ id ‘:’ Type\n\nRecursiveType     ::=  ‘{’ recid ‘=>’ Type ’}’\nRecursiveThis     ::=  recid ‘.’ ‘this‘\n\nUnionType         ::=  Type ｜ Type\nIntersectionType  ::=  Type ＆ Type\n\nMatchType               ::=  Type ‘match’ ‘<:’ Type ‘{’ {TypeCaseClause} ’}’\nTypeCaseClause          ::=  ‘case’ TypeCasePattern ‘=>’ Type\nTypeCasePattern         ::=  TypeCapture\n                          |  TypeCaseAppliedPattern\n                          |  Type\nTypeCaseAppliedPattern  ::=  Type ‘[’ TypeCasePattern { ‘,’ TypeCasePattern } ’]’\nTypeCapture             ::=  (id | ‘_’) TypeBounds\n\nSkolemType        ::=  ‘∃’ skolemid ‘:’ Type\n\nTypeOrMethodic    ::=  Type\n                    |  MethodicType\nMethodicType      ::=  MethodType\n                    |  PolyType\n\nMethodType        ::=  ‘(’ MethodTypeParams ’)’ TypeOrMethodic\nMethodTypeParams  ::=  ε\n                    |  MethodTypeParam {‘,’ MethodTypeParam}\nMethodTypeParam   ::=  id ‘:’ Type\n\nPolyType          ::=  ‘[’ PolyTypeParams ’]’ TypeOrMethodic\nPolyTypeParams    ::=  PolyTypeParam {‘,’ PolyTypeParam}\nPolyTypeParam     ::=  id TypeBounds\n\nTypeAliasOrBounds ::=  TypeAlias\n                    |  TypeBounds\nTypeAlias         ::=  ‘=’ Type\nTypeBounds        ::=  ‘<:’ Type ‘>:’ Type\n```\n\n----------------------------------------\n\nTITLE: Implicit Lazy Val Definition in Scala 2 - Scala\nDESCRIPTION: Shows how to define a lazy implicit val pos of type Position in Scala 2. The value is initialized from tree.sourcePos and is available implicitly. Requires Position class and an accessible tree with sourcePos member.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nlazy implicit val pos: Position = tree.sourcePos\n```\n\n----------------------------------------\n\nTITLE: Explicitly Specifying Context Parameters in Scala 3\nDESCRIPTION: Example showing how to explicitly specify context parameters with the new 'using' keyword syntax at the call site.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-02-05-22nd-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nf(2)(using 20)\n```\n\n----------------------------------------\n\nTITLE: EBNF Syntax Definition for Scala 3 Match Expressions\nDESCRIPTION: Provides the formal syntax definition in Extended Backus–Naur Form (EBNF) for the new Scala 3 match expressions. It defines how `InfixExpr` and `SimpleExpr` can be extended by a `MatchClause`, and the structure of a `MatchClause` itself.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/match-syntax.md#_snippet_3\n\nLANGUAGE: ebnf\nCODE:\n```\nInfixExpr    ::=  ...\n               |  InfixExpr MatchClause\nSimpleExpr   ::=  ...\n               |  SimpleExpr ‘.’ MatchClause\nMatchClause  ::=  ‘match’ ‘{’ CaseClauses ‘}’\n```\n\n----------------------------------------\n\nTITLE: Defining TypeTest Trait in Scala Reflect\nDESCRIPTION: Shows the definition of the `TypeTest` trait in `scala.reflect`. This trait provides an `unapply` method that acts as an extractor, returning the input argument typed as `T` if it passes the runtime type test.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.reflect\n\ntrait TypeTest[-S, T]:\n  def unapply(s: S): Option[s.type & T]\n```\n\n----------------------------------------\n\nTITLE: Using Wildcard Type Arguments in Scala 3 Type Declarations - Scala\nDESCRIPTION: This snippet demonstrates the new Scala 3 syntax for wildcard type arguments by using '?' instead of the previous underscore '_'. The first example creates a list with an unspecified element type, and the second example illustrates using wildcard bounds in a map's key and value types. No special imports are required, but code migration and compatibility should be considered if transitioning from earlier Scala versions or if using the kind-projector plugin. Input types are unspecified, and the output is a generic collection type with bounded or unbounded wildcards; applicable only in Scala 3 or later.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/wildcards.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nList[?]\nMap[? <: AnyRef, ? >: Null]\n```\n\n----------------------------------------\n\nTITLE: Implicit Function Type Syntax in Scala 3\nDESCRIPTION: Shows the syntax for defining an implicit function type, which mirrors implicit function values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimplicit Transaction => Int\n```\n\n----------------------------------------\n\nTITLE: Implicit `TypeTest` Usage in Scala Pattern Matching with Abstract Types\nDESCRIPTION: Illustrates the compiler's automatic handling of `TypeTest`. When a pattern match involves a type test (`x: Y`) or an extractor check (`x @ Y(1)`) on abstract types (`X`, `Y`), the compiler automatically transforms it to use an available contextual `TypeTest[X, Y]` instance provided via `using`, simplifying the syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef f[X, Y](x: X)(using TypeTest[X, Y]): Option[Y] = x match\n  case x @ Y(1) => Some(x)\n  case x: Y => Some(x)\n  case _ => None\n```\n\n----------------------------------------\n\nTITLE: Closure Capturing an External Capability in Scala\nDESCRIPTION: Demonstrates how a lambda function captures the `fs` capability because it's used within the lambda's body (indirectly via `Logger(fs)`). The resulting function type correctly reflects this capture: `{fs} String -> Unit`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef test(fs: FileSystem): {fs} String -> Unit =\n  (x: String) => Logger(fs).log(x)\n```\n\n----------------------------------------\n\nTITLE: isInstanceOf Pattern Match Implementation in Scala\nDESCRIPTION: Demonstrates how the isInstanceOf type test is implemented using pattern matching, showing the equivalent code pattern and explaining type member handling.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n´x´ match {\n  case _: ´T'´ => true\n  case _ => false\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Match Types in Scala 3\nDESCRIPTION: Shows how to create recursive match types that refer to themselves in their definition. The LeafElem example recursively traverses nested structures to find the leaf element type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/match-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntype LeafElem[X] = X match\n  case String => Char\n  case Array[t] => LeafElem[t]\n  case Iterable[t] => LeafElem[t]\n  case AnyVal => X\n```\n\n----------------------------------------\n\nTITLE: Syntax for Declaring Uninitialized Variable in Scala\nDESCRIPTION: This Scala snippet shows the syntax `var x: T = _` which is an exception to the rule requiring all fields to be initialized at the end of the primary constructor. This syntax is used to declare a mutable variable (`var`) without an initial value, which will be initialized later.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/safe-initialization.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nvar x: T = _\n```\n\n----------------------------------------\n\nTITLE: Performing Compile-Time Computation with Inline Match on ADTs in Scala\nDESCRIPTION: Demonstrates using `inline match` within a `transparent inline` function `toInt` to compute the integer value of a Church-encoded natural number (`Nat` ADT) entirely at compile time. The `inline match` recursively evaluates the structure (`Succ` or `Zero`). The result `natTwo` is assigned the precise singleton type `2`, showcasing compile-time computation capabilities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ntrait Nat\ncase object Zero extends Nat\ncase class Succ[N <: Nat](n: N) extends Nat\n\ntransparent inline def toInt(n: Nat): Int =\n  inline n match\n    case Zero     => 0\n    case Succ(n1) => toInt(n1) + 1\n\ninline val natTwo = toInt(Succ(Succ(Zero)))\nval intTwo: 2 = natTwo\n```\n\n----------------------------------------\n\nTITLE: Scala Example Usage and Testing of Derived Eq\nDESCRIPTION: Provides a Scala example demonstrating how to apply the `deriving Eq` clause to an `enum` (`Lst`) and how to summon and test the automatically derived `Eq` instance in a `@main` method. It shows how the compiler generates the necessary boilerplate for derivation and verifies correctness using `assert` statements.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nenum Lst[+T] derives Eq:\n  case Cns(t: T, ts: Lst[T])\n  case Nl\n\nextension [T](t: T) def ::(ts: Lst[T]): Lst[T] = Lst.Cns(t, ts)\n\n@main def test(): Unit =\n  import Lst.*\n  val eqoi = summon[Eq[Lst[Int]]]\n  assert(eqoi.eqv(23 :: 47 :: Nl, 23 :: 47 :: Nl))\n  assert(!eqoi.eqv(23 :: Nl, 7 :: Nl))\n  assert(!eqoi.eqv(23 :: Nl, Nl))\n```\n\n----------------------------------------\n\nTITLE: Calculating Join of Union Types in Scala with Variance Considerations\nDESCRIPTION: This Scala snippet demonstrates how the join (least-upper-bound) of a union type is computed with respect to type constructor variance. Traits and classes are defined to illustrate how the join produces an intersection that preserves structure (e.g., 'C[A ｜ B] ＆ D'). Inputs include trait/class definitions and no external libraries; output is a type relationship that can be used for type inference or conformance checks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\ntrait C[+T]\ntrait D\ntrait E\nclass A extends C[A] with D\nclass B extends C[B] with D with E\n```\n\n----------------------------------------\n\nTITLE: Basic Export Clause Example in Scala 3\nDESCRIPTION: Demonstrates the potential ambiguity with export clauses when one export might depend on another export in the same class. The example shows how export clauses referencing nested members raise questions about elaboration order.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/export.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nclass B { val c: Int }\nobject A { val b = new B }\nexport A.*\nexport b.*\n```\n\n----------------------------------------\n\nTITLE: Bypassing Erasure Restriction with WithoutPreciseParameterTypes\nDESCRIPTION: This Scala snippet shows how extending `Selectable.WithoutPreciseParameterTypes` allows bypassing the erased parameter type check during structural subtyping. This is intended for `Selectable` implementations (like potential multi-method dispatchers) that do not require exact parameter types for reflection, enabling assignments like the one shown without a type error.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types-spec.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ntrait MultiMethodSelectable extends Selectable.WithoutPreciseParameterTypes:\n  // Assume this version of `applyDynamic` can be implemented without knowing\n  // precise parameter types `paramTypes`:\n  def applyDynamic(name: String, paramTypes: Class[_]*)(args: Any*): Any = ???\n\nclass Sink[A] extends MultiMethodSelectable:\n  def put(x: A): Unit = {}\n\nval a = new Sink[String]\nval b: MultiMethodSelectable { def put(x: String): Unit } = a  // OK\n```\n\n----------------------------------------\n\nTITLE: Creating a Template Project for scala3-tasty-inspector Using sbt New (Shell)\nDESCRIPTION: Command to generate a new Scala 3 TASTy inspector project from an official g8 template using sbt version 1.1.5 or higher. This facilitates quickly scaffolding a functional project structure pre-configured for TASTy inspection development.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/tasty-inspect.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nsbt new scala/scala3-tasty-inspector.g8\n```\n\n----------------------------------------\n\nTITLE: Mapping Tuples using a Predefined Function in Scala 3\nDESCRIPTION: Shows how a predefined function (`combine`) accepting multiple arguments can be passed directly to `map` on a list of tuples, leveraging Scala 3's parameter untupling feature.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef combine(i: Int, j: Int) = i + j\nxs.map(combine)\n```\n\n----------------------------------------\n\nTITLE: Runtime Behavior of Erased Definitions in Scala\nDESCRIPTION: Demonstrates how erased values and parameters are completely removed at runtime and not evaluated.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// becomes def methodWithErasedEv(): Int at runtime\ndef methodWithErasedEv(erased ev: Ev): Int = ...\n\ndef evidence1: Ev = ...\nerased def erasedEvidence2: Ev = ... // does not exist at runtime\nerased val erasedEvidence3: Ev = ... // does not exist at runtime\n\n// evidence1 is not evaluated and no value is passed to methodWithErasedEv\nmethodWithErasedEv(evidence1)\n```\n\n----------------------------------------\n\nTITLE: Accessing Exported Members in Scala 3\nDESCRIPTION: Creates an instance of the `Copier` class (defined previously) and calls the exported `scan` and `print` methods. This demonstrates how export aliases defined within a class are accessed like regular members on instances of that class.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval copier = new Copier\ncopier.print(copier.scan())\n```\n\n----------------------------------------\n\nTITLE: Using 'as' Binder in Scala 3 Pattern Matching - Scala\nDESCRIPTION: This set of examples demonstrates the proposed use of the 'as' binder in Scala 3 pattern matching syntax, replacing the deprecated '@' symbol. The 'as' binder allows assignment of a name to a matched pattern directly within case statements. Dependencies include Scala 3, and examples presume standard collection types such as lists and user-defined case classes like Person and Param. Inputs are typical pattern matches on lists; outputs are the bindings of sub-patterns to the provided names, compatible with the new 'as' syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/typeclasses.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\n  xs match\n    case (Person(name, age) as p) :: rest => ...\n\n  tp match\n    case Param(tl, _) :: _ as tparams => ...\n\n  val x :: xs1 as xs = ys.checkedCast\n```\n\n----------------------------------------\n\nTITLE: Implementing control flow with scala.util.boundary and boundary.break in Scala\nDESCRIPTION: This Scala code demonstrates replacing deprecated nonlocal return patterns with scala.util.boundary and boundary.break. The method firstIndex takes a list and an element, and returns the index of the element's first occurrence, or -1 if not found. The boundary scope ensures that break(i) exits the loop immediately upon finding the element without resorting to exceptions. This pattern avoids the pitfalls of nonlocal returns such as performance overhead and leaky exception handling.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/nonlocal-returns.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.boundary, boundary.break\n\ndef firstIndex[T](xs: List[T], elem: T): Int =\n  boundary:\n    for (x, i) <- xs.zipWithIndex do\n      if x == elem then break(i)\n    -1\n```\n\n----------------------------------------\n\nTITLE: Using `?` for Wildcard Types in Scala 3\nDESCRIPTION: Illustrates the use of `?` as syntax for wildcard types in Scala 3, providing an alternative to `_`. This change aims to make `_` available solely for term and type parameters in the future, improving language regularity. The example shows matching a list with an unknown element type using `List[?]`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-09-23-19th-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n@main def Test =\n  val xs: List[Int] = (1 to 10).toList\n  xs match\n    case xss: List[?] => println(s\"It is a list\")\n```\n\n----------------------------------------\n\nTITLE: Executing @main Scala Program with Invalid Argument Type\nDESCRIPTION: Illustrates the automatic type conversion validation performed when running a program defined with `@main`. If a command-line argument cannot be successfully converted to the expected parameter type using the available `FromString` instance, the program terminates with a type-specific error message. Requires a compiled `@main` program.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/main-functions.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n> scala happyBirthday sixty Fred\nIllegal command line: java.lang.NumberFormatException: For input string: \"sixty\"\n```\n\n----------------------------------------\n\nTITLE: Simulating Properties with Custom Getters/Setters in Scala\nDESCRIPTION: Demonstrates property simulation in Scala using a `TimeOfDayVar` class. Private `var` fields (`h`, `m`, `s`) store the state, while public getter (`hours`) and setter (`hours_=`) methods provide controlled access, including validation. Client code interacts with `d.hours` as if it were a public variable, but assignments trigger the setter logic.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass TimeOfDayVar {\n  private var h: Int = 0\n  private var m: Int = 0\n  private var s: Int = 0\n\n  def hours              =  h\n  def hours_= (h: Int)   =  if (0 <= h && h < 24) this.h = h\n                            else throw new DateError()\n\n  def minutes            =  m\n  def minutes_= (m: Int) =  if (0 <= m && m < 60) this.m = m\n                            else throw new DateError()\n\n  def seconds            =  s\n  def seconds_= (s: Int) =  if (0 <= s && s < 60) this.s = s\n                            else throw new DateError()\n}\nval d = new TimeOfDayVar\nd.hours = 8; d.minutes = 30; d.seconds = 0\nd.hours = 25                  // throws a DateError exception\n```\n\n----------------------------------------\n\nTITLE: Implementation of the Summon Method in Scala\nDESCRIPTION: The definition of the 'summon' utility method that retrieves a given instance of type T, implemented as the identity function over a context parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ndef summon[T](using x: T): x.type = x\n```\n\n----------------------------------------\n\nTITLE: Using qualified private for reflection-accessible fields in Scala 3\nDESCRIPTION: This example demonstrates how to ensure a field is retained for reflection access by using private[C] qualifier instead of the now-deprecated private[this]. The field is needed by another instance member, ensuring it is properly retained.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/this-qualifier.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n  class C(x: Int):\n    private[C] val field = x + 1\n      // [C] needed if `field` is to be accessed through reflection\n    val retained = field * field\n```\n\n----------------------------------------\n\nTITLE: Experimental Reference Constraints in Scala 3\nDESCRIPTION: Shows references to experimental vals, defs, and objects and explains that referencing them from non-experimental methods results in compilation errors. Also displays importing and usage restrictions, demonstrating that only experimental methods can call experimental APIs without errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/experimental-defs.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.experimental\n\n@experimental\nval x = ()\n\n@experimental\ndef f() = ()\n\n@experimental\nobject X:\n  def fx() = 1\n\ndef test1: Unit =\n  f() // error: def f is marked @experimental and therefore ...\n  x // error: value x is marked @experimental and therefore ...\n  X.fx() // error: object X is marked @experimental and therefore ...\n  import X.fx\n  fx() // error: object X is marked @experimental and therefore ...\n\n@experimental\ndef test2: Unit =\n  // references to f, x and X are ok because `test2` is experimental\n  f()\n  x\n  X.fx()\n  import X.fx\n  fx()\n```\n\n----------------------------------------\n\nTITLE: Concrete List-Based Table Implementation in Scala Extending Abstract Table\nDESCRIPTION: This class provides a concrete implementation of the `Table` abstract class using a private mutable list to store key-value pairs. The class overrides `get` to find a key in the list and returns an optional value, and `set` to prepend new entries. The default value is passed to the superclass constructor.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nclass ListTable[A, B](defaultValue: B) extends Table[A, B](defaultValue) {\n  private var elems: List[(A, B)] = Nil\n  def get(key: A) = elems.find(_._1 == key).map(_._2)\n  def set(key: A, value: B) = { elems = (key, value) :: elems }\n}\n```\n\n----------------------------------------\n\nTITLE: Opaque Types Meter and Second Represented as Double in Scala 3\nDESCRIPTION: Defines two opaque types Meter and Second as distinct types backed by Double, illustrating that universal equals will not distinguish between them correctly. This motivates the use of Matchable and advanced equality mechanisms to enforce stronger type safety.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/matchable.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nopaque type Meter = Double\ndef Meter(x: Double): Meter = x\n\nopaque type Second = Double\ndef Second(x: Double): Second = x\n```\n\n----------------------------------------\n\nTITLE: Implementing Immutable Array Type in Scala using Opaque Type\nDESCRIPTION: Shows the implementation details of the new immutable array type `scala.IArray[T]`. It uses an `opaque type` alias for `Array[T]` within the companion object `IArray`, and defines `implied` (implicit) extension methods (`apply`, `length`) that delegate to the underlying `Array` methods. The `inline` modifier ensures performance parity.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-04-15-14th-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nopaque type IArray[T] = Array[T]\n\nobject IArray {\n\n  implied arrayOps {\n    inline def (arr: IArray[T]) apply[T] (n: Int): T = (arr: Array[T]).apply(n)\n    inline def (arr: IArray[T]) length[T] : Int = (arr: Array[T]).length\n  }\n  def apply[T: ClassTag](xs: T*): IArray[T] = Array(xs: _*)\n  /*...*/\n}\n```\n\n----------------------------------------\n\nTITLE: Research Compiler Plugin Template - Scala\nDESCRIPTION: This sample outlines the minimal structure required to create a research compiler plugin for Scala 3 by extending `ResearchPlugin`. The class provides required fields (`name`, `description`) and implements the `init` method, which can manipulate the entire compiler phase pipeline using the provided phase list. Dependencies are the core Scala 3 compiler plugin APIs. This template expects plugin options and phase lists, and outputs a (potentially modified) list of phases; real plugins would provide logic inside `init` to customize the pipeline. Available only in nightly or snapshot releases.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/compiler-plugins.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport dotty.tools.dotc.core.Contexts.Context\nimport dotty.tools.dotc.core.Phases.Phase\nimport dotty.tools.dotc.plugins.ResearchPlugin\n\nclass DummyResearchPlugin extends ResearchPlugin:\n  val name: String = \"dummy\"\n  override val description: String = \"dummy research plugin\"\n\n  def init(options: List[String], phases: List[List[Phase]])(implicit ctx: Context): List[List[Phase]] =\n    phases\nend DummyResearchPlugin\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Universal Equality Pitfall Between Opaque Types in Scala\nDESCRIPTION: This code illustrates how universal equality allows comparing two opaque types Meter and Second, both wrapping Double, to produce a true result when the values are equal, even though these types should be logically distinct. No external dependencies. This limitation can be addressed with stricter equality typing features.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/matchable.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nMeter(10).equals(Second(10))\n```\n\n----------------------------------------\n\nTITLE: Method Overloading Clash with By-Name Parameters in Scala\nDESCRIPTION: Presents an example of a compilation error (\"double definition\") that occurs when attempting to overload a method `f` with by-name parameters (`=> String` and `=> Int`). The clash happens because both parameter types erase to `Function0`, resulting in identical method signatures after type erasure.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/targetName.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: => String): Int = x.length\ndef f(x: => Int): Int = x + 1  // error: double definition\n```\n\n----------------------------------------\n\nTITLE: Compiler-Expanded try Expression for Checked Exceptions in Scala\nDESCRIPTION: This snippet demonstrates how a try/catch block involving a checked exception is rewritten by the Scala compiler to introduce an erased CanThrow capability instance. The erased given ctl: CanThrow[LimitExceeded] is available for type-checking but not present in runtime code. This ensures that the call to xs.map(f).sum is type-safe with respect to LimitExceeded. This code relies on the compiletime.erasedValue utility and the presence of language.experimental.saferExceptions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\ntry\n  erased given ctl: CanThrow[LimitExceeded] = compiletime.erasedValue\n  xs.map(f).sum\ncatch case ex: LimitExceeded => -1\n```\n\n----------------------------------------\n\nTITLE: Compiler Error for Class Shadowing in Scala 3\nDESCRIPTION: This Scala 3 compiler error snippet demonstrates the error message produced when defining an inner class with the same name as an inner class in the superclass, highlighting that Scala 3 forbids overriding class definitions and requires distinct inner class names. The snippet includes the line number and caret indicating the error position along with the detailed error message. Dependencies include using the Scala 3 compiler. The input is a class definition with an inner class name matching a superclass inner class; the output is a compilation failure displaying the error message.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/class-shadowing.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n6 |      class Ops {  }\n  |            ^\n  |class Ops cannot have the same name as class Ops in class Base\n  | -- class definitions cannot be overridden\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Parametric Types and Array Extraction in Scala\nDESCRIPTION: This snippet defines a polymorphic function that pattern matches on any value x of type T and attempts to extract an Array[Int]. Dependencies include Scala 3 language features. This highlights how unbounded type parameters allow pattern matching that could lead to runtime safety violations if x is actually an IArray masquerading as immutable.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/matchable.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef f[T](x: T) = x match\n  case a: Array[Int] => a(0) = 0\nf(imm)\n```\n\n----------------------------------------\n\nTITLE: Class Capturing Constructor Capability in Scala\nDESCRIPTION: Illustrates how a class (`Logger`) retains a capability (`fs`) passed through its constructor. Consequently, creating an instance of `Logger` within the `test` function results in a value of type `{xfs} Logger`, reflecting the captured capability.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nclass Logger(using fs: FileSystem):\n  def log(s: String): Unit = ... summon[FileSystem] ...\n\ndef test(xfs: FileSystem): {xfs} Logger =\n  Logger(xfs)\n```\n\n----------------------------------------\n\nTITLE: Importing a Specific Source Version with Scala Language Import in Scala\nDESCRIPTION: This code demonstrates how to specify the desired Scala source compatibility version directly within a source file using the 'scala.language' import statement. It must be the first import and precede any class, object, or method definitions in the file. This approach supersedes the '-source' compiler flag for the affected file, ensuring local control over syntax features for migration or stability purposes. No external libraries beyond the Scala standard library are required; input is implicit via file structure, and output is governed by compiler behavior during compilation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/language-versions/source-compatibility.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage p\nimport scala.language.`future-migration`\n\nclass C { ... }\n```\n\n----------------------------------------\n\nTITLE: Infinite Recursion via Implicit Conversion\nDESCRIPTION: Illustrates a problematic implicit `magic` method that recursively calls itself via implicit `A => Ordered[A]`. When applied to an argument where no suitable implicit exists, it results in infinite implicit expansion. This highlights the issues of recursive implicit definitions and the importance of divergence detection.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/07-implicits.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def magic[A](x: A)(implicit a2ordered: A => Ordered[A]): Ordered[A] =\n  a2ordered(x)\n```\n\n----------------------------------------\n\nTITLE: Defining Evaluation Rules for Symmetric Metaprogramming Calculus\nDESCRIPTION: Describes the small-step evaluation rules (`-->`) for terms in the calculus. These rules specify how terms are reduced, including lambda application (beta reduction), evaluation under application contexts, and evaluation of quoted terms by evaluating their content using the splicing relation (`==>`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/simple-smp.md#_snippet_1\n\nLANGUAGE: Formal Calculus\nCODE:\n```\n            ((x: T) => t) v  -->  [x := v]t\n\n                         t1  -->  t2\n                       ---------------\n                       t1 t  -->  t2 t\n\n                         t1  -->  t2\n                       ---------------\n                       v t1  -->  v t2\n\n                         t1  ==>  t2\n                        -------------\n                        ’t1  -->  ’t2\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Compilation with -optimise Flag in Dotty (Java)\nDESCRIPTION: Generated by Dotty 0.2.0-RC1 with local optimizations enabled (-optimise flag), this Java snippet represents a more efficient compilation, reducing code length and manual tuple allocations. Key improvements include direct computations, minimal tuple use, and more straightforward branching logic. Still, tuple allocation occurs, but performance is enhanced compared to prior outputs. Inputs remain generic; outputs are computed sums or booleans, and reliance on Scala runtime library classes persists.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-07-12-second-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\n// output of 0.2.0-RC1 with -optimise\n\n    public int foo(Object x) {\n        int n;\n        Tuple2 tuple2;\n        CC cC;\n        Object object;\n        if (x instanceof CC && 1 == (n = (cC = (CC)x)._1()) && (object = cC._2()) instanceof CC) {\n            ((CC)object)._1();\n            tuple2 = new Tuple2((Object)BoxesRunTime.boxToInteger((int)1), (Object)BoxesRunTime.boxToInteger((int)2));\n        } else {\n            tuple2 = new Tuple2((Object)BoxesRunTime.boxToInteger((int)42), (Object)BoxesRunTime.boxToInteger((int)43));\n        }\n        Tuple2 tuple22 = tuple2;\n        return BoxesRunTime.unboxToInt((Object)tuple22._1()) + BoxesRunTime.unboxToInt((Object)tuple22._2());\n    }\n\n    public boolean booleans(Object a) {\n        boolean bl = a instanceof CC;\n        boolean bl2 = a instanceof List;\n        new Tuple2((Object)BoxesRunTime.boxToBoolean((boolean)bl), (Object)BoxesRunTime.boxToBoolean((boolean)bl2));\n        new Tuple2((Object)BoxesRunTime.boxToBoolean((boolean)bl), (Object)BoxesRunTime.boxToBoolean((boolean)bl2));\n        if (bl && bl2) {\n            return true;\n        }\n        boolean bl3 = bl;\n        if (bl3) return false;\n        if (bl2) return false;\n        return true;\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala Program with an Explicit `main` Method\nDESCRIPTION: Shows how to define a simple Scala program (`test.HelloWorld`) by creating an object with a `main` method. The `main` method accepts an `Array[String]` for command-line arguments and serves as the program's entry point.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/09-top-level-definitions.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\npackage test\nobject HelloWorld {\n  def main(args: Array[String]) { println(\"Hello World\") }\n}\n```\n\n----------------------------------------\n\nTITLE: Variant Generalized Algebraic Data Types (GADTs) in Scala 3\nDESCRIPTION: Demonstrates support for variant GADTs in Scala 3, using an enum to define a type-safe expression tree with covariant type parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-05-23-15th-dotty-milestone-release.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nenum Expr[+T] {\n  case StrLit(s: String) extends Expr[String]\n  case Pair[A, B](a: Expr[A], b: Expr[B]) extends Expr[(A, B)]\n}\n\ndef eval[T](e: Expr[T]): T = e match {\n  case Expr.StrLit(s) => s\n  case Expr.Pair(a, b) => (eval(a), eval(b))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Mirror Type Class in Scala\nDESCRIPTION: Provides the sealed trait Mirror and its subtypes Product and Sum, which are foundational for representing product and sum types respectively in Scala 3 metaprogramming and automatic derivation. These types capture static type information such as the mirrored type, element types, and labels, as well as methods for constructing instances or determining the ordinal of a case. Key dependencies include Scala 3's scala.deriving and support from automatic compiler generation for enums and case classes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait Mirror:\n\n  /** the type being mirrored */\n  type MirroredType\n\n  /** the type of the elements of the mirrored type */\n  type MirroredElemTypes\n\n  /** The mirrored *-type */\n  type MirroredMonoType\n\n  /** The name of the type */\n  type MirroredLabel <: String\n\n  /** The names of the elements of the type */\n  type MirroredElemLabels <: Tuple\n\nobject Mirror:\n\n  /** The Mirror for a product type */\n  trait Product extends Mirror:\n\n    /** Create a new instance of type `T` with elements\n     *  taken from product `p`.\n     */\n    def fromProduct(p: scala.Product): MirroredMonoType\n\n  trait Sum extends Mirror:\n\n    /** The ordinal number of the case class of `x`.\n     *  For enums, `ordinal(x) == x.ordinal`\n     */\n    def ordinal(x: MirroredMonoType): Int\n\nend Mirror\n```\n\n----------------------------------------\n\nTITLE: Defining Union and Intersection Types in Scala 3 EBNF\nDESCRIPTION: This EBNF segment defines the syntax for union ('Type ｜ Type') and intersection ('Type ＆ Type') types. These constructions enable value types to be formed via type composition using infix operators '|', '&', crucial for modeling unioned or intersected sets of values. Requires understanding of type constructor variance and infix operator precedence; applies only to type grammar, not implementation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_28\n\nLANGUAGE: ebnf\nCODE:\n```\nUnionType         ::=  Type ‘｜‘ Type\nIntersectionType  ::=  Type ‘＆‘ Type\n```\n\n----------------------------------------\n\nTITLE: Using Implicit Compiler Contexts for Dependency Injection - Scala\nDESCRIPTION: Demonstrates the use of implicit Context parameters in compiler functions for dependency injection and phase control in Dotty. It shows how functions accept a Context implicitly named 'ctx' to avoid ambiguities and how explicit context parameters with distinct names like 'ictx' are used to prevent closure capture and space leaks. This approach centralizes configuration and parameter passing within a compiler run, facilitating modular and reusable compiler components.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/overall-structure.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nf(/*normal args*/)(using ctx.withPhase(phase))\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(/*normal parameters*/)(implicit ctx: Context) ...\n```\n\n----------------------------------------\n\nTITLE: Implementing CanEqual with Class Derivation\nDESCRIPTION: Shows how to make a class participate in multiversal equality by using the 'derives' keyword with CanEqual, which restricts equality comparisons to the same type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass T derives CanEqual\n```\n\n----------------------------------------\n\nTITLE: Error When Using Symbol Literals in Scala 3\nDESCRIPTION: A compiler error message showing what happens when trying to use symbol literals in Scala 3. The error suggests using string literals or Symbol() applications instead, with the option to temporarily enable symbol literals with an import statement.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/symlits.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscalac Test.scala\n-- Error: Test.scala:1:25 ------------------------------------------------------------------------------------------------\n\n1 |@main def test = println('abc)\n  |                         ^\n  |                         symbol literal 'abc is no longer supported,\n  |                         use a string literal \"abc\" or an application Symbol(\"abc\") instead,\n  |                         or enclose in braces '{abc} if you want a quoted expression.\n  |                         For now, you can also `import language.deprecated.symbolLiterals` to accept\n  |                         the idiom, but this possibility might no longer be available in the future.\n1 error found\n```\n\n----------------------------------------\n\nTITLE: Implementing Monoid instance for String\nDESCRIPTION: Provides a given instance of `Monoid` for `String` type, defining how to combine strings (concatenation) and the identity element (empty string). Enables using `Monoid[String]` in context bounds and implicit .\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Monoid[String]:\n  extension (x: String) def combine(y: String): String = x.concat(y)\n  def unit: String = \"\"\n```\n\n----------------------------------------\n\nTITLE: Mapping Tuples using Parameter Untupling in Scala 3\nDESCRIPTION: Shows the concise Scala 3 syntax for mapping a list of tuples using parameter untupling. The lambda function `(x, y) => x + y` directly accepts the tuple elements as separate parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nxs.map {\n  (x, y) => x + y\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Conflicts in Scala Traits\nDESCRIPTION: An example showing how conflicting type definitions can occur in Scala's trait inheritance system, which is one of the technical challenges addressed in DOT's type soundness proof.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-02-03-essence-of-scala.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Base { type A }\ntrait Sub1 extends Base { type A = String }\ntrait Sub2 extends Base { type A = Int }\ntrait Bad extends Sub1 with Sub2\n```\n\n----------------------------------------\n\nTITLE: Preventing Capability Retention with @constructorOnly in Scala\nDESCRIPTION: Demonstrates the use of the `@constructorOnly` annotation on a constructor parameter (`fs`) to indicate that the capability should be used only during construction and not retained as a field. This allows the `test2` function to return a pure `NullLogger` type, even though the constructor uses the `fs` capability.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport annotation.constructorOnly\n\nclass NullLogger(using @constructorOnly fs: FileSystem):\n  ...\ndef test2(using fs: FileSystem): NullLogger = NullLogger() // OK\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Compilation with Basic Optimizations in Dotty (Java)\nDESCRIPTION: This Java snippet represents the code generated by Dotty 0.2.0-RC1 (without using the -optimise flag), further optimizing the pattern matching and reducing the number of instructions and allocations compared to previous versions. Key improvements include consolidated conditionals and reduced branching, but tuple creation remains. Inputs and outputs mirror the previous version (generic objects, integers, booleans), with dependencies on Scala's case class representation and utility methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-07-12-second-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\n// output of 0.2.0-RC1 without -optimise\n    public int foo(Object x) {\n        var3_2 = x;\n        if (!(var3_2 instanceof CC)) ** GOTO lbl-1000\n        var4_3 = CC$.MODULE$.unapply((CC)var3_2);\n        s = var5_4 = var4_3._1();\n        if (1 == var5_4 && (var7_6 = var4_3._2()) instanceof CC) {\n            t = CC$.MODULE$.unapply((CC)var7_6)._1();\n            v0 = Tuple2..MODULE$.apply((Object)BoxesRunTime.boxToInteger((int)1), (Object)BoxesRunTime.boxToInteger((int)2));\n        } else lbl-1000: // 2 sources:\n        {\n            v0 = Tuple2..MODULE$.apply((Object)BoxesRunTime.boxToInteger((int)42), (Object)BoxesRunTime.boxToInteger((int)43));\n        }\n        var2_8 = v0;\n        a = BoxesRunTime.unboxToInt((Object)var2_8._1());\n        b = BoxesRunTime.unboxToInt((Object)var2_8._2());\n        return a + b;\n    }\n\n    public boolean booleans(Object a) {\n        Tuple2 tuple2 = Tuple2..MODULE$.apply((Object)BoxesRunTime.boxToBoolean((boolean)(a instanceof CC)), (Object)BoxesRunTime.boxToBoolean((boolean)(a instanceof List)));\n        boolean b1 = BoxesRunTime.unboxToBoolean((Object)tuple2._1());\n        boolean b2 = BoxesRunTime.unboxToBoolean((Object)tuple2._2());\n        Tuple2 tuple22 = Tuple2..MODULE$.apply((Object)BoxesRunTime.boxToBoolean((boolean)b1), (Object)BoxesRunTime.boxToBoolean((boolean)b2));\n        if (tuple22 != null) {\n            boolean bl;\n            boolean bl2 = BoxesRunTime.unboxToBoolean((Object)tuple22._1());\n            if (!bl2) {\n                bl = bl2;\n            } else {\n                if (BoxesRunTime.unboxToBoolean((Object)tuple22._2())) {\n                    return true;\n                }\n                bl = bl2;\n            }\n            if (!bl) {\n                if (false != BoxesRunTime.unboxToBoolean((Object)tuple22._2())) return false;\n                return true;\n            }\n        }\n        return false;\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining FromDigits Exception Types in Scala\nDESCRIPTION: Defines a hierarchy of exceptions rooted in `FromDigitsException`, which extends `NumberFormatException`. Implementations of `FromDigits` should throw these specific exceptions (`NumberTooLarge`, `NumberTooSmall`, `MalformedNumber`) to signal conversion errors when parsing a numeric literal string.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nabstract class FromDigitsException(msg: String) extends NumberFormatException(msg)\n\nclass NumberTooLarge (msg: String = \"number too large\")         extends FromDigitsException(msg)\nclass NumberTooSmall (msg: String = \"number too small\")         extends FromDigitsException(msg)\nclass MalformedNumber(msg: String = \"malformed number literal\") extends FromDigitsException(msg)\n```\n\n----------------------------------------\n\nTITLE: Full Desugaring of Anonymous Structural Instance Creation in Scala\nDESCRIPTION: This code demonstrates the final underlying translation of a Scala anonymous structural type instance. It creates an anonymous class extending 'AnyRef' and providing the 'getName' method, then instantiates it. No parameters are required; this form is rarely written by users directly but underlies Scala's structural instance mechanism. The key output is an object of a compiler-generated (anonymous) type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\n{ class anon$X extends AnyRef{ def getName() = \"aaron\" }; new anon$X }\n```\n\n----------------------------------------\n\nTITLE: Defining and Summoning Givens in Scala 3 (Dotty 0.19)\nDESCRIPTION: Demonstrates the updated syntax for defining `given` instances in Scala 3 (Dotty 0.19+), including anonymous, named, parameterized, and type-parameterized givens. It also shows the use of `summon` (formerly `the`) to retrieve a given instance implicitly. The previous experimental syntax involving `delegate for`, `given as`, and infix `given` has been removed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-09-23-19th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ngiven Int = 10  // Anonymous\ngiven x: String = \"foo\"  // Named\ngiven f(given x: Int): Option[Int] = Some(x * x)  // With given parameters\ngiven [T](given opt: Option[T]): List[T] = opt.toList  // Anonymous with type parameters\n\n@main def Test = println(summon[List[Int]])\n```\n\n----------------------------------------\n\nTITLE: Matching on Opaque Types to Expose Underlying Arrays in Scala\nDESCRIPTION: This snippet demonstrates how pattern matching can break abstraction barriers of opaque types in Scala by treating an IArray as an Array. The code shows a pattern match on an IArray[Int] that exposes its underlying mutable Array, permitting mutation via assignment. Scala 3 standard library is required. This pattern is unsafe because it undermines immutability guarantees.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/matchable.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval imm: IArray[Int] = ...\nimm match\n  case a: Array[Int] => a(0) = 1\n```\n\n----------------------------------------\n\nTITLE: Escaped Exception Capability Example in Scala\nDESCRIPTION: An example demonstrating how capabilities can escape from bounded scopes, where a function returns a closure that might throw an exception even though the exception was caught at the definition site.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/canthrow.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef escaped(xs: Double*): () => Int =\n  try () => xs.map(f).sum\n  catch case ex: LimitExceeded => -1\n```\n\n----------------------------------------\n\nTITLE: Circumventing Opaque Type Abstractions Using Type Casting in Scala\nDESCRIPTION: This snippet shows direct type-cast from an opaque IArray to Array[Int], followed by Array element mutation. No dependencies except the Scala 3 language itself. This approach is less dangerous than pattern matching because asInstanceOf is acknowledged as unsafe, but still exposes the underlying mutable structure of the supposedly immutable IArray.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/matchable.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimm.asInstanceOf[Array[Int]](0) = 1\n```\n\n----------------------------------------\n\nTITLE: Defining the `.nn` Extension Method in Scala\nDESCRIPTION: Provides the definition of a suggested extension method `.nn` that can be used on nullable types (`T | Null`) to assert non-nullity and cast the type to its non-nullable counterpart (`T`). This method throws a NullPointerException if the value is actually `null` at runtime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nextension [T](x: T | Null)\n  inline def nn: T =\n    assert(x != null)\n    x.asInstanceOf[T]\n```\n\n----------------------------------------\n\nTITLE: Example of defining a right-associative extension method in Scala 3\nDESCRIPTION: This code snippet illustrates how to define a right-associative extension method, demonstrating the use of leading, trailing, and other parameters, along with the method body. It highlights the syntax and structure for such methods.\n\nDependencies: Requires Scala 3 syntax support for extension methods. Inputs are extension parameters and method parameters; outputs depend on method implementation.\n\nNote: Used to enable custom operators with right-associative behavior when called.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/right-associative-extension-methods.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nextension (using a: A, b: B)(using c: C)    // <-- leadingUsing\n        (x: X)                            // <-- extensionParam\n        (using d: D)                      // <-- trailingUsing\n  def +:: (y: Y)(using e: E)(z: Z)          // <-- otherParams\n```\n\n----------------------------------------\n\nTITLE: Importing Capture Checking Language Feature in Scala 3\nDESCRIPTION: This snippet shows how to enable the experimental capture checking feature in Scala 3 by importing the language.experimental.captureChecking package. This import is required to activate the capture checking type system extension, which tracks capabilities in values to ensure safe resource usage and prevent capability escape.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport language.experimental.captureChecking\n```\n\n----------------------------------------\n\nTITLE: Subtraits of FromDigits for Different Numeric Formats\nDESCRIPTION: This snippet shows subclasses of FromDigits that support various number literal formats, such as hex with radix, decimal numbers with decimal points, and floating-point with exponents. These subclasses enable flexible literal parsing for custom types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject FromDigits:\n\n  /** A subclass of `FromDigits` that also allows to convert whole\n   *  number literals with a radix other than 10\n   */\n  trait WithRadix[T] extends FromDigits[T]:\n    def fromDigits(digits: String): T = fromDigits(digits, 10)\n    def fromDigits(digits: String, radix: Int): T\n\n  /** A subclass of `FromDigits` that also allows to convert number\n   *  literals containing a decimal point \".\".\n   */\n  trait Decimal[T] extends FromDigits[T]\n\n  /** A subclass of `FromDigits` that allows converting number literals\n   *  containing a decimal point \".\" or an exponent 'e'/'E'.\n   */\n  trait Floating[T] extends Decimal[T]\n```\n\n----------------------------------------\n\nTITLE: Implementing Empty Lazy List in Scala\nDESCRIPTION: Implementation of the empty case for LzyList, which is a singleton object with appropriate implementations of the required methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nobject LzyNil extends LzyList[Nothing]:\n  def isEmpty = true\n  def head = ???\n  def tail = ???\n```\n\n----------------------------------------\n\nTITLE: Changed Semantics of Inline Parameters in Scala 3\nDESCRIPTION: Example demonstrating the relaxed constraint on inline parameters, showing how code with inline parameters is transformed during compilation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-02-05-22nd-dotty-milestone-release.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ninline def sumTwice(a: Int, b: =>Int, inline c: Int) = a + a + b + b + c + c\nsumTwice(f(), g(), h())\n```\n\n----------------------------------------\n\nTITLE: Using the show Method for Human-Readable Output - Scala\nDESCRIPTION: Calls the 'show' method on a compiler tree object and prints its human-readable representation to the console. The 'show' method provides formatted introspection of AST nodes, aiding in debugging and analysis. Requires that the input 'tree' object has an implicit rich wrapper or inherits the 'show' method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nprintln(tree.show)\n```\n\n----------------------------------------\n\nTITLE: Generated Scala Code for Derived Lst Eq Instance\nDESCRIPTION: Shows a simplified representation of the Scala code that is generated by the compiler for the `Eq[Lst[T]]` instance when the `derives Eq` clause is used on the `Lst` enum. It illustrates how the `inline` expansion of `Eq.derived` results in nested calls to `eqSum` and `eqProduct` with lazily cached lists of summoned or derived element instances, reflecting the structure of `Lst` (a sum type of `Cns` and `Nl`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\ngiven derived$Eq[T] => (eqT: Eq[T]) => Eq[Lst[T]] = \n  eqSum(summon[Mirror.Of[Lst[T]]], {/* cached lazily */\n    List(\n      eqProduct(summon[Mirror.Of[Cns[T]]], {/* cached lazily */\n        List(summon[Eq[T]], summon[Eq[Lst[T]]])\n      }),\n      eqProduct(summon[Mirror.Of[Nl.type]], {/* cached lazily */\n        Nil\n      })\n    )\n  })\n```\n\n----------------------------------------\n\nTITLE: Using Polymorphic Functions as Arguments in Scala\nDESCRIPTION: Implements a function `mapSubexpressions` that traverses an `Expr[A]`. It accepts a polymorphic function `f` as an argument, defined with the type `[B] => Expr[B] => Expr[B]`. This allows `f` to operate on subexpressions (`fun` and `arg`) regardless of their specific types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/polymorphic-function-types.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef mapSubexpressions[A](e: Expr[A])(f: [B] => Expr[B] => Expr[B]): Expr[A] =\n  e match\n    case Apply(fun, arg) => Apply(f(fun), f(arg))\n    case Var(n) => Var(n)\n```\n\n----------------------------------------\n\nTITLE: Trait for Synchronized Access to Table Methods in Scala\nDESCRIPTION: This trait augments the `Table` class by wrapping its `get` and `set` methods in `synchronized` blocks to ensure thread-safe access. The methods are marked `abstract override` to allow method composition via mixins, and `super` references statically resolve to the abstract parents.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\ntrait SynchronizedTable[A, B] extends Table[A, B] {\n  abstract override def get(key: A): B =\n    synchronized { super.get(key) }\n  abstract override def set(key: A, value: B) =\n    synchronized { super.set(key, value) }\n}\n```\n\n----------------------------------------\n\nTITLE: Casting and Variance Handling in Scala Arrays - Scala\nDESCRIPTION: Demonstrates the restrictions on covariance in Scala arrays and how to safely cast an Array[String] to Array[Object] using asInstanceOf. It shows that direct assignment between arrays of different parameter types is disallowed even if their element types have a subtype relationship; however, an explicit cast allows such conversions without a ClassCastException.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval xs = new Array[String](2)\n// val ys: Array[Object] = xs   // **** error: incompatible types\nval ys: Array[Object] = xs.asInstanceOf[Array[Object]] // OK\n```\n\n----------------------------------------\n\nTITLE: Adding Parameters with @unroll (V2) and Generated Forwarder in Scala\nDESCRIPTION: Demonstrates updating the `foo` method to version V2 by adding two new parameters (`b` and `l`) with default values. The `@unroll` annotation on parameter `b` triggers the automatic generation of a backward-compatible forwarder method (shown commented) that has the same signature as the V1 method, ensuring clients compiled against V1 remain compatible.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/unrolled-defs.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// V2\nfinal def foo(\n  s: String,\n  i: Int,\n  @unroll b: Boolean = true,\n  l: Long = 0L\n): String = s + i + b + l\n\n// Generated automatically\n`<invisible>` final def foo(\n  s: String,\n  i: Int\n) = foo(s, i, true, 0L)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Indentation Without Braces Leading to Missing Brace Error - Scala\nDESCRIPTION: Demonstrates the second indentation rule enforcement where if significant indentation is disabled or Scala 2 mode is used, an indented sub-block must be followed by a statement with less indentation width. Here, the second println is incorrectly indented causing the compiler to emit an error about a missing opening brace. Dependencies: Scala 3 compiler with indentation mode off or Scala 2 compatibility mode.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nif (x < 0)\n  println(1)\n  println(2)   // error: missing `{`\n```\n\n----------------------------------------\n\nTITLE: Concrete Type Lambdas Syntax in Scala 3 EBNF\nDESCRIPTION: Shows the EBNF grammar for type lambdas in Scala 3's concrete syntax. It details how type lambda parameters are declared with optional annotations, bounds, and type parameter clauses, and how type lambdas are expressed with '=>>' followed by a type body. This is key for expressing higher-kinded type abstractions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_8\n\nLANGUAGE: ebnf\nCODE:\n```\nTypeLambda            ::= TypeLambdaParams ‘=>>’ Type\nTypeLambdaParams      ::=  ‘[’ TypeLambdaParam {‘,’ TypeLambdaParam} ‘]’\nTypeLambdaParam       ::=  {Annotation} (id | ‘_’) [TypeParamClause] TypeBounds\nTypeParamClause       ::=  ‘[’ VariantTypeParam {‘,’ VariantTypeParam} ‘]’\nVariantTypeParam      ::=  {Annotation} [‘+’ | ‘-’] (id | ‘_’) [TypeParamClause] TypeBounds\n```\n\n----------------------------------------\n\nTITLE: Top-Level Opaque Type Alias Scope and Visibility in Scala 3\nDESCRIPTION: Demonstrates the scoping rules for opaque type aliases declared at the top level, where the alias is transparent only within its own source file scope but opaque (non-transparent) within nested objects/classes or other source files. The snippet also explains that top-level definitions are treated as members of an autogenerated package object, affecting visibility accordingly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/opaques-details.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// in test1.scala\nopaque type A = String\nval x: A = \"abc\"\n\nobject obj:\n  val y: A = \"abc\"  // error: found: \"abc\", required: A\n```\n\nLANGUAGE: scala\nCODE:\n```\n// in test2.scala\ndef z: String = x   // error: found: A, required: String\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject test1$package:\n  opaque type A = String\n  val x: A = \"abc\"\n\nobject obj:\n  val y: A = \"abc\"  // error: cannot assign \"abc\" to opaque type alias A\n```\n\n----------------------------------------\n\nTITLE: Illustrative Usage of Reader Monad flatMap in Scala\nDESCRIPTION: Shows the desired syntax for composing `compute` and `show` using a hypothetical `flatMap` operation provided by a Monad instance for functions of type `Config => Result`. This demonstrates how the Reader Monad can chain dependent computations without explicitly passing the `Config` parameter multiple times.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\ndef computeAndShow(i: Int): Config => Unit = compute(i).flatMap(show)\n```\n\n----------------------------------------\n\nTITLE: Reducing Redundant Nullable Types When Translating Java Generics - Scala\nDESCRIPTION: This Scala code represents the result of translating Java generic classes (Box and BoxFactory) according to Scala 3's nullification policy: outer types or container types become nullable (`?`) only where needed, avoiding redundant nullability on type parameters. It showcases modular application of nullification on Java reference types for proper null safety.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nclass Box[T] { def get(): T? }\nclass BoxFactory[T] { def makeBox(): Box[T]? }\n\n```\n\n----------------------------------------\n\nTITLE: Defining Traits with Type Members in Scala 3\nDESCRIPTION: This snippet presents two traits, 'Ord' and 'SemiGroup', each with an associated type 'Self'. The 'SemiGroup' trait defines an extension method 'combine' for 'Self' types. These traits establish a pattern for type classes and extension methods to facilitate algebraic structures in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/scaladoc-testcases/docs/_docs/index.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Ord:\n  type Self\n\ntrait SemiGroup:\n  type Self\n  extension (x: Self) def combine(y: Self): Self\n```\n\n----------------------------------------\n\nTITLE: Mapping Tuples with Parameter Untupling in Scala (New Syntax)\nDESCRIPTION: This snippet shows the new parameter untupling syntax introduced in Scala 3. Instead of using pattern matching ('case'), the function literal directly lists the expected tuple components '(x, y)' as parameters, which are then implicitly extracted from the single tuple argument provided by 'map'. This offers a more concise alternative to pattern matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling-spec.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nxs.map {\n  (x, y) => x + y\n}\n```\n\n----------------------------------------\n\nTITLE: Old Vararg Splice Syntax in Scala 3 - Syntax Error Example\nDESCRIPTION: This snippet shows the deprecated syntax `: _*` for vararg splices in Scala 3, which results in a syntax error. It emphasizes that the old syntax will be phased out and that the new postfix `*` syntax should be used. This highlights the importance of updating legacy code to adhere to the new syntax standards.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/vararg-splices.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n/*!*/ val lst = List(arr: _*)      // syntax error\n      lst match\n        case List(0, 1, xs @ _*)  // ok, equivalent to `xs*`\n```\n\n----------------------------------------\n\nTITLE: Defining and Using an Inline Macro in Scala 3\nDESCRIPTION: Demonstrates the idiomatic way to define a Scala 3 macro using `inline def`. The `powerMacro` function uses a top-level splice calling `powerCode`. The `inline` parameter `n` makes its value available at compile time. User code calls the macro (`power2` calls `powerMacro`) like a regular function, triggering compile-time code generation via `powerCode` and inlining of the result.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n// inline macro definition\ninline def powerMacro(x: Double, inline n: Int): Double =\n  ${ powerCode('x, 'n) }\n\n// user code\ndef power2(x: Double): Double =\n  powerMacro(x, 2) // x * x\n```\n\n----------------------------------------\n\nTITLE: Defining Polymorphic Methods and Functions in Scala\nDESCRIPTION: Compares a standard polymorphic method `foo` with a polymorphic function value `bar`. `bar` is assigned a lambda that explicitly takes a type parameter `A` and then value parameters, demonstrating the syntax for polymorphic function types and values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/polymorphic-function-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// A polymorphic method:\ndef foo[A](xs: List[A]): List[A] = xs.reverse\n\n// A polymorphic function value:\nval bar: [A] => List[A] => List[A]\n//       ^^^^^^^^^^^^^^^^^^^^^^^^^\n//       a polymorphic function type\n       = [A] => (xs: List[A]) => foo[A](xs)\n```\n\n----------------------------------------\n\nTITLE: Processing Block Trees with Context in Scala Typer\nDESCRIPTION: This Scala code snippet from the type checker demonstrates how the context is adapted when processing specific tree nodes. For an `untpd.Block`, it calls `typedBlock`, passing a new context derived from the old one (`ctx.fresh.withNewScope`). This illustrates how entering a new scope requires context modification in the type checking phase.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/contexts.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase tree: untpd.Block => typedBlock(desugar.block(tree), pt)(ctx.fresh.withNewScope)\n```\n\n----------------------------------------\n\nTITLE: Fallback Encoding of Polymorphic Type Aliases as Lambda Traits in Scala\nDESCRIPTION: Handles polymorphic type aliases that cannot be expanded by transforming them into monomorphic type aliases referencing Lambda traits. Lambda traits model type lambdas with type parameters and an 'Apply' type member to represent type application. Includes details on variance annotations and trait hierarchy.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntype List2D[T] = List[List[T]]\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype List2D = Lambda$I { type Apply = List[List[$hkArg$0]] }\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Lambda$I[type $hkArg$0] { type +Apply }\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Lambda$NP[type -$hkArg$0, +$hkArg$1] { type +Apply } extends Lambda$IP with Lambda$NI\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Lambda$IP[type $hkArg$0, +$hkArg$1] { type +Apply } extends Lambda$II\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Lambda$NI[type -$hkArg$0, $hkArg$1] { type +Apply } extends Lambda$II\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Lambda$II[type $hkArg$0, $hkArg$1] { type +Apply }\n```\n\n----------------------------------------\n\nTITLE: Enabling Checked Exceptions with Safer Exceptions in Scala\nDESCRIPTION: This snippet enables the experimental saferExceptions feature in Scala, defines a custom exception LimitExceeded, and demonstrates a function f that can throw this exception. The throws clause signals that f may throw LimitExceeded, which is enforced by the type system, requiring explicit propagation or handling of the exception. The import of language.experimental.saferExceptions is a prerequisite. The limit and f's computation show checked exception integration in mainstream Scala code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nimport language.experimental.saferExceptions\n\nclass LimitExceeded extends Exception\n\nval limit = 10e+10\ndef f(x: Double): Double throws LimitExceeded =\n  if x < limit then x * x else throw LimitExceeded()\n```\n\n----------------------------------------\n\nTITLE: Converting Between Staged Lambdas and Staging Lambdas in Scala 3 Macros\nDESCRIPTION: These snippets provide utility functions to convert between `Expr[T => U]` (staged lambdas existing at the next stage) and `Expr[T] => Expr[U]` (staging lambdas existing at compile time). The `later` function creates a staged lambda from a function on expressions, while `now` creates a staging lambda from a staged lambda, optionally performing beta-reduction. They depend on the Scala 3 macro quoting API, including `Expr.betaReduce` for optimizing expression applications. Inputs are functions working on quoted types and outputs are corresponding staged or staging lambdas.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\ndef later[T: Type, U: Type](f: Expr[T] => Expr[U]): Expr[T => U] =\n  '{ (x: T) => ${ f('x) } }\n\ndef now[T: Type, U: Type](f: Expr[T => U]): Expr[T] => Expr[U] =\n  (x: Expr[T]) => '{ $f($x) }\n\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef now[T: Type, U: Type](f: Expr[T => U]): Expr[T] => Expr[U] =\n  (x: Expr[T]) => Expr.betaReduce('{ $f($x) })\n\n```\n\n----------------------------------------\n\nTITLE: Providing Implicit Conversion for Parameter Untupling in Scala 3\nDESCRIPTION: Illustrates how to define an implicit conversion (`fallback untupling`) that automatically adapts a function like `combiner` (taking multiple arguments) to the required tupled function type `((Int, Int)) => Int`. This allows `xs.map(combiner)` to compile without explicit `.tupled`, provided `implicitConversions` are enabled.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.implicitConversions\ntransparent inline implicit def `fallback untupling`(f: (Int, Int) => Int): ((Int, Int)) => Int =\n  p => f(p._1, p._2)     // use specialized apply instead of unspecialized `tupled`\nxs.map(combiner)\n```\n\n----------------------------------------\n\nTITLE: Using summonFrom to Select Implementation (Scala)\nDESCRIPTION: This code demonstrates calling the `setFor[String]` function (defined using `summonFrom`). Since an `Ordering[String]` is available in the standard library (proven by the `summon` call), `summonFrom` selects the `TreeSet` case. The output confirms that an instance of `TreeSet` was created.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\n// Assuming setFor is defined as in the previous examples\nimport scala.collection.immutable.{HashSet, TreeSet}\nimport scala.compiletime.summonFrom\n\ninline def setFor[T]: Set[T] = summonFrom {\n  case given Ordering[T] => new TreeSet[T]\n  case _                 => new HashSet[T]\n}\n\nsummon[Ordering[String]] // Proves that an Ordering[String] is in scope\n\nprintln(setFor[String].getClass) // prints class scala.collection.immutable.TreeSet\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Compilation with Dotty Linker Global Analysis (Java)\nDESCRIPTION: Produced by the Dotty linker with global analysis disabled, this Java example presents the most optimized translation of the original Scala pattern matching logic. All intermediate tuple allocations are eliminated in favor of simple primitive and boolean computations, resulting in minimal, highly efficient code. Inputs and outputs are as before; the approach maximizes runtime performance by avoiding extraneous object creation or complex branching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-07-12-second-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\n  // output of Dotty linker https://github.com/dotty-linker/dotty/tree/opto\n    public int foo(Object x) {\n         CC cC;\n         int n = 0;\n         int n2 = 0;\n         if (x instanceof CC && 1 == (cC = (CC)x)._1() && cC._2() instanceof CC) {\n             n = 1;\n             n2 = 2;\n         } else {\n             n = 42;\n             n2 = 43;\n         }\n         return n + n2;\n     }\n\n     public boolean booleans(Object a) {\n         boolean bl = a instanceof CC;\n         boolean bl2 = a instanceof List;\n         if (bl && bl2 || !bl && !bl2) {\n             return true;\n         }\n         return false;\n }\n```\n\n----------------------------------------\n\nTITLE: Using '@' Binder in Scala Pattern Matching (Old Syntax) - Scala\nDESCRIPTION: These examples illustrate the previous pattern matching syntax in Scala using the '@' binder, which the proposal aims to replace. The '@' symbol is used to assign names to matched patterns within case statements. The code assumes a Scala environment with access to lists, case classes like Person and Param, and standard pattern matching constructs. Inputs are pattern matching expressions, and outputs are variable bindings resulting from the matched patterns using the '@' syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/typeclasses.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n  xs match\n    case p @ Person(name, age) :: rest => ...\n\n  tp match\n    case tparams @ (Param(tl, _) :: _) => ...\n\n  val xs @ (x :: xs1) = ys.checkedCast\n```\n\n----------------------------------------\n\nTITLE: Illustrating Named Type Argument Restrictions Scala\nDESCRIPTION: Demonstrates that named type arguments (`T = Int`) cannot be used when referring to or instantiating type constructors (classes or traits). Shows examples in type annotations, instantiation, and inheritance, all resulting in errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/named-typeargs-spec.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass C[T]\n\nval x: C[T = Int] = // error\n  new C[T = Int] // error\n\nclass E extends C[T = Int] // error\n```\n\n----------------------------------------\n\nTITLE: Signature for Selectable selectDynamic Method\nDESCRIPTION: This snippet shows the required signature for the `selectDynamic` method used by `Selectable` implementations. It takes a `String` representing the member name and returns a value of type `T`, often `Any`. This method is invoked for structural selections that access values (fields or methods without arguments).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types-spec.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef selectDynamic(name: String): T\n```\n\n----------------------------------------\n\nTITLE: Constructing Period Instances in Scala\nDESCRIPTION: Shows the factory methods within the `Period` companion object used for creating `Period` instances. The first `apply` method constructs a `Period` representing a single phase within a given run. The second `apply` method constructs a `Period` spanning a range of phases (from `loPid` to `hiPid`) within a specific run (`rid`). These methods facilitate the creation of the time intervals used throughout the compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/periods.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject Period {\n  /** The single-phase period consisting of given run id and phase id */\n  def apply(rid: RunId, pid: PhaseId): Period\n\n  /** The period consisting of given run id, and lo/hi phase ids */\n  def apply(rid: RunId, loPid: PhaseId, hiPid: PhaseId): Period\n}\n```\n\n----------------------------------------\n\nTITLE: Defining List contains with two-parameter CanEqual (Scala 3)\nDESCRIPTION: Illustrates the safe version of the `contains` method in Scala 3. This definition uses a context bound or `using` clause, requiring an implicit `CanEqual[T, U]` instance. This dependency ensures that calling `xs.contains(y)` (where `xs: List[T]` and `y: U`) is only type-correct if an equality relationship is defined between types `T` and `U`, preventing nonsensical comparisons.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\n  def contains[U >: T](x: U)(using CanEqual[T, U]): Boolean // (1)\n```\n\n----------------------------------------\n\nTITLE: Using Implicit Conversion with List and Array Concatenation - Scala\nDESCRIPTION: Demonstrates Scala REPL commands where a List and Array are concatenated. This example shows implicit conversion from 'Array[Int]' to 'IterableOnce[Int]' when calling 'xs ++ ys', relying on Scala's standard library conversions. Input is a List and an Array, output is a List containing merged elements; requires a Scala REPL or worksheet context, and conversion availability.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val xs = List(0, 1)\nscala> val ys = Array(2, 3)\nscala> xs ++ ys\nval res0: List[Int] = List(0, 1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Grammar Production for Colon-Based Template, Enum, Refinement, and Packaging in Scala (EBNF)\nDESCRIPTION: This EBNF grammar fragment formalizes the new Scala 3 syntax supporting optional braces and indentation regions for template bodies, enum bodies, refinements, and packaging. It explains how a colon ('<colon>') together with an indentation region ('<indent>', '<outdent>') is grammatically equivalent to curly braces or standard block notation. No dependencies are required.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_7\n\nLANGUAGE: EBNF\nCODE:\n```\n:<<< TS >>>   ::=   ‘{’ TS ‘}’\n                |   <colon> <indent\" TS <outdent>\n```\n\nLANGUAGE: EBNF\nCODE:\n```\nTemplateBody      ::=  :<<< [SelfType] TemplateStat {semi TemplateStat} >>>\nEnumBody          ::=  :<<< [SelfType] EnumStat {semi EnumStat} >>>\nRefinement        ::=  :<<< [RefineDcl] {semi [RefineDcl]} >>>\nPackaging         ::=  ‘package’ QualId :<<< TopStats >>>\n```\n\n----------------------------------------\n\nTITLE: Named Type Parameters as Type Members in Scala\nDESCRIPTION: Illustrates how named type parameters can be declared using the 'type' keyword, making them visible as fields (type members) within the class, providing an alternate encoding style for parameterized types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Map[type K, type V]\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Map { type K; type V }\n```\n\n----------------------------------------\n\nTITLE: Example Implementation of a User-Defined Numeric Type 'BigFloat' with FromDigits\nDESCRIPTION: This snippet provides a complete example of a custom numeric type 'BigFloat' with a constructor, a string representation, and conversion logic from digit strings using a companion object. It illustrates how to implement FromDigits.Floating to enable literal support, handling decimal points and exponents.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ncase class BigFloat(mantissa: BigInt, exponent: Int):\n  override def toString = s\"${mantissa}e${exponent}\"\n\nobject BigFloat:\n  import scala.util.FromDigits\n\n  def apply(digits: String): BigFloat =\n    val (mantissaDigits, givenExponent) =\n      digits.toUpperCase.split('E') match\n        case Array(mantissaDigits, edigits) =>\n          val expo =\n            try FromDigits.intFromDigits(edigits)\n            catch case ex: FromDigits.NumberTooLarge =>\n              throw FromDigits.NumberTooLarge(s\"exponent too large: $edigits\")\n          (mantissaDigits, expo)\n        case Array(mantissaDigits) =>\n          (mantissaDigits, 0)\n    val (intPart, exponent) =\n      mantissaDigits.split('.') match\n        case Array(intPart, decimalPart) =>\n          (intPart ++ decimalPart, givenExponent - decimalPart.length)\n        case Array(intPart) =>\n          (intPart, givenExponent)\n    BigFloat(BigInt(intPart), exponent)\n\n  given FromDigits: FromDigits.Floating[BigFloat] with\n    def fromDigits(digits: String) = apply(digits)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Binding Precedence, Import Shadowing, and Local Definitions in Scala 3\nDESCRIPTION: This comprehensive Scala snippet demonstrates multiple binding precedences involving package clause bindings, wildcard imports, explicit imports, and local definitions. It uses nested locally blocks to showcase the shadowing of imported objects and members, ambiguous references due to shadowing, and resolution of members from different packages. It also contains commented-out lines indicating where references would be ambiguous, helping illustrate Scala's name resolution rules in nested scopes with competing bindings.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/02-identifiers-names-and-scopes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\npackage p {                     // `X' bound by package clause\n  import Console.*              // `println' bound by wildcard import\n  object Y {\n    println(s\"L4: $X\")          // `X' refers to `p.X' here\n    locally {\n      import q.*                // `X' bound by wildcard import\n      println(s\"L7: $X\")        // `X' refers to `q.X' here\n      import X.*                // `x' and `y' bound by wildcard import\n      println(s\"L9: $x\")        // `x' refers to `q.X.x' here\n      locally {\n        val x = 3               // `x' bound by local definition\n        println(s\"L12: $x\")     // `x' refers to constant `3' here\n        locally {\n          import q.X.*          // `x' and `y' bound by wildcard import\n//        println(s\"L15: $x\")   // reference to `x' is ambiguous here\n          import X.y            // `y' bound by explicit import\n          println(s\"L17: $y\")   // `y' refers to `q.X.y' here\n          locally {\n            val x = \"abc\"       // `x' bound by local definition\n            import p.X.*        // `x' and `y' bound by wildcard import\n//          println(s\"L21: $y\") // reference to `y' is ambiguous here\n            println(s\"L22: $x\") // `x' refers to string \"abc\" here\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Desugaring Dependent Function Types in Scala\nDESCRIPTION: Illustrates how a dependent function type `(x1: K1, ..., xN: KN) => R` desugars into a refinement of `scala.FunctionN`. The resulting type includes an `apply` method whose result type `R` depends on the input parameters `x1` to `xN`, while the type parameter `R'` represents the least upper bound of `R` independent of the value parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/dependent-function-types-spec.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nFunctionN[K1, ..., Kn, R']:\n  def apply(x1: K1, ..., xN: KN): R\n```\n\n----------------------------------------\n\nTITLE: Generating Scaladoc Documentation via sbt\nDESCRIPTION: These sbt commands are used to trigger the Scaladoc documentation generation process. `scaladoc/generateSelfDocumentation` builds docs for the Scaladoc tool's codebase, while `scaladoc/generateScalaDocumentation` builds docs for the main Scala 3 project (Dotty). These are the primary ways to create the documentation output locally.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/scaladoc.md#_snippet_0\n\nLANGUAGE: sbt\nCODE:\n```\nsbt scaladoc/generateSelfDocumentation\n```\n\nLANGUAGE: sbt\nCODE:\n```\nsbt scaladoc/generateScalaDocumentation\n```\n\n----------------------------------------\n\nTITLE: Using Transparent Traits to Refine Type Inference in Scala 3\nDESCRIPTION: This snippet introduces a transparent trait S and shows how objects can inherit from both a standard and a transparent trait. It demonstrates Scala 3's ability to suppress transparent traits from inferred types, yielding simpler type results for vals. The snippet requires Scala 3 and knowledge of the transparent modifier. Inputs are object definitions, and output is a Set with a refined, less cluttered type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/transparent-traits.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntransparent trait S\ntrait Kind\nobject Var extends Kind, S\nobject Val extends Kind, S\nval x = Set(if condition then Val else Var)\n```\n\n----------------------------------------\n\nTITLE: Creating Local Selectable Instances to Enable Safe Dynamic Fields in Scala\nDESCRIPTION: This snippet demonstrates defining a local anonymous class that extends 'reflect.Selectable', thereby allowing dynamic selection of members with type safety. The 'Vehicle' trait requires the 'Selectable' mix-in to access fields like 'range' that are not specified in the trait but are present in the anonymous instance. This functionality is available in Scala 3 or Dotty 0.26.0-RC1+. 'i3' is an instance of 'Vehicle' with additional fields. Accessing 'i3.range' is valid due to 'Selectable'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-07-27-26th-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Vehicle extends reflect.Selectable {\n  val wheels: Int\n}\nval i3 = new Vehicle { // i3: Vehicle { val range: Int }\n  val wheels = 4\n  val range = 240\n}\ni3.range\n```\n\n----------------------------------------\n\nTITLE: Demonstrating 'super' Reference Behavior Example (Scala)\nDESCRIPTION: Provides Scala code demonstrating the behavior of 'super' references in a class hierarchy involving traits and linearization. It shows how 'super.x' resolves based on the specific linearization path of the class where it's called, illustrating the effect of mixins on super calls.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Root { def x = \"Root\" }\nclass A extends Root { override def x = \"A\" ; def superA = super.x }\ntrait B extends Root { override def x = \"B\" ; def superB = super.x }\nclass C extends Root with B {\n  override def x = \"C\" ; def superC = super.x\n}\nclass D extends A with B {\n  override def x = \"D\" ; def superD = super.x\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n(new A).superA == \"Root\"\n\n(new C).superB == \"Root\"\n(new C).superC == \"B\"\n\n(new D).superA == \"Root\"\n(new D).superB == \"A\"\n(new D).superD == \"B\"\n```\n\n----------------------------------------\n\nTITLE: Defining Core Transformer Phases in Scala\nDESCRIPTION: This Scala code block defines the main list of phase groups for the Scala 3 compiler's transformation pipeline. It lists numerous phases, each performing a specific AST transformation, grouped into inner lists for combined execution during a single tree traversal. The comments provide brief descriptions of each phase's function, such as rewriting tail recursion or expanding lazy vals.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/overall-structure.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nList(\n         new sjs.AddLocalJSFakeNews, // Adds fake new invocations to local JS classes in calls to `createLocalJSClass`\n         new ElimPolyFunction,       // Rewrite PolyFunction subclasses to FunctionN subclasses\n         new TailRec,                // Rewrite tail recursion to loops\n         new CompleteJavaEnums,      // Fill in constructors for Java enums\n         new Mixin,                  // Expand trait fields and trait initializers\n         new LazyVals,               // Expand lazy vals\n         new Memoize,                // Add private fields to getters and setters\n         new NonLocalReturns,        // Expand non-local returns\n         new CapturedVars) ::        // Represent vars captured by closures as heap objects\n    List(new Constructors,           // Collect initialization code in primary constructors\n                                        // Note: constructors changes decls in transformTemplate, no InfoTransformers should be added after it\n         new Instrumentation) ::     // Count calls and allocations under -Yinstrument\n    List(new LambdaLift,             // Lifts out nested functions to class scope, storing free variables in environments\n                                     // Note: in this mini-phase block scopes are incorrect. No phases that rely on scopes should be here\n         new ElimStaticThis,         // Replace `this` references to static objects by global identifiers\n         new CountOuterAccesses) ::  // Identify outer accessors that can be dropped\n    List(new DropOuterAccessors,     // Drop unused outer accessors\n         new Flatten,                // Lift all inner classes to package scope\n         new RenameLifted,           // Renames lifted classes to local numbering scheme\n         new TransformWildcards,     // Replace wildcards with default values\n         new MoveStatics,            // Move static methods from companion to the class itself\n         new ExpandPrivate,          // Widen private definitions accessed from nested classes\n         new RestoreScopes,          // Repair scopes rendered invalid by moving definitions in prior phases of the group\n         new SelectStatic,           // get rid of selects that would be compiled into GetStatic\n         new sjs.JUnitBootstrappers, // Generate JUnit-specific bootstrapper classes for Scala.js (not enabled by default)\n         new CollectSuperCalls) ::   // Find classes that are called with super\n    Nil\n```\n\n----------------------------------------\n\nTITLE: Importing Safer Exceptions Language Feature in Scala 3\nDESCRIPTION: This snippet imports the experimental safer exceptions feature from the Scala 3 language, enabling support for static exception checking via capabilities. It requires the Scala 3 compiler with experimental features enabled and the appropriate language import statement. This import is necessary to activate the CanThrow capabilities feature described throughout the document.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/canthrow.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport language.experimental.saferExceptions\n```\n\n----------------------------------------\n\nTITLE: Creating Bidirectional CanEqual Instances Between Types\nDESCRIPTION: Example of setting up CanEqual instances to allow values of type A and B to be comparable with each other but not with other types, demonstrating multi-type equality configuration.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ngiven CanEqual[A, A] = CanEqual.derived\ngiven CanEqual[B, B] = CanEqual.derived\ngiven CanEqual[A, B] = CanEqual.derived\ngiven CanEqual[B, A] = CanEqual.derived\n```\n\n----------------------------------------\n\nTITLE: Defining Backend Code Generation Phases in Scala\nDESCRIPTION: This Scala code snippet defines the list of phase groups responsible for the final code generation step in the Scala 3 compiler. It includes phases for generating Scala.js Intermediate Representation (.sjsir) and JVM bytecode (.class files), grouped into separate lists. These phases are typically executed after all transformations are complete.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/overall-structure.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nprotected def backendPhases: List[List[Phase]] =\n    List(new backend.sjs.GenSJSIR) :: // Generate .sjsir files for Scala.js (not enabled by default)\n    List(new GenBCode) ::             // Generate JVM bytecode\n    Nil\n```\n\n----------------------------------------\n\nTITLE: Implementing a try-with-resources pattern in Scala without capture checking\nDESCRIPTION: A basic implementation of the try-with-resources pattern in Scala that opens a log file, performs an operation with it, and closes it afterward. This version is unsafe as the file resource could escape its intended scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef usingLogFile[T](op: FileOutputStream => T): T =\n  val logFile = FileOutputStream(\"log\")\n  val result = op(logFile)\n  logFile.close()\n  result\n```\n\n----------------------------------------\n\nTITLE: Encoding By-Name Parameters Using Implicit Functions in Scala 3\nDESCRIPTION: Demonstration of how by-name parameters can be equivalently encoded using implicit function types, showing two identical implementations of a timed operation function.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-07-06-ninth-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef timed[T](op: => T): T = ...\ndef timed[T](op: implicit () => T): T = ...\n\ntimed {\n  fetch(url)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala Program using the `App` Trait\nDESCRIPTION: Demonstrates an alternative way to define a Scala program by creating an object (`test.HelloWorld`) that extends the `scala.App` trait. The initialization code within the object body automatically becomes the program's execution logic, eliminating the need for an explicit `main` method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/09-top-level-definitions.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\npackage test\nobject HelloWorld extends App {\n  println(\"Hello World\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Scala Intersection Types\nDESCRIPTION: Defines two traits, `Resettable` and `Growable[T]`, and demonstrates a function `f` that accepts a parameter `x` whose type is the intersection `Resettable & Growable[String]`. The function then calls methods defined in both traits (`reset` and `add`) on the parameter `x`, showcasing that `x` possesses members from both types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/intersection-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Resettable:\n  def reset(): Unit\n\ntrait Growable[T]:\n  def add(t: T): Unit\n\ndef f(x: Resettable & Growable[String]) =\n  x.reset()\n  x.add(\"first\")\n```\n\n----------------------------------------\n\nTITLE: Defining Instance Creation Expression Syntax Using EBNF in Scala\nDESCRIPTION: This snippet specifies, in EBNF, the syntax for creating new class instances or objects in Scala 3. A 'SimpleExpr' can be a 'new' keyword followed by either a class template or a template body. This formal rule underpins the language's object instantiation mechanism, with no dependencies or parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_13\n\nLANGUAGE: EBNF\nCODE:\n```\nSimpleExpr     ::=  ‘new’ (ClassTemplate | TemplateBody)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ambiguous Implicit Values in Scala\nDESCRIPTION: This Scala snippet illustrates a potential issue with nested implicit parameters. Defining an outer function `foo` with implicit `a` and a nested function `bar` with implicit `b` (both of the same type `A`) causes an 'ambiguous implicit values' error when trying to resolve `implicitly[A]` inside `bar`, as both `a` and `b` are visible and match.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/contexts.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> class A\n\nscala> def foo(implicit a: A) { def bar(implicit b: A) { println(implicitly[A]) } }\n<console>:8: error: ambiguous implicit values:\n both value a of type A\n and value b of type A\n match expected type A\n       def foo(implicit a: A) { def bar(implicit b: A) { println(implicitly[A]) } }\n```\n\n----------------------------------------\n\nTITLE: Inferring List Type with Mixed Numeric Literals in Scala\nDESCRIPTION: This Scala snippet demonstrates how a list containing mixed numeric types—including Double, Int, and literals—was inferred to the List[Double] type due to weak conformance in earlier Scala versions. Dependencies are the Scala standard library (no external references required). List elements are a combination of literals and function calls; the expected output is a list typed as List[Double] under old rules, but this changes with removal of weak conformance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/weak-conformance.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nList(1.0, math.sqrt(3.0), 0, -3.3) // : List[Double]\n```\n\n----------------------------------------\n\nTITLE: Using Ref with Capture Checking Constraints in Scala 3\nDESCRIPTION: Illustrates the capture checking restrictions when using the generic Ref class with List[Proc]. Attempts to store List[Proc] in Ref result in illegal type errors due to capture set violations on type arguments. The usage within a usingFile context further demonstrates the enforcement of reachability constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef runAll(xs: List[Proc]): Unit =\n  val cur = Ref[List[Proc]](xs) // error, illegal type for type argument to Ref\n  while cur.get.nonEmpty do\n    val next: () => Unit = cur.get.head\n    next()\n    cur.set(cur.get.tail: List[Proc])\n\n  usingFile: f =>\n    cur.set:\n      (() => f.write(): () ->{f*} Unit) :: Nil\n```\n\n----------------------------------------\n\nTITLE: Declaring a Capability-Restricted Higher-Order Function in Scala\nDESCRIPTION: This Scala snippet defines the function `usingLogFile` with a type parameter `T` and a parameter `op` representing a function from a captured `FileOutputStream` to `T`. It demonstrates how capability types are marked with `^`, indicating restricted capture sets to prevent the universal capability `cap` from escaping. The snippet serves as context for why closures capturing local capabilities produce errors when escaping their allowed lifetimes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\ndef usingLogFile[T](op: FileOutputStream^ => T): T = ...\n```\n\n----------------------------------------\n\nTITLE: New `=>` Syntax for Monomorphic Conditional Givens in Scala 3\nDESCRIPTION: Demonstrates the proposed new experimental `=>` syntax for non-parameterized (monomorphic) conditional `given` instances. `(outer: Context) => Context` indicates that a given `Context` (named `outer`) implies another given `Context`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ngiven (outer: Context) => Context = ...\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Nullable Constants in Java and Their Translation - Scala\nDESCRIPTION: This Scala translation of the Java Constants class shows that Scala 3 maps final literal fields to value types or singleton types where possible, keeping them non-nullable. Non-literal fields (assigned from a method) remain potentially nullable to reflect their runtime uncertainty, ensuring safe representations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nclass Constants:\n  val NAME: String(\"name\") = \"name\"\n  val AGE: Int(0) = 0\n  val CHAR: Char('a') = 'a'\n\n  val NAME_GENERATED: String | Null = getNewName()\n\n```\n\n----------------------------------------\n\nTITLE: Using `given` in For-Comprehension Pattern Bindings in Scala 3\nDESCRIPTION: Illustrates how to declare a variable extracted in a for-comprehension generator as `given` in Scala 3. This allows the variable (e.g., `x`) to be implicitly passed to subsequent function calls (like `foo`) within the comprehension. Note that the type of the `given` variable must be explicitly specified.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-09-23-19th-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(given x: Int): Option[Int] = Some(x * x)\ndef bar = Some(10)\n\n@main def Test =\n  for\n    given x: Int <- bar\n    res <- foo\n  yield println(res)\n```\n\n----------------------------------------\n\nTITLE: Supporting Multiversal Equality with 'Eql' Trait\nDESCRIPTION: Introduces support for cross-type equality comparison using the 'Eql' trait, allowing expressions like 'implied for Eql[Int, String] = Eql.derived' to define shared comparison behavior.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nimplied for Eql[Int, String] = Eql.derived\n```\n\n----------------------------------------\n\nTITLE: Using the `@targetName` Annotation for Symbolic Operators in Scala 3\nDESCRIPTION: Highlights the recommendation to annotate symbolic operator definitions with `@targetName` to provide an alphanumeric alias. This improves interoperability with other languages, enhances readability in runtime diagnostics such as stack traces, and serves as documentation making symbolic operators easier to find and understand.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/operators.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n@targetName(\"intersection\")\ndef *(other: MultiSet[T]): MultiSet[T]\n```\n\n----------------------------------------\n\nTITLE: Observing Union Type Inference with Implicit Object Supertype in Scala REPL\nDESCRIPTION: This REPL session demonstrates Scala 3's type inference for expressions involving types whose common superclass is implicitly `Object`. Since `Object` is treated as transparent for inference purposes, the compiler correctly infers the precise Union Type (`UserName | Password`) for the expression, providing a more accurate type than the common superclass.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/union-types.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nscala> if true then UserName(\"Eve\") else Password(123)\nval res3: UserName | Password = UserName(Eve)\n\n```\n\n----------------------------------------\n\nTITLE: Defining Match Types in Scala 3\nDESCRIPTION: This Scala snippet defines a match type `Elem` that pattern matches on the generic type parameter `X` to determine a corresponding type alias based on the input type. It demonstrates conditional type-level programming, reducing `Elem[X]` to specific types when `X` is a String, an Array of some type `t`, or an Iterable of `t`. This feature enables compile-time type computation based on input types and is experimental in Dotty 0.10.0-RC1.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-10-10-10th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Elem[X] = X match {\n  case String => Char\n  case Array[t] => t\n  case Iterable[t] => t\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Position of 'given' Clause in Scala 3\nDESCRIPTION: Shows an invalid function definition where the 'given' clause appears before a normal parameter list, which is not allowed in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-05-23-15th-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimplied for String = \"foo\"\ndef f(x: Int) given (y: String) (z: Int) = x + z\nf(1)(3)\n```\n\n----------------------------------------\n\nTITLE: New Scala 3 Syntax for Multiple Inheritance\nDESCRIPTION: Illustrates the alternative syntax in Scala 3 where multiple extended types in an `extends` clause can be separated by commas, similar to the `derives` clause, as an equivalent to the older `with` keyword syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nclass A extends B, C { ... }\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass A extends B with C { ... }\n```\n\n----------------------------------------\n\nTITLE: Runtime Multi-Stage Programming Example in Scala\nDESCRIPTION: Provides a practical example of runtime multi-stage programming. It defines a function `f` that calculates the sum of an array. The implementation of `f` is generated at runtime using `staging.run` and a staged expression `Expr[Array[Int] => Int]`. It requires an available `staging.Compiler` instance and demonstrates how to create one.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/staging.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.quoted.*\n\n// make available the necessary compiler for runtime code generation\ngiven staging.Compiler =\n  // We need an instance of a class that is defined in the current application (not the standard library)\n  // `this` can be used instead of an instance of `Dummy` if the Compiler is instantiated within one of the application classes.\n  object Dummy\n  staging.Compiler.make(Dummy.getClass.getClassLoader)\n\nval f: Array[Int] => Int = staging.run {\n  val stagedSum: Expr[Array[Int] => Int] =\n    '{ (arr: Array[Int]) => ${sum('arr)}}\n  println(stagedSum.show) // Prints \"(arr: Array[Int]) => { var sum = 0; ... }\"\n  stagedSum\n}\n\nf.apply(Array(1, 2, 3)) // Returns 6\n```\n\n----------------------------------------\n\nTITLE: Defining and Implementing Abstract Inline Methods in Scala\nDESCRIPTION: Demonstrates abstract inline methods. An `abstract inline def f` in class `A` can only be implemented by another `inline def f` (as in object `B`). Direct calls like `B.f` are inlined. However, dynamic calls via the abstract type (`a.f`) are disallowed because the compiler cannot determine the specific inline implementation at the call site.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nabstract class A:\n  inline def f: Int\n\nobject B extends A:\n  inline def f: Int = 22\n\nB.f         // OK\nval a: A = B\na.f         // error: cannot inline f in A.\n```\n\n----------------------------------------\n\nTITLE: Examples of Numeric Literals with Different Types in Scala 3\nDESCRIPTION: This snippet demonstrates various numeric literals assigned to different types such as Long, BigInt, and BigDecimal in Scala 3, showing how literals can represent large and hexadecimal numbers. It illustrates the syntax and type inference rules for literals.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval x: Long = -10_000_000_000\nval y: BigInt = 0x123_abc_789_def_345_678_901\nval z: BigDecimal = 110_222_799_799.99\n\n(y: BigInt) match\n  case 123_456_789_012_345_678_901 =>\n```\n\n----------------------------------------\n\nTITLE: Obtaining Compile-Time Constant Values for Tuples with constValueTuple in Scala\nDESCRIPTION: This snippet shows the use of 'constValueTuple' to obtain a tuple of compile-time constants from a type-level tuple of literal types. The resulting runtime value is a tuple of the literal values. Required: Scala 3/Dotty 0.26.0-RC1+, and the tuple elements must be compile-time constant types. Output: a tuple of constants, printed for demonstration.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-07-27-26th-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval result = constValueTuple[\"foo\" *: \"bar\" *: 10 *: 2.5 *: EmptyTuple]\nprintln(result)  // (foo,bar,10,2.5)\n```\n\n----------------------------------------\n\nTITLE: Custom Type Parsing for @main Functions\nDESCRIPTION: Example of defining a custom type with a given FromString instance to enable parsing from command-line arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class Address(city: String, street: String)\n\ngiven scala.util.FromString[Address] {\n  /** Can throw java.lang.IllegalArgumentException */\n  def fromString(s: String): T =\n    s.split(\",\").toList match {\n      case city :: street :: Nil => Address(city, street)\n      case _ => throw new IllegalArgumentException(s\"Please specify address in the format 'city, street'\")\n    }\n}\n\n@main def sayHello(addr: Address): Unit =\n  println(s\"You are living at $addr\")\n```\n\n----------------------------------------\n\nTITLE: Decision Flowchart for Backporting Changes - Mermaid\nDESCRIPTION: This flowchart visualizes the decision-making process for determining whether a Pull Request (PR) merged into the main development branch (`main`) should be backported to the Scala LTS branch. It details checks for CVE fixes, forward compatibility breaks, regressions (including those in LTS), type changes, impact on the Community Build (CB), and whether the fix is heavily requested.\nSOURCE: https://github.com/scala/scala3/blob/main/project/RELEASES.md#_snippet_0\n\nLANGUAGE: Mermaid\nCODE:\n```\nflowchart TB\n    start([\"PR relevant for LTS was merged to main branch\"])\n    -->\n    cve{\"Is this\n         a fix for a CVE?\"}\n    -- yes --> ocb\n\n    subgraph \"CVE\"\n        ocb{\"Does it cause\n            any new failures\n            in the full CB?\"}\n\n        -- yes -->\n        regFix[\\\"Try to provide\n                a followup fix for\n                a regressions\"/]\n\n        -- failure -->\n        debate[\\\"Possible workarounds\n                 for new regressions are discussed\n                 by the compiler team\"/]\n\n        regFix -- success --> ocb\n    end\n    ocb -- no --> acc\n    debate -->|\"decision on\n                the recommended\n                workarounds\"| acc\n\n    cve -- no -->\n    incompat{\"Does the fix\n              break forward\n              compatibiliy?\"}\n    -- yes --> reject\n\n    incompat -- no -->\n\n    regression{\"Is this a fix for\n                a regression present\n                also in LTS?\"}\n    -- yes -->\n\n    regIsLTS{\"Was the last version\n              affected by\n              the regression released\n              before 3.3.0?\"}\n    -- yes --> ocbReg\n\n    subgraph \"LTS Regression\"\n        ocbReg{\"Does it cause\n                any new failures\n                in the full CB?\"}\n\n        -- yes -->\n        regFixReg[\\\"Try to provide\n                    a followup fix for\n                    a regressions\"/]\n\n        -- failure -->\n        debateReg[\\\"Impact of both new and old regression\n                    and possible workarounds\n                    are discussed by the compiler team.\"/]\n\n        regFixReg -- success --> ocbReg\n    end\n    ocbReg -- no --> acc\n    debateReg -->|\"decision on\n                   the recommended\n                   workarounds for\n                   the new regression\"| acc\n    debateReg -->|\"decision on\n                   the recommended\n                   workarounds for\n                   the old regression\"| reject\n\n    regression -- no --> types\n    regIsLTS -- no --> types\n    types{\"Can the fix\n           change types\n           in any correct\n           Scala 3 code?\"}\n    -- yes --> request\n    types -- no --> ocbOther\n\n    request{\"Is backport\n             of the fix\n             heavily requested?\"}\n    -- yes --> debateReq\n    request -- no --> reject\n\n    debateReq[\\\"Possibility of\n                the backport is discussed\n                by the compiler team\"/]\n    --> |\"backport is rejected\"| reject\n    debateReq --> |\"backport is accepted\"| ocbOther\n\n    subgraph \"Other Fixes\"\n        ocbOther{\"Does it cause\n                 any new failures\n                 in the full CB?\"}\n\n        -- yes -->\n        regFixOther[\\\"Try to provide\n                    a followup fix for\n                    a regressions\"/]\n        -- success --> ocbOther\n\n        ocbOther -- no -->\n        lint{\"Does it introduce\n              any new warnings\n              behind flags?\"}\n        -- yes -->\n        lintOcb{\"Does it cause any\n                 new failures in the full CB\n                 after forcing a new flag?\"}\n        -- yes --> regFixOther\n    end\n\n    lint -- no --> acc\n    lintOcb -- no --> acc\n    regFixOther -- failure --> reject\n\n    acc([\"The PR is backported\"])\n    reject([\"The PR is not backported\"])\n\n```\n\n----------------------------------------\n\nTITLE: Evaluation Command Examples - Scala 3 Debug Test - Plaintext\nDESCRIPTION: These examples demonstrate how to test expression evaluation and error reporting in debugger scenarios. Multi-line expressions and error messages are supported, facilitating comprehensive coverage of code evaluation outcomes in the test suite.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_13\n\nLANGUAGE: plaintext\nCODE:\n```\neval fibonacci(2)\nresult 55\n\neval\n  def square(x: Int): Int =\n    x * x\n  square(2)\nresult 4\n\neval foo\nerror\n  <expression>:1:0\n  1 |foo\n    |^^^\n    | Not found: foo\n```\n\n----------------------------------------\n\nTITLE: Defining Unary Operators in Scala 3\nDESCRIPTION: Defines the requirement that unary operator methods in Scala 3 must be named \"unary_`op`\" where `op` is one of `+`, `-`, `!`, or `~`, and must not have any explicit parameter lists, including empty ones. This enforces a consistent unary operator syntax for compiler parsing and usage.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/operators.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n/* Unary operator must be defined without explicit parameter lists and named unary_op */\n```\n\n----------------------------------------\n\nTITLE: Defining List Contains with Safe Equality using CanEqual[T, U] in Scala\nDESCRIPTION: This snippet presents the equality-safe version of `List.contains` currently used in Scala. It adds a `using CanEqual[T, U]` clause, requiring an implicit `CanEqual` instance specifically between the list's element type `T` and the argument type `U`. This design ensures that `xs.contains(y)` is only type-correct if an equality relationship is defined between `T` and `U`, providing compile-time safety.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ndef contains[U >: T](x: U)(using CanEqual[T, U]): Boolean // (1)\n```\n\n----------------------------------------\n\nTITLE: Running the TASTy Inspector in Scala\nDESCRIPTION: Demonstrates how to invoke the TASTy inspection process. It creates a list of TASTy file paths and passes them along with an instance of the custom `MyInspector` to the `TastyInspector.inspectTastyFiles` method. This is typically done within a main method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/tasty-inspect.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject Test:\n   def main(args: Array[String]): Unit =\n      val tastyFiles = List(\"foo/Bar.tasty\")\n      TastyInspector.inspectTastyFiles(tastyFiles)(new MyInspector)\n```\n\n----------------------------------------\n\nTITLE: Java Interoperability: @NotNull Annotation Handling\nDESCRIPTION: Illustrates how Java fields or method return types annotated with a recognized `@NotNull` annotation are treated as non-nullable when imported into Scala, overriding the default nullification. Note that method parameters are still nullified unless also annotated. For generics, the outermost type is non-nullable, but inner types are still nullified according to standard rules (e.g., `Box[String | Null]`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_11\n\nLANGUAGE: java\nCODE:\n```\n// Java definition (assuming @NotNull is recognized)\nclass C {\n  @NotNull String name;\n  @NotNull List<String> getNames(String prefix); // List is Java-defined\n  @NotNull Box<String> getBoxedName(); // Box is Scala-defined\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Equivalent Scala signature with explicit nulls\nclass C:\n  val name: String\n  def getNames(prefix: String | Null): java.util.List[String] // Parameter still nullable\n  def getBoxedName(): Box[String | Null] // Outer type non-null, inner type nullable\n```\n\n----------------------------------------\n\nTITLE: Using New Vararg Splice Syntax in Scala 3\nDESCRIPTION: Demonstrates the new syntax for vararg splices in Scala 3 using postfix asterisk (*) for both function arguments and pattern matching. The example shows how to splice an array into a list and how to use vararg patterns in match expressions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/vararg-splices.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval arr = Array(0, 1, 2, 3)\nval lst = List(arr*)                   // vararg splice argument\nlst match\n  case List(0, 1, xs*) => println(xs)  // binds xs to Seq(2, 3)\n  case List(1, _*) =>                  // wildcard pattern\n```\n\n----------------------------------------\n\nTITLE: Inferred Types from Automatic Eta Expansion in Scala 3\nDESCRIPTION: This snippet shows the inferred types for the function values `f1` and `f2` created by the automatic eta expansion demonstrated in the previous snippet. `f1` is a curried function type representing the full method signature, while `f2` is a function type representing the partially applied method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/eta-expansion.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nf1: (Boolean, String) => Int => List[Int]\nf2: Int => List[Int]\n```\n\n----------------------------------------\n\nTITLE: Expansion of Multiple Context Bounds in Scala\nDESCRIPTION: Shows the expanded form of the previous `f` function definition. The context bounds `: C1 : C2` on `T` and `: C3` on `U` are translated into corresponding context parameters (`using _: C1[T], _: C2[T], _: C3[U]`) prepended to the existing `using` clause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-bounds.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef f[T, U](x: T)(using _: C1[T], _: C2[T], _: C3[U], y: U, z: V): R\n```\n\n----------------------------------------\n\nTITLE: Compiler Error Output for Exponent Too Large (Scala)\nDESCRIPTION: Shows the error message produced at compile time when a BigFloat literal with a too-large exponent is used with the macro machinery. Input is the invalid literal assignment, and output is the annotated compile error. No additional dependencies.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\n3 |  val x: BigFloat = 1234.45e3333333333\n  |                    ^^^^^^^^^^^^^^^^^^\n  |                    exponent too large: 3333333333\n```\n\n----------------------------------------\n\nTITLE: Compiler Expansion of BigFloat Literal in Scala\nDESCRIPTION: Shows how the Scala compiler expands a BigFloat literal assignment into a call to BigFloat.FromDigits.fromDigits with the corresponding digit string. No dependencies except the BigFloat class being in scope. This approach can throw exceptions at runtime if the value represented is too large.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nBigFloat.FromDigits.fromDigits(\"1e100000000000\")\n```\n\n----------------------------------------\n\nTITLE: Defining Compilation Test Methods Scala\nDESCRIPTION: Defines two Scala test methods, `exampleNeg` and `exampleRun`, annotated with `@Test`. These methods utilize the Vulpix framework to compile the sample `.scala` files created by the bash script, checking for expected errors in the `neg` directory and successful execution in the `run` directory.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/procedures/vulpix.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n  @Test def exampleNeg: Unit = {\n    implicit val testGroup: TestGroup = TestGroup(\"exampleNeg\")\n    compileFilesInDir(\"tests/playground/neg\", defaultOptions).checkExpectedErrors()\n  }\n\n  @Test def exampleRun: Unit = {\n    implicit val testGroup: TestGroup = TestGroup(\"exampleRun\")\n    compileFilesInDir(\"tests/playground/run\", defaultOptions).checkRuns()\n  }\n```\n\n----------------------------------------\n\nTITLE: Respecting NotNull Annotations in Java and Scala - Java\nDESCRIPTION: This Java class declares @NotNull-annotated fields and methods using both Java-defined and Scala-defined containers. The snippet illustrates that properly recognized NotNull annotations signal the Scala compiler to keep the outermost type non-nullable, while still handling potential nulls inside generic arguments as per interop rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_17\n\nLANGUAGE: Java\nCODE:\n```\nclass C {\n  @NotNull String name;\n  @NotNull List<String> getNames(String prefix); // List is Java-defined\n  @NotNull Box<String> getBoxedName(); // Box is Scala-defined\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized String Interpolation in Scala 3\nDESCRIPTION: Example showing how the compiler now optimizes s and raw string interpolators by desugaring them into concatenation operations, improving performance to match non-type-safe string concatenation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-07-06-ninth-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ns\"Hello $name!\"\n\n// compared to:\n\"Hello \" + name + \"!\"\n```\n\n----------------------------------------\n\nTITLE: Anonymous Given Instances with Synthesized Names in Scala 3 - Scala\nDESCRIPTION: Defines anonymous given instances for Ord[Int] and Ord[List[T]] in Scala 3. The compiler generates canonical names based on the type structure. These are useful when explicit instance names are omitted, ensuring unique and traceable identifiers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ngiven given_Ord_Int: Ord[Int] with { ... }\ngiven given_Ord_List[T](using ord: Ord[T]): Ord[List[T]] with { ... }\n```\n\n----------------------------------------\n\nTITLE: Equivalent Function Signature Using CanThrow Capability in Scala\nDESCRIPTION: This snippet shows how the `throws` clause in Scala expands into an equivalent function signature with an implicit `CanThrow` capability parameter. It provides the type-level detail that enforcing checked exceptions depends on the presence of these implicit capabilities during function invocation, facilitating static checking and capability tracking.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Double)(using CanThrow[LimitExceeded]): Double = ...\n```\n\n----------------------------------------\n\nTITLE: Running Specific Compilation Tests SBT\nDESCRIPTION: Provides the SBT command `testOnly` to execute specific tests within the `dotty.tools.dotc.CompilationTests` class. The wildcard pattern `-- *example*` filters the execution to only include test methods whose names contain \"example\", specifically targeting the `exampleNeg` and `exampleRun` methods defined for the playground.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/procedures/vulpix.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntestOnly dotty.tools.dotc.CompilationTests -- *example*\n```\n\n----------------------------------------\n\nTITLE: Static Error Preventing Capability Escape with Capture Checking in Scala 3\nDESCRIPTION: This snippet shows the compiler error triggered when an attempt is made to define a value `later` that captures and retains the capability beyond its allowed lifetime. The error message indicates the type is not allowed to capture the root capability `cap`, preventing unsafe use of resources.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n   |  val later = usingLogFile { f => () => f.write(0) }\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |The expression's type () => Unit is not allowed to capture the root capability `cap`.\n   |This usually means that a capability persists longer than its allowed lifetime.\n```\n\n----------------------------------------\n\nTITLE: Using @threadUnsafe Annotation on a Lazy Val in Scala 3\nDESCRIPTION: This snippet demonstrates how to apply the @threadUnsafe annotation to a lazy val in Scala 3 to enable faster, non-thread-safe initialization. The annotation is imported from scala.annotation and applied directly above the lazy val definition. The expected input is a class with a lazy val annotated with @threadUnsafe, resulting in a lazy value initialized with a faster mechanism. No external dependencies beyond Scala standard library are required.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/threadUnsafe-annotation.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.threadUnsafe\n\nclass Hello:\n   @threadUnsafe lazy val x: Int = 1\n```\n\n----------------------------------------\n\nTITLE: Enabling Scala 2 library TASTy support in bootstrapped Scala 3 compiler\nDESCRIPTION: Instructions for enabling the Scala 2 library repackaged with only TASTy files (no classfiles) in bootstrapped compiler tests using an sbt setting. This is useful to test TASTy loading in compiler and runtime phases. The setting can switch between using the TASTy or the default classfile JAR.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\n> set ThisBuild/Build.scala2Library := Build.Scala2LibraryTasty\n> scala3-compiler-bootstrapped/scalac MyFile.scala\n> scala3-compiler-bootstrapped/test\n> scala3-compiler-bootstrapped/testCompilation\n```\n\nLANGUAGE: bash\nCODE:\n```\n> set ThisBuild/Build.scala2Library := Build.Scala2LibraryJar\n```\n\n----------------------------------------\n\nTITLE: Define Anonymous Function Grammar - EBNF\nDESCRIPTION: This EBNF snippet specifies the grammatical structure for anonymous functions in Scala. It defines the different forms expressions (Expr, ResultExpr) can take when representing functions, including parameters (Bindings, Binding), optional types, the => separator, and the function body.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_43\n\nLANGUAGE: ebnf\nCODE:\n```\nExpr            ::=  (Bindings | [‘implicit’] id | ‘_’) ‘=>’ Expr\nResultExpr      ::=  (Bindings | ([‘implicit’] id | ‘_’) ‘:’ CompoundType) ‘=>’ Block\nBindings        ::=  ‘(’ Binding {‘,’ Binding} ‘)’\nBinding         ::=  (id | ‘_’) [‘:’ Type]\n```\n\n----------------------------------------\n\nTITLE: Invoking Target-Named Method from Java (Java)\nDESCRIPTION: This Java code demonstrates how to call a Scala method that was annotated with @targetName ('append') from Java code. The Scala method is exposed in the generated bytecode under the external name provided, making it possible for Java consumers to call VecOps.append directly. The method expects two Vec parameters and returns another Vec.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/targetName.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\nVecOps.append(vec1, vec2)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Updated Numeric Type Assignment Rules in Scala 3 - Scala\nDESCRIPTION: This code snippet illustrates the new rules for assigning types to constant expressions involving numeric primitives in Scala 3 after the removal of weak conformance. It covers various cases, such as using inline values, method results, and combining numeric values of different types within arrays, showing how Scala determines the resulting array type. The expected output types are annotated for each array; note that loss of precision may prevent widening conversions. Dependencies: Scala 3 or later. Input: inline val, method definition, and array constructions of mixed numeric types. Output: Arrays with deduced types according to the updated rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/weak-conformance-spec.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ninline val b = 33\ndef f(): Int = b + 1\nArray(b, 33, 5.5)      : Array[Double] // b is an inline val\nArray(f(), 33, 5.5)    : Array[AnyVal] // f() is not a constant\nArray(5, 11L)          : Array[Long]\nArray(5, 11L, 5.5)     : Array[AnyVal] // Long and Double found\nArray(1.0f, 2)         : Array[Float]\nArray(1.0f, 1234567890): Array[AnyVal] // loss of precision\nArray(b, 33, 'a')      : Array[Char]\nArray(5.toByte, 11)    : Array[Byte]\n```\n\n----------------------------------------\n\nTITLE: Using Opaque Types with Classes in Scala 3\nDESCRIPTION: This example demonstrates defining opaque type members within a class 'Logarithms', enabling each instance to have its own opaque 'Logarithm' type. It shows how different class instances treat opaque types as separate, preventing cross-instance type errors when calling their methods, thus modeling encapsulation within object-oriented design.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/opaques.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass Logarithms:\n\n  opaque type Logarithm = Double\n\n  def apply(d: Double): Logarithm = math.log(d)\n\n  def safe(d: Double): Option[Logarithm] =\n    if d > 0.0 then Some(math.log(d)) else None\n\n  def mul(x: Logarithm, y: Logarithm) = x + y\n\nval l1 = new Logarithms\nval l2 = new Logarithms\nval x = l1(1.5)\nval y = l1(2.6)\nval z = l2(3.1)\n\nl1.mul(x, y) // type checks\nl1.mul(x, z) // error: found l2.Logarithm, required l1.Logarithm\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tracked Parameters for Dependent Typing in Classes\nDESCRIPTION: Illustrates how the 'tracked' modifier for class parameters enables proper dependent typing for classes, allowing the preservation of specific type information across class instantiations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/modularity.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n  class C:\n    type T\n    ...\n\n  def f(x: C): x.T = ...\n\n  val y: C { type T = Int }\n```\n\nLANGUAGE: scala\nCODE:\n```\n  class F(val x: C):\n    val result: x.T = ...\n```\n\nLANGUAGE: scala\nCODE:\n```\n  class F(tracked val x: C):\n    val result: x.T = ...\n```\n\n----------------------------------------\n\nTITLE: Mapping Structural Method Selection to applyDynamic (with Class Tags)\nDESCRIPTION: This snippet shows how a structural method selection `v.a(...)` is translated when the `applyDynamic` implementation requires parameter type tags. The call includes the method name, literal `classOf[Tij]` expressions for each formal parameter type `Tij`, and the actual arguments `a_ij`. The result is cast to the expected return type `R`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types-spec.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nv.applyDynamic(\"a\", c11, ..., c1n, ..., cN1, ... cNn)(\n    a11, ..., a1n, ..., aN1, ..., aNn)\n    .asInstanceOf[R]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pattern Type Checking in Scala val Bindings - Scala\nDESCRIPTION: This snippet shows how declaring a typed pattern in a val binding (specifically, assigning a List of Any to a head pattern typed as String) leads to a type mismatch error in Scala 3.2, whereas it would only fail at runtime in earlier Scala versions. Requires Scala 3.2 or the '-source future' setting, and demonstrates that patterns must be irrefutable unless annotated as unchecked.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-bindings.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval xs: List[Any] = List(1, 2, 3)\nval (x: String) :: _ = xs   // error: pattern's type String is more specialized\n                                // than the right-hand side expression's type Any\n```\n\n----------------------------------------\n\nTITLE: Refutable Pattern for List Decomposition in Scala 3\nDESCRIPTION: This snippet shows a common list decomposition pattern where the list is assumed non-empty. In Scala 2, this works by default, but in Scala 3.2, it issues a warning unless annotated with @unchecked. It highlights how to suppress warnings when the developer assumes the pattern is irrefutable.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/pattern-bindings.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval first :: rest = elems: @unchecked\n```\n\n----------------------------------------\n\nTITLE: Using Intersection Types in a Function Parameter\nDESCRIPTION: Defines traits `Resettable` and `Growable[String]`, then declares a function `f` that accepts a parameter `x` which must be both `Resettable` and `Growable[String]`. The function calls `reset()` and `add(\"first\")` on `x`, illustrating the use of intersection types to specify multiple required behaviors for a single parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/new-types/intersection-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Resettable & Growable[String]) =\n  x.reset()\n  x.add(\"first\")\n```\n\n----------------------------------------\n\nTITLE: List of Contributors to Scala 3 Release\nDESCRIPTION: A Git-generated list of contributors to the Scala 3 project between versions 0.20.0-RC1 and 0.21.0-RC1, showing the number of commits made by each contributor.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_20\n\nLANGUAGE: text\nCODE:\n```\n   176  Martin Odersky\n   171  Bryan Abate\n    88  Nicolas Stucki\n    81  Jamie Thompson\n    44  noti0na1\n    29  Anatolii\n    28  bishabosha\n    23  Antoine Brunner\n    19  Guillaume Martres\n    10  Aleksander Boruch-Gruszecki\n     8  Guillaume Raffin\n     6  Olafur Pall Geirsson\n     5  Sébastien Doeraene\n     4  Aggelos Biboudis\n     4  Liu Fengyun\n     4  Paolo G. Giarrusso\n     3  Andrea Mocci\n     3  Martijn Hoekstra\n     2  Ben Elliott\n     2  Patrik Mada\n     2  Rafal Piotrowski\n     2  odersky\n     1  Markus Kahl\n     1  Richard Beddington\n     1  Vlastimil Dort\n     1  Anatolii Kmetiuk\n     1  Raphael Jolly\n     1  Lucas\n     1  Nikita Eshkeev\n     1  Brian Wignall\n     1  Olivier Blanvillain\n     1  张志豪\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Community Build Test Group with sbt (Shell)\nDESCRIPTION: Executes only the tests belonging to a specific group (e.g., `CommunityBuildTestA`) as defined in `CommunityBuildTest.scala`. This mirrors how tests are partitioned in the CI environment. The fully qualified class name of the test suite is provided to the `testOnly` task via the sbt command.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/community-build.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nsbt \"community-build/testOnly dotty.communitybuild.CommunityBuildTestA\"\n```\n\n----------------------------------------\n\nTITLE: Equivalent Generated Static main Method Class for @main Method in Scala\nDESCRIPTION: This snippet illustrates the Scala compiler-generated class corresponding to the @main annotated method 'happyBirthday'. The class contains a static 'main' method which parses command line arguments into expected parameter types using scala.util.CommandLineParser, calls the original method, and handles parsing errors by displaying them. Dependencies include scala.util.CommandLineParser for argument parsing and error handling. The input is the args Array[String] from the JVM entry point; output is Unit as the method delegates to the annotated method. This snippet clarifies the underlying Java-compatible main method generated by Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/main-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfinal class happyBirthday:\n  import scala.util.CommandLineParser as CLP\n  <static> def main(args: Array[String]): Unit =\n    try\n      happyBirthday(\n        CLP.parseArgument[Int](args, 0),\n        CLP.parseArgument[String](args, 1),\n        CLP.parseRemainingArguments[String](args, 2))\n    catch\n      case error: CLP.ParseError => CLP.showError(error)\n```\n\n----------------------------------------\n\nTITLE: Defining Top-Level Type Alias and Values in Scala 3\nDESCRIPTION: This snippet demonstrates the new capability in Dotty (Scala 3) to define types and values directly at the top level within a package, eliminating the need for package objects. It defines a type alias `Labelled` and two top-level values `a` and `b` within package `p`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage p\n\ntype Labelled[T] = (String, T)\n\nval a: Labelled[Int] = (\"count\", 1)\ndef b = a._2\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using Scala Product Match Extractor\nDESCRIPTION: Shows how to implement a Product match extractor using a class extending `Product` and a companion object with an `unapply` method returning an instance. The example demonstrates using the extractor in a `match` expression to destructure elements based on `_1`, `_2`, etc., members.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nclass FirstChars(s: String) extends Product:\n  def _1 = s.charAt(0)\n  def _2 = s.charAt(1)\n\n   // Not used by pattern matching: Product is only used as a marker trait.\n  def canEqual(that: Any): Boolean = ???\n  def productArity: Int = ???\n  def productElement(n: Int): Any = ???\n\nobject FirstChars:\n  def unapply(s: String): FirstChars = new FirstChars(s)\n\n\"Hi!\" match\n  case FirstChars(char1, char2) =>\n    println(s\"First: $char1; Second: $char2\")\n\n// First: H; Second: i\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Bounded Opaque Types for Permissions in Scala\nDESCRIPTION: Defines an 'Access' object with three related opaque type aliases over Int: 'Permissions', 'PermissionChoice', and a bounded 'Permission <: Permissions & PermissionChoice.' Accompanied by extension methods that provide bitwise operations ('&', '|') and permission-testing logic, alongside predefined permission values. All APIs are constrained to the Access module scope, supporting fine-grained access control modeling without exposing the raw Int representation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/opaques.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject Access:\n\n  opaque type Permissions = Int\n  opaque type PermissionChoice = Int\n  opaque type Permission <: Permissions & PermissionChoice = Int\n\n  extension (x: PermissionChoice)\n    def | (y: PermissionChoice): PermissionChoice = x | y\n  extension (x: Permissions)\n    def & (y: Permissions): Permissions = x | y\n  extension (granted: Permissions)\n    def is(required: Permissions) = (granted & required) == required\n    def isOneOf(required: PermissionChoice) = (granted & required) != 0\n\n  val NoPermission: Permission = 0\n  val Read: Permission = 1\n  val Write: Permission = 2\n  val ReadWrite: Permissions = Read | Write\n  val ReadOrWrite: PermissionChoice = Read | Write\n\nend Access\n```\n\n----------------------------------------\n\nTITLE: Accessing Exported Members in Scala Class Instance\nDESCRIPTION: Illustrates how to interact with an instance of a class defined using the `export` keyword (the `Copier` class). It shows that the exported methods (`print`, `scan`) from the internal components (`printUnit`, `scanUnit`) can be called directly on the `copier` instance as if they were its own members.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-04-15-14th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval copier = new Copier\ncopier.print(copier.scan())\n```\n\n----------------------------------------\n\nTITLE: Dependent Function Type Syntax in Scala 3\nDESCRIPTION: The basic syntax for dependent function types in Scala 3, showing how a function type can refer to its parameter in its return type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/dependent-function-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n(e: Entry) => e.Key\n```\n\n----------------------------------------\n\nTITLE: Defining Opaque Type Wrappers for Units in Scala\nDESCRIPTION: This code shows two opaque type definitions for Meter and Second, both wrapping Double, along with their companion constructors. Dependencies: Scala 3 opaque type feature. This exemplifies reusing the same runtime representation (Double) for logically distinct units, but does not enforce semantic distinction at runtime unless further measures are taken.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/matchable.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nopaque type Meter = Double\ndef Meter(x: Double): Meter = x\n\nopaque type Second = Double\ndef Second(x: Double): Second = x\n```\n\n----------------------------------------\n\nTITLE: Using a Code Generation Function within a Quote Block in Scala\nDESCRIPTION: Illustrates splicing the result of the `unrolledPowerCode` function into a quoted code block. The call `${ unrolledPowerCode('{x}, 3) }` is evaluated during compilation, replacing the splice with the generated expression `x * x * x`. Assumes `unrolledPowerCode` is defined and a `Quotes` context is available.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n'{\n  val x = ...\n  ${ unrolledPowerCode('{x}, 3) } // evaluates to: x * x * x\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Alphanumeric Method Infix Restrictions in Scala 3\nDESCRIPTION: Illustrates how alphanumeric methods are not allowed to be used in infix position by default, generating a deprecation warning when used this way.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-05-23-15th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Foo(x: Int) { def plus(other: Foo) = x + other.x }\nFoo(1) plus Foo(2)\nFoo(1).plus(Foo(2))\n```\n\n----------------------------------------\n\nTITLE: Implementing a Generic Expression Evaluator with Improved GADT Support in Scala\nDESCRIPTION: Presents how to implement type-safe expression evaluation with Generalized Algebraic Data Types (GADTs) in Scala 3. The example defines an expression trait with a type parameter representing the return type, along with case classes for literals and pairs. The evaluator function uses pattern matching with inferred precise types, enabling compile-time type safety and returning strongly typed results rather than using Any. This demonstrates enhanced GADT support in Dotty 0.7.0-RC1, which catches more type errors at compile-time.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-03-05-seventh-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Exp\ncase class Lit(value: Int) extends Exp\ncase class Pair(fst: Exp, snd: Exp) extends Exp\n\nobject Evaluator {\n  def eval(e: Exp): Any = e match {\n    case Lit(x) =>\n      x\n    case Pair(a, b) =>\n      (eval(a), eval(b))\n  }\n\n  eval(Lit(1))                             // 1: Any\n  eval(Pair(Pair(Lit(1), Lit(2)), Lit(3))) // ((1, 2), 3) : Any\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Exp[T]\ncase class Lit(value: Int) extends Exp[Int]\ncase class Pair[A, B](fst: Exp[A], snd: Exp[B]) extends Exp[(A, B)]\n\nobject Evaluator {\n  def eval[T](e: Exp[T]): T = e match {\n    case Lit(x) =>\n      // In this case, T = Int\n      x\n    case Pair(a, b) =>\n      // In this case, T = (A, B) where A is the type of a and B is the type of b\n      (eval(a), eval(b))\n  }\n\n  eval(Lit(1))                             // 1: Int\n  eval(Pair(Pair(Lit(1), Lit(2)), Lit(3))) // ((1, 2), 3) : ((Int, Int), Int)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Core Predef Utilities and Types\nDESCRIPTION: Defines the core structure of the `scala.Predef` object, including fundamental methods like `classOf` (compiler-handled), `valueOf` (compiler-assisted), standard type aliases (String, Class, Collection types), utility functions (`identity`, `implicitly`, `locally`), and validation methods (`assert`, `assume`, `require`) for preconditions and postconditions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\nobject Predef {\n\n  // classOf ---------------------------------------------------------\n\n  /** Returns the runtime representation of a class type. */\n  def classOf[T]: Class[T] = null\n   // this is a dummy, classOf is handled by compiler.\n\n  // valueOf -----------------------------------------------------------\n\n  /** Retrieve the single value of a type with a unique inhabitant. */\n  @inline def valueOf[T](implicit vt: ValueOf[T]): T {} = vt.value\n   // instances of the ValueOf type class are provided by the compiler.\n\n  // Standard type aliases ---------------------------------------------\n\n  type String    = java.lang.String\n  type Class[T]  = java.lang.Class[T]\n\n  // Miscellaneous -----------------------------------------------------\n\n  type Function[-A, +B] = Function1[A, B]\n\n  type Map[A, +B] = collection.immutable.Map[A, B]\n  type Set[A] = collection.immutable.Set[A]\n\n  val Map = collection.immutable.Map\n  val Set = collection.immutable.Set\n\n  // Manifest types, companions, and incantations for summoning ---------\n\n  type ClassManifest[T] = scala.reflect.ClassManifest[T]\n  type Manifest[T]      = scala.reflect.Manifest[T]\n  type OptManifest[T]   = scala.reflect.OptManifest[T]\n  val ClassManifest     = scala.reflect.ClassManifest\n  val Manifest          = scala.reflect.Manifest\n  val NoManifest        = scala.reflect.NoManifest\n\n  def manifest[T](implicit m: Manifest[T])           = m\n  def classManifest[T](implicit m: ClassManifest[T]) = m\n  def optManifest[T](implicit m: OptManifest[T])     = m\n\n  // Minor variations on identity functions -----------------------------\n  def identity[A](x: A): A         = x\n  def implicitly[T](implicit e: T) = e    // for summoning implicit values from the nether world\n  @inline def locally[T](x: T): T  = x    // to communicate intent and avoid unmoored statements\n\n  // Asserts, Preconditions, Postconditions -----------------------------\n\n  def assert(assertion: Boolean) {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed\")\n  }\n\n  def assert(assertion: Boolean, message: => Any) {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed: \" + message)\n  }\n\n  def assume(assumption: Boolean) {\n    if (!assumption)\n      throw new IllegalArgumentException(\"assumption failed\")\n  }\n\n  def assume(assumption: Boolean, message: => Any) {\n    if (!assumption)\n      throw new IllegalArgumentException(\"assumption failed: \" + message.toString)\n  }\n\n  def require(requirement: Boolean) {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed\")\n  }\n\n  def require(requirement: Boolean, message: => Any) {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed: \"+ message)\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Recursive Reference Within an Extension Method in Scala\nDESCRIPTION: Demonstrates how an extension method can recursively call itself by implicitly using the receiver as a prefix. This allows internal recursion within an extension method without explicitly passing the extended receiver each time. The snippet shows the rewritten form from implicit receiver usage perspective and how the method expands to a normal static method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nextension (s: String)\n  def position(ch: Char, n: Int): Int =\n    if n < s.length && s(n) != ch then position(ch, n + 1)\n    else n\n\n// rewrites to\n\ndef position(s: String)(ch: Char, n: Int): Int =\n  if n < s.length && s(n) != ch then position(s)(ch, n + 1)\n  else n\n```\n\n----------------------------------------\n\nTITLE: Automatic Eta Expansion with Implicit Parameters in Scala\nDESCRIPTION: Illustrates how methods with implicit parameter lists are automatically eta-expanded while applying the implicit arguments, resulting in a function that only requires the explicit parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/eta-expansion-spec.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(x: Int)(implicit p: Double): Float = ???\nimplicit val bla: Double = 1.0\n\nval bar = foo // val bar: Int => Float = ...\n```\n\n----------------------------------------\n\nTITLE: Debugging 'Position Not Set' Error with Tree ID in Scala 3\nDESCRIPTION: Use the Scala 3 compiler flag `-Ydebug-tree-with-id <ID>` (e.g., `-Ydebug-tree-with-id 2326942`) to make the compiler crash when a specific Abstract Syntax Tree (AST), identified by its ID from a 'position not set' error message, is created. Examining the resulting stack trace helps pinpoint where the problematic tree without position information originates.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/debug-macros.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n-Ydebug-tree-with-id 2326942\n```\n\n----------------------------------------\n\nTITLE: Compiling Scala Source Files with scalac - Shell\nDESCRIPTION: Compiles the Scala source file 'while.scala' located in the 'tests/debug' directory using the 'scalac' command. This creates compiled '.class' files, making them ready for execution or debugging. Ensure that the 'scalac' compiler is properly installed, and the target file exists at the specified path.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nscalac tests/debug/while.scala\n```\n\n----------------------------------------\n\nTITLE: Complete Scala Low-Level Eq Derivation Example\nDESCRIPTION: Presents the full Scala source code for implementing the `Eq` type class with low-level derivation using `inline` and `Mirror`. It includes the `Eq` trait, its companion object with a base instance for `Int`, helper functions (`check`, `iterable`, `eqSum`, `eqProduct`), the recursive instance summoning helpers, and the core `derived` method, demonstrating a complete working example. Requires imports from `scala.collection`, `scala.compiletime`, and `scala.deriving`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.AbstractIterable\nimport scala.compiletime.{erasedValue, error, summonInline}\nimport scala.deriving.*\n\ninline def summonInstances[T, Elems <: Tuple]: List[Eq[?]] = \n  inline erasedValue[Elems] match\n    case _: (elem *: elems) => deriveOrSummon[T, elem] :: summonInstances[T, elems]\n    case _: EmptyTuple => Nil\n\ninline def deriveOrSummon[T, Elem]: Eq[Elem] = \n  inline erasedValue[Elem] match\n    case _: T => deriveRec[T, Elem]\n    case _    => summonInline[Eq[Elem]]\n\ninline def deriveRec[T, Elem]: Eq[Elem] = \n  inline erasedValue[T] match\n    case _: Elem => error(\"infinite recursive derivation\")\n    case _       => Eq.derived[Elem](using summonInline[Mirror.Of[Elem]]) // recursive derivation\n\ntrait Eq[T]:\n  def eqv(x: T, y: T): Boolean\n\nobject Eq:\n  given Eq[Int]:\n    def eqv(x: Int, y: Int) = x == y\n\n  def check(x: Any, y: Any, elem: Eq[?]): Boolean =\n    elem.asInstanceOf[Eq[Any]].eqv(x, y)\n\n  def iterable[T](p: T): Iterable[Any] = new AbstractIterable[Any]:\n    def iterator: Iterator[Any] = p.asInstanceOf[Product].productIterator\n\n  def eqSum[T](s: Mirror.SumOf[T], elems: => List[Eq[?]]): Eq[T] = \n    new Eq[T]:\n      def eqv(x: T, y: T): Boolean =\n        val ordx = s.ordinal(x)\n        (s.ordinal(y) == ordx) && check(x, y, elems(ordx))\n\n  def eqProduct[T](p: Mirror.ProductOf[T], elems: => List[Eq[?]]): Eq[T] = \n    new Eq[T]:\n      def eqv(x: T, y: Any): Boolean =\n        iterable(x).lazyZip(iterable(y)).lazyZip(elems).forall(check)\n\n  inline def derived[T](using m: Mirror.Of[T]): Eq[T] = \n    lazy val elemInstances = summonInstances[T, m.MirroredElemTypes]\n    inline m match\n      case s: Mirror.SumOf[T]     => eqSum(s, elemInstances)\n      case p: Mirror.ProductOf[T] => eqProduct(p, elemInstances)\nend Eq\n```\n\n----------------------------------------\n\nTITLE: Defining scala.xml.Node Trait with XML Tree Traversal and XPath-like Methods - Scala\nDESCRIPTION: Defines the trait Node representing an XML node with key methods including label retrieval, attribute access as a Map, child and descendant traversals, and equality/hashcode overrides. It implements XPath-like projection operators \\ and \\\\ for selecting child nodes by label and descendant nodes respectively, preserving document order. This trait serves as a base for XML processing with node navigation and pattern matching support.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.xml\n\ntrait Node {\n\n  /** the label of this node */\n  def label: String\n\n  /** attribute axis */\n  def attribute: Map[String, String]\n\n  /** child axis (all children of this node) */\n  def child: Seq[Node]\n\n  /** descendant axis (all descendants of this node) */\n  def descendant: Seq[Node] = child.toList.flatMap {\n    x => x::x.descendant.asInstanceOf[List[Node]]\n  }\n\n  /** descendant axis (all descendants of this node) */\n  def descendant_or_self: Seq[Node] = this::child.toList.flatMap {\n    x => x::x.descendant.asInstanceOf[List[Node]]\n  }\n\n  override def equals(x: Any): Boolean = x match {\n    case that:Node =>\n      that.label == this.label &&\n        that.attribute.sameElements(this.attribute) &&\n          that.child.sameElements(this.child)\n    case _ => false\n  }\n\n /** XPath style projection function. Returns all children of this node\n  *  that are labeled with 'that'. The document order is preserved.\n  */\n    def \\(that: Symbol): NodeSeq = {\n      new NodeSeq({\n        that.name match {\n          case \"_\" => child.toList\n          case _ =>\n            var res:List[Node] = Nil\n            for (x <- child.elements if x.label == that.name) {\n              res = x::res\n            }\n            res.reverse\n        }\n      })\n    }\n\n /** XPath style projection function. Returns all nodes labeled with the\n  *  name 'that' from the 'descendant_or_self' axis. Document order is preserved.\n  */\n  def \\\\(that: Symbol): NodeSeq = {\n    new NodeSeq(\n      that.name match {\n        case \"_\" => this.descendant_or_self\n        case _ => this.descendant_or_self.asInstanceOf[List[Node]].\n        filter(x => x.label == that.name)\n      })\n  }\n\n  /** hashcode for this XML node */\n  override def hashCode =\n    Utility.hashCode(label, attribute.toList.hashCode, child)\n\n  /** string representation of this node */\n  override def toString = Utility.toXML(this)\n\n}\n```\n\n----------------------------------------\n\nTITLE: Array Companion Object Factory and Utility Methods - Scala\nDESCRIPTION: Outlines the Array companion object providing factory methods for creating arrays of various dimensions and types using ClassTag, methods for copying, concatenating, filling, tabulating, and generating ranges or iterative arrays. Also includes unapplySeq for pattern matching over arrays. The snippet lists method signatures and brief summaries illustrating the rich API available for Scala arrays.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\nobject Array {\n  /** copies array elements from `src` to `dest`. */\n  def copy(src: AnyRef, srcPos: Int,\n           dest: AnyRef, destPos: Int, length: Int): Unit = ...\n\n  /** Returns an array of length 0 */\n  def empty[T: ClassTag]: Array[T] =\n\n  /** Create an array with given elements. */\n  def apply[T: ClassTag](xs: T*): Array[T] = ...\n\n  /** Creates array with given dimensions */\n  def ofDim[T: ClassTag](n1: Int): Array[T] = ...\n  /** Creates a 2-dimensional array */\n  def ofDim[T: ClassTag](n1: Int, n2: Int): Array[Array[T]] = ...\n  ...\n\n  /** Concatenate all argument arrays into a single array. */\n  def concat[T: ClassTag](xss: Array[T]*): Array[T] = ...\n\n  /** Returns an array that contains the results of some element computation a number\n    * of times. */\n  def fill[T: ClassTag](n: Int)(elem: => T): Array[T] = ...\n  /** Returns a two-dimensional array that contains the results of some element\n    * computation a number of times. */\n  def fill[T: ClassTag](n1: Int, n2: Int)(elem: => T): Array[Array[T]] = ...\n  ...\n\n  /** Returns an array containing values of a given function over a range of integer\n    * values starting from 0. */\n  def tabulate[T: ClassTag](n: Int)(f: Int => T): Array[T] = ...\n  /** Returns a two-dimensional array containing values of a given function\n    * over ranges of integer values starting from `0`. */\n  def tabulate[T: ClassTag](n1: Int, n2: Int)(f: (Int, Int) => T): Array[Array[T]] = ...\n  ...\n\n  /** Returns an array containing a sequence of increasing integers in a range. */\n  def range(start: Int, end: Int): Array[Int] = ...\n  /** Returns an array containing equally spaced values in some integer interval. */\n  def range(start: Int, end: Int, step: Int): Array[Int] = ...\n\n  /** Returns an array containing repeated applications of a function to a start value. */\n  def iterate[T: ClassTag](start: T, len: Int)(f: T => T): Array[T] = ...\n\n  /** Enables pattern matching over arrays */\n  def unapplySeq[A](x: Array[A]): Option[IndexedSeq[A]] = Some(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Eta Expansion with Context Parameters and Query Types in Scala 3\nDESCRIPTION: Demonstrates how to expand a method with context parameters to a value of a context function type by explicitly specifying the expected type, using the new context function syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/eta-expansion-spec.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(x: Int)(using p: Double): Float = ???\nval bar: Double ?=> Float = foo(3)\n```\n\n----------------------------------------\n\nTITLE: Syntax overview of 'using' clauses in Scala 3\nDESCRIPTION: Provides syntactic definitions for 'using' clauses in class parameters, function parameters, and arguments, illustrating the new syntax introduced in Scala 3 for context parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/using-clauses.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nClsParamClause ::= ... | UsingClsParamClause\nDefParamClauses ::= ... | UsingParamClause\nUsingClsParamClause ::= ‘(’ ‘using’ (ClsParams | Types) ‘)’\nUsingParamClause ::= ‘(’ ‘using’ (DefParams | Types) ‘)’\nParArgumentExprs ::= ... | ‘(’ ‘using’ ExprsInParens ‘)’\n```\n\n----------------------------------------\n\nTITLE: Capture Checking Failure with Generic Set and Proc in Scala 3\nDESCRIPTION: Shows an example where attempting to instantiate a generic Set with a Proc type parameter fails due to capture restrictions preventing instantiation of type parameters to non-sealed or violating types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef cons(x: Proc, xs: Set[Proc]) =\n  Set.include[Proc](x, xs) // error: can't instantiate type parameter to Proc\n```\n\n----------------------------------------\n\nTITLE: Defining a Method with @use on a Term Parameter (Scala)\nDESCRIPTION: Defines a method `runOps` that takes a list of functions (`ops`) annotated with `@use`. This annotation signifies that the capture set associated with `ops` should be considered \"used\" by the method, impacting how capture checking handles its environment, particularly relevant for rule 5 of the proposed design.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/use-design.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef runOps(@use ops: List[() => Unit]): Unit = ops.foreach(_())\n```\n\n----------------------------------------\n\nTITLE: Comparing Type Lambdas for Subtyping in Scala\nDESCRIPTION: This Scala snippet illustrates the subtyping rules for two type lambdas, TL1 and TL2. It shows that TL1 is a subtype of TL2 if TL2's bounds are narrower (L1 <: L2, U2 <: U1) and TL1's result type R1 is a subtype of TL2's result type R2, assuming alpha-renaming for bound variables.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas-spec.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntype TL1  =  [X >: L1 <: U1] =>> R1\ntype TL2  =  [X >: L2 <: U2] =>> R2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Local Type Inference with Type Constraints and Polymorphic Arguments - Scala\nDESCRIPTION: Presents another example of local type inference where a generic method `cons` is invoked with a String and a List[Int]. The example illustrates a fallback typing strategy when direct typing with expected types fails, leading to a different solution for the inferred type parameter `a`. This snippet leverages type constraints and variance rules to deduce type arguments that satisfy subtyping relations. It requires the previous definitions of `cons` and `xs` and demonstrates polymorphic argument typing and constraint solving in Scala type inference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_55\n\nLANGUAGE: scala\nCODE:\n```\nval ys = cons(\"abc\", xs)\n```\n\n----------------------------------------\n\nTITLE: Nesting Considerations in Implicit Resolution in Scala 3 Scala\nDESCRIPTION: Illustrates how nested implicit parameters are preferred over outer ones during implicit resolution. The example shows an inner method with an implicit parameter shadowing an outer implicit parameter of the same type, with the inner binding selected by the \"implicitly\" method call, reflecting the new nesting sensitivity to avoid ambiguity errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-resolution.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n  def f(implicit i: C) = {\n    def g(implicit j: C) = {\n      implicitly[C]\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Using Recursive and Refined Types Together in Scala\nDESCRIPTION: This Scala example demonstrates how a refined type referring to 'this' is desugared into a recursive type by the compiler. It entails defining a trait with a type member (X) and a method referencing it, then using subtyping to check conformance between concrete and recursive type instances. Input includes trait definitions for T, Z, and some value declarations; output is type relationships validated at compile time.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\ntrait Z extends T:\n  type X = Option[Int]\n  def foo: Option[Int] = Some(5)\n\nval z: Z\n```\n\n----------------------------------------\n\nTITLE: Equality Operations on Opaque Types in Scala 3\nDESCRIPTION: Explains that comparing values of an opaque type using == or != normally uses universal equality unless specifically overloaded. To improve performance and avoid boxing, after type checking, the equality comparisons are dispatched to the underlying type's equality operators. The code example defines an opaque type T as Int and compares two values of T using ==, which maps to Int equality.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/opaques-details.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nopaque type T = Int\n\n...\nval x: T\nval y: T\nx == y    // uses Int equality for the comparison.\n```\n\n----------------------------------------\n\nTITLE: Compiler Expansion for Traits with Context Parameters in Scala\nDESCRIPTION: This snippet illustrates how Scala's compiler expands inheritance involving traits that require context parameters, explicitly showing the insertion of an additional parent (`ImpliedGreeting`) with inferred arguments. No dependencies beyond previously defined traits. Purpose: clarifies how context parameter inheritance operates behind the scenes. Limitations: for illustration only; actual expansion is handled automatically by the compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/trait-parameters.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass F(using iname: ImpliedName) extends\n  Object,\n  ImpliedGreeting(using iname),\n  ImpliedFormalGreeting\n```\n\n----------------------------------------\n\nTITLE: Eta Expansion of a Method with @use Parameter (Scala)\nDESCRIPTION: Demonstrates the problematic eta expansion of the `runOps` method. Because anonymous functions cannot have `@use` parameters (rule 1), but passing the argument `xs` to the original `runOps` requires charging `xs*` to the environment (rule 5), this expansion violates rule 3, which disallows charging `xs*` if `xs` is not `@use`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/use-design.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n(xs: List[() => Unit]) => runOps(xs)\n```\n\n----------------------------------------\n\nTITLE: Flow Typing Limitation: Variables Mutated by Closures in Scala 3\nDESCRIPTION: Explains a limitation of flow typing for mutable variables: tracking is disabled if the variable is assigned within a closure. This is because the closure could be executed concurrently or at an unpredictable time, invalidating any flow-derived facts in the surrounding scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nvar x: String | Null = ???\ndef y =\n  x = null\n\nif x != null then\n   // y can be called here, which would break the fact\n   val a: String = x // error: x is captured and mutated by the closure, not trackable\n```\n\n----------------------------------------\n\nTITLE: Transitive Capture Checking in Nested Scala Functions\nDESCRIPTION: Shows that a closure also captures all capabilities captured by the functions it calls. Here, function f calls g, which returns a lambda capturing fs. Therefore, f indirectly captures fs, and the overall type of test reflects this capture set {fs} on the returned lambda.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ndef test(fs: FileSystem) =\n  def f() = g()\n  def g() = (x: String) => Logger(fs).log(x)\n  f\n```\n\n----------------------------------------\n\nTITLE: Invalid Direct Reference to Erased Class Instance in Scala\nDESCRIPTION: Illustrates an error that occurs when attempting to create or reference a value of an erased class type in a non-erased context. The type system ensures that erased class instances cannot escape erased usage and will reject any attempt to store them as non-erased types such as 'Any'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nval err: Any = CanRead() // error: illegal reference to erased class CanRead\n```\n\n----------------------------------------\n\nTITLE: Name Categories in DOT Calculus\nDESCRIPTION: The classification of different name types used in the DOT calculus grammar, including variables, methods, and types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-02-03-essence-of-scala.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nx      for (immutable) variables\na      for (parameterless) methods\nA      for types\n```\n\n----------------------------------------\n\nTITLE: Formal Syntax Definition for Scala 3 Export Clauses\nDESCRIPTION: Presents the formal EBNF-style grammar rules detailing how `Export` clauses integrate into Scala 3's syntax. It defines `Export`, `ImportExpr`, `ImportSpec`, `NamedSelector`, `WildCardSelector`, and `ImportSelectors`, showing their relationship to `TemplateStat`, `TopStat`, and `ExtMethod`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_11\n\nLANGUAGE: Syntax\nCODE:\n```\nTemplateStat      ::=  ...\n                    |  Export\nTopStat           ::=  ...\n                    |  Export\nExtMethod         ::=  ...\n                    |  Export\nExport            ::=  ‘export’ ImportExpr {‘,’ ImportExpr}\nImportExpr        ::=  SimpleRef {‘.’ id} ‘.’ ImportSpec\nImportSpec        ::=  NamedSelector\n                    |  WildcardSelector\n                    | ‘{’ ImportSelectors) ‘}’\nNamedSelector     ::=  id [‘as’ (id | ‘_’)]\nWildCardSelector  ::=  ‘*’ | ‘given’ [InfixType]\nImportSelectors   ::=  NamedSelector [‘,’ ImportSelectors]\n                    |  WildCardSelector {‘,’ WildCardSelector}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Import Syntax Grammar Definition\nDESCRIPTION: Provides the formal grammar rules defining the structure of the `import` statement and its components in Scala 3. This block outlines the permissible syntax for import expressions, import specifications, named selectors, and wildcard selectors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/imports.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nImport            ::=  ‘import’ ImportExpr {‘,’ ImportExpr}\nImportExpr        ::= SimpleRef {‘.’ id} ‘.’ ImportSpec\n                    | SimpleRef `as` id\nImportSpec        ::=  NamedSelector\n                    |  WildcardSelector\n                    | ‘{’ ImportSelectors) ‘}’\nNamedSelector     ::=  id [‘as’ (id | ‘_’)]\nWildCardSelector  ::=  ‘*' | ‘given’ [InfixType]\nImportSelectors   ::=  NamedSelector [‘,’ ImportSelectors]\n                    |  WildCardSelector {‘,’ WildCardSelector}\n```\n\n----------------------------------------\n\nTITLE: Mixin Composition for Synchronized List Table in Scala\nDESCRIPTION: This snippet demonstrates the creation of a singleton object combining a concrete list-based table with synchronization capabilities using mixin composition. It inherits synchronized `get` and `set` from `SynchronizedTable` which delegate to `ListTable` implementations. The table uses strings as keys, integers as values, and defaults to zero for missing keys.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\nobject MyTable extends ListTable[String, Int](0) with SynchronizedTable[String, Int]\n```\n\n----------------------------------------\n\nTITLE: Compiling Several Scala Files in Debug Launch Args - JSON\nDESCRIPTION: Shows how to extend a VSCode Scala debug configuration to compile multiple Scala files by listing them in the 'args' property of launch.json. No additional dependencies beyond those needed for single-file compilation. Files to compile are passed as arguments, followed by the classpath option. Limitations: All referenced files must exist and be valid Scala source files.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/ide-debugging.md#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n\"args\": [\n  \"file1.scala\",\n  \"file2.scala\",\n  \"-classpath\",\n  \"/home/user/scala/scala3/out/bootstrap/scala3-library-bootstrapped/scala-3.3.1-RC1-bin-SNAPSHOT-nonbootstrapped/classes:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.10/scala-library-2.13.10.jar\"\n]\n```\n\n----------------------------------------\n\nTITLE: Defining the TupledFunction Type Class in Scala\nDESCRIPTION: Defines the TupledFunction type class that relates a function type F with its equivalent tupled function type G, where G is a function of a single tuple argument. It provides methods to convert between the untupled and tupled versions of the function. This trait is sealed and requires implicit resolution for conversion instances. Key parameters are the function types F and G, which must correspond in arity and result type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/tupled-function.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n/** Type class relating a `FunctionN[...\\, R]` with an equivalent tupled function `Function1[TupleN[...], R]`\\n *\\n *  @tparam F a function type\\n *  @tparam G a tupled function type (function of arity 1 receiving a tuple as argument)\\n */\\n@implicitNotFound(\"${F} cannot be tupled as ${G}\")\\nsealed trait TupledFunction[F, G] {\\n  def tupled(f: F): G\\n  def untupled(g: G): F\\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Capture Set Violation with Parametric Types in Scala\nDESCRIPTION: This Scala snippet shows how capture checking prevents returning closures with a local capability wrapped in parametric types, such as in a class instance. Here, a `Cell` class instances with a captured closure from `usingLogFile`. When the closure is accessed later, the capture set changes to the universal capability `cap`, causing a compile-time error. This enforces monotonicity of capture sets to avoid capability leaks through parameterized types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nclass Cell[+A](x: A)\nval sneaky = usingLogFile { f => Cell(() => f.write(0)) }\nsneaky.x()\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Source Code Rewriting Commands\nDESCRIPTION: Describes the compiler's code rewriting capabilities between old and new Scala syntax. Specifies command-line options '-rewrite -new-syntax' for converting old syntax to new, omitting parentheses and braces, and '-rewrite -old-syntax' for reversing the process, restoring traditional syntax structures.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/control-syntax.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Defining and Using Pattern Matching Case Classes in Dotty (Scala)\nDESCRIPTION: This Scala snippet defines a case class 'CC' and two functions that utilize pattern matching and type checking. The function 'foo' matches on nested case classes, binding and destructuring values, while 'booleans' evaluates type checks against input and matches on tuples of boolean results. No special dependencies beyond the Scala standard library and case class definitions are required. Inputs are generic objects and outputs are computed integers or booleans, depending on pattern matching outcome; efficiency depends heavily on code generation strategy.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-07-12-second-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class CC(a: Int, b: Object)\n\n  def foo(x: Any): Int = {\n    val (a, b) = x match {\n      case CC(s @ 1, CC(t, _)) =>\n        (s , 2)\n      case _ => (42, 43)\n    }\n    a + b\n  }\n\n  def booleans(a: Object) = {\n    val (b1, b2) = (a.isInstanceOf[CC], a.isInstanceOf[List[Int]])\n    (b1, b2) match {\n      case (true, true) => true\n      case (false, false) => true\n      case _ => false\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining the `Mirror` Trait in Scala 3\nDESCRIPTION: Defines the core `scala.deriving.Mirror` sealed trait and its nested `Product` and `Sum` traits. It includes type members like `MirroredType`, `MirroredElemTypes`, `MirroredMonoType`, `MirroredLabel`, and `MirroredElemLabels` to provide type-level information about a data type. The `Product` trait adds `fromProduct` for reconstructing instances, and the `Sum` trait adds `ordinal` for identifying sum type elements.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Mirror:\n\n  /** the type being mirrored */\n  type MirroredType\n\n  /** the type of the elements of the mirrored type */\n  type MirroredElemTypes\n\n  /** The mirrored *-type */\n  type MirroredMonoType\n\n  /** The name of the type */\n  type MirroredLabel <: String\n\n  /** The names of the elements of the type */\n  type MirroredElemLabels <: Tuple\n\nobject Mirror:\n\n  /** The Mirror for a product type */\n  trait Product extends Mirror:\n\n    /** Create a new instance of type `T` with elements\n     *  taken from product `p`.\n     */\n    def fromProduct(p: scala.Product): MirroredMonoType\n\n  trait Sum extends Mirror:\n\n    /** The ordinal number of the case class of `x`.\n     *  For enums, `ordinal(x) == x.ordinal`\n     */\n    def ordinal(x: MirroredMonoType): Int\n\nend Mirror\n```\n\n----------------------------------------\n\nTITLE: Parameter Constraints on `infix` Methods and Extensions in Scala 3\nDESCRIPTION: Explains that methods marked with the `infix` modifier must have the first non-receiver parameter list with exactly one parameter. The snippet provides valid and invalid examples for standalone methods and extension methods to illustrate the compiler's enforcement of this constraint, ensuring consistent and unambiguous usage of infix operators.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/operators.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ninfix def op1(x: S): R             // ok\ninfix def op2[T](x: T)(y: S): R    // ok\ninfix def op3[T](x: T, y: S): R    // error: two parameters\n\nextension (x: A)\n  infix def op4(y: B): R          // ok\n  infix def op5(y1: B, y2: B): R  // error: two parameters\n```\n\n----------------------------------------\n\nTITLE: Visualizing Scala 3 Macro Compilation Stages Using Nested Quotes in Scala\nDESCRIPTION: This snippet illustrates a syntactic way to conceptualize the multi-stage compilation of macros by nesting quoted blocks. Each nested quote represents a successive compilation stage: the innermost macro library, the dependent library using macros, and finally the application code that invokes the library. This visualization helps understand how compilation is delayed to ensure proper macro expansion order. The sample uses Scala quoted expressions with the `'{}'` syntax, showing how macro definitions and calls are nested to represent compilation order. It requires Scala 3 with staging and macro support.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\n'{ // macro library (compilation stage 1)\n  def powerCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] =\n    ...\n  inline def powerMacro(x: Double, inline n: Int): Double =\n    ${ powerCode('x, 'n) }\n  '{ // library using macros (compilation stage 2)\n    def power2(x: Double) =\n      ${ powerCode('x, '{2}) } // inlined from a call to: powerMacro(x, 2)\n    '{ power2(3.14) /* app (compilation stage 3) */ }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Inheritance with Parameterized Traits in Scala\nDESCRIPTION: This snippet illustrates an error case where a class attempts to inherit the same parameterized trait `Greeting` multiple times with different arguments, which is illegal in Scala 3. The example demonstrates Scala's type system preventing ambiguous trait parameter usage. No external dependencies. Parameters: class `D` attempts to inherit from both `C` and `Greeting(\"Bill\")`. Input/Output: code fails to compile; purpose is to illustrate a language constraint.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/trait-parameters.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass D extends C, Greeting(\"Bill\") // error: parameter passed twice\n```\n\n----------------------------------------\n\nTITLE: Defining and Expanding Erased Classes and Usages in Scala\nDESCRIPTION: Introduces the use of the erased modifier for class, val, def, and given declarations. Displays the expansion from normal to erased forms when used with erased classes as types. Shows that vals, defs, and givens producing erased types are automatically made erased, and demonstrates the underlying generated code corresponding to erased class usage. This snippet does not require dependencies beyond Scala 3 configured for erased features.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nerased class CanRead\n\nval x: CanRead = ...        // `x` is turned into an erased val\nval y: CanRead => Int = ... // the function is turned into an erased function\ndef f(x: CanRead) = ...     // `f` takes an erased parameter\ndef g(): CanRead = ...      // `g` is turned into an erased def\ngiven CanRead = ...         // the anonymous given is assumed to be erased\n```\n\n----------------------------------------\n\nTITLE: Defining Infix and Symbolic Operators with infix Modifier and @targetName in Scala\nDESCRIPTION: This Scala trait demonstrates how to define both alphanumeric (infix) and symbolic operators with the required 'infix' modifier and an optional @targetName annotation for interoperability and documentation. The 'union' method is declared with 'infix' to permit infix usage, while the symbolic '*' operator is annotated with @targetName for better external referencing. The code illustrates various valid ways to invoke these operators, including infix, backticked, and method-call notation. Dependencies: Requires Scala 3 with support for the 'infix' modifier and scala.annotation.targetName. Inputs: Definitions and invocations of MultiSet operations; Outputs: Instances of MultiSet resulting from union, difference, or * operations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/operators.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.targetName\n\ntrait MultiSet[T]:\n\n  infix def union(other: MultiSet[T]): MultiSet[T]\n\n  def difference(other: MultiSet[T]): MultiSet[T]\n\n  @targetName(\"intersection\")\n  def *(other: MultiSet[T]): MultiSet[T]\n\nend MultiSet\n\nval s1, s2: MultiSet[Int]\n\ns1 union s2         // OK\ns1 `union` s2       // also OK but unusual\ns1.union(s2)        // also OK\n\ns1.difference(s2)   // OK\ns1 `difference` s2  // OK\ns1 difference s2    // gives a deprecation warning\n\ns1 * s2             // OK\ns1 `*` s2           // also OK, but unusual\ns1.*(s2)            // also OK, but unusual\n```\n\n----------------------------------------\n\nTITLE: Using scala.compiletime.ops for Singleton Type Operations in Scala\nDESCRIPTION: Illustrates the usage of types in the `scala.compiletime.ops` package to perform primitive operations on singleton types at the type level. Examples include integer multiplication and boolean conjunction yielding compile-time constant types. The snippet also shows correct operator precedence in type-level expressions and demonstrates dispatching overloaded operations for Int and String types with match types. Required imports are from `scala.compiletime.ops.int` and `scala.compiletime.ops.boolean`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/compiletime-ops.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.ops.int.*\nimport scala.compiletime.ops.boolean.*\n\nval conjunction: true && true = true\nval multiplication: 3 * 5 = 15\n\n// Correct precedence handling\nimport scala.compiletime.ops.int.*\nval x: 1 + 2 * 3 = 7\n\n// Dispatching addition over Int and String using match types\nimport scala.compiletime.ops.*\nimport scala.annotation.infix\n\ntype +[X <: Int | String, Y <: Int | String] = (X, Y) match\n  case (Int, Int) => int.+[X, Y]\n  case (String, String) => string.+[X, Y]\n\nval concat: \"a\" + \"b\" = \"ab\"\nval addition: 1 + 1 = 2\n```\n\n----------------------------------------\n\nTITLE: Mapping List of Tuples with Predefined Function (Scala)\nDESCRIPTION: Demonstrates applying a predefined function `combine` that accepts two `Int` parameters to the list of tuples `xs`. Scala 3's parameter untupling automatically adapts the `combine` function application, effectively calling `combine(x, y)` for each tuple `(x, y)` in the list.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/parameter-untupling.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef combine(i: Int, j: Int) = i + j\nxs.map(combine)\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Structural Given with Context Parameter Scala 3\nDESCRIPTION: Defines a structural given named `listOrd` for `Ord[List[T]]`. This given is parameterized by type `T` and depends on the availability of a given `Ord[T]` in the context, expressed using the `[T] => Ord[T] =>` syntax before the target type `Ord[List[T]]`. The implementation is provided directly within the given's body.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/more-givens.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ngiven listOrd: [T] => Ord[T] => Ord[List[T]]:\n  ...\n  def compare(x: List[T], y: List[T]) = ...\n```\n\n----------------------------------------\n\nTITLE: Match Expression Syntax Definition in Scala\nDESCRIPTION: This code snippet defines the formal syntax of match expressions in Scala 3. It shows how InfixExpr and SimpleExpr can include match clauses, and defines the structure of a MatchClause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/match-syntax.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nInfixExpr    ::=  ...\n           |  InfixExpr MatchClause\nSimpleExpr   ::=  ...\n           |  SimpleExpr '.' MatchClause\nMatchClause  ::=  'match' '{' CaseClauses '}'\n```\n\n----------------------------------------\n\nTITLE: Returning a Closure with a Local Capability in a Parametric Type Argument in Scala\nDESCRIPTION: This snippet demonstrates another pattern that violates escape checking. A Cell class is used to wrap a closure capturing a local capability (f), which is then returned from usingLogFile and later invoked. The sneaky value, of type Cell[() => Unit], stores a closure that references f, but f is no longer in scope at the point sneaky.x() is called. This causes the closure's capture set to escalate to *, leading to a compile-time error. This illustrates how Scala's type system prevents unsafe persistence of capabilities through object graphs and parametric types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nclass Cell[+A](x: A)\nval sneaky = usingLogFile { f => Cell(() => f.write(0)) }\nsneaky.x()\n```\n\n----------------------------------------\n\nTITLE: Expanding Abstract Parameterized Types with Bounds to Type Lambdas in Scala\nDESCRIPTION: This illustrates how a parameterized abstract type definition with bounds (`type T[X] >: L <: U`) is treated as shorthand for an unparameterized abstract type bounded by type lambdas: `type T >: ([X] =>> L) <: ([X] =>> U)`. This expansion applies the parameterization to both the lower and upper bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas-spec.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntype T[X] >: L <: U\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype T >: ([X] =>> L) <: ([X] =>> U)\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Tabulate with Exception Handling in Scala\nDESCRIPTION: Example function that creates a lazy list of squares, demonstrating how side effects (potential exceptions) are tracked in the type system using capture checking.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\nclass LimitExceeded extends Exception\ndef squares(n: Int)(using ct: CanThrow[LimitExceeded]) =\n  tabulate(10) { i =>\n    if i > 9 then throw LimitExceeded()\n    i * i\n  }\n```\n\n----------------------------------------\n\nTITLE: Covariant Type Parameters in Scala 3\nDESCRIPTION: Example of a class with covariant type parameters that allows subtype relationships between differently parameterized instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nabstract class P[+A, +B] {\n  def fst: A\n  def snd: B\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Indented Block Syntax for ExtMethods - EBNF - Scala 3\nDESCRIPTION: This EBNF grammar rule specifies alternative syntactic forms for multiple extension methods defined collectively in Scala 3. The notation '<<< ts >>>' means the methods may be grouped either with explicit curly braces or using indentation, according to the Scala 3 indentation syntax rules. This distinction is essential for language parsers and helps clarify the correspondence between traditional and offside (indentation-based) syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_11\n\nLANGUAGE: EBNF\nCODE:\n```\n<<< ts >>>        ::=  ‘{’ ts ‘}’ | indent ts outdent\n```\n\n----------------------------------------\n\nTITLE: Defining a Resource-Safe Using Pattern without Capture Checking in Scala 3\nDESCRIPTION: The `usingLogFile` method follows the try-with-resources pattern by opening a FileOutputStream, passing it to an operation, and closing the file afterward. It takes a function from FileOutputStream to a generic type T and returns T. However, without capture checking, it is unsafe since the operation might retain the file reference and use it after the file is closed, leading to runtime errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef usingLogFile[T](op: FileOutputStream => T): T =\n  val logFile = FileOutputStream(\"log\")\n  val result = op(logFile)\n  logFile.close()\n  result\n```\n\n----------------------------------------\n\nTITLE: Using Indented Code Blocks in Scala REPL\nDESCRIPTION: Demonstrates the improved support for multi-line indented code blocks within the Scala REPL in Dotty 0.24.0-RC1. The REPL now correctly waits for the complete `if` expression, including potential subsequent lines or an `else` clause, before evaluating.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-04-29-24th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> if true then\n     |   print(1)\n     |   print(2)\n     |\n```\n\n----------------------------------------\n\nTITLE: Member Type Resolution in Scala Intersection Types\nDESCRIPTION: Illustrates how the type of a member common to both types in an intersection is determined. It defines traits `A` and `B`, both having a `children` method but with different return types (`List[A]` and `List[B]`). For a value `x` of type `A & B`, the type of `x.children` becomes the intersection `List[A] & List[B]`, which simplifies to `List[A & B]` due to the covariance of `List`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/intersection-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait A:\n  def children: List[A]\n\ntrait B:\n  def children: List[B]\n\nval x: A & B = new C // Assuming C is defined as shown below\nval ys: List[A & B] = x.children\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Lexical Tokens and Structure (EBNF)\nDESCRIPTION: This EBNF grammar defines the basic building blocks of the Scala 3 language at the lexical level. It specifies how characters form tokens such as identifiers, various types of literals (integer, floating-point, boolean, character, string, interpolated strings), operators, comments, and whitespace. Includes rules for character escapes and Unicode handling.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/syntax.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nwhiteSpace       ::=  ‘\\u0020’ | ‘\\u0009’ | ‘\\u000D’ | ‘\\u000A’\nupper            ::=  ‘A’ | ... | ‘Z’ | ‘$’ and any character in Unicode categories Lu, Lt or Nl,\n                      and any character in Unicode categories Lo and Lm that doesn't have\n                      contributory property Other_Lowercase\nlower            ::=  ‘a’ | ... | ‘z’ | ‘_’ and any character in Unicode category Ll,\n                      and any character in Unicode categories Lo or Lm that has contributory\n                      property Other_Lowercase\nletter           ::=  upper | lower\ndigit            ::=  ‘0’ | ... | ‘9’\nparen            ::=  ‘(’ | ‘)’ | ‘[’ | ‘]’ | ‘{’ | ‘}’\ndelim            ::=  ‘`’ | ‘'’ | ‘\"’ | ‘.’ | ‘;’ | ‘,’\nopchar           ::=  ‘!’ | ‘#’ | ‘%’ | ‘&’ | ‘*’ | ‘+’ | ‘-’ | ‘/’ | ‘:’ |\n                      ‘<’ | ‘=’ | ‘>’ | ‘?’ | ‘@’ | ‘\\’ | ‘^’ | ‘|’ | ‘~’\n                      and any character in Unicode categories Sm or So\nprintableChar    ::=  all characters in [\\u0020, \\u007E] inclusive\nUnicodeEscape    ::=  ‘\\’ ‘u’ {‘u’} hexDigit hexDigit hexDigit hexDigit\nhexDigit         ::=  ‘0’ | ... | ‘9’ | ‘A’ | ... | ‘F’ | ‘a’ | ... | ‘f’\ncharEscapeSeq    ::=  ‘\\’ (‘b’ | ‘t’ | ‘n’ | ‘f’ | ‘r’ | ‘\"’ | ‘'’ | ‘\\’)\nescapeSeq        ::=  UnicodeEscape | charEscapeSeq\n\nop               ::=  opchar {opchar}\nvarid            ::=  lower idrest\nboundvarid       ::=  varid\n                   |  ‘`’ varid ‘`’\nplainid          ::=  alphaid\n                   |  op\nid               ::=  plainid\n                   |  ‘`’ { charNoBackQuoteOrNewline | escapeSeq } ‘`’\nidrest           ::=  {letter | digit} [‘_’ op]\nquoteId          ::=  ‘'’ alphaid\nspliceId         ::=  ‘$’ alphaid ;\n\nintegerLiteral   ::=  (decimalNumeral | hexNumeral | binaryNumeral) [‘L’ | ‘l’]\ndecimalNumeral   ::=  ‘0’ | digit [{digit | ‘_’} digit]\nhexNumeral       ::=  ‘0’ (‘x’ | ‘X’) hexDigit [{hexDigit | ‘_’} hexDigit]\nbinaryNumeral    ::=  ‘0’ (‘b’ | ‘B’) binaryDigit [{binaryDigit | ‘_’} binaryDigit]\n\nfloatingPointLiteral\n                 ::=  [decimalNumeral] ‘.’ digit [{digit | ‘_’} digit] [exponentPart] [floatType]\n                   |  decimalNumeral exponentPart [floatType]\n                   |  decimalNumeral floatType\nexponentPart     ::=  (‘E’ | ‘e’) [‘+’ | ‘-’] digit [{digit | ‘_’} digit]\nfloatType        ::=  ‘F’ | ‘f’ | ‘D’ | ‘d’\n\nbooleanLiteral   ::=  ‘true’ | ‘false’\n\ncharacterLiteral ::=  ‘'’ (charNoQuoteOrNewline | escapeSeq) ‘'’\n\nstringLiteral    ::=  ‘\"’ {stringElement} ‘\"’\n                   |  ‘\"\"\"’ multiLineChars ‘\"\"\"’\nstringElement    ::=  charNoDoubleQuoteOrNewline\n                   |  escapeSeq\nmultiLineChars   ::=  {[ ‘\"’] [‘\"’] charNoDoubleQuote} {‘\"’}\n\ninterpolatedString\n                 ::=  alphaid ‘\"’ {[ ‘\\’] interpolatedStringPart | ‘\\\\’ | ‘\\\"’} ‘\"’\n                   |  alphaid ‘\"\"\"’ {[ ‘\"’] [‘\"’] char \\ (‘\"’ | ‘\\$’) | escape} {‘\"’} ‘\"\"\"’\ninterpolatedStringPart\n                 ::= printableChar \\ (‘\"’ | ‘$’ | ‘\\’) | escape\nescape           ::=  ‘\\$\\$’\n                   |  ‘\\$\"’\n                   |  ‘\\$’ alphaid\n                   |  ‘\\$’ BlockExpr\nalphaid          ::=  upper idrest\n                   |  varid\n\ncomment          ::=  ‘/*’ “any sequence of characters; nested comments are allowed” ‘*/’\n                   |  ‘//’ “any sequence of characters up to end of line”\n\nnl               ::=  “new line character”\nsemi             ::=  ‘;’ |  nl {nl}\n```\n\n----------------------------------------\n\nTITLE: Ambiguity in Implicit Resolution with Multiple Candidates Scala\nDESCRIPTION: Illustrates changes in how ambiguity is treated during implicit resolution. Multiple implicit definitions produce ambiguous interpretations for an implicit query, showing that Scala 3 propagates ambiguity errors upwards, unlike Scala 2 which sometimes prematurely failed sub-searches. This emphasizes the introduction of explicit negation via scala.util.NotGiven.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-resolution.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n  class A\n  class B extends C\n  class C\n  implicit def a1: A\n  implicit def a2: A\n  implicit def b(implicit a: A): B\n  implicit def c: C\n```\n\n----------------------------------------\n\nTITLE: Modeling Effects with Dependent Function Types in Scala\nDESCRIPTION: Shows how dependent function types can model computational effects (like `CanThrow` or `CanIO`) in Scala 3 using context functions. It defines an abstract `Fun` class where the `apply` method's type signature `f.Eff ?=> Y` indicates that the computation requires a capability of type `f.Eff` (which depends on the specific function instance `f`) to produce a `Y`. The example includes `map` and `compose` functions that correctly propagate these effect requirements.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/dependent-function-types-spec.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait Effect\n\n// Type X => Y\nabstract class Fun[-X, +Y]:\n  type Eff <: Effect\n  def apply(x: X): Eff ?=> Y\n\nclass CanThrow extends Effect\nclass CanIO extends Effect\n\ngiven ct: CanThrow = new CanThrow\ngiven ci: CanIO = new CanIO\n\nclass I2S extends Fun[Int, String]:\n  type Eff = CanThrow\n  def apply(x: Int) = x.toString\n\nclass S2I extends Fun[String, Int]:\n  type Eff = CanIO\n  def apply(x: String) = x.length\n\n// def map(f: A => B)(xs: List[A]): List[B]\ndef map[A, B](f: Fun[A, B])(xs: List[A]): f.Eff ?=> List[B] =\n  xs.map(f.apply)\n\n// def mapFn[A, B]: (A => B) -> List[A] -> List[B]\ndef mapFn[A, B]: (f: Fun[A, B]) => List[A] => f.Eff ?=> List[B] =\n  f => xs => map(f)(xs)\n\n// def compose(f: A => B)(g: B => C)(x: A): C\ndef compose[A, B, C](f: Fun[A, B])(g: Fun[B, C])(x: A):\n  f.Eff ?=> g.Eff ?=> C =\n  g(f(x))\n\n// def composeFn: (A => B) -> (B => C) -> A -> C\ndef composeFn[A, B, C]:\n  (f: Fun[A, B]) => (g: Fun[B, C]) => A => f.Eff ?=> g.Eff ?=> C =\n  f => g => x => compose(f)(g)(x)\n\n@main def test =\n  val i2s = new I2S\n  val s2i = new S2I\n\n  assert(mapFn(i2s)(List(1, 2, 3)).mkString == \"123\")\n  assert(composeFn(i2s)(s2i)(22) == 2)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Cross-Stage Variable Usage Examples in Scala 3 Macros\nDESCRIPTION: These snippets demonstrate errors caused by violating cross-stage safety rules in Scala 3 macros. The first example shows an attempt to splice a non-quoted `Int` variable `n` where its value is not known yet at macro expansion time. The second illustrates referencing a non-lifted local variable `n` inside a quote, which causes a compilation error due to cross-stage persistence restrictions. These examples highlight constraints that local variables must be used only at their defining staging level and the need to manage scope carefully. They require Scala 3 macro support to detect such errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\ndef badPower(x: Double, n: Int): Double =\n  ${ unrolledPowerCode('x, n) } // error: value of `n` not known yet\n\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef badPowerCode(x: Expr[Double], n: Int)(using Quotes): Expr[Double] =\n  // error: `n` potentially not available in the next execution environment\n  '{ power($x, n) }\n\n```\n\n----------------------------------------\n\nTITLE: Using Transient Mutability for Local Values in Scala\nDESCRIPTION: This function shows how to construct mutable local data with capture sets, then return a pure, read-only closure. It relies on local capture inference, temporary skolemization, and post-processing to eliminate mutability from the function's exported type. Parameters include a size 'n' and a function 'f', returning a lambda from Int to Double; internal mutation is allowed, but output is pure. Requires Scala 3 with capture checking enabled.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Int): Double = ...\n\ndef precomputed(n: Int)(f: Int -> Double): Int -> Double =\n  val a: Array[Double]^ = Array.tabulate(n)(f)\n  a(_)\n```\n\n----------------------------------------\n\nTITLE: Mapping Structural Method Selection to applyDynamic (Basic)\nDESCRIPTION: This snippet shows how a structural method selection `v.a(...)` is translated into a call to `v.applyDynamic(\"a\")`, passing all arguments `a_ij`flattened into a single list. The result is then cast to the expected return type `R`. This applies when the `applyDynamic` method used does not require parameter type tags.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types-spec.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nv.applyDynamic(\"a\")(a11, ..., a1n, ..., aN1, ..., aNn)\n    .asInstanceOf[R]\n```\n\n----------------------------------------\n\nTITLE: Allowing Refined Types as Class Parents\nDESCRIPTION: Demonstrates support for using refined types as parent types of classes, where refinements become synthetic members of the inheriting class.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/modularity.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass C:\n  type T\n  def m(): T\n\ntype R = C:\n  type T = Int\n  def m(): 22\n\nclass D extends R:\n  def next(): D\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Macros in Scala 3 with Multi-Stage Compilation\nDESCRIPTION: This snippet defines a macro function `powerCode` that generates code for exponentiation at compile time, along with an inline macro `powerMacro` that splices the generated expression. It shows how macro libraries (`Macro.scala`) can be used in dependent libraries (`Lib.scala`) and in application code (`App.scala`), illustrating compilation stages. Dependencies between macros and sources cause delayed compilation to resolve calls to not-yet-compiled macros. Input expressions are passed as typed expressions (`Expr`), and splicing is performed using the `${}` notation. Expected output is generated code with macro expansions. This requires Scala 3 compiler with macro support.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\n// Macro.scala\ndef powerCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] = ...\ninline def powerMacro(x: Double, inline n: Int): Double =\n  ${ powerCode('x, 'n) }\n\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Lib.scala (depends on Macro.scala)\ndef power2(x: Double) =\n  ${ powerCode('x, '{2}) } // inlined from a call to: powerMacro(x, 2)\n\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// App.scala  (depends on Lib.scala)\n@main def app() = power2(3.14)\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating XML Literals and XML String Interpolation in Scala 3\nDESCRIPTION: This Scala snippet shows how XML literals are used to create XML structures embedded within Scala code and how the upcoming XML string interpolation replaces this approach. It requires the dependency on the dotty.xml.interpolator package to support XML string interpolation. The snippet defines a Person case class, creates a list of meeting data, and generates XML messages using both legacy XML literals and the newer xml\"\"\" string interpolation syntax. Inputs are tuples representing message details, and outputs are XML message representations printed to the console. The code uses inline XML elements and scala for-expressions to transform data into XML nodes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/xml.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport dotty.xml.interpolator.*\n\ncase class Person(name: String) { override def toString = name }\n\n@main def test: Unit =\n  val bill = Person(\"Bill\")\n  val john = Person(\"John\")\n  val mike = Person(\"Mike\")\n  val todoList = List(\n    (bill, john, \"Meeting\", \"Room 203, 11:00am\"),\n    (john, mike, \"Holiday\", \"March 22-24\")\n  )\n  // XML literals (to be dropped)\n  val mails1 = for (from, to, heading, body) <- todoList yield\n    <message>\n      <from>{from}</from><to>{to}</to>\n      <heading>{heading}</heading><body>{body}</body>\n    </message>\n  println(mails1)\n  // XML string interpolation\n  val mails2 = for (from, to, heading, body) <- todoList yield xml\"\"\"\n    <message>\n      <from>${from}</from><to>${to}</to>\n      <heading>${heading}</heading><body>${body}</body>\n    </message>\"\"\"\n  println(mails2)\n```\n\n----------------------------------------\n\nTITLE: Initializing Dotty Project with sbt Plugin Shell Script\nDESCRIPTION: This shell command initializes a new Scala project configured to use the Dotty compiler via the sbt build tool. It requires sbt version 0.13.13 or newer and invokes the sbt new command with the lampepfl/dotty.g8 template. This sets up all necessary project structure and configuration files to enable Dotty compilation in sbt. The input is the user's terminal command line, and the output is a new sbt project ready for Scala 3 development.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-05-31-first-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsbt new lampepfl/dotty.g8\n```\n\n----------------------------------------\n\nTITLE: EBNF Grammar for Value Definitions in Scala 3\nDESCRIPTION: Presents the EBNF grammar for value definitions (`val`) in Scala 3. It details the structure of `PatVarDef` using `PatDef`, which allows one or more patterns (`Pattern2`) optionally followed by a type annotation (`: Type`) and an assigned expression (`= Expr`). It also defines the `ids` rule for comma-separated identifiers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_1\n\nLANGUAGE: ebnf\nCODE:\n```\nPatVarDef    ::=  ‘val’ PatDef\nPatDef       ::=  Pattern2 {‘,’ Pattern2} [‘:’ Type] [‘=’ Expr]\nids          ::=  id {‘,’ id}\n```\n\n----------------------------------------\n\nTITLE: Type Alias Eta Expansion and Partial Application with Lambda Traits in Scala\nDESCRIPTION: Shows examples of composing polymorphic type aliases using Lambda traits and type members. Explains eta-expansion of aliases by stepwise substitution of Lambda traits and reasoning about applications via the 'Apply' type member.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntype RMap[K, V] = Map[V, K]\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype RRMap[K, V] = RMap[V, K]\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype RMap  = Lambda$II { self1 => type Apply = Map[self1.$hkArg$1, self1.$hkArg$0] }\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype RRMap = Lambda$II { self2 => type Apply = RMap[self2.$hkArg$1, self2.$hkArg$0] }\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype RRMap = Lambda$II { self2 => type Apply = Map[self2.$hkArg$0, self2.$hkArg$1] }\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype IMap[K, V] = Map[K, V]\n```\n\n----------------------------------------\n\nTITLE: Defining Method with Single Type Clause (Scala 2)\nDESCRIPTION: Shows the traditional Scala 2 method definition syntax, limited to a single leading type parameter clause, followed by term parameter clauses and an optional implicit clause. This highlights the constraints overcome by Scala 3's generalized syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/generalized-method-syntax.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef foo[T, U](x: T)(y: U)(z: Int, s: String)(a: Array[T])(implicit ordInt: Ord[Int], l: List[U])\n```\n\n----------------------------------------\n\nTITLE: Defining Experimental Functions, Values, Types, Classes, and Traits in Scala 3\nDESCRIPTION: This snippet demonstrates the use of the @experimental annotation on various definitions such as def, val, type, class, and trait. It explains how references to these experimental definitions are restricted to experimental scopes, illustrating with multiple scope examples including definitions, signatures, inheritance, body, annotations, and compile-time implications.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/experimental-defs.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.experimental\n\n@experimental\ndef x = ()\n\ndef d1 = x // error: value x is marked @experimental and therefore ...\n@experimental def d2 = x\n\n@experimental\nval x = ()\n\n@experimental\ndef f() = ()\n\n@experimental\nobject X:\n  def fx() = 1\n\ndef test1: Unit =\n  f() // error: def f is marked @experimental and therefore ...\n  x // error: value x is marked @experimental and therefore ...\n  X.fx() // error: object X is marked @experimental and therefore ...\n  import X.fx\n  fx() // error: object X is marked @experimental and therefore ...\n\n@experimental\ndef test2: Unit =\n  // references to f, x and X are ok because `test2` is experimental\n  f()\n  x\n  X.fx()\n  import X.fx\n  fx()\n\n@experimental\ntype E\n\ntype A = E // error type E is marked @experimental and therefore ...\n@experimental type B = E\n\n@experimental\nclass A\n@experimental\ntype X\n@experimental\ntype Y = Int\n@experimental\nopaque type Z = Int\n\ndef test: Unit =\n  new A // error: class A is marked @experimental and therefore ...\n  val i0: A = ??? // error: class A is marked @experimental and therefore ...\n  val i1: X = ??? // error: type X is marked @experimental and therefore ...\n  val i2: Y = ??? // error: type Y is marked @experimental and therefore ...\n  val i2: Z = ??? // error: type Z is marked @experimental and therefore ...\n  ()\n\n@experimental\ntrait ExpSAM {\n  def foo(x: Int): Int\n}\n\ndef bar(f: ExpSAM): Unit = {} // error: error form rule 2\n\n\ndef test: Unit =\n  bar(x => x) // error: reference to experimental SAM\n  ()\n```\n\n----------------------------------------\n\nTITLE: Defining 'Ord' Trait and Given Instances in Scala 3\nDESCRIPTION: This snippet defines a trait `Ord[T]` with comparison methods and provides given instances for `Int` and `List[T]` types. The `listOrd[T]` instance depends on an existing `Ord[T]` instance via a `using` clause, illustrating contextual givens for recursive comparisons.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/previous-givens.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Ord[T]:\n  def compare(x: T, y: T): Int\n  extension (x: T)\n    def < (y: T) = compare(x, y) < 0\n    def > (y: T) = compare(x, y) > 0\n\ngiven intOrd: Ord[Int] with\n  def compare(x: Int, y: Int) =\n    if x < y then -1 else if x > y then +1 else 0\n\ngiven listOrd[T](using ord: Ord[T]): Ord[List[T]] with\n  def compare(xs: List[T], ys: List[T]): Int = (xs, ys) match\n    case (Nil, Nil) => 0\n    case (Nil, _) => -1\n    case (_, Nil) => +1\n    case (x :: xs1, y :: ys1) =>\n      val fst = ord.compare(x, y)\n      if fst != 0 then fst else compare(xs1, ys1)\n```\n\n----------------------------------------\n\nTITLE: Attaching Java Debugger (JDB) to Scala Process - Shell\nDESCRIPTION: Attaches the Java Debugger (JDB) to a running Scala process on port 5005 and specifies the source path for accurate mapping. The command uses '-attach' with the debugging port and '-sourcepath' to provide context for breakpoints and stack traces. Ensure the JVM is started with remote debugging enabled and the correct source path is provided.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\njdb -attach 5005 -sourcepath tests/debug/\n```\n\n----------------------------------------\n\nTITLE: Defining Bindings and Imports Grammar in Scala 3\nDESCRIPTION: Grammar specification for bindings, modifiers, annotations, imports, and exports in Scala 3. This section defines syntax for parameter bindings, access modifiers, annotations, import and export statements, and end markers for indentation-based syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/syntax.md#_snippet_6\n\nLANGUAGE: BNF\nCODE:\n```\nBindings          ::=  '(' [Binding {',' Binding}] ')'\nBinding           ::=  (id | '_') [':' Type]\n\nModifier          ::=  LocalModifier\n                    |  AccessModifier\n                    |  'override'\n                    |  'opaque'\nLocalModifier     ::=  'abstract'\n                    |  'final'\n                    |  'sealed'\n                    |  'open'\n                    |  'implicit'\n                    |  'lazy'\n                    |  'inline'\n                    |  'transparent'\n                    |  'infix'\nAccessModifier    ::=  ('private' | 'protected') [AccessQualifier]\nAccessQualifier   ::=  '[' id ']'\n\nAnnotation        ::=  '@' SimpleType {ParArgumentExprs}\n\nImport            ::=  'import' ImportExpr {',' ImportExpr}\nExport            ::=  'export' ImportExpr {',' ImportExpr}\nImportExpr        ::=  SimpleRef {'.' id} '.' ImportSpec\n                    |  SimpleRef 'as' id\nImportSpec        ::=  NamedSelector\n                    |  WildCardSelector\n                    | '{' ImportSelectors) '}'\nNamedSelector     ::=  id ['as' (id | '_')]\nWildCardSelector  ::=  '*' | 'given' [InfixType]\nImportSelectors   ::=  NamedSelector [',' ImportSelectors]\n                    |  WildCardSelector {',' WildCardSelector}\n\nEndMarker         ::=  'end' EndMarkerTag    -- when followed by EOL\nEndMarkerTag      ::=  id | 'if' | 'while' | 'for' | 'match' | 'try'\n                    |  'new' | 'this' | 'given' | 'extension' | 'val'\n```\n\n----------------------------------------\n\nTITLE: Matching Higher-Kinded Types in Scala 3 Quotes\nDESCRIPTION: Shows advanced type matching for higher-kinded types using type variables with appropriate kind constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\ndef empty[K <: AnyKind : Type](using Quotes): Type[?] =\n  Type.of[K] match\n    case '[type f[X]; f] => Type.of[f]\n    case '[type f[X <: Int, Y]; f] => Type.of[f]\n    case '[type k <: AnyKind; k ] => Type.of[k]\n```\n\n----------------------------------------\n\nTITLE: Triggering Macro Derivation with Inline Given in Scala\nDESCRIPTION: Shows the common pattern for making a macro-derived instance available implicitly. An `inline given` definition calls the macro (`${ Eq.derived[T] }`) to generate the instance code at compile time.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation-macro.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ninline given eqGen[T]: Eq[T] = ${ Eq.derived[T] }\n```\n\n----------------------------------------\n\nTITLE: Multi-line Infix Operator Syntax Changes in Scala 3\nDESCRIPTION: Illustrates Scala 3's new syntax allowing infix operators to start lines in multi-line expressions without triggering semicolon inference errors. Examples show concatenations and logical expressions spanning multiple lines with leading infix operators. The snippet also explains conditions for recognizing leading infix operators to avoid misinterpretation by the compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/operators.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval str = \"hello\"\n  ++ \" world\"\n  ++ \"!\"\n\ndef condition =\n  x > 0\n  ||\n  xs.exists(_ > 0)\n  || xs.isEmpty\n```\n\n----------------------------------------\n\nTITLE: Conceptual Signatures of Quote and Splice Operations in Scala 3\nDESCRIPTION: Presents the conceptual function signatures for Scala 3's quote (`'`) and splice (`$`) operations using contextual function syntax (`?=>`). Quote requires a `Quotes` context to produce an `Expr[T]`, while splice consumes an `Expr[T]` computation (within its own `Quotes` context) to produce a value `T`. This is not directly executable code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef '[T](x: T): Quotes ?=> Expr[T] // def '[T](x: T)(using Quotes): Expr[T]\n\ndef $[T](x: Quotes ?=> Expr[T]): T\n```\n\n----------------------------------------\n\nTITLE: Signature of Expr.summon for Implicit Search in Scala Macros\nDESCRIPTION: Shows the method signature for `Expr.summon[T]`. This method, used within a macro implementation (`using Quotes`), searches for an implicit instance of type `T` in the scope where the macro is expanded. It returns an `Option[Expr[T]]`, containing the expression of the found implicit or `None` if no suitable implicit is found.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\ndef summon[T: Type](using Quotes): Option[Expr[T]]\n```\n\n----------------------------------------\n\nTITLE: Incorrect Extension of Parameterized Trait in Scala\nDESCRIPTION: This snippet shows a compilation error resulting from attempting to define a class that extends a derived trait (`FormalGreeting`) without supplying the necessary constructor parameter to the root trait (`Greeting`). Purpose: to highlight and explain the source of the error. No dependencies. Parameters: none provided, which triggers the error. Limitation: incomplete implementation won't compile unless trait parameters are passed correctly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/trait-parameters.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass E extends FormalGreeting // error: missing arguments for `Greeting`.\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Method with Multiple Type/Term Clauses (Scala 3)\nDESCRIPTION: Illustrates that the generalized method syntax also applies to extension methods in Scala 3. The zipWith extension method on List[T] features type parameters U and V located in separate clauses following term parameters, demonstrating the syntax's consistency.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/generalized-method-syntax.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nextension [T](l1: List[T])\n  def zipWith[U](l2: List[U])[V](l3: List[V]): List[(T,U,V)]\n```\n\n----------------------------------------\n\nTITLE: Using Pure vs Impure Function Types with Capture Sets in Scala 3\nDESCRIPTION: This text fragment explains capture annotations in function types: the usual impure function type `A => B` allows arbitrary capture (`^{cap}`), while the pure function type `A -> B` does not capture capabilities. Capture sets can specify exact capabilities allowed to be captured (e.g., `A ->{c,d} B`). The fragment clarifies the parsing precedence and analogies for context functions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Installing Dotty via Homebrew\nDESCRIPTION: Command to install Dotty using the Homebrew package manager for macOS.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-10-16-fourth-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbrew install lampepfl/brew/dotty\n```\n\n----------------------------------------\n\nTITLE: Deprecated Eta Expansion Syntax - Scala 3\nDESCRIPTION: This code shows the older syntax (`_`) previously used for eta expansion, applied here to a nullary method `next`. While this syntax worked for nullary methods, it is no longer needed for methods with parameters and is scheduled for deprecation, making the explicit `() => method()` form preferred for nullary methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/eta-expansion.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nnext _\n```\n\n----------------------------------------\n\nTITLE: Defining Custom String Interpolator in Scala\nDESCRIPTION: Provides an example of how to define a custom string interpolator in Scala using an implicit class. The custom interpolator method (e.g., 'id') is defined on the StringContext and can process arguments provided via dollar-sign syntax within the interpolated string.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nimplicit class StringInterpolation(s: StringContext) {\n  def id(args: Any*) = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Declarations and Definitions in Scala 3 EBNF\nDESCRIPTION: This extensive EBNF snippet defines the grammar for declarations and definitions in Scala 3, including `val`, `var`, `def`, `type`, `class`, `trait`, `object`, `enum`, and `implied` (instance). It covers nested rules for signatures, patterns, constructors, inheritance (`extends`, `derives`), templates, self types, packaging, and the overall structure of a compilation unit.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/syntax-3.1.md#_snippet_2\n\nLANGUAGE: EBNF\nCODE:\n```\nRefineDcl         ::=  ‘val’ ValDcl\n                    |  ‘def’ DefDcl\n                    |  ‘type’ {nl} TypeDcl\nDcl               ::=  RefineDcl\n                    |  ‘var’ ValDcl\nValDcl            ::=  ids ‘:’ Type\nDefDcl            ::=  DefSig [‘:’ Type]\nDefSig            ::=  ‘(’ DefParam ‘)’ [nl] id [DefTypeParamClause] {DefParamClause}\nTypeDcl           ::=  id [TypeParamClause] (SubtypeBounds | ‘=’ Type)\n                    |  id [TypeParamClause] <: Type = MatchType\n\nDef               ::=  ‘val’ PatDef\n                    |  ‘var’ VarDef\n                    |  ‘def’ DefDef\n                    |  ‘type’ {nl} TypeDcl\n                    |  ([‘case’] ‘class’ | ‘trait’) ClassDef\n                    |  [‘case’] ‘object’ ObjectDef\n                    |  ‘enum’ EnumDef\n                    |  ‘implied’ InstanceDef\n\nPatDef            ::=  Pattern2 {‘,’ Pattern2} [‘:’ Type] ‘=’ Expr\nVarDef            ::=  PatDef\n                    |  ids ‘:’ Type ‘=’ ‘_’\nDefDef            ::=  DefSig [(‘:’ | ‘<:’) Type] ‘=’ Expr\n                    |  ‘this’ DefParamClause {DefParamClause} ‘=’ ConstrExpr\nClassDef          ::=  id ClassConstr [Template]=\nClassConstr       ::=  [ClsTypeParamClause] [ConstrMods] {ClsParamClause}\nConstrMods        ::=  {Annotation} [AccessModifier]\nObjectDef         ::=  id [Template]\nEnumDef           ::=  id ClassConstr InheritClauses EnumBody\nInstanceDef       ::=  [id] InstanceParams InstanceBody\nInstanceParams    ::=  [DefTypeParamClause] {GivenParamClause}\nInstanceBody      ::=  [‘for’ ConstrApp {‘,’ ConstrApp }] [TemplateBody]\n                    |  ‘for’ Type ‘=’ Expr\nTemplate          ::=  InheritClauses [TemplateBody]\nInheritClauses    ::=  [‘extends’ ConstrApps] [‘derives’ QualId {‘,’ QualId}]\nConstrApps        ::=  ConstrApp {‘,’ ConstrApp}\nConstrApp         ::=  AnnotType {ArgumentExprs}\nConstrExpr        ::=  SelfInvocation\n                    |  {’ SelfInvocation {semi BlockStat} ‘}’\nSelfInvocation    ::=  ‘this’ ArgumentExprs {ArgumentExprs}\n\nTemplateBody      ::=  [nl] ‘{’ [SelfType] TemplateStat {semi TemplateStat} ‘}’\nTemplateStat      ::=  Import\n                    |  Export\n                    |  {Annotation [nl]} {Modifier} Def\n                    |  {Annotation [nl]} {Modifier} Dcl\n                    |  Expr1\n                    |\nSelfType          ::=  id [‘:’ InfixType] ‘=>’\n                    |  ‘this’ ‘:’ InfixType ‘=>’\n\nEnumBody          ::=  [nl] ‘{’ [SelfType] EnumStat {semi EnumStat} ‘}’\nEnumStat          ::=  TemplateStat\n                    |  {Annotation [nl]} {Modifier} EnumCase\nEnumCase          ::=  ‘case’ (id ClassConstr [‘extends’ ConstrApps]] | ids)\n\nTopStatSeq        ::=  TopStat {semi TopStat}\nTopStat           ::=  Import\n                    |  Export\n                    |  {Annotation [nl]} {Modifier} Def\n                    |  Packaging\n                    |\nPackaging         ::=  ‘package’ QualId [nl] ‘{’ TopStatSeq ‘}’\n\nCompilationUnit   ::=  {‘package’ QualId semi} TopStatSeq\n```\n\n----------------------------------------\n\nTITLE: Defining Collective Extension Methods for Sequences in Scala\nDESCRIPTION: This snippet illustrates how to define multiple extension methods on the Seq[String] type using the collective extension method syntax. Two methods are added: 'longestStrings', which returns all the strings with the maximal length, and 'longestString', which gives the first longest string. The methods utilize standard collection functions and depend on the new unified syntax available in Scala 3 or Dotty 0.26.0-RC1+. Input: a sequence of strings. Output: a sequence of the longest strings and a single string, respectively.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-07-27-26th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nextension (ss: Seq[String]):\n\n  def longestStrings: Seq[String] =\n    val maxLength = ss.map(_.length).max\n    ss.filter(_.length == maxLength)\n\n  def longestString: String = longestStrings.head\n```\n\n----------------------------------------\n\nTITLE: Valid Usage Examples of Opaque Logarithm Type in Scala\nDESCRIPTION: Demonstrates usage of the previously defined MyMath.Logarithm opaque type, showing valid instantiation and combination of Logarithm values using static methods and extension operators. Requires the Logarithm API from the enclosing MyMath module; input must be wrapped via API calls, and arithmetic is performed via extension methods. This code showcases the encapsulation enforced by opaque types for enhanced type safety.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/opaques.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport MyMath.Logarithm\n\nval l = Logarithm(1.0)\nval l2 = Logarithm(2.0)\nval l3 = l * l2\nval l4 = l + l2\n```\n\n----------------------------------------\n\nTITLE: Try-Catch Expression Expanded with Erased CanThrow Capability in Scala\nDESCRIPTION: This snippet illustrates how Scala 3 expands a `try-catch` block when using checked exceptions by inserting an erased implicit `CanThrow` capability parameter. The capability is required only for type checking and can be erased from compiled code. This integration exemplifies how capture and exception checking collaborate, ensuring only code with proper capabilities can throw or handle exceptions safely.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\ntry\n  erased given ctl: CanThrow[LimitExceeded] = compiletime.erasedValue\n  xs.map(f).sum\ncatch case ex: LimitExceeded => -1\n```\n\n----------------------------------------\n\nTITLE: Defining Alias Given Instance in Scala\nDESCRIPTION: This snippet defines a named alias `given` instance `global` of type `ExecutionContext`. It initializes to a `ForkJoinPool()` the first time it is accessed. Alias givens provide a concise way to make existing expressions or values available as givens.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/givens.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ngiven global: ExecutionContext = ForkJoinPool()\n```\n\n----------------------------------------\n\nTITLE: Defining Transparent Inline Match Expressions for Compile-Time Branch Selection in Scala 3\nDESCRIPTION: Defines a transparent inline method using an inline match expression that selects a matching branch at compile time based on the scrutinee's static type. This allows returning a value with a more precise specialized type. The example matches on Any with cases for String and Double, illustrating compile-time type-based dispatch and specialization.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\ntransparent inline def g(x: Any): Any =\n  inline x match\n    case x: String => (x, x) // Tuple2[String, String](x, x)\n    case x: Double => x\n\ng(1.0d) // Has type 1.0d which is a subtype of Double\ng(\"test\") // Has type (String, String)\n```\n\n----------------------------------------\n\nTITLE: Using the @infix Annotation to Allow Infix Notation in Scala 3\nDESCRIPTION: Demonstrates how to use the @infix annotation to explicitly allow alphanumeric methods to be used in infix position.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-05-23-15th-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.infix\ncase class Foo(x: Int) { @infix def plus(other: Foo) = x + other.x }\nFoo(1) plus Foo(2)\n```\n\n----------------------------------------\n\nTITLE: Recovering Precise Types with Type Variables in Scala 3 Quotes\nDESCRIPTION: Demonstrates how to recover the exact type of an expression using type variables, even when the static type is more general (e.g., Any).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\ndef let(x: Expr[Any])(using Quotes): Expr[Any] =\n  x match\n    case '{ $x: t } =>\n      '{ val y: t = $x; y }\n\nlet('{1}) // will return a `Expr[Any]` that contains an `Expr[Int]]`\n```\n\n----------------------------------------\n\nTITLE: EBNF Grammar for Variable Definitions in Scala 3\nDESCRIPTION: Outlines the EBNF grammar for variable definitions (`var`) in Scala 3. It covers abstract variable declarations (`VarDcl`), concrete variable definitions based on patterns (`PatDef`), and a shorthand for initializing variables of a given type with a default value (`_`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_8\n\nLANGUAGE: ebnf\nCODE:\n```\nDcl            ::=  ‘var’ VarDcl\nPatVarDef      ::=  ‘var’ VarDef\nVarDcl         ::=  ids ‘:’ Type\nVarDef         ::=  PatDef\n                 |  ids ‘:’ Type ‘=’ ‘_’\n```\n\n----------------------------------------\n\nTITLE: Defining Eq Type Class in Scala\nDESCRIPTION: Defines a simple type class `Eq` with a single method `eqv` for checking equality between two values of type `T`. This is the fundamental interface that derived instances must implement.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation-macro.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Eq[T]:\n  def eqv(x: T, y: T): Boolean\n```\n\n----------------------------------------\n\nTITLE: Generating Compile-Time Error with Code Context using error and codeOf (Scala)\nDESCRIPTION: This example shows how to use `scala.compiletime.error` in combination with `scala.compiletime.codeOf`. The `codeOf(p1)` call gets the source code representation of the argument `p1`, which is included in the compile-time error message generated by the `fail` inline function.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.{error, codeOf}\n\ninline def fail(inline p1: Any) =\n  error(\"failed on: \" + codeOf(p1))\n\nfail(identity(\"foo\")) // error: failed on: identity[String](\"foo\")\n```\n\n----------------------------------------\n\nTITLE: Accessing and Using Implicit Context in Scala3 Compiler (Scala)\nDESCRIPTION: This snippet demonstrates how methods in the Scala3 compiler typically declare an implicit Context parameter using Scala 3's 'using' syntax. It shows accessing the current Context via the imported 'ctx' alias, which references the implicit Context instance. Dependencies include the dotty.tools.dotc.Contexts package. This pattern is essential for propagating compiler state across methods without global variables. The input is an implicit Context passed to the method, and there is no output; the snippet illustrates contextual state access.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/architecture/context.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport dotty.tools.dotc.Contexts.{Context, ctx}\n\ndef doFoo(using Context): Unit =\n  val current = ctx.run // access the Context parameter with `ctx`\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Script Entry Point with @main\nDESCRIPTION: This snippet shows how to define the entry point for a Scala 3 script using the '@main' annotation on a top-level definition. This simplifies script creation compared to the traditional 'def main(args: Array[String]): Unit' method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-12-18-scala3-m3.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\n@main def Test(name: String): Unit =\n  println(s\"Hello ${name}!\")\n```\n\n----------------------------------------\n\nTITLE: Extractor Pattern Match Triggering Runtime Type Test in Scala\nDESCRIPTION: Shows another pattern matching scenario requiring a runtime type test. When an extractor (`Y.unapply`) is used, and its expected input type (`Y`) is not a subtype of the scrutinee's type (`X`), a runtime check is necessary. The snippet includes a simple extractor definition for context.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n(x: X) match\n  case y @ Y(n) =>\n\nobject Y:\n  def unapply(x: Y): Some[Int] = ...\n```\n\n----------------------------------------\n\nTITLE: Ambiguity with Call-by-Name and Call-by-Value Implicit Conversions in Scala\nDESCRIPTION: This code shows that, unlike Scala 2, Scala 3 treats implicit conversions with call-by-name and call-by-value parameters equally, which may result in ambiguity during implicit resolution. The snippet defines two implicit conversions from Int to A, one with a by-name and one with a by-value argument. When trying to call a method buzz(y: A) with an Int, the result is an ambiguous implicit error. Dependencies include class A and the relevant conversions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/implicit-resolution.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def conv1(x: Int): A = new A(x)\nimplicit def conv2(x: => Int): A = new A(x)\ndef buzz(y: A) = ???\nbuzz(1)   // error: ambiguous\n\n```\n\n----------------------------------------\n\nTITLE: Describing Optional Braces and Colon Handling in Scala 3 Syntax - EBNF\nDESCRIPTION: This snippet details the EBNF grammar for handling optional braces and colon tokens in Scala 3, enabling both indentation-based and brace-enclosed code blocks. It prescribes rules for when a colon can be replaced by a synthetic 'colon' token and how '<<< ts >>>' and ':<<< ts >>>' denote grouped statements or expressions either with braces or indented code. No external dependencies needed, input is token sequences from parsed Scala code, and output indicates valid block delimiters. This grammar is specification-level and not meant for direct execution.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/syntax.md#_snippet_1\n\nLANGUAGE: EBNF\nCODE:\n```\ncolon         ::=  ':'    -- with side conditions explained above\n <<< ts >>>   ::=  ‘{’ ts ‘}’\n                |  indent ts outdent\n:<<< ts >>>   ::=  [nl] ‘{’ ts ‘}’\n                |  colon indent ts outdent\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Erasure Rules in Scala 3\nDESCRIPTION: Defines the type erasure mapping ´|T|´ that converts generic Scala 3 types into non-generic types suitable for the JVM runtime. The erasure operates under transparent mode affecting behavior of member types for opaque type aliases. It specifies erasure results for primitive types, class types, term designators, parameterized types (including arrays), annotated, refined, recursive, union, and intersection types. Additionally, two algorithms compute erased least upper bounds (elub) and erased greatest lower bounds (eglb) with careful considerations for arrays, primitive types, and inheritance hierarchies. Understanding Scala types and JVM types is required for correct usage.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_42\n\nLANGUAGE: scala\nCODE:\n```\n- Erasure of AnyKind is Object.\n- Erasure of non-class type designator is erasure of underlying upper bound.\n- Erasure of term designator is erasure of underlying type.\n- Erasure of scala.Array[T_1] is scala.Array[|T_1|].\n- Erasure of other parameterized types T[T_1, ..., T_n] is |T|.\n- Erasure of stable type p is erasure of its underlying type.\n- Erasure of by-name type => T_1 is scala.Function0.\n- Erasure of annotated type T_1 a is |T_1|.\n- Erasure of refined type T_1 { R } is |T_1|.\n- Erasure of recursive type { \\u03B1 => T_1 } is |T_1|.\n- Erasure of union type S ｜ T is _erased least upper bound_ of |S| and |T|.\n- Erasure of intersection type S ＆ T is _erased greatest lower bound_ of |S| and |T|.\n```\n\nLANGUAGE: pseudocode\nCODE:\n```\nundefined\n```\n\n----------------------------------------\n\nTITLE: Executing Generated Code with Runtime Reflection\nDESCRIPTION: Shows how to compile and run macro-generated code by wrapping it into a class `RunInstance` with an `exec` method, which is then loaded and invoked via reflection to produce the final result.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nrun(mkPower2())\n```\n\n----------------------------------------\n\nTITLE: Example Compile-Time Error for Non-Constant Condition in Inline If in Scala 3\nDESCRIPTION: Shows the kind of compile-time error message generated when an inline if condition is not a constant expression. The inline if enforces compile-time constant conditions and the compiler reports an error indicating the condition cannot be reduced when violated.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\n  |  inline if delta >= 0 then ???\n  |  ^\n  |  cannot reduce inline if\n  |   its condition\n  |     delta >= 0\n  |   is not a constant value\n  | This location is in code that was inlined at ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Receiver Type Behavior for Right-Associative Extension Methods in Scala\nDESCRIPTION: Explains and shows that within an extension group defined for a specific receiver type (e.g., `Int`), a right-associative extension method (whose name ends in `:`) is uniquely treated as an extension on the type of its *argument*, not the receiver type of the extension group. This contrasts with left-associative methods in the same group.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/right-associative-extension-methods.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n  extension (a: Int)\n    def :+(b: Long): Long = ... // extension on Int\n    def +:(b: Long): Long = ... // extension on Long\n```\n\n----------------------------------------\n\nTITLE: Explicit TypeTest Pattern Matching in Scala\nDESCRIPTION: Demonstrates how a `TypeTest` instance can be used explicitly in a pattern match (`case tt(x)`). When matching against abstract types like `Y`, a contextual `TypeTest[X, Y]` is required to perform the runtime check.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef f[X, Y](x: X)(using tt: TypeTest[X, Y]): Option[Y] = x match\n  case tt(x @ Y(1)) => Some(x)\n  case tt(x) => Some(x)\n  case _ => None\n```\n\n----------------------------------------\n\nTITLE: Analyzing Git Contributions in Scala Project\nDESCRIPTION: This shell command sequence is used to analyze Git history to determine the number of code contributions per author within a Scala project. It lists all `.scala` files, performs a `git blame` on each line to identify authors, counts unique authors, and sorts them by contribution count.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/release-notes-0.1.2.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit ls-tree -r -z --name-only HEAD -- |egrep -z -Z -E '\\.(scala)$'| xargs -0 -n1 git blame --line-porcelain |grep \"^author \"|sort|uniq -c|sort -nr\n```\n\n----------------------------------------\n\nTITLE: Constant Expression Requirements for Inline Values and Parameters\nDESCRIPTION: Defines that right-hand sides of inline vals and inline parameters must be constant expressions (§6.24), enabling the compiler to perform full inlining and constant folding, which is crucial for effective optimization.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ninline val four = 4\n```\n\n----------------------------------------\n\nTITLE: Accessing Position Information in Scala 3 Macros\nDESCRIPTION: Demonstrates how to obtain source position information at the macro expansion point, including file path, line numbers, column positions, and source code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/reflection.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef macroImpl()(quotes: Quotes): Expr[Unit] =\n  import quotes.reflect.*\n  val pos = Position.ofMacroExpansion\n\n  val jpath = pos.sourceFile.getJPath.getOrElse(report.errorAndAbort(\"virtual file not supported\", pos))\n  val path = pos.sourceFile.path // fallback for a virtual file\n  val start = pos.start\n  val end = pos.end\n  val startLine = pos.startLine\n  val endLine = pos.endLine\n  val startColumn = pos.startColumn\n  val endColumn = pos.endColumn\n  val sourceCode = pos.sourceCode\n  ...\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using Scala Single Match Extractor (isEmpty/get)\nDESCRIPTION: Illustrates how to create and use a Single match extractor using a class with `isEmpty` and `get` methods and a companion object with an `unapply` method returning an instance. The `match` expression checks `isEmpty` and extracts the value via `get` if not empty.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nclass Nat(val x: Int):\n  def get: Int = x\n  def isEmpty = x < 0\n\nobject Nat:\n  def unapply(x: Int): Nat = new Nat(x)\n\n5 match\n  case Nat(n) => println(s\"$n is a natural number\")\n  case _      => ()\n\n// 5 is a natural number\n```\n\n----------------------------------------\n\nTITLE: Translating Generator Followed by Value Definition in Scala 3 For Comprehensions\nDESCRIPTION: Shows the translation rule for a generator (`p <- e`) followed by a value definition (`p' = e'`) within a Scala 3 `for` expression. It transforms this sequence into a new generator that yields pairs `(p, p')`, effectively combining the results. This involves a nested `for` comprehension with `yield` and introduces fresh variable names.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\n(´p´, ´p'´) <- for (´x @ p´ <- ´e´) yield { val ´x' @ p'´ = ´e'´; (´x´, ´x'´) }\n```\n\n----------------------------------------\n\nTITLE: Mixing By-Name and By-Type Given Imports in Scala 3\nDESCRIPTION: This snippet shows how to combine named and by-type imports in a single clause, ensuring by-type imports come last. This is helpful for cases where some givens are accessed by specific names and others by their type. The source (e.g., Instances) must declare both named and typed given instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/given-imports.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport Instances.{im, given Ordering[?]}\n```\n\n----------------------------------------\n\nTITLE: Declaring a polymorphic function value in Scala 3\nDESCRIPTION: Declares a polymorphic function value `bar` with type `[A] => List[A] => List[A]`, representing a function that takes a type `A` and returns a function from `List[A]` to `List[A]`. This illustrates how to define polymorphic function values that can be passed as parameters or returned.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/polymorphic-function-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval bar: [A] => List[A] => List[A]\n       = [A] => (xs: List[A]) => foo[A](xs)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating double quote escaping in Scala 3 s-interpolation\nDESCRIPTION: This snippet shows how to escape a double quote (`\"`) character within a single-quoted `s` interpolated string in Scala 3. It defines a string variable `inventor` and then constructs an interpolated string that embeds this variable and includes literal double quotes for a quote within the string itself, using the `$` prefix before the quote to escape it. The result is a single string variable `interpolation` containing the full quote.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/interpolation-escapes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n  val inventor = \"Thomas Edison\"\n  val interpolation = s\"as $inventor said: $\"The three great essentials to achieve anything worth while are: Hard work, Stick-to-itiveness, and Common sense.$\"\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating Well-Formed Parameterized Types in Scala\nDESCRIPTION: Provides examples of well-formed parameterized types in Scala, using previously defined classes. It demonstrates basic parameterization (`TreeMap[I, String]`), nested types (`List[List[Boolean]]`), higher-kinded types (`F[List, Int]`), type lambdas as arguments (`F[[X] =>> List[X], Int]`), and various uses of wildcard arguments (`?`) with inferred or specified bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nTreeMap[I, String]\nList[I]\nList[List[Boolean]]\n\nF[List, Int]\nF[[X] =>> List[X], Int]\nG[S, String]\n\nList[?] // ? inferred as List[_ >: Nothing <: Any], equivalent to List[Any]\nList[? <: String] // equivalent to List[String]\nS[? <: String]\nF[?, Boolean] // ? inferred as ? >: Nothing <: [A] =>> Any\n```\n\n----------------------------------------\n\nTITLE: Basic Comparison Error Example with Universal Equality\nDESCRIPTION: Demonstrates the problem with universal equality where comparing values of incompatible types (T and S) will typecheck but likely produce incorrect runtime results.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval x = ... // of type T\nval y = ... // of type S, but should be T\nx == y      // typechecks, will always yield false\n```\n\n----------------------------------------\n\nTITLE: Using 'uninitialized' for Wildcard Initializers – Scala\nDESCRIPTION: This snippet compares the old and new ways of creating uninitialized variables in Scala. The older '_'-based approach is now replaced by the 'uninitialized' value from 'scala.compiletime'. Inputs: variable declarations in a class/object context. Outputs: declares an instance variable without immediate assignment. Important: cannot be used for local variables. Requires Scala 3.0.0-RC1 or later and importing the specified module.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2021-02-17-scala3-rc1.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nvar x: T = _\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.compiletime.uninitialized\n\nvar x: A = uninitialized\n```\n\n----------------------------------------\n\nTITLE: Constructing a Method Definition Type in Scala 3 Compiler (Scala)\nDESCRIPTION: This snippet demonstrates how to construct a complex method definition type with two type parameters, one of which is bounded by a sequence of the other, and two value parameters. It relies on internal compiler APIs: dotty.tools.dotc.core.Types, Symbols, Contexts, and Decorators. The Context and Symbol for the method must already be available. The construction produces a PolyType wrapping a MethodType, mapping directly to a Scala signature like def f[A, B <: Seq[A]](x: A, y: B): Unit. The code expects user to provide the appropriate context and symbol injections as prerequisites.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/architecture/types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport dotty.tools.dotc.core.Types.*\nimport dotty.tools.dotc.core.Symbols.*\nimport dotty.tools.dotc.core.Contexts.*\nimport dotty.tools.dotc.core.Decorators.*\n\ngiven Context = … // contains the definitions of the compiler\n\nval f: Symbol = … // def f[A, B <: Seq[A]](x: A, y: B): Unit\n\nf.info = PolyType(\n  List(\"A\".toTypeName, \"B\".toTypeName))(\n  pt => List(\n    TypeBounds(defn.NothingType, defn.AnyType),\n    TypeBounds(defn.NothingType, AppliedType(defn.SeqType, List(pt.newParamRef(0))))\n  ),\n  pt => MethodType(\n    List(\"x\".toTermName, \"y\".toTermName))(\n    mt => List(pt.newParamRef(0), pt.newParamRef(1)),\n    mt => defn.UnitType\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Generated Aliases from Export Clauses in Scala 3\nDESCRIPTION: Shows the final method and type definitions generated by the Scala 3 compiler as a result of the `export` clauses used in the `Copier` class example. These aliases forward calls to the original members of `scanUnit` and `printUnit`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nfinal def scan(): BitMap            = scanUnit.scan()\nfinal def print(bits: BitMap): Unit = printUnit.print(bits)\nfinal type PrinterType              = printUnit.PrinterType\n```\n\n----------------------------------------\n\nTITLE: Defining Literal Types in Scala 3 EBNF\nDESCRIPTION: This EBNF snippet introduces the rule for 'literal types', restricting them to be simple literals. Literal types represent singleton types for specific literal values, such as numbers or booleans. These types enable precise typing and pattern matching at the value level; only primitive and string literals can be expressed in concrete syntax. No explicit dependencies.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_19\n\nLANGUAGE: ebnf\nCODE:\n```\nLiteralType  ::=  SimpleLiteral\n```\n\n----------------------------------------\n\nTITLE: Implementing Magnet Pattern Argument Conversions in a Scala Object\nDESCRIPTION: This snippet showcases the magnet pattern within an object Completions, defining an enum CompletionArg and multiple implicit conversions from various types to the enum using given Conversion instances. It provides conversions from String, Future[HttpResponse], and Future[StatusCode] to CompletionArg, facilitating flexible method signatures (such as the complete method) without requiring numerous overloads. Dependencies include the existence of KeyWord, Future, HttpResponse, and StatusCode types, and the approach is suited for cases where overloaded methods would be ambiguous or lead to excessive method variants.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/conversions.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject Completions:\n\n  // The argument \"magnet\" type\n  enum CompletionArg:\n    case Error(s: String)\n    case Response(f: Future[HttpResponse])\n    case Status(code: Future[StatusCode])\n\n  object CompletionArg:\n\n    // conversions defining the possible arguments to pass to `complete`\n    // these always come with CompletionArg\n    // They can be invoked explicitly, e.g.\n    //\n    //   CompletionArg.fromStatusCode(statusCode)\n\n    given fromString    : Conversion[String, CompletionArg]               = Error(_)\n    given fromFuture    : Conversion[Future[HttpResponse], CompletionArg] = Response(_)\n    given fromStatusCode: Conversion[Future[StatusCode], CompletionArg]   = Status(_)\n  end CompletionArg\n  import CompletionArg.*\n\n  def complete[T](arg: CompletionArg) = arg match\n    case Error(s) => ...\n    case Response(f) => ...\n    case Status(code) => ...\n\nend Completions\n```\n\n----------------------------------------\n\nTITLE: Defining a Method with Vararg Parameters - Scala\nDESCRIPTION: Defines a method with standard vararg parameters (without 'into'), illustrating how the vararg annotation is similarly dropped after partial application, providing context for how 'into' is handled at the type level. Input is an Int followed by multiple Ints; output is Unit.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef g(x: Int)(y: Int*): Unit\n```\n\n----------------------------------------\n\nTITLE: Generated Code for @main Functions\nDESCRIPTION: The code generated by the compiler when using @main annotation, showing how it creates a class with a static main method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nfinal class test {\n  <static> def main(args: Array[String]): Unit =\n    try Main$package.test() catch\n      {\n        case\n          error @ _:scala.util.CommandLineParser.CommandLineParser$ParseError\n         => scala.util.CommandLineParser.showError(error)\n      }\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Splice Transformation to Hole Representation\nDESCRIPTION: Shows how a normalized splice (represented as a lambda application) is further transformed into a 'hole' during the pickling process. The hole representation `<< idx; holeType; args* >>` captures the hole's index, inferred type, and the arguments as quote-defined variables, omitting the computation logic.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\n${ ((y: Expr[Double], m: Expr[Int]) => powerCode(y, m)).apply('x, 'n) }\n// becomes\n<< 0; Double; x, n >>\n```\n\n----------------------------------------\n\nTITLE: Show Placeholder Syntax Equivalents - Scala\nDESCRIPTION: This section illustrates the equivalence between anonymous functions using placeholder syntax (_) and their explicit (parameters) => body form. Each example shows an expression with underscores and its equivalent anonymous function definition, demonstrating how subsequent underscores map to successive parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_47\n\nLANGUAGE: scala\nCODE:\n```\n_ + 1\n```\n\nLANGUAGE: scala\nCODE:\n```\nx => x + 1\n```\n\nLANGUAGE: scala\nCODE:\n```\n_ * _\n```\n\nLANGUAGE: scala\nCODE:\n```\n(x1, x2) => x1 * x2\n```\n\nLANGUAGE: scala\nCODE:\n```\n(_: Int) * 2\n```\n\nLANGUAGE: scala\nCODE:\n```\n(x: Int) => (x: Int) * 2\n```\n\nLANGUAGE: scala\nCODE:\n```\nif (_) x else y\n```\n\nLANGUAGE: scala\nCODE:\n```\nz => if (z) x else y\n```\n\nLANGUAGE: scala\nCODE:\n```\n_.map(f)\n```\n\nLANGUAGE: scala\nCODE:\n```\nx => x.map(f)\n```\n\nLANGUAGE: scala\nCODE:\n```\n_.map(_ + 1)\n```\n\nLANGUAGE: scala\nCODE:\n```\nx => x.map(y => y + 1)\n```\n\n----------------------------------------\n\nTITLE: Invalid Exception Throwing in Map Function\nDESCRIPTION: Example of attempting to throw a checked exception inside a mapping function, which would be invalid in Java's checked exception model.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/canthrow.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nxs.map(x => if x < limit then x * x else throw LimitExceeded())\n```\n\n----------------------------------------\n\nTITLE: Passing Context Function Literals as Arguments in Scala\nDESCRIPTION: Examples demonstrate calls to a method `g` accepting an argument of type `Executable[Int]` (i.e., a context function). Shows how Scala expands ordinary arguments or context function calls to context function literals with explicit context parameters. This snippet clarifies how context functions interact with normal expressions and explicit `using` arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/context-functions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef g(arg: Executable[Int]) = ...\n\ng(22)      // expanded to g((ev: ExecutionContext) ?=> 22)\n\ng(f(2))    // expanded to g((ev: ExecutionContext) ?=> f(2)(using ev))\n\ng((ctx: ExecutionContext) ?=> f(3))  // left as context function literal\n\ng((ctx: ExecutionContext) ?=> f(3)(using ctx)) // unchanged\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Sequence Match Type Structure (X)\nDESCRIPTION: Defines the structural type `X` required for the return type `U` or a type `S` derived from it in variadic extractors using the sequence match pattern. It specifies the required methods like `lengthCompare`, `apply`, `drop`, and `toSeq` for sequence-like behavior.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ntype X = {\n  def lengthCompare(len: Int): Int // or, `def length: Int`\n  def apply(i: Int): T1\n  def drop(n: Int): scala.Seq[T2]\n  def toSeq: scala.Seq[T3>\n}\n```\n\n----------------------------------------\n\nTITLE: Recognized NotNull Annotations in Scala Compiler\nDESCRIPTION: Shows the internal list of Java annotations recognized by the Scala 3 compiler as indicating non-nullability. When encountering these annotations on Java members during interoperability with explicit nulls enabled, the compiler avoids adding `| Null` to the corresponding type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n@tu lazy val NotNullAnnots: List[ClassSymbol] = ctx.getClassesIfDefined(\n  \"javax.annotation.Nonnull\" ::\n  \"edu.umd.cs.findbugs.annotations.NonNull\" ::\n  \"androidx.annotation.NonNull\" ::\n  \"android.support.annotation.NonNull\" ::\n  \"android.annotation.NonNull\" ::\n  \"com.android.annotations.NonNull\" ::\n  \"org.eclipse.jdt.annotation.NonNull\" ::\n  \"org.checkerframework.checker.nullness.qual.NonNull\" ::\n  \"org.checkerframework.checker.nullness.compatqual.NonNullDecl\" ::\n  \"org.jetbrains.annotations.NotNull\" ::\n  \"lombok.NonNull\" ::\n  \"io.reactivex.annotations.NonNull\" :: Nil map PreNamedString)\n```\n\n----------------------------------------\n\nTITLE: Defining Typing Rules for Symmetric Metaprogramming Calculus\nDESCRIPTION: Specifies the type system for the calculus using judgments of the form `E1 * E2 |- t: T`. It defines rules for variables, lambdas, applications, quotes (`’t`), and splices (`~t`), showing how types are assigned based on two environments (`E1`, `E2`) and the current phase (`*` being `~` for stage 1 or `’` for stage 0).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/simple-smp.md#_snippet_3\n\nLANGUAGE: Formal Calculus\nCODE:\n```\n                          x: T in E2\n                       ---------------\n                       E1 * E2 |- x: T\n\n\n                   E1 * E2, x: T1 |- t: T2\n               --------------------------------\n               E1 * E2 |- (x: T1) => t: T -> T2\n\n\n         E1 * E2 |- t1: T2 -> T    E1 * E2 |- t2: T2\n         -------------------------------------------\n                     E1 * E2 |- t1 t2: T\n\n\n                       E2 ’ E1 |- t: T\n                      -----------------\n                      E1 ~ E2 |- ’t: ’T\n\n\n                       E2 ~ E1 |- t: ’T\n                       ----------------\n                       E1 ’ E2 |- ~t: T\n```\n\n----------------------------------------\n\nTITLE: EBNF Syntax for Scala 3 Enum Definitions\nDESCRIPTION: Details the EBNF grammar productions governing enum definitions in Scala 3 including syntax for EnumDef, EnumBody, EnumStat, and EnumCase. The formal grammar outlines how enum identifiers, constructors, extension clauses, and various case declarations are structured, forming the basis of Scala's enum construct implementation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_31\n\nLANGUAGE: ebnf\nCODE:\n```\nTmplDef   ::=  ‘enum’ EnumDef\nEnumDef   ::=  id ClassConstr [‘extends’ ConstrApps] EnumBody\nEnumBody  ::=  [nl] ‘{’ [SelfType] EnumStat {semi EnumStat} ‘}’\nEnumStat  ::=  TemplateStat\n            |  {Annotation [nl]} {Modifier} EnumCase\nEnumCase  ::=  ‘case’ (id ClassConstr [‘extends’ ConstrApps] | ids)\n```\n\n----------------------------------------\n\nTITLE: Type-safe Pattern Bindings in For Expressions\nDESCRIPTION: Demonstrates compile-time validation of pattern bindings in for expressions to ensure type safety.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-05-23-15th-dotty-milestone-release.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval elems: List[Any] = List((1, 2), \"hello\", (3, 4))\nfor ((x, y) <- elems) yield (y, x) // error: pattern's type (Any, Any) is more specialized\n                                     // than the right hand side expression's type Any\n```\n\n----------------------------------------\n\nTITLE: EBNF Syntax for Type Parameters in Scala 3\nDESCRIPTION: Defines the EBNF grammar for type parameter clauses, including variant type parameters and type parameter bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_18\n\nLANGUAGE: ebnf\nCODE:\n```\nTypeParamClause  ::= '[' VariantTypeParam {',' VariantTypeParam} ']'\nVariantTypeParam ::= {Annotation} ['+' | '-'] TypeParam\nTypeParam        ::= (id | '_') [TypeParamClause] ['>:' Type] ['<:' Type] [':' Type]\n```\n\n----------------------------------------\n\nTITLE: Class Hierarchy Diagram for JVM Backend Implementation in Scala\nDESCRIPTION: A textual representation of the inheritance hierarchy in the JVM backend, showing how CodeGen.Impl extends through various builder classes down to BCodeIdiomatic, with connections to different components.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/backend.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nclass CodeGen.Impl -[defines]-->        PlainClassBuilder\n     |\n [extends]                                      [extends]\n     |                                              |\nBCodeSyncAndTry    ---------------->        SyncAndTryBuilder\n     |                                              |\nBCodeBodyBuilder   ---------------->        PlainBodyBuilder\n     |                                              |\nBCodeSkelBuilder   ---------------->        PlainSkelBuilder\n     |                                       /      |       \\\n BCodeHelpers      ---------------->  BCClassGen BCAnnotGen ...  (more components)\n     |              \\\n     |               \\------------->  helper methods\n     |                \\------------>  JMirrorBuilder, JAndroidBuilder (uses some components, e.g. BCInnerClassGen)\n     |                 \\----------->  `backendUtils`: utility for bytecode related ops, contains mapping for supported classfile version\n     |\nBCodeIdiomatic     ---------------->        utilities for code generation, e.g. genPrimitiveArithmetic\n                    \\-------------->        `bTypes`: maps and fields for common BTypes\n                     \\------------->        `int`: synchronized interface between PostProcessor and compiltion ctx\n```\n\n----------------------------------------\n\nTITLE: Leading Non-symbolic Operators as Separate Statements in Scala\nDESCRIPTION: This snippet contrasts proper infix operator use by demonstrating a unary operator ('!') used without a separating space, which is recognized as a separate statement rather than an infix operation. The example serves to clarify the infix parsing rules and shows a common pitfall. Dependencies: Scala 3. Input: 'freezing' and '!boiling' on consecutive lines; Output: Two statements rather than one infix operation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/operators.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n    freezing\n  !boiling\n```\n\n----------------------------------------\n\nTITLE: Eta-Expanding Type Constructors to Higher-Kinded Lambda Types in Scala\nDESCRIPTION: This code demonstrates eta-expansion of type constructors into higher-kinded lambda types using 'Lambda1' in Scala 3. It shows how a parameterized trait or class, such as 'Set' or 'Map[String, _]', is adapted into a lambda form suitable for abstraction over type parameters. This transformation is necessary for using parameterized types in type class contexts expecting higher-kinded types. The key parameters are the type constructors to pass and the generated Lambda1 with appropriate substitutions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ntype Rep = Set\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntype Rep = Lambda1 { type Apply = Set[$hkArg$0] }\n```\n\n----------------------------------------\n\nTITLE: Simulating Parameterized Given Instance with Scala 2 Implicit Method (Part 2)\nDESCRIPTION: Defines an implicit method `listOrd` that constructs and returns an instance of the `listOrd` class (defined in Part 1). This method provides the implicit instance based on the available implicit `Ord[T]`, completing the Scala 2 simulation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nfinal implicit def listOrd[T](implicit ord: Ord[T]): listOrd[T] =\n new listOrd[T]\n```\n\n----------------------------------------\n\nTITLE: Importing Multiple Givens By Type in Scala 3\nDESCRIPTION: This snippet demonstrates how to import multiple given instances by specifying several types in a single import clause. Dependencies include the presence of matching given instances in the imported object. The approach provides granular control over which contextual abstractions are available.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/given-imports.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport A.{given T1, ..., given Tn}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scope Extrusion Issues with Mutable State in Scala 3 Macros\nDESCRIPTION: This snippet shows an example of scope extrusion by mutable state in Scala 3 macros. A mutable variable `x` of type `Expr[T]` is assigned inside a quote using splicing. After the quote creation, `x` holds a quoted expression referencing a variable `y` that is not in scope anymore, resulting in unsafe scope extrusion. This example illustrates how mutable state can inadvertently allow quoted expressions to escape their defining lexical scope, potentially breaking hygiene and safety. It requires understanding of the `Expr` type and quoting mechanisms in Scala 3 macros.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nvar x: Expr[T] = null\n'{ (y: T) => ${ x = 'y; 1 } }\nx // has value '{y} but y is not in scope\n\n```\n\n----------------------------------------\n\nTITLE: Illustrating Compile-Time Error for Non-Constant Inline If Condition in Scala\nDESCRIPTION: Shows the typical compile-time error message generated when an `inline if` statement's condition cannot be resolved to a constant value during compilation. This error occurs because `inline if` guarantees compile-time evaluation and simplification, which is not possible if the condition depends on runtime values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n|  inline if delta >= 0 then ???\n|  ^\n|  cannot reduce inline if\n|   its condition\n|     delta >= 0\n|   is not a constant value\n| This location is in code that was inlined at ...\n```\n\n----------------------------------------\n\nTITLE: Function 'nullifyMember' for Java nullability interop in JavaNullInterop.scala\nDESCRIPTION: Implements logic to adjust Java method and field types to incorporate nullability annotations when imported into Scala. The function 'nullifyMember' takes a symbol, its type, and context, then nullifies its type based on annotations like '@NotNull' or special cases such as enum values. This facilitates seamless passing of nulls between Java and Scala APIs by adjusting method signatures appropriately.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/explicit-nulls.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef nullifyMember(sym: Symbol, tp: Type, isEnumValueDef: Boolean)(implicit ctx: Context): Type = {...}\n```\n\n----------------------------------------\n\nTITLE: Defining Try Expression Syntax in EBNF for Scala 3\nDESCRIPTION: Provides the Extended Backus-Naur Form (EBNF) grammar definition for the Scala 3 `try` expression. It shows the structure `try Expr`, optionally followed by a `Catches` block (`catch`) and/or a `finally Expr` block.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_41\n\nLANGUAGE: ebnf\nCODE:\n```\nExpr1    ::=  ‘try’ Expr [Catches] [‘finally’ Expr]\n\nCatches  ::=  ‘catch‘ (Expr | ExprCaseClause)\n```\n\n----------------------------------------\n\nTITLE: Brace-less Control Expressions\nDESCRIPTION: Examples of new syntax for control expressions without braces, using 'then' and 'do' keywords.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n@main def testFor = {\n  val xs = 0 to 10\n  val xsFiltered = for x <- xs if x > 1 yield x\n  for\n    x <- xsFiltered\n    y <- xsFiltered\n  do println(s\"$x * $y = ${x * y}\")\n}\n\n@main def testIf(day: String) = {\n  if day == \"Sunday\" || day == \"Saturday\" then println(\"Today is a weekend, hooray!\")\n  else println(s\"Today is a workday.\")\n}\n\n@main def testWhile(bound: Int) = {\n  var x = 0\n  def incrementX() = {\n    x += 1\n    println(x)\n  }\n  while x <= bound do incrementX()\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Uninitialized Field Access via Inner Class in Scala\nDESCRIPTION: This Scala snippet illustrates an initialization problem involving inner classes and outer scope fields. The `ValDef` inner class accesses `counter` from the outer `Trees` object during its construction. However, the instance `theEmptyValDef` of `EmptyValDef` (which extends `ValDef`) is created before the `counter` variable is initialized in the `Trees` object, leading to an access before initialization.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/safe-initialization.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject Trees:\n  class ValDef { counter += 1 }\n  class EmptyValDef extends ValDef\n  val theEmptyValDef = new EmptyValDef\n  private var counter = 0  // error\n```\n\n----------------------------------------\n\nTITLE: Migrating Do-While Loop Body to While with Block Condition in Scala\nDESCRIPTION: This example illustrates transforming a standard 'do-while' increment loop into Scala 3's block-structured 'while' loop, separating the loop header and body. The initial snippet increments a variable and checks a function result; the replacement leverages indentation-based syntax and the 'do' keyword for side effects. No external dependencies are required, and the approach is suitable for any prior 'do-while' usage.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/do-while.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndo\n  i += 1\nwhile (f(i) == 0)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nwhile\n  i += 1\n  f(i) == 0\ndo ()\n```\n\n----------------------------------------\n\nTITLE: Defining Type and Value Parameters in Scala 3 EBNF\nDESCRIPTION: This EBNF snippet defines the syntax for type and value parameter clauses and individual parameters in Scala 3. It covers parameters for classes (ClsTypeParam, ClsParam), definitions (DefTypeParam, DefParam), types (TypTypeParam), and higher-kinded types (HkTypeParam), including annotations, variance ('+'/'_'), bounds, and default arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/syntax-3.1.md#_snippet_0\n\nLANGUAGE: EBNF\nCODE:\n```\nClsTypeParamClause::=  ‘[’ ClsTypeParam {‘,’ ClsTypeParam} ‘]’\nClsTypeParam      ::=  {Annotation} [‘+’ | ‘-’] id [HkTypeParamClause] TypeParamBounds\n\nDefTypeParamClause::=  ‘[’ DefTypeParam {‘,’ DefTypeParam} ‘]’\nDefTypeParam      ::=  {Annotation} id [HkTypeParamClause] TypeParamBounds\n\nTypTypeParamClause::=  ‘[’ TypTypeParam {‘,’ TypTypeParam} ‘]’\nTypTypeParam      ::=  {Annotation} id [HkTypeParamClause] SubtypeBounds\n\nHkTypeParamClause ::=  ‘[’ HkTypeParam {‘,’ HkTypeParam} ‘]’\nHkTypeParam       ::=  {Annotation} [‘+’ | ‘-’] (Id[HkTypeParamClause] | ‘_’) SubtypeBounds\n\nClsParamClause    ::=  [nl] [‘erased’] ‘(’ [ClsParams] ‘)’\n                    |  ‘given’ [‘erased’] (‘(’ ClsParams ‘)’ | GivenTypes)\nClsParams         ::=  ClsParam {‘,’ ClsParam}\nClsParam          ::=  {Annotation} [{Modifier} (‘val’ | ‘var’) | ‘inline’] Param\nParam             ::=  id ‘:’ ParamType [‘=’ Expr]\n\nDefParamClause    ::=  [nl] [‘erased’] ‘(’ [DefParams] ‘)’ | GivenParamClause\nGivenParamClause  ::=  ‘given’ [‘erased’] (‘(’ DefParams ‘)’ | GivenTypes)\nDefParams         ::=  DefParam {‘,’ DefParam}\nDefParam          ::=  {Annotation} [‘inline’] Param\nGivenTypes        ::=  AnnotType {‘,’ AnnotType}\n```\n\n----------------------------------------\n\nTITLE: Defining 'this' and 'super' Expression Grammar (EBNF)\nDESCRIPTION: Specifies the EBNF rules for 'SimpleExpr' forms representing 'this' and 'super' references, optionally qualified by a class name or trait qualifier. These rules cover self-references and references to superclass/trait members within the expression grammar.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_3\n\nLANGUAGE: ebnf\nCODE:\n```\nSimpleExpr  ::=  [id ‘.’] ‘this’\n              |  [id ‘.’] ‘super’ [ClassQualifier] ‘.’ id\n```\n\n----------------------------------------\n\nTITLE: Given Instance Alias and Value Definitions in Scala 3 - Scala\nDESCRIPTION: Defines two given instances in Scala 3: 'global' instantiates a new ExecutionContext as an alias, and a given Context is created from the variable ctx. Requires ExecutionContext, ForkJoinContext, and Context. These givens make global and ctx implicitly available in scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ngiven global: ExecutionContext = new ForkJoinContext()\n\nval ctx: Context\ngiven Context = ctx\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit and Implicit Conversion Functions\nDESCRIPTION: Demonstrates the previous Scala implicit mechanisms with implicit defs for conditional implicit values and implicit conversions. Shows how both use the 'implicit' keyword but serve different purposes, highlighting potential confusion and limitations in expressiveness.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def i1(implicit x: T): C[T] = ... // 1: conditional implicit value\nimplicit def i2(x: T): C[T] = ...          // 2: implicit conversion\n```\n\n----------------------------------------\n\nTITLE: Closure-Captured Mutable Variable Not Trackable in Scala Flow Typing\nDESCRIPTION: This example displays flow typing limitations when a mutable variable is assigned within a closure in Scala 3. The variable 'x' of type 'String | Null' cannot be safely refined after null checks because a closure captures and mutates it, making tracking unsound. Uses a closure 'y' that assigns null to 'x', and demonstrates the resulting type error from unsafe usage. Requires understanding of lambda/closure scoping. Key parameter: mutable variable possibly mutated outside main control flow.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\nvar x: String | Null = ???\ndef y =\n  x = null\n\nif x != null then\n   // y can be called here, which would break the fact\n   val a: String = x // error: x is captured and mutated by the closure, not trackable\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Inference Complexity without Transparent Traits (Scala)\nDESCRIPTION: This Scala snippet demonstrates a common type inference scenario prior to transparent traits. The inferred type for `x` becomes `Set[Kind & Product & Serializable]` because both `Var` and `Val` case objects implicitly extend `Product` and `Serializable`, and the least upper bound includes these mixins, making the inferred type more complex than the expected `Set[Kind]`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/transparent-traits.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Kind\ncase object Var extends Kind\ncase object Val extends Kind\nval x = Set(if condition then Val else Var)\n```\n\n----------------------------------------\n\nTITLE: Defining Expressions Grammar in Scala 3\nDESCRIPTION: Formal grammar specification for expressions in Scala 3, including function definitions, control structures, pattern matching, and various expression types. This covers the syntax for if/else, while loops, try/catch blocks, for comprehensions, and other expression constructs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/syntax.md#_snippet_4\n\nLANGUAGE: BNF\nCODE:\n```\nExpr              ::=  FunParams ('=>' | '?=>') Expr\n                    |  TypTypeParamClause '=>' Expr\n                    |  Expr1\nBlockResult       ::=  FunParams ('=>' | '?=>') Block\n                    |  TypTypeParamClause '=>' Block\n                    |  Expr1\nFunParams         ::=  Bindings\n                    |  id\n                    |  '_'\nExpr1             ::=  ['inline'] 'if' '(' Expr ')' {nl} Expr [[semi] 'else' Expr]\n                    |  ['inline'] 'if'  Expr 'then' Expr [[semi] 'else' Expr]\n                    |  'while' '(' Expr ')' {nl} Expr\n                    |  'while' Expr 'do' Expr\n                    |  'try' Expr Catches ['finally' Expr]\n                    |  'try' Expr ['finally' Expr]\n                    |  'throw' Expr\n                    |  'return' [Expr]\n                    |  ForExpr\n                    |  [SimpleExpr '.'] id '=' Expr\n                    |  PrefixOperator SimpleExpr '=' Expr\n                    |  SimpleExpr ArgumentExprs '=' Expr\n                    |  PostfixExpr [Ascription]\n                    |  'inline' InfixExpr MatchClause\nAscription        ::=  ':' InfixType\n                    |  ':' Annotation {Annotation}\nCatches           ::=  'catch' (Expr | ExprCaseClause)\nPostfixExpr       ::=  InfixExpr [id]                                          -- only if language.postfixOperators is enabled\nInfixExpr         ::=  PrefixExpr\n                    |  InfixExpr id [nl] InfixExpr\n                    |  InfixExpr id ColonArgument\n                    |  InfixExpr MatchClause\nMatchClause       ::=  'match' <<< CaseClauses >>>\nPrefixExpr        ::=  [PrefixOperator] SimpleExpr\nPrefixOperator    ::=  '-' | '+' | '~' | '!'                                    -- unless backquoted\nSimpleExpr        ::=  SimpleRef\n                    |  Literal\n                    |  '_'\n                    |  BlockExpr\n                    |  ExprSplice\n                    |  Quoted\n                    |  quoteId                                                  -- only inside splices\n                    |  'new' ConstrApp {'with' ConstrApp} [TemplateBody]\n                    |  'new' TemplateBody\n                    |  '(' [ExprsInParens] ')'\n                    |  SimpleExpr '.' id\n                    |  SimpleExpr '.' MatchClause\n                    |  SimpleExpr TypeArgs\n                    |  SimpleExpr ArgumentExprs\n                    |  SimpleExpr ColonArgument\nColonArgument     ::=  colon [LambdaStart]\n                       indent (CaseClauses | Block) outdent\nLambdaStart       ::=  FunParams ('=>' | '?=>')\n                    |  TypTypeParamClause '=>'\nQuoted            ::=  ''' '{' Block '}'\n                    |  ''' '[' TypeBlock ']'\nExprSplice        ::= spliceId                                                  -- if inside quoted block\n                    |  '$' '{' Block '}'                                        -- unless inside quoted pattern\n                    |  '$' '{' Pattern '}'                                      -- when inside quoted pattern\nExprsInParens     ::=  ExprInParens {',' ExprInParens}\nExprInParens      ::=  PostfixExpr ':' Type |  Expr\nParArgumentExprs  ::=  '(' [ExprsInParens] ')'\n                    |  '(' 'using' ExprsInParens ')'\n                    |  '(' [ExprsInParens ','] PostfixExpr '*' ')'\nArgumentExprs     ::=  ParArgumentExprs\n                    |  BlockExpr\nBlockExpr         ::=  <<< (CaseClauses | Block) >>>\nBlock             ::=  {BlockStat semi} [BlockResult]\nBlockStat         ::=  Import\n                    |  {Annotation {nl}} {LocalModifier} Def\n                    |  Extension\n                    |  Expr1\n                    |  EndMarker\nTypeBlock         ::=  {TypeBlockStat semi} Type\nTypeBlockStat     ::=  'type' {nl} TypeDef\n\nForExpr           ::=  'for' '(' Enumerators0 ')' {nl} ['do' | 'yield'] Expr\n                    |  'for' '{' Enumerators0 '}' {nl} ['do' | 'yield'] Expr\n                    |  'for'     Enumerators0          ('do' | 'yield') Expr\nEnumerators0      ::=  {nl} Enumerators [semi]\nEnumerators       ::=  Generator {semi Enumerator | Guard}\nEnumerator        ::=  Generator\n                    |  Guard {Guard}\n                    |  Pattern1 '=' Expr\nGenerator         ::=  ['case'] Pattern1 '<-' Expr\nGuard             ::=  'if' PostfixExpr\n\nCaseClauses       ::=  CaseClause { CaseClause }\nCaseClause        ::=  'case' Pattern [Guard] '=>' Block\nExprCaseClause    ::=  'case' Pattern [Guard] '=>' Expr\nTypeCaseClauses   ::=  TypeCaseClause { TypeCaseClause }\nTypeCaseClause    ::=  'case' (InfixType | '_') '=>' Type [semi]\n\nPattern           ::=  Pattern1 { '|' Pattern1 }\nPattern1          ::=  PatVar ':' RefinedType\n                    |  ['-'] integerLiteral ':' RefinedType\n                    |  ['-'] floatingPointLiteral ':' RefinedType\n                    |  Pattern2\nPattern2          ::=  [id '@'] InfixPattern\nInfixPattern      ::=  SimplePattern { id [nl] SimplePattern }\nSimplePattern     ::=  PatVar\n                    |  Literal\n                    |  '(' [Patterns] ')'\n                    |  Quoted\n                    |  SimplePattern1 [TypeArgs] [ArgumentPatterns]\n                    |  'given' RefinedType\nSimplePattern1    ::=  SimpleRef\n                    |  SimplePattern1 '.' id\nPatVar            ::=  varid\n                    |  '_'\nPatterns          ::=  Pattern {',' Pattern}\n\nArgumentPatterns  ::=  '(' [Patterns] ')'\n                    |  '(' [Patterns ','] PatVar '*' ')'\n```\n\n----------------------------------------\n\nTITLE: Eta-Expanding Map Type Constructor to Higher-Kinded Lambda Type in Scala\nDESCRIPTION: This snippet demonstrates eta-expansion for a partially applied type constructor (e.g., 'Map[String, _]') into a higher-kinded type compatible with lambda representations in Scala 3. It shows how the wildcard is replaced with a lambda-abstracted type parameter, allowing integration with generic type classes such as Functor. The example operates at the type level, requiring knowledge of lambda types and type projections.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ntype Rep = Map[String, _]\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntype Rep = Lambda1 { type Apply = Map[String, $hkArg$0] }\n```\n\n----------------------------------------\n\nTITLE: Defining Function with Using Clause in Scala 3\nDESCRIPTION: Defines a generic `max` function in Scala 3 that takes two arguments and requires a contextual `Ord[T]` instance provided via a `using` clause. This demonstrates Scala 3's syntax for contextual parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef max[T](x: T, y: T)(using ord: Ord[T]): T\n```\n\n----------------------------------------\n\nTITLE: General Form of a Scala 3 Class Definition in Scala\nDESCRIPTION: Expresses the general pattern of a Scala class definition with name, optional type parameters, annotations, access modifiers, formal parameter clauses for the primary constructor, and an extension template defining inheritance and class body. Inputs include class name (c), type parameters (tps), annotations (as), access modifier (m), parameter lists (ps), and template (t). Outputs are fully initialized class instances conforming to this definition. Limitations include restrictions on duplicated parameter names, and constraints on parameter scoping and usage in parent classes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass ´c´[´\\mathit{tps}\\,´] ´as´ ´m´(´\\mathit{ps}_1´)...(´\\mathit{ps}_n´) extends ´t´    ´\\quad(n \\geq 0)´.\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Equality in Scala\nDESCRIPTION: Shows how to enable the strictEquality language feature, which disables the fallback canEqualAny instance and enforces that all equality comparisons must have explicit CanEqual instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.strictEquality\n```\n\n----------------------------------------\n\nTITLE: Automatic Eta Expansion with Partial Application in Scala\nDESCRIPTION: Shows how methods with multiple parameter lists can be automatically eta-expanded when assigned to a value, and demonstrates how partial application works in this context.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/eta-expansion-spec.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef m(x: Boolean, y: String)(z: Int): List[Int]\nval f1 = m\nval f2 = m(true, \"abc\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nf1: (Boolean, String) => Int => List[Int]\nf2: Int => List[Int]\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Declaration and Definition Grammar Specification\nDESCRIPTION: The complete grammar specification for declarations and definitions in Scala 3, written in BNF-like notation. This defines the formal syntax for all language constructs including classes, methods, values, variables, enums, templates, and more.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/syntax.md#_snippet_7\n\nLANGUAGE: bnf\nCODE:\n```\nRefineDcl         ::=  'val' ValDcl\n                    |  'def' DefDcl\n                    |  'var' ValDcl\n                    |  'type' {nl} TypeDef\nValDcl            ::=  ids ':' Type\nDefDcl            ::=  DefSig ':' Type\n\nDef               ::=  'val' PatDef\n                    |  'var' PatDef\n                    |  'def' DefDef\n                    |  'type' {nl} TypeDef\n                    |  TmplDef\nPatDef            ::=  ids [':' Type] ['=' Expr]\n                    |  Pattern2 [':' Type] ['=' Expr]                           PatDef(_, pats, tpe?, expr)\nDefDef            ::=  DefSig [':' Type] ['=' Expr]                             DefDef(_, name, paramss, tpe, expr)\n                    |  'this' ConstrParamClauses [DefImplicitClause] '=' ConstrExpr DefDef(_, <init>, vparamss, EmptyTree, expr | Block)\nDefSig            ::=  id [DefParamClauses] [DefImplicitClause]\nTypeDef           ::=  id [HkTypeParamClause] {FunParamClause}TypeBounds         TypeDefTree(_, name, tparams, bound\n                       ['=' Type]\n\nTmplDef           ::=  (['case'] 'class' | 'trait') ClassDef\n                    |  ['case'] 'object' ObjectDef\n                    |  'enum' EnumDef\n                    |  'given' (GivenDef | OldGivenDef)\nClassDef          ::=  id ClassConstr [Template]\nClassConstr       ::=  [ClsTypeParamClause] [ConstrMods] ClsParamClauses\nConstrMods        ::=  {Annotation} [AccessModifier]\nObjectDef         ::=  id [Template]\nEnumDef           ::=  id ClassConstr InheritClauses EnumBody\n\nGivenDef          ::=  [id ':'] GivenSig\nGivenSig          ::=  GivenImpl\n                    |  '(' ')' '=>' GivenImpl\n                    |  GivenConditional '=>' GivenSig\nGivenImpl         ::=  GivenType (['=' Expr] | TemplateBody)\n                    |  ConstrApps TemplateBody\nGivenConditional  ::=  DefTypeParamClause\n                    |  DefTermParamClause\n                    |  '(' FunArgTypes ')'\n                    |  GivenType\nGivenType         ::=  AnnotType1 {id [nl] AnnotType1}\n\nOldGivenDef       ::=  [OldGivenSig] (AnnotType ['=' Expr] | StructuralInstance) -- syntax up to Scala 3.5, to be deprecated in the future\nOldGivenSig       ::=  [id] [DefTypeParamClause] {UsingParamClause} ':'          -- one of `id`, `DefTypeParamClause`, `UsingParamClause` must be present\nStructuralInstance ::=  ConstrApp {'with' ConstrApp} ['with' WithTemplateBody]\n\nExtension         ::=  'extension' [DefTypeParamClause] {UsingParamClause}\n                       '(' DefTermParam ')' {UsingParamClause} ExtMethods\nExtMethods        ::=  ExtMethod | [nl] <<< ExtMethod {semi ExtMethod} >>>\nExtMethod         ::=  {Annotation [nl]} {Modifier} 'def' DefDef\n                    |  Export\nTemplate          ::=  InheritClauses [TemplateBody]\nInheritClauses    ::=  ['extends' ConstrApps] ['derives' QualId {',' QualId}]\nConstrApps        ::=  ConstrApp ({',' ConstrApp} | {'with' ConstrApp})\nConstrApp         ::=  SimpleType {Annotation} {ParArgumentExprs}\nConstrExpr        ::=  SelfInvocation\n                    |  <<< SelfInvocation {semi BlockStat} >>>\nSelfInvocation    ::=  'this' ArgumentExprs {ArgumentExprs}\n\nWithTemplateBody  ::=  <<< [SelfType] TemplateStat {semi TemplateStat} >>>\nTemplateBody      ::=  :<<< [SelfType] TemplateStat {semi TemplateStat} >>>\nTemplateStat      ::=  Import\n                    |  Export\n                    |  {Annotation [nl]} {Modifier} Def\n                    |  Extension\n                    |  Expr1\n                    |  EndMarker\n                    |\nSelfType          ::=  id [':' InfixType] '=>'\n                    |  'this' ':' InfixType '=>'\n\nEnumBody          ::=  :<<< [SelfType] EnumStat {semi EnumStat} >>>\nEnumStat          ::=  TemplateStat\n                    |  {Annotation [nl]} {Modifier} EnumCase\nEnumCase          ::=  'case' (id ClassConstr ['extends' ConstrApps]] | ids)\n\nTopStats          ::=  TopStat {semi TopStat}\nTopStat           ::=  Import\n                    |  Export\n                    |  {Annotation [nl]} {Modifier} Def\n                    |  Extension\n                    |  Packaging\n                    |  PackageObject\n                    |  EndMarker\n                    |\nPackaging         ::=  'package' QualId :<<< TopStats >>>\nPackageObject     ::=  'package' 'object' ObjectDef\n\nCompilationUnit   ::=  {'package' QualId semi} TopStats\n```\n\n----------------------------------------\n\nTITLE: Defining List Contains with Hypothetical Single-Parameter CanEqual1[U] in Scala\nDESCRIPTION: This snippet shows a hypothetical version of `List.contains` using a single-parameter equality type class, `CanEqual1[U]`. The accompanying text explains that this approach is problematic for gradual migration. If a universal `CanEqual1[Any]` instance exists, this definition would allow comparisons with any type `U`, making it effectively as unsafe and widely applicable as the original `contains(x: Any)` and failing to leverage the benefits of safe equality checks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\ndef contains[U >: T](x: U)(using CanEqual1[U]): Boolean   // (2)\n```\n\n----------------------------------------\n\nTITLE: ValDef.let Helper Methods in Scala 3 Reflection\nDESCRIPTION: Shows the type signatures of the ValDef.let and ValDef.lets methods that help bind expressions to values for use in a body expression, simplifying code generation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/reflection.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef let(rhs: Term)(body: Ident => Term): Term = ...\n\ndef lets(terms: List[Term])(body: List[Term] => Term): Term = ...\n```\n\n----------------------------------------\n\nTITLE: Example of Scala 3 Compiler Suggesting Missing Import\nDESCRIPTION: Displays a sample Scala 3 compiler error message indicating a missing implicit argument. The error output includes a new feature where the compiler suggests a specific import statement (`import testObjectInstance.instances.zipOption`) that could resolve the compilation error, improving developer workflow.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-02-05-22nd-dotty-milestone-release.md#_snippet_10\n\nLANGUAGE: Text\nCODE:\n```\n-- Error: tests/neg/missing-implicit1.scala:17:4 -----------------------------------------------------------------------\n17 |  ff // error\n   |    ^\n   |no implicit argument of type testObjectInstance.Zip[Option] was found for parameter xs of method ff in object testObjectInstance\n   |\n   |The following import might fix the problem:\n   |\n   |  import testObjectInstance.instances.zipOption\n```\n\n----------------------------------------\n\nTITLE: Resolving Package Name Conflicts with `_root_` in Scala\nDESCRIPTION: Illustrates how to resolve potential package name shadowing in Scala. It uses `_root_.b.B` to explicitly refer to the class `B` in the top-level package `b`, bypassing the inner package `a.b`. It also shows importing from the top-level package using `_root_`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/09-top-level-definitions.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\npackage b {\n  class B\n}\n\npackage a {\n  package b {\n    class A {\n      val x = new _root_.b.B\n    }\n    class C {\n      import _root_.b._\n      def y = new B\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Experimental Pure Function Syntax in Scala 3 - Scala\nDESCRIPTION: This code snippet demonstrates how to enable the experimental 'pureFunctions' feature in Scala 3 by importing 'language.experimental.pureFunctions'. This import allows developers to use pure function type syntax (such as 'A -> B') in their Scala code. No additional dependencies are required besides Scala 3, and the import should be placed wherever pure function types are intended for documentation or preparatory effect tracking.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/purefuns.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport language.experimental.pureFunctions\n```\n\n----------------------------------------\n\nTITLE: Listing Infix Operator Precedence and Associativity in Scala3 - Scala\nDESCRIPTION: This snippet lists the precedence of infix operators in Scala3 as determined by the first character of the operator symbol, arranged in increasing order from letters (lowest precedence) to other operator characters (highest). Also, it explains that associativity is determined by the last character of the operator symbol, with operators ending in ':' being right-associative and others left-associative. These rules govern expression grouping and parsing of infix operations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\n(all letters, as defined in [chapter 1](01-lexical-syntax.html), including `_` and `$`)\n|\n^\n&\n= !\n< >\n:\n+ -\n* / %\n(other operator characters, as defined in [chapter 1](01-lexical-syntax.html), including Unicode categories `Sm` and `So`)\n```\n\n----------------------------------------\n\nTITLE: Testing Derived Eq Instance with an ADT in Scala\nDESCRIPTION: Demonstrates how to use the derived `Eq` instance. An enum `Opt[+T]` is defined with a `derives Eq` clause. A test function then summons the `Eq[Opt[Int]]` instance and uses its `eqv` method to assert equality and inequality for different `Opt` values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nenum Opt[+T] derives Eq:\n  case Sm(t: T)\n  case Nn\n\n@main def test(): Unit =\n  import Opt.*\n  val eqoi = summon[Eq[Opt[Int]]]\n  assert(eqoi.eqv(Sm(23), Sm(23)))\n  assert(!eqoi.eqv(Sm(23), Sm(13)))\n  assert(!eqoi.eqv(Sm(23), Nn))\n```\n\n----------------------------------------\n\nTITLE: Defining Constant Values in Scala\nDESCRIPTION: Illustrates the syntax for a constant value definition in Scala using `final val`. The assigned expression `e` must be a [constant expression](06-expressions.html#constant-expressions), the `final` modifier is mandatory, and no type annotation is permitted. The compiler replaces references to `x` with the expression `e`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nfinal val x = e\n```\n\n----------------------------------------\n\nTITLE: Recursive Given Prevention in Implicit Resolution in Scala\nDESCRIPTION: This snippet demonstrates how future Scala versions prevent generation of recursive givens that could lead to runtime infinite loops. An opaque type Price is defined over BigDecimal, and a given Ordering[Price] is assigned using summon within Scope. Prior Scala versions would trigger an error; the new behavior avoids problematic givens. Dependencies are an opaque type alias and the implicit Ordering type class, with the input being the definition of given in the companion object.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/implicit-resolution.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nobject Prices {\n  opaque type Price = BigDecimal\n\n  object Price{\n    given Ordering[Price] = summon[Ordering[BigDecimal]] // was error, now avoided\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Single Match Extractor Returning Wrapper with get/isEmpty in Scala\nDESCRIPTION: Illustrates the creation of a custom extractor class conforming to the 'single match' protocol, with required `get`/`isEmpty` members. The example enables pattern matching on integers to selectively extract and validate values. Dependencies include definition of the wrapper class and object with appropriate unapply signature. Input is an integer, output is the wrapped value if `isEmpty` is false. Constraint: `isEmpty` logic controls which values succeed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/pattern-matching.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass Nat(val x: Int):\n  def get: Int = x\n  def isEmpty = x < 0\n\nobject Nat:\n  def unapply(x: Int): Nat = new Nat(x)\n\n5 match\n  case Nat(n) => println(s\"$n is a natural number\")\n  case _      => ()\n\n// 5 is a natural number\n```\n\n----------------------------------------\n\nTITLE: Running all tests in Scala 3 with sbt using Bash\nDESCRIPTION: Commands to run all non-bootstrapped tests and all tests including bootstrapped compiler, REPL and libraries in Scala 3 using sbt. The first command runs all tests excluding those requiring a bootstrapped compiler, while the second enters the sbt prompt to run the full bootstrapped test suite.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt test\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\nsbt:scala3> scala3-bootstrapped/test\n```\n\n----------------------------------------\n\nTITLE: Illustrating Illegal Wildcard Usage with Abstract Type Constructors in Scala\nDESCRIPTION: Demonstrates an illegal type definition in Scala where a wildcard argument (`_`, equivalent to `?`) is applied to an abstract type constructor (`F`). Abstract type constructors, like `F` defined as `F[A]` (desugared to `F <: [A] =>> Any`) in trait `H`, cannot be instantiated with wildcard arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\ntrait H[F[A]]:  // F[A] desugars to F <: [A] =>> Any, which is abstract\n  def f: F[_]   // illegal : an abstract type constructor\n                // cannot be applied to wildcard arguments.\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Named Tuple Syntax and Pattern Matching Rules\nDESCRIPTION: Outlines the extended syntax for named tuples and constructor patterns, including rules that all elements in a tuple or pattern must be either all named or all unnamed, and that each name must be unique. It emphasizes restrictions on mixing named and unnamed elements and pattern matching constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/named-tuples.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nSimpleType        ::=  ...\n                    |  ‘(’ NameAndType {‘,’ NameAndType} ‘)’\nNameAndType       ::=  id ':' Type\n\nSimpleExpr        ::=  ...\n                    |  '(' NamedExprInParens {‘,’ NamedExprInParens} ')'\nNamedExprInParens ::=  id '=' ExprInParens\n\nPatterns          ::=  Pattern {‘,’ Pattern}\n                    |  NamedPattern {‘,’ NamedPattern}\nNamedPattern      ::=  id '=' Pattern\n```\n\n----------------------------------------\n\nTITLE: Unsafe Nulls Migration and Usage in Scala with Language Feature\nDESCRIPTION: This snippet exemplifies multiple uses of the 'unsafeNulls' language feature in Scala 3 for migration from less strict null handling. It shows direct assignment and usage patterns (variable assignment, method calls, type bounds, implicit conversions, and extension methods) that would otherwise fail type checking with explicit nulls. Prerequisites: import 'scala.language.unsafeNulls' or compiler flag. Inputs: nullable/high-bound Strings, arrays; outputs: demonstrates unsafe conversions and usages typically blocked by explicit-nulls. Limitation: Not all unsafe casts are allowed, e.g., interop with unknown reference types may still require manual null-stripping. Use is intended for migration, not long-term reliance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_30\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: String): String = ???\ndef nullOf[T >: Null]: T = null\n\nimport scala.language.unsafeNulls\n\nval s: String | Null = ???\nval a: String = s // unsafely convert String | Null to String\n\nval b1 = s.trim // call .trim on String | Null unsafely\nval b2 = b1.length\n\nf(s).trim // pass String | Null as an argument of type String unsafely\n\nval c: String = null // Null to String\n\nval d1: Array[String] = ???\nval d2: Array[String | Null] = d1 // unsafely convert Array[String] to Array[String | Null]\nval d3: Array[String] = Array(null) // unsafe\n\nclass C[T >: Null <: String] // define a type bound with unsafe conflict bound\n\nval n = nullOf[String] // apply a type bound unsafely\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Array from an IArray Leading to Abstraction Breach in Scala\nDESCRIPTION: Demonstrates that pattern matching on an opaque IArray type can expose its underlying Array representation, allowing mutation operations that violate the immutability abstraction. This snippet shows how a value of type IArray[Int] can be matched as Array[Int] and mutated.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/matchable.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval imm: IArray[Int] = ...\nimm match\n  case a: Array[Int] => a(0) = 1\n```\n\n----------------------------------------\n\nTITLE: Defining a Procedure Function Using an Equals Sign in Scala\nDESCRIPTION: Shows the recommended way to define a procedure in Scala 3, using an equals sign before the block. This version infers that the function returns Unit. No additional parameters or dependencies are needed. This syntax is fully supported and future-proof.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/procedure-syntax.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef f() = { ... }\n```\n\n----------------------------------------\n\nTITLE: Using Package and Import Bindings with Shadowing in Scala 3\nDESCRIPTION: This snippet demonstrates package and import bindings with explicit import and local class declaration. It shows how an imported identifier and a local class with the same name are distinguished based on the import qualifier. It uses 'println' and the construction of a new object, illustrating name resolution precedence between package and import declarations in nested scopes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/02-identifiers-names-and-scopes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage util {\n  import scala.util\n  class Random\n  object Test extends App {\n    println(new util.Random)  // scala.util.Random\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining generic ReaderMonad with type parameter Ctx\nDESCRIPTION: Defines a polymorphic `readerMonad` as a `Monad` for functions from a generic context `Ctx` to `X`. Encapsulates environment passing as a monadic operation for any context type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\ngiven readerMonad: [Ctx] => Monad[[X] =>> Ctx => X]:\n\n  def pure[A](x: A): Ctx => A =\n    ctx => x\n\n  extension [A](x: Ctx => A)\n    def flatMap[B](f: A => Ctx => B): Ctx => B =\n      ctx => f(x(ctx))(ctx)\n```\n\n----------------------------------------\n\nTITLE: Export Clause Syntax in Scala\nDESCRIPTION: General syntax form for export clauses in Scala 3, consisting of a qualifier path followed by selectors that determine what gets aliased.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/export.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nexport path . { sel_1, ..., sel_n }\n```\n\n----------------------------------------\n\nTITLE: Defining the Core `Eq` Type Class for Multiversal Equality\nDESCRIPTION: Defines the central `Eq[-T, -U]` marker trait for the Multiversal Equality proposal. This contravariant trait, with no members, serves as a type-level predicate indicating that values of type `T` can be safely compared with values of type `U`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-05-05-multiversal-equality.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\n\ntrait Eq[-T, -U]\n```\n\n----------------------------------------\n\nTITLE: DOT Calculus Syntax in Scala-like Notation\nDESCRIPTION: The formal grammar of the DOT calculus expressed in Scala-like notation, showing the structure of values, definitions, terms, and types that form the core of Scala's type system.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-02-03-essence-of-scala.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nValue       v  =  (x: T) => t            Function\n                  new { x: T => ds }     Object\n\nDefinition  d  =  def a = t              Method definition\n                  type A = T             Type\n\nTerm        t  =  v                      Value\n                  x                      Variable\n                  t1(t2)                 Application\n                  t.a                    Selection\n                  { val x = t1; t2 }     Local definition\n\nType        T  =  Any                    Top type\n                  Nothing                Bottom type\n                  x.A                    Selection\n                  (x: T1) => T2          Function\n                  { def a: T }           Method declaration\n                  { type T >: T1 <: T2 } Type declaration\n                  T1 & T2                Intersection\n                  { x => T }             Recursion\n```\n\n----------------------------------------\n\nTITLE: Using Match Expression After Period in Scala 3\nDESCRIPTION: Shows how a `match` expression can now directly follow a period in Scala 3, similar to a method call (`xs.match`). This snippet demonstrates using this new syntax within an `if` condition to match on the value of `xs`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/match-syntax.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nif xs.match\n  case Nil => false\n  case _   => true\nthen \"nonempty\"\nelse \"empty\"\n```\n\n----------------------------------------\n\nTITLE: Complete Eq Type Class with Derivation Logic in Scala\nDESCRIPTION: Provides the complete source code for the `Eq` type class, its companion object containing helper methods (`summonAll`, `check`, `iterator`, `eqSum`, `eqProduct`), a base instance for `Int`, and the inline `derived` method enabling automatic instance generation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.deriving.*\nimport scala.compiletime.{erasedValue, summonInline}\n\ninline def summonAll[T <: Tuple]: List[Eq[_]] =\n  inline erasedValue[T] match\n    case _: EmptyTuple => Nil\n    case _: (t *: ts) => summonInline[Eq[t]] :: summonAll[ts]\n\ntrait Eq[T]:\n  def eqv(x: T, y: T): Boolean\n\nobject Eq:\n  given Eq[Int] with\n    def eqv(x: Int, y: Int) = x == y\n\n  def check(elem: Eq[_])(x: Any, y: Any): Boolean =\n    elem.asInstanceOf[Eq[Any]].eqv(x, y)\n\n  def iterator[T](p: T) = p.asInstanceOf[Product].productIterator\n\n  def eqSum[T](s: Mirror.SumOf[T], elems: => List[Eq[_]]): Eq[T] =\n    new Eq[T]:\n      def eqv(x: T, y: T): Boolean =\n        val ordx = s.ordinal(x)\n        (s.ordinal(y) == ordx) && check(elems(ordx))(x, y)\n\n  def eqProduct[T](p: Mirror.ProductOf[T], elems: => List[Eq[_]]): Eq[T] =\n    new Eq[T]:\n      def eqv(x: T, y: T): Boolean =\n        iterator(x).zip(iterator(y)).zip(elems.iterator).forall {\n          case ((x, y), elem) => check(elem)(x, y)\n        }\n\n  inline given derived[T](using m: Mirror.Of[T]): Eq[T] =\n    lazy val elemInstances = summonAll[m.MirroredElemTypes]\n    inline m match\n      case s: Mirror.SumOf[T]     => eqSum(s, elemInstances)\n      case p: Mirror.ProductOf[T] => eqProduct(p, elemInstances)\nend Eq\n```\n\n----------------------------------------\n\nTITLE: Importing Decorators for Pretty Printing in Scala 3\nDESCRIPTION: Imports the necessary extension methods from the `dotty.tools.dotc.core.Decorators` package. This import enables the use of special string interpolators (`i\"\"`, `em\"\"`, `ex\"\"`) within the Scala 3 compiler codebase for pretty-printing compiler-specific objects, which often default to calling the `.show` method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/inspection.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport dotty.tools.dotc.core.Decorators.*\n```\n\n----------------------------------------\n\nTITLE: Defining a Command Line Entry Method Using @main Annotation in Scala\nDESCRIPTION: This Scala snippet demonstrates how to define a command line executable program by annotating a method with @main. The method 'happyBirthday' takes mandatory parameters including an Int and String, and a repeated String parameter for additional names, constructs a birthday greeting string, and returns it. Dependencies include Scala 3's @main annotation and command line argument parsing support. The input parameters correspond to parsed command line arguments; output is a formatted greeting string. The method can be invoked from the command line by its name with arguments, which are automatically parsed and validated.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/main-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n@main def happyBirthday(age: Int, name: String, others: String*) =\n  val suffix =\n    age % 100 match\n    case 11 | 12 | 13 => \"th\"\n    case _ =>\n      age % 10 match\n        case 1 => \"st\"\n        case 2 => \"nd\"\n        case 3 => \"rd\"\n        case _ => \"th\"\n  val bldr = new StringBuilder(s\"Happy $age$suffix birthday, $name\")\n  for other <- others do bldr.append(\" and \").append(other)\n  bldr.toString\n```\n\n----------------------------------------\n\nTITLE: Defining Prefix, Infix, and Postfix Operation Syntax Using EBNF in Scala\nDESCRIPTION: This code defines, in EBNF, the grammatical structure for prefix, infix, and postfix operations on expressions. It shows how these expressions are parsed, including the base cases and recursive structures for chaining operations. The rules here guide how the Scala parser recognizes and handles operator precedence and associativity. No runtime dependencies exist.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_15\n\nLANGUAGE: EBNF\nCODE:\n```\nPostfixExpr     ::=  InfixExpr [id [nl]]\nInfixExpr       ::=  PrefixExpr\n                  |  InfixExpr id [nl] InfixExpr\nPrefixExpr      ::=  [‘-’ | ‘+’ | ‘!’ | ‘~’] SimpleExpr\n```\n\n----------------------------------------\n\nTITLE: Defining Overloaded Methods and Classes for Example in Scala\nDESCRIPTION: Defines a class `A` that extends `B`, two overloaded methods named `f` with different parameter types (`B`, `B`) and (`A`, `B`), and declares values `a` and `b` of types `A` and `B` respectively. These definitions serve as the basis for illustrating Scala's overloading resolution mechanism in the subsequent examples.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_50\n\nLANGUAGE: Scala\nCODE:\n```\nclass A extends B {}\ndef f(x: B, y: B) = ...\ndef f(x: A, y: B) = ...\nval a: A\nval b: B\n```\n\n----------------------------------------\n\nTITLE: EBNF Syntax for Scala Integer Literals\nDESCRIPTION: This snippet defines the formal syntax of integer literals in Scala, covering decimal, hexadecimal, and binary numeral formats as well as optional Long-type suffixes 'L' or 'l'. It indicates how digits may be grouped with underscores for readability.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_10\n\nLANGUAGE: EBNF\nCODE:\n```\nintegerLiteral   ::=  (decimalNumeral | hexNumeral | binaryNumeral) [‘L’ | ‘l’]\ndecimalNumeral   ::=  ‘0’ | digit [{digit | ‘_’} digit]\nhexNumeral       ::=  ‘0’ (‘x’ | ‘X’) hexDigit [{hexDigit | ‘_’} hexDigit]\nbinaryNumeral    ::=  ‘0’ (‘b’ | ‘B’) binaryDigit [{binaryDigit | ‘_’} binaryDigit]\n```\n\n----------------------------------------\n\nTITLE: Using Extractors to Pattern Match on AST in Scala 3\nDESCRIPTION: Demonstrates how to use extractors from quotes.reflect to pattern match on tree structures and validate input parameters, with error reporting for invalid inputs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/reflection.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef natConstImpl(x: Expr[Int])(using Quotes): Expr[Int] =\n  import quotes.reflect.*\n  val tree: Term = x.asTerm\n  tree match\n    case Inlined(_, _, Literal(IntConstant(n))) =>\n      if n <= 0 then\n        report.error(\"Parameter must be natural number\")\n        '{0}\n      else\n        tree.asExprOf[Int]\n    case _ =>\n      report.error(\"Parameter must be a known constant\")\n      '{0}\n```\n\n----------------------------------------\n\nTITLE: Translated Scala 3 For Comprehension: Prime Sum Pairs using flatMap/withFilter/map\nDESCRIPTION: Shows the translated version of the prime sum pairs example `for` comprehension. This demonstrates how the original syntax maps directly to chained calls of `flatMap`, `withFilter`, and `map` on the underlying collections (`1 until n` and `1 until i`), according to the standard translation rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\n(1 until n)\n  .flatMap { // Corresponds to the first generator `i <- 1 until n`\n     case i => (1 until i) // Corresponds to the second generator `j <- 1 until i`\n       .withFilter { j => isPrime(i+j) } // Corresponds to the guard `if isPrime(i+j)`\n       .map { case j => (i, j) } // Corresponds to the `yield (i, j)`\n    }\n```\n\n----------------------------------------\n\nTITLE: Illustrating Subcapturing Relationships in Scala\nDESCRIPTION: Demonstrates valid subcapturing relationships (`<:`) between different capture sets (`{l}`, `{fs}`, `{fs, ct}`, `{*}`) based on variable declarations with specific capture sets. It shows how smaller sets are subtypes of larger, covering sets, with `{}` being the universal cover.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nfs: {*} FileSystem\nct: {*} CanThrow[Exception]\nl : {fs} Logger\n```\n\nLANGUAGE: text\nCODE:\n```\n{l}  <: {fs}     <: {*}\n{fs} <: {fs, ct} <: {*}\n{ct} <: {fs, ct} <: {*}\n```\n\n----------------------------------------\n\nTITLE: Applying the max function with explicit and inferred context parameters\nDESCRIPTION: Shows examples of invoking the max function by explicitly passing the context parameter using 'using' and by relying on inference, illustrating flexibility in context argument passing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/using-clauses.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nmax(2, 3)(using intOrd)\nmax(List(1, 2, 3), Nil)\n```\n\n----------------------------------------\n\nTITLE: Publishing Scala 3 Compiler Locally Using sbt - Bash\nDESCRIPTION: Details the sbt command to publish the locally built Scala 3 compiler artifacts into the local Ivy repository, allowing testing compiler changes in separate projects by referencing the published snapshot version in their build.sbt files.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/getting-started.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt publishLocal\n```\n\n----------------------------------------\n\nTITLE: Illustration of right-associative operator expansion rule\nDESCRIPTION: This snippet explains how the compiler transforms a right-associative infix operation like `x +: xs` into a method call such as `xs.+:(x)` with parameter swapping. It emphasizes the importance of understanding parameter reordering for defining correct extension methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/right-associative-extension-methods.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nThe expansion of right-associative extension methods performs an analogous parameter swap:\n\nIf `otherParams` consists of a single parameter `rightParam` followed by `remaining`, the total parameter sequence becomes:\n\nleadingUsing  rightParam  trailingUsing  extensionParam  remaining\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Methods with Named Type Arguments in Scala\nDESCRIPTION: This snippet demonstrates defining a generic method with type parameters and invoking it using named type arguments in Scala 3. The method 'construct' takes an element type 'Elem' and a collection type constructor 'Coll', receiving a variable number of arguments of type 'Elem' and returning a collection built from those elements. The snippet shows two ways to call 'construct': one with both type parameters explicitly named and another with only one named, allowing the compiler to infer the other. The method itself requires no implementation for the demonstration. Prerequisites: Scala 3 compiler. Parameters: 'Elem' for element type, 'Coll' for collection type constructor, 'xs' as a varargs sequence. Output: A collection of the specified type containing the provided elements.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/named-typeargs.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef construct[Elem, Coll[_]](xs: Elem*): Coll[Elem] = ???\n\nval xs1 = construct[Coll = List, Elem = Int](1, 2, 3)\nval xs2 = construct[Coll = List](1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Standard Scala 3 Compiler Plugin (Scala)\nDESCRIPTION: Presents the source code for a standard Scala 3 compiler plugin named `DivideZero`. The plugin defines a new compiler phase (`DivideZeroPhase`) that runs after `Pickler` and before `Staging` to detect and report errors for integer division by zero by transforming the Abstract Syntax Tree (AST). It demonstrates extending `StandardPlugin` and `PluginPhase` and overriding `transformApply` for AST manipulation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/compiler-plugins.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\npackage dividezero\n\nimport dotty.tools.dotc.ast.Trees.*\nimport dotty.tools.dotc.ast.tpd\nimport dotty.tools.dotc.core.Constants.Constant\nimport dotty.tools.dotc.core.Contexts.Context\nimport dotty.tools.dotc.core.Decorators.*\nimport dotty.tools.dotc.core.StdNames.*\nimport dotty.tools.dotc.core.Symbols.*\nimport dotty.tools.dotc.plugins.{PluginPhase, StandardPlugin}\nimport dotty.tools.dotc.transform.{Pickler, Staging}\n\nclass DivideZero extends StandardPlugin:\n  val name: String = \"divideZero\"\n  override val description: String = \"divide zero check\"\n\n  override def initialize(options: List[String])(using Context): List[PluginPhase] =\n    (new DivideZeroPhase) :: Nil\n\nclass DivideZeroPhase extends PluginPhase:\n  import tpd.*\n\n  val phaseName = \"divideZero\"\n\n  override val runsAfter = Set(Pickler.name)\n  override val runsBefore = Set(Staging.name)\n\n  override def transformApply(tree: Apply)(implicit ctx: Context): Tree =\n    tree match\n      case Apply(Select(rcvr, nme.DIV), List(Literal(Constant(0))))\n      if rcvr.tpe <:< defn.IntType =>\n        report.error(\"dividing by zero\", tree.pos)\n      case _ =>\n        ()\n    tree\nend DivideZeroPhase\n```\n\n----------------------------------------\n\nTITLE: Assigning a Closure with a Local Capability to a Global Variable in Scala\nDESCRIPTION: This example shows improper assignment of a closure capturing a local capability to a globally scoped mutable variable. The loophole variable, typed as {*} () -> Unit, is globally accessible, and the closure () => f.write(0) captures the local parameter f. This snippet demonstrates a pattern that will fail escape checking in Scala 3 because the capability f would outlive its intended scope if assigned to loophole. The code presumes prior definition of usingLogFile and a suitable FileOutputStream context. Mutable variables cannot have universal capture sets, and the snippet will not compile as intended.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nvar loophole: {*} () -> Unit = () => ()\nusingLogFile { f =>\n  loophole = () => f.write(0)\n}\nloophole()\n```\n\n----------------------------------------\n\nTITLE: Mapping Structural Value Selection to selectDynamic\nDESCRIPTION: This snippet shows how a structural selection `v.a` on a value `v` of type `C { Rs }` is translated by the compiler into a call to `v.selectDynamic(\"a\")` followed by a type cast to the expected static type `U`. This demonstrates the underlying mechanism for accessing structural members.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types-spec.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nv.selectDynamic(\"a\").asInstanceOf[U]\n```\n\n----------------------------------------\n\nTITLE: Type Error Example with Bounded Opaque Permission Types in Scala\nDESCRIPTION: Provides an example where passing a Permissions value in place of a required PermissionChoice results in a type error, illustrating the precise separation imposed by opaque type bounds. This snippet should be compiled in the context of previous Access and User modules for the error to manifest; demonstrates how Scala's type system prevents accidental misuse across unrelated opaque types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/opaques.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nassert(roItem.rights.isOneOf(ReadWrite))\n                               ^^^^^^^^^\n                               Found:    (Access.ReadWrite : Access.Permissions)\n                               Required: Access.PermissionChoice\n```\n\n----------------------------------------\n\nTITLE: Defining Annotated Types in Scala 3 EBNF\nDESCRIPTION: This EBNF grammar describes annotated types as 'Type Annotation', allowing types to carry additional metadata via annotations (e.g., 'String @suspendable'). Annotated types influence compilation and code generation where annotations are used for tooling or frameworks. Prerequisite: understanding of annotation syntax per Scala specifications.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_22\n\nLANGUAGE: ebnf\nCODE:\n```\nAnnotatedType  ::=  Type Annotation\n```\n\n----------------------------------------\n\nTITLE: Scala Root Classes Implementation\nDESCRIPTION: Defines the signatures of Scala's root classes: Any, AnyVal, and AnyRef. Includes core methods like equals, hashCode, toString, and type operations isInstanceOf and asInstanceOf.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\n/** The universal root class */\nabstract class Any {\n\n  /** Defined equality; abstract here */\n  def equals(that: Any): Boolean\n\n  /** Semantic equality between values */\n  final def == (that: Any): Boolean  =\n    if (null eq this) null eq that else this equals that\n\n  /** Semantic inequality between values */\n  final def != (that: Any): Boolean  =  !(this == that)\n\n  /** Hash code; abstract here */\n  def hashCode: Int = ...\n\n  /** Textual representation; abstract here */\n  def toString: String = ...\n\n  /** Type test; needs to be inlined to work as given */\n  def isInstanceOf[a]: Boolean\n\n  /** Type cast; needs to be inlined to work as given */ */\n  def asInstanceOf[A]: A\n}\n\n/** The root class of all value types */\nfinal class AnyVal extends Any\n\n/** The root class of all reference types */\nclass AnyRef extends Any {\n  def equals(that: Any): Boolean      = this eq that\n  final def eq(that: AnyRef): Boolean = ... // reference equality\n  final def ne(that: AnyRef): Boolean = !(this eq that)\n\n  def hashCode: Int = ...     // hashCode computed from allocation address\n  def toString: String  = ... // toString computed from hashCode and class name\n\n  def synchronized[T](body: => T): T // execute `body` in while locking `this`.\n}\n```\n\n----------------------------------------\n\nTITLE: Syntax Rules for Scala Identifiers and Escapes (EBNF)\nDESCRIPTION: Specifies the grammar for constructing different types of identifiers (`op`, `varid`, `boundvarid`, `alphaid`, `plainid`, `id`) and character escape sequences (`escapeSeq`, `UnicodeEscape`, `hexDigit`) in Scala source code, detailing how letters, digits, operator characters, and backticks are used.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_1\n\nLANGUAGE: ebnf\nCODE:\n```\nop            ::=  opchar {opchar}\nvarid         ::=  lower idrest\nboundvarid    ::=  varid\n                | ‘`’ varid ‘`’\nalphaid       ::=  upper idrest\n                |  varid\nplainid       ::=  alphaid\n                |  op\nid            ::=  plainid\n                |  ‘`’ { charNoBackQuoteOrNewline | escapeSeq } ‘`’\nidrest        ::=  {letter | digit} [‘_’ op]\nescapeSeq     ::= UnicodeEscape | charEscapeSeq\nUnicodeEscape ::= ‘\\’ ‘u’ {‘u’} hexDigit hexDigit hexDigit hexDigit\nhexDigit      ::= ‘0’ | ... | ‘9’ | ‘A’ | ... | ‘F’ | ‘a’ | ... | ‘f’\n```\n\n----------------------------------------\n\nTITLE: Adding scala3-tasty-inspector Dependency in sbt Build (Scala)\nDESCRIPTION: Defines how to add the official Scala 3 TASTy inspector library as a dependency in an sbt build configuration. This dependency provides the Inspector API to load and analyze TASTy files programmatically. It uses the active scalaVersion for seamless integration.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/tasty-inspect.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"org.scala-lang\" %% \"scala3-tasty-inspector\" % scalaVersion.value\n```\n\n----------------------------------------\n\nTITLE: Flow Typing with Logical Operators for Nullability - Scala\nDESCRIPTION: This example illustrates the use of logical operators (&&, ||) in null tests with Scala 3's flow typing: both variables are considered non-null in the true branch (with &&), and both revert to nullable in the false branches. The feature improves working with multiple potentially-null values from Java interop.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nval s: String | Null = ???\nval s2: String | Null = ???\nif s != null && s2 != null then\n  // s: String\n  // s2: String\n\nif s == null || s2 == null then\n  // s: String | Null\n  // s2: String | Null\nelse\n  // s: String\n  // s2: String\n\n```\n\n----------------------------------------\n\nTITLE: Simulating Abstract Implicit Def with Scala 3 Abstract Def and Alias Given\nDESCRIPTION: Declares a regular abstract method `symDecorator` and then provides it as a given instance for the type `SymDecorator` using an alias given. This combination simulates an abstract implicit def in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ndef symDecorator: SymDecorator\ngiven SymDecorator = symDecorator\n```\n\n----------------------------------------\n\nTITLE: Function Desugaring for Pattern Matching Anonymous Functions\nDESCRIPTION: Shows how a pattern matching anonymous function is desugared into a traditional anonymous function with an explicit match statement when the expected type is Function.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\n(´x_1: S_1, ..., x_k: S_k´) => (´x_1, ..., x_k´) match {\n  case ´p_1´ => ´b_1´ ... case ´p_n´ => ´b_n´\n}\n```\n\n----------------------------------------\n\nTITLE: Extending a Parameterized Trait with a Class in Scala 3\nDESCRIPTION: Demonstrates how a class `Greet` extends the parameterized trait `Greeting`. It passes the required argument (\"Bob\") to the `Greeting` trait's constructor during extension and invokes the `msg` method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/trait-parameters.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Greet extends Greeting(\"Bob\"):\n  println(msg)\n```\n\n----------------------------------------\n\nTITLE: Defining Concrete Scala `TupleN` and `ProductN` (n <= 22)\nDESCRIPTION: Defines the `scala.ProductN` trait (extending `Product`) and the `scala.TupleN` final case class for concrete tuple implementations where ´1 \\leq n \\leq 22´. `TupleN` extends the corresponding `*:` structure and implements `ProductN`, providing direct accessors `_1` to `_n`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ntrait Product´_n´[+´T_1´, ..., +´T_n´] extends Product:\n  override def productArity: Int = ´n´\n  def _1: ´T_1´\n  ...\n  def _n: ´T_n´\n\nfinal case class Tuple´_n´[+´T_1´, ..., +´T_n´](_1: ´T_1´, ..., _n: ´T_n´)\n    extends *:[´T_1´, ´T_2´ *: ... _: ´T_n´ *: EmptyTuple]\n    with Product´_n´[´T_1´, ..., ´T_n´]\n```\n\n----------------------------------------\n\nTITLE: Quotation and Splicing in Scala 3 Macros\nDESCRIPTION: Quotation converts program code to data using '{...} for expressions and '[...] for types, while splicing with ${...} converts code representation back to program code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/metaprogramming.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n'{...}  // Quotation for expressions\n'[...]  // Quotation for types\n${...}   // Splicing\n```\n\n----------------------------------------\n\nTITLE: List of Regular Scala Reserved Keywords\nDESCRIPTION: Enumerates the set of names that are unconditionally reserved in Scala and cannot be used as user-defined identifiers. These are fundamental keywords for the Scala syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nabstract  case      catch     class     def       do        else\nenum      export    extends   false     final     finally   for\ngiven     if        implicit  import    lazy      match     new\nnull      object    override  package   private   protected return\nsealed    super     then      throw     trait     true      try\ntype      val       var       while     with      yield\n:         =         <-        =>        <:        >:        #\n@         =>>       ?=>\n```\n\n----------------------------------------\n\nTITLE: Creating instance-controlled classes with abstract and sealed modifiers in Scala 3\nDESCRIPTION: Demonstrates a pattern for preventing direct instantiation of a class by declaring it both abstract and sealed. Clients can only create instances through factory methods on existing instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject m {\n  abstract sealed class C (x: Int) {\n    def nextC = new C(x + 1) {}\n  }\n  val empty = new C(0) {}\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nnew m.C(0)    // **** error: C is abstract, so it cannot be instantiated.\nnew m.C(0) {} // **** error: illegal inheritance from sealed class.\n```\n\n----------------------------------------\n\nTITLE: Defining Dependent Method and Function Value in Scala 3\nDESCRIPTION: Illustrates the definition of a trait with a path-dependent type, a dependent method whose result type depends on a parameter, and a dependent function value in Scala 3 that captures the dependent method. This demonstrates the new capability of representing dependent methods as function values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/dependent-function-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Entry { type Key; val key: Key }\n\ndef extractKey(e: Entry): e.Key = e.key          // a dependent method\n\nval extractor: (e: Entry) => e.Key = extractKey  // a dependent function value\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Example of Indentation-Based Syntax for Indent Widths\nDESCRIPTION: Provides an implementation of indentation widths, using an algebraic data type to represent simple and concatenated indentation segments, along with comparison operators, string representation, and caching for efficiency.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nenum IndentWidth:\n  case Run(ch: Char, n: Int)\n  case Conc(l: IndentWidth, r: Run)\n\n  def <= (that: IndentWidth): Boolean = this match\n    case Run(ch1, n1) =>\n      that match\n        case Run(ch2, n2) => n1 <= n2 && (ch1 == ch2 || n1 == 0)\n        case Conc(l, r)   => this <= l\n    case Conc(l1, r1) =>\n      that match\n        case Conc(l2, r2) => l1 == l2 && r1 <= r2\n        case _            => false\n\n  def < (that: IndentWidth): Boolean =\n    this <= that && !(that <= this)\n\n  override def toString: String =\n    this match\n      case Run(ch, n) =>\n        val kind = ch match\n          case ' '  => \"space\"\n          case '\\t' => \"tab\"\n          case _    => s\"'\\$ch'-character\"\n        val suffix = if n == 1 then \"\" else \"s\"\n        s\"$n $kind$suffix\"\n      case Conc(l, r) =>\n        s\"$l, $r\"\n\nobject IndentWidth:\n  private inline val MaxCached = 40\n\n  private val spaces = IArray.tabulate(MaxCached + 1)(new Run(' ', _))\n  private val tabs = IArray.tabulate(MaxCached + 1)(new Run('\\t', _))\n\n  def Run(ch: Char, n: Int): Run =\n    if n <= MaxCached && ch == ' ' then\n      spaces(n)\n    else if n <= MaxCached && ch == '\\t' then\n      tabs(n)\n    else\n      new Run(ch, n)\n  end Run\n\n  val Zero = Run(' ', 0)\n```\n\n----------------------------------------\n\nTITLE: Defining the `TypeTest` Trait in Scala Reflect\nDESCRIPTION: Presents the definition of the `scala.reflect.TypeTest` trait. This trait provides an `unapply` method that performs a sound runtime type test, returning the input `s` typed as `T` within an `Option` if the test succeeds. It's crucial for handling type tests on abstract types where type erasure occurs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.reflect\n\ntrait TypeTest[-S, T]:\n  def unapply(s: S): Option[s.type & T]\n```\n\n----------------------------------------\n\nTITLE: Defining Tuple Type Hierarchy in Scala 3 - Scala\nDESCRIPTION: This Scala snippet defines the type hierarchy for tuples in Dotty 0.25.0-RC2, introducing a dedicated EmptyTuple type instead of using Unit for empty tuples. This change allows all tuples to be subtypes of Product and establishes a clear separation between empty and non-empty tuples. Key components include EmptyTuple representing empty tuples and NonEmptyTuple with a generic *: [Head, Tail <: Tuple] reconstructing the non-empty tuples. This change affects type class derivation codebases that previously relied on Unit for empty tuples.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-06-22-25th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nProduct -- Tuple -+- EmptyTuple\n                  |\n                  +- NonEmptyTuple -- *:[Head, Tail <: Tuple]\n```\n\n----------------------------------------\n\nTITLE: Explicit Eta Expansion for Nullary Method - Scala 3\nDESCRIPTION: This code demonstrates the recommended explicit way to perform eta expansion on a nullary method like `next()` in Scala 3. It creates a function value by defining a lambda expression that calls the method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/eta-expansion.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n() => next()\n```\n\n----------------------------------------\n\nTITLE: Defining Top-Level Types, Values, Methods, Classes, and Extensions in Scala 3 - Scala\nDESCRIPTION: This snippet demonstrates the use of Scala 3's top-level definitions by declaring a type alias, a value, a method, a case class, and an extension method directly within a package scope. The code depends on Scala 3 and requires no additional imports or libraries. Key parameters include the generic type T in the alias, the tuple provided for 'a', and the 'C' class instances. The snippet produces a labelled integer and enables value extraction and instance pairing at the top-level, without wrapping in an explicit object. The main constraint is that this form is only valid in Scala 3 or later versions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/toplevel-definitions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage p\ntype Labelled[T] = (String, T)\nval a: Labelled[Int] = (\"count\", 1)\ndef b = a._2\n\ncase class C()\n\nextension (x: C) def pair(y: C) = (x, y)\n```\n\n----------------------------------------\n\nTITLE: Defining and Extending Open Classes in Scala 3\nDESCRIPTION: This Scala code demonstrates the declaration of an 'open' generic class 'Writer' with methods for sending data to stdout, including a variadic method 'sendAll'. It also shows a subclass 'EncryptedWriter' that extends 'Writer' while overriding the 'send' method to encrypt data before sending. Dependencies include a context bound 'Encryptable' for 'EncryptedWriter'. The snippet illustrates use of the 'open' modifier on the superclass for extensibility, method overriding, and package organization. Inputs are generic type elements to be sent or encrypted before sending; outputs are side effects of printing to stdout.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/open-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// File Writer.scala\npackage p\n\nopen class Writer[T]:\n\n  /** Sends to stdout, can be overridden */\n  def send(x: T) = println(x)\n\n  /** Sends all arguments using `send` */\n  def sendAll(xs: T*) = xs.foreach(send)\nend Writer\n\n// File EncryptedWriter.scala\npackage p\n\nclass EncryptedWriter[T: Encryptable] extends Writer[T]:\n  override def send(x: T) = super.send(encrypt(x))\n```\n\n----------------------------------------\n\nTITLE: Git contributors shortlog for Scala 3.3.0-RC1\nDESCRIPTION: A git shortlog showing contributor statistics between Scala versions 3.2.2 and 3.3.0-RC1, listing the number of commits per contributor in descending order. Martin Odersky leads with 225 commits, followed by Dale Wijnand with 73 and Szymon Rodziewicz with 58.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.3.0-RC2.md#_snippet_0\n\nLANGUAGE: git\nCODE:\n```\n   225 Martin Odersky\n    73 Dale Wijnand\n    58 Szymon Rodziewicz\n    54 Nicolas Stucki\n    48 Kamil Szewczyk\n    48 Paul Coral\n    30 Paweł Marks\n    28 Florian3k\n    28 Yichen Xu\n    14 Guillaume Martres\n     8 Fengyun Liu\n     8 Michał Pałka\n     7 Chris Birchall\n     7 rochala\n     6 Kacper Korban\n     6 Sébastien Doeraene\n     6 jdudrak\n     5 Seth Tisue\n     5 Som Snytt\n     5 nizhikov\n     4 Filip Zybała\n     4 Jan Chyb\n     4 Michael Pollmeier\n     4 Natsu Kagami\n     3 Jamie Thompson\n     2 Alex\n     2 Anatolii Kmetiuk\n     2 Dmitrii Naumenko\n     2 Lukas Rytz\n     2 adampauls\n     2 yoshinorin\n     1 Alexander Slesarenko\n     1 Chris Kipp\n     1 Guillaume Raffin\n     1 Jakub Kozłowski\n     1 Jan-Pieter van den Heuvel\n     1 Julien Richard-Foy\n     1 Kenji Yoshida\n     1 Philippus\n     1 Szymon R\n     1 Tim Spence\n     1 s.bazarsadaev\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running TASTy Inspection Program with Scala Compiler Shell Commands (Shell)\nDESCRIPTION: Provides shell commands to compile and run the Scala TASTy inspection program example showing usage of scalac and scala commands. The -with-compiler option is passed to the scala runtime to enable compiler availability at runtime which is necessary for TASTy inspection. This snippet ensures correct setup for execution of TASTy inspector applications after compilation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/tasty-inspect.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nscalac -d out Test.scala\nscala -with-compiler -classpath out Test\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Legacy XML Literals in Scala\nDESCRIPTION: This snippet illustrates how XML literals were traditionally used in Scala to generate XML nodes directly within code. It defines a Person case class, prepares a todo list of message data, and constructs message XML elements within a for-comprehension. Dependencies include the standard Scala XML literal syntax (now deprecated in Scala 3). Inputs are tuples representing sender, receiver, title, and message body, and output is a collection of XML nodes. This approach will be dropped in future Scala versions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/dropped-features/xml.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport dotty.xml.interpolator.*\n\ncase class Person(name: String) { override def toString = name }\n\n@main def test: Unit =\n  val bill = Person(\"Bill\")\n  val john = Person(\"John\")\n  val mike = Person(\"Mike\")\n  val todoList = List(\n    (bill, john, \"Meeting\", \"Room 203, 11:00am\"),\n    (john, mike, \"Holiday\", \"March 22-24\")\n  )\n  // XML literals (to be dropped)\n  val mails1 = for (from, to, heading, body) <- todoList yield\n    <message>\n      <from>{from}</from><to>{to}</to>\n      <heading>{heading}</heading><body>{body}</body>\n    </message>\n  println(mails1)\n```\n\n----------------------------------------\n\nTITLE: Declaring a Function Parameter with Universal Capability in Scala\nDESCRIPTION: This snippet declares a function usingLogFile that accepts a parameter of type ({*} FileOutputStream) => T, demonstrating the use of universal capabilities in function types. The universal capability {*} is meant to be tightly controlled; using it as a type variable instantiation is disallowed by the system's escape checking. Dependencies include having the FileOutputStream type in scope and using Scala 3's capability system. The function is generic in T, and the op parameter is expected to be a function that receives a FileOutputStream with a universal capability. This pattern will trigger an error if an illegal capability escape occurs, as explained in the accompanying analysis.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ndef usingLogFile[T](op: ({*} FileOutputStream) => T): T = ...\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Typed Pattern Syntax (EBNF)\nDESCRIPTION: Specifies the EBNF syntax for `Pattern1` that includes a type test. It shows that a pattern variable (`varid`) or a wildcard (`_`) can be followed by a colon (`:`) and a `TypePat`, allowing patterns to match values based on their type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_2\n\nLANGUAGE: ebnf\nCODE:\n```\n  Pattern1        ::=  varid ‘:’ TypePat\n                    |  ‘_’ ‘:’ TypePat\n```\n\n----------------------------------------\n\nTITLE: Valid Pattern Examples for Match Types in Scala 3\nDESCRIPTION: Examples of legal pattern types that can be used in Match Types, including simple types, class type constructors with captures, and nested patterns in covariant positions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\n// TypeWithoutCapture's\ncase Any => // also the desugaring of `case _ =>` when the _ is at the top-level\ncase Int =>\ncase List[Int] =>\ncase Array[String] =>\n\n// Class type constructors with direct captures\ncase scala.collection.immutable.List[t] => // not Predef.List; it is a type alias\ncase Array[t] =>\ncase Contra[t] =>\ncase Either[s, t] =>\ncase Either[s, Contra[Int]] =>\ncase h *: t =>\ncase Int *: t =>\n\n// The S type constructor\ncase S[n] =>\n\n// An abstract type constructor\n// given a [F[_]] or `type F[_] >: L <: H` in scope\ncase F[t] =>\n\n// Nested captures in covariant position\ncase Cov[Inv[t]] =>\ncase Cov[Cov[t]] =>\ncase Cov[Contra[t]] =>\ncase Array[h] *: t => // sugar for *:[Array[h], t]\ncase g *: h *: EmptyTuple =>\n\n// Type aliases\ncase List[t] => // which is Predef.List, itself defined as `type List[+A] = scala.collection.immutable.List[A]`\n\n// Refinements (through a type alias)\ncase YExtractor[t] =>\n```\n\n----------------------------------------\n\nTITLE: Illegal @targetName Breaking Overriding in Scala\nDESCRIPTION: Shows a compilation error resulting from attempting to override a method `f` from class `A` in subclass `B` while applying a `@targetName(\"g\")` annotation to the overriding method. This is disallowed because the overridden method lacks a `@targetName`, and overriding methods must match the erased name (or lack thereof) of the method they override.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/targetName.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport annotation.targetName\nclass A:\n  def f(): Int = 1\nclass B extends A:\n  @targetName(\"g\") def f(): Int = 2\n```\n\n----------------------------------------\n\nTITLE: Collecting AST Nodes with TreeAccumulator in Scala 3\nDESCRIPTION: Demonstrates how to use TreeAccumulator to traverse an AST and collect specific nodes (in this case, ValDef symbols) throughout the traversal.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/reflection.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef collectPatternVariables(tree: Tree)(using ctx: Context): List[Symbol] =\n  val acc = new TreeAccumulator[List[Symbol]]:\n    def foldTree(syms: List[Symbol], tree: Tree)(owner: Symbol): List[Symbol] = tree match\n      case ValDef(_, _, rhs) =>\n        val newSyms = tree.symbol :: syms\n        foldTree(newSyms, body)(tree.symbol)\n      case _ =>\n        foldOverTree(syms, tree)(owner)\n  acc(Nil, tree)\n```\n\n----------------------------------------\n\nTITLE: Fundamental Type Aliases in Scala\nDESCRIPTION: Defines fundamental type aliases in the scala package that expose otherwise internal types to user code, including AnyKind, Nothing, union types (|), and intersection types (&).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype AnyKind = ´x´           // where ´x´ is the internal AnyKind type\ntype Nothing = ´x´           // where ´x´ is the internal Nothing type\ntype | = [A, B] =>> A ´｜´ B // where ｜ is the internal union type operator\ntype & = [A, B] =>> A ´＆´ B // where ＆ is the internal intersection type operator\n```\n\n----------------------------------------\n\nTITLE: Illustrating Scala 3 Type Lambdas\nDESCRIPTION: Provides Scala examples demonstrating the usage of type lambdas. It defines type aliases `Lst` and `Fn` using type lambdas, shows valid instantiations (`x`, `f`), highlights an error case (`g`) where bounds are not met, and demonstrates usage with higher-kinded types in the `liftPair` function.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ntype Lst = [T] =>> List[T] // T is inferred to be covariant with bounds >: Nothing <: Any\ntype Fn = [A <: Seq[?], B] =>> (A => B) // A is inferred to be contravariant, B covariant\n\nval x: Lst[Int] = List(1) // ok, Lst[Int] expands to List[Int]\nval f: Fn[List[Int], Int] = (x: List[Int]) => x.head // ok\n\nval g: Fn[Int, Int] = (x: Int) => x // error: Int does not conform to the bound Seq[?]\n\ndef liftPair[F <: [T] =>> Any](f: F[Int]): Any = f\nliftPair[Lst](List(1)) // ok, Lst <: ([T] =>> Any)\n```\n\n----------------------------------------\n\nTITLE: Accessing Members on Nullable Types in Scala\nDESCRIPTION: Illustrates that attempting to access a member (e.g., `trim`) directly on a variable with a nullable type (`String | Null`) results in a compile-time error, as the variable might be `null`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nx.trim // error: trim is not member of String | Null\n```\n\n----------------------------------------\n\nTITLE: Querying Source Documentation in Dotty REPL Using Scala\nDESCRIPTION: This interactive Scala REPL snippet demonstrates the use of the `:doc` command to query documentation comments of previously compiled sources. The snippet shows defining an object with documentation comments and then retrieving those comments for the object and a method within it, allowing users to access source documentation directly in the REPL environment.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-10-10-10th-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> /** An object */ object O { /** A def */ def foo = 0 }\n// defined object O\n\nscala> :doc O\n/** An object */\n\nscala> :doc O.foo\n/** A def */\n```\n\n----------------------------------------\n\nTITLE: Equivalent Traditional Anonymous Function for Scalar Product\nDESCRIPTION: Shows the equivalent traditional anonymous function with an explicit match statement corresponding to the pattern matching anonymous function used in the scalar product example.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\n(x, y) => (x, y) match {\n  case (a, (b, c)) => a + b * c\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Open Class in Scala\nDESCRIPTION: Defines an open class `Writer` in Scala, marked with the `open` modifier to signal it's intended for extension. It includes methods `send` and `sendAll`, with `send` marked as potentially overridden, establishing part of an 'extension contract'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/open-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// File Writer.scala\npackage p\n\nopen class Writer[T]:\n\n  /** Sends to stdout, can be overridden */\n  def send(x: T) = println(x)\n\n  /** Sends all arguments using `send` */\n  def sendAll(xs: T*) = xs.foreach(send)\nend Writer\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Instance-Scoped Opaque Types and Type Errors in Scala Classes\nDESCRIPTION: Illustrates the uniqueness of instance-scoped opaque type members: two instances of Logarithms have incompatible Logarithm types, preventing accidental mixing. Validates that only values from the same class instance may be legally combined, while combining across instances results in type errors. No dependencies needed beyond the prior class definition.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/opaques.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval l1 = new Logarithms\nval l2 = new Logarithms\nval x = l1(1.5)\nval y = l1(2.6)\nval z = l2(3.1)\nl1.mul(x, y) // type checks\nl1.mul(x, z) // error: found l2.Logarithm, required l1.Logarithm\n```\n\n----------------------------------------\n\nTITLE: Implementing a safe try-with-resources pattern with capture checking\nDESCRIPTION: A modified version of usingLogFile that uses capture checking to track the FileOutputStream capability, preventing it from escaping its intended scope and ensuring safety.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef usingLogFile[T](op: ({*} FileOutputStream) => T): T =\n  // same body as before\n```\n\n----------------------------------------\n\nTITLE: Using Exported Stable Values in Type Paths in Scala 3\nDESCRIPTION: Demonstrates that an export alias for a stable public value (`O.c`) maintains its stability. This allows its nested type (`c.T`) to be used in type signatures (like `f: c.T`), enabling access to members of the aliased value's type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass C { type T }\nobject O { val c: C = ... }\nexport O.c\ndef f: c.T = ...\n```\n\n----------------------------------------\n\nTITLE: Using summonInline for Compile-Time Implicit Resolution and Error Reporting (Scala)\nDESCRIPTION: This example defines an inline function `summonInlineCheck` that uses `scala.compiletime.summonInline` within an inline match. Based on the input integer `t`, it attempts to summon different traits (`Missing1`, `Missing2`, `NotMissing`). `summonInline` delays the implicit search until the call site is inlined. If a required implicit (`Missing1` or `Missing2`) is not found, it triggers the corresponding `@implicitNotFound` error at compile time. If the implicit (`NotMissing`) is found, the code compiles.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.summonInline\nimport scala.annotation.implicitNotFound\n\n@implicitNotFound(\"Missing One\")\ntrait Missing1\n\n@implicitNotFound(\"Missing Two\")\ntrait Missing2\n\ntrait NotMissing\ngiven NotMissing = ???\n\ntransparent inline def summonInlineCheck[T <: Int](inline t : T) : Any =\n  inline t match\n    case 1 => summonInline[Missing1]\n    case 2 => summonInline[Missing2]\n    case _ => summonInline[NotMissing]\n\n// These lines would cause compile errors if uncommented:\n// val missing1 = summonInlineCheck(1) // error: Missing One\n// val missing2 = summonInlineCheck(2) // error: Missing Two\n\nval notMissing : NotMissing = summonInlineCheck(3)\n```\n\n----------------------------------------\n\nTITLE: Solving Loop-and-a-Half with Blocked While Condition in Scala\nDESCRIPTION: This snippet demonstrates using a code block in the condition of a 'while' loop to repeatedly advance an iterator until a negative value is encountered, printing a period for each non-negative value. It solves the 'loop-and-a-half' problem by permitting variable declaration and assignment within the loop condition, enhancing clarity. The example requires a pre-existing iterator returning integers and uses only Scala 3 standard syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/do-while.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nwhile\n  val x: Int = iterator.next\n  x >= 0\ndo print(\".\")\n```\n\n----------------------------------------\n\nTITLE: Handling Deprecated Enum Cases Scala\nDESCRIPTION: Illustrates how to define methods or extensions (like `isDeprecatedCase`) to identify deprecated enum cases, showing how deprecated cases can still be referenced within the enum's scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Deprecations[T <: reflect.Enum]:\n  extension (t: T) def isDeprecatedCase: Boolean\n\nobject Planet:\n  given Deprecations[Planet]:\n    extension (p: Planet)\n      def isDeprecatedCase = p == Pluto\n```\n\n----------------------------------------\n\nTITLE: Peano Numbers TypeTest Example in Scala\nDESCRIPTION: Demonstrates the use of the `PeanoInt` implementation and its implicit `TypeTest` instances. The `divOpt` function safely pattern matches on the abstract types `Zero` and `Succ` of the input `n` thanks to the provided `TypeTest` givens.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n@main def test =\n  import PeanoInt.*\n\n  def divOpt(m: Nat, n: Nat): Option[(Nat, Nat)] =\n    n match\n      case Zero => None\n      case s @ Succ(_) => Some(safeDiv(m, s))\n\n  val two = Succ(Succ(Zero))\n  val five = Succ(Succ(Succ(two)))\n\n  println(divOpt(five, two))  // prints \"Some((2,1))\"\n  println(divOpt(two, five))  // prints \"Some((0,2))\"\n  println(divOpt(two, Zero))  // prints \"None\"\n```\n\n----------------------------------------\n\nTITLE: Defining Designator Types Syntax in EBNF\nDESCRIPTION: Defines the EBNF grammar for Scala 3 designator types. Designators are references to definitions (terms or types) and consist of an optional prefix (Type, PackageRef, or empty) followed by an identifier.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_11\n\nLANGUAGE: ebnf\nCODE:\n```\nDesignatorType    ::=  Prefix ‘.‘ id\nPrefix            ::=  Type\n                    |  PackageRef\n                    |  ε\nPackageRef        ::=  id {‘.‘ id}\n```\n\n----------------------------------------\n\nTITLE: Defining Export Clauses in a Copier Class in Scala\nDESCRIPTION: Example showing how to use export clauses in a Copier class to expose functionality from private printer and scanner components while controlling which members are exposed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/export.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass BitMap\nclass InkJet\n\nclass Printer:\n  type PrinterType\n  def print(bits: BitMap): Unit = ???\n  def status: List[String] = ???\n\nclass Scanner:\n  def scan(): BitMap = ???\n  def status: List[String] = ???\n\nclass Copier:\n  private val printUnit = new Printer { type PrinterType = InkJet }\n  private val scanUnit = new Scanner\n\n  export scanUnit.scan\n  export printUnit.{status as _, *}\n\n  def status: List[String] = printUnit.status ++ scanUnit.status\n```\n\n----------------------------------------\n\nTITLE: Simulating Extension Method with Implicit Class in Scala 2 - Scala\nDESCRIPTION: Implements an extension-like method in Scala 2 by defining an implicit class CircleDecorator, which wraps a Circle and provides a circumference method. Requires Circle with radius member. The implicit class adds 'circumference' as a method available where implicit conversion applies.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit class CircleDecorator(c: Circle) extends AnyVal {\n  def circumference: Double = c.radius * math.Pi * 2\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Eta Expansion with Polymorphism (Scala)\nDESCRIPTION: Demonstrates a manual attempt to eta-expand the original `runOps` method using explicit polymorphism (`[C^] => ...`). While conceptually sound within the proposed design (resulting type `[C^] -> List[() ->{C^} Unit] ->[C^] Unit`), the text notes this currently conflicts with an implementation restriction.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/use-design.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n[C^] => (xs: List[() ->{C^} Unit]) => runOps(xs)\n  : [C^] -> List[() ->{C^} Unit] ->[C^] Unit\n```\n\n----------------------------------------\n\nTITLE: Implementing Postconditions with Context Functions in Scala\nDESCRIPTION: Creating a zero-overhead abstraction for checking postconditions using opaque types and context functions, allowing simple reference to the result value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject PostConditions:\n  opaque type WrappedResult[T] = T\n\n  def result[T](using r: WrappedResult[T]): T = r\n\n  extension [T](x: T)\n    def ensuring(condition: WrappedResult[T] ?=> Boolean): T =\n      assert(condition(using x))\n      x\nend PostConditions\nimport PostConditions.{ensuring, result}\n\nval s = List(1, 2, 3).sum.ensuring(result == 6)\n```\n\n----------------------------------------\n\nTITLE: Using scalac with the -Yprint-pos Option - Shell\nDESCRIPTION: Runs the Scala compiler with the '-Yprint-pos' flag to annotate printed trees with their corresponding source code line and character positions. Useful for correlating output with original source locations when debugging complex transformations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nscalac -Yprint-pos  ../issues/Playground.scala\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Functor assertTransformation Method in Scala\nDESCRIPTION: Shows an example call to the `assertTransformation` method using `List` as the functor `F`. It passes the expected result list, the original list, and a lambda function to transform the elements. This demonstrates how the `Functor[List]` instance is implicitly used.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nassertTransformation(List(\"a1\", \"b1\"), List(\"a\", \"b\"), elt => s\"${elt}1\")\n```\n\n----------------------------------------\n\nTITLE: Interoperating with Java Classes Using Flexible Types in Scala - Scala\nDESCRIPTION: This code snippet demonstrates how a Java class with nullable reference types is translated and used in Scala 3, leveraging flexible types (`T?`) for null-safety. The example covers method invocation with nullable and non-nullable arguments, assignment from potentially-nullable Java return types, and potential runtime exception risks (NullPointerException) when interacting with flexible types. It requires a Java class J in the classpath and Scala 3's null-safety features enabled.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n// Considering class J is from Java\nclass J {\n  // Translates to def f(s: String?): Unit\n  public void f(String s) {\n  }\n\n  // Translates to def g(): String?\n  public String g() {\n    return \"\";\n  }\n}\n\n// Use J in Scala\ndef useJ(j: J) =\n  val x1: String = \"\"\n  val x2: String | Null = null\n  j.f(x1) // Passing String to String?\n  j.f(x2) // Passing String | Null to String?\n  j.f(null) // Passing Null to String?\n\n  // Assign String? to String\n  val y1: String = j.g()\n  // Assign String? to String | Null\n  val y2: String | Null = j.g()\n\n  // Calling member functions on flexible types\n  j.g().trim().length()\n\n```\n\n----------------------------------------\n\nTITLE: List of Soft Scala Keywords\nDESCRIPTION: Lists identifiers that are treated as keywords only in specific syntactic contexts. In other situations, these names can be used as normal identifiers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nas      derives      end      extension   infix   inline   opaque\nopen    transparent  using\n|       *            +        -\n```\n\n----------------------------------------\n\nTITLE: Debug Arg Configuration with External Library - JSON\nDESCRIPTION: Extends the launch.json 'args' for Scala debugging to include a user-defined source file and a classpath concatenated with external dependencies (e.g., cats-core), which can be collected using Coursier CLI. Requires all library jars to be present at the specified locations. Files and dependencies are passed as elements of the 'args' array; output is used by the VSCode debugger to establish classpath context for the Scala process. Limitation: All paths must be accurate and dependencies compatible.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/ide-debugging.md#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n\"args\": [\n  \"using-cats.scala\",\n  \"-classpath\",\n  \"/home/user/scala/scala3/out/bootstrap/scala3-library-bootstrapped/scala-3.3.1-RC1-bin-SNAPSHOT-nonbootstrapped/classes:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.10/scala-library-2.13.10.jar:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/typelevel/cats-core_3/2.9.0/cats-core_3-2.9.0.jar:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/typelevel/cats-kernel_3/2.9.0/cats-kernel_3-2.9.0.jar\"\n]\n```\n\n----------------------------------------\n\nTITLE: Declaring a Monomorphic Opaque Type Alias in Scala 3\nDESCRIPTION: Demonstrates the syntax for defining a monomorphic opaque type alias with optional lower (L) and upper (U) bounds and a right-hand side (R) type. The snippet shows that within the scope of definition, the alias is transparent and treated as equivalent to R, while outside it behaves as an abstract type bounded by L and U. It also notes that the type parameter T cannot appear in bounds to avoid F-bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/opaques-details.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nopaque type T >: L <: U = R\n```\n\n----------------------------------------\n\nTITLE: Defining Infix Types with infix Modifier in Scala\nDESCRIPTION: This code snippet demonstrates the declaration and use of an infix type via the 'infix' modifier in Scala 3. By marking 'type or[X, Y]' with 'infix', the custom type constructor can be applied using infix syntax, improving code readability (e.g., 'String or Int'). Dependencies: Native to Scala 3; no external dependencies needed. Inputs: Two type parameters; Outputs: A type that can be used infix-style. Limitation: Only types with two parameters can be made infix.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/operators.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ninfix type or[X, Y]\nval x: String or Int = ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Reader Monad Instance in Scala\nDESCRIPTION: Defines a generic `given` instance `readerMonad` for the `Monad` type class, parameterized by the context type `Ctx`. It uses a type lambda `[X] =>> Ctx => X` to represent the function type constructor `Ctx => ?`. This allows the Reader Monad pattern to be reused for any context type `Ctx`, not just the specific `Config` trait.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ngiven readerMonad[Ctx]: Monad[[X] =>> Ctx => X] with\n\n  def pure[A](x: A): Ctx => A =\n    ctx => x\n\n  extension [A](x: Ctx => A)\n    def flatMap[B](f: A => Ctx => B): Ctx => B =\n      ctx => f(x(ctx))(ctx)\n\nend readerMonad\n```\n\n----------------------------------------\n\nTITLE: Rewriter Macro Implementation with Quoted Pattern Matching in Scala\nDESCRIPTION: A simple, non-recursive rewriter macro for mathematical exponents that demonstrates the new quoted pattern matching feature in Scala 3. The implementation uses pattern matching on quoted expressions to apply various mathematical rules for exponents.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\ninline def rewrite(expr: => Double): Double = ${rewrite('expr)}\n\ndef rewrite(expr: Expr[Double])(given QuoteContext): Expr[Double] = {\n  val res = expr match {\n    // product rule\n    case '{ power2($a, $x) * power2($b, $y)} if a.matches(b) => '{ power2($a, $x + $y) }\n    // rules of 1\n    case '{ power2($a, 1)} => a\n    case '{ power2(1, $a)} => '{ 1.0 }\n    // rule of 0\n    case '{ power2($a, 0)} => '{ 1.0 }\n    // power rule\n    case '{ power2(power2($a, $x), $y)} => '{ power2($a, $x * $y ) }\n    case _ => expr\n  }\n  res\n}\n```\n\n----------------------------------------\n\nTITLE: Syntax of Generators in For Expressions with Case\nDESCRIPTION: This snippet specifies the syntax for generators in Scala for comprehensions, indicating that a generator can optionally be prefixed with 'case' to filter elements matching a pattern. This supports more expressive pattern matching within comprehensions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/pattern-bindings.md#_snippet_3\n\nLANGUAGE: EBNF\nCODE:\n```\nGenerator ::= [‘case’] Pattern1 ‘<-’ Expr\n```\n\n----------------------------------------\n\nTITLE: Defining Additional Methods for Scala `FunctionN` (n <= 22)\nDESCRIPTION: Shows additional methods defined for `FunctionN` traits when ´n \\leq 22´. These include `toString`, `curried` (for currying the function), and `tupled` (to accept arguments as a tuple). It also notes that `Function` is an alias for `Function1`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\ntrait Function´_n´[-´T_1´, ..., -´T_n´, +´R´]:\n  ...\n  override def toString = \"<function´_n´>\"\n  def curried: ´T_1´ => ... => ´T_n´ => R = ...\n  def tupled: ((´T_1´, ..., ´T_n´)) => R = ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Flexible Override Signatures for Java Methods in Scala - Scala\nDESCRIPTION: This set of Scala method signatures shows the various ways a Java method returning or accepting a nullable String may be overridden in Scala. It highlights Scala 3's relaxed nullability override rules when working with Java libraries, although care must be taken to avoid unsound return values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: String | Null): String | Null\n\ndef f(x: String): String | Null\n\ndef f(x: String | Null): String\n\ndef f(x: String): String\n\n```\n\n----------------------------------------\n\nTITLE: Dispatching Type-Level Operations with Match Types (Scala)\nDESCRIPTION: This snippet defines a custom infix type alias `+` that works for both `Int` and `String` singleton types. It uses a match type to delegate to the appropriate operation (`scala.compiletime.ops.int.+` or `scala.compiletime.ops.string.+`) based on the types of the operands provided at compile time.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.ops.*\n\nimport scala.annotation.infix\n\ntype +[X <: Int | String, Y <: Int | String] = (X, Y) match\n  case (Int, Int) => int.+[X, Y]\n  case (String, String) => string.+[X, Y]\n\nval concat: \"a\" + \"b\" = \"ab\"\nval addition: 1 + 1 = 2\n```\n\n----------------------------------------\n\nTITLE: Tail-Recursive Polymorphic Method Example in Scala 3\nDESCRIPTION: This Scala snippet illustrates a polymorphic tail-recursive method `loop` annotated with `@tailrec`. The method accepts a generic parameter `T` and returns an `Int`. It shows the previously existing limitation that polymorphic recursive calls changing type arguments were disallowed for optimization, producing a compile error. Dotty 0.10.0-RC1 removes this restriction, enabling optimization of such calls.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-10-10-10th-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n@tailrec def loop[T](x: T): Int = {\n  ...\n  loop[Int](1)\n}\n```\n\n----------------------------------------\n\nTITLE: Calling the Escaped Function in Scala\nDESCRIPTION: Shows how calling the escaped function can lead to unexpected exceptions at runtime, due to the capability escaping from the try block's scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/canthrow.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval g = escaped(1, 2, 1000000000)\ng()\n```\n\n----------------------------------------\n\nTITLE: Defining Type and Value Parameters Grammar in Scala 3\nDESCRIPTION: Grammar specification for type parameters and value parameters in Scala 3. This covers class type parameters, definition type parameters, type parameter clauses, higher-kinded type parameters, class parameters, and various parameter clauses.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/syntax.md#_snippet_5\n\nLANGUAGE: BNF\nCODE:\n```\nClsTypeParamClause::=  '[' ClsTypeParam {',' ClsTypeParam} ']'\nClsTypeParam      ::=  {Annotation} ['+' | '-'] id [HkTypeParamClause] TypeAndCtxBounds\n\nDefTypeParamClause::=  [nl] '[' DefTypeParam {',' DefTypeParam} ']'\nDefTypeParam      ::=  {Annotation} id [HkTypeParamClause] TypeAndCtxBounds\n\nTypTypeParamClause::=  '[' TypTypeParam {',' TypTypeParam} ']'\nTypTypeParam      ::=  {Annotation} (id | '_') [HkTypeParamClause] TypeBounds\n\nHkTypeParamClause ::=  '[' HkTypeParam {',' HkTypeParam} ']'\nHkTypeParam       ::=  {Annotation} ['+' | '-'] (id  | '_') [HkTypeParamClause] TypeBounds\n\nClsParamClauses   ::=  {ClsParamClause} [[nl] '(' ['implicit'] ClsParams ')']\nClsParamClause    ::=  [nl] '(' ClsParams ')'\n                    |  [nl] '(' 'using' (ClsParams | FunArgTypes) ')'\nClsParams         ::=  ClsParam {',' ClsParam}\nClsParam          ::=  {Annotation} [{Modifier} ('val' | 'var')] Param\n\nDefParamClauses   ::=  DefParamClause { DefParamClause } -- and two DefTypeParamClause cannot be adjacent\nDefParamClause    ::=  DefTypeParamClause\n                    |  DefTermParamClause\n                    |  UsingParamClause\nConstrParamClauses::=  ConstrParamClause {ConstrParamClause}\nConstrParamClause ::=  DefTermParamClause\n                    |  UsingParamClause\n\nDefTermParamClause::=  [nl] '(' [DefTermParams] ')'\nUsingParamClause  ::=  [nl] '(' 'using' (DefTermParams | FunArgTypes) ')'\nDefImplicitClause ::=  [nl] '(' 'implicit' DefTermParams ')'\n\nDefTermParams     ::= DefTermParam {',' DefTermParam}\nDefTermParam      ::= {Annotation} ['inline'] Param\nParam             ::=  id ':' ParamType ['=' Expr]\n```\n\n----------------------------------------\n\nTITLE: Instantiating Functor with Explicit Lambda Type in Scala\nDESCRIPTION: This code shows how to instantiate a higher-kinded type class, such as Functor, with an explicit Lambda1 type carrying a List as its type constructor. The example provides the type member assignment that adapts List into the expected Lambda form, suitable for passing to Functor. The snippet demonstrates proper type encoding for advanced type class usage in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nFunctor {\n   type F = Lambda1 { type Apply = List[$hkArg$0] }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Class Implementing Intersection Traits\nDESCRIPTION: Defines a class `C` that extends both traits `A` and `B`, each with a method `children` returning `List[A]` and `List[B]`, respectively. Implements `children` with the type `List[A & B]`. This demonstrates how a class can fulfill combined type requirements via intersection types, and how the compiler ensures member definitions meet the intersection's constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/new-types/intersection-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends A, B:\n  def children: List[A & B] = ???\n```\n\n----------------------------------------\n\nTITLE: Defining Methodic Type Syntax in Scala 3 EBNF\nDESCRIPTION: EBNF syntax for methodic types in Scala 3. Methodic types are not real types but are used as declared types for def definitions with at least one term or type parameter list.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_35\n\nLANGUAGE: EBNF\nCODE:\n```\nTypeOrMethodic    ::=  Type\n                    |  MethodicType\nMethodicType      ::=  MethodType\n                    |  PolyType\n```\n\n----------------------------------------\n\nTITLE: Defining an Explicit 'main' Method in Scala 3\nDESCRIPTION: Shows the standard way to define a main entry point in a Scala object using an explicit `main` method with the signature `def main(args: Array[String])`. This approach is necessary if command-line arguments need to be accessed, serving as a robust alternative to the limited `App` trait in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/delayed-init.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject Hello:\n  def main(args: Array[String]) =\n    println(s\"Hello, ${args(0)}\")\n```\n\n----------------------------------------\n\nTITLE: Defining an Opaque Type for Immutable Arrays in Scala\nDESCRIPTION: This snippet demonstrates the declaration of an opaque type, IArray, as a type alias for Array with a covariant type argument. The purpose is to provide an interface for immutable arrays in Scala. Required Scala 3, no external dependencies. The type encapsulation blocks mutation by restricting available methods (no 'update'), but runtime representations remain Arrays, making low-level access possible via pattern matching or type casting.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/matchable.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nopaque type IArray[+T] = Array[_ <: T]\n```\n\n----------------------------------------\n\nTITLE: Serving Local Scaladoc Output with Python HTTP Server\nDESCRIPTION: These shell commands navigate to the directory where Scaladoc output is generated and then start a simple Python HTTP server on port 8080. This allows viewing the generated documentation in a web browser, avoiding potential CORS issues when accessing files directly. Requires Python 3 to be installed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/scaladoc.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ncd scaladoc/output\n```\n\nLANGUAGE: Shell\nCODE:\n```\npython3 -m http.server 8080\n```\n\n----------------------------------------\n\nTITLE: Capture Checking of Closures in Scala\nDESCRIPTION: Illustrates that closures capture all capabilities referenced in their body, reflected in their function types. Shows a function that takes a FileSystem capability and returns a lambda capturing this capability, making the lambda's type include the capture set {fs}. Highlights that syntactically impure and pure functions both use =>, with purity distinctions visible only in type annotations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ndef test(fs: FileSystem): String ->{fs} Unit =\n  (x: String) => Logger(fs).log(x)\n```\n\n----------------------------------------\n\nTITLE: Listing Contributors using Git Shortlog\nDESCRIPTION: Displays the output of the `git shortlog -sn --no-merges 3.6.3..3.6.4-RC1` command. This command summarizes commits between the specified tags (3.6.3 and 3.6.4-RC1), showing the number of commits per contributor, excluding merge commits. It is used here to acknowledge the contributors to this specific Scala 3 release.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.6.4-RC1.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n    46  Martin Odersky\n    33  noti0na1\n    17  Wojciech Mazur\n    14  Dale Wijnand\n    13  Matt Bovel\n    11  Hamza Remmal\n     7  Jan Chyb\n     6  aherlihy\n     5  Kacper Korban\n     5  Seth Tisue\n     5  Som Snytt\n     4  Oliver Bračevac\n     4  Yichen Xu\n     3  Sébastien Doeraene\n     3  dependabot[bot]\n     3  kasiaMarek\n     2  João Ferreira\n     1  David Hua\n     1  Eugene Flesselle\n     1  Eugene Yokota\n     1  Florian3k\n     1  Jędrzej Rochala\n     1  Kenji Yoshida\n     1  Mathias\n     1  Natsu Kagami\n     1  Oleg Zenzin\n     1  Piotr Chabelski\n     1  Rui Chen\n     1  philippus\n     1  rochala\n     1  xiaoshihou\n```\n\n----------------------------------------\n\nTITLE: Calling Scala @targetName Alias from Java\nDESCRIPTION: Illustrates how a Java program can invoke the Scala extension method `++=` (defined in a previous snippet) using its `@targetName` alias `append`. This highlights the interoperability benefit of using `@targetName` for symbolic or non-standard JVM identifiers defined in Scala.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/targetName.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nVecOps.append(vec1, vec2)\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Map Function with Exception Type Parameter\nDESCRIPTION: A hypothetical signature for map that would support checked exceptions by adding an exception type parameter, but adds significant ceremony to method signatures.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/canthrow.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef map[B, E](f: A => B throws E): List[B] throws E\n```\n\n----------------------------------------\n\nTITLE: Modifying Bootstrapped Project BSP Export in sbt (diff)\nDESCRIPTION: This snippet shows how to modify the value of the 'enableBspAllProjects' setting in the sbt configuration file 'Build.scala'. Changing this flag from 'false' to 'true' ensures that all bootstrapped projects, which are necessary for certain modules like 'scaladoc', are exported to the build server used by Metals. To apply this, edit the file and restart or reload sbt as required. Prerequisites: write access to the scala3 project, working knowledge of sbt. Impact: ensures 'scala3-compiler-bootstrapped' and related modules are visible in IDEs using BSP.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/setting-up-your-ide.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n-    val enableBspAllProjects = false,\n+    val enableBspAllProjects = true,\n```\n\n----------------------------------------\n\nTITLE: Defining Scala isEmpty/get Type Structure (R) for Variadic Extractors\nDESCRIPTION: Defines the structural type `R` required for the return type `U` or a type `S` derived from it in variadic extractors that use the `isEmpty` and `get` methods to signal match success/failure and provide the extracted sequence value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntype R = {\n  def isEmpty: Boolean\n  def get: S\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Quote Syntax Grammar\nDESCRIPTION: Provides pseudo-BNF grammar rules defining the various forms of quotes available in Scala 3 macros. This includes quoted identifiers (`'ident`), quoted blocks (`'{ Block }`), quoted block patterns (`'{ Block }` in pattern context), and quoted type patterns (`'[ Type ]`). It notes the reuse of the deprecated Scala 2 `Symbol` literal syntax for quoted identifiers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_1\n\nLANGUAGE: BNF\nCODE:\n```\nSimpleExpr ::= ...\n             |  `'` alphaid                           // quoted identifier\n             |  `'` `{` Block `}`                     // quoted block\nPattern    ::= ...\n             |  `'` `{` Block `}`                     // quoted block pattern\n             |  `'` `[` Type `]`                      // quoted type pattern\n```\n\n----------------------------------------\n\nTITLE: Defining Throw Expression Syntax in EBNF for Scala 3\nDESCRIPTION: Provides the Extended Backus-Naur Form (EBNF) grammar definition for the Scala 3 `throw` expression. It requires an expression (`Expr`) following the `throw` keyword, which must evaluate to a `Throwable`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_40\n\nLANGUAGE: ebnf\nCODE:\n```\nExpr1      ::=  ‘throw’ Expr\n```\n\n----------------------------------------\n\nTITLE: Subtyping Rules for Intersection Types - Scala\nDESCRIPTION: This snippet presents formal inference rules in Scala type theory that describe subtyping relationships involving intersection types `A & B`. It establishes that a type `T` is a subtype of `A & B` if it is a subtype of both `A` and `B`, and conversely, `A & B` can be a subtype of a type `T` if either `A` or `B` is a subtype of `T`. It also demonstrates the commutativity property of intersection types, indicating `A & B` and `B & A` are subtypes of each other.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/intersection-types-spec.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nT <: A    T <: B\n----------------\n  T <: A & B\n\n    A <: T\n----------------\n    A & B <: T\n\n    B <: T\n----------------\n    A & B <: T\n```\n\nLANGUAGE: scala\nCODE:\n```\n   B <: B           A <: A\n----------       -----------\nA & B <: B       A & B <: A\n---------------------------\n       A & B  <:  B & A\n```\n\n----------------------------------------\n\nTITLE: Defining Named Type Arguments Syntax EBNF\nDESCRIPTION: Specifies the grammar rules for named type arguments in Scala 3 using Extended Backus-Naur Form (EBNF). It defines how `NamedTypeArgs` can appear after `SimpleExpr` and the structure of `NamedTypeArg` as an identifier followed by an equals sign and a type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/named-typeargs-spec.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nSimpleExpr1       ::=  ...\n                    |  SimpleExpr (TypeArgs | NamedTypeArgs)\nNamedTypeArgs     ::=  ‘[’ NamedTypeArg {‘,’ NamedTypeArg} ‘]’\nNamedTypeArg      ::=  id ‘=’ Type\n```\n\n----------------------------------------\n\nTITLE: Export Clauses in Extensions in Scala\nDESCRIPTION: Demonstrates how to use export clauses within extension methods to extend functionality of a type by composing with another class.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/export.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass StringOps(x: String):\n  def *(n: Int): String = ...\n  def capitalize: String = ...\n\nextension (x: String)\n  def take(n: Int): String = x.substring(0, n)\n  def drop(n: Int): String = x.substring(n)\n  private def moreOps = new StringOps(x)\n  export moreOps.*\n```\n\n----------------------------------------\n\nTITLE: Illustrating Unsoundness with Uninitialized Fields in Scala\nDESCRIPTION: Demonstrates a scenario where explicit nulls can be unsound. An uninitialized field (`f`) in a class starts as `null` but has a non-nullable type (`String`), leading to a `null` value at runtime despite the type declaration. This specific unsoundness can often be detected using the `-Ysafe-init` compiler flag.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass C:\n  val f: String = foo(f)\n  def foo(f2: String): String = f2\n\nval c = new C()\n// c.f is null at runtime\n```\n\n----------------------------------------\n\nTITLE: Deriving CanEqual for Generic Classes\nDESCRIPTION: Demonstrates how to derive CanEqual for a generic class Box, which generates an instance that allows comparing boxes if their element types can be compared.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nclass Box[T](x: T) derives CanEqual\n```\n\n----------------------------------------\n\nTITLE: Suppressing Initialization Checks in Scala\nDESCRIPTION: Use the `@unchecked` annotation on an expression `e` to instruct the Scala 3 initialization checker to skip verification for that specific expression. This serves as an escape hatch when the checker's warnings need to be suppressed, though using lazy fields is mentioned as an alternative.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/safe-initialization.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ne: @unchecked\n```\n\n----------------------------------------\n\nTITLE: Compiler-Generated Code for Escaped Function in Scala\nDESCRIPTION: Shows how the compiler would transform the escaped function example, explicitly showing the given CanThrow capability that gets captured in the closure, causing the potential exception leakage.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/canthrow.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n// compiler-generated code\ndef escaped(xs: Double*): () => Int =\n  try\n    given ctl: CanThrow[LimitExceeded] = ???\n    () => xs.map(x => f(x)(using ctl)).sum\n  catch case ex: LimitExceeded => -1\n```\n\n----------------------------------------\n\nTITLE: Implementing ToExpr for Option[T] using Quotes and Splices in Scala\nDESCRIPTION: Provides a `given` implementation of `ToExpr[Option[T]]`. This implementation requires `Type[T]` and `ToExpr[T]` instances (via context bounds) and uses pattern matching, quotes, and splices to generate an `Expr[Option[T]]` representing either `Some(value)` (by lifting the inner value using `Expr(x)`) or `None`. Requires a `using Quotes` context.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ngiven OptionToExpr: [T: {Type, ToExpr}] => ToExpr[Option[T]]:\n  def apply(opt: Option[T])(using Quotes): Expr[Option[T]] =\n    opt match\n      case Some(x) => '{ Some[T]( ${Expr(x)} ) }\n      case None => '{ None }\n```\n\n----------------------------------------\n\nTITLE: Using @unchecked Annotation for Pattern Bindings in Scala 3\nDESCRIPTION: Shows how to force a pattern binding even when the pattern is not irrefutable by using the @unchecked annotation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-05-23-15th-dotty-milestone-release.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval xs: List[Any] = List(\"1\", \"2\", \"3\")\nval (x: String) :: _: @unchecked = xs\n```\n\n----------------------------------------\n\nTITLE: Inferring List Type with Variables and Mixed Numerics in Scala\nDESCRIPTION: This Scala code snippet shows variable declarations of Int, Char, and Double, followed by creation of a list mixing these types. In versions of Scala with weak conformance, the resulting list was typed as List[Double], whereas in Scala 3 it is typed as List[AnyVal]. Variables 'n', 'c', and 'd' represent different value types; this snippet depends on the standard Scala library. The example demonstrates the effect of dropping weak conformance in Scala's type inference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/weak-conformance.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval n: Int = 3\nval c: Char = 'X'\nval d: Double = math.sqrt(3.0)\nList(n, c, d) // used to be: List[Double], now: List[AnyVal]\n```\n\n----------------------------------------\n\nTITLE: Conditionally Summoning Givens using summonFrom (Explicit using) (Scala)\nDESCRIPTION: This snippet defines an inline function `setFor[T]` that uses `scala.compiletime.summonFrom` to conditionally create a `TreeSet` if an `Ordering[T]` can be summoned at compile time, otherwise it creates a `HashSet`. It explicitly binds the summoned `Ordering` to `ord` and uses it in the `using` clause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.summonFrom\nimport scala.collection.immutable.{HashSet, TreeSet}\n\ninline def setFor[T]: Set[T] = summonFrom {\n  case ord: Ordering[T] => new TreeSet[T]()(using ord)\n  case _                => new HashSet[T]\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Shadowing and Import Precedence in Scala 3\nDESCRIPTION: This Scala snippet illustrates how a local definition, an explicit import, and binding precedence interact. It shows a situation where a reference to 'x' inside a block is ambiguous due to shadowing rules and import precedence. The snippet requires no additional dependencies and assumes standard Scala 3 syntax and semantics.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/02-identifiers-names-and-scopes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval x = 1\nlocally {\n  import p.X.x\n  x\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Nullability of Mutable Variables with Flow Typing in Scala\nDESCRIPTION: This snippet demonstrates Scala 3's ability to track the nullability of a local mutable variable using flow typing when all assignments occur within a single method scope. The variable 'xs' of type 'C | Null' is tracked so that its refined type is known after null checks and assignments. Dependencies include class definition for 'C' and understanding of union types ('|'). Inputs include instances of class C, and the output is type-safe access to 'C' methods when 'xs' is non-null. Limitations: Path-dependent mutable variables like 'x.a' are not tracked.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(val x: Int, val next: C | Null)\n\nvar xs: C | Null = C(1, C(2, null))\n// xs is trackable, since all assignments are in the same method\nwhile xs != null do\n  // xs: C\n  val xsx: Int = xs.x\n  val xscpy: C = xs\n  xs = xscpy // since xscpy is non-null, xs still has type C after this line\n  // xs: C\n  xs = xs.next // after this assignment, xs can be null again\n  // xs: C | Null\n```\n\n----------------------------------------\n\nTITLE: Applying a Polymorphic Function to Transform Expressions in Scala\nDESCRIPTION: Demonstrates the usage of `mapSubexpressions`. An initial expression `e0` is defined. Then, `mapSubexpressions` is called with `e0` and a polymorphic lambda function. This lambda takes a type `B` and an expression `se` of type `Expr[B]`, returning a new `Apply` expression that wraps `se` with a call to a `Var` named \"wrap\".\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/polymorphic-function-types.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval e0 = Apply(Var(\"f\"), Var(\"a\"))\nval e1 = mapSubexpressions(e0)(\n  [B] => (se: Expr[B]) => Apply(Var[B => B](\"wrap\"), se))\nprintln(e1) // Apply(Apply(Var(wrap),Var(f)),Apply(Var(wrap),Var(a)))\n```\n\n----------------------------------------\n\nTITLE: Rules for Overriding Inline Methods\nDESCRIPTION: This code illustrates that inline methods can override non-inline methods and also can be abstract. Inline methods are implicitly final and their invocation is replaced with code at compile time, supporting both static and dynamic dispatch when appropriate.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class A:\n  def f: Int\n  def g: Int = f\n\nclass B extends A:\n  inline def f = 22\n  override inline def g = f + 11\n```\n\n----------------------------------------\n\nTITLE: Unsafe Variable Initialization with Exception Teleport in Scala\nDESCRIPTION: This Scala snippet illustrates a complex initialization problem involving exceptions thrown during object construction, which can 'teleport' uninitialized values and break soundness guarantees. The example shows classes `MyException`, `A`, and `B` where the constructor of `A` catches an exception thrown by `B` referencing an uninitialized value. This code demonstrates how control effects can violate the standard stackability principle of initialization, and the checker relies on ensuring that thrown values are transitively initialized. Dependencies include Scala 3 language features and exception handling.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/safe-initialization.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass MyException(val b: B) extends Exception(\"\")\nclass A:\n  val b = try { new B } catch { case myEx: MyException => myEx.b }\n  println(b.a)\n\nclass B:\n  throw new MyException(this)\n  val a: Int = 1\n```\n\n----------------------------------------\n\nTITLE: Building Scala3 Local Distribution with SBT\nDESCRIPTION: Command to build a local distribution of Scala3 using SBT, with instructions on where to find the built distribution packages.\nSOURCE: https://github.com/scala/scala3/blob/main/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsbt dist/Universal/packageBin\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Scala Code Using Dotty Scripts - Shell\nDESCRIPTION: Shows commands to compile and run a Scala source file using the Dotty compiler scripts, scalac and scala, which may be slower due to rebuilding distribution packages on changes. It assumes the PATH is set as previously shown.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/getting-started.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n# Compile code using Dotty\n$ scalac tests/pos/HelloWorld.scala\n\n# Run it with the proper classpath\n$ scala HelloWorld\n```\n\n----------------------------------------\n\nTITLE: Correctly Extending Multiple Traits with Trait Parameters in Scala\nDESCRIPTION: This snippet demonstrates the correct way to extend both the parent (`Greeting`) and the derived trait (`FormalGreeting`) in a class (`E`), ensuring all necessary trait parameters are provided. Dependencies: both `Greeting` and `FormalGreeting` from previous examples. Parameters: name provided to `Greeting`. Input/Output: class can be instantiated and used. Limitation: trait parameter rules and order of inheritance must be respected.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/trait-parameters.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass E extends Greeting(\"Bob\"), FormalGreeting\n```\n\n----------------------------------------\n\nTITLE: Abstract Variable Definition Equivalence in Scala\nDESCRIPTION: Explains that an abstract variable definition `var x: T` in Scala is conceptually equivalent to defining an abstract getter method `def x: T` and an abstract setter method `def x_= (y: T): Unit`. Implementations can provide a concrete `var` or implement these getter/setter methods directly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef ´x´: ´T´\ndef ´x´_= (´y´: ´T´): Unit\n```\n\n----------------------------------------\n\nTITLE: Signatures for Selectable applyDynamic Method\nDESCRIPTION: This snippet shows the two possible signatures for the `applyDynamic` method used by `Selectable` implementations. This method is invoked for structural selections that involve method calls. Both versions take the method name and arguments; the second version additionally takes `java.lang.Class` objects representing parameter types, useful for reflection-based implementations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types-spec.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef applyDynamic(name: String)(args: Any*): T\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef applyDynamic(name: String, ctags: Class[?]*)(args: Any*): T\n```\n\n----------------------------------------\n\nTITLE: Examples of Value Definitions in Scala\nDESCRIPTION: Provides concrete examples of different kinds of `val` definitions in Scala. It includes an abstract value definition (`foo`), simple concrete definitions with inferred (`pi`) and explicit (`pi: Double`) types, a pattern definition extracting a value from `Some`, and an infix pattern definition destructuring a list.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval foo: Int              // abstract value definition\nval pi = 3.1415\nval pi: Double = 3.1415   // equivalent to first definition\nval Some(x) = f()         // a pattern definition\nval x :: xs = mylist      // an infix pattern definition\n```\n\n----------------------------------------\n\nTITLE: Stripping Margin from Multi-Line String in Scala\nDESCRIPTION: Shows how to use the stripMargin method from scala.collection.StringOps to remove leading whitespace up to a specified margin character (defaulting to '|') from each line of a multi-line string literal. This is useful for formatting source code while maintaining readable output strings.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\n\"\"\"the present string\n  |spans three\n  |lines.\"\"\".stripMargin\n```\n\n----------------------------------------\n\nTITLE: Exception Wrapping Workaround\nDESCRIPTION: A workaround for Java's checked exception limitations using exception wrapping and unwrapping, which is cumbersome and error-prone.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/canthrow.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntry\n  xs.map(x => if x < limit then x * x else throw Wrapper(LimitExceeded()))\ncatch case Wrapper(ex) => throw ex\n```\n\n----------------------------------------\n\nTITLE: Debugging the Scala 3 Compiler with Custom Args - JSON\nDESCRIPTION: Configures VSCode launch.json to debug the Scala 3 compiler's main entry point, dotty.tools.dotc.Main, with precise arguments and dependencies. Prerequisites include having the scala-library_2.13 and a bootstrapped scala3-library_3 on the classpath, which can be located using sbt's export command. Key parameters include 'mainClass' set to the compiler main, and 'args' specifying the target Scala file, classpath, and optional color settings. Inputs are handled in the 'args' array; output is an interactive debug session. Check classpath paths and dependency versions for accuracy.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/ide-debugging.md#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"type\": \"scala\",\n  \"request\": \"launch\",\n  \"name\": \"Debug Scala 3 Compiler\",\n  \"mainClass\": \"dotty.tools.dotc.Main\",\n  \"args\": [\n    \"../tests/pos/HelloWorld.scala\",\n    \"-classpath\",\n    \"/home/user/scala/scala3/out/bootstrap/scala3-library-bootstrapped/scala-3.3.1-RC1-bin-SNAPSHOT-nonbootstrapped/classes:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.10/scala-library-2.13.10.jar\",\n    \"-color\",\n    \"never\"\n  ],\n  \"jvmOptions\": [],\n  \"env\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed-Arity Product Extractor for Tupling in Scala\nDESCRIPTION: Demonstrates creation of a product extractor by subclassing Product and providing _1 and _2 accessors for use in tuple-style pattern decomposition. Object `FirstChars` supplies an unapply returning a new instance for use in matching. Requires familiarity with Scala class/trait inheritance and unapply mechanisms. Input is a string; exposes its first two characters as matching variables. Limitations: extractor expects strings of at least two characters, and the remaining Product methods are unimplemented placeholders.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/pattern-matching.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass FirstChars(s: String) extends Product:\n  def _1 = s.charAt(0)\n  def _2 = s.charAt(1)\n\n   // Not used by pattern matching: Product is only used as a marker trait.\n  def canEqual(that: Any): Boolean = ???\n  def productArity: Int = ???\n  def productElement(n: Int): Any = ???\n\nobject FirstChars:\n  def unapply(s: String): FirstChars = new FirstChars(s)\n\n\"Hi!\" match\n  case FirstChars(char1, char2) =>\n    println(s\"First: $char1; Second: $char2\")\n\n// First: H; Second: i\n```\n\n----------------------------------------\n\nTITLE: Capture Checking Error from Conflicting 'this' Constraints\nDESCRIPTION: Demonstrates a capture checking error. The assignment `val x: A = this` implies `this` must be pure (capture set `{}`), but the method `f` references an external capability `c`, implying `this` must capture `c`. This contradiction leads to a compiler error.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\n@capability class Cap\ndef test(c: Cap) =\n  class A:\n    val x: A = this\n    def f = println(c)  // error\n```\n\nLANGUAGE: text\nCODE:\n```\n16 |    def f = println(c)  // error\n   |                    ^\n   |(c : Cap) cannot be referenced here; it is not included in the allowed capture set {}\n```\n\n----------------------------------------\n\nTITLE: Translate Anonymous Function - Scala\nDESCRIPTION: This Scala snippet illustrates the standard translation of an anonymous function (x_1: T_1, ..., x_n: T_n) => e into an object instance. It shows that the function is effectively compiled into a new instance of the scala.FunctionN trait, implementing the apply method with the defined parameters and body expression e.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_44\n\nLANGUAGE: scala\nCODE:\n```\nnew scala.Function´n´[´T_1, ..., T_n´, ´T´] {\n  def apply(´x_1´: ´T_1´, ..., x_n´: ´T_n´): ´T´ = ´e´\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting Structural Type Members via selectDynamic in Scala\nDESCRIPTION: This snippet demonstrates the underlying method calls performed by the Scala compiler when accessing fields of a structural type. Instead of direct field access, it calls selectDynamic on the structural type instance and casts the result to the expected type. This requires the instance to be a subtype of Selectable. The inputs are structural type instances and field names as strings; outputs are field values with proper type casting.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nperson.selectDynamic(\"name\").asInstanceOf[String]\nperson.selectDynamic(\"age\").asInstanceOf[Int]\n```\n\n----------------------------------------\n\nTITLE: Syntax Definition for Type Patterns (EBNF)\nDESCRIPTION: Defines the EBNF syntax for type patterns, indicating that a type pattern consists simply of a `Type` specification.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_20\n\nLANGUAGE: ebnf\nCODE:\n```\n  TypePat           ::=  Type\n```\n\n----------------------------------------\n\nTITLE: Scala Literal Examples: Integer, Floating Point, Character, and String Literals\nDESCRIPTION: This snippet provides example literal values for integer, floating point, character, and string literals in Scala, illustrating valid formats, use of underscores as digit separators, escape sequences, and type suffixes where applicable.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\n0           21_000      0x7F        -42L        0xFFFF_FFFF        0b0100_0010\n```\n\nLANGUAGE: Scala\nCODE:\n```\n0.0        1e30f      3.14159f      1.0e-100      .1\n```\n\nLANGUAGE: Scala\nCODE:\n```\n'a'    '\\u0041'    '\\n'    '\\t'\n```\n\nLANGUAGE: Scala\nCODE:\n```\n\"Hello, world!\\n\"\n\"\\\"Hello,\\\" replied the world.\"\n```\n\n----------------------------------------\n\nTITLE: Examples of Scala Variable Identifiers\nDESCRIPTION: Provides a list of valid identifiers in Scala that are classified as \"variable identifiers\" according to the pattern matching rules, typically starting with a lowercase letter or an underscore.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n    x         maxIndex   p2p   empty_?\n    `yield`   αρετη      _y    dot_product_*\n    __system  _MAX_LEN_\n    ªpple     ʰelper\n```\n\n----------------------------------------\n\nTITLE: Scala Source: Examples Illustrating Newline Token Behavior in Code\nDESCRIPTION: This collection of Scala code examples demonstrates how newline tokens affect code interpretation, including statement termination and expression continuation. Examples cover conditional expressions, while loops, for comprehensions, abstract method definitions, attributes, and operator line breaks, highlighting consequences of additional newlines on parsing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nif (x > 0)\n  x = x - 1\n\nwhile (x > 0)\n  x = x / 2\n\nfor (x <- 1 to 10)\n  println(x)\n\ntype\n  IntList = List[Int]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nnew Iterator[Int]\n{\n  private var x = 0\n  def hasNext = true\n  def next = { x += 1; x }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nnew Iterator[Int]\n\n{\n  private var x = 0\n  def hasNext = true\n  def next = { x += 1; x }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n  x < 0 ||\n  x > 10\n```\n\nLANGUAGE: Scala\nCODE:\n```\n  x < 0 ||\n\n  x > 10\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef func(x: Int)\n        (y: Int) = x + y\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef func(x: Int)\n\n        (y: Int) = x + y\n```\n\nLANGUAGE: Scala\nCODE:\n```\n@serializable\nprotected class Data { ... }\n```\n\nLANGUAGE: Scala\nCODE:\n```\n@serializable\n\nprotected class Data { ... }\n```\n\n----------------------------------------\n\nTITLE: Implementing Scala Eq Derivation for Sum Types\nDESCRIPTION: Defines the `eqSum` function in Scala, which constructs an `Eq` instance for sum types (like enums or sealed traits). It implements the `eqv` method by first checking if the two values are of the same subtype using `s.ordinal`, and if so, comparing them using the appropriate element `Eq` instance retrieved from the `elems` list via the helper `check`. Requires a `Mirror.SumOf[T]` and a lazy list of element instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.deriving.Mirror\n\ndef eqSum[T](s: Mirror.SumOf[T], elems: => List[Eq[?]]): Eq[T] = \n  new Eq[T]:\n    def eqv(x: T, y: T): Boolean =\n      val ordx = s.ordinal(x)                            // (3)\n      (s.ordinal(y) == ordx) && check(x, y, elems(ordx)) // (4)\n```\n\n----------------------------------------\n\nTITLE: Compiler-Generated Mirror Instances for Sum and Product Types in Scala\nDESCRIPTION: Demonstrates how the Scala 3 compiler automatically generates Mirror instances for an algebraic data type (Tree) and its components (Branch and Leaf). The Sum and Product subtypes of Mirror provide type members reflecting type and field structure, as well as methods for case item construction or ordinal calculation. These mirrors enable downstream generic or derived implementations to introspect type structure at compile time.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n// Mirror for Tree\nnew Mirror.Sum:\n  type MirroredType = Tree\n  type MirroredElemTypes[T] = (Branch[T], Leaf[T])\n  type MirroredMonoType = Tree[_]\n  type MirroredLabel = \"Tree\"\n  type MirroredElemLabels = (\"Branch\", \"Leaf\")\n\n  def ordinal(x: MirroredMonoType): Int = x match\n    case _: Branch[_] => 0\n    case _: Leaf[_] => 1\n\n// Mirror for Branch\nnew Mirror.Product:\n  type MirroredType = Branch\n  type MirroredElemTypes[T] = (Tree[T], Tree[T])\n  type MirroredMonoType = Branch[_]\n  type MirroredLabel = \"Branch\"\n  type MirroredElemLabels = (\"left\", \"right\")\n\n  def fromProduct(p: Product): MirroredMonoType =\n    new Branch(...)\n\n// Mirror for Leaf\nnew Mirror.Product:\n  type MirroredType = Leaf\n  type MirroredElemTypes[T] = Tuple1[T]\n  type MirroredMonoType = Leaf[_]\n  type MirroredLabel = \"Leaf\"\n  type MirroredElemLabels = Tuple1[\"elem\"]\n\n  def fromProduct(p: Product): MirroredMonoType =\n    new Leaf(...)\n```\n\n----------------------------------------\n\nTITLE: Expanded Form of Dependent Function Types in Scala 3\nDESCRIPTION: The desugared representation of a dependent function type, showing how it's implemented as a refinement of the Function1 trait with a refined apply method that captures the dependency.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/dependent-function-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nFunction1[Entry, Entry#Key]:\n  def apply(e: Entry): e.Key\n```\n\n----------------------------------------\n\nTITLE: Translating Multi-Generator For Comprehension (yield) in Scala 3\nDESCRIPTION: Illustrates the recursive translation rule for a Scala 3 `for` comprehension with multiple enumerators starting with two generators (`for (p <- e; p' <- e'; ...) yield e''`). The first generator is translated into a `flatMap` call on the source expression `e`, recursively processing the remaining enumerators.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nfor (´p´ <- ´e´; ´p'´ <- ´e'; ...´) yield ´e''´\n\n// is translated to\n\n´e´.flatMap { case ´p´ => for (´p'´ <- ´e'; ...´) yield ´e''´ }\n```\n\n----------------------------------------\n\nTITLE: PartialFunction Creation for Pattern Matching Anonymous Functions\nDESCRIPTION: Shows how a pattern matching anonymous function is desugared into an instance creation expression of PartialFunction when the expected type is PartialFunction, including both apply and isDefinedAt methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nnew scala.PartialFunction[´S´, ´T´] {\n  def apply(´x´: ´S´): ´T´ = x match {\n    case ´p_1´ => ´b_1´ ... case ´p_n´ => ´b_n´\n  }\n  def isDefinedAt(´x´: ´S´): Boolean = {\n    case ´p_1´ => true ... case ´p_n´ => true\n    case _ => false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining General Scala Extractor Signatures\nDESCRIPTION: Shows the core method signatures required for defining extractors in Scala 3. Extractors can implement either `unapply` for fixed-arity matching or `unapplySeq` for variadic matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef unapply[A](x: T)(implicit x: B): U\ndef unapplySeq[A](x: T)(implicit x: B): U\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Methods with @targetName in Scala\nDESCRIPTION: This Scala snippet demonstrates how to use the @targetName annotation to assign an alternative implementation name (here 'append') to a symbolic extension method (here '++=') defined for a generic Vec type inside an object. It requires importing scala.annotation.targetName and applies to all kinds of method-like definitions except top-level classes, traits, or objects. The method takes another Vec parameter and returns a new Vec; its external name in generated code becomes 'append', facilitating cross-language invocation while retaining the symbolic name for Scala usage.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/targetName.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.targetName\n\nobject VecOps:\n  extension [T](xs: Vec[T])\n    @targetName(\"append\")\n    def ++= [T] (ys: Vec[T]): Vec[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Product-Sequence Extractor for Pattern Matching Repeated Arguments in Scala\nDESCRIPTION: Demonstrates advanced variadic extractor combining product and sequence style decompositions via unapplySeq returning Option[(String, Seq[Int])]. Used to match objects with a fixed attribute and an arbitrary number of repeated integer fields. Dependencies are a case class or class with repeated parameters, a companion exposing unapplySeq, and a pattern match expression. Expected input is a Foo instance; pattern-matches against its 'name' and multiple 'children'. Limitation: assumes correct arity in unapplySeq tuple result.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/pattern-matching.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass Foo(val name: String, val children: Int*)\nobject Foo:\n  def unapplySeq(f: Foo): Option[(String, Seq[Int])] =\n    Some((f.name, f.children))\n\ndef foo(f: Foo) = f match\n  case Foo(name, x, y, ns*) => \">= two children.\"\n  case Foo(name, ns*)       => \"< two children.\"\n```\n\n----------------------------------------\n\nTITLE: Mapping Tuples with Placeholder Syntax and Untupling in Scala\nDESCRIPTION: This snippet demonstrates the shortest form using parameter untupling combined with placeholder syntax. The '_ + _' is automatically expanded to '(x, y) => x + y' thanks to parameter untupling when the expected type is a function receiving a tuple.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling-spec.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nxs.map(_ + _)\n```\n\n----------------------------------------\n\nTITLE: Running All Community Build Tests with sbt (Shell)\nDESCRIPTION: Executes all defined tests within the `community-build` sbt project. This command should be run from the root of the dotty repository after initializing Git submodules (`git submodule update --init`). It triggers the building and testing of all configured open-source projects.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/community-build.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nsbt community-build/test\n```\n\n----------------------------------------\n\nTITLE: Summary of Named Given Clause Forms Scala 3\nDESCRIPTION: Presents a summary of common forms for defining *named* given clauses in Scala 3. This mirrors the anonymous forms but shows the syntax for adding an identifier (like `intOrd` or `listOrd`) to the given definition, covering structural givens, parameterized givens, simple and parameterized aliases, deferred/abstract givens, and by-name givens.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/more-givens.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n  // Simple typeclass\n  given intOrd: Ord[Int]:\n    def compare(x: Int, y: Int) = ...\n\n  // Parameterized typeclass with context bound\n  given listOrd: [A: Ord] => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with context parameter\n  given listOrd: [A] => Ord[A] => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with named context parameter\n  given listOrd: [A] => (ord: Ord[A]) => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Simple alias\n  given intOrd: Ord[Int] = IntOrd()\n\n  // Parameterized alias with context bound\n  given listOrd: [A: Ord] => Ord[List[A]] =\n    ListOrd[A]\n\n  // Parameterized alias with context parameter\n  given listOrd: [A] => Ord[A] => Ord[List[A]] =\n    ListOrd[A]\n\n  // Abstract or deferred given\n  given context: Context = deferred\n\n  // By-name given\n  given context: () => Context = curCtx\n```\n\n----------------------------------------\n\nTITLE: Fixing Covariance Issues with Lower Bounds\nDESCRIPTION: Example showing how to fix variance issues by using lower bounds to generalize method parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Sequence[+A] {\n  def append[B >: A](x: Sequence[B]): Sequence[B]\n}\n```\n\n----------------------------------------\n\nTITLE: Anonymous Class Without Selectable Results in Typing Error in Scala\nDESCRIPTION: This snippet demonstrates that if an anonymous class does not extend Selectable (trait Vehicle defines wheels but is not a subtype of Selectable), then the instantiated object i3 cannot access extra fields, such as range, via dot notation. Accessing i3.range results in a type error, indicating the lack of structural selection support. The code illustrates the limitation and the need for Selectable to enable such patterns.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Vehicle:\n  val wheels: Int\n\nval i3 = new Vehicle: // i3: Vehicle\n  val wheels = 4\n  val range = 240\n\ni3.range // error: range is not a member of `Vehicle`\n```\n\n----------------------------------------\n\nTITLE: Defining the 'NameBased' Extractor Type Class (Scala)\nDESCRIPTION: Defines a Scala class `NameBased` designed to be used as an extractor type. It satisfies the requirements by providing `isEmpty` (returning false), `get` (returning itself), and member access methods `_1` and `_2`. This allows it to be returned by an `unapply` method for multi-value extraction.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nclass NameBased[A, B](a: A, b: B) {\n  def isEmpty = false\n  def get = this\n  def _1 = a\n  def _2 = b\n}\n```\n\n----------------------------------------\n\nTITLE: Grouping Compiler Phases in Scala 3 Compiler using the Compiler Class (Scala)\nDESCRIPTION: Defines a method in the Compiler class returning a list of phase groups, where each group is a list of phases. The phases are grouped via list concatenation of frontendPhases, picklerPhases, transformPhases, and backendPhases. This modular grouping organizes the compiler's phases for improved performance via fusion and represents a hierarchical structuring of compilation steps. The method returns a List of List of Phase objects, encapsulating the modular phase groups.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/architecture/phases.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef phases: List[List[Phase]] =\n  frontendPhases ::: picklerPhases ::: transformPhases ::: backendPhases\n```\n\n----------------------------------------\n\nTITLE: Importing Class Context Parameters in Scala\nDESCRIPTION: Shows how to properly import context parameters from a class instance using different import styles.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval b = GivenIntBox(using 23)\n// Works:\nimport b.given\nsummon[Int]  // 23\nusingParameter  // 23\n\n// Fails:\nimport b.*\nsummon[Int]      // No given instance found\nusingParameter   // Not found\n```\n\n----------------------------------------\n\nTITLE: Typed Expression Syntax in Scala3 - EBNF\nDESCRIPTION: Defines the syntax for typed expressions in Scala3, where an expression is followed by ':' and a compound type, denoting that the expression has the specified type. The expression's type is expected to conform to the provided type, and the expression's evaluation result is converted accordingly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_21\n\nLANGUAGE: ebnf\nCODE:\n```\nExpr1              ::=  PostfixExpr ‘:’ CompoundType\n```\n\n----------------------------------------\n\nTITLE: Implementing Eq Type Class Derivation Macro Body in Scala\nDESCRIPTION: Provides the core implementation logic for the `Eq.derived` macro for product types using Scala 3 quotes. It summons a `Mirror` for type `T`, pattern matches to extract element types (`elementTypes`), summons `Eq` instances for elements using `summonAll`, and generates quoted code that compares product elements field by field.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation-macro.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ngiven derived[T: Type](using Quotes): Expr[Eq[T]] = \n  import quotes.reflect.*\n\n  val ev: Expr[Mirror.Of[T]] = Expr.summon[Mirror.Of[T]].get\n\n  ev match\n    case '{ $m: Mirror.ProductOf[T] { type MirroredElemTypes = elementTypes }} =>\n      val elemInstances = summonAll[elementTypes]\n      def eqProductBody(x: Expr[Product], y: Expr[Product])(using Quotes): Expr[Boolean] = {\n        elemInstances.zipWithIndex.foldLeft(Expr(true)) {\n          case (acc, ('{ $elem: Eq[t] }, index)) =>\n            val indexExpr = Expr(index)\n            val e1 = '{ $x.productElement($indexExpr).asInstanceOf[t] }\n            val e2 = '{ $y.productElement($indexExpr).asInstanceOf[t] }\n            '{ $acc && $elem.eqv($e1, $e2) }\n         }\n      }\n      '{ eqProduct((x: T, y: T) => ${eqProductBody('x.asExprOf[Product], 'y.asExprOf[Product])}) }\n\n  // case for Mirror.ProductOf[T]\n  // ...\n```\n\n----------------------------------------\n\nTITLE: Comparing Structural Types with scala.Dynamic\nDESCRIPTION: This snippet explains the conceptual differences between Scala's 'Structural Types' and 'scala.Dynamic', highlighting that structural types are type-safe for member selection provided the underlying value matches the type, whereas 'Dynamic' allows fully runtime, untyped member access. It also discusses shared mechanisms like 'selectDynamic' and 'applyDynamic'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Indented Expression Sequence in Scala 3 If-Then-Else with Operators\nDESCRIPTION: This snippet demonstrates how a block of additions is grouped under a single 'then', leveraging Scala 3's indentation and optional braces so that the additions are parsed as part of the 'then' clause. It is useful for understanding how significant indentation groups constructs in control flow. The snippet is standalone and requires no dependencies.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nif x then\n    a\n  + b\n  + c\nelse d\n```\n\n----------------------------------------\n\nTITLE: Using Negated Givens with NotGiven Scala 3\nDESCRIPTION: Demonstrates how to use `scala.util.NotGiven[Q]` to define a given that is active only if an implicit search for type `Q` fails. The example defines two givens for `Foo[A]`: one requiring `Tagged[A]` and one requiring `NotGiven[Tagged[A]]`, showing how summoning `Foo[Int]` (when `Tagged[Int]` is given) and `Foo[String]` (when `Tagged[String]` is not given) resolves to different instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/more-givens.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.NotGiven\n\ntrait Tagged[A]\n\ncase class Foo[A](value: Boolean)\nobject Foo:\n  given fooTagged: [A] => Tagged[A] => Foo[A] = Foo(true)\n  given fooNotTagged: [A] => NotGiven[Tagged[A]] => Foo[A] = Foo(false)\n\n@main def test(): Unit =\n  given Tagged[Int]()\n  assert(summon[Foo[Int]].value) // fooTagged is found\n  assert(!summon[Foo[String]].value) // fooNotTagged is found)\n```\n\n----------------------------------------\n\nTITLE: Type-Level Bitwise Operations in Scala 3 with Compile-Time Enforcement\nDESCRIPTION: This snippet shows the extension of Scala 3's compile-time support for integer operations by including bitwise operations. It defines constants with shift operations, illustrating how the compiler enforces correct values at compile time. Introducing `scala.compiletime.ops.int._` as a dependency, it highlights compile-time validation for bitwise expressions and their results.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-03-18-23rd-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.compiletime.ops.int._\n\n@main def Test =\n  val t1: 1 << 1 = 2\n  val t2: 1 << 2 = 4\n  val t3: 1 << 3 = 8\n  val t4: 1 << 4 = 0  // error\n```\n\n----------------------------------------\n\nTITLE: Modern XML String Interpolation with dotty.xml.interpolator in Scala\nDESCRIPTION: This snippet demonstrates the recommended approach for XML construction in Scala 3 using the dotty.xml.interpolator library. It builds on the same setup as the legacy example but replaces XML literals with the xml string interpolation syntax. Requires the dotty.xml.interpolator dependency. Inputs are the same tuples representing sender, receiver, title, and body, outputting XML nodes via string interpolation. This method is future-proof and aligns with modern Scala 3 language changes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/dropped-features/xml.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport dotty.xml.interpolator.*\n\ncase class Person(name: String) { override def toString = name }\n\n@main def test: Unit =\n  val bill = Person(\"Bill\")\n  val john = Person(\"John\")\n  val mike = Person(\"Mike\")\n  val todoList = List(\n    (bill, john, \"Meeting\", \"Room 203, 11:00am\"),\n    (john, mike, \"Holiday\", \"March 22-24\")\n  )\n  // XML string interpolation\n  val mails2 = for (from, to, heading, body) <- todoList yield xml\"\"\"\n    <message>\n      <from>${from}</from><to>${to}</to>\n      <heading>${heading}</heading><body>${body}</body>\n    </message>\"\"\"\n  println(mails2)\n```\n\n----------------------------------------\n\nTITLE: Fetching External Scala Dependencies via Coursier CLI - Shell\nDESCRIPTION: Demonstrates the usage of the Coursier command line tool to fetch an external Scala library (e.g., cats-core) and produce a classpath string, excluding certain default libraries. Required dependencies: Coursier CLI installed, Internet access, and appropriate group/artifact/version information. The output is a classpath string suitable for use in launch.json. Ensure compatible Scala versions and exclude overlapping libraries for best results.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/ide-debugging.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ cs fetch org.typelevel::cats-core:2.+ --classpath --scala-version 3 --exclude org.scala-lang:scala-library --exclude org.scala-lang:scala3-library\n/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/typelevel/cats-core_3/2.9.0/cats-core_3-2.9.0.jar:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/typelevel/cats-kernel_3/2.9.0/cats-kernel_3-2.9.0.jar\n```\n\n----------------------------------------\n\nTITLE: Irrefutable Pattern Matching in Tuple Destructuring - Scala\nDESCRIPTION: This snippet illustrates a standard, irrefutable pattern where a tuple is assigned to (x, y), showing a simple pattern binding that succeeds in both Scala 2 and Scala 3. No special dependencies are required; both variables will be correctly typed to match the tuple elements on the right-hand side.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-bindings.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval pair = (1, true)\nval (x, y) = pair\n```\n\n----------------------------------------\n\nTITLE: Resolving Most Deeply Nested Implicit in Scala\nDESCRIPTION: This example illustrates how implicit resolution now prioritizes the most deeply nested applicable implicit in Scala 3, where a method's inner implicit parameter will be chosen over an outer one. No external dependencies are required other than the definition of type C. The main parameter is the implicit of type C passed to both f and g, and the result is that implicitly[C] resolves to the inner implicit, aligning with the new scoping rules and eliminating prior ambiguity.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/implicit-resolution.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(implicit i: C) = {\n  def g(implicit j: C) = {\n    implicitly[C]\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Declaring a Transparent Trait in Scala 3\nDESCRIPTION: This concise snippet shows how to declare an existing trait as transparent using the transparent modifier. It affects subsequent type inference for any member or value using this trait as a supertype. The snippet is standalone and has no parameters; it demonstrates the declaration syntax only. Requires Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/transparent-traits.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntransparent trait Kind\n```\n\n----------------------------------------\n\nTITLE: Typechecking with Revised VAR Rule and Reach Capabilities in Scala 3\nDESCRIPTION: Shows an example where a mutable variable `cur` holds a list of functions annotated with the reach capability `xs*`, enabling the loop to typecheck. The example also demonstrates how substituting functions with capabilities reachable from another variable `f` is prohibited when those capabilities are unrelated, enforcing subcapturing constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef runAll(xs: List[Proc]): Unit =\n  var cur: List[() ->{xs*} Unit] = xs  // OK, by revised VAR\n  while cur.nonEmpty do\n    val next: () ->{xs*} Unit = cur.head\n    next()\n    cur = cur.tail: List[() ->{xs*} Unit]\n\n  usingFile: f =>\n    cur = (() => f.write(): () ->{f*} Unit) :: Nil // error since {f*} !<: {xs*}\n```\n\n----------------------------------------\n\nTITLE: Declaring Uninitialized Field (New uninitialized) - Scala\nDESCRIPTION: This snippet demonstrates the new, recommended way to declare an uninitialized variable in Scala 3. It utilizes the `uninitialized` value from the `scala.compiletime` package, requiring an explicit import.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/wildcard-init.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.uninitialized\n\nvar x: A = uninitialized\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Nullable Reference Types in Scala 3\nDESCRIPTION: This example shows how the explicit nulls feature prevents assigning null to a reference type. With explicit nulls enabled, reference types like String are non-nullable by default.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval x: String = null // error: found `Null`, but required `String`\n```\n\n----------------------------------------\n\nTITLE: Declaring ContextFunctionN Trait - Scala - Scala\nDESCRIPTION: This code defines the ContextFunctionN trait used as a base for representing context function types in Scala 3. The trait uses type parameters to generically support N-ary functions and declares an apply method that takes context (using) parameters, allowing for dependency injection and contextual abstraction. No explicit dependencies are needed beyond the Scala standard library; key input types are T1...TN (argument types) and R (result type), with flexibility for N >= 1. Context functions erase to normal function types and these classes are not instantiated at runtime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/context-functions-spec.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\ntrait ContextFunctionN[-T1, ..., -TN, +R]:\n  def apply(using x1: T1, ..., xN: TN): R\n```\n\n----------------------------------------\n\nTITLE: Defining List Contains with Universal Equality in Scala\nDESCRIPTION: This snippet shows an older definition of the `List.contains` method from the Scala standard library. It accepts an argument of type `Any`, enabling universal but potentially unsafe equality comparisons between list elements (of type `T`) and the argument. This allows comparison with any type, bypassing compile-time type safety for equality checks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nclass List[+T]:\n  ...\n  def contains(x: Any): Boolean\n```\n\n----------------------------------------\n\nTITLE: Underlying Java Reflective applyDynamic Call for Structural Types in Scala\nDESCRIPTION: This snippet shows the low-level translation of a structural method call to reflectiveSelectable(f).applyDynamic(\"close\")(), demonstrating how a closeable instance's close method is invoked at runtime using Java reflection. It relies on an implicit conversion provided by importing reflectiveSelectable, and the structural type must have the appropriate method signature. Inputs are the object f and the method name; output is invocation of the method via reflection with its runtime overhead.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nreflectiveSelectable(f).applyDynamic(\"close\")()\n```\n\n----------------------------------------\n\nTITLE: Define Placeholder Syntax Rule - EBNF\nDESCRIPTION: This EBNF snippet defines a part of the grammar related to placeholder syntax in anonymous functions. It specifies that an underscore symbol _ can appear as a SimpleExpr1, enabling its use as a placeholder for parameters within an expression that is implicitly converted into an anonymous function.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_46\n\nLANGUAGE: ebnf\nCODE:\n```\nSimpleExpr1  ::=  ‘_’\n```\n\n----------------------------------------\n\nTITLE: Attempting List Contains with Covariant Type in Scala\nDESCRIPTION: This snippet represents an intuitive but incorrect attempt to define a type-safe `contains` method for a covariant list (`List[+T]`). Using the covariant type parameter `T` directly in a parameter position (a nonvariant context without a lower bound) is disallowed by Scala's variance rules, which prevents this simple signature from being valid.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef contains(x: T): Boolean\n```\n\n----------------------------------------\n\nTITLE: Using By-Name Parameter Types with Capture Annotations in Scala 3\nDESCRIPTION: This snippet contrasts by-name parameters without and with capture annotations. The typical by-name parameter `x: => Int` can capture arbitrary capabilities, but specifying `x: -> Int` restricts it to pure values, and `x: ->{c} Int` permits capture of specific capabilities. This extension enforces safer resource handling in argument evaluation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: => Int): Int\n\ndef f(x: -> Int): Int\n\ndef f(x: ->{c} Int): Int\n```\n\n----------------------------------------\n\nTITLE: Infix Operators at Start of Line\nDESCRIPTION: New ability to place infix operators at the beginning of lines for better code formatting.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef isABorC(x: Char) = x == 'A'\n  || x == 'B'\n  || x == 'C'\n```\n\n----------------------------------------\n\nTITLE: Executing a Scala Program from the Command Line\nDESCRIPTION: Demonstrates the command-line syntax using the `scala` command to execute a compiled Scala program (`test.HelloWorld`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/09-top-level-definitions.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\nscala test.HelloWorld\n```\n\n----------------------------------------\n\nTITLE: Implementing Scala XML Interpolation for Patterns\nDESCRIPTION: Demonstrates how to create an implicit class `XMLinterpolation` in Scala that adds an `xml` method to `StringContext`. This `xml` method returns an object with `apply` (for constructing) and `unapplySeq` (for pattern matching XML `Node`s), enabling the use of `xml\"...\"` interpolated strings as patterns.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimplicit class XMLinterpolation(s: StringContext) = {\n    object xml {\n        def apply(exprs: Any*) =\n            // parse ‘s’ and build an XML tree with ‘exprs’\n            //in the holes\n        def unapplySeq(xml: Node): Option[Seq[Node]] =\n          // match `s’ against `xml’ tree and produce\n          //subtrees in holes\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Differentiating Transparent and Non-Transparent Inline Methods in Scala\nDESCRIPTION: Demonstrates the syntax difference between a regular `inline` method (`f1`) and a `transparent inline` method (`f2`). `transparent inline` methods influence type checking at the call site and are expanded earlier during type checking, while regular `inline` methods are inlined later after the program is fully typed. The type ascription `(...): T` in `f2` ensures the return type remains `T`, preventing overly specific type inference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ninline def f1: T = ...\ntransparent inline def f2: T = (...): T\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Given Instance and Method in Scala\nDESCRIPTION: This snippet defines an `inline` given instance for `Show[Foo]` with an `inline` `show` method. This allows calls to `summon[Show[Foo]].show(foo)` to be inlined, potentially removing the instantiation of the given itself if it's no longer needed after inlining the method call.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/givens.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Show[T] {\n  inline def show(x: T): String\n}\n\ninline given Show[Foo] with {\n  /*transparent*/ inline def show(x: Foo): String = ${ ... }\n}\n\ndef app =\n  // inlines `show` method call and removes the call to `given Show[Foo]`\n  summon[Show[Foo]].show(foo)\n```\n\n----------------------------------------\n\nTITLE: Using Pattern-Bound Given Instances in Scala\nDESCRIPTION: This snippet illustrates how `given` instances can be bound within patterns. The first part shows establishing anonymous `given` instances for `Context` from a collection in a `for` comprehension. The second part shows binding a named `given` instance `ctx` for `Context` during pattern matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/givens.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nfor given Context <- applicationContexts do\n\npair match\n  case (ctx @ given Context, y) => ...\n```\n\n----------------------------------------\n\nTITLE: Resolving Overloads with Inferrable Function Literals (Scala)\nDESCRIPTION: This Scala code defines two overloaded methods `f` that accept different types for their first parameter and a function literal for the second. The calls `f(\"a\", _.toUpperCase)` and `f(2, _ * 2)` demonstrate that Scala 3 can correctly resolve the overload even when the function literal's parameter type (`_`) is not explicitly given, using the type of the *first* argument (`\"a\"` or `2`) to infer the required function type (`String => String` or `Int => Int`). This improved inference in the first parameter list was not supported in Scala 2, leading to 'missing parameter type' errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/overload-resolution.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Int, f2: Int => Int) = f2(x)\ndef f(x: String, f2: String => String) = f2(x)\nf(\"a\", _.toUpperCase)\nf(2, _ * 2)\n```\n\n----------------------------------------\n\nTITLE: Installing Dotty via Homebrew (Shell)\nDESCRIPTION: Gives the shell command for installing the Dotty compiler using the Homebrew package manager. This provides a convenient way for macOS and Linux users to install Dotty directly from the Homebrew repository by tapping the lampepfl/brew tap.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-12-01-fifth-dotty-milestone-release.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nbrew install lampepfl/brew/dotty\n```\n\n----------------------------------------\n\nTITLE: Using Match Types for Type Equivalence in Scala 3\nDESCRIPTION: This snippet shows type-level equality examples using the previously defined match type `Elem`. It demonstrates that applying `Elem` to different type arguments reduces to expected types, checked via the `=:=` type operator, which asserts mutual subtype relationships. It clarifies how match types behave with concrete examples, including a fallback to `Nothing` for unmatched types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-10-10-10th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nElem[String]       =:=  Char\nElem[Array[Int]]   =:=  Int\nElem[List[Float]]  =:=  Float\nElem[Nil]          =:=  Nothing\n```\n\n----------------------------------------\n\nTITLE: Handling Nullable Type Parameters from Java in Scala 3 - Scala\nDESCRIPTION: The Scala version of the generic Java class demonstrates how Scala 3 signals the type parameter as nullable (`T?`) for more precise null-safety. This snippet reflects Scala's translation mechanism for generic Java code, ensuring interoperability and correct nullability propagation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nclass C[T] { def foo(): T? }\n\n```\n\n----------------------------------------\n\nTITLE: Simplified Inline Function Result Without Logging\nDESCRIPTION: Provides an example of how inlining removes logging code when `Config.logging` is false, resulting in a direct recursive factorial implementation without additional logging statements. It illustrates the code reduction achieved by compile-time inlining.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef factorial(n: BigInt): BigInt =\n  if n == 0 then 1\n  else n * factorial(n - 1)\n```\n\n----------------------------------------\n\nTITLE: Deriving 'CanEqual' instances for complex parameter structures\nDESCRIPTION: This code demonstrates how Scala 3 derives 'CanEqual' instances between two 'DerivingType' types with different parameters by requiring evidence of 'CanEqual' for each parameter of kind '*'. It handles bidirectional equality and supports complex nested types, ensuring type-safe comparisons.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ngiven [T_1L, T_1R, ..., T_NL, T_NR](using CanEqual[U_1L, U_1R], ..., CanEqual[U_ML, U_MR]) : CanEqual[DerivingType[T_1L, ..., T_NL], DerivingType[T_1R, ..., T_NR]] = CanEqual.derived\n```\n\n----------------------------------------\n\nTITLE: Handling Capability Escaping in Try Blocks with Scala Exception Checking - Scala\nDESCRIPTION: Illustrates a function escaped that returns a delayed computation (() => Int) which includes a try-catch block providing a CanThrow capability. The expansion shows compiler-generated code where the capability is provided in the try block and is passed to all calls that can throw. This example demonstrates a limitation in the current model since the capability escapes the scope of the try block via the returned lambda, allowing exceptions at runtime despite typechecking. It highlights missing scope enforcement for ephemeral capabilities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/canthrow.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef escaped(xs: Double*): () => Int =\n  try () => xs.map(f).sum\n  catch case ex: LimitExceeded => -1\n```\n\nLANGUAGE: scala\nCODE:\n```\n// compiler-generated code\ndef escaped(xs: Double*): () => Int =\n  try\n    given ctl: CanThrow[LimitExceeded] = ???\n    () => xs.map(x => f(x)(using ctl)).sum\n  catch case ex: LimitExceeded => -1\n```\n\nLANGUAGE: scala\nCODE:\n```\nval g = escaped(1, 2, 1000000000)\ng()\n```\n\n----------------------------------------\n\nTITLE: Listing Contributors using `git shortlog`\nDESCRIPTION: Displays the output of the `git shortlog -sn --no-merges 0.23.0-RC1..0.24.0-RC1` command. This output lists the contributors to the Dotty project between the specified release candidate versions, along with their respective commit counts.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-04-29-24th-dotty-milestone-release.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n   136  Martin Odersky\n    74  Nicolas Stucki\n    37  Guillaume Martres\n    33  Robert Stoll\n    22  Liu Fengyun\n    19  Anatolii Kmetiuk\n    16  Arnaud ESTEVE\n    15  Olivier Blanvillain\n    10  Arnaud Esteve\n     9  Martijn Hoekstra\n     6  Anatolii\n     4  Som Snytt\n     4  bishabosha\n     4  Aleksander Boruch-Gruszecki\n     3  Miles Sabin\n     2  odersky\n     2  Fengyun Liu\n     2  Julien Richard-Foy\n     1  Ara Adkins\n     1  Maxime Kjaer\n     1  Philippus\n     1  Rike-Benjamin Schuppner\n     1  Julien Jean Paul Sirocchi\n     1  Dani Rey\n     1  Sébastien Doeraene\n     1  aesteve\n     1  Dale Wijnand\n     1  fhackett\n     1  gzoller\n     1  Michael Pilquist\n```\n\n----------------------------------------\n\nTITLE: Controlling Virtual Semicolons with Indentation in Scala 3\nDESCRIPTION: This Scala code snippet illustrates how indentation is used to determine virtual semicolon insertion between consecutive lines. If a line is indented more than the previous line and starts with '(', '[', or '{', or if the previous line ends with `return`, the lines are treated as a single statement (continuation). Otherwise, a virtual semicolon is inserted, treating them as separate statements.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nf(x + 1)\n  (2, 3)        // equivalent to  `f(x + 1)(2, 3)`\n\ng(x + 1)\n(2, 3)          // equivalent to  `g(x + 1); (2, 3)`\n\nh(x + 1)\n  {}            // equivalent to  `h(x + 1){}`\n\ni(x + 1)\n{}              // equivalent to  `i(x + 1); {}`\n\nif x < 0 then return\n  a + b         // equivalent to  `if x < 0 then return a + b`\n\nif x < 0 then return\nprintln(a + b)  // equivalent to  `if x < 0 then return; println(a + b)`\n```\n\n----------------------------------------\n\nTITLE: Listing Standard NotNull Annotations Recognized by Scala - Scala\nDESCRIPTION: This code snippet is a partial list of annotation symbols recognized by the Scala 3 compiler as NotNull markers. It shows a lazy val construction with symbol lookup in the context, relevant for developers extending or customizing nullification logic when interoperating with Java. Dependencies include ctx and PreNamedString.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\n// A list of annotations that are commonly used to indicate\n// that a field/method argument or return type is not null.\n// These annotations are used by the nullification logic in\n// JavaNullInterop to improve the precision of type nullification.\n// We don't require that any of these annotations be present\n// in the class path, but we want to create Symbols for the\n// ones that are present, so they can be checked during nullification.\n@tu lazy val NotNullAnnots: List[ClassSymbol] = ctx.getClassesIfDefined(\n  \"javax.annotation.Nonnull\" ::\n  \"edu.umd.cs.findbugs.annotations.NonNull\" ::\n  \"androidx.annotation.NonNull\" ::\n  \"android.support.annotation.NonNull\" ::\n  \"android.annotation.NonNull\" ::\n  \"com.android.annotations.NonNull\" ::\n  \"org.eclipse.jdt.annotation.NonNull\" ::\n  \"org.checkerframework.checker.nullness.qual.NonNull\" ::\n  \"org.checkerframework.checker.nullness.compatqual.NonNullDecl\" ::\n  \"org.jetbrains.annotations.NotNull\" ::\n  \"lombok.NonNull\" ::\n  \"io.reactivex.annotations.NonNull\" :: Nil map PreNamedString)\n\n```\n\n----------------------------------------\n\nTITLE: Using Peano Numbers with Implicit `TypeTest` for Safe Division in Scala\nDESCRIPTION: Demonstrates the usage of the `PeanoInt` implementation. The `divOpt` function performs pattern matching on the abstract type `Nat`. Thanks to the implicitly available `given` `TypeTest` instances defined in `PeanoInt`, the compiler can safely distinguish between `Zero` and `Succ` cases (`case Zero`, `case s @ Succ(_)`), preventing division by zero and ensuring type safety.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n@main def test =\n  import PeanoInt.*\n\n  def divOpt(m: Nat, n: Nat): Option[(Nat, Nat)] =\n    n match\n      case Zero => None\n      case s @ Succ(_) => Some(safeDiv(m, s))\n\n  val two = Succ(Succ(Zero))\n  val five = Succ(Succ(Succ(two)))\n\n  println(divOpt(five, two))  // prints \"Some((2,1))\"\n  println(divOpt(two, five))  // prints \"Some((0,2))\"\n  println(divOpt(two, Zero))  // prints \"None\"\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor List for Scala 3.3.0-RC1\nDESCRIPTION: Output of the git command showing contributors to Scala 3.3.0-RC1 release sorted by number of commits. The command excludes merge commits and shows the difference between 3.2.2 and 3.3.0-RC1.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.3.0-RC1.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n   225 Martin Odersky\n    73 Dale Wijnand\n    58 Szymon Rodziewicz\n    54 Nicolas Stucki\n    48 Kamil Szewczyk\n    48 Paul Coral\n    30 Paweł Marks\n    28 Florian3k\n    28 Yichen Xu\n    14 Guillaume Martres\n     8 Fengyun Liu\n     8 Michał Pałka\n     7 Chris Birchall\n     7 rochala\n     6 Kacper Korban\n     6 Sébastien Doeraene\n     6 jdudrak\n     5 Seth Tisue\n     5 Som Snytt\n     5 nizhikov\n     4 Filip Zybała\n     4 Jan Chyb\n     4 Michael Pollmeier\n     4 Natsu Kagami\n     3 Jamie Thompson\n     2 Alex\n     2 Anatolii Kmetiuk\n     2 Dmitrii Naumenko\n     2 Lukas Rytz\n     2 adampauls\n     2 yoshinorin\n     1 Alexander Slesarenko\n     1 Chris Kipp\n     1 Guillaume Raffin\n     1 Jakub Kozłowski\n     1 Jan-Pieter van den Heuvel\n     1 Julien Richard-Foy\n     1 Kenji Yoshida\n     1 Philippus\n     1 Szymon R\n     1 Tim Spence\n     1 s.bazarsadaev\n```\n\n----------------------------------------\n\nTITLE: Type Error Due to Capture Set Widening in Scala\nDESCRIPTION: Illustrates a type error occurring when a function declared to return a pure type (`LazyList[Int]`) actually returns a capturing type (`{l} LazyList[Int]`). The error message shows the type widened to `{fs} LazyList[Int]` because the local variable `l` (with capture set `{fs}`) cannot escape the function's scope, demonstrating the 'avoidance' mechanism.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n11 |def test(using fs: {*} FileSystem): LazyList[Int] = {\n   |                                                    ^\n   |                                            Found:    {fs} LazyList[Int]\n   |                                            Required: LazyList[Int]\n```\n\n----------------------------------------\n\nTITLE: Package Declaration and Import Ambiguity with Classes in Scala 3\nDESCRIPTION: This snippet exhibits the ambiguity that arises from importing packages and separately declared package classes with the same name across multiple files. It underscores that imported aliases from package statements are permitted although strictly ambiguous, but references are treated as if shadowing the import because they are equivalent. This example involves multiple compilation units illustrating implicit shadowing behavior between package and import bindings.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/02-identifiers-names-and-scopes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// c.scala\npackage p { class C }\n\n// xy.scala\nimport p.*\npackage p { class X extends C }\npackage q { class Y extends C }\n```\n\n----------------------------------------\n\nTITLE: Defining Compiler Phases Sequence in Dotty Scala3 - Scala\nDESCRIPTION: This snippet defines the composition and ordering of the compiler phases within the Dotty Scala 3 compiler. The 'phases' method concatenates lists of frontend, pickler, transform, and backend phases. Each sublist enumerates classes implementing individual phases such as parsing, typing, inlining, tree transformations, and code generation. This staged design structures the compiler workflow from source code scanning through bytecode emission.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/overall-structure.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n  def phases: List[List[Phase]] =\n  frontendPhases ::: picklerPhases ::: transformPhases ::: backendPhases\n\n  /** Phases dealing with the frontend up to trees ready for TASTY pickling */\n  protected def frontendPhases: List[List[Phase]] =\n    List(new Parser) ::             // scanner, parser\n    List(new TyperPhase) ::         // namer, typer\n    List(new YCheckPositions) ::    // YCheck positions\n    List(new sbt.ExtractDependencies) :: // Sends information on classes' dependencies to sbt via callbacks\n    List(new semanticdb.ExtractSemanticDB) :: // Extract info into .semanticdb files\n    List(new PostTyper) ::          // Additional checks and cleanups after type checking\n    List(new sjs.PrepJSInterop) ::  // Additional checks and transformations for Scala.js (Scala.js only)\n    List(new sbt.ExtractAPI) ::     // Sends a representation of the API of classes to sbt via callbacks\n    List(new SetRootTree) ::        // Set the `rootTreeOrProvider` on class symbols\n    Nil\n\n  /** Phases dealing with TASTY tree pickling and unpickling */\n  protected def picklerPhases: List[List[Phase]] =\n    List(new Pickler) ::            // Generate TASTY info\n    List(new Inlining) ::           // Inline and execute macros\n    List(new PostInlining) ::       // Add mirror support for inlined code\n    List(new Staging) ::            // Check staging levels and heal staged types\n    List(new Splicing) ::           // Replace level 1 splices with holes\n    List(new PickleQuotes) ::       // Turn quoted trees into explicit run-time data structures\n    Nil\n\n  /** Phases dealing with the transformation from pickled trees to backend trees */\n  protected def transformPhases: List[List[Phase]] =\n    List(new FirstTransform,         // Some transformations to put trees into a canonical form\n         new CheckReentrant,         // Internal use only: Check that compiled program has no data races involving global vars\n         new ElimPackagePrefixes,    // Eliminate references to package prefixes in Select nodes\n         new CookComments,           // Cook the comments: expand variables, doc, etc.\n         new CheckStatic,            // Check restrictions that apply to @static members\n         new BetaReduce,             // Reduce closure applications\n         new init.Checker) ::        // Check initialization of objects\n    List(new ElimRepeated,           // Rewrite vararg parameters and arguments\n         new ExpandSAMs,             // Expand single abstract method closures to anonymous classes\n         new ProtectedAccessors,     // Add accessors for protected members\n         new ExtensionMethods,       // Expand methods of value classes with extension methods\n         new UncacheGivenAliases,    // Avoid caching RHS of simple parameterless given aliases\n         new ByNameClosures,         // Expand arguments to by-name parameters to closures\n         new HoistSuperArgs,         // Hoist complex arguments of supercalls to enclosing scope\n         new SpecializeApplyMethods, // Adds specialized methods to FunctionN\n         new RefChecks) ::           // Various checks mostly related to abstract members and overriding\n    List(new ElimOpaque,             // Turn opaque into normal aliases\n         new TryCatchPatterns,       // Compile cases in try/catch\n         new PatternMatcher,         // Compile pattern matches\n         new sjs.ExplicitJSClasses,  // Make all JS classes explicit (Scala.js only)\n         new ExplicitOuter,          // Add accessors to outer classes from nested ones.\n         new ExplicitSelf,           // Make references to non-trivial self types explicit as casts\n         new ElimByName,             // Expand by-name parameter references\n         new StringInterpolatorOpt) :: // Optimizes raw and s string interpolators by rewriting them to string concatentations\n    List(new PruneErasedDefs,        // Drop erased definitions from scopes and simplify erased expressions\n         new InlinePatterns,         // Remove placeholders of inlined patterns\n         new VCInlineMethods,        // Inlines calls to value class methods\n         new SeqLiterals,            // Express vararg arguments as arrays\n         new InterceptedMethods,     // Special handling of `==`, `|=`, `getClass` methods\n         new Getters,                // Replace non-private vals and vars with getter defs (fields are added later)\n         new SpecializeFunctions,    // Specialized Function{0,1,2} by replacing super with specialized super\n         new CollectNullableFields,  // Collect fields that can be nulled out after use in lazy initialization\n         new ElimOuterSelect,        // Expand outer selections\n         new ResolveSuper,           // Implement super accessors\n         new FunctionXXLForwarders,  // Add forwarders for FunctionXXL apply method\n         new ParamForwarding,        // Add forwarders for aliases of superclass parameters\n         new TupleOptimizations,     // Optimize generic operations on tuples\n         new LetOverApply,            // Lift blocks from receivers of applications\n         new ArrayConstructors) ::   // Intercept creation of (non-generic) arrays and intrinsify.\n    List(new Erasure) ::             // Rewrite types to JVM model, erasing all type parameters, abstract types and refinements.\n    List(new ElimErasedValueType,    // Expand erased value types to their underlying implementation types\n         new PureStats,              // Remove pure stats from blocks\n         new VCElideAllocations,     // Peep-hole optimization to eliminate unnecessary value class allocations\n         new ArrayApply,             // Optimize `scala.Array.apply([....])` and `scala.Array.apply(..., [....])` into `[...]`\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Universal Equality with Matchable Casting in Scala\nDESCRIPTION: This code demonstrates the new idiom for writing equals methods in Scala 3, where the argument is cast to Matchable before performing pattern matching. Dependencies: Scala 3. This ensures that pattern matching on Any arguments is explicitly permitted only via Matchable, which may produce compile-time warnings if used with unsafe selectors (e.g., types not guaranteed matchable). Input is any object, and output is Boolean indicating value equality.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/matchable.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(val x: String):\n\n  override def equals(that: Any): Boolean =\n    that.asInstanceOf[Matchable] match\n      case that: C => this.x == that.x\n      case _ => false\n```\n\n----------------------------------------\n\nTITLE: Defining For Comprehension/Loop Syntax in EBNF for Scala 3\nDESCRIPTION: Provides the Extended Backus-Naur Form (EBNF) grammar definition for Scala 3 `for` comprehensions and `for` loops. It outlines the structure involving enumerators (generators, value definitions, guards) and the optional `yield` keyword that distinguishes comprehensions from loops.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_29\n\nLANGUAGE: ebnf\nCODE:\n```\nExpr1          ::=  ‘for’ (‘(’ Enumerators ‘)’ | ‘{’ Enumerators ‘}’)\n                       {nl} [‘yield’] Expr\nEnumerators    ::=  Generator {semi Generator}\nGenerator      ::=  [‘case’] Pattern1 ‘<-’ Expr {[semi] Guard | semi Pattern1 ‘=’ Expr}\nGuard          ::=  ‘if’ PostfixExpr\n```\n\n----------------------------------------\n\nTITLE: Defining Type Members with Refining Capture Sets in Scala\nDESCRIPTION: This snippet demonstrates how to define and refine type members with explicit capture sets and read-only capabilities across class hierarchies in Scala 3. Dependencies include correct support for contextual capture checking and capability subtyping, as covered by Scala 3's type system updates. The key parameters are type refinement with capture set annotations and the use of 'rd' for read-only modes. Inputs are type variables and their bounds; expected output is an error or correct type hierarchy based on subcapturing compatibility and declared mode.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass A:\n  type T <: Object^{x.rd, y}\nclass B extends A:\n  type T <: Object^{x.rd}\nclass C extends B:\n  type T = Matrix^{x.rd}\n```\n\n----------------------------------------\n\nTITLE: Defining a Single Extension Method with Unified Syntax in Scala\nDESCRIPTION: This snippet defines a single extension method '<' for the String type using the new unified extension method syntax introduced in Scala 3. The syntax allows adding methods to existing types without modifying their original definitions. The extension method accepts a String parameter 'y' and is invoked as a member of any String instance. Required: Scala 3 or Dotty 0.26.0-RC1 or newer. Inputs: two strings. Output: a Boolean result based on the custom logic implemented (left as an ellipsis in this example).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-07-27-26th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nextension (x: String)\n  def < (y: String): Boolean = ...\n```\n\n----------------------------------------\n\nTITLE: Using BigFloat Literal with FromDigits in Scala\nDESCRIPTION: Demonstrates assigning a large literal to a BigFloat type. With default behavior, the compiler expands the literal to a call to BigFloat.FromDigits.fromDigits, which may throw a NumberTooLarge exception at runtime if the value is too large. Requires an import of the BigFloat class and standard numeric literal handling. Input is a numeric literal; output is a runtime exception unless compile-time macro handling is implemented.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n1e10_0000_000_000: BigFloat\n```\n\n----------------------------------------\n\nTITLE: Defining Return Expression Syntax in EBNF for Scala 3\nDESCRIPTION: Provides the Extended Backus-Naur Form (EBNF) grammar definition for the Scala 3 `return` expression. It shows that `return` can optionally be followed by an expression (`Expr`), whose value is returned from the enclosing method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_39\n\nLANGUAGE: ebnf\nCODE:\n```\nExpr1      ::=  ‘return’ [Expr]\n```\n\n----------------------------------------\n\nTITLE: Type of Generic Instance Showing Capture Tunnelling\nDESCRIPTION: Shows the inferred type of the `Pair` instance `p` created with capturing types. The outer type `Pair[...]` itself is pure (empty capture set), demonstrating capture tunnelling where capabilities `ct` and `fs` are associated with the type arguments, not the `Pair` instance itself.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\ndef p: Pair[{ct} Int -> String, {fs} Logger] = Pair(x, y)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Exception Impact on Initialization in Scala\nDESCRIPTION: This Scala snippet provides an example demonstrating how control effects like exceptions could potentially break the stackability principle (all fields initialized at the end of the constructor) if not handled carefully. The code shows an exception being thrown during the initialization of `B`, potentially carrying an uninitialized `this` reference (`myEx.b`) back to `A`, although the checker's implementation prevents this by requiring thrown values to be transitively initialized.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/safe-initialization.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass MyException(val b: B) extends Exception(\"\")\nclass A:\n  val b = try { new B } catch { case myEx: MyException => myEx.b }\n  println(b.a)\n\nclass B:\n  throw new MyException(this)\n  val a: Int = 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Lazy Cons Node with Memoization in Scala\nDESCRIPTION: Implementation of the non-empty case for LzyList using a class that memoizes the tail computation for efficiency. The implementation uses capture annotations to track capabilities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.uninitialized\n\nfinal class LzyCons[+A](hd: A, tl: () => {*} LzyList[A]) extends LzyList[A]:\n  private var forced = false\n  private var cache: {this} LzyList[A] = uninitialized\n  private def force =\n    if !forced then { cache = tl(); forced = true }\n    cache\n\n  def isEmpty = false\n  def head = hd\n  def tail: {this} LzyList[A] = force\nend LzyCons\n```\n\n----------------------------------------\n\nTITLE: Contrasting Old vs. New Polymorphic Function Definition in Scala\nDESCRIPTION: Compares how a polymorphic function like the identity function was defined previously (requiring the type parameter `T` to be bound externally) versus how it can be defined using the new polymorphic function type syntax, allowing local quantification.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-06-11-16th-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n  val id: T => T = t => t\n  println(s\"${id(1)} , ${id(7.0d)}\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\n  val id = [T] => (t: T) => t\n  println(s\"${id(1)} , ${id(7.0d)}\")\n```\n\n----------------------------------------\n\nTITLE: EBNF Grammar for Scala Qualified Identifiers\nDESCRIPTION: Defines the Extended Backus-Naur Form (EBNF) grammar for a Scala qualified identifier (`QualId`), which is a sequence of identifiers separated by dots, commonly used for package names and member access.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/09-top-level-definitions.md#_snippet_5\n\nLANGUAGE: EBNF\nCODE:\n```\nQualId           ::=  id {‘.’ id}\n```\n\n----------------------------------------\n\nTITLE: Translation of Operator Extension Methods in Scala\nDESCRIPTION: Shows the compiler's translation for the previously defined operator extension methods. It highlights the parameter swapping (`x` and `xs`) necessary for the right-associative operator `+:` to work correctly with Scala's operator precedence rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n<extension> def < (x: String)(y: String): Boolean = ...\n<extension> def +: (xs: Seq[Elem])(x: Elem): Seq[Elem] = ...\n<extension> infix def min(x: Number)(y: Number): Number = ...\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Parameter Explicit Passing Limitation for Right-Associative Extension Methods in Scala\nDESCRIPTION: Demonstrates a current limitation where it is not possible to explicitly specify the type parameters of the method itself (like `[T]` here) when calling a right-associative extension method using the dot notation, unlike how it works for standard methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/right-associative-extension-methods.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n  extension (x: Int)\n    def *:[T](xs: List[T]): List[T] = ...\n\n  xs.*:[Int](1) // error when trying to set T explicitly\n```\n\n----------------------------------------\n\nTITLE: Defining Bindings, Imports, and Modifiers in Scala 3 EBNF\nDESCRIPTION: This EBNF snippet specifies the grammar for bindings, various modifiers (local, access, override), annotations, and import/export statements in Scala 3. It details how identifiers, underscores, types, access qualifiers, and import selectors are structured within these constructs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/syntax-3.1.md#_snippet_1\n\nLANGUAGE: EBNF\nCODE:\n```\nBindings          ::=  ‘(’ Binding {‘,’ Binding} ‘)’\nBinding           ::=  (id | ‘_’) [‘:’ Type]\n\nModifier          ::=  LocalModifier\n                    |  AccessModifier\n                    |  ‘override’\nLocalModifier     ::=  ‘abstract’\n                    |  ‘final’\n                    |  ‘sealed’\n                    |  ‘lazy’\n                    |  ‘opaque’\n                    |  ‘inline’\n                    |  ‘erased’\nAccessModifier    ::=  (‘private’ | ‘protected’) [AccessQualifier]\nAccessQualifier   ::=  ‘[’ (id | ‘this’) ‘]’\n\nAnnotation        ::=  ‘@’ SimpleType {ParArgumentExprs}\n\nImport            ::=  ‘import’ [‘implied’] ImportExpr {‘,’ ImportExpr}\nImportExpr        ::=  StableId ‘.’ (id | ‘_’ | ImportSelectors)\nImportSelectors   ::=  ‘{’ {ImportSelector ‘,’} (ImportSelector | ‘_’) ‘}’\nImportSelector    ::=  id [‘=>’ id | ‘=>’ ‘_’]\nExport            ::=  ‘export’ [‘implied’] ImportExpr {‘,’ ImportExpr}\n```\n\n----------------------------------------\n\nTITLE: Flow Typing Usage Scope Constraints with Mutable Variables in Scala\nDESCRIPTION: This snippet highlights that flow typing for local mutable variables in Scala 3 is only safe at the same lexical scope as the variable definition. It demonstrates two uses of 'x: String | Null', one within a nested closure and one in the outer method. Only the latter occurrence can correctly leverage flow typing. Requires understanding of closures and method scoping. Unsafe usage in closures is prevented by the type system; safe flow typing only in direct method scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\nvar x: String | Null = ???\ndef y =\n  if x != null then\n    // not safe to use the fact (x != null) here\n    // since y can be executed at the same time as the outer block\n    val _: String = x\nif x != null then\n  val a: String = x // ok to use the fact here\n  x = null\n```\n\n----------------------------------------\n\nTITLE: Importing Given Instances with Wildcard Selectors in Scala\nDESCRIPTION: Demonstrates importing all members except given instances with a regular wildcard `*`, and importing all given instances with the `given` selector. Shows how to combine both selectors in a single import clause to bring both regular and given members into scope from another object.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/contextual/given-imports.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject A:\n  class TC\n  given tc: TC = ???\n  def f(using TC) = ???\n\nobject B:\n  import A.*\n  import A.given\n  ...\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject B:\n  import A.{given, *}\n  ...\n```\n\n----------------------------------------\n\nTITLE: Using Literal Types in Scala - Type Ascription and Subtyping\nDESCRIPTION: This Scala snippet showcases the usage of literal types by ascribing precise singleton types to values (e.g., 'val x: 1 = 1'). It demonstrates both successful assignments and type errors that result from subtype incompatibility (e.g., assigning an Int to a literal type or mismatching boolean literals). Requires Scala 3; no external libraries are needed; input is variable declarations; results in compile-time checks for type precision.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nval x: 1 = 1\nval y: false = false\nval z: false = y\nval int: Int = x\n\nval badX: 1 = int       // error: Int is not a subtype of 1\nval badY: false = true  // error: true is not a subtype of false\n```\n\n----------------------------------------\n\nTITLE: Compiler Warning for Extending Non-Open Classes Without Ad-Hoc Feature\nDESCRIPTION: This compiler output snippet illustrates the warning message generated when a class attempts to extend a non-open class in a separate file without enabling the 'adhocExtensions' feature. It informs the developer to add the import 'scala.language.adhocExtensions' or use the compiler option '-language:adhocExtensions' to enable such extensions. This warning highlights the requirement to explicitly opt in for ad-hoc extensions and enforces disciplined extensibility.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/open-classes.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n-- Feature Warning: EncryptedWriter.scala:6:14 ----\n  |class EncryptedWriter[T: Encryptable] extends Writer[T]\n  |                                              ^\n  |Unless class Writer is declared 'open', its extension\n  | in a separate file should be enabled\n  |by adding the import clause 'import scala.language.adhocExtensions'\n  |or by setting the compiler option -language:adhocExtensions.\n```\n\n----------------------------------------\n\nTITLE: Defining a Structural Type Record and Person with Selectable in Scala\nDESCRIPTION: This snippet defines a class Record that extends Selectable, storing field key-value pairs and providing a selectDynamic method for dynamic field resolution. It also defines a structural type Person as Record refined with name and age fields. Dependencies include the scala.Selectable trait, and usage requires Scala 3's structural typing mechanisms. The code stores arbitrary fields, enables dot notation for structural selection, and assumes correct field presence when casting to structural types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Record(elems: (String, Any)*) extends Selectable:\n  private val fields = elems.toMap\n  def selectDynamic(name: String): Any = fields(name)\n\ntype Person = Record { val name: String; val age: Int }\n```\n\n----------------------------------------\n\nTITLE: Creating a Stack Trace Tracer in Scala\nDESCRIPTION: This Scala code defines a `val` named `tracer` that captures the current thread's stack trace as a formatted string. It is intended to be added as a field to a class within the compiler's source code. When an instance of this class is created, the `tracer` field stores the stack trace leading to that creation, aiding in debugging by revealing the object's instantiation point.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/issues/cause.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval tracer = Thread.currentThread.getStackTrace.mkString(\"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Defining Deferred Givens in Scala Traits - Scala\nDESCRIPTION: This snippet demonstrates the new syntax for declaring a given instance using 'deferred' within a trait. The 'given T = deferred' statement, available in Scala 3.6 via 'scala.compiletime.deferred', defines a given that must be provided by subclasses or synthesized by the compiler. This can only be used in the right-hand side of a given in a trait, and it enables cleaner implementation of context bounds. No explicit dependencies are required except for Scala 3.6, and the output is a trait with a deferred given to be resolved by child classes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/deferred-givens.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ngiven T = deferred\n```\n\n----------------------------------------\n\nTITLE: Translating Concrete Infix Types to Internal Type Applications in Scala (EBNF)\nDESCRIPTION: This snippet describes the conversion of concrete infix types composed with operators into internal type applications. The concrete infix type grammar allows chaining operators with operands and maps them to type applications where the operator is the type constructor applied to the operands. It details operator associativity and precedence rules and notes for emitting deprecation warnings under certain compiler flags. This facilitates consistent and semantically correct internal representations of infix types with arbitrary identifiers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_2\n\nLANGUAGE: EBNF\nCODE:\n```\nInfixType     ::=  CompoundType {id [nl] CompoundType}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Top-Level Class and Trait Hierarchy Showing Matchable Trait\nDESCRIPTION: Lists the inheritance hierarchy of Scala 3 top-level classes Any, AnyVal, Object and the Matchable trait, highlighting that Matchable serves as a marker trait between Any and concrete types to enforce pattern matching constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/matchable.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Any:\n  def getClass\n  def isInstanceOf\n  def asInstanceOf\n  def ==\n  def !=\n  def ##\n  def equals\n  def hashCode\n  def toString\n\ntrait Matchable extends Any\n\nclass AnyVal extends Any, Matchable\nclass Object extends Any, Matchable\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Method Accepting 'into' Modifier - Scala\nDESCRIPTION: Defines a trait whose method accepts the 'into' modifier on its parameter. This enables the trait to admit arguments convertible to Text, offering SAM (single abstract method) types as an alternative to function types for supporting 'into'. Useful when converting existing interfaces or enabling conversions in callback arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ntrait ConvArg:\n  def apply(x: into Text): Unit\n\nval x: ConvArg = f(3)(_)\n```\n\n----------------------------------------\n\nTITLE: Type Class Derivation with 'derives' Clause\nDESCRIPTION: Shows the new 'derives' syntax that automatically generates implied instances (like 'Eql', 'Ordering', 'Pickling') for enum types. Also includes an example of defining a 'derived' method in the companion object for type class derivation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nenum Tree[T] derives Eql, Ordering, Pickling {\n  case Branch(left: Tree[T], right: Tree[T])\n  case Leaf(elem: T)\n}\n\nimplied [T: Eql] for Eql[Tree[T]] = Eql.derived\nimplied [T: Ordering] for Ordering[Tree[T]] = Ordering.derived\nimplied [T: Pickling] for Pickling[Tree[T]] = Pickling.derived\n```\n\n----------------------------------------\n\nTITLE: Type After Partial Application Drops 'into' Modifier - Scala\nDESCRIPTION: Shows type signature after partially applying a curried method with 'into' modifier. Demonstrates that 'into' does not propagate to the resulting function type, so follow-on arguments do not admit conversions. Input is an Int supplied to 'f', output is a function from Text to Unit without 'into'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nf(3) : Text => Unit\n```\n\n----------------------------------------\n\nTITLE: Example Defining Capturing Types and Capabilities in Scala 3\nDESCRIPTION: This snippet demonstrates capability annotations in types and usage with capturing types. It shows a `Logger` class using a `FileSystem^` capability parameter, variables annotated with capture sets, and lazy lists retaining specific capabilities. It illustrates how capture sets track which capabilities are retained.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nclass FileSystem\n\nclass Logger(fs: FileSystem^):\n  def log(s: String): Unit = ... // Write to a log file, using `fs`\n\ndef test(fs: FileSystem^) =\n  val l: Logger^{fs} = Logger(fs)\n  l.log(\"hello world!\")\n  val xs: LazyList[Int]^{l} =\n    LazyList.from(1)\n      .map { i =>\n        l.log(s\"computing elem # $i\")\n        i * i\n      }\n  xs\n```\n\n----------------------------------------\n\nTITLE: Displaying Compiler Phases Using scalac Command-Line Flag (shell)\nDESCRIPTION: Demonstrates the usage of the scalac compiler command with the '-Xshow-phases' flag to print a flattened list of all compiler phases. This is a runtime invocation example showing how to inspect compilation phases from the command line. The snippet assumes that the scalac command is available in the environment.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/architecture/phases.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ scalac -Xshow-phases\n```\n\n----------------------------------------\n\nTITLE: Using Java Reflection with Structural Types via reflectiveSelectable in Scala\nDESCRIPTION: This snippet demonstrates how to use Java reflection for structural call dispatch in Scala 3. It imports scala.reflect.Selectable.reflectiveSelectable to provide the implicit conversion, then defines an autoClose higher-order function that receives a Closeable structural type and executes a provided operation before closing the resource. The try-finally ensures safe resource closure, while the reflective call f.close() is enabled by the import. Dependencies are reflectiveSelectable and structural type definitions. Inputs are a Closeable instance and an operation function; output is Unit, and the code incurs a runtime cost due to Java reflection.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.Selectable.reflectiveSelectable\n\ndef autoClose(f: Closeable)(op: Closeable => Unit): Unit =\n  try op(f) finally f.close()\n```\n\n----------------------------------------\n\nTITLE: Running Local Preview Server with Docker Compose Bash\nDESCRIPTION: This snippet shows how to run a local preview of the Scala 3 language specification documentation by invoking Docker Compose with environment variables to set the user and group IDs. It launches the Jekyll server inside a Docker container to automatically rebuild and serve the markdown files as HTML in real time. The expected input is the command executed in the docs/_spec directory, and the output is a running server accessible on the localhost port 4000. Dependencies include Docker and Docker Compose properly configured with the appropriate docker-compose.yml file. Changes to _config.yml require a restart of the server.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nenv UID=\"$(id -u)\" GID=\"$(id -g)\" docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Generic Method with Named Type Arguments (Scala)\nDESCRIPTION: This snippet defines a generic method `construct` with two type parameters and demonstrates two calls using named type arguments. The first call (`xs1`) explicitly names both type arguments, showing that they can be specified out of positional order. The second call (`xs2`) explicitly names only one type argument (`Coll`), allowing the other (`Elem`) to be inferred by the compiler from the provided value arguments, which highlights a key advantage of named type arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/named-typeargs.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef construct[Elem, Coll[_]](xs: Elem*): Coll[Elem] = ???\n\nval xs1 = construct[Coll = List, Elem = Int](1, 2, 3)\nval xs2 = construct[Coll = List](1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Custom MainAnnotation Implementation in Scala\nDESCRIPTION: Implementation of a custom myMain annotation that extends MainAnnotation. It handles command line argument validation, parameter parsing using FromString, and execution of the annotated method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/main-annotation.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Parser used to parse command line arguments\nimport scala.util.CommandLineParser.FromString[T]\n\n// Result type of the annotated method is Int and arguments are parsed using FromString\n@experimental class myMain extends MainAnnotation[FromString, Int]:\n  import MainAnnotation.{ Info, Parameter }\n\n  def command(info: Info, args: Seq[String]): Option[Seq[String]] =\n    if args.contains(\"--help\") then\n      println(info.documentation)\n      None // do not parse or run the program\n    else if info.parameters.exists(_.hasDefault) then\n      println(\"Default arguments are not supported\")\n      None\n    else if info.hasVarargs then\n      val numPlainArgs = info.parameters.length - 1\n      if numPlainArgs > args.length then\n        println(\"Not enough arguments\")\n        None\n      else\n        Some(args)\n    else\n      if info.parameters.length > args.length then\n        println(\"Not enough arguments\")\n        None\n      else if info.parameters.length < args.length then\n        println(\"Too many arguments\")\n        None\n      else\n        Some(args)\n\n  def argGetter[T](param: Parameter, arg: String, defaultArgument: Option[() => T])(using parser: FromString[T]): () => T =\n    () => parser.fromString(arg)\n\n  def varargGetter[T](param: Parameter, args: Seq[String])(using parser: FromString[T]): () => Seq[T] =\n    () => args.map(arg => parser.fromString(arg))\n\n  def run(program: () => Int): Unit =\n    println(\"executing program\")\n\n    val result = program()\n    println(\"result: \" + result)\n    println(\"executed program\")\n    \nend myMain\n```\n\n----------------------------------------\n\nTITLE: Extension Method Resolution via Implicit Scope in Scala\nDESCRIPTION: Illustrates Rules 3 and 4 for extension method resolution: a method is applicable if it's defined in the implicit scope of the receiver type (Rule 3) or within a `given` instance in that implicit scope (Rule 4). The example shows `flatten` defined directly in `List`'s companion object (implicit scope) and `<` defined within a `given Ordering` in the same companion object, both becoming available.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nclass List[T]:\n  ...\nobject List:\n  ...\n  extension [T](xs: List[List[T]])\n    def flatten: List[T] = xs.foldLeft(List.empty[T])(_ ++ _)\n\n  given [T: Ordering]: Ordering[List[T]] with\n    extension (xs: List[T])\n      def < (ys: List[T]): Boolean = ...\nend List\n\n// extension method available since it is in the implicit scope\n// of List[List[Int]]\nList(List(1, 2), List(3, 4)).flatten\n\n// extension method available since it is in the given Ordering[List[T]],\n// which is itself in the implicit scope of List[Int]\nList(1, 2) < List(3)\n```\n\n----------------------------------------\n\nTITLE: Implementing a TASTy Inspector in Scala\nDESCRIPTION: Defines a custom inspector class `MyInspector` by extending `scala.tasty.inspector.Inspector`. It overrides the `inspect` method, which receives a list of `Tasty` objects and uses the `quotes.reflect` API to access and process the Abstract Syntax Tree (AST) for each TASTy file.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/tasty-inspect.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.quoted.*\nimport scala.tasty.inspector.*\n\nclass MyInspector extends Inspector:\n   def inspect(using Quotes)(tastys: List[Tasty[quotes.type]]): Unit =\n      import quotes.reflect.*\n      for tasty <- tastys do\n         val tree = tasty.ast\n         // Do something with the tree\n```\n\n----------------------------------------\n\nTITLE: Implementing Capture Checking Logic in Scala 3 Compiler\nDESCRIPTION: This snippet encompasses code for carrying and verifying universal capabilities, inference of parameter types in context functions, reach capability handling, and visibility checks. It ensures correct capture semantics and soundness in context-dependent code, relying on functions like `checkCapability` and `markFree` with detailed internal logic.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.5.0-RC1.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n# Capture Checking\n\n- Carry and check universal capability from parents correctly [#20004]\n- Make parameter types of context functions inferred type trees [#20155]\n- Handle reach capabilities correctly in dependent functions [#20203]\n- Fix the visibility check in `markFree` [#20221]\n- Make inline proxy vals have inferred types [#20241]\n- CC: Give more info when context function parameters leak [#20244]\n- Plug soundness hole for reach capabilities [#20051]\n- Tighten the screws a bit more to seal the soundness hole for reach capabilities [#20056]\n- Drop retains annotations in inferred type trees [#20057]\n- Allow @retains arguments to be context functions [#20232]\n- Fix conversion of this.fld capture refs under separate compilation [#20238]\n```\n\n----------------------------------------\n\nTITLE: Result of Inlining with True Condition in Scala\nDESCRIPTION: Shows the expanded code for the `factorial` function after the `log` method call is inlined, assuming `Config.logging` is `true`. The `if` statement within `log` resolves to the `then` branch. By-value parameters (`msg`) are evaluated once and stored in a local variable. Assignments to private variables (`indent`) are handled by generating and calling special setter methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef factorial(n: BigInt): BigInt =\n  val msg = s\"factorial($n)\"\n  println(s\"${\"  \" * indent}start $msg\")\n  Logger.inline$indent_=(indent.+(indentSetting))\n  val result =\n    if n == 0 then 1\n    else n * factorial(n - 1)\n  Logger.inline$indent_=(indent.-(indentSetting))\n  println(s\"${\"  \" * indent}$msg = $result\")\n  result\n```\n\n----------------------------------------\n\nTITLE: Example Output with Tree IDs in Scala 3\nDESCRIPTION: Shows an example of the compiler's output for a simple Scala program when the `-Yshow-tree-ids` flag is enabled. Unique integer IDs (e.g., `#1047`, `#1049`) are appended to elements, allowing identification of specific tree nodes generated during the compilation process.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\npackage <empty>#1047 {\n  final lazy module val Playground: Playground$#1049 =\n    new Playground$#1049#1050#1051()#1052\n  #1053\n  final module class Playground$() extends Object#1090#1091#1092()#1093, _root_#\n    1061\n  .scala#1062.Serializable#1063 { this: Playground#1054.type#1055 =>\n    def main(args: Array#1028[String#1033]#1034#1038): Unit#1039 =\n      {\n        println#1094(\"Hello World\"#1041)#1095\n      }#1096\n    #1097\n  }#1099\n}#1100\n```\n\n----------------------------------------\n\nTITLE: Structural Subtyping Erasure Restriction Example\nDESCRIPTION: This Scala snippet demonstrates the limitation on structural subtyping related to erased parameter types. Assigning `Sink[String]` (where `put` erases to `Object`) to a structural type `{ def put(x: String): Unit }` (where `put` erases to `String`) results in a type error in Scala 3, preventing potential runtime `NoSuchMethodException` issues.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types-spec.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nclass Sink[A] { def put(x: A): Unit = {} }\nval a = Sink[String]()\nval b: { def put(x: String): Unit } = a  // error\nb.put(\"abc\") // looks for a method with a `String` parameter\n```\n\n----------------------------------------\n\nTITLE: Dependent Function Type Syntax in Scala 3\nDESCRIPTION: Explicitly shows the syntax for a dependent function type in Scala 3. This type signature, where the result type (`e.Key`) refers to a specific parameter (`e`), is what enables dependent methods to be treated and passed around as first-class function values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/dependent-function-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n(e: Entry) => e.Key\n```\n\n----------------------------------------\n\nTITLE: Running PrintTypes Tool via sbt Shell (Bash)\nDESCRIPTION: Provides the command format to execute the `dotty.tools.printTypes` helper tool from the sbt shell. This tool is used to inspect the internal representation of types within the Scala 3 compiler by supplying source code context, a 'kind' specifying the format of type strings, and the type strings themselves.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/inspection.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nsbt:scala3> scala3-compiler/Test/runMain\n  dotty.tools.printTypes\n  <source>\n  <kind>\n  <typeStrings*>\n```\n\n----------------------------------------\n\nTITLE: Scala Example of Comma-Separated Extends Syntax\nDESCRIPTION: A simple Scala code snippet demonstrating the Scala 3 syntax where multiple types extended by a class (`B` and `C`) can be separated by commas instead of the `with` keyword. This new syntax is allowed to align with the structure of the `derives` clause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nclass A extends B, C { ... }\n```\n\n----------------------------------------\n\nTITLE: Detecting Uninitialized Field Access in Parent-Child Classes in Scala\nDESCRIPTION: This Scala snippet demonstrates a parent-child class interaction where a field of the child class (`localFile`) is accessed before initialization, causing the safe initialization checker to report an error. Key focus is on the interaction between the abstract `name` method and the `extension` field in the abstract parent class. The checker warns about unsafe usage of `localFile` during initialization. Dependencies include the Scala 3 compiler with `-Wsafe-init` enabled. The input includes an abstract class with a concrete val depending on an abstract method, and a subclass that improperly initializes a val that is referenced early. Output is a compiler warning citing the field access trace.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/safe-initialization.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nabstract class AbstractFile:\n  def name: String\n  val extension: String = name.substring(4)\n\nclass RemoteFile(url: String) extends AbstractFile:\n  val localFile: String = s\"${url.##}.tmp\"  // error: usage of `localFile` before it's initialized\n  def name: String = localFile\n```\n\n----------------------------------------\n\nTITLE: Detecting Uninitialized Variable in Inner-Outer Interaction in Scala\nDESCRIPTION: This Scala code snippet exemplifies an inner-outer scope initialization error where a `counter` variable is used before it's fully initialized through nested class instantiations inside an object. The safe initialization checker flags an error because the variable is accessed during initialization of inner classes, violating the initialization guarantees. This snippet depends on nested classes and var usage in Scala 3 with the safe init checker enabled. Inputs are class definitions referencing a variable declared afterwards, resulting in a warning illustrating the chain of class constructor calls leading to access of an uninitialized var.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/safe-initialization.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject Trees:\n  class ValDef { counter += 1 }\n  class EmptyValDef extends ValDef\n  val theEmptyValDef = new EmptyValDef\n  private var counter = 0  // error\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Wildcard Existential Types Treated as Refined Types in Scala 3 - Scala\nDESCRIPTION: This snippet illustrates how Scala 3 treats wildcard existential types (e.g., Map[_ <: AnyRef, Int]) as refined types by applying upper bounds and aliases to type parameters. It highlights the substitution of removed 'forSome' existential types with wildcard refinements, maintaining compatibility while preserving sound typing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/existential-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nMap[_ <: AnyRef, Int]\n```\n\n----------------------------------------\n\nTITLE: Defining Anonymous Given Instances in Scala\nDESCRIPTION: This code demonstrates defining `given` instances without explicit names. The compiler synthesizes names based on the type, such as `given_Ord_Int` and `given_Ord_List`. This is a shorthand for named givens when the name isn't critical for explicit reference or binary compatibility.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/givens.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Ord[Int] with\n  ...\ngiven [T](using Ord[T]): Ord[List[T]] with\n  ...\n```\n\n----------------------------------------\n\nTITLE: Using Secondary Type Parameter Lists in Extension Methods – Scala\nDESCRIPTION: This snippet demonstrates the updated Scala 3 syntax allowing extension methods to define secondary type parameter lists. Example usages show a generic 'sumBy' extension method for lists, which takes an additional type parameter and uses context bounds (like 'Numeric[B]'). Required: Scala 3.0.0-RC1 or later. Inputs: a list with elements of any type, a function 'f' mapping elements to another type 'B', and an implicit 'Numeric[B]'. Output: returns a summarized value using the provided mapping function.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2021-02-17-scala3-rc1.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nList(1, 2, 3).second[Int]\nextension [A](xs: List[A])\n   def sumBy[B](f: A => B)(using Numeric[B]): B = ...\n```\n\nLANGUAGE: Scala\nCODE:\n```\nList(\"a\", \"bb\", \"ccc\").sumBy[Int](_.length)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nsumBy[String](List(\"a\", \"bb\", \"ccc\"))(_.length)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nsumBy[String](List(\"a\", \"bb\", \"ccc\"))[Int](_.length)\n```\n\n----------------------------------------\n\nTITLE: Type After Partial Application Drops Vararg Annotation - Scala\nDESCRIPTION: Shows that after partially applying 'g', the resulting type signature no longer contains the vararg annotation, paralleling the loss of the 'into' modifier in similar contexts. Input is an Int passed to 'g', output is a function from Seq[Int] to Unit.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ng(4) : Seq[Int] => Unit\n```\n\n----------------------------------------\n\nTITLE: Example of Using MultiMethodSelectable to Bypass Precise Parameter Type Checks in Scala\nDESCRIPTION: This snippet introduces the trait MultiMethodSelectable which extends Selectable.WithoutPreciseParameterTypes and provides an implementation of applyDynamic assuming method dispatch can occur without precise knowledge of parameter types. The Sink class extends this trait, allowing structural calls with differing parameter erasures to compile without error, demonstrating a workaround for the limitations of exact parameter type matching in structural types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types-spec.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait MultiMethodSelectable extends Selectable.WithoutPreciseParameterTypes:\n  // Assume this version of `applyDynamic` can be implemented without knowing\n  // precise parameter types `paramTypes`:\n  def applyDynamic(name: String, paramTypes: Class[_]*)(args: Any*): Any = ???\n\nclass Sink[A] extends MultiMethodSelectable:\n  def put(x: A): Unit = {}\n\nval a = new Sink[String]\nval b: MultiMethodSelectable { def put(x: String): Unit } = a  // OK\n```\n\n----------------------------------------\n\nTITLE: Propagation Rules for Capture Set Constraints\nDESCRIPTION: Summarizes the rules used by the incremental solver to propagate new relationships (e.g., `c <: a` or `c <: b`) across different types of constraints. It details how propagation behaves for simple subcapturing, bijective maps (`B`), and general maps (`F`), including specific conditions for handling mapped capabilities (`F(c)`) and their capture sets (`F(c).CS`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/handling-invariant-vars.md#_snippet_1\n\nLANGUAGE: Scala Capture Checking Notation\nCODE:\n```\nConstraint     new relation  propagation                 remark\n---------------------------------------------------------------\n a <: b         c <: a        c <: b\n                c <: b        none\n\n a = B(b)       c <: a        B^-1(c) <: b\n                c <: b        B(c) <: a\n\n a >: F(b)      c <: a        none\n                c <: b        F(c).CS <: a\n\n a <: F(b)      c <: a        c <: b        if F(c) = c   (1)\n                              c.super <: a  otherwise\n                c <: b        none\n\n a = F(b)       c <: a        c <: b        if F(c) = c   (1)\n                              c.super <: a  otherwise\n                c <: b        c' <: a       if F(c) = c'\n                              F(c).CS? <: a otherwise     (2)\n```\n\n----------------------------------------\n\nTITLE: Generic Method Signature with @unroll Parameter in Scala\nDESCRIPTION: Illustrates the generic signature of a final method `foo` with type parameters and multiple parameter lists. One parameter `p` is annotated with `@unroll`, indicating that parameters from `p` onwards in that list (`psY...`) must have default values and a forwarder will be generated omitting them.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/unrolled-defs.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nfinal def foo[T](ps0...)(psX..., @unroll p, psY...)(psN...): T =\n  ...\n```\n\n----------------------------------------\n\nTITLE: Covariant Behavior of Transparent Type Aliases in Scala\nDESCRIPTION: This Scala snippet defines a transparent type alias `O2[X] = List[X]`. Unlike opaque types, transparent aliases infer their variance from the right-hand side; thus, `O2` is treated as covariant because `X` is used covariantly in `List[X]`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas-spec.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntype O2[X] = List[X]\n```\n\n----------------------------------------\n\nTITLE: Basic Quote with Splices in Scala 3\nDESCRIPTION: An example of a quoted expression containing splices that call the powerCode function with quoted variables. This represents the starting point before serialization transformations occur.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\n'{\\n  val (x, n): (Double, Int) = (5, 2)\\n  ${ powerCode('{x}, '{n}) } * ${ powerCode('{2}, '{n}) }\\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating Using Clause with Scala 2 Implicit Parameter Clause\nDESCRIPTION: Defines a generic `max` function using a Scala 2 implicit parameter clause `(implicit ord: Ord[T])`. This is the Scala 2 equivalent of requiring a contextual parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ndef max[T](x: T, y: T)(implicit ord: Ord[T]): T\n```\n\n----------------------------------------\n\nTITLE: Inlining with Private Vars and Method Calls\nDESCRIPTION: Shows how `inline` methods can produce assignments to private variables via generated setter methods, enabling updates during inlined code execution. This example illustrates how graphics or mutable state can be optimized with inlining while maintaining safety and encapsulation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nLogger.inline$indent_=(indent.+(indentSetting))\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Import Statement Syntax - EBNF\nDESCRIPTION: This EBNF specification formally describes the grammar of import statements in Scala 3, including the updated wildcard 'as' and named selector rules. It provides a technical blueprint for understanding allowed import forms, token types, and combinations in the Scala 3 language. The definition is primarily relevant for language designers, parser implementers, or those seeking to understand the exact syntax constraints of Scala imports.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/imports.md#_snippet_3\n\nLANGUAGE: EBNF\nCODE:\n```\nImport            ::=  ‘import’ ImportExpr {‘,’ ImportExpr}\nImportExpr        ::= SimpleRef {‘.’ id} ‘.’ ImportSpec\n                    | SimpleRef `as` id\nImportSpec        ::=  NamedSelector\n                    |  WildcardSelector\n                    | ‘{’ ImportSelectors) ‘}’\nNamedSelector     ::=  id [‘as’ (id | ‘_’)]\nWildCardSelector  ::=  ‘*' | ‘given’ [InfixType]\nImportSelectors   ::=  NamedSelector [‘,’ ImportSelectors]\n                    |  WildCardSelector {‘,’ WildCardSelector}\n```\n\n----------------------------------------\n\nTITLE: Breaking Down GADT Constraints in Pattern Matching (Scala)\nDESCRIPTION: Provides an example defining `Expr[A]` and `IntList` and then shows a function `foo[T]`. It details how pattern matching `e` against `IntList` leads the type checker (specifically `TypeComparer`) to break down the subtype relationship (`Expr[List[T]]` vs `IntList <: Expr[List[Int]]`) into constraints on the type parameter `T` (`Int <: T` and `T <: Int`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/gadts.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass Expr[A]\nclass IntList extends Expr[List[Int]]\n\ndef foo[T](e: Expr[List[T]]): T =\n  e match {\n    case _ : IntList =>\n      // Level 1:\n      //   We start with e : Expr[List[T]]\n      //   We check that e : IntList <: Expr[List[Int]\n      //   Expr is invariant,\n      //     so we have List[Int] <: List[T] , List[T] <: List[Int]\n      // Level 2:\n      //   We compare List[Int] <: List[T]\n      //   We record  Int <: T\n      //   We compare List[T] <: List[Int]\n      //   We record  T <: Int\n      0\n  }\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Variable Numerics in Scala\nDESCRIPTION: This snippet illustrates how weak conformance affected type inference when constructing a list of variables with differing numeric types (Int, Char, Double). Previously, weak conformance allowed variables of Int and Char to be promoted to Double, resulting in a List[Double]. Required dependencies include variables of the relevant numeric types. Inputs are numeric variables and outputs are an inferred List type. In Scala 3, without weak conformance, the inferred type is now List[AnyVal] instead of List[Double], aligning with stricter type safety.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/weak-conformance.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval n: Int = 3\nval c: Char = 'X'\nval d: Double = math.sqrt(3.0)\nList(n, c, d) // used to be: List[Double], now: List[AnyVal]\n```\n\n----------------------------------------\n\nTITLE: Simulating Implicit Val with Scala 3 Lazy Val and Alias Given\nDESCRIPTION: Defines a regular lazy val `pos` and then provides it as a given instance for the type `Position` using an alias given. This combination simulates a Scala 2 implicit val in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nlazy val pos: Position = tree.sourcePos\ngiven Position = pos\n```\n\n----------------------------------------\n\nTITLE: Working with Refined Types and Conformance in Scala\nDESCRIPTION: This Scala example defines refined types with abstract type members, method/field overrides, and demonstrates valid and invalid subtyping relationships (e.g., 'U <: T { def foo: Int }'). Requires trait/class definitions for T, U, and V with appropriate members. Inputs are trait declarations and subtype checks; errors illustrate limitations or misuses of the refinement system.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\ntrait T:\n  type X <: Option[Any]\n  def foo: Any\n  def fooPoly[A](x: A): Any\n\ntrait U extends T:\n  override def foo: Int\n  override def fooPoly[A](x: A): A\n\ntrait V extends T\n  type X = Some[Int]\n  def bar: Int\n  def barPoly[A](x: A): A\n```\n\n----------------------------------------\n\nTITLE: Defining Codec Givens with By-Name Context Parameters in Scala\nDESCRIPTION: Defines a `Codec` trait and `given` instances for `Int` and `Option`. The `optionCodec` demonstrates a by-name context parameter (`using ev: => Codec[T]`) to defer evaluation, useful for avoiding divergent expansions. It shows how `summon` finds the appropriate codec and how the by-name argument `ev` is only evaluated if needed (when writing `Some`). Dependencies: Scala 3 features (traits, givens, summon).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/by-name-context-parameters.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Codec[T]:\n  def write(x: T): Unit\n\ngiven intCodec: Codec[Int] = ???\n\ngiven optionCodec[T](using ev: => Codec[T]): Codec[Option[T]] with\n  def write(xo: Option[T]) = xo match\n    case Some(x) => ev.write(x)\n    case None =>\n\nval s = summon[Codec[Option[Int]]]\n\ns.write(Some(33))\ns.write(None)\n```\n\n----------------------------------------\n\nTITLE: Summoning All Given Instances for Tuple Types Using summonAll in Scala\nDESCRIPTION: This snippet uses the new 'summonAll' method to retrieve all given instances corresponding to the types specified in a type-level tuple. It demonstrates defining given instances of Int, String, and Double, and then summoning them as a tuple. This is a Scala 3 metaprogramming feature; requires Dotty 0.26.0-RC1+ and that the specified types in the tuple have given/implicit values available. Output: a tuple of the resolved given instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-07-27-26th-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ngiven as Int = 10\ngiven as String = \"foo\"\ngiven as Double = 1.2\nprintln(summonAll[Int *: String *: Double *: EmptyTuple])  // (10,foo,1.2)\n```\n\n----------------------------------------\n\nTITLE: Preventing Capability Escape with Dependent Function Types in Scala\nDESCRIPTION: Demonstrates how Scala 3's separation checking prevents capabilities (e.g., `File^`) from escaping their scope. The example shows a `withFile` function accepting a body function. Attempting to return a closure that captures the `File^` capability fails because the inferred dependent function type `(f: File^) -> () ->{f} Unit` does not match the required non-dependent type `() ->{cap} Unit`, violating separation rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef withFile[T](body: File^ => T): T =\n  ...\n\nwithFile: f =>\n  () => f.write(\"too late\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Inferred type of argument to withFile\n(f: File^) -> () ->{f} Unit\n\n// Expected type for the closure's result\n() ->{cap} Unit\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Conceptual expansion showing the violation\n{\n  def $anon(f: File^): () ->{cap} Unit =\n    () => f.write(\"too late\") // Body captures 'f', violating separation\n  $anon\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Opaque Type Members Within a Scala Class\nDESCRIPTION: Shows how opaque type members scoped to a Scala class ('Logarithms') offer encapsulated abstraction per instance: each 'Logarithms' instance defines a distinct Logarithm type over Double. This example presents the basic API for constructing and safely using logarithms, with method inputs as Doubles and Logarithm, and outputs as Logarithm or Option[Logarithm]. No external dependencies needed apart from Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/opaques.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass Logarithms:\n\n  opaque type Logarithm = Double\n\n  def apply(d: Double): Logarithm = math.log(d)\n\n  def safe(d: Double): Option[Logarithm] =\n    if d > 0.0 then Some(math.log(d)) else None\n\n  def mul(x: Logarithm, y: Logarithm) = x + y\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Parametric Type Leading to Run-Time Mutation in Scala\nDESCRIPTION: Shows that pattern matching on an unbounded type parameter T that is actually a representation of a mutable type like Array can cause mutation via pattern matching, thereby breaking abstraction and type safety without compiler warnings.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/matchable.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef f[T](x: T) = x match\n  case a: Array[Int] => a(0) = 0\nf(imm)\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Scala Debug Configuration in VSCode - JSON\nDESCRIPTION: Defines a minimal launch configuration for debugging a Scala main class using the VSCode launch.json format. Dependencies include the Metals VSCode extension and a Scala project set up in VSCode. The most important fields are 'type' (set to 'scala'), 'mainClass' (should be the full name of the Scala object/class with main method), and 'args' for any arguments. This template must be edited to reflect your specific entry point and arguments. The output is a launch configuration recognized by VSCode for initiating the debugger; limitations include the need for correct class and project paths.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/ide-debugging.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"type\": \"scala\",\n  \"request\": \"launch\",\n  \"name\": \"Untitled\",\n  \"mainClass\": \"???\",\n  \"args\": [],\n  \"jvmOptions\": [],\n  \"env\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Expanded form of a right-associative extension method\nDESCRIPTION: Showcases how a method like `+::` would be expanded internally to accommodate the parameter swap, illustrating the altered order of leading, extension, and trailing parameters. This clarifies the transformation for both implementation and comprehension.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/right-associative-extension-methods.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nextension def +:: (using a: A, b: B)(using c: C)\n                    (y: Y)\n                    (using d: D)\n                    (x: X)\n                    (using e: E)(z: Z)\n```\n\n----------------------------------------\n\nTITLE: Invoking Generic Extension Methods with Explicit Method Type Arguments in Scala\nDESCRIPTION: Shows how to call a generic extension method (`sumBy`) while explicitly providing the type argument (`[Int]`) for the *method's* type parameter (`U`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nList(\"a\", \"bb\", \"ccc\").sumBy[Int](_.length)\n```\n\n----------------------------------------\n\nTITLE: Transformations for named and default arguments\nDESCRIPTION: Explains how Scala 3 internally rewrites method calls with named arguments and default parameters into block expressions that initialize variables, handle argument passing, and assign default values for unspecified parameters. The transformation ensures correct ordering and scoping of arguments, fostering type safety and explicit parameter management.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Simplification Rules for Covariant and Contravariant Types - Scala\nDESCRIPTION: This snippet shows how intersection types involving type constructors can be simplified based on variance annotations. For covariant type constructors `C`, the intersection `C[A] & C[B]` can be simplified to `C[A & B]`. For contravariant constructors, `C[A] & C[B]` simplifies to `C[A | B]` (union type). These simplifications are supported by formal subtyping derivations displayed as inference rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/intersection-types-spec.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n- If `C` is covariant, `C[A] & C[B] ~> C[A & B]`\n- If `C` is contravariant, `C[A] & C[B] ~> C[A | B]`\n```\n\nLANGUAGE: scala\nCODE:\n```\n    A <: A                  B <: B\n  ----------               ---------\n  A & B <: A               A & B <: B\n---------------         -----------------\nC[A & B] <: C[A]          C[A & B] <: C[B]\n------------------------------------------\n      C[A & B] <: C[A] & C[B]\n```\n\nLANGUAGE: scala\nCODE:\n```\n    A <: A                        B <: B\n  ----------                     ---------\n  A <: A | B                     B <: A | B\n-------------------           ----------------\nC[A | B] <: C[A]              C[A | B] <: C[B]\n--------------------------------------------------\n            C[A | B] <: C[A] & C[B]\n```\n\n----------------------------------------\n\nTITLE: Utility Methods in the Scala 3 `Type` Companion Object\nDESCRIPTION: Details the static utility methods provided by the `Type` companion object. Key methods include the intrinsic `given Type.of[T]` which allows the compiler to generate `Type[T]` instances at runtime, `Type.show` for getting a string representation useful for debugging, and `valueOfConstant`/`valueOfTuple` to extract constant values from singleton types or tuples thereof. These operations typically require an implicit `Quotes` instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nobject Type:\n  given of: [T <: AnyKind] => Quotes => Type[T] = ...\n  def show[T <: AnyKind](using Type[T])(using Quotes): String = ...\n  def valueOfConstant[T](using Type[T])(using Quotes): Option[T] = ...\n  def valueOfTuple[T <: Tuple](using Type[T])(using Quotes): Option[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Implementing a Boolean Fixed-Arity Extractor in Scala\nDESCRIPTION: Defines an object exposing `unapply` that tests a property and returns a Boolean result, supporting boolean pattern matching. This example examines string length parity, assigning matched values to variables in the pattern match. Requires only core Scala and an understanding of pattern matching. Input is a string, and output behavior depends on match result; there are no particular limitations except the standard ones of boolean extractors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/pattern-matching.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject Even:\n  def unapply(s: String): Boolean = s.size % 2 == 0\n\n\"even\" match\n  case s @ Even() => println(s\"$s has an even number of characters\")\n  case s          => println(s\"$s has an odd number of characters\")\n\n// even has an even number of characters\n```\n\n----------------------------------------\n\nTITLE: Defining and Expanding a Recursive Inline Method in Scala\nDESCRIPTION: Defines a recursive `power` function using `inline`. When called with a constant exponent (e.g., `10`), the compiler unrolls the recursion into straight-line code by repeatedly inlining the method body. The example comment shows the conceptual translation, eliminating recursion. The maximum inline depth is controlled by `-Xmax-inlines` (default 32).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ninline def power(x: Double, n: Int): Double =\n  if n == 0 then 1.0\n  else if n == 1 then x\n  else\n    val y = power(x, n / 2)\n    if n % 2 == 0 then y * y else y * y * x\n\npower(expr, 10)\n// translates to\n//\n//   val x = expr\n//   val y1 = x * x   // ^2\n//   val y2 = y1 * y1 // ^4\n//   val y3 = y2 * x  // ^5\n//   y3 * y3          // ^10\n```\n\n----------------------------------------\n\nTITLE: Opaque Type Bounds for Permission Sets in Scala 3\nDESCRIPTION: This code defines opaque type aliases for permission management with bounds: 'Permission' (subtype of 'Permissions & PermissionChoice'), 'Permissions', and 'PermissionChoice', all represented as 'Int'. Extension methods enable combining permissions using bitwise operators. This pattern enforces type safety while allowing flexible permission sets for clients.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/opaques.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nobject Access:\n\n  opaque type Permissions = Int\n  opaque type PermissionChoice = Int\n  opaque type Permission <: Permissions & PermissionChoice = Int\n\n  extension (x: PermissionChoice)\n    def | (y: PermissionChoice): PermissionChoice = x | y\n  extension (x: Permissions)\n    def & (y: Permissions): Permissions = x & y\n  extension (granted: Permissions)\n    def is(required: Permissions) = (granted & required) == required\n    def isOneOf(required: PermissionChoice) = (granted & required) != 0\n\n  val NoPermission: Permission = 0\n  val Read: Permission = 1\n  val Write: Permission = 2\n  val ReadWrite: Permissions = Read | Write\n  val ReadOrWrite: PermissionChoice = Read | Write\n\nend Access\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Class with Export Keyword\nDESCRIPTION: Demonstrates the use of the new `export` keyword in Scala to define aliases for selected members of composed objects (`printUnit`, `scanUnit`). It shows how to re-export all members except one (`status => _`) and selectively re-export specific members (`scanUnit.scan`), promoting composition over inheritance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-04-15-14th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass BitMap\nclass InkJet\nclass Printer {\n  type PrinterType\n  def print(bits: BitMap): Unit = ???\n  def status: List[String] = ???\n}\nclass Scanner {\n  def scan(): BitMap = ???\n  def status: List[String] = ???\n}\nclass Copier {\n  private val printUnit = new Printer { type PrinterType = InkJet }\n  private val scanUnit = new Scanner\n  export scanUnit.scan\n  export printUnit.{status => _, _}\n  def status: List[String] = printUnit.status ++ scanUnit.status\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Binding Issues in Pattern Matching (Scala)\nDESCRIPTION: Shows a pattern match on `List[Int]` using a type pattern `case lst : List[a] =>`. This highlights a known issue where the type variable `a` bound within the pattern is treated as a fresh type, and necessary constraints (like `a =:= Int` or `a <: Int`) are not automatically captured or recorded by the GADT mechanism in this specific scenario.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/gadts.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n(list : List[Int]) match {\n  case lst : List[a] =>\n    // a is a new type bound in the pattern.\n    // We do not record any information about a.\n    // We should know that a <: Int.\n    // (Or it's fine to just have a =:= Int.)\n    // We would not have this issue if we used a custom unapply.\n    // Type case patterns create a fresh symbol even if they shouldn't.\n    // (See indexPattern in Typer.)\n}\n```\n\n----------------------------------------\n\nTITLE: Macro Implementation for Compile-Time Validation in Scala\nDESCRIPTION: Implements the fromDigitsImpl macro that accepts an Expr[String] and generates an Expr[BigFloat]. It checks if the string argument is a literal, attempts the conversion using apply, and emits a compile-time error if FromDigitsException is thrown. For non-constant arguments, it defers processing to runtime. Requires 'Quotes' context import. Inputs: Expr[String] for digits; Outputs: Expr[BigFloat] or compile-time error.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nprivate def fromDigitsImpl(digits: Expr[String])(using ctx: Quotes): Expr[BigFloat] =\n  digits.value match\n    case Some(ds) =>\n      try\n        val BigFloat(m, e) = apply(ds)\n        '{BigFloat(${Expr(m)}, ${Expr(e)})}\n      catch case ex: FromDigits.FromDigitsException =>\n        ctx.error(ex.getMessage)\n        '{BigFloat(0, 0)}\n    case None =>\n      '{apply($digits)}\n```\n\n----------------------------------------\n\nTITLE: Producing Compile-time Errors Using scala.compiletime.error in Scala\nDESCRIPTION: Demonstrates the use of `inline def error(inline msg: String): Nothing` to produce user-defined compile-time error messages during inline expansion. When the inline method calling `error` is instantiated, the compiler emits the specified error message. The examples include a fixed error message and an error message constructed dynamically using `codeOf` to show the failed expression. It requires importing `error` and `codeOf` from scala.compiletime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/compiletime-ops.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.{error, codeOf}\n\ninline def fail() =\n  error(\"failed for a reason\")\n\nfail() // error: failed for a reason\n\ninline def fail(inline p1: Any) =\n  error(\"failed on: \" + codeOf(p1))\n\nfail(identity(\"foo\")) // error: failed on: identity[String](\"foo\")\n```\n\n----------------------------------------\n\nTITLE: Importing Multiple Type Aliases with the Same Name in Scala 3\nDESCRIPTION: This snippet shows how multiple bindings of a type identifier to the same underlying type are permitted when imported using wildcard imports with the same binding precedence. It imports type aliases named T from different objects which all alias to the same annotation. It demonstrates its use as an annotation on a method and highlights that the method itself is not tail recursive. The snippet requires Scala 3 and annotation support.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/02-identifiers-names-and-scopes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject X { type T = annotation.tailrec }\nobject Y { type T = annotation.tailrec }\nobject Z {\n  import X.*, Y.*, annotation.tailrec as T  // OK, all T mean tailrec\n  @T def f: Int = { f ; 42 }                // error, f is not tail recursive\n}\n```\n\n----------------------------------------\n\nTITLE: Modifications for Experimental Features in Scala 3 Compiler\nDESCRIPTION: This snippet involves code related to enabling and managing experimental features such as named tuples, change rules, and match type amendments within the Scala 3 compiler. It likely includes configurations or annotations to control experimental mode activation and feature-specific annotations, depending on import statements or feature flags.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.5.0-RC1.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n# Experimental Changes\n\n- Named tuples second implementation [#19174](https://github.com/lampepfl/dotty/pull/19174)\n- Change rules for given prioritization [#19300](https://github.com/lampepfl/dotty/pull/19300)\n- Enable experimental mode when experimental feature is imported [#19807](https://github.com/lampepfl/dotty/pull/19807)\n- Add message parameter to `@experimental` annotation [#19935](https://github.com/lampepfl/dotty/pull/19935)\n- Implement match type amendment: extractors follow aliases and singletons [#20161](https://github.com/lampepfl/dotty/pull/20161)\n```\n\n----------------------------------------\n\nTITLE: Erasure Rules for Intersection Types - Pseudocode\nDESCRIPTION: This snippet defines the erasure strategy for intersection types `S & T` in Scala 3 as pseudocode. The erased type is the greatest lower bound (glb) of the erased types of `S` and `T`. Rules demonstrate how to compute the glb for arrays and other types, including fallback strategies based on subtype relations and trait status, ensuring proper runtime representation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/intersection-types-spec.md#_snippet_3\n\nLANGUAGE: pseudocode\nCODE:\n```\n|S & T| = glb(|S|, |T|)\n\nglb(JArray(A), JArray(B)) = JArray(glb(A, B))\nglb(JArray(T), _)         = JArray(T)\nglb(_, JArray(T))         = JArray(T)\nglb(A, B)                 = A                     if A extends B\nglb(A, B)                 = B                     if B extends A\nglb(A, _)                 = A                     if A is not a trait\nglb(_, B)                 = B                     if B is not a trait\nglb(A, _)                 = A                     // use first\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution Across Multiple Curried Argument Lists in Scala 3 - Scala\nDESCRIPTION: Shows overload resolution for methods with three argument lists, where the last argument list differs in parameter types (Int vs String). Scala 3 correctly resolves calls based on the types provided in all argument lists, supporting multiple overloads distinguished by deeper argument lists. This snippet exemplifies the broader scope of overload consideration for chained argument lists enabled in Scala 3 and relies on the updated overloading strategy per SLS §6.26.3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/overload-resolution.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef g(x: Int)(y: Int)(z: Int): Int = 0\ndef g(x: Int)(y: Int)(z: String): Int = 0\n\ng(2)(3)(4)     // ok\ng(2)(3)(\"\")    // ok\n```\n\n----------------------------------------\n\nTITLE: Defining Type Lambda Syntax in EBNF\nDESCRIPTION: This EBNF snippet defines the formal grammar for type lambdas in Scala 3. It specifies how a TypeParamClause ([...]...) combines with a result Type using '=>>' to form a type lambda, detailing the structure of type parameters (TypeParam) and their bounds (TypeBounds).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas-spec.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nType            ::=  ... |  TypeParamClause ‘=>>’ Type\nTypeParamClause ::=  ‘[’ TypeParam {‘,’ TypeParam} ‘]’\nTypeParam       ::=  {Annotation} (id [HkTypeParamClause] | ‘_’) TypeBounds\nTypeBounds      ::=  [‘>:’ Type] [‘<:’ Type]\n```\n\n----------------------------------------\n\nTITLE: Informational Definition of Scala `Array` Class\nDESCRIPTION: Provides an informational definition of the `scala.Array` final class. It notes that array operations desugar to the underlying platform's operations. The class definition includes `length`, `apply` (indexing), `update`, and `clone` methods, and mentions its implementation (`java.io.Serializable`, `java.lang.Cloneable`). It also discusses type erasure and representation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nfinal class Array[T](_length: Int)\nextends java.io.Serializable with java.lang.Cloneable {\n  def length: Int = ...\n  def apply(i: Int): T = ...\n  def update(i: Int, x: T): Unit = ...\n  override def clone(): Array[T] = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Option ADT with Explicit Extends Clauses\nDESCRIPTION: This snippet demonstrates the `Option` ADT definition with explicit `extends` clauses for its cases. It shows how `Some` extends `Option[T]` and how the compiler infers `Option[Nothing]` for the `None` case due to the covariant type parameter. Explicit clauses are useful for understanding or when the default inference isn't desired.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/adts.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nenum Option[+T]:\n  case Some(x: T) extends Option[T]\n  case None       extends Option[Nothing]\n```\n\n----------------------------------------\n\nTITLE: Inconsistent Method Definition in Scala 2 Libraries\nDESCRIPTION: Shows an example of inconsistent method definition in Scala 2's standard library, where toInt() uses parentheses unlike similar methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/auto-apply.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef toInt(): Int\n```\n\n----------------------------------------\n\nTITLE: Variance checking with private class parameters in Scala 3\nDESCRIPTION: This example shows that private class parameters are not exempt from variance checking in Scala 3, resulting in an error when using a contravariant type parameter with a private val parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/this-qualifier.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n  class C[-T](private val t: T) // error\n```\n\n----------------------------------------\n\nTITLE: Example Inkuire Search Signatures in Scala\nDESCRIPTION: Illustrates example function signatures used as input queries for the Inkuire search engine. These Scala-like signatures demonstrate how to search for functions based on their type signatures, including generics (e.g., `A`, `B`), wildcards (`_`), and curried functions. Expected results (like `IterableOps.map` or `Function.const`) are indicated for each example signature, showcasing Inkuire's capabilities.\nSOURCE: https://github.com/scala/scala3/blob/main/scaladoc/resources/dotty_res/scripts/inkuire.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n- `Seq[Int] => (Int => Long) => Seq[Long]` -> `IterableOps.map`\n- `(A, B) => A` -> `Product2._1`\n- `Set[Long] => Long => Boolean` -> `SetOps.contains`\n- `BigDecimal => Byte` -> `ScalaNumericAnyConversions.toByte`\n- `Int => Long => Int` -> `Function.const`\n- `String => Int => Char` -> `StringOps.apply`\n```\n\n----------------------------------------\n\nTITLE: Applying 'into' Modifier to Function Argument Result - Scala\nDESCRIPTION: Defines the 'flatMap' method for List with a function argument whose result uses the 'into' modifier, enabling implicit conversions on the result of function application. The snippet illustrates how functions returning convertible values can be accepted without additional imports. Inputs are a function from A to a convertible type; output is a List of type B.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef flatMap[B](f: A => into IterableOnce[B]): List[B]\n```\n\n----------------------------------------\n\nTITLE: Multiple 'using' clauses in function definitions and applications\nDESCRIPTION: Illustrates functions with multiple 'using' clauses, showing their order and how they can be combined with normal parameters. Demonstrates valid function calls with multiple context parameters that normalize to a specific application.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/using-clauses.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(u: Universe)(using ctx: u.Context)(using s: ctx.Symbol, k: ctx.Kind) = ...\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject global extends Universe { type Context = ... }\n Givens:\n given ctx : global.Context with { type Symbol = ...; type Kind = ... }\n given sym : ctx.Symbol\ngiven kind: ctx.Kind\n\nf(global)\nf(global)(using ctx)\nf(global)(using ctx)(using sym, kind)\n```\n\n----------------------------------------\n\nTITLE: Given Disambiguation Preferring Most General in Scala 3.5\nDESCRIPTION: This example demonstrates the change in Scala 3.5 where, when several givens match an expected type, the most general one is chosen, contrasting prior preference for specificity. It defines classes A, B (extends A), and C (extends A) with givens for each. A call to summon[A] now returns given_A instead of being ambiguous. Dependencies are definitions of A, B, and C classes, and the corresponding givens.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/implicit-resolution.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass A\nclass B extends A\nclass C extends A\n\ngiven A = A()\ngiven B = B()\ngiven C = C()\n\nsummon[A]  // was ambiguous, will now return `given_A`\n\n```\n\n----------------------------------------\n\nTITLE: Updating implicit function type to Conversion in Scala 3\nDESCRIPTION: Example showing how implicit function types in Scala 2 need to be updated to use Conversion in Scala 3. Function parameters and implicit values must be changed, while call sites remain unchanged.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-conversions-spec.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Scala 2:\ndef foo(x: Int)(implicit conv: Int => String): String = x\n\n// Becomes with Scala 3:\ndef foo(x: Int)(implicit conv: Conversion[Int, String]): String = x\n\n// Call site is unchanged:\nfoo(4)(_.toString)\n\n// Scala 2:\nimplicit val myConverter: Int => String = _.toString\n\n// Becomes with Scala 3:\nimplicit val myConverter: Conversion[Int, String] = _.toString\n```\n\n----------------------------------------\n\nTITLE: Defining List Contains with Lower Bound and Universal Equality in Scala\nDESCRIPTION: This snippet shows a variance-correct way to define `List.contains` using a lower-bound type parameter `U >: T`. While satisfying variance rules, this version still relies on universal equality for the comparison `listElement == x`, effectively allowing the same broad, potentially unsafe applications as the `contains(x: Any)` signature it replaced in older Scala versions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ndef contains[U >: T](x: U): Boolean\n```\n\n----------------------------------------\n\nTITLE: Generated Code for Exports in Extensions in Scala 3\nDESCRIPTION: Displays the expanded Scala code resulting from the `export` clause used within the `extension (x: String)` example. It shows how the exported members (`*` and `capitalize` from `moreOps`) become direct extension methods on `String`, forwarding calls to the `moreOps` instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nextension (x: String)\n  def take(n: Int): String = x.substring(0, n)\n  def drop(n: Int): String = x.substring(n)\n  private def moreOps = StringOps(x)\n  def *(n: Int): String = moreOps.*(n)\n  def capitalize: String = moreOps.capitalize\n```\n\n----------------------------------------\n\nTITLE: Generated Code for Scala 3 Lazy Val Initialization\nDESCRIPTION: Illustrates the equivalent code generated by the Scala 3 compiler for a lazy val. It utilizes helper methods from `scala.runtime.LazyVals` and a bitmap field to manage the initialization state (0: uninitialized, 1: initializing, 2: concurrent readers, 3: initialized) in a thread-safe manner, minimizing deadlock risks as per SIP-20. `<RHS>` is the original initializer, `<field-id>` uniquely identifies the lazy val, and `<state-i>` represents initialization states.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/lazy-vals-init.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Foo {\n  import scala.runtime.LazyVals\n  var value_0: Int = _\n  var bitmap: Long = 0L\n  val bitmap_offset: Long = LazyVals.getOffset(classOf[LazyCell], \"bitmap\")\n\n  def bar(): Int = {\n    while (true) {\n      val flag = LazyVals.get(this, bitmap_offset)\n      val state = LazyVals.STATE(flag, <field-id>)\n\n      if (state == <state-3>) {\n        return value_0\n      } else if (state == <state-0>) {\n        if (LazyVals.CAS(this, bitmap_offset, flag, <state-1>, <field-id>)) {\n          try {\n            val result = <RHS>\n            value_0 = result\n            LazyVals.setFlag(this, bitmap_offset, <state-3>, <field-id>)\n            return result\n          }\n          catch {\n            case ex =>\n              LazyVals.setFlag(this, bitmap_offset, <state-0>, <field-id>)\n              throw ex\n          }\n        }\n      } else /* if (state == <state-1> || state == <state-2>) */ {\n        LazyVals.wait4Notification(this, bitmap_offset, flag, <field-id>)\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating End Markers for Various Constructs in Scala 3\nDESCRIPTION: This comprehensive Scala code snippet showcases the use of the optional `end` marker introduced in Scala 3 to explicitly delineate the end of indentation regions for various constructs including packages, classes, methods (`def`), constructors (`this`), conditional statements (`if`), value definitions (`val`, `var`), loops (`while`), exception handling (`try`, `finally`), pattern matching (`match`), objects (`object`), given instances (`given`), anonymous classes (`new`), and extension methods (`extension`). The specifier token following `end` must match the preceding construct.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\npackage p1.p2:\n\n  abstract class C():\n\n    def this(x: Int) =\n      this()\n      if x > 0 then\n        val a :: b =\n          x :: Nil\n        end val\n        var y =\n          x\n        end y\n        while y > 0 do\n          println(y)\n          y -= 1\n        end while\n        try\n          x match\n            case 0 => println(\"0\")\n            case _ =>\n          end match\n        finally\n          println(\"done\")\n        end try\n      end if\n    end this\n\n    def f: String\n  end C\n\n  object C:\n    given C =\n      new C:\n        def f = \"!\"\n        end f\n      end new\n    end given\n  end C\n\n  extension (x: C)\n    def ff: String = x.f ++ x.f\n  end extension\n\nend p2\n```\n\n----------------------------------------\n\nTITLE: Defining Transparent Inline Given Macro Scala 3\nDESCRIPTION: Defines an `inline` and `transparent` given alias named `mkAnnotations` that uses a macro (`${ ... }`) on its right-hand side to produce the given instance. The `transparent` modifier allows the compiler to see the specific subtype returned by the macro, potentially enabling further optimizations and type refinements at compile time.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/more-givens.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntransparent inline given mkAnnotations: [A, T] => Annotations[A, T] = ${\n```\n\n----------------------------------------\n\nTITLE: Simulating Extension Method with Scala 2 Implicit Class\nDESCRIPTION: Defines an implicit class `CircleDecorator` in Scala 2 that wraps a `Circle` instance and provides a `circumference` method. This simulates extension methods by implicitly converting `Circle` instances to `CircleDecorator` when the method is called.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit class CircleDecorator(c: Circle) extends AnyVal {\n  def circumference: Double = c.radius * math.Pi * 2\n}\n```\n\n----------------------------------------\n\nTITLE: Array Creation with Context Bound ClassTag in Scala - Scala\nDESCRIPTION: Defines a method mkArray that creates an array of a generic type T from a sequence of T elements, requiring an implicit ClassTag[T] to provide runtime type information. The method allocates an array of appropriate length and populates it by iterating over the input sequence. This approach supports creation of primitive arrays when applicable on the host platform, like JVM.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport reflect.ClassTag\ndef mkArray[T : ClassTag](elems: Seq[T]): Array[T] = {\n  val result = new Array[T](elems.length)\n  var i = 0\n  for (elem <- elems) {\n    result(i) = elem\n    i += 1\n  }\n  result\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Scala Code with Deprecated Symbol Literals - Shell\nDESCRIPTION: This snippet shows the error message generated by Scala's compiler when a deprecated symbol literal syntax ('abc) is used within a Scala 3 program. It captures the compilation failure and the suggested migration path by the compiler message. No dependencies other than the Scala 3 compiler are required. Inputs are the source code containing symbol literals, and output is the diagnostic error message.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/symlits.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nscalac Test.scala\n-- Error: Test.scala:1:25 ------------------------------------------------------------------------------------------------\n\n1 |@main def test = println('abc)\n  |                         ^\n  |                         symbol literal 'abc is no longer supported,\n  |                         use a string literal \"abc\" or an application Symbol(\"abc\") instead,\n  |                         or enclose in braces '{abc} if you want a quoted expression.\n  |                         For now, you can also `import language.deprecated.symbolLiterals` to accept\n  |                         the idiom, but this possibility might no longer be available in the future.\n1 error found\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional Implicit Value and Implicit Conversion in Scala\nDESCRIPTION: This snippet demonstrates two implicit definitions in Scala: the first one (`i1`) is a conditional implicit value that depends on another implicit parameter of type `T`, used typically for expressing type classes. The second (`i2`) is an implicit conversion from type `T` to `C[T]`, which can be more prone to misuse. The snippet serves to illustrate the syntactic similarity yet conceptual difference between conditional implicit values and implicit conversions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/contextual.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimplicit def i1(implicit x: T): C[T] = ...\nimplicit def i2(x: T): C[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Defining Named Given Instances in Scala\nDESCRIPTION: This snippet defines the `Ord` trait for ordering and provides named `given` instances. `intOrd` provides an ordering for integers, while `listOrd` provides an ordering for lists of a type `T`, depending on an implicit `Ord[T]` being available via a `using` clause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/givens.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Ord[T]:\n  def compare(x: T, y: T): Int\n  extension (x: T) def < (y: T) = compare(x, y) < 0\n  extension (x: T) def > (y: T) = compare(x, y) > 0\n\ngiven intOrd: Ord[Int] with\n  def compare(x: Int, y: Int) =\n    if x < y then -1 else if x > y then +1 else 0\n\ngiven listOrd[T](using ord: Ord[T]): Ord[List[T]] with\n\n  def compare(xs: List[T], ys: List[T]): Int = (xs, ys) match\n    case (Nil, Nil) => 0\n    case (Nil, _) => -1\n    case (_, Nil) => +1\n    case (x :: xs1, y :: ys1) =>\n      val fst = ord.compare(x, y)\n      if fst != 0 then fst else compare(xs1, ys1)\n```\n\n----------------------------------------\n\nTITLE: Safe Initialization Checks with `-Ysafe-init` Flag in Scala 3\nDESCRIPTION: This code demonstrates the use of safe initialization checks by defining an abstract class and a subclass with dependent field initializations, which can lead to runtime errors if fields are accessed before initialization. When compiled with the `-Ysafe-init` flag, the compiler detects potential unsafe field access, providing a compile-time error with detailed trace. Dependencies include Scala 3 compiler and safe initialization feature documentation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-03-18-23rd-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class AbstractFile {\n   def name: String\n   val extension: String = name.reverse.dropWhile(_ != '.').reverse\n}\n\nclass RemoteFile(url: String) extends AbstractFile {\n   val localFile: String = url.hashCode + \".tmp\"\n   def name: String = localFile\n}\n```\n\n----------------------------------------\n\nTITLE: Type Signature Transformation for Functor.map with Substitution in Scala\nDESCRIPTION: This sequence of code snippets details how the map method of a Functor instantiated with List expands via higher-kinded type substitution. It shows the transformation from a generic projected type using Functor's type member to a concrete function type, highlighting the process of substituting type arguments and resolving #Apply projections. The output demonstrates that mapping with Functor[List] is ultimately just a function from List[A] to List[B].\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ns(F { type $hkArg$0 = A } # Apply  =>  F { type $hkArg$0 = B } # Apply)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nLambda1 { type Apply = List[$hkArg$0] } { type $hkArg$0 = A } # Apply\n =>  Lambda1 { type Apply = List[$hkArg$0] } { type $hkArg$0 = B } # Apply\n```\n\nLANGUAGE: Scala\nCODE:\n```\nList[A] => List[B]\n```\n\n----------------------------------------\n\nTITLE: Performing Equality Checks with Null in Scala\nDESCRIPTION: Shows the rules for equality comparisons (`==`, `!=`, `eq`, `ne`) involving `null` when explicit nulls are enabled. Direct comparison between a non-nullable type and `null` is an error. Comparisons are allowed for nullable types (`T | Null`), `Any`, or `Null`. Type hints like `: Any` or `: String | Null` can be used to allow comparisons.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval x: String = ???\nval y: String | Null = ???\n\nx == null       // error: Values of types String and Null cannot be compared with == or !=\nx eq null       // error\n\"hello\" == null // error\n\ny == null       // ok\ny == x          // ok\n\n(x: String | Null) == null  // ok\n(x: Any) == null            // ok\n```\n\n----------------------------------------\n\nTITLE: Grammar for Colon-Based Lambda and Argument Blocks in Scala (EBNF)\nDESCRIPTION: This EBNF code fragment updates Scala's expression grammar to allow colon-based argument sections and multi-line lambdas. It adds 'ColonArgument' to the set of options for SimpleExpr and InfixExpr, detailing how a colon with optional lambda parameters triggers an indented block as the argument. The grammar is a reference for implementing or understanding the latest parsing changes in Scala's compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_9\n\nLANGUAGE: EBNF\nCODE:\n```\nSimpleExpr       ::=  ...\n                   |  SimpleExpr ColonArgument\nInfixExpr        ::=  ...\n                   |  InfixExpr id ColonArgument\nColonArgument    ::=  colon [LambdaStart]\n                      indent (CaseClauses | Block) outdent\nLambdaStart      ::=  FunParams (‘=>’ | ‘?=>’)\n                   |  HkTypeParamClause ‘=>’\n```\n\n----------------------------------------\n\nTITLE: Invoking Generic Extensions as Non-Extension Methods in Scala\nDESCRIPTION: Demonstrates how to pass type arguments for the *extension's* type parameter (`T`) by calling the method as if it were a static method, passing the receiver (`List(...)`) explicitly as the first argument. This syntax is necessary to specify extension type parameters and can also be combined with method type parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nsumBy[String](List(\"a\", \"bb\", \"ccc\"))(_.length)\n\n// Or, when passing both type arguments:\nsumBy[String](List(\"a\", \"bb\", \"ccc\"))[Int](_.length)\n```\n\n----------------------------------------\n\nTITLE: Representations of Scala 3 Types\nDESCRIPTION: This snippet illustrates how various Scala 3 types are represented internally using classes like TermRef, TypeRef, RefinedType, and others. It explains the correspondence between high-level type syntax and its internal representation for type checking and compiler operations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/type-system.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nType                      | Representation\n ------------------------- | -----------------------------\n `p.x.type`                | `TermRef(p, x)`\n `p#T`                     | `TypeRef(p, T)`\n `p.x.T` == `p.x.type#T`   | `TypeRef(TermRef(p, x), T)`\n `this.type`               | `ThisType`\n `A & B`                   | `AndType(A, B)`\n <code>A \\| B</code>       | `OrType(A, B)`\n `=> T`                    | `ExprType(T)`\n `p { refinedName }`       | `RefinedType(p, refinedName)`\n type of the value `super` | `SuperType`\n `type T >: A <: B`        | `TypeRef` with underlying type `RealTypeBounds(A, B)`\n `type T = A`              | `TypeRef` with underlying type `TypeAlias(A)`\n `class p.C ...`           | `ClassInfo(p, C, ...)\n```\n\n----------------------------------------\n\nTITLE: Accessing Enum Ordinal Values in Scala\nDESCRIPTION: Shows how to retrieve the zero-based integer index (ordinal) of an enum value using the `ordinal` method. Assigns `Color.Red` to `red` and then calls `red.ordinal`, which returns `0`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val red = Color.Red\nval red: Color = Red\nscala> red.ordinal\nval res0: Int = 0\n```\n\n----------------------------------------\n\nTITLE: Implementing eqSum for Sum Types in Scala\nDESCRIPTION: Defines the `eqSum` helper function which creates an `Eq[T]` instance for sum types (ADTs). It takes a `Mirror.SumOf[T]` and a list of `Eq` instances for the subtypes. The `eqv` implementation uses the mirror's `ordinal` method to check if both values belong to the same subtype and then uses the corresponding subtype's `Eq` instance via the `check` helper.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.deriving.Mirror\n\ndef eqSum[T](s: Mirror.SumOf[T], elems: List[Eq[_]]): Eq[T] =\n  new Eq[T]:\n    def eqv(x: T, y: T): Boolean =\n      val ordx = s.ordinal(x)                            // (3)\n      (s.ordinal(y) == ordx) && check(elems(ordx))(x, y) // (4)\n```\n\n----------------------------------------\n\nTITLE: Replacing Procedure Syntax with Standard Method Definitions in Scala 3 Scala\nDESCRIPTION: Illustrates the removal of procedure syntax in Scala 3, which previously allowed method definitions without an explicit result type or '=' sign. The snippet shows both the deprecated syntax and the two recommended alternatives using an explicit Unit return type or '=' to begin the method body. Usage of the old syntax requires the '-source:3.0-migration' flag or the Scalafix tool for automatic rewriting. Inputs are method definitions; outputs are valid Scala 3 methods complying with the new syntax rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/A2-scala-2-compatibility.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef f() { ... }\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f() = { ... }\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(): Unit = { ... }\n```\n\n----------------------------------------\n\nTITLE: Using Java Enum Methods on a Scala Enum\nDESCRIPTION: Shows an example of using a method inherited from `java.lang.Enum`, such as `compareTo`, on a Scala enum (`Color`) that has been defined to extend `java.lang.Enum[Color]`. The result indicates the relative order based on ordinal values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nscala> Color.Red.compareTo(Color.Green)\nval res15: Int = -1\n```\n\n----------------------------------------\n\nTITLE: Defining for-comprehensions with aliases in Scala\nDESCRIPTION: This snippet demonstrates how to define a for-comprehension in Scala 3.7 that starts with alias assignments, a feature enabled under -preview mode. It creates two list aliases and iterates over both, yielding the sum of each pair of elements. No explicit dependencies are required apart from standard Scala collections. The inputs are implicit within the comprehension, and the output is a collection of summed pairs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/preview/better-fors.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  as = List(1, 2, 3)\n  bs = List(4, 5, 6)\n  a <- as\n  b <- bs\nyield a + b\n```\n\n----------------------------------------\n\nTITLE: TASTy Pickle Representation of Type Expressions\nDESCRIPTION: Example of how type expressions with type holes are represented in the TASTy pickle format, preserving information about type bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ntasty\"\"\"\\n  type U = << 0; Nothing..Any; >>\\n  List.empty[U]\\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Listing Compiler Sub-packages in Dotty Scala3 - Scala\nDESCRIPTION: This snippet shows the hierarchical package layout of the Dotty compiler core located under the dotc package, including sub-packages dedicated to AST, parsing, typing, reporting, and transformations. It enumerates the major compiler components and their responsibilities ranging from syntax tree representation to utility modules, forming the structural foundation of the compiler implementation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/overall-structure.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n\n.\n├── ast                 // Abstract syntax trees\n├── config              // Compiler configuration, settings, platform specific definitions.\n├── core                // Core data structures and operations, with specific subpackages for:\n│   ├── classfile       // Reading of Java classfiles into core data structures\n│   ├── tasty           // Reading and writing of TASTY files to/from core data structures\n│   └── unpickleScala2  // Reading of Scala2 symbol information into core data structures\n├── parsing             // Scanner and parser\n├── printing            // Pretty-printing trees, types and other data\n├── repl                // The interactive REPL\n├── reporting           // Reporting of error messages, warnings and other info.\n├── rewrites            // Helpers for rewriting Scala 2's constructs into dotty's.\n├── semanticdb          // Helpers for exporting semanticdb from trees.\n├── transform           // Miniphases and helpers for tree transformations.\n├── typer               // Type-checking and other frontend phases\n└── util                // General purpose utility classes and modules.\n\n```\n\n----------------------------------------\n\nTITLE: Quotes Interface for Reflection and Quotation APIs in Scala 3 Macros\nDESCRIPTION: Defines the Quotes trait, which centralizes all reflection and macro operations. It extends with methods for displaying expressions, pattern matching, and extracting values. The Quotes object also manages the current splicing scope via Scope objects, and provides access to reflection APIs and quote unpickling mechanisms necessary for macro expansion and pattern matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Quotes:\n  this: runtime.QuoteUnpickler & runtime.QuoteMatching =>\n\n  extension [T](self: Expr[T])\n    def show: String\n    def matches(that: Expr[Any]): Boolean\n    def value(using FromExpr[T]): Option[T]\n    def valueOrAbort(using FromExpr[T]): T\n  end extension\n\n  extension (self: Expr[Any])\n    def isExprOf[X](using Type[X]): Boolean\n    def asExprOf[X](using Type[X]): Expr[X]\n  end extension\n\n  // Internal reflect object and other methods are part of implementation\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Mixed Numeric Types in Scala\nDESCRIPTION: This snippet demonstrates how a Scala list containing values of type Double and Int is inferred as List[Double] due to weak conformance in previous versions. This behavior permitted easier interoperability between integer and floating-point literals within collections. Dependencies include the standard Scala library and numeric literals, and the expected input is a sequence of mixed numeric literals. The output is a strongly-typed List, previously coerced to List[Double]. In Scala 3, this behavior has changed and now relies less on weak conformance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/weak-conformance.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nList(1.0, math.sqrt(3.0), 0, -3.3) // : List[Double]\n```\n\n----------------------------------------\n\nTITLE: Creating a lazy list with `tabulate` function in Scala 3\nDESCRIPTION: This function generates a lazy list of length `n`, with each element produced by the generator `gen`. It uses a recursive inner function `recur`, which constructs a list node with potential side effects in `gen(i)`. The tail remains lazy and effects are captured, illustrating effectful delayed list construction.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_30\n\nLANGUAGE: Scala\nCODE:\n```\ndef tabulate[A](n: Int)(gen: Int => A) =\n  def recur(i: Int): LzyList[A]^{gen} =\n    if i == n then LzyNil\n    else gen(i) #: recur(i + 1)\n  recur(0)\n```\n\n----------------------------------------\n\nTITLE: Extending Parameterized Traits Without Arguments in Scala\nDESCRIPTION: This snippet defines a new trait (`FormalGreeting`) by extending a parameterized trait (`Greeting`) without providing arguments, as required by Scala 3's inheritance rules. The snippet showcases overriding a method of the parent trait. Dependencies: parent trait expects a constructor parameter but child trait does not supply it. No input/output without further implementation. Limitation: extending a class from `FormalGreeting` alone will lead to a compilation error unless trait parameters are supplied elsewhere.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/trait-parameters.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait FormalGreeting extends Greeting:\n  override def msg = s\"How do you do, $name\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Scala Eq Derivation for Product Types\nDESCRIPTION: Defines the `eqProduct` function in Scala, which constructs an `Eq` instance for product types (like case classes). It implements the `eqv` method by iterating over the fields of the product types (`x` and `y`) using the `iterable` helper, zipping them with the list of element `Eq` instances (`elems`), and then using `forall` with the `check` helper to compare each corresponding field.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.deriving.Mirror\n\ndef eqProduct[T](p: Mirror.ProductOf[T], elems: => List[Eq[?]]): Eq[T] = \n  new Eq[T]:\n    def eqv(x: T, y: T): Boolean =\n      iterable(x).lazyZip(iterable(y)).lazyZip(elems).forall(check)\n```\n\n----------------------------------------\n\nTITLE: Comparing Legacy and New Type Class Syntax for TupleOf Implementation in Scala 3\nDESCRIPTION: Demonstrates two implementations of a TupleOf type class that handles tuple mapping operations: first using the legacy syntax with explicit tracked parameters, then using the new cleaner type class syntax with context bounds. Shows how the new syntax is more concise and idiomatic.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/typeclasses.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ninfix abstract class TupleOf[T, +A]:\n  type Mapped[+A] <: Tuple\n  def map[B](x: T)(f: A => B): Mapped[B]\n\nobject TupleOf:\n\n  given TupleOf[EmptyTuple, Nothing] with\n    type Mapped[+A] = EmptyTuple\n    def map[B](x: EmptyTuple)(f: Nothing => B): Mapped[B] = x\n\n  given [A, Rest <: Tuple](using tracked val tup: Rest TupleOf A): TupleOf[A *: Rest, A] with\n    type Mapped[+A] = A *: tup.Mapped[A]\n    def map[B](x: A *: Rest)(f: A => B): Mapped[B] =\n      f(x.head) *: tup.map(x.tail)(f)\n```\n\nLANGUAGE: scala\nCODE:\n```\n//> using options -language:experimental.modularity -source future\n\ntrait TupleOf[+A]:\n  type Self\n  type Mapped[+A] <: Tuple\n  def map[B](x: Self)(f: A => B): Mapped[B]\n\nobject TupleOf:\n\n  given EmptyTuple is TupleOf[Nothing]:\n    type Mapped[+A] = EmptyTuple\n    def map[B](x: EmptyTuple)(f: Nothing => B): Mapped[B] = x\n\n  given [A, Rest <: Tuple : TupleOf[A]] => A *: Rest is TupleOf[A]:\n    type Mapped[+A] = A *: Rest.Mapped[A]\n    def map[B](x: A *: Rest)(f: A => B): Mapped[B] =\n      f(x.head) *: Rest.map(x.tail)(f)\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Unpickling: Combined Hole Lambdas Dispatch\nDESCRIPTION: Presents an optimization technique for evaluating multiple splice holes during unpickling. All individual hole lambdas are combined into a single dispatch lambda that uses the hole index to select the appropriate branch and arguments for evaluation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\n(idx: Int, args: Seq[Any]) =>\n  idx match\n    case 0 => // for << 0; Double; x, n >>\n      val x = args(0).asInstanceOf[Expr[Double]]\n      val n = args(1).asInstanceOf[Expr[Int]]\n      powerCode(x, n)\n    case 1 => // for << 1; Double; n >>\n      val n = args(0).asInstanceOf[Expr[Int]]\n      powerCode('{2}, n)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Research Scala 3 Compiler Plugin Template (Scala)\nDESCRIPTION: Shows a basic template for creating a research compiler plugin in Scala 3. Research plugins extend `ResearchPlugin` and implement the `init` method, which receives the compiler's phase pipeline and plugin options. This method can modify the pipeline (add, remove, replace phases) before returning the updated version, allowing deep compiler customization, typically restricted to non-production compiler releases.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/compiler-plugins.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport dotty.tools.dotc.core.Contexts.Context\nimport dotty.tools.dotc.core.Phases.Phase\nimport dotty.tools.dotc.plugins.ResearchPlugin\n\nclass DummyResearchPlugin extends ResearchPlugin:\n  val name: String = \"dummy\"\n  override val description: String = \"dummy research plugin\"\n\n  def init(options: List[String], phases: List[List[Phase]])(implicit ctx: Context): List[List[Phase]] =\n    phases\nend DummyResearchPlugin\n```\n\n----------------------------------------\n\nTITLE: Type Behavior of Enum Case Constructors in Scala REPL\nDESCRIPTION: Demonstrates how applying enum case constructors like Option.Some(\"hello\") and Option.None yields values whose types are widened to the underlying enum type Option with appropriate type parameters. It contrasts this with explicitly constructing case classes via 'new' which preserves the specific case class type, illustrating Scala 3 enum type widening behavior for constructor applications.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/adts.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> Option.Some(\"hello\")\nval res1: t2.Option[String] = Some(hello)\n\nscala> Option.None\nval res2: t2.Option[Nothing] = None\n\nscala> new Option.Some(2)\nval res3: Option.Some[Int] = Some(2)\nscala> val x: Option.Some[Int] = Option.Some(3)\nval res4: Option.Some[Int] = Some(3)\n```\n\n----------------------------------------\n\nTITLE: Defining Traits and Type Inference with Case Objects in Scala\nDESCRIPTION: This snippet demonstrates creating a trait and several case objects that extend it, then uses a conditional to create a Set of those objects. It illustrates Scala's type inference, where inferred types can include superfluous parent traits such as Product and Serializable. No external dependencies are required. Inputs are the trait and objects; output is a Set whose inferred type exposes the type-inference issue.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/transparent-traits.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Kind\ncase object Var extends Kind\ncase object Val extends Kind\nval x = Set(if condition then Val else Var)\n```\n\n----------------------------------------\n\nTITLE: Invalid Export Clause: Duplicate Renaming Target in Scala 3\nDESCRIPTION: Presents an invalid `export` clause demonstrating Restriction 4: All target names within renaming selectors in the same clause must be unique. Here, `C` is used as the target name twice (`A as C`, `B as C`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nexport {A as C, B as C}   // error: duplicate renaming\n```\n\n----------------------------------------\n\nTITLE: Example of cast to refine types for flow typing in Scala\nDESCRIPTION: Shows how Scala performs runtime castings during flow typing to refine the types of variables in nullable chains, enabling safe member access. It uses an intersection type to reflect the non-nullable refinement, supporting complex path-sensitive null analysis in the type system.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/explicit-nulls.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef f = \n   val l: Node | Null = ???\n   if l != null && l.$asInstanceOf$[l.type & Node].next != null then\n      val third:\n         l.$asInstanceOf$[l.type & Node].next.$asInstanceOf$[(l.type & Node).next.type & Node].next.type = \n         l.$asInstanceOf$[l.type & Node].next.$asInstanceOf$[(l.type & Node).next.type & Node].next\n```\n\n----------------------------------------\n\nTITLE: Using Basic Dependent Function Types in Scala\nDESCRIPTION: Demonstrates the definition and usage of both regular (`DF`) and implicit (`IDF`) dependent function types in Scala 3. It defines a trait `C` with a path-dependent type `M`, creates instances of the dependent function types, applies them to an instance of `C`, and prints the results, showing how the return type depends on the input value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/dependent-function-types-spec.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait C { type M; val m: M }\n\ntype DF = (x: C) => x.M\n\ntype IDF = (x: C) ?=> x.M\n\n@main def test =\n  val c = new C { type M = Int; val m = 3 }\n\n  val depfun: DF = (x: C) => x.m\n  val t = depfun(c)\n  println(s\"t=$t\")   // prints \"t=3\"\n\n  val idepfun: IDF = summon[C].m\n  val u = idepfun(using c)\n  println(s\"u=$u\")   // prints \"u=3\"\n```\n\n----------------------------------------\n\nTITLE: Declaring a List of Pairs in Scala\nDESCRIPTION: This snippet shows the declaration of a variable 'xs' as a List containing pairs of integers (tuples of type (Int, Int)). This is the common data structure used to demonstrate the parameter untupling feature.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling-spec.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval xs: List[(Int, Int)]\n```\n\n----------------------------------------\n\nTITLE: Recursive Match Type for Element Extraction\nDESCRIPTION: This code snippet defines a recursive match type `LeafElem[X]` that processes nested data structures like `Array` and `Iterable` to extract their innermost element types (e.g., Char, Float). It showcases recursive type definitions using match types, which can be employed in complex type computations or dependently typed methods. The `AnyVal` case ensures fallback to the input type when no further traversal is applicable.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/match-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntype LeafElem[X] = X match\n  case String => Char\n  case Array[t] => LeafElem[t]\n  case Iterable[t] => LeafElem[t]\n  case AnyVal => X\n```\n\n----------------------------------------\n\nTITLE: Unpickling Process with Splice Lambdas\nDESCRIPTION: Code showing how a hole is unpickled by applying the corresponding splice lambda to quoted versions of the hole arguments. This reconstructs the original splice expression.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\n  ((y: Expr[Double], m: Expr[Int]) => powerCode(y, m)).apply('x, 'n)\n```\n\n----------------------------------------\n\nTITLE: Modeling Higher-Kinded Type Declarations as Subtypes of Lambda Traits in Scala\nDESCRIPTION: Describes the modeling of higher-kinded type declarations as subtypes of Lambda traits, inheriting type parameters from their bounds, facilitating uniform representation of unary and multi-parameter type constructors via refinements containing hkArg type members with optional bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ntype Rep[T]\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype Rep <: Lambda$I\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype T[v1 X1 >: S1 <: U1, ..., vn XN >: SN <: UN] >: SR <: UR\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype T <: LambdaV1...Vn { self =>\n  type v1 $hkArg$0 >: s(S1) <: s(U1)\n  ...\n  type vn $hkArg$N >: s(SN) <: s(UN)\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Export Clause: Renaming Hides Member in Scala 3\nDESCRIPTION: Shows an invalid `export` clause illustrating Restriction 3: An export renaming (`A as B`) prevents the target name (`B`) from being exported without renaming by a subsequent selector in the same clause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nexport {A as B, B}        // error: B is hidden\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching in for Expressions with Type Error - Scala\nDESCRIPTION: This code attempts to match each element of a List[Any] as a tuple in a for expression, which is not type-safe and triggers a compile-time error in Scala 3.2. In Scala 2, it would filter out incompatible elements at runtime. The snippet illustrates the stricter pattern matching behavior of Scala 3.2 for comprehensions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-bindings.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval elems: List[Any] = List((1, 2), \"hello\", (3, 4))\nfor (x, y) <- elems yield (y, x) // error: pattern's type (Any, Any) is more specialized\n                                 // than the right-hand side expression's type Any\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala `Boolean` Value Type\nDESCRIPTION: Defines the `scala.Boolean` abstract sealed class, a value type extending `AnyVal` with values `true` and `false`. It implements logical operations (`&&`, `||`, `&`, `|`), equality (`==`, `!=`), and negation (`unary_!`), along with standard `Any` methods (`equals`, `hashCode`, `toString`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\nabstract sealed class Boolean extends AnyVal {\n  def && (p: => Boolean): Boolean = // boolean and\n    if (this) p else false\n  def || (p: => Boolean): Boolean = // boolean or\n    if (this) true else p\n  def &  (x: Boolean): Boolean =    // boolean strict and\n    if (this) x else false\n  def |  (x: Boolean): Boolean =    // boolean strict or\n    if (this) true else x\n  def == (x: Boolean): Boolean =    // boolean equality\n    if (this) x else x.unary_!\n  def != (x: Boolean): Boolean =    // boolean inequality\n    if (this) x.unary_! else x\n  def unary_!: Boolean =            // boolean negation\n    if (this) false else true\n}\n```\n\n----------------------------------------\n\nTITLE: Contravariant Type Parameter Example\nDESCRIPTION: Example of a class with a contravariant type parameter, showing how it enables specific subtyping relationships.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nabstract class OutputChannel[-A] {\n  def write(x: A): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Enum with Custom Members in Scala\nDESCRIPTION: Defines a `Planet` enum with parameters (`mass`, `radius`) and custom members, including a private constant `G` and methods `surfaceGravity` and `surfaceWeight`. Each case extends `Planet` with specific mass and radius values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nenum Planet(mass: Double, radius: Double):\n  private final val G = 6.67300E-11\n  def surfaceGravity = G * mass / (radius * radius)\n  def surfaceWeight(otherMass: Double) = otherMass * surfaceGravity\n\n  case Mercury extends Planet(3.303e+23, 2.4397e6)\n  case Venus   extends Planet(4.869e+24, 6.0518e6)\n  case Earth   extends Planet(5.976e+24, 6.37814e6)\n  case Mars    extends Planet(6.421e+23, 3.3972e6)\n  case Jupiter extends Planet(1.9e+27,   7.1492e7)\n  case Saturn  extends Planet(5.688e+26, 6.0268e7)\n  case Uranus  extends Planet(8.686e+25, 2.5559e7)\n  case Neptune extends Planet(1.024e+26, 2.4746e7)\nend Planet\n```\n\n----------------------------------------\n\nTITLE: Using DottyTypeStealer to Programmatically Inspect Types (Scala)\nDESCRIPTION: A Scala test case snippet demonstrating how to use the `DottyTypeStealer.stealType` helper function. It allows programmatically obtaining a compiler `Context` and internal `Type` objects for given source code and type strings, enabling detailed inspection or assertion on the internal structure of types within code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/inspection.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport dotty.tools.dotc.core.Contexts.Context\nimport dotty.tools.dotc.core.Types.*\n\nimport org.junit.Test\n\nimport dotty.tools.DottyTypeStealer, DottyTypeStealer.Kind\n\nclass StealBox:\n\n  @Test\n  def stealBox: Unit =\n    val (ictx, List(rhs)) =\n      DottyTypeStealer.stealType(\"class Box { type X }\", Kind.rhs, \"Box#X\")\n\n    given Context = ictx\n\n    rhs match\n      case X @ TypeRef(Box @ TypeRef(ThisType(empty), _), _) =>\n        assert(Box.name.toString == \"Box\")\n        assert(X.name.toString == \"X\")\n        assert(empty.name.toString == \"<empty>\")\n```\n\n----------------------------------------\n\nTITLE: Handling Companion Case Objects in Function Contexts – Scala\nDESCRIPTION: This snippet demonstrates the breaking change in Scala 3 where case class companions are no longer auto-eta-expanded into functions. Shows an example where 'Foo' needs to be explicitly referenced as 'Foo.apply' when passed where a function is expected. Input: case class and a higher-order function. Output: compiler warning and necessity to use 'apply' explicitly. Applies in Scala 3.0.0-RC1 and later.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2021-02-17-scala3-rc1.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Foo(x: Int)\ndef f(g: Int => Foo) = g(10)\n\nf(Foo)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Capture Check Violations with List and Function Types in Scala 3\nDESCRIPTION: Showcases an example where a mutable variable `cur` of type List[Proc] is declared in a function but results in a type error due to the illegal type for mutable variables regarding capture sets. Additionally, the example demonstrates how reassignments involving capabilities reachable through another variable are rejected, enforcing capture checking rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef runAll(xs: List[Proc]): Unit =\n  var cur: List[Proc] = xs // error: Illegal type for var\n  while cur.nonEmpty do\n    val next: () => Unit = cur.head\n    next()\n    cur = cur.tail\n\n  usingFile: f =>\n    cur = ((() => f.write()): (() ->{f*} Unit)) :: Nil\n```\n\n----------------------------------------\n\nTITLE: Generating Contributor List - Git Shell\nDESCRIPTION: This command-line snippet shows how the `git shortlog` tool is used to generate a summary list of contributors. The `-sn` flags sort the output by the number of commits and show contributor names. `--no-merges` excludes merge commits. The range `3.0.0-RC2..3.0.1-RC1` specifies the commits between these two tags to count contributions for the specific release candidate period.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2021-06-07-scala3.0.1-rc1-release.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ngit shortlog -sn --no-merges 3.0.0-RC2..3.0.1-RC1\n```\n\n----------------------------------------\n\nTITLE: Syntax of Capture Set Constraints\nDESCRIPTION: Defines the structure of capture sets, typemaps, and the various forms of constraints used in the Scala capture checker. It distinguishes between constant (`ac`) and variable (`av`) capture sets, bijective (`B`) and general (`F`) type maps, and simple (`<:`) vs. map-based (`=`, `>:`, `<:`) constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/handling-invariant-vars.md#_snippet_0\n\nLANGUAGE: Scala Capture Checking Notation\nCODE:\n```\nCapture set a, b, c = ac     // constant, aliases bv, cc\n                    | av     // variable, aliases bv, cv\n\nTypemap          tm = B      // bijective on capabilities\n                    | F      // arbitrary\n\nConstraint     C    = a <: b     // simple constraint\n                    | a = B(b)   // bimap constraint\n                    | a >: F(b)  // covariant map constraint\n                    | a <: F(b)  // contravariant map constraint\n                    | a = F(b)   // invariant map constraint\n```\n\n----------------------------------------\n\nTITLE: Declaring Functions with Checked Exceptions Using SaferExceptions in Scala\nDESCRIPTION: This Scala snippet demonstrates enabling checked exceptions through the import `language.experimental.saferExceptions`. It shows definition of a function `f` that declares it throws a `LimitExceeded` exception using a `throws` clause. The underlying mechanism attaches an implicit `CanThrow` capability to ensure exception safety at compile time, thus requiring callers to handle or declare the capability. This snippet is foundational for safe exception capture checking.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nimport language.experimental.saferExceptions\n\nclass LimitExceeded extends Exception\n\nval limit = 10e+10\ndef f(x: Double): Double throws LimitExceeded =\n  if x < limit then x * x else throw LimitExceeded()\n```\n\n----------------------------------------\n\nTITLE: Int-Based Peano Numbers Implementation in Scala\nDESCRIPTION: Provides a concrete implementation of the `Peano` trait using `Int` as the underlying type for `Nat`, `Zero`, and `Succ`. It implements the abstract members and defines the `given` `TypeTest` instances for `Zero` and `Succ` based on `Int` values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nobject PeanoInt extends Peano:\n  type Nat  = Int\n  type Zero = Int\n  type Succ = Int\n\n  def safeDiv(m: Nat, n: Succ): (Nat, Nat) = (m / n, m % n)\n\n  val Zero: Zero = 0\n\n  val Succ: SuccExtractor = new:\n    def apply(nat: Nat): Succ = nat + 1\n    def unapply(succ: Succ) = Some(succ - 1)\n\n  def typeTestOfZero: TypeTest[Nat, Zero] = new:\n    def unapply(x: Nat): Option[x.type & Zero] =\n      if x == 0 then Some(x) else None\n\n  def typeTestOfSucc: TypeTest[Nat, Succ] = new:\n    def unapply(x: Nat): Option[x.type & Succ] =\n      if x > 0 then Some(x) else None\n```\n\n----------------------------------------\n\nTITLE: Indentation Misalignment in Scala 3 Signficant Indentation\nDESCRIPTION: This Scala snippet demonstrates an error when an 'else' clause is incorrectly aligned in relation to a prior 'if' block, violating indentation region rules. It serves as an example of the parser rejecting a line whose indentation width does not match a previous line's width in scope. Only standard Scala syntax is involved; no imports are required. The result is a compiler error due to misaligned indentation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nif x < 0 then\n    -x\n  else   // error: `else` does not align correctly\n    x\n```\n\n----------------------------------------\n\nTITLE: Using Scala 3 Enum Case Constructors (Examples)\nDESCRIPTION: These examples show how to instantiate cases of a Scala 3 enum defined as an ADT. Cases are typically accessed via the enum's companion object (e.g., `Option.Some`, `Option.None`). The examples also illustrate how the type is widened to the enum type (`Option`) by default, but can be explicitly specified or obtained by constructing the underlying case class directly using `new`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/adts.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> Option.Some(\"hello\")\nval res1: t2.Option[String] = Some(hello)\n\nscala> Option.None\nval res2: t2.Option[Nothing] = None\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> new Option.Some(2)\nval res3: Option.Some[Int] = Some(2)\nscala> val x: Option.Some[Int] = Option.Some(3)\nval res4: Option.Some[Int] = Some(3)\n```\n\n----------------------------------------\n\nTITLE: Scala inline given specialization with `<:` syntax\nDESCRIPTION: Demonstrates how to specialize inline `given`s using the `<:` syntax to specify subtype constraints. This enables more precise and flexible implicit definitions, aligning `given`s with `inline def`s. The example shows a trait `A`, its subtype `B`, and a specialized given instance `tc` that is an inline given constrained to subtype `A`, with an explicit `summon` call to `B`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-11-04-20th-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait A\nclass B extends A\n\ninline given tc <: A = B()\n\nval x: B = summon[A]\n```\n\n----------------------------------------\n\nTITLE: Defining Objects with Same Names in Separate Packages in Scala 3\nDESCRIPTION: This snippet defines two separate packages, each containing an object named X with members x and y of different types. It sets up an example context for demonstrating binding precedence, import shadowing, and local definitions in subsequent code examples. The snippet is syntactically correct and requires no external dependencies.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/02-identifiers-names-and-scopes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\npackage p {\n  object X { val x = 1; val y = 2 }\n}\n\npackage q {\n  object X { val x = true; val y = false }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Type Realizability in Scala 3\nDESCRIPTION: Describes the criteria and rules to determine if a type ´T´ is realizable, meaning it has non-null inhabitants. The analysis involves checking term designators, stable flags, concrete types, and the boundedness of type members and refinements. It also covers the conditions checking base classes and handling cases where base types may not be defined due to meet computation failures. There are no explicit code dependencies, but familiarity with Scala 3 type concepts like term designators, member types, and type bounds is necessary.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_41\n\nLANGUAGE: scala\nCODE:\n```\nA type ´T´ is realizable if:\n- For a term designator p.x with underlying type U:\n  - p is \\u03B5 (empty), or a package ref, or a realizable type AND\n  - memberType(p, x) has the stable flag OR its returned type is realizable\n- A stable type that is not a term designator is realizable\n- Otherwise, T is realizable if T is concrete and has good bounds\n\nGood bounds require:\n- All non-class type members have bounds L <: H\n- All type refinements have good bounds\n- For all base classes C of T:\n  - baseType(T, C) is defined as p.C[T_1, ..., T_n]\n  - Each T_i is a real type or, if a wildcard, has good bounds\n\nNote: baseType may be undefined due to meet computation failures merging prefixes or invariant arguments.\n```\n\n----------------------------------------\n\nTITLE: Declaring a Simple Lazy Val in Scala\nDESCRIPTION: Demonstrates the standard syntax for declaring a lazy val `bar` within a class `Foo` in Scala. The value of `bar` is computed via the expression `<RHS>` only upon its first access.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/lazy-vals-init.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Foo {\n  lazy val bar = <RHS>\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Tracked Parameter Inference\nDESCRIPTION: Examples showing when the 'tracked' modifier can be inferred automatically, such as when a class parameter is referenced in public member signatures or when using context bounds with associated types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/modularity.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass OrdSet(val ord: Ordering) {\n  type Set = List[ord.T]\n  def empty: Set = Nil\n\n  implicit class helper(s: Set) {\n    def add(x: ord.T): Set = x :: remove(x)\n    def remove(x: ord.T): Set = s.filter(e => ord.compare(x, e) != 0)\n    def member(x: ord.T): Boolean = s.exists(e => ord.compare(x, e) == 0)\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait TC:\n  type Self\n  type T\n\nclass Klass[A: {TC as tc}]\n```\n\n----------------------------------------\n\nTITLE: Migration Strategy for Old-Style Implicits with Given Imports in Scala 3\nDESCRIPTION: Explains the backward compatibility strategy for migrating from Scala 2 implicits to Scala 3 given instances. Describes how `given` import selectors include old-style implicits in Scala 3.0, how wildcard imports produce deprecation warnings in Scala 3.1, and how errors will eventually be issued to enforce migration.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/contextual/given-imports.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n 1. A `given` import selector also brings old style implicits into scope. So, in Scala 3.0\n    an old-style implicit definition can be brought into scope either by a `*` or a `given` wildcard selector.\n\n 2. In Scala 3.1, old-style implicits accessed through a `*` wildcard import will give a deprecation warning.\n\n 3. In some version after 3.1, old-style implicits accessed through a `*` wildcard import will give a compiler error.\n```\n\n----------------------------------------\n\nTITLE: Effect polymorphism in `map` and `filter` based on function purity in Scala 3\nDESCRIPTION: This snippet illustrates that if the `map` or `filter` functions receive pure functions, the effects do not propagate beyond the original list. For example, `xs.map(_ + 1)` results in a list with only `xs` in its capture set, demonstrating effect polymorphism where pure functions do not affect captured effects. This highlights how capability-based effect systems can distinguish pure from impure computations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_33\n\nLANGUAGE: Scala\nCODE:\n```\nval xs = squares(10)\nval ys: LzyList[Int]^{xs} = xs.map(_ + 1)\n```\n\n----------------------------------------\n\nTITLE: Defining a Binary Type Lambda using Scala Syntax - Scala\nDESCRIPTION: This code snippet demonstrates the syntax for defining a binary type lambda in Scala 3, mapping two type parameters X and Y to the type Map[Y, X]. No external dependencies are required, but the context requires Scala 3 or later due to the new type lambda syntax. Type parameters in the lambda can have bounds but cannot specify variance, and the resulting lambda can be used wherever a type constructor is required. The snippet expects type-level inputs and does not produce runtime output directly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/new-types/type-lambdas.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n[X, Y] =>> Map[Y, X]\n```\n\n----------------------------------------\n\nTITLE: Enabling Ad-Hoc Extensions in Scala 3\nDESCRIPTION: This Scala code snippet shows how to enable the 'adhocExtensions' language feature required for extending classes that are not declared 'open' and reside in different source files. It requires importing 'scala.language.adhocExtensions' to avoid compiler warnings when extending such classes. The code has no inputs or outputs by itself but influences compiler behavior during extension. This feature is typically enabled by an import statement or compiler option '-language:adhocExtensions'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/open-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.adhocExtensions\n```\n\n----------------------------------------\n\nTITLE: Java Interoperability: Using Scala Generics from Java\nDESCRIPTION: Illustrates type patching when Java code uses generic classes defined in Scala (`Box`). The outer type returned from Java becomes nullable (`Box[...] | Null`), and the type argument (`T`) within the Scala generic is also made nullable (`T | Null`) to reflect that Java might pass null. For Java-defined generics (`List`), only the contents are nullified according to standard rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_9\n\nLANGUAGE: java\nCODE:\n```\n// Java definition where Box is Scala-defined and List is Java-defined\nclass BoxFactory<T> {\n  Box<T> makeBox();\n  List<Box<List<T>>> makeCrazyBoxes();\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Equivalent Scala signature with explicit nulls\nclass BoxFactory[T]:\n  def makeBox(): Box[T | Null] | Null\n  def makeCrazyBoxes(): java.util.List[Box[java.util.List[T] | Null]] | Null\n```\n\n----------------------------------------\n\nTITLE: Using boundary for early exit in Scala\nDESCRIPTION: This snippet demonstrates how to use the `scala.util.boundary` and `boundary.break` constructs as a modern alternative to deprecated nonlocal returns. The `boundary` block defines a context where `break` can be called to exit immediately with a specified value. This function finds the first index of an element in a list, exiting the loop and the boundary block early if the element is found, otherwise returning -1.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/nonlocal-returns.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.boundary, boundary.break\ndef firstIndex[T](xs: List[T], elem: T): Int =\n  boundary:\n    for (x, i) <- xs.zipWithIndex do\n      if x == elem then break(i)\n    -1\n```\n\n----------------------------------------\n\nTITLE: Using Infix Operators at the Start of Lines in Multi-line Scala Expressions\nDESCRIPTION: Demonstrates the new Scala 3 syntax, where infix operators such as '++' and '||' are allowed at the beginning of a line in multi-line expressions. This enables chaining and logical combinations without semicolon inference issues, improving code formatting flexibility. Dependencies: Scala 3 compiler. Inputs: Multi-line expressions with infix operator continuation; Outputs: Concatenated strings or boolean expressions as appropriate.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/operators.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval str = \"hello\"\n  ++ \" world\"\n  ++ \"!\"\n\ndef condition =\n  x > 0\n  ||\n  xs.exists(_ > 0)\n  || xs.isEmpty\n```\n\n----------------------------------------\n\nTITLE: Using Back-to-back Symbolic Identifiers and Patterns in Scala Statements\nDESCRIPTION: This code demonstrates that consecutive symbolic identifiers (e.g., '???') without spacing or alignment suitable for infix continuation are interpreted as separate statements and not as infix expressions. The snippet underlines the importance of white space and context for operator parsing in Scala 3. Dependencies: None beyond the Scala language. Inputs: Symbolic method calls and a pattern match; Outputs: Three independent statements.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/operators.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n  println(\"hello\")\n  ???\n  ??? match { case 0 => 1 }\n```\n\n----------------------------------------\n\nTITLE: Error Due to Missing Braces in Scala If Statement\nDESCRIPTION: This example demonstrates the error that occurs when an indented sub-part of an expression is not properly enclosed with braces. It relies on Scala's parsing of indentation when significant indentation is turned off, showing that missing braces can lead to parsing errors. Inputs are sequential println statements after an if condition, and outputs include a compiler error about missing opening brace. No dependencies are required.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nif (x < 0)\n  println(1)\n  println(2)   // error: missing `{`\n```\n\n----------------------------------------\n\nTITLE: Applying New Import Syntax – Scala\nDESCRIPTION: This snippet illustrates the Scala 3 update adopting the '*' wildcard and 'as' renaming operator for imports, replacing the older '_' and '=>' syntax. It highlights importing all members from a package or module and renaming imported modules. Inputs: standard or user-defined modules. Output: makes imported symbols available under a new alias. Requires Scala 3.0.0-RC1 or later.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2021-02-17-scala3-rc1.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.*  // imports everything in the annotation package\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable as mut\nimport NumPy as np\n```\n\n----------------------------------------\n\nTITLE: Defining the Period Value Class API in Scala\nDESCRIPTION: Defines the `Period` value class, which represents a time interval within a specific compiler run. It encapsulates a run ID and a range of phase IDs using a single 32-bit integer. The API provides methods to access the run ID (`runId`), the start (`firstPhaseId`) and end (`lastPhaseId`) phase IDs, check for containment (`contains`, `containsPhaseId`), overlap (`overlaps`), and compute intersections (`&`) or unions (`|`) with other periods. `RunId` and `PhaseId` are type aliases for `Int`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/periods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Period(val code: Int) extends AnyVal {\n  def runId: RunId            // The run identifier of this period.\n  def firstPhaseId: PhaseId   // The first phase of this period\n  def lastPhaseId: PhaseId    // The last phase of this period\n  def phaseId: PhaseId        // The phase identifier of this single-phase period\n\n  def containsPhaseId(id: PhaseId): Boolean\n  def contains(that: Period): Boolean\n  def overlaps(that: Period): Boolean\n\n  def & (that: Period): Period\n  def | (that: Period): Period\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference Example with Union Types and Mutable ListBuffer in Scala\nDESCRIPTION: Illustrates how Scala 3 compiler widens the inferred union type argument to ListBuffer for successful typechecking. The `x` variable is inferred as a ListBuffer containing a union of Left and Right, which is then widened to ListBuffer[Either[Int, String]] allowing assignment to `y` of that explicit type. This behavior avoids type mismatches due to invariance and shows union type widening during inference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/new-types/union-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ListBuffer\nval x = ListBuffer(Right(\"foo\"), Left(0))\nval y: ListBuffer[Either[Int, String]] = x\n```\n\n----------------------------------------\n\nTITLE: Defining Block Indentation Syntax (`<<< ts >>>`) in Scala 3 Grammar\nDESCRIPTION: Defines the BNF notation `<<< ts >>>`, used within the `ExtMethods` rule. This notation signifies that a block of statements (`ts`) can be represented either by enclosing them in curly braces (`{ ts }`) or by using indentation (`indent ts outdent`), supporting Scala 3's optional braces feature.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_20\n\nLANGUAGE: BNF\nCODE:\n```\n<<< ts >>>        ::=  ‘{’ ts ‘}’ | indent ts outdent\n```\n\n----------------------------------------\n\nTITLE: EBNF Definition for Method Types in Scala 3\nDESCRIPTION: Provides the EBNF grammar defining the syntax for method types in Scala 3. A method type specifies the types of named parameters and the result type (which can itself be another method type).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_36\n\nLANGUAGE: ebnf\nCODE:\n```\nMethodType        ::=  ‘(‘ MethodTypeParams ‘)‘ TypeOrMethodic\nMethodTypeParams  ::=  ε\n                    |  MethodTypeParam {‘,‘ MethodTypeParam}\nMethodTypeParam   ::=  id ‘:‘ Type\n```\n\n----------------------------------------\n\nTITLE: Using 'summon' to retrieve given instances\nDESCRIPTION: Explains how the 'summon' method retrieves an existing given instance of a specific type, exemplified with 'Ord[List[Int]]'. The method acts as an identity function facilitating access to implicit instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/using-clauses.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nsummon[Ord[List[Int]]]  // reduces to listOrd(using intOrd)\n\ndef summon[T](using x: T): x.type = x\n```\n\n----------------------------------------\n\nTITLE: Correct Partial Application of Inline Method Using Wildcard in Scala\nDESCRIPTION: Shows the correct way to achieve a behavior similar to partial application with inline methods by passing a wildcard `_` for the final argument list. This allows the expression to typecheck, although the full inlining only occurs when the resulting function is applied.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nLogger.log[String](\"some op\", indentSetting)(_)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Use of @targetName with Overridden Method (Scala)\nDESCRIPTION: This Scala snippet illustrates a compile-time error when attempting to override a method from a superclass with a different target name using @targetName. The base class 'A' defines a method 'f'; subclass 'B' overrides it, but assigns a different external name ('g') using @targetName. The Scala compiler disallows this since overridden methods must maintain the same erased name to preserve correct overriding relationships. This demonstrates a restriction of @targetName usage when overriding.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/targetName.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport annotation.targetName\nclass A:\n  def f(): Int = 1\nclass B extends A:\n  @targetName(\"g\") def f(): Int = 2\n```\n\n----------------------------------------\n\nTITLE: Declaring Top-Level Opaque Type Alias in Scala\nDESCRIPTION: Defines a top-level opaque type alias 'A' for String and demonstrates its transparency within the source file (allowing direct assignment to 'x'), and its opacity both within nested objects (causing error for 'y') and in other source files. This snippet requires placement in a file-level scope in Scala 3 and is illustrative of source file modularity affecting opaque type visibility.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/opaques.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\n// in test1.scala\nopaque type A = String\nval x: A = \"abc\"\n\nobject obj:\n  val y: A = \"abc\"  // error: found: \"abc\", required: A\n\n// in test2.scala\ndef z: String = x   // error: found: A, required: String\n```\n\n----------------------------------------\n\nTITLE: Invalid Pattern Examples for Match Types in Scala 3\nDESCRIPTION: Examples of illegal pattern types that cannot be used in Match Types, including nested captures in non-covariant positions and types with restrictive bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\n// Type capture nested two levels below a non-covariant type constructor\ncase Inv[Cov[t]] =>\ncase Inv[Inv[t]] =>\ncase Contra[Cov[t]] =>\n\n// Type constructor with bounds that do not contain all possible instantiations\ncase IsSeq[t] =>\n\n// Type refinement where the refined type member is not a member of the parent\ncase ZExtractor[t] =>\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala `Int` Value Type\nDESCRIPTION: Defines the `scala.Int` abstract sealed class, a value type extending `AnyVal`. It details overloaded methods for equality (`==`, `!=`, etc.), arithmetic (`+`, `-`, `*`, `/`, `%`), bitwise operations (`&`, `|`, `^`, `<<`, `>>`, `>>>`), unary operations (`unary_+`, `unary_-`, `unary_~`), and type conversions (`toByte`, `toShort`, etc.).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\nabstract sealed class Int extends AnyVal {\n  def == (that: Double): Boolean  // double equality\n  def == (that: Float): Boolean   // float equality\n  def == (that: Long): Boolean    // long equality\n  def == (that: Int): Boolean     // int equality\n  def == (that: Short): Boolean   // int equality\n  def == (that: Byte): Boolean    // int equality\n  def == (that: Char): Boolean    // int equality\n  /* analogous for !=, <, >, <=, >= */\n\n  def + (that: Double): Double    // double addition\n  def + (that: Float): Double     // float addition\n  def + (that: Long): Long        // long addition\n  def + (that: Int): Int          // int addition\n  def + (that: Short): Int        // int addition\n  def + (that: Byte): Int         // int addition\n  def + (that: Char): Int         // int addition\n  /* analogous for -, *, /, % */\n\n  def & (that: Long): Long        // long bitwise and\n  def & (that: Int): Int          // int bitwise and\n  def & (that: Short): Int        // int bitwise and\n  def & (that: Byte): Int         // int bitwise and\n  def & (that: Char): Int         // int bitwise and\n  /* analogous for |, ^ */\n\n  def << (cnt: Int): Int          // int left shift\n  def << (cnt: Long): Int         // long left shift\n  /* analogous for >>, >>> */\n\n  def unary_+ : Int               // int identity\n  def unary_- : Int               // int negation\n  def unary_~ : Int               // int bitwise negation\n\n  def toByte: Byte                // convert to Byte\n  def toShort: Short              // convert to Short\n  def toChar: Char                // convert to Char\n  def toInt: Int                  // convert to Int\n  def toLong: Long                // convert to Long\n  def toFloat: Float              // convert to Float\n  def toDouble: Double            // convert to Double\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom MainAnnotation Class in Scala\nDESCRIPTION: Example implementation of a custom MainAnnotation class called myMain that processes positional arguments. Shows how to implement the required methods for command-line parsing and execution.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/main-annotation.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Parser used to parse command line arguments\nimport scala.util.CommandLineParser.FromString[T]\n\n// Result type of the annotated method is Int and arguments are parsed using FromString\n@experimental class myMain extends MainAnnotation[FromString, Int]:\n  import MainAnnotation.{ Info, Parameter }\n\n  def command(info: Info, args: Seq[String]): Option[Seq[String]] =\n    if args.contains(\"--help\") then\n      println(info.documentation)\n      None // do not parse or run the program\n    else if info.parameters.exists(_.hasDefault) then\n      println(\"Default arguments are not supported\")\n      None\n    else if info.hasVarargs then\n      val numPlainArgs = info.parameters.length - 1\n      if numPlainArgs > args.length then\n        println(\"Not enough arguments\")\n        None\n      else\n        Some(args)\n    else\n      if info.parameters.length > args.length then\n        println(\"Not enough arguments\")\n        None\n      else if info.parameters.length < args.length then\n        println(\"Too many arguments\")\n        None\n      else\n        Some(args)\n\n  def argGetter[T](param: Parameter, arg: String, defaultArgument: Option[() => T])(using parser: FromString[T]): () => T =\n    () => parser.fromString(arg)\n\n  def varargGetter[T](param: Parameter, args: Seq[String])(using parser: FromString[T]): () => Seq[T] =\n    () => args.map(arg => parser.fromString(arg))\n\n  def run(program: () => Int): Unit =\n    println(\"executing program\")\n\n    val result = program()\n    println(\"result: \" + result)\n    println(\"executed program\")\n\nend myMain\n```\n\n----------------------------------------\n\nTITLE: Declaring Abstract Givens in Traits - Scala\nDESCRIPTION: This snippet shows the traditional way of declaring an abstract given in a trait, which requires an explicit name and provides no right-hand side. While still supported in Scala 3.6, abstract givens are now considered redundant and are expected to be replaced by deferred givens. There are no dependencies except for using Scala 3.6, and subclasses are responsible for providing implementations of the named given.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/deferred-givens.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntrait HasOrd[T]:\n  given ord: Ord[T]\n```\n\n----------------------------------------\n\nTITLE: Declaring Uninitialized Field (Old Wildcard) - Scala\nDESCRIPTION: This code snippet shows the old syntax using the wildcard `_` to declare a variable as uninitialized. This syntax was used in previous Scala versions but is deprecated and will be dropped in future 3.x releases.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/wildcard-init.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n  var x: A = _\n```\n\n----------------------------------------\n\nTITLE: Refutable List Head Decomposition Using @unchecked Annotation - Scala\nDESCRIPTION: This code shows how adding the @unchecked annotation to the right-hand side of a refutable pattern allows the binding in Scala 3.2, shifting potential errors from compile time to runtime. Key dependency is scala.unchecked, and it is recommended only if it is certain that the value matches the pattern.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-bindings.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval first :: rest = elems: @unchecked   // OK\n```\n\n----------------------------------------\n\nTITLE: Referencing Experimental Types in Scala 3\nDESCRIPTION: Illustrates how types annotated with @experimental can only be referenced inside experimental scopes. Attempting to refer to an experimental type E in a non-experimental type alias causes a compile error, while declaring an experimental type alias referencing E is allowed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/experimental-defs.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.experimental\n\n@experimental type E\n\ntype A = E // error type E is marked @experimental and therefore ...\n@experimental type B = E\n```\n\n----------------------------------------\n\nTITLE: Transitive Disambiguation of Givens and Implicits by Inheritance in Scala\nDESCRIPTION: This snippet illustrates the need for transitive comparison of companion object and class inheritance to resolve the most specific implicit. Classes and objects A, B, and C are defined with given instances, and the rules determine that specificity should be transitive to make the result order-independent. The code requires class definitions, object companions, and given declarations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/implicit-resolution.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass A extends B\nobject A { given a ... }\nclass B\nobject B extends C { given b ... }\nclass C { given c }\n\n```\n\n----------------------------------------\n\nTITLE: Ambiguity Propagation in Implicit Search in Scala\nDESCRIPTION: This snippet highlights Scala 3's new handling of ambiguity errors during recursive implicit searches. When multiple valid implicit paths exist and can't be disambiguated, the error is propagated outward instead of being resolved by fallback mechanisms. It demonstrates alternative implicit definitions for types A, B, and C and shows that searching for implicitly[C] results in an ambiguity. Required definitions are of the types and implicits for A, B, and C. Inputs include the implicit query, and the output is a compile-time ambiguity error.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/implicit-resolution.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass A\nclass B extends C\nclass C\nimplicit def a1: A\nimplicit def a2: A\nimplicit def b(implicit a: A): B\nimplicit def c: C\n\n```\n\n----------------------------------------\n\nTITLE: Desugared Dependent Function Type Representation in Scala 3\nDESCRIPTION: Explains and shows the underlying representation of a dependent function type in Scala 3. It demonstrates that the syntax `(e: Entry) => e.Key` is syntactic sugar for a refined `Function1` trait, specifying the exact dependent signature of the `apply` method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/dependent-function-types.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nFunction1[Entry, Entry#Key]:\n  def apply(e: Entry): e.Key\n```\n\n----------------------------------------\n\nTITLE: Type Variables with Bounds in Scala 3 Quoted Patterns\nDESCRIPTION: Shows how to define type variables with upper and lower bounds to constrain the types that will match in a quoted pattern.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\n  case '{ type t >: List[Int] <: Seq[Int]; $x: t } =>\n```\n\n----------------------------------------\n\nTITLE: Using type lambda syntax for ConfigDependent\nDESCRIPTION: Rewrites the `configDependentMonad` using Scala 3 type lambda syntax, abstracting over the input type to produce a polymorphic environment-based computation, enhancing reusability across different contexts.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\ngiven configDependentMonad: Monad[[Result] =>> Config => Result]:\n\n  def pure[A](x: A): Config => A =\n    config => x\n\n  extension [A](x: Config => A)\n    def flatMap[B](f: A => Config => B): Config => B =\n      config => f(x(config))(config)\n```\n\n----------------------------------------\n\nTITLE: Implementing lazy cons class `LzyCons` with memoized tail in Scala 3\nDESCRIPTION: This snippet defines the `LzyCons` class, representing a non-empty lazy list node with a head element and a lazy, memoized tail. It uses a private boolean `forced` to indicate whether the tail function has been evaluated, caching its result in `cache`. The implementation ensures that the tail is computed at most once, supporting delayed evaluation and memoization. It relies on `scala.compiletime.uninitialized` to handle uninitialized state.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\nfinal class LzyCons[+A](hd: A, tl: () => LzyList[A]^) extends LzyList[A]:\n  private var forced = false\n  private var cache: LzyList[A]^{this} = uninitialized\n  private def force =\n    if !forced then { cache = tl(); forced = true }\n    cache\n\n  def isEmpty = false\n  def head = hd\n  def tail: LzyList[A]^{this} = force\nend LzyCons\n```\n\n----------------------------------------\n\nTITLE: Valid Irrefutable Pattern Binding in Scala 3\nDESCRIPTION: Illustrates a valid pattern binding where the pattern is irrefutable because the right-hand side conforms to the pattern's type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-05-23-15th-dotty-milestone-release.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval pair = (1, true)\nval (x, y) = pair\n```\n\n----------------------------------------\n\nTITLE: Running Compiled Scala Classes with Debugging Enabled - Shell\nDESCRIPTION: Runs the compiled Scala main class 'Test' with debugging enabled using the 'scala' command and the '-d' flag. This setup is typically required to attach debuggers such as JDB for real-time inspection. Ensure the main class 'Test' is present in the classpath and the '-d' flag is used to specify debugging information.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nscala -d Test\n```\n\n----------------------------------------\n\nTITLE: Covariant Type Parameters with Private Mutable Fields\nDESCRIPTION: Example showing how object-private fields can be used with covariant type parameters since they don't affect the public interface.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nabstract class R[+A, +B](x: A, y: B) {\n  private var fst: A = x        // OK\n  private var snd: B = y        // OK\n}\n```\n\n----------------------------------------\n\nTITLE: Type Parameter Inference with Upper Bounds in Scala\nDESCRIPTION: Shows pattern matching against a List[a] with a more specific expected type, where 'a' gets inferred with an upper bound of List[String] due to List's covariance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nval x: List[List[String]]\n```\n\n----------------------------------------\n\nTITLE: Defining infix Methods with Various Parameter Lists in Scala\nDESCRIPTION: These examples illustrate valid and invalid uses of the 'infix' modifier for method definitions, showing that only single-parameter lists are allowed for infix methods. It also demonstrates extension methods with infix notation. Errors in definition (multiple parameters) are specifically annotated. Dependencies: Requires Scala 3 for 'infix' syntax and extension methods. Inputs: Varying parameter lists to infix methods; Outputs: Method definitions or compiler errors as appropriate.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/operators.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ninfix def op1(x: S): R             // ok\ninfix def op2[T](x: T)(y: S): R    // ok\ninfix def op3[T](x: T, y: S): R    // error: two parameters\n\nextension (x: A)\n  infix def op4(y: B): R          // ok\n  infix def op5(y1: B, y2: B): R  // error: two parameters\n```\n\n----------------------------------------\n\nTITLE: Accessing Companion Members from Enum Case Scala\nDESCRIPTION: Illustrates restrictions on how enum case declarations can access members of the enum's companion object in Scala 3. Direct references or references via `import` are often disallowed; indirect references (e.g., `Planet.member`) are required.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nimport Planet.*\nenum Planet(mass: Double, radius: Double):\n  private final val (mercuryMass, mercuryRadius) = (3.303e+23, 2.4397e6)\n\n  case Mercury extends Planet(mercuryMass, mercuryRadius)             // Not found\n  case Venus   extends Planet(venusMass, venusRadius)                 // illegal reference\n  case Earth   extends Planet(Planet.earthMass, Planet.earthRadius)   // ok\nobject Planet:\n  private final val (venusMass, venusRadius) = (4.869e+24, 6.0518e6)\n  private final val (earthMass, earthRadius) = (5.976e+24, 6.37814e6)\nend Planet\n```\n\n----------------------------------------\n\nTITLE: Detecting Uninitialized Field Access via Inheritance in Scala\nDESCRIPTION: This Scala snippet demonstrates a potential initialization issue in an inheritance hierarchy. The `RemoteFile` class overrides the `name` method to return `localFile`, but the parent `AbstractFile` accesses `name` during its own construction to initialize `extension`. The checker correctly identifies that `localFile` is accessed via `name` before it has been initialized in the `RemoteFile` constructor.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/safe-initialization.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nabstract class AbstractFile:\n  def name: String\n  val extension: String = name.substring(4)\n\nclass RemoteFile(url: String) extends AbstractFile:\n  val localFile: String = s\"${url.##}.tmp\"  // error: usage of `localFile` before it's initialized\n  def name: String = localFile\n```\n\n----------------------------------------\n\nTITLE: Scala `with` keyword's new role for class body indentation\nDESCRIPTION: Shows how the `with` keyword can now precede class or trait bodies to explicitly start an indentation block. This change helps prevent accidental outdenting of class members and facilitates clearer code structure. The example demonstrates class and type definitions using the new `with` syntax, improving readability and maintainability.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-11-04-20th-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait A with {\n  def f: Int\n}\nclass C(x: Int) extends A with {\n  def f = x\n}\ntype T = A with {\n  def f: Int\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntrait A with\n  def f: Int\nclass C(x: Int) extends A with\n  def f = x\nType T = A with\n  def f: Int\n```\n\n----------------------------------------\n\nTITLE: Definition of Auxiliary Type Alias `is` for Context Bound Synthesis\nDESCRIPTION: Defines a standard type alias `is` that maps a type `A` to a refinement `{ type Self = A }`, facilitating the creation of instance definitions and use clauses with meaningful and consistent naming. Supports concise syntax for declaring that certain types are instances of type classes, enhancing code readability and expressiveness.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/typeclasses.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ninfix type is[A <: AnyKind, B <: {type Self <: AnyKind}] = B { type Self = A }\n\ngiven Int is Ord ...\n given Int is Monoid ...\n\n type Reader = [X] =>> Env => X\n given Reader is Monad ...\n\n object Monoid:\n   def unit[M](using m: M is Monoid): M\n```\n\n----------------------------------------\n\nTITLE: Using Union Types with Explicit Type Annotation in Scala REPL\nDESCRIPTION: Shows example Scala REPL session where instances of UserName and Password are created. It demonstrates that expressions using union types require explicit type annotation to receive the precise union type instead of defaulting to a supertype like Object & Product. The explicit annotation enables the compiler to treat the value as the least supertype union (Password | UserName), enabling more precise typing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/new-types/union-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> val password = Password(123)\nval password: Password = Password(123)\n\nscala> val name = UserName(\"Eve\")\nval name: UserName = UserName(Eve)\n\nscala> if true then name else password\nval res2: Object = UserName(Eve)\n\nscala> val either: Password | UserName = if true then name else password\nval either: Password | UserName = UserName(Eve)\n```\n\n----------------------------------------\n\nTITLE: Applying Ref with Reach Capabilities in Scala 3\nDESCRIPTION: Similar to the previous snippet but using the Ref class, this example demonstrates how storing functions with reach capability `xs*` typechecks correctly, while attempting to replace these with functions reachable from an unrelated capability `f` is disallowed by the capture checking rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef runAll(xs: List[Proc]): Unit =\n  val cur = Ref[List[() ->{xs*} Unit]](xs)  // OK, by revised VAR\n  while cur.get.nonEmpty do\n    val next: () ->{xs*} Unit = cur.get.head\n    next()\n    cur.set(cur.get.tail: List[() ->{xs*} Unit])\n\n  usingFile: f =>\n    cur.set:\n      (() => f.write(): () ->{f*} Unit) :: Nil // error since {f*} !<: {xs*}\n```\n\n----------------------------------------\n\nTITLE: Initializing State and Flags with Deprecated and Extended Methods in Scala 3\nDESCRIPTION: This snippet covers modifications to the initialization process, including deprecating older methods (`StandardPlugin.init`) in favor of new `initialize` methods that use implicit contexts. It also includes specific enhancements like handling `changesParents` flag and global init checks, ensuring proper startup procedures.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.5.0-RC1.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n# Initialization\n\n- Deprecate `StandardPlugin.init` in favor of `initialize` taking implicit Context [#20330]\n- Fix missing `changesParents` in `PostTyper` [#20062]\n- Special case handling for the next field of colon colon in global init checker [#20281]\n- Extend whitelist in global initialization checker [#20290]\n```\n\n----------------------------------------\n\nTITLE: Implementation of Expr Class for Runtime Expression Representation in Scala 3 Macros\nDESCRIPTION: Defines the abstract class Expr[T], which encapsulates a typed abstract syntax tree (AST) and a scope object to track splicing contexts during macro execution. The companion object provides utility methods for creating, deconstructing, and manipulating expressions in macro code, such as apply, unapply, betaReduce, and block constructors. It forms the core runtime representation of code fragments in Scala 3 macros.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Expr[+T] private[scala]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject Expr:\n  def apply[T](x: T)(using ToExpr[T])(using Quotes): Expr[T] = ...\n  def unapply[T](x: Expr[T])(using FromExpr[T])(using Quotes): Option[T] = ...\n  def betaReduce[T](e: Expr[T])(using Quotes): Expr[T] = ...\n  def summon[T: Type](using Quotes): Option[Expr[T]] = ...\n  def block[T](stats: List[Expr[Any]], e: Expr[T])(using Quotes): Expr[T] = ...\n  def ofSeq[T: Type](xs: Seq[Expr[T]])(using Quotes): Expr[Seq[T]] = ...\n  def ofList[T: Type](xs: Seq[Expr[T]])(using Quotes): Expr[List[T]] = ...\n  def ofTupleFromSeq(xs: Seq[Expr[Any]])(using Quotes): Expr[Tuple] = ...\n  def ofTuple[T <: Tuple: Tuple.IsMappedBy[Expr]: Type](tup: T)(using Quotes): Expr[Tuple.InverseMap[T, Expr]] = ...\n```\n\n----------------------------------------\n\nTITLE: Applying polymorphic functions in expression transformations\nDESCRIPTION: Example of invoking `mapSubexpressions` with a polymorphic function that wraps each subexpression with a `Var` labeled `wrap`. Highlights how polymorphic functions facilitate dynamic, type-safe transformations over data structures like expression trees.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/polymorphic-function-types.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval e0 = Apply(Var(\"f\"), Var(\"a\"))\nval e1 = mapSubexpressions(e0)(\n  [B] => (se: Expr[B]) => Apply(Var[B => B](\"wrap\"), se))\nprintln(e1) // Apply(Apply(Var(wrap),Var(f)),Apply(Var(wrap),Var(a)))\n```\n\n----------------------------------------\n\nTITLE: Defining Super Types in Scala 3 EBNF\nDESCRIPTION: This EBNF defines the syntax for 'super types' as 'classid . super [ classid ]', denoting the 'this' value from the perspective of a superclass or trait D within class C. This syntax is included for Scala 2 compatibility, where inner class shadowing is allowed. In Scala 3, 'super types' are generally replaced with 'this types'. No external dependencies; applies to type grammar only.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_18\n\nLANGUAGE: ebnf\nCODE:\n```\nSuperType  ::=  classid ‘.‘ ‘super‘ ‘[‘ classid ‘]‘\n```\n\n----------------------------------------\n\nTITLE: Scala inference of `private[this]` modifier in variables\nDESCRIPTION: Illustrates the new implicit inference of the `private[this]` modifier for variables accessed exclusively via `this`. Explicit `private[this]` and `protected[this]` modifiers are deprecated under the `-strict` flag to promote simpler and more predictable access control. The snippet emphasizes the compiler's ability to deduce the appropriate visibility modifier, reducing boilerplate and enhancing code clarity.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-11-04-20th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nvar x = 0\n// accesses only via this, so `private[this]` can be inferred\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Import and Export Syntax Definition\nDESCRIPTION: Provides the syntactic grammar rules for the Scala 3 `import` and `export` statements, including different forms of import selectors such as named selectors, wildcard selectors (`*` and `given`), and grouped selectors. This serves as a formal specification of the allowed import/export forms.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/contextual/given-imports.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nImport            ::=  ‘import’ ImportExpr {‘,’ ImportExpr}\nExport            ::=  ‘export’ ImportExpr {‘,’ ImportExpr}\nImportExpr        ::=  SimpleRef {‘.’ id} ‘.’ ImportSpec\nImportSpec        ::=  NamedSelector\n                    |  WildcardSelector\n                    | ‘{’ ImportSelectors) ‘}’\nNamedSelector     ::=  id [‘as’ (id | ‘_’)]\nWildCardSelector  ::=  ‘*’ | ‘given’ [InfixType]\nImportSelectors   ::=  NamedSelector [‘,’ ImportSelectors]\n                    |  WildCardSelector {‘,’ WildCardSelector}\n```\n\n----------------------------------------\n\nTITLE: Using Inline If for Compile-Time Conditional Execution in Scala\nDESCRIPTION: Defines an `inline` function `update` that utilizes `inline if`. This construct requires the condition (`delta >= 0`) to be a constant expression evaluatable at compile time. Based on the condition's result, the compiler replaces the `inline if` expression with the code from the chosen branch (`increaseBy(delta)` or `decreaseBy(-delta)`), effectively removing the conditional logic from the runtime code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ninline def update(delta: Int) =\n  inline if delta >= 0 then increaseBy(delta)\n  else decreaseBy(-delta)\n```\n\n----------------------------------------\n\nTITLE: Syntax Definition for Sequence SimplePattern (EBNF)\nDESCRIPTION: Defines the EBNF syntax for a simple pattern used for matching sequences. It includes a stable identifier, optional fixed patterns, and a final sequence wildcard (`_*`) optionally bound to a variable using `@`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_17\n\nLANGUAGE: ebnf\nCODE:\n```\nSimplePattern ::= StableId ‘(’ [Patterns ‘,’] [varid ‘@’] ‘_’ ‘*’ ‘)’\n```\n\n----------------------------------------\n\nTITLE: Observing Default Union Type Inference in Scala REPL\nDESCRIPTION: This REPL session demonstrates Scala 3's default type inference for expressions that could result in a Union Type. When a common supertype (`ID`) is available and not marked `transparent`, the compiler infers the supertype (`ID`) for an expression (like an `if/else`), requiring an explicit type annotation (`Password | UserName`) to get the Union Type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/union-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> val password = Password(123)\nval password: Password = Password(123)\n\nscala> val name = UserName(\"Eve\")\nval name: UserName = UserName(Eve)\n\nscala> if true then name else password\nval res1: ID = UserName(Eve)\n\nscala> val either: Password | UserName = if true then name else password\nval either: UserName | Password = UserName(Eve)\n\n```\n\n----------------------------------------\n\nTITLE: Implementing ExprMap for Bottom-Up Optimization in Scala\nDESCRIPTION: Provides an example implementation of `ExprMap` named `OptimizeIdentity`. This object performs a bottom-up transformation by first calling `transformChildren` on the input expression `e` and then pattern matching on the result. If the transformed expression matches `'{ identity($x) }`, it returns `x`, effectively optimizing away the identity function call.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nobject OptimizeIdentity extends ExprMap:\n  def transform[T](e: Expr[T])(using Type[T])(using Quotes): Expr[T] =\n    transformChildren(e) match // bottom-up transformation\n      case '{ identity($x) } => x\n      case _ => e\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Interpolated String Literal Syntax (EBNF)\nDESCRIPTION: Provides the EBNF rule indicating that an `interpolatedString` is a specific type of `Literal`. This is key for understanding how interpolated strings can be utilized within patterns, as demonstrated in subsequent examples.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_5\n\nLANGUAGE: ebnf\nCODE:\n```\n  Literal  ::=  interpolatedString\n```\n\n----------------------------------------\n\nTITLE: Allowed Quoted Pattern Without Type Bounds in Scala\nDESCRIPTION: Example of a quoted pattern that is *allowed* by the current experimental implementation because the type parameter `A` has no explicit bounds. This is part of the explanation of implementation restrictions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/quoted-patterns-with-polymorphic-functions.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ncase '{ [A] => (x: List[A]) => $y(x) : Int } => // Allowed\n```\n\n----------------------------------------\n\nTITLE: Incorrect Partial Application of Inline Method in Scala\nDESCRIPTION: Demonstrates that inline methods require all argument lists to be provided at the call site. Attempting to partially apply an inline method by omitting an argument list results in a compile-time error.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nLogger.log[String](\"some op\", indentSetting)\n```\n\n----------------------------------------\n\nTITLE: Summary of Anonymous Given Clause Forms Scala 3\nDESCRIPTION: Provides a consolidated overview of various common forms for defining *anonymous* given clauses in Scala 3. This includes structural givens, parameterized givens (with context bounds, context parameters, and named context parameters), simple aliases, parameterized aliases, deferred givens, and by-name givens, serving as a quick reference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/more-givens.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n  // Simple typeclass\n  given Ord[Int]:\n    def compare(x: Int, y: Int) = ...\n\n  // Parameterized typeclass with context bound\n  given [A: Ord] => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with context parameter\n  given [A] => Ord[A] => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with named context parameter\n  given [A] => (ord: Ord[A]) => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Simple alias\n  given Ord[Int] = IntOrd()\n\n  // Parameterized alias with context bound\n  given [A: Ord] => Ord[List[A]] =\n    ListOrd[A]\n\n  // Parameterized alias with context parameter\n  given [A] => Ord[A] => Ord[List[A]] =\n    ListOrd[A]\n\n  // Deferred given\n  given Context = deferred\n\n  // By-name given\n  given () => Context = curCtx\n```\n\n----------------------------------------\n\nTITLE: Definition of the @use Annotation (Scala)\nDESCRIPTION: Shows the Scala definition of the `use` annotation. It's a `StaticAnnotation` that takes an optional Boolean parameter `cond`, defaulting to `true`. This allows usages like `@use` (equivalent to `@use(true)`) and `@use(false)`. \nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/use-design.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass use(cond: Boolean = true) extends StaticAnnotation\n```\n\n----------------------------------------\n\nTITLE: TASTy Pickle Representation of Quoted Code\nDESCRIPTION: Human-readable representation of the TASTy pickle format for quoted expressions, showing how holes are preserved in the serialized form with encoded byte data.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\n// pickled AST bytes encoded in a base64 string\\ntasty\"\"\"\\n  val (x, n): (Double, Int) = (5, 2)\\n  << 0; Double; x, n >> * << 1; Double; n >>\\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Generated Companion Object - Universal Apply - Scala\nDESCRIPTION: Illustrates the structure of the synthetic companion object, known as a constructor proxy, that Scala 3 automatically generates for concrete classes like `StringBuilder`. This object contains `inline apply` methods that forward directly to the class's constructors, enabling the universal apply syntax shown previously. These generated objects and methods are implicitly available when creating class instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/creator-applications.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject StringBuilder:\n  inline def apply(s: String): StringBuilder = new StringBuilder(s)\n  inline def apply(): StringBuilder = new StringBuilder()\n```\n\n----------------------------------------\n\nTITLE: Illustrating Ill-Formed Parameterized Types in Scala\nDESCRIPTION: Presents examples of ill-formed parameterized types in Scala. These illustrate common errors such as providing the wrong number of type parameters, violating type bounds, using a concrete type where a type constructor is expected, passing type constructors with incorrect arity or parameter kinds, and violating specific parameter constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nTreeMap[I]            // illegal: wrong number of parameters\nTreeMap[List[I], Int] // illegal: type parameter not within bound\nList[[X] => List[X]]\n\nF[Int, Boolean]       // illegal: Int is not a type constructor\nF[TreeMap, Int]       // illegal: TreeMap takes two parameters,\n                      //   F expects a constructor taking one\nF[[X, Y] => (X, Y)]\nG[S, Int]             // illegal: S constrains its parameter to\n                      //   conform to String,\n                      // G expects type constructor with a parameter\n                      //   that conforms to Int\n```\n\n----------------------------------------\n\nTITLE: Example of Replacing Do-While with While in Scala 3\nDESCRIPTION: Demonstrates the equivalent `while` loop replacement for the previous `do-while` example, following the recommended Scala 3 syntax. The increment `i += 1` and the condition `f(i) == 0` are placed within the `while` condition block. The loop body itself is empty `do ()`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/do-while.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nwhile\n  i += 1\n  f(i) == 0\ndo ()\n```\n\n----------------------------------------\n\nTITLE: Declaring Integer Variable in Scala 3\nDESCRIPTION: This snippet demonstrates variable initialization by declaring an immutable integer variable named 'someVariable' with a value of 2. It exemplifies simple variable declaration in Scala 3 without dependencies.\nSOURCE: https://github.com/scala/scala3/blob/main/scaladoc-testcases/docs/_docs/index.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval someVariable: Int = 2\n```\n\n----------------------------------------\n\nTITLE: Implementing Negated Given Constraints with NotGiven in Scala\nDESCRIPTION: This snippet demonstrates using `scala.util.NotGiven` to provide a `given` instance only when another specific `given` instance *does not* exist. `fooTagged` is available if `Tagged[A]` exists, while `fooNotTagged` is available if `Tagged[A]` does *not* exist, as shown in the test case.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/givens.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.NotGiven\n\ntrait Tagged[A]\n\ncase class Foo[A](value: Boolean)\nobject Foo:\n  given fooTagged[A](using Tagged[A]): Foo[A] = Foo(true)\n  given fooNotTagged[A](using NotGiven[Tagged[A]]): Foo[A] = Foo(false)\n\n@main def test(): Unit =\n  given Tagged[Int]()\n  assert(summon[Foo[Int]].value) // fooTagged is found\n  assert(!summon[Foo[String]].value) // fooNotTagged is found\n```\n\n----------------------------------------\n\nTITLE: Referencing Experimental Definitions in Scala 3\nDESCRIPTION: Demonstrates how references to terms annotated with @experimental are only allowed within experimental scopes. Shows term definitions (def, val, var, lazy val) and how accessing experimental symbols outside such scopes causes compiler errors, enforcing safety when using unstable APIs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/experimental-defs.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.experimental\n\n@experimental\ndef x = ()\n\ndef d1 = x // error: value x is marked @experimental and therefore ...\n@experimental def d2 = x\n\nval v1 = x // error: value x is marked @experimental and therefore ...\n@experimental val v2 = x\n\nvar vr1 = x // error: value x is marked @experimental and therefore ...\n@experimental var vr2 = x\n\nlazy val lv1 = x // error: value x is marked @experimental and therefore ...\n@experimental lazy val lv2 = x\n```\n\n----------------------------------------\n\nTITLE: Improved Naming for Context Bounds with `as` Syntax\nDESCRIPTION: Proposes a convention where unnamed context bounds automatically adopt the name of the type parameter, avoiding the need for explicit `as` bindings. When multiple bounds are present, each gets a uniquely synthesized name unless an `as` clause is used, which explicitly states the name. This enhancement simplifies code and improves clarity in evidence binding.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/typeclasses.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef reduce[A : Monoid](xs: List[A]) =\n  xs.foldLeft(A.unit)(_ `combine` _)\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Types in Scala 3 EBNF\nDESCRIPTION: This EBNF describes recursive type grammar as '{ recid => Type }', where recursive self-references ('recid.this') are enabled and essential for encoding types that need to refer to themselves (such as for certain kinds of structural typing). Recursive types result from desugaring concrete refined types that syntactically reference 'this'. No explicit dependencies are expected beyond type grammar rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_26\n\nLANGUAGE: ebnf\nCODE:\n```\nRecursiveType  ::=  ‘{‘ recid ‘=>‘ Type ‘}‘\nRecursiveThis  ::=  recid ‘.‘ ‘this‘\n```\n\n----------------------------------------\n\nTITLE: Core Quote and Splice Desugarings in Scala\nDESCRIPTION: These are the conceptual method signatures representing how quote (`'`) and splice (`$`) operators are desugared by the Scala 3 compiler. `quote` lifts a value into a quoted expression `Expr[T]`, requiring a `Quotes` context. `splice` extracts the value from a quoted expression within a `Quotes` context. The text notes these methods are compiler-internal and not intended for direct user use.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef quote[T](x: T): Quotes ?=> Expr[T]\n\ndef splice[T](x: Quotes ?=> Expr[T]): T\n```\n\n----------------------------------------\n\nTITLE: Syntax Rules for Optional Braces and Indentation (EBNF)\nDESCRIPTION: Defines the grammar rules (`<<< ts >>>`, `:<<< ts >>>`) used in context-free productions to represent code blocks that can either be enclosed in standard braces (`{ ts }`) or denoted by indentation levels (`indent ts outdent`). It also specifies the conditions under which a colon token (`:`) is generated.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\ncolon         ::=  ':'    -- with side conditions explained above\n <<< ts >>>   ::=  ‘{’ ts ‘}’\n                |  indent ts outdent\n:<<< ts >>>   ::=  [nl] ‘{’ ts ‘}’\n                |  colon indent ts outdent\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Healed Type Alias Transformation to Type Hole\nDESCRIPTION: Illustrates the transformation of a healed type alias (`t.Underlying`) into a 'type hole' during the pickling process. The type hole `<< idx; bounds >>` stores the hole's index and the original type bounds, abstracting away the specific type reference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\n'{ type U = << 0; Nothing..Any >>; List.empty[U] }\n```\n\n----------------------------------------\n\nTITLE: Explicit Implementation of Deferred Givens in Subclasses - Scala\nDESCRIPTION: This example provides an explicit override of a deferred given in a class that extends a trait. The class 'SortedString' extends 'Sorted', sets the element type to 'String', and provides its own implementation of the required 'Ord[String]' given. The 'override' keyword is mandatory because the deferred given acts as a concrete definition. Replace '...' with a suitable given instance according to application logic.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/deferred-givens.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass SortedString[A] extends Sorted:\n  type Element = String\n  override given Ord[String] = ...\n```\n\n----------------------------------------\n\nTITLE: EBNF Syntax for Scala Derives and Extends Clauses\nDESCRIPTION: Provides EBNF grammar rules illustrating the syntax structure for `Template`, `EnumDef`, `InheritClauses`, and `ConstrApps` in Scala. Specifically highlights the inclusion of the `derives` clause within `InheritClauses` and shows how `ConstrApps` (used after `extends`) can use either `with` or commas for separation in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_20\n\nLANGUAGE: EBNF\nCODE:\n```\nTemplate          ::=  InheritClauses [TemplateBody]\nEnumDef           ::=  id ClassConstr InheritClauses EnumBody\nInheritClauses    ::=  [‘extends’ ConstrApps] [‘derives’ QualId {‘,’ QualId}]\nConstrApps        ::=  ConstrApp {‘with’ ConstrApp}\n                    |  ConstrApp {‘,’ ConstrApp}\n```\n\n----------------------------------------\n\nTITLE: Implementing Functions with Implicit Transaction Parameters in Scala\nDESCRIPTION: Shows three functions (`f1`, `f2`, `f3`) that call each other and require access to the current transaction context. This is achieved by declaring an implicit parameter `thisTransaction` of type `Transaction` in each function signature, demonstrating the pattern that leads to boilerplate.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n  def f1(x: Int)(implicit thisTransaction: Transaction): Int = {\n    thisTransaction.println(s\"first step: $x\")\n    f2(x + 1)\n  }\n  def f2(x: Int)(implicit thisTransaction: Transaction): Int = {\n    thisTransaction.println(s\"second step: $x\")\n    f3(x * x)\n  }\n  def f3(x: Int)(implicit thisTransaction: Transaction): Int = {\n    thisTransaction.println(s\"third step: $x\")\n    if (x % 2 != 0) thisTransaction.abort()\n    x\n  }\n```\n\n----------------------------------------\n\nTITLE: Illustrating Enum Case Member Access Restrictions in Scala\nDESCRIPTION: Demonstrates the restrictions on accessing members within enum case declarations. Cases cannot access private members of the enum class directly (`Mercury`) or imported members from the companion object (`Venus`). Accessing companion object members requires explicit qualification (`Planet.earthMass`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport Planet.*\nenum Planet(mass: Double, radius: Double):\n  private final val (mercuryMass, mercuryRadius) = (3.303e+23, 2.4397e6)\n\n  case Mercury extends Planet(mercuryMass, mercuryRadius)             // Not found\n  case Venus   extends Planet(venusMass, venusRadius)                 // illegal reference\n  case Earth   extends Planet(Planet.earthMass, Planet.earthRadius)   // ok\nobject Planet:\n  private final val (venusMass, venusRadius) = (4.869e+24, 6.0518e6)\n  private final val (earthMass, earthRadius) = (5.976e+24, 6.37814e6)\nend Planet\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Methods in Scala 3\nDESCRIPTION: This snippet defines an inline method `log` inside the `Logger` object, which is always inlined at call sites. The method performs conditional logging based on the compile-time constant `Config.logging`, with inlining enabling code reduction when logging is disabled. It also shows how inlining impacts code generation and optimizer behavior.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ninline def log[T](msg: String, indentMargin: =>Int)(op: => T): T =\n    if Config.logging then\n      println(s\"${\"  \" * indent}start $msg\")\n      indent += indentMargin\n      val result = op\n      indent -= indentMargin\n      println(s\"${\"  \" * indent}$msg = $result\")\n      result\n    else op\n```\n\n----------------------------------------\n\nTITLE: Defining TupledFunction Trait in Scala\nDESCRIPTION: This trait defines the `TupledFunction` type class, enabling conversion between a function `F` of any arity and a tupled function `G` accepting a single tuple argument. It provides abstract methods `tupled` and `untupled` for these conversions and includes an `@implicitNotFound` annotation for helpful compiler messages.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/tupled-function.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n/** Type class relating a `FunctionN[..., R]` with an equivalent tupled function `Function1[TupleN[...], R]`\n *\n *  @tparam F a function type\n *  @tparam G a tupled function type (function of arity 1 receiving a tuple as argument)\n */\n@implicitNotFound(\"${F} cannot be tupled as ${G}\")\nsealed trait TupledFunction[F, G] {\n  def tupled(f: F): G\n  def untupled(g: G): F\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Third Argument List Overload Resolution (Scala)\nDESCRIPTION: This Scala example defines two overloaded methods `g` with three argument lists, differing in the type of the parameter in the third list. The calls `g(2)(3)(4)` and `g(2)(3)(\"\")` demonstrate that Scala 3's overload resolution can distinguish between these variants based on the parameter types in the third argument list, extending the multi-argument list resolution feature.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/overload-resolution.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef g(x: Int)(y: Int)(z: Int): Int = 0\ndef g(x: Int)(y: Int)(z: String): Int = 0\n\ng(2)(3)(4)     // ok\ng(2)(3)(\"\")    // ok\n```\n\n----------------------------------------\n\nTITLE: Example of map Function Signature in Scala Without Exception Checking - Scala\nDESCRIPTION: Demonstrates the typical signature of the 'map' method on a List in Scala, which takes a function from A to B and returns a List of B. The signature shows no indication that the function argument may throw exceptions, illustrating the lack of exception type handling in the current type system. This serves as the basis for explaining the limitations of checked exceptions and exception propagation in common functional methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/canthrow.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef map[B](f: A => B): List[B]\n```\n\n----------------------------------------\n\nTITLE: Declaring Methods and Lambdas with Erased Parameters in Scala\nDESCRIPTION: Demonstrates how to define methods and lambdas in Scala 3 that accept erased parameters, which are only available at compile time and cannot be used at runtime. Requires the experimental.erasedDefinitions feature to be enabled. Erased parameters must be placed before regular parameters and cannot participate in runtime computations, though they may be passed to other erased parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef methodWithErasedEv(erased ev: Ev, x: Int): Int = x + 2\n\nval lambdaWithErasedEv: (erased Ev, Int) => Int =\n  (erased ev, x) => x + 2\n```\n\n----------------------------------------\n\nTITLE: Setting up a new Dotty project with sbt (Shell)\nDESCRIPTION: Uses the sbt build tool to create a new project pre-configured with Dotty as the compiler, leveraging the official `lampepfl/dotty.g8` template. This command scaffolds a basic Dotty project structure.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nsbt new lampepfl/dotty.g8\n```\n\n----------------------------------------\n\nTITLE: Defining the Internal RuntimeChecked Annotation\nDESCRIPTION: Provides the source code definition for the internal `scala.annotation.internal.RuntimeChecked` annotation. This annotation is applied by the `runtimeChecked` extension method and signals to the compiler to skip pattern match exhaustivity checks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/runtimeChecked.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.annotation.internal\n\nfinal class RuntimeChecked extends Annotation\n```\n\n----------------------------------------\n\nTITLE: Using 'into' with Vararg Parameters - Scala\nDESCRIPTION: Defines a 'concatAll' method that accepts a vararg parameter where each argument uses the 'into' modifier, permitting implicit conversions for each argument individually. These conversions are performed per-argument based on their types. Inputs are multiple values (List, String, Array), output is a unified List of Char. Enclosing the parameter type in parentheses is mandatory.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef concatAll(xss: (into IterableOnce[Char])*): List[Char] =\n  xss.foldLeft(List[Char]())(_ ++ _)\n```\n\n----------------------------------------\n\nTITLE: Obsolete Scala 3 given Syntax (M2)\nDESCRIPTION: This code block illustrates the syntax for declaring 'given' instances and aliases in Scala 3.0.0-M2 using the 'as' keyword, which is now obsolete and no longer accepted in Scala 3.0.0-M3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-12-18-scala3-m3.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ngiven intOrd as Ordering[Int]:\n  ...\ngiven listOrd[T: Ordering] as Ordering[List[T]]:\n  ...\n\ngiven Ordering[Int]:\n  ...\ngiven [T: Ordering] as Ordering[List[T]]:\n  ...\n\ngiven global as ExecutionContext = ForkJoinContext()\ngiven Context = ctx\n```\n\n----------------------------------------\n\nTITLE: Defining Type Lambdas Syntax in EBNF\nDESCRIPTION: Defines the Extended Backus-Naur Form (EBNF) grammar for Scala 3 type lambdas. Type lambdas directly represent type constructors, specifying type parameters with optional variance (+/-) and bounds (TypeBounds), followed by the result type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_9\n\nLANGUAGE: ebnf\nCODE:\n```\nTypeLambda     ::=  ‘[‘ TypeParams ‘]‘ ‘=>>‘ Type\nTypeParams     ::=  TypeParam {‘,‘ TypeParam}\nTypeParam      ::=  ParamVariance id TypeBounds\nParamVariance  ::=  ε | ‘+‘ | ‘-‘\n```\n\n----------------------------------------\n\nTITLE: Example Shell Command Execution and Output\nDESCRIPTION: Shows sample command-line executions of the `TransactionDemo` program with different arguments, illustrating how the program behaves (successful transaction with output log or aborted transaction).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nscala TransactionDemo 1 2 3\nresult: 16\n******* log ********\nfirst step: 3\nsecond step: 4\nthird step: 16\n\nscala TransactionDemo 1 2 3 4\naborted\n```\n\n----------------------------------------\n\nTITLE: Match Types EBNF Syntax Definition\nDESCRIPTION: The EBNF grammar defining the syntax for Match Types in Scala 3, including the structure of match types, case clauses, and patterns.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_30\n\nLANGUAGE: ebnf\nCODE:\n```\nMatchType               ::=  Type 'match' '<:' Type '{' {TypeCaseClause} '}'\nTypeCaseClause          ::=  'case' TypeCasePattern '=>' Type\nTypeCasePattern         ::=  TypeCapture\n                          |  TypeCaseAppliedPattern\n                          |  Type\nTypeCaseAppliedPattern  ::=  Type '[' TypeCasePattern { ',' TypeCasePattern } ']'\nTypeCapture             ::=  (id | '_') TypeBounds\n```\n\n----------------------------------------\n\nTITLE: Verbose Null Checking for Java Interop without `UncheckedNull` in Scala 3\nDESCRIPTION: Contrasts the concise method chaining (enabled by mechanisms like `UncheckedNull`) with the verbose, nested `if` statements required to manually and safely handle potentially null return values and intermediate results from Java methods when explicit null checking is enforced.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval ret = someJavaMethod()\nval s2 = if (ret != null) {\n  val tmp = ret.trim()\n  if (tmp != null) {\n    val tmp2 = tmp.substring(2)\n    if (tmp2 != null) {\n      tmp2.toLowerCase()\n    }\n  }\n}\n// Additionally, we need to handle the `else` branches.\n```\n\n----------------------------------------\n\nTITLE: Improving Context Function Syntax in Scala 3\nDESCRIPTION: This code contrasts the old and new syntax for context functions in Scala 3. The transformation from `(x: String)?=> x.toInt` to `(using x: String) => x.toInt` enhances readability and aligns context functions with method parameters. It depends on Scala 3 syntax improvements and aims to make context functions more intuitive.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-03-18-23rd-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// OLD SYNTAX\nval ctxFunOld = (x: String) ?=> x.toInt\n\n// NEW SYNTAX\nval ctxFunNew = (using x: String) => x.toInt\n```\n\n----------------------------------------\n\nTITLE: Abstract Syntax and Call-by-Value Evaluator Using Scala Case Classes\nDESCRIPTION: This example defines an abstract syntax tree for untyped lambda calculus expressions using Scala case classes. It then provides a call-by-value evaluator function employing pattern matching on the expression types. Dependencies include proper handling of environment closures and pattern matching capabilities of case classes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nclass Expr\ncase class Var   (x: String)          extends Expr\ncase class Apply (f: Expr, e: Expr)   extends Expr\ncase class Lambda(x: String, e: Expr) extends Expr\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntype Env = String => Value\ncase class Value(e: Expr, env: Env)\n\ndef eval(e: Expr, env: Env): Value = e match {\n  case Var (x) =>\n    env(x)\n  case Apply(f, g) =>\n    val Value(Lambda (x, e1), env1) = eval(f, env)\n    val v = eval(g, env)\n    eval (e1, (y => if (y == x) v else env1(y)))\n  case Lambda(_, _) =>\n    Value(e, env)\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Vararg Method with Multiple Convertible Types - Scala\nDESCRIPTION: An example call to 'concatAll' passing a List, String, and Array, where implicit conversions are applied automatically per argument type. This demonstrates the 'into' modifier's effect on each vararg, resulting in a concatenated List[Char]. Inputs include both directly compatible and convertible types; output is a single List.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nconcatAll(List('a'), \"bc\", Array('d', 'e'))\n```\n\n----------------------------------------\n\nTITLE: Listing Git Contributors Between Tags\nDESCRIPTION: This shell command utilizes `git shortlog` to generate a summarized list of contributors based on commit history between two specific tags (3.3.1-RC5 and 3.3.1-RC6). The `-s` flag counts commits per author, `-n` sorts the list numerically by commit count in descending order, and `--no-merges` excludes merge commits from the log.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.3.1-RC6.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit shortlog -sn --no-merges 3.3.1-RC5..3.3.1-RC6\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid and Valid Usages of Erased Parameters in Scala\nDESCRIPTION: Showcases both incorrect and correct ways to use erased parameters within method bodies in Scala 3. Direct computation with erased parameters is a compile-time error, but they can be passed to other erased parameters. This example emphasizes usage constraints: computations using erased values are disallowed, but erased-to-erased parameter passage is permitted.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef methodWithErasedInt1(erased i: Int): Int =\n  i + 42 // ERROR: can not use i\n\ndef methodWithErasedInt2(erased i: Int): Int =\n  methodWithErasedInt1(i) // OK\n```\n\n----------------------------------------\n\nTITLE: Generated Forwarder Method Signature for @unroll in Scala\nDESCRIPTION: Shows the generic signature of the forwarder method `f_p` automatically generated when `@unroll` is used on parameter `p`. This forwarder maintains the method signature excluding `p` and subsequent parameters (`psY...`) from the same list, calling the original method with the default values (`p_D`, `psY_D...`) for the omitted parameters. The forwarder is marked `<invisible>`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/unrolled-defs.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n`<invisible>` final def foo[T](ps0...)(psX...)(psN...): T =\n  foo(ps0...)(psX..., p_D, psY_D...)(psN...)\n```\n\n----------------------------------------\n\nTITLE: Generating Git Contributor List (Shell)\nDESCRIPTION: This shell command uses `git shortlog` to generate a summary of contributors based on commit history. The `-sn` flags sort by commit count and display the author's name, while `--no-merges` excludes merge commits. The range `3.6.4-RC1..3.6.4-RC2` specifies the commits between these two tags.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.6.4-RC2.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit shortlog -sn --no-merges 3.6.4-RC1..3.6.4-RC2\n```\n\n----------------------------------------\n\nTITLE: Implementing a Set Functor with Tracked Parameters\nDESCRIPTION: A complete example showing how tracked parameters enable proper modular programming with dependent types, creating a generic Set structure parameterized by an Ordering type class with preserved type relationships.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/modularity.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Ordering:\n  type T\n  def compare(t1:T, t2: T): Int\n\nclass SetFunctor(tracked val ord: Ordering):\n  type Set = List[ord.T]\n\n  def empty: Set = Nil\n\n  extension (s: Set)\n    def add(x: ord.T): Set = x :: remove(x)\n    def remove(x: ord.T): Set = s.filter(e => ord.compare(x, e) != 0)\n    def contains(x: ord.T): Boolean = s.exists(e => ord.compare(x, e) == 0)\n\nobject intOrdering extends Ordering:\n  type T = Int\n  def compare(t1: T, t2: T): Int = t1 - t2\n\nval IntSet = new SetFunctor(intOrdering)\n\n@main def Test =\n  import IntSet.*\n  val set = IntSet.empty.add(6).add(8).add(23)\n  assert(!set.contains(7))\n  assert(set.contains(8))\n```\n\n----------------------------------------\n\nTITLE: Defining polymorphic method with type projection in Scala 3\nDESCRIPTION: Defines a class Box with an abstract type member X, and a method foo that takes a Box instance and a parameter x of type b.X, returning a list of elements of type b.X. Demonstrates use of path-dependent types and type projections in Scala 3. There are no additional dependencies beyond the Scala standard library. The input is a Box instance and a value of its type member, and the output is a list containing that value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/architecture/time.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Box { type X }\n\ndef foo(b: Box)(x: b.X): List[b.X] = List(x)\n```\n\n----------------------------------------\n\nTITLE: Alternative Export Clause Order in Scala 3\nDESCRIPTION: Shows an alternative ordering of the same export clauses, which raises questions about whether the elaboration result would be different based on the order of declarations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/export.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nexport b.*\nexport A.*\n```\n\n----------------------------------------\n\nTITLE: Flow Typing Limitation: Variable Usage in Nested Closures in Scala 3\nDESCRIPTION: Describes another limitation for mutable variables: flow typing facts derived in an outer scope (`if x != null`) cannot be relied upon for usages of the variable inside a nested closure, even if the variable isn't mutated by *that* specific closure. Flow typing is restricted to the method scope where the variable is defined.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nvar x: String | Null = ???\ndef y =\n  if x != null then\n    // not safe to use the fact (x != null) here\n    // since y can be executed at the same time as the outer block\n    val _: String = x\nif x != null then\n  val a: String = x // ok to use the fact here\n  x = null\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Inline Structural Given Scala 3\nDESCRIPTION: Defines an `inline` structural given for the `Show[Foo]` trait, which itself contains an `inline` method `show`. The example demonstrates how calling `summon[Show[Foo]].show(foo)` can result in the `show` method call being inlined and potentially allow dead code elimination for the given instance itself if not otherwise used.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/more-givens.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ntrait Show[T]:\n  inline def show(x: T): String\n\ninline given Show[Foo]:\n  inline def show(x: Foo): String = ${ ... }\n\ndef app =\n  // inlines `show` method call and removes the call to `given Show[Foo]`\n  summon[Show[Foo]].show(foo)\n```\n\n----------------------------------------\n\nTITLE: Declaring Capability Classes Extending Capability in Scala\nDESCRIPTION: Defines capability classes that extend the Capability trait from the caps package. This establishes an implied capture set of {cap} for all instances, reducing boilerplate and enforcing capability capture semantics. The example includes FileSystem and Logger classes, showing how implicit parameters represent capabilities and how explicit capture sets on capability parameters are redundant and cause warnings.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport caps.Capability\n\nclass FileSystem extends Capability\n\nclass Logger(using FileSystem):\n  def log(s: String): Unit = ???\n\ndef test(using fs: FileSystem) =\n  val l: Logger^{fs} = Logger()\n  ...\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Logger(using FileSystem^{cap}):\n                   ^^^^^^^^^^^^^^\n             redundant capture: FileSystem already accounts for cap\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Top-Level Type Hierarchy with Matchable\nDESCRIPTION: This snippet presents the simplified type hierarchy involving Any, Matchable, AnyVal, and Object in Scala 3. It denotes Matchable as an extension of Any, with AnyVal and Object both extending Any and mixing in Matchable. The code aids in understanding inheritances that affect pattern matching constraints. No runtime dependencies; this is a type system diagram.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/matchable.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Any:\n  def getClass\n  def isInstanceOf\n  def asInstanceOf\n  def ==\n  def !=\n  def ##\n  def equals\n  def hashCode\n  def toString\n\ntrait Matchable extends Any\n\nclass AnyVal extends Any, Matchable\nclass Object extends Any, Matchable\n```\n\n----------------------------------------\n\nTITLE: Show support for Java 8 SAM types in Dotty\nDESCRIPTION: This code demonstrates how to utilize SAM conversions in Dotty for improved interoperability with Java 8 lambdas. It includes a sample Java stream processing pipeline in Scala, which uses lambda expressions seamlessly with the improved SAM support, facilitating cleaner and more idiomatic Scala-Java interoperation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-04-27-eighth-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval myList =\n  java.util.Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\")\n\nmyList\n  .stream\n  .filter(s => s.startsWith(\"c\"))\n  .map(_.toUpperCase)\n  .sorted\n  .forEach(println(_))\n```\n\n----------------------------------------\n\nTITLE: Explicit Unboxing using Unbox Type Wrapper in Scala\nDESCRIPTION: Demonstrates explicit unboxing using the `Unbox` type wrapper in a function signature (`fs: List[Unbox[T => T]]`). This signals that the list elements contain capabilities needing unboxing. The `compose` function uses `foldRight` to combine these functions, and the resulting combined function captures the union of the capabilities from the list elements (`{fs*}`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef compose[T](fs: List[Unbox[T => T]], x: T) =\n  val combined = (xs.foldRight(identity)((f: T => T, g: T => T) => x => g(f(x)))): T->{fs*} T\n  combined(x)\n```\n\n----------------------------------------\n\nTITLE: Using a Name-Based Extractor in a Match Expression (Scala)\nDESCRIPTION: Shows how to use the `NameBased` class as an extractor type. An `Extractor` object's `unapply` method returns a `NameBased` instance. A `match` expression then uses `Extractor(a, b)` to invoke `unapply`, check `isEmpty`, call `get`, and extract values using the `_1` and `_2` members of the returned `NameBased` object.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nobject Extractor {\n  def unapply(x: Any) = new NameBased(1, \"two\")\n}\n\n\"anything\" match {\n  case Extractor(a, b) => println(s\"\\$a, \\$b\") //prints \"1, two\"\n}\n```\n\n----------------------------------------\n\nTITLE: Suppressing Exhaustivity Warnings with runtimeChecked\nDESCRIPTION: Illustrates using `.runtimeChecked` on the scrutinee (`weekDay`) of a `match` expression. This suppresses the compiler warning about non-exhaustive patterns when the programmer asserts that certain cases (e.g., `Some(Sat | Sun)`) are impossible or intentionally unhandled at runtime. Requires a `Day` enum.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/runtimeChecked.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// example 2\nenum Day:\n  case Mon, Tue, Wed, Thu, Fri, Sat, Sun\n\nval weekDay: Option[Day] = ???\n\nweekDay.runtimeChecked match\n  case Some(Mon | Tue | Wed | Thu | Fri) => println(\"got weekday\")\n// case Some(Sat | Sun) => // weekend should not appear\n  case None =>\n```\n\n----------------------------------------\n\nTITLE: Listing Contributors with Git Shortlog (Shell)\nDESCRIPTION: This command utilizes `git shortlog` to summarize commit activity within a specified range of Git tags. The `-sn` flags sort authors by the number of commits and display their names, while `--no-merges` filters out merge commits. It is used here to identify and count individual contributors for a specific release version.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.5.0-RC3.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit shortlog -sn --no-merges 3.5.0-RC2..3.5.0-RC3\n```\n\n----------------------------------------\n\nTITLE: Example: Inspecting Type Representation with PrintTypes (Bash)\nDESCRIPTION: A concrete example demonstrating the usage of the `dotty.tools.printTypes` tool via the sbt shell to inspect the internal representation of the type `Box#X` given a simple class definition `class Box { type X }`. Includes the sbt command and the resulting output showing the TypeRef structure.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/inspection.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nsbt:scala3> scala3-compiler/Test/runMain\n> dotty.tools.printTypes\n> \"class Box { type X }\"\n> \"rhs\"\n> \"Box#X\"\n[info] running (fork) dotty.tools.printTypes \"class Box { type X }\" rhs Box#X\nTypeRef(TypeRef(ThisType(TypeRef(NoPrefix,module class <empty>)),class Box),type X) [class dotty.tools.dotc.core.Types$CachedTypeRef]\n```\n\n----------------------------------------\n\nTITLE: Handling Mixed Java and Scala Generics in Scala Interop - Java\nDESCRIPTION: In this Java snippet, Box and List generics (with Box defined in Scala and List in Java) demonstrate how Scala's nullification function applies to Java classes but not to Scala ones. The class shows method signatures that will be differently nullified in the Scala translation, according to the container type's origin.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_13\n\nLANGUAGE: Java\nCODE:\n```\nclass BoxFactory<T> {\n  Box<T> makeBox(); // Box is Scala-defined\n  List<Box<List<T>>> makeCrazyBoxes(); // List is Java-defined\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Quoted Expressions with Generic Types using Type[T] in Scala\nDESCRIPTION: Demonstrates two functions, `singletonListExpr` and `emptyListExpr`, that generate `Expr[List[T]]` for generic types. They utilize the `Type[T]` type class (provided via context bound or `using` clause) to handle generic types within quotes and require a `using Quotes` context. Requires `scala.quoted.*` import.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.quoted.*\ndef singletonListExpr[T: Type](x: Expr[T])(using Quotes): Expr[List[T]] =\n  '{ List[T]($x) } // generic T used within a quote\n\ndef emptyListExpr[T](using Type[T], Quotes): Expr[List[T]] =\n  '{ List.empty[T] } // generic T used within a quote\n```\n\n----------------------------------------\n\nTITLE: Defining a BigFloat Case Class in Scala\nDESCRIPTION: Defines a simple case class `BigFloat` to serve as an example of a user-defined numeric type that will support generic literals. It stores a mantissa as a `BigInt` and an exponent as an `Int`, providing a basic `toString` representation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ncase class BigFloat(mantissa: BigInt, exponent: Int):\n  override def toString = s\"${mantissa}e${exponent}\"\n```\n\n----------------------------------------\n\nTITLE: The FromDigits Trait for Converting String Digits to Numeric Types\nDESCRIPTION: This code defines the FromDigits trait, which provides a method 'fromDigits' for converting digit strings into numeric values. It serves as the core interface for enabling user-defined numeric types to be constructed from literals.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait FromDigits[T]:\n  def fromDigits(digits: String): T\n```\n\n----------------------------------------\n\nTITLE: Legacy Infix Operator Indentation Example in Scala 3\nDESCRIPTION: This example illustrates the role of leading infix operators and how indentation affects parsing of chained operators and method calls in Scala 3. It is shown to clarify grammar rules regarding indented statement groups, making sure that chained operations bind as expected. There are no imports required; sample values 'one', 'two', and 'three' are assumed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n  one\n  + two.match\n      case 1 => b\n      case 2 => c\n  + three\n```\n\n----------------------------------------\n\nTITLE: Defining a Pure Map Function (Hypothetical Example in Scala)\nDESCRIPTION: A hypothetical example showing how a 'pureMap' function could be defined to enforce that its argument does not throw exceptions, using a pure function type syntax that doesn't currently exist in Scala.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/canthrow.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef pureMap(f: A -> B): List[B]\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Method Syntax in Scala 3 Grammar\nDESCRIPTION: Specifies the Backus-Naur Form (BNF) grammar rules for defining extension methods and collective extensions in Scala 3. It outlines the structure starting with the `extension` soft keyword, optional type parameters (`DefTypeParamClause`), `using` clauses (`UsingParamClause`), the primary parameter (`DefParam`), and the block containing the extension methods (`ExtMethods`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_19\n\nLANGUAGE: BNF\nCODE:\n```\nBlockStat         ::=  ... | Extension\nTemplateStat      ::=  ... | Extension\nTopStat           ::=  ... | Extension\nExtension         ::=  ‘extension’ [DefTypeParamClause] {UsingParamClause}\n                       ‘(’ DefParam ‘)’ {UsingParamClause} ExtMethods\nExtMethods        ::=  ExtMethod | [nl] <<< ExtMethod {semi ExtMethod} >>>\nExtMethod         ::=  {Annotation [nl]} {Modifier} ‘def’ DefDef\n```\n\n----------------------------------------\n\nTITLE: Previous Syntax for Defining Given Extension Methods in Scala 3\nDESCRIPTION: Shows the original syntax for defining `given` instances that provide extension methods in Scala 3. The newer proposed syntaxes (`extension` or `extended with`) aim to improve upon this by making the association between parameters and the extension method more explicit.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ngiven listOps: [T](xs: List[T]) { ... }\n\ngiven (s: String) { ... }\n```\n\n----------------------------------------\n\nTITLE: Equivalent Alias Given and Val in Scala 3 - Scala\nDESCRIPTION: In Scala 3, defines a lazy val pos and creates a given alias for it. The given Position = pos makes pos available as an implicit in the new style. Needs Position class and tree with sourcePos. This separates value creation and given declaration.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nlazy val pos: Position = tree.sourcePos\ngiven Position = pos\n```\n\n----------------------------------------\n\nTITLE: Flow-Sensitive Typing with Compound Null Checks in Scala 3\nDESCRIPTION: Shows how flow-sensitive typing handles compound boolean expressions involving null checks. Within the scope of the `if` condition `s != null && s2 != null`, both `s` and `s2`, initially typed as `String|Null`, are refined to `String` because the condition ensures neither is null.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval s: String|Null = ???\nval s2: String|Null = ???\n\nif (s != null && s2 != null) // s: String and s2: String\n```\n\n----------------------------------------\n\nTITLE: Illustrating Unsoundness with Uninitialized Lazy Values in Scala\nDESCRIPTION: Shows how a self-referential lazy value `p` of type `S` might never be initialized because accessing it causes an infinite loop. Using this uninitialized `p` as a prefix for a type selection `p.T` bypasses runtime checks for bad bounds associated with the type member `T` in `S`, potentially leading to unsoundness.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-02-17-scaling-dot-soundness.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nlazy val p: S = p\n... p.T ...\n```\n\n----------------------------------------\n\nTITLE: Using Aligned Case Clauses in Scala 3 Match Expressions\nDESCRIPTION: This Scala code snippet demonstrates the special indentation rule for `match` and `catch` clauses in Scala 3. It shows how `case` statements can be aligned at the same indentation level as the `match` keyword, and how the indentation region for the cases closes when a non-`case` token or a token with smaller indentation is encountered at that level.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/indentation.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nx match\ncase 1 => print(\"I\")\ncase 2 => print(\"II\")\ncase 3 => print(\"III\")\ncase 4 => print(\"IV\")\ncase 5 => print(\"V\")\n\nprintln(\".\")\n```\n\n----------------------------------------\n\nTITLE: Defining Pattern Syntax with 'as' Binder in Backus-Naur Form - Scala Grammar\nDESCRIPTION: This snippet provides a grammar rule in Backus-Naur Form representing the introduction of the 'as' binder in Scala pattern syntax. It proposes that 'Pattern2' may optionally end with 'as' followed by an identifier, formalizing the new syntax extension. The rule is relevant to Scala 3 language designers and implementers, affecting how pattern matching can be parsed and recognized in the language grammar.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/typeclasses.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nPattern2          ::=  InfixPattern ['as' id]\n```\n\n----------------------------------------\n\nTITLE: Using `given` in Case Pattern Matching in Scala 3\nDESCRIPTION: Demonstrates using the `given` keyword within a `case` pattern in Scala 3. This allows a matched value (like `email`) to be implicitly available to functions called within that `case` block (e.g., `sendEmail`). The type of the `given` variable must be explicitly specified.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-09-23-19th-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nopaque type Email = String\nobject Email\n  def apply(value: String): Email = value\n\ndef sendEmail(given m: Email): Unit =\n  println(s\"Sent an email to $m\")\n\ncase class User(name: String, email: Option[Email])\n\n@main def Test =\n  val user = User(\"Tom\", Some(Email(\"tom@gmail.com\")))\n  user match\n    case User(_, Some(given email: Email)) => sendEmail\n```\n\n----------------------------------------\n\nTITLE: Compiling and Printing TASTy with Bash Commands\nDESCRIPTION: A sequence of Bash commands used to compile a Scala file and then print the contents of its generated TASTy file. This is typically run within a dedicated issue directory workspace. It involves cleaning/creating an output directory, invoking `scalac` to compile, and then using `scalac -print-tasty` on the resulting `.tasty` file.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/inspection.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n$ (rm -rv out || true) && mkdir out # clean up compiler output, create `out` dir.\n\nscala3/scalac -d $here/out $here/Foo.scala\n\nscala3/scalac -print-tasty $here/out/Foo.tasty\n```\n\n----------------------------------------\n\nTITLE: Using MutableScope for Grouping Mutable Object Captures in Scala\nDESCRIPTION: Demonstrates using `MutableScope` within an `object` (`enclave`). A `given` instance `ms` of `MutableScope` ensures that all mutable objects created within this scope automatically use `ms` as their capture set. This allows these objects (and variables holding them) to refer to each other, as they share the same scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nobject enclave:\n  private given ms: MutableScope()\n\n  ...\n```\n\n----------------------------------------\n\nTITLE: Adapting N-ary Function to Tupled Type Scala\nDESCRIPTION: This snippet illustrates the compiler's internal transformation during parameter untupling in Scala 3. It shows an n-ary function literal (p1, ..., pn) => e being adapted into a function that takes a single tuple x: TupleN[T1, ..., Tn] and extracts individual parameters from it before executing the original body e. This adaptation is performed when the expected type is a tupled function type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/parameter-untupling-spec.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n(p1, ..., pn) => e\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(x: TupleN[T1, ..., Tn]) =>\n  def p1: T1 = x._1\n  ...\n  def pn: Tn = x._n\n  e\n```\n\n----------------------------------------\n\nTITLE: Defining the core trait `LzyList` for lazy lists in Scala 3\nDESCRIPTION: This snippet defines the abstract trait `LzyList` representing lazy lists, with essential methods `isEmpty`, `head`, and `tail`. The `tail` method includes a capture annotation indicating potential side effects or references captured by the tail, modeling laziness in the list's tail part. It establishes the basic interface for the lazy list implementation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\ntrait LzyList[+A]:\n  def isEmpty: Boolean\n  def head: A\n  def tail: LzyList[A]^{this}\n```\n\n----------------------------------------\n\nTITLE: Implementing Extension Methods in Scala with Dotty\nDESCRIPTION: This code defines an extension method on the `Circle` class to compute its circumference. It demonstrates how to add methods to existing types after their initial definition using Dotty's language support. The snippet shows defining an extension method and how implicit scope enables their usage without boilerplate.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-01-21-12th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Circle(x: Double, y: Double, radius: Double)\n\ndef (c: Circle) circumference: Double = c.radius * math.Pi * 2\n```\n\n----------------------------------------\n\nTITLE: Emulating for-comprehension aliases using val in Scala\nDESCRIPTION: This snippet emulates the behavior of the new alias-supporting for-comprehensions using val assignments prior to Scala 3.7. Lists are assigned to variables before the for-comprehension, which then binds variables to iterate and yield element sums. This pattern is standard in earlier Scala versions and relies on val for variable introduction.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/preview/better-fors.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval as = List(1, 2, 3)\nval bs = List(4, 5, 6)\nfor\n  a <- as\n  b <- bs\nyield a + b\n```\n\n----------------------------------------\n\nTITLE: Using Quoted Pattern Matchers like `Const` in Scala 3 Macros\nDESCRIPTION: This code showcases how to pattern match on constant expressions within macros using the `Const` extractor from `scala.quoted`. It evaluates a quoted expression, extracts its constant value, and performs a computation, all at compile-time. It relies on the macro quoting API from `scala.quoted` with minimal imports.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-03-18-23rd-dotty-milestone-release.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.quoted._\n\ninline def square(inline x: Int): Int = ${ squareImpl('x) }\ndef squareImpl(xExpr: Expr[Int])(using QuoteContext): Expr[Int] =\n  xExpr match\n    case Const(x) => Expr(x * x)\n```\n\n----------------------------------------\n\nTITLE: Result of Inlining with False Condition in Scala\nDESCRIPTION: Shows the simplified code for the `factorial` function after the `log` method call is inlined, assuming `Config.logging` is `false`. The `if` statement within `log` resolves to the `else` branch, and since the parameters `msg` and `indentMargin` are unused in that branch, the logging logic and parameter evaluations are completely eliminated.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef factorial(n: BigInt): BigInt =\n  if n == 0 then 1\n  else n * factorial(n - 1)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scala 3 Quiet Control Syntax\nDESCRIPTION: This snippet showcases the new 'quiet' control syntax introduced in Scala 3. It provides examples for `if/then/else`, `while/do`, `for` expressions (with `yield` and `do`), and `try/catch` with a single case, illustrating how parentheses and braces can often be omitted according to the new syntax rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/control-syntax.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nif x < 0 then\n  \"negative\"\nelse if x == 0 then\n  \"zero\"\nelse\n  \"positive\"\n\nif x < 0 then -x else x\n\nwhile x >= 0 do x = f(x)\n\nfor x <- xs if x > 0\nyield x * x\n\nfor\n  x <- xs\n  y <- ys\ndo\n  println(x + y)\n\ntry body\ncatch case ex: IOException => handle\n```\n\n----------------------------------------\n\nTITLE: Defining a Conditional `Eq` Instance for Generic Option Types\nDESCRIPTION: Illustrates a more complex, conditional `Eq` instance for `Option`. This implicit definition allows comparing `Option[T]` with `Option[U]` if and only if an implicit `Eq[T, U]` instance exists, meaning the underlying element types `T` and `U` are comparable. It depends on an implicit `Eq[T, U]` being available in scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-05-05-multiversal-equality.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimplicit def eqOption[T, U](implicit _eq: Eq[T, U]): Eq[Option[T], Option[U]] = Eq\n```\n\n----------------------------------------\n\nTITLE: Example of Invalid map Call Throwing a Checked Exception in Java-Style Model - Scala\nDESCRIPTION: Shows an example of a call to 'map' that attempts to throw a checked exception within the mapping function. In Java's checked exception model, this would be disallowed because the function passed to map is not declared to throw any exceptions. The snippet illustrates the inflexibility of Java-style checked exceptions and motivates the need for a better model.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/canthrow.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nxs.map(x => if x < limit then x * x else throw LimitExceeded())\n```\n\n----------------------------------------\n\nTITLE: Using Exported Members in Scala\nDESCRIPTION: Example demonstrating how to use the members exported by a class from outside that class, accessing them as if they were defined directly in the class.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/export.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval copier = new Copier\ncopier.print(copier.scan())\n```\n\n----------------------------------------\n\nTITLE: Using polymorphic functions to map over subexpressions in an expression tree\nDESCRIPTION: Defines a generic function `mapSubexpressions` that takes an expression `Expr[A]` and a polymorphic function `f` that can transform subexpressions of any type `B`. It demonstrates passing a polymorphic function as an argument to process each subexpression accordingly, enabling flexible traversal and transformation of expression trees.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/polymorphic-function-types.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef mapSubexpressions[A](e: Expr[A])(f: [B] => Expr[B] => Expr[B]): Expr[A] =\n  e match\n    case Apply(fun, arg) => Apply(f(fun), f(arg))\n    case Var(n) => Var(n)\n```\n\n----------------------------------------\n\nTITLE: Explicitly Tupling a Function for Mapping in Scala\nDESCRIPTION: Shows the solution to the type mismatch by explicitly converting the `combiner` function (which takes two Ints) into a function that accepts a single tuple argument using the `.tupled` method before passing it to `map`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nxs.map(combiner.tupled)\n```\n\n----------------------------------------\n\nTITLE: Implementing BigFloat String Constructor in Scala\nDESCRIPTION: Provides an `apply` method within the `BigFloat` companion object that parses a string potentially containing a decimal point and/or exponent into a `BigFloat` instance. This method handles separating mantissa and exponent parts, and extracting integer and decimal parts from the mantissa string. It relies on `BigInt` and `Int` constructors for base conversion.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nobject BigFloat:\n  import scala.util.FromDigits\n\n  def apply(digits: String): BigFloat =\n    val (mantissaDigits, givenExponent) =\n      digits.toUpperCase.split('E') match\n        case Array(mantissaDigits, edigits) =>\n          val expo =\n            try FromDigits.intFromDigits(edigits)\n            catch case ex: FromDigits.NumberTooLarge =>\n              throw FromDigits.NumberTooLarge(s\"exponent too large: $edigits\")\n          (mantissaDigits, expo)\n        case Array(mantissaDigits) =>\n          (mantissaDigits, 0)\n    val (intPart, exponent) =\n      mantissaDigits.split('.') match\n        case Array(intPart, decimalPart) =>\n          (intPart ++ decimalPart, givenExponent - decimalPart.length)\n        case Array(intPart) =>\n          (intPart, givenExponent)\n    BigFloat(BigInt(intPart), exponent)\n```\n\n----------------------------------------\n\nTITLE: Implementing Compile-Time Pattern Matching with Inline Match in Scala\nDESCRIPTION: Defines a `transparent inline` function `g` employing `inline match`. This feature performs pattern matching based on the static type of the input `x` known at compile time. The expression reduces to the selected branch, and because `g` is `transparent`, the return type is specialized accordingly (e.g., `(String, String)` or `Double`). A compile-time error occurs if the match cannot be statically determined.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ntransparent inline def g(x: Any): Any =\n  inline x match\n    case x: String => (x, x) // Tuple2[String, String](x, x)\n    case x: Double => x\n\ng(1.0d) // Has type 1.0d which is a subtype of Double\ng(\"test\") // Has type (String, String)\n```\n\n----------------------------------------\n\nTITLE: Using Scala Non-Given Imports (Specific, Rename, Wildcard)\nDESCRIPTION: This Scala code block demonstrates non-given imports from the object `M`. It imports `one` directly, renames `z` to `zero` using `as zero`, and imports all other non-given members using the wildcard `*`. It then uses the imported members `zero` and `one` in a call to `add` (which would be imported by the wildcard).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\n{\n  import M.{one, z as zero, *}\n  add(zero, one)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Extensions Using `using` Clauses in Scala\nDESCRIPTION: Presents an alternative syntax for defining generic extension methods with context bounds. This example redefines the generic `+` operator using an explicit `using n: Numeric[T]` clause instead of the `[T: Numeric]` shorthand.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nextension [T](x: T)(using n: Numeric[T])\n  def + (y: T): T = n.plus(x, y)\n```\n\n----------------------------------------\n\nTITLE: Previous Syntax for Monomorphic Conditional Givens in Scala 3\nDESCRIPTION: Demonstrates the older syntax for non-parameterized (monomorphic) conditional `given` instances, where one given instance depends on another (`given Context` depends on `given outer: Context`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ngiven (given outer: Context): Context = ...\n```\n\n----------------------------------------\n\nTITLE: Scala normal parameters following `given` parameters\nDESCRIPTION: Illustrates the new syntax allowing normal method parameters to follow `given` parameters within method definitions. This enhancement improves the expressiveness and natural structure of methods that depend on implicit parameters, demonstrated with a method `f` taking a normal parameter, a `given` parameter, and another normal parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-11-04-20th-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(val x: Int)\ndef f(x: Int)(given c: C)(y: Int) = x + c.x + y\n```\n\n----------------------------------------\n\nTITLE: Defining the FromDigits Trait in Scala\nDESCRIPTION: Presents the core `FromDigits` trait definition. Any type `T` that intends to support numeric literals via the generic mechanism must provide a `given` instance of `FromDigits[T]` implementing the `fromDigits` method. This method takes a string representation of the literal (with separators removed) and converts it to the type `T`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait FromDigits[T]:\n  def fromDigits(digits: String): T\n```\n\n----------------------------------------\n\nTITLE: Abstract Definition and Alias Given in Scala 3 - Scala\nDESCRIPTION: In Scala 3, an abstract def symDecorator is defined and a given is created to alias it, providing the same implicit contract. Requires SymDecorator trait/object. Facilitates migration from abstract implicits to explicit contextual abstraction.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\ndef symDecorator: SymDecorator\ngiven SymDecorator = symDecorator\n```\n\n----------------------------------------\n\nTITLE: Eta Expansion with Context Parameters Using 'using' in Scala\nDESCRIPTION: This example shows how a method with context parameters (using clause) can be eta-expanded to a value matching a context function type. The method 'foo' takes an Int and a context Double, returning a Float. Assigning 'foo(3)' to 'bar' as a 'Double ?=> Float' demonstrates explicit context typing and assignment. Dependencies: None beyond basic Scala 3 support for context parameters. Parameters: 'x' (Int), 'p' (Double). Returns: Float.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/eta-expansion-spec.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef foo(x: Int)(using p: Double): Float = ???\nval bar: Double ?=> Float = foo(3)\n```\n\n----------------------------------------\n\nTITLE: Asserting Pattern Match Success with runtimeChecked\nDESCRIPTION: Demonstrates using `.runtimeChecked` on the result of `config.get` to assert that the pattern match in the `val` definition (`Some(appVersion)`) will succeed at runtime. This suppresses the compile-time error that would otherwise occur due to the potential non-exhaustivity (if `config.get` returned `None`). Requires an `AppConfig` trait providing a `get` method returning `Option[String]`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/runtimeChecked.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// example 1\ntrait AppConfig:\n  def get(key: String): Option[String]\n\nval config: AppConfig = ???\n\nval Some(appVersion) = config.get(\"appVersion\").runtimeChecked\n```\n\n----------------------------------------\n\nTITLE: Defining a Method with a Custom Main Annotation in Scala\nDESCRIPTION: Example of a method annotated with @myMain, showing how parameters are defined with documentation and default values. This would generate a class with a main method to parse command-line arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/main-annotation.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n/** Sum all the numbers\n *\n *  @param first Fist number to sum\n *  @param rest The rest of the numbers to sum\n */\n@myMain def sum(first: Int, second: Int = 0, rest: Int*): Int = first + second + rest.sum\n```\n\n----------------------------------------\n\nTITLE: Defining Opaque Type and Given Ordering to Prevent Recursive Givens in Scala\nDESCRIPTION: This Scala snippet defines an opaque type alias Price for BigDecimal inside the Prices object. It provides a given Ordering for Price by summoning the existing Ordering for BigDecimal, avoiding a previously occurring infinite recursion in implicit resolution. The snippet demonstrates the new rule that prevents implicit searches from resolving givens recursively when defined within the same owner, thereby stopping runtime infinite loops. Dependencies include Scala 3 compiler with the experimental.givenLoopPrevention import enabled.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/given-loop-prevention.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Prices {\n  opaque type Price = BigDecimal\n\n  object Price{\n    given Ordering[Price] = summon[Ordering[BigDecimal]] // was error, now avoided\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Macro Implementation for BigFloat Compile-Time Validation in Scala\nDESCRIPTION: Defines the `fromDigitsImpl` macro using `scala.quoted.Expr` and `scala.quoted.Quotes`. It checks if the input `digits` expression is a constant string at compile time. If constant, it attempts to parse it using `BigFloat.apply`; on `FromDigitsException`, it reports a compile-time error via `ctx.error`. If not constant, it generates code to call `BigFloat.apply` at runtime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nprivate def fromDigitsImpl(digits: Expr[String])(using ctx: Quotes): Expr[BigFloat] =\n  digits.value match\n    case Some(ds) =>\n      try\n        val BigFloat(m, e) = apply(ds)\n        '{BigFloat(${Expr(m)}, ${Expr(e)})}\n      catch case ex: FromDigits.FromDigitsException =>\n        ctx.error(ex.getMessage)\n        '{BigFloat(0, 0)}\n    case None =>\n      '{apply($digits)}\nend BigFloat\n```\n\n----------------------------------------\n\nTITLE: Ambiguity Error with summonFrom (Scala)\nDESCRIPTION: This snippet illustrates a potential issue with `summonFrom`. Two given instances of class `A` (`a1` and `a2`) are defined. When the inline function `f` attempts to summon a given of type `A` using `summonFrom`, the compiler raises an ambiguity error because it cannot uniquely choose between `a1` and `a2`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.summonFrom\n\nclass A\ngiven a1: A = new A\ngiven a2: A = new A\n\ninline def f: Any = summonFrom {\n  case given _: A => ???  // error: ambiguous givens\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Delegates by Type in Scala\nDESCRIPTION: Introduces the `import delegate ... {for ...}` syntax. This mechanism allows importing delegate instances based on their type, providing a more specific alternative to wildcard imports, especially useful for anonymous delegates.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-06-11-16th-dotty-milestone-release.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport delegate A.{for TC}\n```\n\n----------------------------------------\n\nTITLE: Implementing Extension Methods in Scala 3\nDESCRIPTION: Example of defining an extension method 'toPower' for the Int type, demonstrating how to extend types with methods after they are defined. The method uses tail recursion to calculate integer powers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-02-05-22nd-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef (x: Int) toPower (n: Int): Int =\n  @annotation.tailrec def loop(accum: Int, power: Int): Int =\n    if power == 0 then accum\n    else if power > 0 then loop(accum * x, power - 1)\n    else throw IllegalArgumentException(\"This operation only supports positive powers\")\n  loop(1, n)\n  println(s\"3^3 = ${3.toPower(3)}\")  // 3^3 = 27\n```\n\n----------------------------------------\n\nTITLE: Example of Capture Widening (Avoidance) in Scala Types\nDESCRIPTION: An example demonstrating that a method returning a capturing type must widen to a supertype that excludes local variables in capture sets. Here, a method returning LazyList[Int]^l causes a type error if declared to return LazyList[Int], because local capture set l is not allowed in the result type. The compiler widens the capture set to fs which covers l as per subcapturing rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n11 |def test(using fs: FileSystem^): LazyList[Int] = {\n   |                                                 ^\n   |                                        Found:    LazyList[Int]^{fs}\n   |                                        Required: LazyList[Int]\n```\n\n----------------------------------------\n\nTITLE: Adding Ensuring Methods via Implicit Wrapper\nDESCRIPTION: Demonstrates an implicit wrapper (likely a value class or extension method) provided by `Predef` that adds `ensuring` methods to `Any`. These methods act as postconditions, checking a boolean condition or a predicate function after an expression evaluates and throwing an `AssertionError` if the condition is false.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\ndef ensuring(cond: Boolean): A = { assert(cond); x }\ndef ensuring(cond: Boolean, msg: Any): A = { assert(cond, msg); x }\ndef ensuring(cond: A => Boolean): A = { assert(cond(x)); x }\ndef ensuring(cond: A => Boolean, msg: Any): A = { assert(cond(x), msg); x }\n```\n\n----------------------------------------\n\nTITLE: Applying Flow Typing with Logical Operators in Scala 3\nDESCRIPTION: Illustrates how flow typing works with logical operators (`&&`, `||`). It shows that if a condition using `&&` implies two variables are non-null, their types are refined within the 'then' branch. For `||`, the refinement might occur in the 'else' branch.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nval s: String | Null = ???\nval s2: String | Null = ???\nif s != null && s2 != null then\n  // s: String\n  // s2: String\n\nif s == null || s2 == null then\n  // s: String | Null\n  // s2: String | Null\nelse\n  // s: String\n  // s2: String\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Implicit Conversion Class in Scala\nDESCRIPTION: This snippet defines an abstract class Conversion parameterized on input type T and output type U, extending the function signature T => U in Scala. The Conversion class mandates the implementation of the apply method, transforming values of type T into values of type U, and serves as the foundation for all implicit conversions in Scala 3. No dependencies are required other than the standard library; T and U can be any types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/conversions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Conversion[-T, +U] extends (T => U):\n  def apply (x: T): U\n```\n\n----------------------------------------\n\nTITLE: unsafeNulls Impact on Implicits and Extensions in Scala 3\nDESCRIPTION: Shows that the `unsafeNulls` feature also influences implicit searches and extension methods. It allows implicit conversions designed for non-nullable types to be applied to nullable types where they wouldn't normally type-check under strict explicit nulls rules, aiming for behavioral similarity with regular Scala.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.unsafeNulls\n\nval x = \"hello, world!\".split(\" \").map(_.length)\n\ngiven Conversion[String, Array[String]] = _ => ???\n\nval y: String | Null = ???\nval z: Array[String | Null] = y\n```\n\n----------------------------------------\n\nTITLE: Step-In Command Syntax - Scala 3 Debug Test - Plaintext\nDESCRIPTION: This snippet defines the accepted syntax for the `step` debug action, which expects either a line number or method name as its parameter. The action directs the debugger to enter a method or the next instruction and checks that the current frame matches the expected location. This command is used in .check files for automated debugging tests.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\nstep ${expected line number or method name}\n```\n\n----------------------------------------\n\nTITLE: Adding tupled Extension Method in Scala\nDESCRIPTION: This extension method adds a `tupled` capability to any function `F`, provided there is an implicit `TupledFunction[F, Args => R]` instance. It transforms the function `F` into an equivalent function that accepts a single `Args` tuple. It leverages the `tupled` method from the implicit `TupledFunction` instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/tupled-function.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n/** Creates a tupled version of this function: instead of N arguments,\n *  it accepts a single [[scala.Tuple]] with N elements as argument.\n *\n *  @tparam F the function type\n *  @tparam Args the tuple type with the same types as the function arguments of F\n *  @tparam R the return type of F\n */\nextension [F, Args <: Tuple, R](f: F)\n  def tupled(using tf: TupledFunction[F, Args => R]): Args => R = tf.tupled(f)\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Vals for Types Without Literal Syntax in Scala\nDESCRIPTION: Illustrates defining an `inline val` for types like `Short` that don't have a direct literal syntax matching the type (e.g., there's no `4s` literal for `Short`). The right-hand side (`4`) must still be a constant expression, and the compiler infers the specific constant value (conceptually `Short(4)`) for the inline val.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ntrait InlineConstants:\n  inline val myShort: Short\n\nobject Constants extends InlineConstants:\n  inline val myShort/*: Short(4)*/ = 4\n```\n\n----------------------------------------\n\nTITLE: Summation Function Using Monoid Type Class\nDESCRIPTION: Defines a generic recursive function `sum` to compute the sum of a list of elements using an implicit `Monoid` type class. It depends on the `add` and `unit` operations of `Monoid`, allowing summation of any type with a `Monoid` instance, such as `Int` or `String`. The snippet illustrates implicit parameter inference based on element types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/07-implicits.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum[A](xs: List[A])(implicit m: Monoid[A]): A =\n  if (xs.isEmpty) m.unit\n  else m.add(xs.head, sum(xs.tail))\n```\n\n----------------------------------------\n\nTITLE: Discussion on the semantics of effect annotations and capture sets in effect systems\nDESCRIPTION: This section explains how effect annotations (`cap`) are interpreted differently based on scope, especially within higher-order functions and existentials. It describes internal representations of existential types, their expansion rules, and how captures at various scopes influence effect tracking. The explanation clarifies the internal modeling of effects and the influence on type expansion and error reporting within the effect system.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_34\n\n\n\n----------------------------------------\n\nTITLE: Compiling with Tree IDs in Scala 3\nDESCRIPTION: Demonstrates how to compile a Scala file using the `scalac` compiler with the `-Xprint:typer` flag to show the code after the 'typer' phase and the `-Yshow-tree-ids` flag to output unique integer IDs for each tree node in the printed output. This is useful for inspecting the compiler's internal tree representation and identifying specific nodes by ID.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_14\n\nLANGUAGE: Shell\nCODE:\n```\nscalac -Xprint:typer -Yshow-tree-ids  ../issues/Playground.scala\n```\n\n----------------------------------------\n\nTITLE: Implementation of Type Class for Runtime Type Representation in Scala 3 Macros\nDESCRIPTION: Defines the abstract class Type[T], representing a type abstraction wrapping a type AST and scope. The companion object provides static methods for obtaining type instances via implicit summoning, displaying types as strings, and extracting constant values. The Underlying alias allows internal type referencing, supporting complex meta-programming activities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Type[T <: AnyKind] private[scala]:\n  type Underlying = T\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject Type:\n  given of[T <: AnyKind](using Quotes): Type[T] = ...\n  def show[T <: AnyKind](using Type[T])(using Quotes): String = ...\n  def valueOfConstant[T](using Type[T])(using Quotes): Option[T] = ...\n  def valueOfTuple[T <: Tuple](using Type[T])(using Quotes): Option[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Synthesizing By-Name Context Parameter Argument (Step 1)\nDESCRIPTION: Illustrates the first conceptual step in synthesizing an argument for a by-name context parameter of type `=> T`. A fresh local `given` instance of type `T` (e.g., `given lv: T = ???`) is created internally. This newly created given is not immediately available for argument inference in the current scope to prevent infinite loops but becomes available in nested searches.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/by-name-context-parameters.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ngiven lv: T = ???\n```\n\n----------------------------------------\n\nTITLE: Listing Contributors for Scala 3.6.4 Release using Git\nDESCRIPTION: This shell command uses `git shortlog` to list all contributors who made commits between the `3.6.3` and `3.6.4` tags, excluding merge commits. It sorts the contributors by the number of commits (`-n`) and displays their names and commit counts (`-s`). Requires Git installed and access to the Scala 3 git repository.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.6.4.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit shortlog -sn --no-merges 3.6.3..3.6.4\n```\n\n----------------------------------------\n\nTITLE: Illustrating Eta Expansion Results for Function Types in Scala\nDESCRIPTION: This snippet presents the resulting function types obtained after automatic eta expansion of the previous 'm' method. 'f1' takes two parameters and yields a function, while 'f2' takes a single parameter. This clarifies how partial application impacts the resulting function signatures in Scala 3. Dependencies: The types correspond to the implementation of 'm' from prior examples.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/eta-expansion-spec.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nf1: (Boolean, String) => Int => List[Int]\nf2: Int => List[Int]\n```\n\n----------------------------------------\n\nTITLE: Respecting NotNull Annotations in Java and Scala - Scala\nDESCRIPTION: This Scala snippet is the translated version of a Java class with @NotNull annotations. The translation demonstrates that even with non-nullable outer types, parameter types and inner type arguments may remain nullable as necessary for correctness. It assumes recognized @NotNull annotations and correct classpath setup.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nclass C:\n  val name: String\n  def getNames(prefix: String?): java.util.List[String] // we still need to nullify the paramter types\n  def getBoxedName(): Box[String?] // we don't append `Null` to the outmost level, but we still need to nullify inside\n\n```\n\n----------------------------------------\n\nTITLE: Inspecting Generic Signatures via Reflection (Scala REPL)\nDESCRIPTION: Demonstrates how Dotty 0.5.0-RC1 generates generic signatures that are accessible at runtime via Java reflection. It shows defining a generic class Foo in the Scala REPL and then using classOf and getTypeParameters to inspect the generic type parameters, confirming their presence and names (\"T, U\").\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-12-01-fifth-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> class Foo[T, U]\n// defined class Foo\n\nscala> classOf[Foo[_, _]].getTypeParameters.map(_.getName).mkString(\", \")\nval res0: String = \"T, U\"\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion for Untupling (Discouraged) (Scala)\nDESCRIPTION: Illustrates how a user-defined implicit conversion (`given Conversion`) can simulate untupling for explicitly typed functions. This code defines a conversion that maps a `(Int, Int) => Int` function to a `((Int, Int)) => Int` function using `.tupled`. The text notes this approach is strongly discouraged as parameter untupling is attempted before conversions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/parameter-untupling.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.implicitConversions\n\ntransparent inline given `fallback untupling`: Conversion[(Int, Int) => Int, ((Int, Int)) => Int] = _.tupled\n\nxs.map(combiner)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scala Creator Applications Syntax\nDESCRIPTION: Illustrates the new Creator Applications language feature. This feature generalizes the ability to instantiate a class (like `StringBuilder`) without the `new` keyword, allowing direct calls to the class name followed by constructor arguments, mirroring the syntax used for case classes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-04-15-14th-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass StringBuilder(s: String) {\n  def this() = this(\"\")\n}\nStringBuilder(\"abc\")  // same as new StringBuilder(\"abc\")\nStringBuilder()       // same as new StringBuilder()\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Number Literals in Scala 3\nDESCRIPTION: Demonstrates Scala 3's generic number literal feature using `FromDigits`. A numeric literal (`1234`) is automatically converted to a custom `Digits` type because a `given` instance of `FromDigits[Digits]` is implicitly available, converting the number's string representation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.FromDigits\n\ncase class Digits(ds: List[Char])\n\ngiven as FromDigits[Digits] = (digits: String) => Digits(digits.toList)\n\n@main def test =\n  val x: Digits = 1234\n  println(x)  // Digits(List('1', '2', '3', '4'))\n```\n\n----------------------------------------\n\nTITLE: Local and Argument Capabilities Inherited in Scala Classes\nDESCRIPTION: Explains how local capabilities (defined outside a class but referenced inside) and argument capabilities (constructor parameters) form the captured references of a class, including inheritance by subclasses. The example shows classes Super and Sub with capabilities a, b, and parameter x, and how the final capture set includes all three references after instantiation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nclass Cap extends caps.Capability\n\ndef test(a: Cap, b: Cap, c: Cap) =\n  class Super(y: Cap):\n    def f = a\n  class Sub(x: Cap) extends Super(x)\n    def g = b\n  Sub(c)\n```\n\n----------------------------------------\n\nTITLE: Decomposing Polymorphic Function with Quoted Pattern in Scala\nDESCRIPTION: Illustrates using the experimental feature to match a polymorphic function expression like `[A] => (x: List[A]) => ...`. The pattern `$y[A](x)` captures the function body (`$y`) and includes the type variable `A` and value parameter `x`. Requires `Expr`, `Quotes`, and the experimental feature enabled.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/quoted-patterns-with-polymorphic-functions.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef decomposePoly(x: Expr[Any])(using Quotes): Expr[Int] =\n  x match\n    case '{ [A] => (x: List[A]) => $y[A](x) : Int } =>\n      '{ $y[Int](List(1, 2, 3)) }\n    case _ => Expr(0)\n```\n\n----------------------------------------\n\nTITLE: Installing Dotty via Homebrew on macOS\nDESCRIPTION: These shell commands illustrate how to install and upgrade Dotty using Homebrew on macOS. The first command installs Dotty from the lampepfl tap, and the second command upgrades an existing Dotty installation. This provides convenient access to Dotty releases via a popular package manager.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-10-10-10th-dotty-milestone-release.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nbrew install lampepfl/brew/dotty\n```\n\nLANGUAGE: shell\nCODE:\n```\nbrew upgrade dotty\n```\n\n----------------------------------------\n\nTITLE: Context Function Expansion Rules in Scala 3\nDESCRIPTION: Examples showing how context functions are expanded during compilation, demonstrating different ways of passing arguments to context functions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n  def g(arg: Executable[Int]) = ...\n\n  g(22)      // is expanded to g((ev: ExecutionContext) ?=> 22)\n\n  g(f(2))    // is expanded to g((ev: ExecutionContext) ?=> f(2)(using ev))\n\n  g((ctx: ExecutionContext) ?=> f(3))  // is expanded to g((ctx: ExecutionContext) ?=> f(3)(using ctx))\n  g((ctx: ExecutionContext) ?=> f(3)(using ctx)) // is left as it is\n```\n\n----------------------------------------\n\nTITLE: Observing Union Type Inference with Transparent Trait in Scala REPL\nDESCRIPTION: This REPL session demonstrates how marking a common supertrait (`ID`) as `transparent` affects type inference. When an expression results in values whose types have a common transparent supertype, the compiler infers the more precise Union Type (`UserName | Password`) instead of the supertype, contrasting with the behavior without `transparent`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/union-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> if true then name else password\nval res2: UserName | Password = UserName(Eve)\n\n```\n\n----------------------------------------\n\nTITLE: Example Showing Unsafe Usage Causing Runtime Error in Scala 3\nDESCRIPTION: This example demonstrates how the unsafe usage pattern can cause a runtime IOException. The `later` value holds a closure returned from `usingLogFile`, which tries to write to the file after it has been closed, leading to a crash. It showcases why static capture checking is necessary to prevent capability escape and unsafe resource access.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval later = usingLogFile { file => () => file.write(0) }\nlater() // crash\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with case in for Expressions - Scala\nDESCRIPTION: This example demonstrates the new syntax in Scala 3.2 where using 'case' in a for-generator enables pattern matching with filtering, yielding only those elements of the list that conform to the pattern. No special dependencies are needed. The result output is a list of tuples with elements whose structure matched (x, y), reversed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-bindings.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nfor case (x, y) <- elems yield (y, x)  // returns List((2, 1), (4, 3))\n```\n\n----------------------------------------\n\nTITLE: Importing All Members in a Scala Package - Scala\nDESCRIPTION: This snippet demonstrates how to use the new '*' wildcard syntax to import all members from the 'scala.annotation' package. It requires Scala 3, as the syntax replaces the previous usage of '_'. The import statement is typically placed at the beginning of a file or inside a scope, bringing all publicly available members of the package into visibility. The result is that all definitions inside 'scala.annotation' become accessible in the current scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/imports.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.*  // imports everything in the annotation package\n```\n\n----------------------------------------\n\nTITLE: Current Scala 3 given Syntax (M3)\nDESCRIPTION: This code block demonstrates the current and accepted syntax for declaring 'given' instances and aliases in Scala 3.0.0-M3, where the 'as' keyword has been replaced by a colon (':').\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-12-18-scala3-m3.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ngiven intOrd: Ordering[Int] with\n  ...\ngiven listOrd[T: Ordering]: Ordering[List[T]] with\n  ...\n\ngiven Ordering[Int] with\n  ...\ngiven [T: Ordering]: Ordering[List[T]] with\n  ...\n\ngiven global: ExecutionContext = ForkJoinContext()\ngiven Context = ctx\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Named Tuple Type Alias and Internal Representation\nDESCRIPTION: Defines how named tuples are represented internally using an opaque type in Scala 3, illustrating that they are essentially regular tuples with erased names at runtime. It also shows how a named tuple like Person is mapped to a NamedTuple type with name and age fields, and explains the role of the NamedTuple object containing extension methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/named-tuples.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nopaque type NamedTuple[N <: Tuple, +V <: Tuple] >: V = V\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala 3 Matchable Trait\nDESCRIPTION: This snippet conceptually defines the new 'Matchable' trait and illustrates its position in the Scala 3 type hierarchy, showing it inherits from 'Any' and is mixed into 'AnyVal' and 'Object'. It is designed to improve pattern matching soundness.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-12-18-scala3-m3.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Any:\n  def asInstanceOf\n  def ==\n  def !=\n  def ##\n  def equals\n  def hashCode\n  def toString\n\ntrait Matchable extends Any:\n  def isInstanceOf\n  def getClass\n\nclass AnyVal extends Any, Matchable\n\nclass Object extends Any, Matchable\n```\n\n----------------------------------------\n\nTITLE: Defining Methods with Dependent Types/Parameters (Scala 3)\nDESCRIPTION: Provides a code example illustrating dependent type parameters in Scala 3, made possible by generalized method syntax. The getOrElse method's type parameter V depends on the term parameter k from a preceding clause, showcasing how type bounds can refer to term parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/generalized-method-syntax.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Key { type Value }\ntrait DB {\n  def get(k: Key): Option[k.Value] // dependent result type\n  def getOrElse(k: Key)[V >: k.Value](default: V): V // dependent type parameter\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Capability Polymorphism with Capture Sets in Scala\nDESCRIPTION: Explains how to parameterize types like `Source` with capability capture sets represented by `X^`, enabling flexible registration of listeners with specific capabilities. Includes usage of a sealed trait `CapSet` for defining and instantiating capture sets. Demonstrates registration of listeners with various capabilities and access to the captured set of listeners.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_36\n\nLANGUAGE: Scala\nCODE:\n```\nclass Source[X^]:\n  private var listeners: Set[Listener^{X^}] = Set.empty\n  def register(x: Listener^{X^}): Unit =\n    listeners += x\n\n  def allListeners: Set[Listener^{X^}] = listeners\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass Source[X <: CapSet^]:\n  ...\n\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass Async extends caps.Capability\n\ndef listener(async: Async): Listener^{async} = ???\n\ndef test1(async1: Async, others: List[Async]) =\n  val src = Source[CapSet^{async1, others*}]\n  ...\n  src.register(listener(async1))\n  others.map(listener).foreach(src.register)\n  val ls: Set[Listener^{async, others*}] = src.allListeners\n```\n\n----------------------------------------\n\nTITLE: Expansion of Example Pattern Value Definitions in Scala\nDESCRIPTION: Shows the expanded Scala code corresponding to the pattern-based value definitions (`Some(x)` and `x :: xs`) from the previous example. These expansions explicitly demonstrate the use of `match` expressions to destructure the right-hand side and assign values to the bound variables, using temporary tuples for multi-variable patterns.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval x = f() match { case Some(x) => x }\n\nval x´\\$´ = mylist match { case x :: xs => (x, xs) }\nval x = x´\\$´._1\nval xs = x´\\$´._2\n```\n\n----------------------------------------\n\nTITLE: Merging Given and Wildcard Imports in Scala 3\nDESCRIPTION: This snippet demonstrates how to merge both wildcard and 'given' imports into a single import clause to bring all members, including givens, into scope in Scala 3. It is useful for succinctly importing both regular definitions and given instances. The import must be used in a context where the referenced object (e.g., A) exists and defines givens.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/given-imports.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject B:\n  import A.{given, *}\n   ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Union Type Inference with Transparent Root Classes in Scala\nDESCRIPTION: This short code sample illustrates how a conditional expression using values of different types results in a union type, rather than being widened to the root type Any, due to transparent treatment of root classes in Scala 3. The snippet requires Scala 3. Inputs are a boolean condition and constants of different types; output is their union type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/transparent-traits.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nif condition then 1 else \"hello\"\n```\n\n----------------------------------------\n\nTITLE: Defining and Invoking a Simple Method in Scala\nDESCRIPTION: This snippet defines a simple method in Scala that prints the result of another function 'f()'. There are no dependencies or prerequisites beyond standard Scala function definitions. This demonstrates a pre-instrumented example, before code coverage enhancements are applied. The method 'method' takes no parameters and outputs the result of 'f()' to the console, with the input being whatever 'f()' returns.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/coverage.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef method() =\n  println(f())\n```\n\n----------------------------------------\n\nTITLE: Defining Main Program using Scala 2 App Trait\nDESCRIPTION: Shows the older, less recommended approach in Scala 2 (and limited Scala 3) for creating command-line programs by extending the `App` trait. This method relies on the now-deprecated `DelayedInit` and does not automatically handle command-line argument parsing, requiring manual processing of the `args` vector. Requires the Scala 2 or compatible Scala 3 compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/main-functions.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nobject happyBirthday extends App:\n  // needs by-hand parsing of arguments vector\n  ...\n```\n\n----------------------------------------\n\nTITLE: Using Monoid with Context Bound and summon in Scala\nDESCRIPTION: Demonstrates a generic method `combineAll` that operates on a `List[T]`. It uses a context bound `T: Monoid` to require that type `T` has a `Monoid` instance available. The implementation explicitly fetches the `Monoid` instance using `summon[Monoid[T]]` to access its `unit` and `combine` members for folding the list.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef combineAll[T: Monoid](xs: List[T]): T =\n  xs.foldLeft(summon[Monoid[T]].unit)(_.combine(_))\n```\n\n----------------------------------------\n\nTITLE: Generating Contributor List with Git Shortlog\nDESCRIPTION: This shell command utilizes `git shortlog` to create a summarized and numerically sorted list of contributors based on commit count between the tags `3.0.0-M3` and `3.0.0-RC1`. The `--no-merges` option excludes merge commits from the count, focusing on individual contributions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2021-02-17-scala3-rc1.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\ngit shortlog -sn --no-merges 3.0.0-M3..3.0.0-RC1\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion from List to Ordered\nDESCRIPTION: Provides an implicit conversion `list2ordered` from `List[A]` to `Ordered[List[A]]`, given an implicit conversion `A => Ordered[A]`. Also demonstrates an implicit method to convert `Int` to `Ordered[Int]`. This setup enables automatic ordering of lists and their elements, facilitating sorted operations. It relies on implicit conversions and by-name parameters for recursive conversions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/07-implicits.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def list2ordered[A](x: List[A])\n  (implicit elem2ordered: A => Ordered[A]): Ordered[List[A]] =\n  ...\n\nimplicit def int2ordered(x: Int): Ordered[Int]\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Extension Method in Scala\nDESCRIPTION: Defines an extension method named \"circumference\" for the Circle case class which calculates the circumference of a circle instance by multiplying its radius by 2π. No external dependencies are required aside from the standard math library. The method is invoked directly on instances of Circle using the dot notation as if it were a member method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Circle(x: Double, y: Double, radius: Double)\n\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Automatic Eta Expansion for Methods in Scala 3\nDESCRIPTION: This snippet defines a method `m` with multiple parameter lists and shows how referencing it directly (`val f1 = m`) or applying only the first parameter list (`val f2 = m(true, \"abc\")`) automatically converts it into a function value in Scala 3, without requiring the explicit `_` syntax used in Scala 2.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/eta-expansion.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef m(x: Boolean, y: String)(z: Int): List[Int]\nval f1 = m\nval f2 = m(true, \"abc\")\n```\n\n----------------------------------------\n\nTITLE: Dropping Old `given` Parameter Syntax in Scala 3\nDESCRIPTION: This snippet demonstrates the removal of legacy syntax for context parameters in Scala 3 functions, replacing `given` syntax with the new `using` syntax. The code transitions from `def f(given x: Int)` to `def f(using x: Int)`, simplifying language syntax and improving consistency across the codebase.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-03-18-23rd-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n// OLD SYNTAX, NO LONGER SUPPORTED\ndef f(given x: Int) = x * x\n\n// REPLACEMENT WITH NEW SYNTAX\ndef f(using x: Int) = x * x\n```\n\n----------------------------------------\n\nTITLE: Pattern-Bound Given Instances in For-Comprehensions and Match Clauses - Scala\nDESCRIPTION: Illustrates the updated usage of contextual `given` instances in pattern matching and for-comprehensions in Scala 3.0.0-M1. It shows how to bind `given` instances explicitly within `for` loops and how to pattern match on `given` instances using the `as given` syntax. This facilitates contextual abstractions and enhances the expressiveness of patterns involving implicit parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-11-09-scala3-m1.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nfor given Context <- applicationContexts do\n```\n\nLANGUAGE: Scala\nCODE:\n```\npair match\n  case (ctx as given Context, y) => ...\n```\n\n----------------------------------------\n\nTITLE: Recursive Implicit with By-Name Parameter\nDESCRIPTION: Shows a recursive implicit definition of `Foo` where the implicit argument `rec` is passed by-name (`=> Foo`) to allow recursive self-reference without divergence. This pattern enables defining recursive implicit instances that refer to themselves, with the compiler desugaring the recursion into a local synthetic object containing a lazy val.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/07-implicits.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Foo {\n  def next: Foo\n}\n\nobject Foo {\n  implicit def foo(implicit rec: => Foo): Foo =\n    new Foo { def next = rec }\n}\n\nval foo = implicitly[Foo]\nassert(foo eq foo.next)\n```\n\n----------------------------------------\n\nTITLE: Handling Mixed Java and Scala Generics in Scala Interop - Scala\nDESCRIPTION: The Scala translation shows a modular approach to nullifying generics: Scala-defined containers (Box) have their type arguments made nullable (`T?`), whereas Java-defined containers (List) do not. The example highlights compatibility and safe null handling in mixed-classpath generic code when interoperating with Java libraries.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nclass BoxFactory[T]:\n  def makeBox(): Box[T?]?\n  def makeCrazyBoxes(): java.util.List[Box[java.util.List[T]?]]?\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Nullable Types with Union Types in Scala 3\nDESCRIPTION: Demonstrates how Scala 3 with the `-Yexplicit-nulls` compiler option enabled requires explicit marking of nullable reference types using union types (`|Null`). Assigning `null` directly to a non-union type like `String` results in a compile-time error, whereas assigning it to `String|Null` is permitted.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval x: String = null // error: found `Null`,  but required `String`\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x: String|Null = null // ok\n```\n\n----------------------------------------\n\nTITLE: Eta Expansion with Explicit @use Capture Set Parameter (Scala)\nDESCRIPTION: Illustrates the eta expansion of the `runOpsPoly` method. The inferred capture set `cs` is passed to the `@use` type parameter `C^` of `runOpsPoly`. According to rule 6, this charges `cs` to the environment, resulting in the function type `List[() ->{cs} Unit]) ->{cs} Unit`, which is valid under the proposed design.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/use-design.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n(xs: List[() ->{cs} Unit]) => runOpsPoly[cs](xs)\n```\n\n----------------------------------------\n\nTITLE: Complex example of capability tracking across class boundaries\nDESCRIPTION: An example demonstrating how capabilities can be tracked across different classes and methods, showing capture sets and how capabilities can be indirectly referenced.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass FileSystem\n\nclass Logger(fs: {*} FileSystem):\n  def log(s: String): Unit = ... // Write to a log file, using `fs`\n\ndef test(fs: {*} FileSystem) =\n  val l: {fs} Logger = Logger(fs)\n  l.log(\"hello world!\")\n  val xs: {l} LazyList[Int] =\n    LazyList.from(1)\n      .map { i =>\n        l.log(s\"computing elem # $i\")\n        i * i\n      }\n  xs\n```\n\n----------------------------------------\n\nTITLE: Flow Typing for Nullability Checks in Scala - Scala\nDESCRIPTION: This code demonstrates Scala 3's flow typing and flow-sensitive inference: after null comparison on a stable variable, subsequent branches can safely rely on the variable's non-null type. The snippet shows null-check patterns supporting safer code when working with nullable types from Java.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nval s: String | Null = ???\nif s != null then\n  // s: String\n\n// s: String | Null\n\nassert(s != null)\n// s: String\n\n```\n\n----------------------------------------\n\nTITLE: Defining Refined Types in Scala 3 EBNF\nDESCRIPTION: This EBNF specifies refined types, supporting syntax such as 'Type { Refinement }', with 'Refinement' for abstract type members, methods, or value declarations. Refined types extend base types with additional contract specifications for members and may involve overriding rules and structural typing exceptions. Understanding this requires familiarity with Scala's type member and method/type refinement concepts.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_24\n\nLANGUAGE: ebnf\nCODE:\n```\nRefinedType  ::=  Type ‘{‘ Refinement ‘}‘\nRefinement   ::=  ‘type‘ id TypeAliasOrBounds\n               |  ‘def‘ id ‘:‘ TypeOrMethodic\n               |  ‘val‘ id ‘:‘ Type\n```\n\n----------------------------------------\n\nTITLE: Defining Members within a Scala Package\nDESCRIPTION: Demonstrates the basic syntax for defining members within a named package (`org.net.prj`) using the `package` keyword and curly braces. Members defined inside are directly accessible within the package scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/09-top-level-definitions.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\npackage org.net.prj {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using While for Loop-and-a-Half Problem in Scala 3\nDESCRIPTION: Illustrates how the new `while` syntax can solve the \"loop-and-a-half\" problem. It fetches the next element `x` from an `iterator` and checks if `x >= 0` within the condition block. If the condition is true, the loop body `print(\".\")` is executed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/do-while.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nwhile\n  val x: Int = iterator.next\n  x >= 0\ndo print(\".\")\n```\n\n----------------------------------------\n\nTITLE: Desugaring Parameterized Type Aliases in Scala 3\nDESCRIPTION: Describes transforming parameterized type aliases into unparameterized ones by wrapping the alias right-hand side in a type lambda that captures the original type parameters. This simplifies parameterized alias definitions to a single type alias with a type lambda representing parameters and alias body. Dependencies include knowledge of type lambdas in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ntype ´t´[´\\mathit{tps}¬¬´] = ´T´\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype ´t´ = [´\\mathit{tps'}¬¬´] =>> ´T´\n```\n\n----------------------------------------\n\nTITLE: Generated Code for Lazy Val Implementation in Scala 3\nDESCRIPTION: The equivalent code generated by the Scala 3 compiler for a lazy val declaration. This implementation uses a state-based approach with bitmap flags to handle concurrent initialization safely.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/lazy-vals-init.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Foo {\n  import scala.runtime.LazyVals\n  var value_0: Int = _\n  var bitmap: Long = 0L\n  val bitmap_offset: Long = LazyVals.getOffset(classOf[LazyCell], \"bitmap\")\n\n  def bar(): Int = {\n    while (true) {\n      val flag = LazyVals.get(this, bitmap_offset)\n      val state = LazyVals.STATE(flag, <field-id>)\n\n      if (state == <state-3>) {\n        return value_0\n      } else if (state == <state-0>) {\n        if (LazyVals.CAS(this, bitmap_offset, flag, <state-1>, <field-id>)) {\n          try {\n            val result = <RHS>\n            value_0 = result\n            LazyVals.setFlag(this, bitmap_offset, <state-3>, <field-id>)\n            return result\n          }\n          catch {\n            case ex =>\n              LazyVals.setFlag(this, bitmap_offset, <state-0>, <field-id>)\n              throw ex\n          }\n        }\n      } else /* if (state == <state-1> || state == <state-2>) */ {\n        LazyVals.wait4Notification(this, bitmap_offset, flag, <field-id>)\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Trailing Commas in Multi-line Expressions in Scala\nDESCRIPTION: Illustrates the use of trailing commas in multi-line expressions, such as function call argument lists. If a comma is followed immediately by a newline and a closing parenthesis, bracket, or brace, it is ignored, simplifying the addition or removal of list elements.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nfoo(\n  23,\n  \"bar\",\n  true,\n)\n```\n\n----------------------------------------\n\nTITLE: Obsolete Scala 3 Context Function Syntax (M2)\nDESCRIPTION: This code demonstrates the obsolete syntax for defining a context function closure using the 'using' keyword, which was valid in Scala 3.0.0-M2.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-12-18-scala3-m3.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n(using s: Show[String]) => s.show(\"foobar\")\n```\n\n----------------------------------------\n\nTITLE: Using Transparent Traits to Simplify Inferred Types (Scala)\nDESCRIPTION: This Scala example shows how declaring a trait `S` as `transparent` prevents it from appearing in the inferred type of `x`. Although both `Var` and `Val` extend `Kind` and the transparent trait `S`, the type inference mechanism drops `S`, resulting in the simpler and more desirable inferred type `Set[Kind]` for `x`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/transparent-traits.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntransparent trait S\ntrait Kind\nobject Var extends Kind, S\nobject Val extends Kind, S\nval x = Set(if condition then Val else Var)\n```\n\n----------------------------------------\n\nTITLE: Importing Delegates by Type with Multiple Bounds and Wildcards in Scala\nDESCRIPTION: Demonstrates using the `import delegate ... {for ...}` syntax with multiple type bounds and a wildcard in a type constructor. This imports delegate instances that match any of the specified types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-06-11-16th-dotty-milestone-release.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nimport delegate Delegates.{for Ordering[_], ExecutionContext}\n```\n\n----------------------------------------\n\nTITLE: Defining a Polymorphic Function Type in Scala\nDESCRIPTION: Illustrates the syntax for a polymorphic function type. This specific type `[A] => List[A] => List[A]` represents functions that first accept a type parameter `A`, then accept a value parameter of type `List[A]`, and finally return a result of type `List[A]`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/polymorphic-function-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n[A] => List[A] => List[A]\n```\n\n----------------------------------------\n\nTITLE: Numeric Value Type equals Method Implementation in Scala\nDESCRIPTION: Shows how the equals method is implemented for numeric value types in Scala, handling various numeric type comparisons through pattern matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef equals(other: Any): Boolean = other match {\n  case that: Byte   => this == that\n  case that: Short  => this == that\n  case that: Char   => this == that\n  case that: Int    => this == that\n  case that: Long   => this == that\n  case that: Float  => this == that\n  case that: Double => this == that\n  case _ => false\n}\n```\n\n----------------------------------------\n\nTITLE: Generated CanEqual Instance for Generic Box Class\nDESCRIPTION: Shows the CanEqual instance that's automatically generated in the companion object when deriving CanEqual for a generic Box class, enabling comparison of boxes with compatible element types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ngiven [T, U](using CanEqual[T, U]): CanEqual[Box[T], Box[U]] =\n  CanEqual.derived\n```\n\n----------------------------------------\n\nTITLE: Applying Method with Multiple Type Clauses & Error (Scala 3)\nDESCRIPTION: Shows how method application works with generalized syntax, including type inference for rightmost clauses. It also demonstrates a type error where explicitly providing a type for the first clause (Char for I) violates its defined upper bound (Int), highlighting type checking behavior with this syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/generalized-method-syntax.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef triple[I <: Int](using Ordering[I])[C <: Char](a: I, b: C) = ???\ntriple[Char](0, 'c') // error: Char does not conform to upperbound Int\n```\n\n----------------------------------------\n\nTITLE: Java Interop and unsafeNulls Limitation in Scala 3\nDESCRIPTION: Shows a scenario with Java interoperation where `unsafeNulls` is insufficient to resolve type errors. A Java method like `java.util.List.get` returns `T | Null` in Scala 3. Even with `unsafeNulls`, the compiler cannot unsafely cast `T | Null` to `T` without user intervention (`.nn`) if `T` could potentially be a value type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\ndef head[T](xs: java.util.List[T]): T = xs.get(0) // error\n```\n\n----------------------------------------\n\nTITLE: Compiler Synthesized `TypeTest` Instance in Scala\nDESCRIPTION: Explains that if no specific `TypeTest` instance is found in the implicit scope, the Scala compiler will synthesize a default one. This synthesized instance performs a standard runtime class check (`case s: B =>`). However, this might lead to unchecked warnings if the type test cannot be guaranteed to be sound at compile time.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nnew TypeTest[A, B]:\n  def unapply(s: A): Option[s.type & B] = s match\n    case s: B => Some(s)\n    case _ => None\n```\n\n----------------------------------------\n\nTITLE: Refutable List Head Decomposition without Unchecked Annotation - Scala\nDESCRIPTION: This snippet attempts a head-tail decomposition of a List using a val binding without marking the right-hand side as unchecked. In Scala 3.2, this triggers a compile-time warning unless the list's non-emptiness is guaranteed; in Scala 2, it would compile but could fail at runtime. Requires careful input validation to avoid potential errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-bindings.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval first :: rest = elems   // error\n```\n\n----------------------------------------\n\nTITLE: Previous Error Message for Missing `else` in Scala\nDESCRIPTION: Displays the type mismatch error message generated by older Dotty versions when an `if` statement without an `else` clause is used in a context expecting a non-Unit type (like `Int`). This serves as a comparison point for the improved error message in 0.24.0-RC1.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-04-29-24th-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n-- [E007] Type Mismatch Error: ...\n12 |def f: Int = if ??? then 1\n   |             ^^^^^^^^^^^^^\n   |             Found:    Unit\n   |             Required: Int\n```\n\n----------------------------------------\n\nTITLE: Installing Dotty Using Homebrew Shell Command\nDESCRIPTION: This shell command installs the Dotty compiler using Homebrew, a popular package manager for macOS and Linux. It requires Homebrew to be installed and configured. Executing this command fetches and installs the latest Dotty release from the lampepfl/brew tap repository, making the Dotty compiler and related tools available system-wide from the command line.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-05-31-first-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbrew install lampepfl/brew/dotty\n```\n\n----------------------------------------\n\nTITLE: Identifying a Specific Tree in Compiler Code (Preliminary) - Scala\nDESCRIPTION: A placeholder or conceptual snippet illustrating how one might identify a specific tree node within the compiler's code based on its structure or properties (e.g., using `.show`). This snippet serves as motivation for needing a mechanism to find the creation site when you have a reference to the object.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nif (tree.show == \"\"\"println(\"Hello World\")\"\"\") {\n  val creationSite = \"<creation site stack here>\"\n  println(creationSite)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Structural Instance: Defining Anonymous Methods in Scala\nDESCRIPTION: This Scala snippet demonstrates creating an anonymous structural type instance with a single method 'getName' returning a string constant. No prerequisites other than a Scala 3 environment are required. The code does not take parameters, and produces an object of an anonymous type implementing the method; this is used to show Scala's concise syntax for structural typing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nnew { def getName() = \"aaron\" }\n```\n\n----------------------------------------\n\nTITLE: Illustrating Right-Associative Extension Method Expansion in Scala\nDESCRIPTION: Demonstrates how the Scala compiler internally transforms the definition of a right-associative extension method. It shows the reordered parameter sequence where the right type parameter and right parameter are moved before the left parameter and trailing using clauses, which is crucial for understanding parameter order during implementation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/right-associative-extension-methods.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n  <extension> def +:: [T]\n                      (using a: A, b: B)(using c: C)\n                      [U]\n                      (y: Y)\n                      (x: X)\n                      (using d: D)\n                      (using e: E)(z: Z)\n```\n\n----------------------------------------\n\nTITLE: Demonstrate unchecked warnings for type erasure in Scala\nDESCRIPTION: This snippet exemplifies how Dotty emits unchecked warnings when performing runtime type tests on generic types like List[String], highlighting type erasure limitations. It also demonstrates Scala's smarter handling to avoid some false warnings with refined type patterns, illustrating advanced type-matching capabilities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-04-27-eighth-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef foo(x: Any) = x.isInstanceOf[List[String]]\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Marker\n\ndef foo[T](x: T) = x match {\n  case _: T with Marker  => // scalac emits a spurious warning\n  case _ =>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Macro using a Top-Level Splice in Scala\nDESCRIPTION: Illustrates a basic macro definition `power2` using a top-level splice. The expression `unrolledPowerCode('x, 2)` is executed during compilation, and the generated code `Expr` representing `x * x` becomes the body of the `power2` function. Assumes `unrolledPowerCode` is defined and a `Quotes` context is available during compilation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndef power2(x: Double): Double =\n  ${ unrolledPowerCode('x, 2) } // x * x\n```\n\n----------------------------------------\n\nTITLE: Using Monoid Companion Object for Cleaner Syntax in Scala\nDESCRIPTION: Rewrites the `combineAll` method using the `Monoid` companion object. Calling `Monoid[T]` implicitly summons the `Monoid` instance for type `T`, allowing access to `unit`. The `combine` method is accessed via the extension method provided by the summoned `Monoid` instance. This results in cleaner code compared to using `summon` directly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef combineAll[T: Monoid](xs: List[T]): T =\n  xs.foldLeft(Monoid[T].unit)(_.combine(_))\n```\n\n----------------------------------------\n\nTITLE: Printing Compiler Trees after Typer Phase - Shell\nDESCRIPTION: Instructs the Scala compiler to print abstract syntax trees after the 'typer' phase by using the '-Xprint:typer' flag. Intended for advanced introspection of how source code is transformed at this compiler phase. The input file path should point to a valid Scala source file, and the output will be printed to standard output.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nscalac -Xprint:typer ../issues/Playground.scala\n```\n\n----------------------------------------\n\nTITLE: Experimental Extends Clauses in Scala 3\nDESCRIPTION: Describes that the extends clause of experimental classes, traits, or objects is considered an experimental scope. If the base class is experimental, a subclass must be experimental to extend it without compile errors. Non-experimental classes extending experimental superclasses or using experimental defs produce errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/experimental-defs.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.experimental\n\n@experimental def x = 2\n\n@experimental class A1(x: Any)\nclass A2(x: Any)\n\n\n@experimental class B1 extends A1(1)\nclass B2 extends A1(1) // error: class A1 is marked @experimental and therefore marked @experimental and therefore ...\n\n@experimental class C1 extends A2(x)\nclass C2 extends A2(x) // error def x is marked @experimental and therefore\n```\n\n----------------------------------------\n\nTITLE: Defining scala.Selectable Marker Trait in Scala\nDESCRIPTION: This snippet defines the universal marker trait scala.Selectable in Scala 3, which enables programmatic structural types. It is a trait that extends Any and serves as a base for implementations that provide dynamic member selection via selectDynamic and applyDynamic methods. No additional dependencies are required, and it forms a key component of Scala 3's approach to structural types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types-spec.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Selectable extends Any\n```\n\n----------------------------------------\n\nTITLE: Defining run and withQuotes functions in scala.quoted.staging\nDESCRIPTION: This snippet declares the `run` and `withQuotes` functions within the `scala.quoted.staging` package, enabling execution of staged expressions (`Expr[T]`) at runtime and providing scoped quoting capabilities. Both functions depend on an implicit `Compiler` context and facilitate capturing expressions within scope for evaluation or quoting.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/staging.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef run[T](expr: Quotes ?=> Expr[T])(using Compiler): T = ...\n\ndef withQuotes[T](thunk: Quotes ?=> T)(using Compiler): T = ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Call-Site Inconsistencies for Right-Associative Extension Methods in Scala\nDESCRIPTION: Highlights the requirement to manually invert the order of arguments when calling a right-associative extension method using the dot or prefix notation, contrasting it with the parameter order defined in the method signature. This shows a potential point of confusion for users calling these methods non-infix.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/right-associative-extension-methods.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n  extension [T](x: T)\n    def *:(xs: List[T]): List[T] = ...\n\n  y.*:(ys) // error when following the parameter definition order\n  ys.*:(y)\n\n  *:(y)(ys) // error when following the parameter definition order\n  *:(ys)(y)\n```\n\n----------------------------------------\n\nTITLE: Exporting Members from an Object in Scala 3\nDESCRIPTION: Defines an object `O` with a nested class `C` and a method `m`. It then uses `export O.*` to demonstrate how both the type `C` and the method `m` are aliased in the current scope, showing the resulting generated code with appropriate type and method definitions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject O:\n  class C(val x: Int)\n  def m(c: C): Int = c.x + 1\nexport O.*\n  // generates\n  //   type C = O.C\n  //   def m(c: O.C): Int = O.m(c)\n```\n\n----------------------------------------\n\nTITLE: Listing Git Contributors Between Dotty Releases\nDESCRIPTION: Uses the 'git shortlog' command to list contributors and the count of their commits between the tags '0.2.0-RC1' and '0.3.0-RC2'. The '-s' flag summarizes counts, '-n' sorts numerically, and '--no-merges' excludes merge commits. Requires Git and access to the project's repository history.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-09-07-third-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ngit shortlog -sn --no-merges 0.2.0-RC1..0.3.0-RC2\n```\n\n----------------------------------------\n\nTITLE: Reporting with Debug Wrappers and Assertions - Scala\nDESCRIPTION: Utilizes a non-intrusive reporting mechanism by calling 'reporting' within the 'assertPositioned' method for the compiler tree. The 'reporting' extension method attaches a debug message to the assertion and accesses the 'result' variable for contextual output. No changes are made to the object itself, and the method leverages a tiny framework for enhanced reporting on all types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nassertPositioned(tree.reporting(s\"Tree is: $result\"))\n```\n\n----------------------------------------\n\nTITLE: Scala `then` keyword made optional at line end\nDESCRIPTION: Shows how the `then` keyword after `if` statements is now optional at the end of a line when the following block or expression exceeds a single line. This syntactic flexibility simplifies writing multi-line conditionals, reducing verbosity without sacrificing clarity.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-11-04-20th-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval y1 =\n  if x > 0\n    1\n  else\n    2\n```\n\n----------------------------------------\n\nTITLE: Defining a MutableScope Class in Scala\nDESCRIPTION: Defines the `MutableScope` class, which extends `Mutable`. Instances of this class are used to group mutable objects, allowing them to share the same capture set (`ms` instead of `cap`) for coarser-grained separation checking, particularly useful in scenarios like constructing doubly linked lists.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nclass MutableScope extends Mutable\n```\n\n----------------------------------------\n\nTITLE: Replacing Dropped Procedure Syntax with Valid Scala 3 Syntax\nDESCRIPTION: Presents the recommended ways to define methods in Scala 3 that perform side effects and do not return meaningful values. These alternatives explicitly use an equals sign and, optionally, declare Unit as a return type with a block body. It details the correct syntax replacing the dropped procedure syntax ensuring code compatibility with Scala 3 standards.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/procedure-syntax.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef f() = { ... }\ndef f(): Unit = { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining Type Constraint Class <:<\nDESCRIPTION: Defines the sealed abstract class `<:<`, which extends `From => To`. This class is used in implicit parameters to enforce type constraints at compile time, ensuring that a type `From` is a subtype of `To`. Instances are typically generated implicitly by the compiler for cases where `From` is indeed a subtype of `To`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nsealed abstract class <:<[-From, +To] extends (From => To)\n```\n\n----------------------------------------\n\nTITLE: Referencing Experimental Classes and Types in Scala 3\nDESCRIPTION: Examples demonstrating that instantiating or assigning experimental classes or types outside experimental scopes causes errors. Includes classes, type aliases, and opaque types annotated @experimental and shows their usage limitations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/experimental-defs.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.experimental\n\n@experimental class A\n@experimental type X\n@experimental type Y = Int\n@experimental opaque type Z = Int\n\ndef test: Unit =\n  new A // error: class A is marked @experimental and therefore ...\n  val i0: A = ??? // error: class A is marked @experimental and therefore ...\n  val i1: X = ??? // error: type X is marked @experimental and therefore ...\n  val i2: Y = ??? // error: type Y is marked @experimental and therefore ...\n  val i2: Z = ??? // error: type Y is marked @experimental and therefore ...\n  ()\n```\n\n----------------------------------------\n\nTITLE: Deriving instances for types with parameters of matching kinds\nDESCRIPTION: This code illustrates how Scala 3's derivation supports cases where the type arguments of 'F' and 'DerivingType' are aligned in kind and position, generating instances directly for the type with corresponding type parameters. It simplifies creation of type class instances for parameter-rich types using the '=>>' lambda syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ngiven TC[ [A_1, ..., A_K] =>> DerivingType[A_1, ..., A_K] ] = TC.derived\n```\n\n----------------------------------------\n\nTITLE: Unsafe usage of usingLogFile that capture checking can detect\nDESCRIPTION: An example of code that would fail capture checking because LazyList defers computation, potentially using the file capability after it's been closed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval xs = usingLogFile { f =>\n  LazyList(1, 2, 3).map { x => f.write(x); x * x }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Explicit Function with .tupled (Scala)\nDESCRIPTION: Shows the correct way to apply an explicitly typed function `combiner: (Int, Int) => Int` to a list of tuples `xs`. The function is explicitly converted to a tupled version using `.tupled`, yielding a function of type `((Int, Int)) => Int` that is compatible with `xs.map`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/parameter-untupling.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nxs.map(combiner.tupled)\n```\n\n----------------------------------------\n\nTITLE: Handling Nullability and Java Interoperability in Scala 3\nDESCRIPTION: This snippet focuses on nullability support, including adding flexible types to handle Java signatures under `-Yexplicit-nulls`, extending quotes library to support flexible types, and providing a `fromNullable` method in `Predef` for explicit null handling. It enhances Java interoperability and null safety.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.5.0-RC1.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n# Nullability\n\n- Add flexible types to deal with Java-defined signatures under -Yexplicit-nulls [#18112]\n- Fix #20287: Add flexible types to Quotes library [#20293]\n- Add fromNullable to Predef for explicit nulls [#20222]\n```\n\n----------------------------------------\n\nTITLE: Defining Structural Types with Common Methods in Scala\nDESCRIPTION: This snippet defines a structural type Closeable requiring a close method, along with example classes FileInputStream and Channel (both of which define close). This enables unified treatment of different types that happen to have a close method, without requiring them to share a common interface. Dependencies are standard Scala type and class declarations. The Closeable type is employed later to enforce structure during runtime method calls.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntype Closeable = { def close(): Unit }\n\nclass FileInputStream:\n  def close(): Unit\n\nclass Channel:\n  def close(): Unit\n```\n\n----------------------------------------\n\nTITLE: Printing Compiler Trees after Multiple Phases - Shell\nDESCRIPTION: Leverages the '-Xprint' option to output compiler trees after both 'typer' and 'collectSuperCalls' phases. This is useful for analyzing transformations across specific compilation stages. Parameters are comma-separated phase names; source path must be specified.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nscalac -Xprint:typer,collectSuperCalls ../issues/Playground.scala\n```\n\n----------------------------------------\n\nTITLE: Implementing Reader Monad using Type Lambda Alias in Scala\nDESCRIPTION: Provides a `given` instance `configDependentMonad` implementing `Monad` directly using the type lambda syntax `[Result] =>> Config => Result`. This version is functionally identical to the one using the intermediate type alias but demonstrates the direct use of type lambdas in `given` definitions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\ngiven configDependentMonad: Monad[[Result] =>> Config => Result] with\n\n  def pure[A](x: A): Config => A =\n    config => x\n\n  extension [A](x: Config => A)\n    def flatMap[B](f: A => Config => B): Config => B =\n      config => f(x(config))(config)\n\nend configDependentMonad\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Longest Match Rule for Identifiers (Scala)\nDESCRIPTION: Illustrates how the Scala lexer applies the longest match rule when tokenizing a sequence of characters that could potentially form multiple identifiers. The string `big_bob++=`def`` is parsed into three distinct tokens: `big_bob`, `++=`, and `def`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nbig_bob++=`def`\n```\n\n----------------------------------------\n\nTITLE: Introducing Implied Instance and Inferable Parameters\nDESCRIPTION: Shows new Scala 3 syntax for defining implied instances with 'implied ... for' and designated implied parameters with 'given'. The example includes trait 'Ord' and implied implementations for 'Int' and 'List[T]', utilizing the new syntax to clarify roles and improve code readability.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Ord[T] { ... }\n\nimplied IntOrd for Ord[Int] { ... }\n\nimplied ListOrd[T] given (ord: Ord[T]) for Ord[List[T]] { ... }\n```\n\n----------------------------------------\n\nTITLE: Setting up Types for Reader Monad Example in Scala\nDESCRIPTION: Prepares for the Reader Monad example by defining a `Config` trait and two functions, `compute` and `show`. Both functions are curried, taking an initial parameter (`Int` or `String`) and returning a function that expects a `Config` object to produce the final result (`String` or `Unit`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Config\n// ...\ndef compute(i: Int)(config: Config): String = ???\ndef show(str: String)(config: Config): Unit = ???\n```\n\n----------------------------------------\n\nTITLE: Debugging Tree Creation by ID in Scala 3\nDESCRIPTION: Illustrates how to use the `scalac` compiler flag `-Ydebug-tree-with-id` followed by a tree ID (e.g., `1049`) to trigger a debug prompt (`a)bort, s)tack, r)esume`) when the compiler allocates the tree object with that specific ID. This is useful for inspecting the tree's creation site or state during compilation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_16\n\nLANGUAGE: Shell\nCODE:\n```\nscalac -Ydebug-tree-with-id 1049 ../issues/Playground.scala\n```\n\n----------------------------------------\n\nTITLE: Null-Adjusting Java Fields and Methods for Scala Interop - Java\nDESCRIPTION: This Java snippet defines a class with both reference and value types to illustrate how the Scala compiler applies nullification rules: reference types become nullable (`?`) while primitives remain unchanged. The example serves as input for Scala 3 translation demonstrating type adaptation between Java and Scala during interop.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_7\n\nLANGUAGE: Java\nCODE:\n```\nclass C {\n  String s;\n  int x;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala 3 `Expr` Abstract Class\nDESCRIPTION: Shows the definition of the abstract class `Expr[+T]`, which serves as the runtime representation for quoted expressions of type `T` in Scala 3 macros. This class is implemented internally by the compiler and encapsulates a typed Abstract Syntax Tree (AST) along with a `Scope` object used for tracking splice scopes and preventing scope extrusion.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Expr[+T] private[scala]\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Ref Class in Scala 3\nDESCRIPTION: Defines a generic mutable reference class Ref with a private mutable variable of generic type T. It includes getter and setter methods. This snippet illustrates the concept of capture checking in the context of mutable variables without annotations for sealed type parameters, aligning with the revised approach.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Proc = () => Unit\n\nclass Ref[T](init: T):\n  private var x: T = init\n  def get: T = x\n  def set(y: T) = { x = y }\n```\n\n----------------------------------------\n\nTITLE: Compiler Warning for Ad-Hoc Extension Without Opt-In\nDESCRIPTION: Displays the feature warning issued by the Scala 3 compiler when attempting to extend a class in a separate file that is neither `open` nor `final`, without explicitly enabling the `adhocExtensions` language feature via import or compiler option.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/open-classes.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n-- Feature Warning: EncryptedWriter.scala:6:14 ----\n  |class EncryptedWriter[T: Encryptable] extends Writer[T]\n  |                                              ^\n  |Unless class Writer is declared 'open', its extension\n  | in a separate file should be enabled\n  |by adding the import clause 'import scala.language.adhocExtensions'\n  |or by setting the compiler option -language:adhocExtensions.\n```\n\n----------------------------------------\n\nTITLE: Flow Typing with Match Statements for Non-Null Cases - Scala\nDESCRIPTION: This Scala 3 snippet shows that match-case statements can be used for flow-sensitive type narrowing, with the type checker recognizing when a nullable variable is non-null in a given case. The code is intended for interoperability scenarios where nullable types may result from Java method calls.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\nval s: String | Null = ???\n\ns match\n  case _: String => // s: String\n  case _ =>\n\n```\n\n----------------------------------------\n\nTITLE: Implementing the empty lazy list `LzyNil` as a singleton object\nDESCRIPTION: This snippet provides the implementation of an empty lazy list object `LzyNil`, extending `LzyList[Nothing]`. It defines `isEmpty` returning `true` and leaves `head` and `tail` undefined (placed as `???`) indicating the absence of elements. It functions as the base case for constructing non-empty lazy lists.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\nobject LzyNil extends LzyList[Nothing]:\n  def isEmpty = true\n  def head = ???\n  def tail = ???\n```\n\n----------------------------------------\n\nTITLE: Simplified Wildcard Given Imports in Scala 3 - Scala\nDESCRIPTION: Shows the revised syntax for importing all given instances from a package or object in Scala 3.0.0-M1. The old import syntax `import p.{given _}` is replaced with the cleaner `import p.given`. This syntactic simplification enhances code clarity and enforces uniformity in contextual imports.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-11-09-scala3-m1.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport p.{given _}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport p.given\n```\n\n----------------------------------------\n\nTITLE: Using Type Aliases as Class Constructors in Scala 3\nDESCRIPTION: Demonstrates how a type alias referring to a parameterized class in Scala 3 can be paired with a companion object providing constructor and extractor methods, effectively allowing usage of the alias as an object constructor. Dependencies include understanding of Scala's companion objects and apply/unapply conventions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\ntype Pair[+A, +B] = Tuple2[A, B]\nobject Pair {\n  def apply[A, B](x: A, y: B) = Tuple2(x, y)\n  def unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x: Pair[Int, String] = new Pair(1, \"abc\")\n```\n\n----------------------------------------\n\nTITLE: Combined Lambda for Multiple Holes During Unpickling\nDESCRIPTION: Optimization technique that combines multiple splice lambdas into a single function that dispatches based on hole index. This reduces the overhead of creating multiple lambda instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\n(idx: Int, args: Seq[Any]) =>\\n  idx match\\n    case 0 => // for << 0; Double; x, n >>\\n      val x = args(0).asInstanceOf[Expr[Double]]\\n      val n = args(1).asInstanceOf[Expr[Int]]\\n      powerCode(x, n)\\n    case 1 => // for << 1; Double; n >>\\n      val n = args(0).asInstanceOf[Expr[Int]]\\n      powerCode('{2}, n)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Covariance Impact on GADT Inference in Scala\nDESCRIPTION: Demonstrates with `Expr[+A]` (covariant) and standard class inheritance (`IntList`, `Weird`) why GADT constraints cannot be reliably inferred from covariant type parameters in non-case classes. The `Weird` class breaks the expected type relationship.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/gadts.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass Expr[+A]\nclass IntList extends Expr[List[Int]]\n\ndef foo[T](e: Expr[List[T]]): T =\n  e match {\n    case _ : IntList =>\n      // e : Expr[List[Int]]\n      // T <: Int\n      0\n  }\n\nclass Weird(list: List[String]) extends IntList with Expr[Nothing]\n```\n\n----------------------------------------\n\nTITLE: Defining List contains with hypothetical one-parameter CanEqual (Scala)\nDESCRIPTION: Shows a hypothetical version of `contains` using a single-parameter `CanEqual1[U]`. This is presented to demonstrate why a one-parameter approach is insufficient for enforcing safety outside of strict equality mode, as it could easily fall back to a universal `CanEqual1[Any]` instance, allowing any comparison again.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\n  def contains[U >: T](x: U)(using CanEqual1[U]): Boolean   // (2)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Tuple Pattern Syntax (EBNF)\nDESCRIPTION: Provides the EBNF rule for `SimplePattern` using parenthesized `Patterns`. This defines the syntax for tuple patterns `(‘(’ [Patterns] ‘)’)` which are used to match tuple values and bind variables to their components. It notes the equivalence to `:*` patterns for n ≥ 2, and special handling for `()` and `(pat)`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_11\n\nLANGUAGE: ebnf\nCODE:\n```\n  SimplePattern   ::=  ‘(’ [Patterns] ‘)’\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Named Tuples with Named and Unnamed Patterns\nDESCRIPTION: Provides examples of pattern matching on named tuples using both unnamed and named patterns, demonstrating flexible matching where only a subset of fields can be matched and names can appear in any order. It also shows pattern matching on case classes with named fields, emphasizing extensibility.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/named-tuples.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nBob match\n  case (name, age) => ...\n\nBob match\n  case (name = x, age = y) => ...\n\nBob match\n  case (age = x) => ...\n\nBob match\n  case (age = x, name = y) => ...\n```\n\n----------------------------------------\n\nTITLE: Comparing Quoting vs. Lifting Values into Expr in Scala\nDESCRIPTION: Demonstrates the difference between quoting an expression (`'{ 1 + 1 }`), which stages the computation, and lifting a value using `Expr.apply` (`Expr(1 + 1)`), which evaluates the expression immediately and then quotes the resulting value. Requires `scala.quoted.Expr`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval expr1plus1: Expr[Int] = '{ 1 + 1 }\n\nval expr2: Expr[Int] = Expr(1 + 1) // lift 2 into '{ 2 }\n```\n\n----------------------------------------\n\nTITLE: Defining XML Expressions in EBNF\nDESCRIPTION: Formal grammar definition for XML expressions in Scala 3. This defines the core structure of how XML can be expressed in Scala code, including elements, tags, and content.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/10-xml-expressions-and-patterns.md#_snippet_0\n\nLANGUAGE: EBNF\nCODE:\n```\nXmlExpr ::= XmlContent {Element}\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Nullable Constants in Java and Their Translation - Java\nDESCRIPTION: This Java code features a class with several final (constant) fields of both reference and primitive types, some initialized with literals and one via a factory method. It demonstrates how Scala 3 considers final literal fields as non-nullable during translation for improved safety guarantees.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_15\n\nLANGUAGE: Java\nCODE:\n```\nclass Constants {\n  final String NAME = \"name\";\n  final int AGE = 0;\n  final char CHAR = 'a';\n\n  final String NAME_GENERATED = getNewName();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Inferred @use with @use(false) (Scala)\nDESCRIPTION: Provides an example of explicitly disabling the `@use` annotation for a parameter `xs` using `@use(false)`. This overrides any inference rule that might otherwise imply `@use` for `xs`, preventing its capture set from being charged to the environment in certain ways.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/use-design.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef f(@use(false) xs: List[() => Unit]): Int = xs.length\n```\n\n----------------------------------------\n\nTITLE: Implicit Unboxing of Boxed Capabilities in Scala Parameters\nDESCRIPTION: Shows that a parameter whose type contains a boxed capability (e.g., `f: Box[T => T]`) is implicitly treated as `@unbox`. This allows the function body to directly use the unboxed value (the `T => T` function in this case) without explicit unboxing operations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ndef apply[T](f: Box[T => T], y: T): T =\n  xs.head(y) // Assuming xs.head uses f, the unboxed capability\n```\n\n----------------------------------------\n\nTITLE: Introducing `Precise` Type Class for Exact Type Variables\nDESCRIPTION: Defines a `Precise` trait that, when used as a context bound, prevents automatic widening of singleton or union types in inferred instances. It allows for precise typing of type variables without requiring them to be singleton types explicitly, offering more control over type inference and refinement in complex scenarios.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/typeclasses.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Precise:\n  type Self\n```\n\n----------------------------------------\n\nTITLE: Overriding Universal Equals Using Matchable Cast to Safely Pattern Match in Scala 3\nDESCRIPTION: Shows a safe implementation of an equals method that overrides universal equality by casting the compared object to Matchable before pattern matching. This cast indicates awareness of abstraction issues and ensures pattern matching respects type safety despite universal Any usage.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/matchable.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass C(val x: String):\n\n  override def equals(that: Any): Boolean =\n    that.asInstanceOf[Matchable] match\n      case that: C => this.x == that.x\n      case _ => false\n```\n\n----------------------------------------\n\nTITLE: Defining Dependent Method and Function Value (Scala)\nDESCRIPTION: Demonstrates defining a class Entry with a dependent type Key and a dependent method extractKey. It then shows how this dependent method can now be converted into a dependent function value extractor in Dotty, illustrating the new dependent function type feature (e: Entry) => e.Key.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-12-01-fifth-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Entry { type Key; key: Key }\n\ndef extractKey(e: Entry): e.Key = e.key          // a dependent method\nval extractor: (e: Entry) => e.Key = extractKey  // a dependent function value\n```\n\n----------------------------------------\n\nTITLE: Manually Creating a `TypeTest` Instance in Scala\nDESCRIPTION: Shows how to manually create a concrete `TypeTest` instance (e.g., `TypeTest[Any, String]`) by implementing its `unapply` method using standard runtime class checks (`case s: String`). This instance can then be passed explicitly using the `using` clause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval tt: TypeTest[Any, String] =\n  new TypeTest[Any, String]:\n    def unapply(s: Any): Option[s.type & String] = s match\n      case s: String => Some(s)\n      case _ => None\n\nf[AnyRef, String](\"acb\")(using tt)\n```\n\n----------------------------------------\n\nTITLE: Defining Infix Types with Two Type Parameters in Scala\nDESCRIPTION: This snippet shows a valid way to define a type constructor as infix using the 'infix' keyword, allowing for cleaner and more readable type expressions. The example 'infix type op[X, Y]' lets users write types as 'A op B'. Dependencies: Built into Scala 3; no external libraries required. Limitation: The type must have exactly two parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/operators.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ninfix type op[X, Y]\n```\n\n----------------------------------------\n\nTITLE: Defining a package object in Scala 3\nDESCRIPTION: This snippet shows how to declare a package object using the 'package object' syntax in Scala, which will be deprecated in the future. It contains value and method definitions inside the package object.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/package-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage object p {\n  val a = ...\n  def b = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Enumerating Regular and Soft Keywords for Scala 3 Grammar - EBNF\nDESCRIPTION: This snippet enumerates all reserved and soft keywords in Scala 3 grammar using grouped listings, serving as vocabulary tokens for the language parser. It lists both traditional reserved words and context-sensitive ('soft') keywords, crucial for syntax highlighting, tokenization, and language tooling. Inputs are token streams, outputs are recognized reserved terms for parsing; note these lists are reference-only and not in functional code form.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/syntax.md#_snippet_2\n\nLANGUAGE: EBNF\nCODE:\n```\nabstract  case      catch     class     def       do        else\nenum      export    extends   false     final     finally   for\ngiven     if        implicit  import    lazy      match     new\nnull      object    override  package   private   protected return\nsealed    super     then      throw     trait     true      try\ntype      val       var       while     with      yield\n:         =         <-        =>        <:        >:        #\n@         =>>       ?=>\n\nas  derives  end  extension  infix  inline  opaque  open  transparent  using  |  *  +  -\n```\n\n----------------------------------------\n\nTITLE: Attempting to access member without Selectable trait\nDESCRIPTION: This snippet shows that if a trait does not extend 'reflect.Selectable', then members defined in an anonymous class are not accessible through structural dispatch. It results in a compilation error when attempting to access '+range+' from an instance of 'Vehicle' without 'Selectable'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Vehicle:\n  val wheels: Int\n\nval i3 = new Vehicle:\n  val wheels = 4\n  val range = 240\n\ni3.range // error: range is not a member of `Vehicle`\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Handling Statement Continuation Using Indentation\nDESCRIPTION: Explains how indentation influences the insertion of virtual semicolons between lines, which affects statement continuation interpretation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nf(x + 1)\n  (2, 3)        // equivalent to  `f(x + 1)(2, 3)`\n\ng(x + 1)\n(2, 3)          // equivalent to  `g(x + 1); (2, 3)`\n\nh(x + 1)\n  {}            // equivalent to  `h(x + 1){}`\n\ni(x + 1)\n{}              // equivalent to  `i(x + 1); {}`\n\nif x < 0 then return\n  a + b         // equivalent to  `if x < 0 then return a + b`\n\nif x < 0 then return\nprintln(a + b)  // equivalent to  `if x < 0 then return; println(a + b)`\n```\n\n----------------------------------------\n\nTITLE: Creating a New Dotty sbt Project via Command Line\nDESCRIPTION: Provides the shell command to initialize a new sbt project configured for Dotty (Scala 3) using the lampepfl/dotty.g8 template. This facilitates easy project setup with the Dotty compiler and dependencies.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-03-05-seventh-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nsbt new lampepfl/dotty.g8\n```\n\n----------------------------------------\n\nTITLE: Updating Dotty on macOS via Homebrew (Shell)\nDESCRIPTION: Updates an existing Dotty (Scala 3) installation managed by Homebrew on macOS to the latest available version. This command should be used if Dotty was previously installed using `brew install`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\nbrew upgrade dotty\n```\n\n----------------------------------------\n\nTITLE: Importing Implicit Conversions in Scala 3 - Scala\nDESCRIPTION: Illustrates the required import of 'scala.language.implicitConversions' in Scala 3 for code utilizing implicit conversions, unless handled with the 'into' modifier. This import is mandatory to enable implicit conversions and suppress feature warnings. No external dependencies are required beyond Scala standard library, and the code must be placed before usages of implicits.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.implicitConversions\n```\n\n----------------------------------------\n\nTITLE: Generated CanEqual Instance for Generic Class\nDESCRIPTION: Shows the CanEqual instance that would be generated in the companion object when deriving CanEqual for a generic Box class.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ngiven [T, U] => CanEqual[T, U] => CanEqual[Box[T], Box[U]] =\n  CanEqual.derived\n```\n\n----------------------------------------\n\nTITLE: Using Dependent Function Types with Traits and Implicit Parameters - Scala\nDESCRIPTION: Provides a practical example demonstrating dependent function types using a trait with an abstract type member and dependent function type aliases. It defines two dependent function types DF and IDF, the latter using implicit parameters (?=>). The example illustrates creating instances conforming to these types, calling the dependent functions with explicit and implicit arguments, and printing the results. Dependencies include the trait C and Scala3 implicit mechanisms for contextually passing parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/dependent-function-types-spec.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait C { type M; val m: M }\n\ntype DF = (x: C) => x.M\n\ntype IDF = (x: C) ?=> x.M\n\n@main def test =\n  val c = new C { type M = Int; val m = 3 }\n\n  val depfun: DF = (x: C) => x.m\n  val t = depfun(c)\n  println(s\"t=$t\")   // prints \"t=3\"\n\n  val idepfun: IDF = summon[C].m\n  val u = idepfun(using c)\n  println(s\"u=$u\")   // prints \"u=3\"\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Tracing for Logging in Scala Compiler\nDESCRIPTION: An example of using the compiler's `trace` function for logging. This mechanism allows tracing execution within a block. It takes a message (using interpolated strings `i\"\"`), a printer instance (`typr`), and configuration options (`show = true`). Tracing can be enabled globally or per call.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ntrace(i\"typing $tree\", typr, show = true) { // ...\n```\n\n----------------------------------------\n\nTITLE: Defining Syntax of Structural Types Using EBNF\nDESCRIPTION: This snippet defines the formal grammar for simple and refinement types using EBNF notation. It specifies how refinements are sequences of declarations like val, def, or type. This grammar forms the basis for understanding structural type syntax in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types-spec.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nSimpleType    ::= ... | Refinement\nRefinement    ::= ‘{’ RefineStatSeq ‘}’\nRefineStatSeq ::=  RefineStat {semi RefineStat}\nRefineStat    ::= ‘val’ VarDcl | ‘def’ DefDcl | ‘type’ {nl} TypeDcl\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ambiguity Error with summonFrom and Multiple Given Instances in Scala\nDESCRIPTION: Example illustrating that `summonFrom` raises ambiguity errors if multiple implicits of the same type are in scope and a pattern matches that type. Here, two givens of type A exist and a summonFrom case attempts to match any A, causing a compile-time ambiguity error. This highlights the importance of unique implicit instances or careful pattern design when using summonFrom. Requires defining implicits and importing summonFrom.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/compiletime-ops.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass A\ngiven a1: A = new A\ngiven a2: A = new A\n\ninline def f: Any = summonFrom {\n  case given _: A => ???  // error: ambiguous givens\n}\n```\n\n----------------------------------------\n\nTITLE: New `=>` Syntax for Parameterized Conditional Givens in Scala 3\nDESCRIPTION: Introduces the proposed new experimental syntax using `=>` (read as 'implies') for defining parameterized conditional `given` instances. `Ord[T] => Ord[List[T]]` signifies that a given `Ord[T]` implies a given `Ord[List[T]]`, aiming for better readability.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ngiven listOrd[T]: Ord[T] => Ord[List[T]] ...\n```\n\n----------------------------------------\n\nTITLE: Recursive Inline Method for Power Computation\nDESCRIPTION: Defines a recursive inline method `power` that computes `x^n` at compile-time when `n` is constant, avoiding runtime recursion or looping. This example demonstrates powerful inline optimizations for mathematical computations, reducing code to directly computed values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ninline def power(x: Double, n: Int): Double =\n  if n == 0 then 1.0\n  else if n == 1 then x\n  else\n    val y = power(x, n / 2)\n    if n % 2 == 0 then y * y else y * y * x\n```\n\n----------------------------------------\n\nTITLE: Example Rejected Function without CanThrow Capability in Scala\nDESCRIPTION: This snippet defines a function g that throws a LimitExceeded exception but does not declare a throws clause nor accept a CanThrow parameter. Under saferExceptions, this results in a type-checking error, as the capability to throw LimitExceeded is missing. This demonstrates Scala 3's enforcement of explicit checked exception handling.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\ndef g(x: Double): Double =\n  if x < limit then x * x else throw LimitExceeded()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Automatic Eta Expansion - Scala 3\nDESCRIPTION: This snippet defines a method `m` with multiple parameter lists and demonstrates how assigning it directly (`val f1 = m`) or partially applying it (`val f2 = m(true, \"abc\")`) automatically converts it into function values in Scala 3. The `_` syntax is no longer needed for such methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/eta-expansion.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef m(x: Boolean, y: String)(z: Int): List[Int]\nval f1 = m\nval f2 = m(true, \"abc\")\n```\n\n----------------------------------------\n\nTITLE: Operational Semantics: Splicing Rules in EBNF\nDESCRIPTION: The splicing rules define how splice operations are evaluated. These include unwrapping quoted values and context rules for propagating evaluations through lambdas, applications and splice operations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/simple-smp.md#_snippet_2\n\nLANGUAGE: ebnf\nCODE:\n```\n                        ~'u  ==>  u\n\n                         t1  ==>  t2\n               -------------------------------\n               (x: T) => t1  ==>  (x: T) => t2\n\n                         t1  ==>  t2\n                       ---------------\n                       t1 t  ==>  t2 t\n\n                         t1  ==>  t2\n                       ---------------\n                       u t1  ==>  u t2\n\n                         t1  -->  t2\n                        -------------\n                        ~t1  ==>  ~t2\n```\n\n----------------------------------------\n\nTITLE: Constructing Lists with Reach Capabilities in Scala 3\nDESCRIPTION: Defines a function `cons` that constructs a List of functions with combined reach capabilities from its parameters `x` and `xs`. This shows the ability to build composite capture sets representing capabilities reachable from multiple variables.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef cons(x: Proc, xs: List[Proc]): List[() ->{x, xs*} Unit] =\n  List.cons[() ->{x, xs*} Unit](x, xs)\n```\n\n----------------------------------------\n\nTITLE: Defining Intersection Types Syntax in EBNF - EBNF\nDESCRIPTION: This snippet provides the extended Backus-Naur Form (EBNF) grammar for the Scala type system, showing where the infix intersection type (`&`) syntax fits. It illustrates that an `InfixType` consists of a `RefinedType` separated by an identifier (such as `&`), which formalizes the type syntax for intersection types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/intersection-types-spec.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nType              ::=  ...| InfixType\nInfixType         ::=  RefinedType {id [nl] RefinedType}\n```\n\n----------------------------------------\n\nTITLE: Dropping Procedure Syntax in Scala 3\nDESCRIPTION: Shows the deprecated procedure syntax in Scala 3 where methods are defined without equals to indicate Unit return type. It highlights the need to migrate away from this syntax since it is dropped, and suggests alternative syntax with explicit equals sign or Unit return type declaration. The snippet helps developers understand the syntax change from Scala 2 to Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/procedure-syntax.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef f() { ... }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Implicit Transaction Usage in Main Method (Scala)\nDESCRIPTION: The main entry point of the program. It calls the `transaction` method, providing a lambda that takes an implicit `Transaction`. Inside the lambda, it calls `f1` (which implicitly uses the passed transaction) and then prints the result or the transaction status.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n  def main(args: Array[String]) = {\n    transaction {\n      implicit thisTransaction =>\n        val res = f1(args.length)\n        println(if (thisTransaction.isAborted) \"aborted\" else s\"result: $res\")\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Scala Equivalent Code with Qualified Names\nDESCRIPTION: This Scala code block shows the functional equivalent of the previous block that used non-given imports. It explicitly accesses the members `z` and `one` from object `M` using their fully qualified names (`M.z`, `M.one`) within the call to `M.add`, demonstrating the result of the import process.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\n{\n  M.add(M.z, M.one)\n}\n```\n\n----------------------------------------\n\nTITLE: Executing @main Scala Program from Command Line\nDESCRIPTION: Shows how to execute a Scala program defined with the `@main` annotation using the `scala` command-line runner. Arguments provided after the program name are automatically passed and parsed according to the `@main` method's parameters. Assumes the `@main` method has been compiled.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/main-functions.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n> scala happyBirthday 23 Lisa Peter\nHappy 23rd birthday, Lisa and Peter\n```\n\n----------------------------------------\n\nTITLE: Handling Variance in Parameterized Type Lambda Equivalence in Scala\nDESCRIPTION: This Scala example shows the expansion of a parameterized type with variance annotations (`type F2[A, +B] = A => B`) into its equivalent type lambda form (`type F2 = [A, B] =>> A => B`). The compiler checks that the specified variance annotations (`+B`) are correctly satisfied by the type lambda's body (`A => B`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas-spec.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntype F2[A, +B] = A => B\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype F2 = [A, B] =>> A => B\n```\n\n----------------------------------------\n\nTITLE: Operational Semantics: Evaluation Rules in EBNF\nDESCRIPTION: The evaluation rules define how terms are reduced during execution. These rules include lambda application (beta reduction) and context rules for applications and quotes, forming the dynamic semantics of the calculus.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/simple-smp.md#_snippet_1\n\nLANGUAGE: ebnf\nCODE:\n```\n            ((x: T) => t) v  -->  [x := v]t\n\n                         t1  -->  t2\n                       ---------------\n                       t1 t  -->  t2 t\n\n                         t1  -->  t2\n                       ---------------\n                       v t1  -->  v t2\n\n                         t1  ==>  t2\n                        -------------\n                        't1  -->  't2\n```\n\n----------------------------------------\n\nTITLE: Comparing Flag Checking in Scala 2 and Scala 3 Compilers\nDESCRIPTION: Illustrates the difference in syntax for checking symbol flags between Scala 2 (scalac) and Scala 3 (dotc). Scala 2 uses specific `isFooBar` methods on the symbol, while Scala 3 uses the `is` method on the symbol's denotation (accessed via implicit conversion) combined with `Flags` objects.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/dotc-scalac.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nif (sym.isPackageClass)         // Scala 2\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif (sym is Flags.PackageClass)  // Scala 3 (*)\n```\n\n----------------------------------------\n\nTITLE: Pattern in For Expression Leading to Type Warning\nDESCRIPTION: This code involves pattern matching within a for comprehension over a list containing heterogeneous elements. It demonstrates how Scala 3 reports a warning when the pattern's type is more specialized than the actual element types. Using 'case' in the pattern filters elements matching the pattern, enabling safe extraction.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/pattern-bindings.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nfor (x, y) <- elems yield (y, x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor case (x, y) <- elems yield (y, x)\n```\n\n----------------------------------------\n\nTITLE: Listing Contributors and Commit Counts - Shell Output\nDESCRIPTION: This snippet displays the formatted output from the `git shortlog -sn --no-merges` command, which summarizes commit counts by author. The command was run with a specific commit range (`3.2.1-RC3..3.2.1-RC4`) to show contributors between two release candidates, excluding merge commits.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.2.1-RC4.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n     2  Paweł Marks\n     1  Seth Tisue\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Implicit Conversion Using Given Instance in Scala\nDESCRIPTION: This snippet demonstrates how to create a given Conversion instance to implicitly convert from a String to a Token in Scala 3. The instance is defined using the given keyword and requires the class KeyWord and class Token to be defined in the scope, with KeyWord accepting a String parameter. The apply method returns a new KeyWord constructed from the input string.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/conversions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Conversion[String, Token]:\n  def apply(str: String): Token = new KeyWord(str)\n```\n\n----------------------------------------\n\nTITLE: Defining By-Name Given Alias Scala 3\nDESCRIPTION: Defines a given alias named `context` for `Context` using a by-name evaluation strategy. The `() => Context` type signature indicates that the right-hand side (`curCtx`) is re-evaluated each time the `context` given is summoned, making it suitable for cases involving mutable state like a variable `curCtx`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/more-givens.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n  val curCtx: Context\n  given context: () => Context = curCtx\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using Scala Name-based Match Extractor\nDESCRIPTION: Demonstrates implementing a Name-based match extractor using an `object` with `_N`, `isEmpty`, and `get` members, and an `unapply` method returning `this`. The `match` expression uses positional patterns (`_, _`) which map to the `_N` members.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nobject ProdEmpty:\n  def _1: Int = ???\n  def _2: String = ???\n  def isEmpty = true\n  def unapply(s: String): this.type = this\n  def get = this\n\n\"\" match\n  case ProdEmpty(_, _) => ???\n  case _ => ()\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Extended End Marker Rules and Syntax\nDESCRIPTION: Details the syntax for end markers, their placement, compatibility with various statement types, and concrete examples illustrating the syntax and rules for matching end markers with code constructs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nEndMarker         ::=  ‘end’ EndMarkerTag    -- followed by EOL\nEndMarkerTag      ::=  id | ‘if’ | ‘while’ | ‘for’ | ‘match’ | ‘try’ | ‘new’ | ‘this’ | ‘given’ | ‘extension’ | ‘val’\n\n// Examples show how end markers such as `end if`, `end val`, `end match`, etc., close corresponding regions.\n// Used especially in long or heavily indented code where visual clarity is needed.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dependent Function Types in Scala 3\nDESCRIPTION: This example shows a dependent method that extracts a key from an Entry trait and how it can be assigned to a function value with a dependent function type. The Entry trait defines a type member Key and a value key of that type. The extractKey method returns the key with a type that depends on the specific entry passed in.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/dependent-function-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Entry { type Key; val key: Key }\n\ndef extractKey(e: Entry): e.Key = e.key          // a dependent method\n\nval extractor: (e: Entry) => e.Key = extractKey  // a dependent function value\n//             ^^^^^^^^^^^^^^^^^^^\n//             a dependent function type\n```\n\n----------------------------------------\n\nTITLE: Expanding Bounded Type Parameters to Type Lambdas in Scala\nDESCRIPTION: This demonstrates how a bounded type parameter, such as `[F[X] <: Coll[X]]`, is expanded into a type parameter bounded by a type lambda: `[F >: Nothing <: [X] =>> Coll[X]]`. This applies the same expansion logic used for abstract types, using `Nothing` as the default lower bound.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas-spec.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n[F[X] <: Coll[X]]\n```\n\nLANGUAGE: scala\nCODE:\n```\n[F >: Nothing <: [X] =>> Coll[X]]\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Function Types Internal Trait Representation in Scala\nDESCRIPTION: Shows the structure of function types in Scala 3 through a trait with an apply method. It models an n-ary function type scala.Function_n[-T1, ..., -Tn, +R] that takes arguments of specified types and returns a result. This trait is foundational to representing function types internally, enabling function objects to be applied with appropriate arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntrait Function’_n’[-’T_1’, ..., -’T_n’, +’R’]:\n  def apply(’x_1’: ’T_1’, ..., ’x_n’: ’T_n’): ’R’\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Project Test in Community Build with sbt (Shell)\nDESCRIPTION: Executes only the tests associated with a specific project (using `shapeless` as an example) within the `community-build` sbt project. The `-- *projectname` syntax targets specific JUnit tests. This command can be run directly in the sbt shell or prefixed with `sbt` in the terminal.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/community-build.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ncommunity-build/testOnly -- *shapeless\n```\n\n----------------------------------------\n\nTITLE: Calling Structural Methods via applyDynamic in Scala\nDESCRIPTION: This snippet shows how a function call on a structural member (such as a.f(b, c)) is translated by the Scala compiler to an applyDynamic invocation on the Selectable instance. The mechanism enables dynamic function dispatch by method name string and arguments, and requires the underlying class to define applyDynamic. It assumes the instance a is of a type extending Selectable. The main input is the function name as string and the arguments; output is the result of the dynamic call.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\na.applyDynamic(\"f\")(b, c)\n```\n\n----------------------------------------\n\nTITLE: Updating SemanticDB Expect Files in Bulk - Scala 3 Compiler - Bash\nDESCRIPTION: The following command regenerates all SemanticDB expect files by invoking an update routine within the Scala 3 compiler. This is useful for matching the expect files to new SemanticDB outputs after changes in the codebase. Users must review and commit the changes using version control tools.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\nsbt:scala3> scala3-compiler/Test/runMain\n  dotty.tools.dotc.semanticdb.updateExpect\n```\n\n----------------------------------------\n\nTITLE: Signature polymorphic methods invocation handling\nDESCRIPTION: Describes how invocation of signature polymorphic methods adapts based on the platform and context. At each call site, the method type may vary, with specific rules for determining the return type based on the declared signature. This facilitates flexible method typing, especially when targeting different platforms such as Java.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Using Anonymous Givens to Define Type Class Instances\nDESCRIPTION: This snippet illustrates defining 'given' instances without explicit names by omitting the `given` identifier and relying on compiler-generated names based on the type. Such anonymous givens simplify code when names are unnecessary or when uniqueness is ensured by the compiler. Examples include anonymous instances for `Int` and `List[T]`, with compiler system generating names like `given_Ord_Int` and `given_Ord_List`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/givens.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Ord[Int]:\n  ...\n\ngiven [T: Ord] => Ord[List[T]]:\n  ...\n\n```\n\n----------------------------------------\n\nTITLE: Mapping Tuples using Placeholder Syntax in Scala 3\nDESCRIPTION: Illustrates an even shorter alternative using placeholder syntax (`_ + _`) with parameter untupling in Scala 3 for mapping tuples to their sums. Each underscore represents a corresponding element from the input tuple.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nxs.map(_ + _)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Parameterized Traits in Scala\nDESCRIPTION: This snippet demonstrates how to define a trait with constructor parameters and shows a class (`C`) extending that trait, passing a value for the parameter. The trait provides a method (`msg`) that uses the parameter, and the class prints the message. Dependencies: no external dependencies beyond standard Scala. Parameters: the trait requires a `name` string. Input: none, output: prints a greeting message. Limitations: trait parameters must follow constructor rules; ambiguity can arise if traits are extended more than once with different parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/trait-parameters.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Greeting(val name: String):\n  def msg = s\"How are you, $name\"\n\nclass C extends Greeting(\"Bob\"):\n  println(msg)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Context-Free Syntax using EBNF\nDESCRIPTION: EBNF grammar rules defining the context-free structure of Scala 3 programs. This covers declarations (ValDcl, VarDcl, DefDcl, TypeDcl), definitions (PatDef, DefDef), template definitions (ClassDef, ObjectDef, EnumDef, GivenDef), extensions, templates, inheritance clauses, constructor expressions, template bodies, enum bodies, top-level statements, packaging, and the overall compilation unit structure.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/13-syntax-summary.md#_snippet_2\n\nLANGUAGE: ebnf\nCODE:\n```\nRefineDcl         ::=  ‘val’ ValDcl\n                    |  ‘def’ DefDcl\n                    |  ‘type’ {nl} TypeDcl\nDcl               ::=  RefineDcl\n                    |  ‘var’ VarDcl\nValDcl            ::=  ids ‘:’ Type\nVarDcl            ::=  ids ‘:’ Type\nDefDcl            ::=  DefSig ‘:’ Type\nDefSig            ::=  id [DefTypeParamClause] [TypelessClauses] [DefImplicitClause]\nTypeDcl           ::=  id [TypeParamClause] {FunParamClause} TypeBounds\n\nDef               ::=  ‘val’ PatDef\n                    |  ‘var’ PatDef\n                    |  ‘def’ DefDef\n                    |  ‘type’ {nl} TypeDcl\n                    |  TmplDef\nPatDef            ::=  ids [‘:’ Type] ‘=’ Expr\n                    |  Pattern2 [‘:’ Type] ‘=’ Expr\nDefDef            ::=  DefSig [‘:’ Type] ‘=’ Expr\n                    |  ‘this’ TypelessClauses [DefImplicitClause] ‘=’ ConstrExpr\n\nTmplDef           ::=  ([‘case’] ‘class’ | ‘trait’) ClassDef\n                    |  [‘case’] ‘object’ ObjectDef\n                    |  ‘enum’ EnumDef\n                    |  ‘given’ GivenDef\nClassDef          ::=  id ClassConstr [Template]\nClassConstr       ::=  [ClsTypeParamClause] [ConstrMods] ClsParamClauses\nConstrMods        ::=  {Annotation} [AccessModifier]\nObjectDef         ::=  id [Template]\nEnumDef           ::=  id ClassConstr InheritClauses EnumBody\nGivenDef          ::=  [GivenSig] (AnnotType [‘=’ Expr] | StructuralInstance)\nGivenSig          ::=  [id] [DefTypeParamClause] {UsingParamClause} ‘:’         -- one of `id`, `DefTypeParamClause`, `UsingParamClause` must be present\nStructuralInstance ::=  ConstrApp {‘with’ ConstrApp} [‘with’ WithTemplateBody]\nExtension         ::=  ‘extension’ [DefTypeParamClause] {UsingParamClause}\n                       ‘(’ DefTermParam ‘)’ {UsingParamClause} ExtMethods\nExtMethods        ::=  ExtMethod | [nl] <<< ExtMethod {semi ExtMethod} >>>\nExtMethod         ::=  {Annotation [nl]} {Modifier} ‘def’ DefDef\n                    |  Export\nTemplate          ::=  InheritClauses [TemplateBody]\nInheritClauses    ::=  [‘extends’ ConstrApps] [‘derives’ QualId {‘,’ QualId}]\nConstrApps        ::=  ConstrApp ({‘,’ ConstrApp} | {‘with’ ConstrApp})\nConstrApp         ::=  SimpleType1 {Annotation} {ParArgumentExprs}\nConstrExpr        ::=  SelfInvocation\n                    |  <<< SelfInvocation {semi BlockStat} >>>\nSelfInvocation    ::=  ‘this’ ArgumentExprs {ArgumentExprs}\n\nWithTemplateBody  ::=  <<< [SelfType] TemplateStat {semi TemplateStat} >>>\nTemplateBody      ::=  :<<< [SelfType] TemplateStat {semi TemplateStat} >>>\nTemplateStat      ::=  Import\n                    |  Export\n                    |  {Annotation [nl]} {Modifier} Def\n                    |  {Annotation [nl]} {Modifier} Dcl\n                    |  Extension\n                    |  Expr1\n                    |  EndMarker\n                    |\nSelfType          ::=  id [‘:’ InfixType] ‘=>’\n                    |  ‘this’ ‘:’ InfixType ‘=>’\n\nEnumBody          ::=  :<<< [SelfType] EnumStat {semi EnumStat} >>>\nEnumStat          ::=  TemplateStat\n                    |  {Annotation [nl]} {Modifier} EnumCase\nEnumCase          ::=  ‘case’ (id ClassConstr [‘extends’ ConstrApps]] | ids)\n\nTopStats          ::=  TopStat {semi TopStat}\nTopStat           ::=  Import\n                    |  Export\n                    |  {Annotation [nl]} {Modifier} Def\n                    |  Extension\n                    |  Packaging\n                    |  PackageObject\n                    |  EndMarker\n                    |\nPackaging         ::=  ‘package’ QualId :<<< TopStats >>>\nPackageObject     ::=  ‘package’ ‘object’ ObjectDef\n\nCompilationUnit   ::=  {‘package’ QualId semi} TopStats\n```\n\n----------------------------------------\n\nTITLE: Correct Indentation Within Mixed Braces and Parentheses Regions - Scala\nDESCRIPTION: Sample code showing correct usage of indentation and braces within mixed delimiter regions, demonstrating the computation of expected indentation widths inside braces, parentheses, and nested expressions. It clarifies how indentation width rules apply selectively to these delimiters ensuring proper parsing of multi-line expressions involving function parameters and nested parentheses.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n{\n  val x = f(x: Int, y =>\n    x * (\n      y + 1\n    ) +\n    (x +\n    x)\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Example Auto-Generated Mirror Instances in Scala 3\nDESCRIPTION: Shows how the Scala 3 compiler automatically generates `Mirror.Sum` and `Mirror.Product` instances for an example Algebraic Data Type (ADT) `Tree` with cases `Branch` and `Leaf`. These instances capture the structure (sum/product), element types, labels, and provide methods like `ordinal` (for sums) or `fromProduct` (for products). This demonstrates the low-level information made available for generic programming.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n// Mirror for Tree\nnew Mirror.Sum:\n  type MirroredType = Tree\n  type MirroredElemTypes[T] = (Branch[T], Leaf[T])\n  type MirroredMonoType = Tree[_]\n  type MirroredLabel = \"Tree\"\n  type MirroredElemLabels = (\"Branch\", \"Leaf\")\n\n  def ordinal(x: MirroredMonoType): Int = x match\n    case _: Branch[_] => 0\n    case _: Leaf[_] => 1\n\n// Mirror for Branch\nnew Mirror.Product:\n  type MirroredType = Branch\n  type MirroredElemTypes[T] = (Tree[T], Tree[T])\n  type MirroredMonoType = Branch[_]\n  type MirroredLabel = \"Branch\"\n  type MirroredElemLabels = (\"left\", \"right\")\n\n  def fromProduct(p: Product): MirroredMonoType =\n    new Branch(...)\n\n// Mirror for Leaf\nnew Mirror.Product:\n  type MirroredType = Leaf\n  type MirroredElemTypes[T] = Tuple1[T]\n  type MirroredMonoType = Leaf[_]\n  type MirroredLabel = \"Leaf\"\n  type MirroredElemLabels = Tuple1[\"elem\"]\n\n  def fromProduct(p: Product): MirroredMonoType =\n    new Leaf(...)\n```\n\n----------------------------------------\n\nTITLE: Using `match` as a Method Call in Scala 3\nDESCRIPTION: Shows the alternative new syntax where `match` can be used like a standard method call on an object (e.g., `xs.match`). This provides a more object-oriented feel compared to the traditional keyword-based or the new infix operator syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nxs.match {\n  case Nil => false\n  case _ => true\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Experimental 'erasedDefinitions' Feature in Scala\nDESCRIPTION: Enables the use of the 'erased' modifier in your code by importing the required feature from Scala's experimental language package. No additional dependencies except for Scala 3 are required. This import is necessary before using any erased definitions or parameters, and does not modify the runtime behavior directly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.experimental.erasedDefinitions\n```\n\n----------------------------------------\n\nTITLE: Defining a function with an any-kinded type parameter in Scala 3\nDESCRIPTION: This snippet demonstrates how to declare a generic function `f` with a type parameter `T` bounded by cAnyKindc, allowing `f` to accept type arguments of any kind, such as `Int`, `List`, or `Map`. It highlights the flexibility gained through kind polymorphism and the restrictions on how such types can be used.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/kind-polymorphism.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef f[T <: AnyKind] = ...\n```\n\n----------------------------------------\n\nTITLE: Defining Syntax for Symmetric Metaprogramming in EBNF\nDESCRIPTION: The formal syntax definition for the two-stage metaprogramming model, specifying terms, simple terms, values, and types. This grammar establishes the foundation for the metaprogramming calculus with quotes and splices.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/simple-smp.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nTerms         t  ::=  x                 variable\n                      (x: T) => t       lambda\n                      t t               application\n                      't                quote\n                      ~t                splice\n\nSimple terms  u  ::=  x  |  (x: T) => u  |  u u\n\nValues        v  ::=  (x: T) => t       lambda\n                      'u                quoted value\n\nTypes         T  ::=  A                 base type\n                      T -> T            function type\n                      'T                quoted type\n```\n\n----------------------------------------\n\nTITLE: Accessing Position Information in Macros\nDESCRIPTION: Demonstrates how to obtain detailed position information about the macro expansion site, including file path, line numbers, columns, and the source code at that position.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/reflection.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef macroImpl()(quotes: Quotes): Expr[Unit] =\n  import quotes.reflect.*\n  val pos = Position.ofMacroExpansion\n\n  val jpath = pos.sourceFile.getJPath.getOrElse(report.errorAndAbort(\"virtual file not supported\", pos))\n  val path = pos.sourceFile.path // fallback for a virtual file\n  val start = pos.start\n  val end = pos.end\n  val startLine = pos.startLine\n  val endLine = pos.endLine\n  val startColumn = pos.startColumn\n  val endColumn = pos.endColumn\n  val sourceCode = pos.sourceCode\n  ...\n```\n\n----------------------------------------\n\nTITLE: Renaming and Excluding Imports using 'as' in Scala 3\nDESCRIPTION: Shows the new `as` keyword used for renaming or excluding imported members in Scala 3. `as newName` renames the imported member, while `as _` excludes it. This replaces the old `=>` syntax, and single renamings no longer require braces.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/imports.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport A.{min as minimum, `*` as multiply}\nimport Predef.{augmentString as _, *}     // imports everything except augmentString\nimport scala.annotation as ann\nimport java as j\n```\n\n----------------------------------------\n\nTITLE: Evaluation Command Syntax - Scala 3 Debug Test - Plaintext\nDESCRIPTION: This snippet illustrates the syntax for evaluation and assertion steps in the debug scenario script. The 'eval' command provides the expression to run, while the corresponding 'result' or 'error' checks the actual output or error message. The syntax also supports multi-line expressions and errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_12\n\nLANGUAGE: plaintext\nCODE:\n```\neval ${expression}\nresult ${expected output}\n\n// or in case an error is expected\neval ${expression}\nerror ${expected message}\n```\n\n----------------------------------------\n\nTITLE: Defining Experimental Tests in Scala 3\nDESCRIPTION: Presents how test methods touching experimental APIs must be annotated @experimental or enclosed in experimental classes or objects. Non-experimental test methods referencing experimental code produce errors. Experimental tests frameworks can use reflection on experimental tests despite their annotation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/experimental-defs.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.experimental\n\n@experimental def x = 2\n\nclass MyTests {\n  /*@Test*/ def test1 = x // error\n  @experimental /*@Test*/ def test2 = x\n}\n\n@experimental\nclass MyExperimentalTests {\n  /*@Test*/ def test1 = x\n  /*@Test*/ def test2 = x\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Method with @use on a Capture Set Parameter (Scala)\nDESCRIPTION: Defines a polymorphic method `runOpsPoly` using an explicit capture set parameter `C^` annotated with `@use`. This approach makes the capture set handling explicit and potentially avoids issues seen with the term parameter version during eta expansion, following rule 6.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/use-design.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef runOpsPoly[@use C^](ops: List[() ->{C^} Unit]): Unit = ops.foreach[C^](_())\n```\n\n----------------------------------------\n\nTITLE: Valid and Invalid Opaque Type Aliases with Type Parameters in Scala 3\nDESCRIPTION: Shows examples of well-formed opaque type aliases with a single type parameter list, and examples of incorrectly defined aliases that use nested or multiple parameter lists. This clarifies that opaque types can have a single parameter list but do not support nested or multiple parameter lists as right-hand-side type lambdas.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/opaques-details.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nopaque type F[T] = (T, T)\nopaque type G = [T] =>> List[T]\n```\n\nLANGUAGE: scala\nCODE:\n```\nopaque type BadF[T] = [U] =>> (T, U)\nopaque type BadG = [T] =>> [U] =>> (T, U)\n```\n\n----------------------------------------\n\nTITLE: Comparing Scala 3 Quote/Splice Syntax with String Interpolation\nDESCRIPTION: Demonstrates the syntactic similarity between Scala 3's macro quoting (`'`) and splicing (`$`) mechanisms and standard Scala string interpolation. Shows examples using both simple variable names and block expressions within quotes/splices and strings.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ns\" Hello $name\"           s\" Hello ${name}\"\n'{ hello($name) }         '{ hello(${name}) }\n${ hello('name) }         ${ hello('{name}) }\n```\n\n----------------------------------------\n\nTITLE: Flow Typing for Nullability Checks in Else Branches - Scala\nDESCRIPTION: This snippet shows flow typing in Scala 3's else branches: when a variable is tested for null, the else branch is guaranteed to see the variable as non-null. It demonstrates type narrowing through control flow, promoting both null-safe programming and documentation of developer intent.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nif s == null then\n  // s: String | Null\nelse\n  // s: String\n\n```\n\n----------------------------------------\n\nTITLE: Using Functor Extension Method for Cleaner Syntax in Scala\nDESCRIPTION: Rewrites the `assertTransformation` method to leverage the `Functor`'s extension method. The call to `map` is now directly on the `original` value (`original.map(mapping)`), which is enabled by the implicit `Functor[F]` instance in scope. This eliminates the need for `summon`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef assertTransformation[F[_]: Functor, A, B](expected: F[B], original: F[A], mapping: A => B): Unit =\n  assert(expected == original.map(mapping))\n```\n\n----------------------------------------\n\nTITLE: Deriving Instances Externally in Scala\nDESCRIPTION: Shows how to derive a type class instance for an ADT defined elsewhere (e.g., `Option` from the standard library). A `given` instance for `Ordering[Option[T]]` is defined, using `Ordering.derived` on the right-hand side, assuming `Ordering` has a similar `derived` method relying on `Mirror`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ngiven [T: Ordering]: Ordering[Option[T]] = Ordering.derived\n```\n\n----------------------------------------\n\nTITLE: Filling remaining parameters when 'F' has fewer args than 'DerivingType'\nDESCRIPTION: This snippet showcases how to generate given instances when the type constructor 'F' has fewer arguments than the 'DerivingType', by supplying the remaining parameters from a list of type parameters. It illustrates advanced derivation techniques for partial type application.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ngiven [T_1, ... T_{N-K}] => TC[[A_1, ..., A_K] =>> DerivingType[T_1, ..., T_{N-K}, A_1, ..., A_K]] = TC.derived\n```\n\n----------------------------------------\n\nTITLE: Implementing Eq Type Class Derivation Macro Signature in Scala\nDESCRIPTION: Shows the required signature for a type class derivation method implemented using Scala 3 macros. It returns a quoted expression `Expr[Eq[T]]` and requires a `Quotes` context and a `Type` context bound on `T` to lift the type into the quote context.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation-macro.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ngiven derived[T: Type](using Quotes): Expr[Eq[T]]\n```\n\n----------------------------------------\n\nTITLE: Defining Semicolon and Newline Tokenization in Scala Grammar EBNF\nDESCRIPTION: This snippet defines the 'semi' token, which may be either a semicolon or one or more newlines represented by the 'nl' token sequence. It is part of the Scala grammar description using Extended Backus-Naur Form (EBNF) notation and establishes the tokenization of statement separators.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_8\n\nLANGUAGE: EBNF\nCODE:\n```\nsemi ::= ‘;’ |  nl {nl}\n```\n\n----------------------------------------\n\nTITLE: Compiler Synthesized TypeTest Pattern in Scala\nDESCRIPTION: Shows the general structure of a `TypeTest` instance that the compiler synthesizes when no implicit instance is found for a type test on abstract types. The synthesis involves a runtime check using `case s: B` which might result in an unchecked warning if `B` is abstract.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nnew TypeTest[A, B]:\n  def unapply(s: A): Option[s.type & B] = s match\n    case s: B => Some(s)\n    case _ => None\n```\n\n----------------------------------------\n\nTITLE: Fixes and Restrictions for Erased Definitions in Scala 3\nDESCRIPTION: This snippet introduces code that enforces restrictions on erased definitions, including fixing crashes related to `CanThrow` and ensuring only parameters marked as `erased` are used in erased definitions. It maintains compiler stability and correctness by validating erased parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.5.0-RC1.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n# Erased definitions\n\n- Fix \"Compiler crash when using CanThrow\" [#20210]\n- Only allow erased parameters in erased definitions [#19686]\n```\n\n----------------------------------------\n\nTITLE: Using the defaultValue Function (Scala)\nDESCRIPTION: This snippet shows example calls to the `defaultValue` function defined previously. It demonstrates how the function correctly returns the default value wrapped in `Some` for known types like `Int`, `Double`, and `Boolean`, and `None` for a type like `Any`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval dInt: Some[Int] = defaultValue[Int]\nval dDouble: Some[Double] = defaultValue[Double]\nval dBoolean: Some[Boolean] = defaultValue[Boolean]\nval dAny: None.type = defaultValue[Any]\n```\n\n----------------------------------------\n\nTITLE: Type Variable Pattern Matching in Scala 3 Quotes\nDESCRIPTION: Shows how to use type variables in quoted patterns to match expressions with unknown types, enabling generic transformations like map fusion on collections.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\ndef fuseMapCode(x: Expr[List[Int]]): Expr[List[Int]] =\n  x match\n    case '{ ($ls: List[t]).map[u]($f).map[Int]($g) } =>\n      '{ $ls.map($g.compose($f)) }\n    ...\n\nfuseMapCode('{ List(1.2).map(f).map(g) }) // '{ List(1.2).map(g.compose(f)) }\nfuseMapCode('{ List('a').map(h).map(i) }) // '{ List('a').map(i.compose(h))  }\n```\n\n----------------------------------------\n\nTITLE: Defining Curried Type Lambdas in Scala\nDESCRIPTION: This Scala example shows a curried type lambda `TL`, where the body of the first lambda (`[X] =>> ...`) is itself another type lambda (`[Y] =>> (X, Y)`). It notes that type argument inference for such curried type lambdas is currently unsupported and is planned for future work.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas-spec.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ntype TL = [X] =>> [Y] =>> (X, Y)\n```\n\n----------------------------------------\n\nTITLE: Defining the Monad type class with flatMap and pure\nDESCRIPTION: Defines the `Monad` trait extending `Functor`, adding `flatMap` and `pure` methods. Implements default `map` in terms of `flatMap` and `pure`. Facilitates chaining of computations within context `F[_]`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Monad[F[_]] extends Functor[F]:\n  def pure[A](x: A): F[A]\n  extension [A](x: F[A])\n    def flatMap[B](f: A => F[B]): F[B]\n    def map[B](f: A => B) = x.flatMap(f.andThen(pure))\n```\n\n----------------------------------------\n\nTITLE: Expansion of Extension Method to Compiler Internal Form in Scala\nDESCRIPTION: Shows how the compiler internally translates an extension method into a method labeled with `<extension>`. The extension method on type Circle becomes a static-like method taking the extended instance explicitly as the first parameter. The example asserts equivalence of invoking the extension method both ways.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n<extension> def circumference(c: Circle): Double = c.radius * math.Pi * 2\n\nassert(circle.circumference == circumference(circle))\n```\n\n----------------------------------------\n\nTITLE: High-order Function Initialization Access Check in Scala\nDESCRIPTION: This Scala snippet shows a subtle initialization problem caused by a high-order function capturing a field during initialization, with a dependent field `b` accessed before completion. The checker identifies that initializing `b` after calling a function that depends on it leads to unsafe access. The dependencies include Scala 3 compiler with safe init checker, classes with vals assigned by function calls, and methods referencing those vals. Inputs include an abstract parent class with a function field referring to a method, and a subclass initializing fields out of order causing an error. The output is a compiler warning showing the dependency chain causing unsafe access.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/safe-initialization.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Parent:\n  val f: () => String = () => this.message\n  def message: String\n\nclass Child extends Parent:\n  val a = f()\n  val b = \"hello\"           // error\n  def message: String = b\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Delegate Instance in Scala\nDESCRIPTION: Introduces the new `delegate` keyword for declaring canonical instances of a type class, replacing the previously used `implied` keyword. This example shows a basic definition for an `Ord[Int]` delegate.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-06-11-16th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndelegate IntOrd for Ord[Int] {\n  def compare(x: Int, y: Int) =\n    if (x < y) -1 else if (x > y) +1 else 0\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Indentation Region Rules for Match and Catch Clauses\nDESCRIPTION: Defines how indentation regions are opened after match or catch statements when the following case appears at the same indentation level, influencing block structure parsing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n - An indentation region is opened after a `match` or `catch` also if the following `case` appears at the indentation width that's current for the `match` itself.\n- The indentation region closes at the first token at that same indentation width that is not a `case`, or at any token with a smaller indentation width, whichever comes first.\n- This allows writing `match` expressions where cases are not indented themselves.\n```\n\n----------------------------------------\n\nTITLE: Indirect Capability Capture via Function Calls in Scala\nDESCRIPTION: Shows that a function (`f`) captures capabilities (`fs`) even if it doesn't directly reference them, provided it calls another function (`g`) that does. The resulting type of `f` (returned by `test`) is `{fs} String -> Unit` due to the capture in `g`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndef test(fs: FileSystem) =\n  def f() = g()\n  def g() = (x: String) => Logger(fs).log(x)\n  f\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Classes with Potential Shadowing in Scala 2\nDESCRIPTION: This Scala 2 snippet illustrates nested classes within an outer class, where a subclass defines an inner class with the same name as the superclass's inner class. This pattern visually resembles overriding inner classes but does not actually override due to Scala 2 semantics. No additional dependencies beyond Scala 2 compiler are required. Input includes class inheritance with inner class declarations, and the output is valid compilation without errors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/class-shadowing.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Base {\n  class Ops { ... }\n}\n\nclass Sub extends Base {\n  class Ops { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Bounds with Deferred Givens - Scala\nDESCRIPTION: This code uses trait and class definitions to showcase implementing context bounds using deferred givens. The 'Sorted' trait requires its type parameter 'Element' to have an implicit 'Ord' instance, which is deferred. The 'SortedSet' class then provides this instance explicitly via a context parameter. Scala 3.6 is necessary, and subclasses must either provide the required given or let the compiler synthesize it. The trait provides a clean context bound, and the class supplies the required implementation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/deferred-givens.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Sorted:\n  type Element : Ord\n\nclass SortedSet[A : Ord as ord] extends Sorted:\n  type Element = A\n```\n\n----------------------------------------\n\nTITLE: Declaring Capability-Tracked Parameter with Capture Annotation in Scala 3\nDESCRIPTION: This revised definition of `usingLogFile` uses capture checking by adding a `^` annotation to the parameter type `FileOutputStream^`. This denotes that the parameter is a capability whose lifetime is statically tracked. This declaration enables the compiler to prevent closures or functions from capturing the capability beyond its valid scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef usingLogFile[T](op: FileOutputStream^ => T): T =\n  // same body as before\n```\n\n----------------------------------------\n\nTITLE: Git Contributor List for Scala 3 3.0.0-M3 Release\nDESCRIPTION: Shell command output showing the list of contributors and their commit counts for the Scala 3 3.0.0-M3 release, obtained using git shortlog between versions 3.0.0-M2 and 3.0.0-M3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-12-18-scala3-m3.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n    80  Nicolas Stucki\n    73  Martin Odersky\n    64  Krzysztof Romanowski\n    32  Liu Fengyun\n    28  Aleksander Boruch-Gruszecki\n    22  Anatolii Kmetiuk\n    17  Guillaume Martres\n    17  Sébastien Doeraene\n    14  Andrzej Ratajczak\n    13  Tom Grigg\n     8  Filip Zybała\n     7  Lan, Jian\n     5  Olivier Blanvillain\n     5  Som Snytt\n     5  Jamie Thompson\n     4  Stéphane Micheloud\n     4  Lionel Parreaux\n     3  Adrien Piquerez\n     3  Artur Opala\n     3  Hanns Holger Rutz\n     3  Michael Pilquist\n     3  Michał Pałka\n     3  bishabosha\n     2  Jonathan Brachthäuser\n     2  Camila Andrea Gonzalez Williamson\n     1  Mikael Blomstrand\n     1  Francois GORET\n     1  Felix Mulder\n     1  Raphael Jolly\n     1  Robert Stoll\n     1  Ruslan Shevchenko\n     1  Seth Tisue\n     1  Eugene Yokota\n     1  Amadou CISSE\n     1  Akhtiam Sakaev\n     1  Martin Duhem\n     1  Tomasz Godzik\n     1  Matthew Pickering\n     1  odersky\n```\n\n----------------------------------------\n\nTITLE: Method application syntax in Scala 3 (EBNF grammar)\nDESCRIPTION: Defines the syntax rules for method applications using Extended Backus-Naur Form (EBNF). It specifies how different argument expressions, including normal, using, varargs, and block expressions, are structured within a method call. This parsing schema provides the foundation for understanding valid method invocation syntax in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_5\n\nLANGUAGE: EBNF\nCODE:\n```\nSimpleExpr    ::=  SimpleExpr1 ArgumentExprs\nArgumentExprs ::=  ‘(’ [Exprs] ‘)’\n                |  ‘(’ ‘using’ Exprs ‘)’\n                |  ‘(’ [Exprs ‘,’] PostfixExpr ‘:’ ‘_’ ‘*’)\n                |  [nl] BlockExpr\nExprs         ::=  Expr {‘,’ Expr}\n```\n\n----------------------------------------\n\nTITLE: Encoded Pickled Scala 3 Quote AST (TASTy String)\nDESCRIPTION: Displays the final serialized form of the quote's AST after all transformations into holes, encoded as a Java String using a fictitious `tasty\"...\"` literal. This represents the TASTy bytes ready for embedding in bytecode.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\n// pickled AST bytes encoded in a base64 string\ntasty\"\"\"\n  val (x, n): (Double, Int) = (5, 2)\n  << 0; Double; x, n >> * << 1; Double; n >>\n\"\"\"\n// or\ntasty\"\"\"\n  type U = << 0; Nothing..Any; >>\n  List.empty[U]\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining an Implicit Object in Scala 2 - Scala\nDESCRIPTION: Simulates Scala 3's given instance by defining an implicit object intOrd that extends Ord[Int] in Scala 2. Relies on the existing Ord trait. Produces an implicit instance of ordering for Int, directly usable in implicit resolution.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit object intOrd extends Ord[Int] { ... }\n```\n\n----------------------------------------\n\nTITLE: Untupling Limitation with Explicit Function Type (Scala)\nDESCRIPTION: Illustrates a limitation of parameter untupling when applying a function `combiner` that has been explicitly typed as `(Int, Int) => Int` to a list of tuples `List[(Int, Int)]`. This results in a `Type Mismatch` because parameter untupling adapts the application, not the function's explicit type itself.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/parameter-untupling.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval combiner: (Int, Int) => Int = _ + _\nxs.map(combiner)     // Type Mismatch\n```\n\n----------------------------------------\n\nTITLE: Defining FromDigits Subclasses in Scala\nDESCRIPTION: Shows helper traits defined within the `FromDigits` companion object. These subclasses (`WithRadix`, `Decimal`, `Floating`) extend `FromDigits` and signal to the compiler that the implementing type can handle specific literal formats like different number bases, decimal points, or exponents. `WithRadix` adds an overloaded `fromDigits` method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject FromDigits:\n\n  /** A subclass of `FromDigits` that also allows to convert whole\n   *  number literals with a radix other than 10\n   */\n  trait WithRadix[T] extends FromDigits[T]:\n    def fromDigits(digits: String): T = fromDigits(digits, 10)\n    def fromDigits(digits: String, radix: Int): T\n\n  /** A subclass of `FromDigits` that also allows to convert number\n   *  literals containing a decimal point \".\".\n   */\n  trait Decimal[T] extends FromDigits[T]\n\n  /** A subclass of `FromDigits`that allows also to convert number\n   *  literals containing a decimal point \".\" or an\n   *  exponent `('e' | 'E')['+' | '-']digit digit*`.\n   */\n  trait Floating[T] extends Decimal[T]\n```\n\n----------------------------------------\n\nTITLE: Adding String Operations via Implicit Wrapper\nDESCRIPTION: Shows an implicit wrapper provided by `Predef` that adds `+` (for string concatenation) and `formatted` methods to `Any`. These methods allow any value to be easily concatenated with a string or formatted using a format string, leveraging the value's `toString` representation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\ndef +(other: String) = String.valueOf(self) + other\ndef formatted(fmtstr: String): String = fmtstr format self\n```\n\n----------------------------------------\n\nTITLE: Extension Method to Untuple Functions for Arbitrary Arity in Scala\nDESCRIPTION: Defines an extension method untupled on functions of type Args => R, creating an equivalent version of the function that accepts N separate arguments instead of a single tuple argument. This method requires an implicit TupledFunction instance to perform the inverse conversion from tupled to untupled functions. It generalizes the standard scala.Function.untupled for functions of any arity.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/tupled-function.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n/** Creates an untupled version of this function: instead of a single argument of type [[scala.Tuple]] with N elements,\\n *  it accepts N arguments.\\n *\\n *  This is a generalization of [[scala.Function.untupled]] that work on functions of any arity\\n *\\n *  @tparam F the function type\\n *  @tparam Args the tuple type with the same types as the function arguments of F\\n *  @tparam R the return type of F\\n */\\nextension [F, Args <: Tuple, R](f: Args => R)\\n  def untupled(using tf: TupledFunction[F, Args => R]): F = tf.untupled(f)\n```\n\n----------------------------------------\n\nTITLE: Adding untupled Extension Method in Scala\nDESCRIPTION: This extension method adds an `untupled` capability to a function `Args => R` that accepts a single tuple argument, requiring an implicit `TupledFunction[F, Args => R]` instance. It transforms the tupled function into an equivalent function `F` with individual arguments. It utilizes the `untupled` method from the implicit `TupledFunction` instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/tupled-function.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n/** Creates an untupled version of this function: instead of a single argument of type [[scala.Tuple]] with N elements,\n *  it accepts N arguments.\n *\n *  This is a generalization of [[scala.Function.untupled]] that work on functions of any arity\n *\n *  @tparam F the function type\n *  @tparam Args the tuple type with the same types as the function arguments of F\n *  @tparam R the return type of F\n */\nextension [F, Args <: Tuple, R](f: Args => R)\n  def untupled(using tf: TupledFunction[F, Args => R]): F = tf.untupled(f)\n```\n\n----------------------------------------\n\nTITLE: Preserving Variance Annotations in Abstract Types in Scala\nDESCRIPTION: This Scala snippet defines an abstract type `F2` with variance annotations (`-A`, `+B`). It highlights that abstract types (and opaque type aliases) remember their declared variance constraints, ensuring they can only be instantiated with types that satisfy these specific variance requirements.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas-spec.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntype F2[-A, +B]\n```\n\n----------------------------------------\n\nTITLE: Example Generated Code for Derived Eq[Opt[T]] in Scala\nDESCRIPTION: Shows the approximate structure of the code generated by the Scala 3 compiler for the `Eq[Opt[T]]` instance after the `derived` method is inlined. It demonstrates how `eqSum`, `eqProduct`, and `summon` calls are composed based on the structure of the `Opt` enum.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ngiven derived$Eq[T](using eqT: Eq[T]): Eq[Opt[T]] =\n  eqSum(\n    summon[Mirror[Opt[T]]],\n    List(\n      eqProduct(summon[Mirror[Sm[T]]], List(summon[Eq[T]])),\n      eqProduct(summon[Mirror[Nn.type]], Nil)\n    )\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining Lazy Cons Operator Extension Method in Scala\nDESCRIPTION: Extension method that defines an infix operator #: for constructing lazy lists. It takes a call-by-name parameter for the tail to ensure laziness and tracks capabilities with capture annotations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nextension [A](x: A)\n  def #:(xs1: => {*} LzyList[A]): {xs1} LzyList[A] =\n    LzyCons(x, () => xs1)\n```\n\n----------------------------------------\n\nTITLE: Equivalence of Parameterized Type and Type Lambda in Scala\nDESCRIPTION: This snippet demonstrates how a standard parameterized type definition like `type T[X] = R` is considered shorthand in Scala 3 for an unparameterized type alias whose right-hand side is an equivalent type lambda `type T = [X] =>> R`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas-spec.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntype T[X] = R\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype T = [X] =>> R\n```\n\n----------------------------------------\n\nTITLE: Using Implicit Functions with Empty Parameters in Scala 3\nDESCRIPTION: Example of using the new support for implicit functions with empty parameter lists, a feature added in Dotty 0.9.0-RC1 that removes the previous arbitrary restriction requiring non-empty parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-07-06-ninth-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype IntProducer = implicit () => Int\n\ndef prod1: IntProducer = 1\nval prod2: IntProducer = 2\n```\n\n----------------------------------------\n\nTITLE: Using Match After a Period in Scala\nDESCRIPTION: This example demonstrates how match can follow a period in Scala 3. The code uses an if-then-else expression that checks if a list is empty using the match operator after a dot notation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/match-syntax.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nif xs.match\n  case Nil => false\n  case _   => true\nthen \"nonempty\"\nelse \"empty\"\n```\n\n----------------------------------------\n\nTITLE: Scala 3 End Marker Usage for Explicit Region Closure\nDESCRIPTION: Describes the optional `end` marker syntax to explicitly specify the end of indentation regions, improving readability for large or heavily indented code blocks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ndef largeMethod(...) =\n  ...\n  if ... then ...\n  else\n    ... // a large block\n  end if\n  ... // more code\nend largeMethod\n\n// End markers include `end` plus a specifier token.\n// Valid specifiers are identifiers or keywords like `if`, `while`, `for`, etc.\n// The marker must match the statement's identifier, e.g., `end if` for an if block.\n```\n\n----------------------------------------\n\nTITLE: Generating GitHub Release Changelog using gren\nDESCRIPTION: Uses the 'gren' tool to generate a changelog for a GitHub release based on Pull Requests within a specified tag range. Requires 'gren' installation, 'origin' remote pointing to 'lampepfl/dotty', and tags pushed to the remote 'main' branch.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/procedures/release.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\ngren changelog -G --override -D prs --tags=0.13.0-RC1..0.14.0-RC1\n```\n\n----------------------------------------\n\nTITLE: Previous Syntax for Parameterized Conditional Givens in Scala 3\nDESCRIPTION: Illustrates the older syntax for defining parameterized `given` instances that depend on other `given` instances (conditional givens). This syntax uses nested `given` clauses (`given Ord[T]`) within the parameter list.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ngiven listOrd[T](given Ord[T]): Ord[List[T]] ...\n```\n\n----------------------------------------\n\nTITLE: Java Interoperability: Constant Field Patching\nDESCRIPTION: Shows that simple Java `final` fields initialized with literals are considered non-null and retain their original types in Scala. However, `final` fields initialized via method calls (`NAME_GENERATED`) are still treated as potentially nullable.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_10\n\nLANGUAGE: java\nCODE:\n```\n// Java definition\nclass Constants {\n  final String NAME = \"name\";\n  final int AGE = 0;\n  final char CHAR = 'a';\n\n  final String NAME_GENERATED = getNewName();\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Equivalent Scala signature with explicit nulls\nclass Constants:\n  val NAME: String(\"name\") = \"name\"\n  val AGE: Int(0) = 0\n  val CHAR: Char('a') = 'a'\n\n  val NAME_GENERATED: String | Null = getNewName()\n```\n\n----------------------------------------\n\nTITLE: Manual use of 'derived' for custom type class instances in Scala 3\nDESCRIPTION: This snippet illustrates how to manually invoke 'derived' for creating an 'Ordering' instance for 'Option' types. It is useful when automatic derivation is not applicable or when custom behavior is needed, showing the explicit pattern for deriving instances outside the usual 'derives' clause.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ngiven [T: Ordering] => Ordering[Option[T]] = Ordering.derived\n```\n\n----------------------------------------\n\nTITLE: Equality Comparison Restrictions with Null in Scala 3\nDESCRIPTION: This example demonstrates how the explicit nulls feature restricts equality comparisons with null. Comparisons between non-nullable types and null are not allowed, but comparisons involving nullable types or with type hints are permitted.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval x: String = ???\nval y: String | Null = ???\n\nx == null       // error: Values of types String and Null cannot be compared with == or !=\nx eq null       // error\n\"hello\" == null // error\n\ny == null       // ok\ny == x          // ok\n\n(x: String | Null) == null  // ok\n(x: Any) == null            // ok\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using Scala Product-Sequence Match Extractor (unapplySeq)\nDESCRIPTION: Illustrates a Product-Sequence match extractor using an `unapplySeq` method returning `Option[(String, Seq[Int])]`. The example shows matching against a fixed initial element (`name`) followed by a variable-length sequence (`ns*`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nclass Foo(val name: String, val children: Int*)\nobject Foo:\n  def unapplySeq(f: Foo): Option[(String, Seq[Int])] =\n    Some((f.name, f.children))\n\ndef foo(f: Foo) = f match\n  case Foo(name, x, y, ns*) => \">= two children.\"\n  case Foo(name, ns*) =>    => \"< two children.\"\n```\n\n----------------------------------------\n\nTITLE: Defining Typeable Alias in Scala Reflect\nDESCRIPTION: Defines `Typeable` as an alias for `TypeTest[Any, T]`. This alias simplifies the syntax for common cases where a type test is needed from an input of type `Any` (or a supertype like `AnyRef`) to a specific type `T`, often used with context bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/type-test.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.reflect\n\ntype Typeable[T] = TypeTest[Any, T]\n```\n\n----------------------------------------\n\nTITLE: Error handling in derivation when conditions are not met\nDESCRIPTION: The documentation notes that if the 'TC' type class is not suitable for automatic derivation, such as having multiple parameters or being unrelated like 'CanEqual', an error will be thrown to indicate the derivation is unsupported. This enforces correct usage constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nError is generated when 'TC' is not valid for derivation, indicating the mismatch or unsupported pattern.\n```\n\n----------------------------------------\n\nTITLE: Enhanced Error Message Hint for Missing `else` in Scala\nDESCRIPTION: Shows the specific additional hint provided in the improved error message in Dotty 0.24.0-RC1 for the typeless conditional example. This hint suggests that a missing `else` part might be the cause of the type mismatch, making the error more beginner-friendly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-04-29-24th-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n|             Maybe you are missing an else part for the conditional?\n```\n\n----------------------------------------\n\nTITLE: Defining Syntax for Dependent Function Types in Scala 3\nDESCRIPTION: Presents the Backus-Naur Form (BNF) syntax rules for defining dependent function types and typed function parameters in Scala 3. It shows how function argument types (`FunArgTypes`) can be an infix type, a parenthesized list of types, or a parenthesized list of typed parameters (`TypedFunParam`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/dependent-function-types-spec.md#_snippet_0\n\nLANGUAGE: bnf\nCODE:\n```\nFunArgTypes       ::=  InfixType\n                    |  ‘(’ [ FunArgType {',' FunArgType } ] ‘)’\n                    |  ‘(’ TypedFunParam {',' TypedFunParam } ‘)’\nTypedFunParam     ::=  id ‘:’ Type\n```\n\n----------------------------------------\n\nTITLE: Safe Capture Usage Example with List in Scala 3\nDESCRIPTION: This example shows a safe usage of `usingLogFile` where a List is processed by mapping numbers while performing logging via the file capability. The usage is safe because the computation is strict and does not retain the capability beyond the allowed scope. Capture checking permits this code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval xs = usingLogFile { f =>\n  List(1, 2, 3).map { x => f.write(x); x * x }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Simple Structural Given Scala 3\nDESCRIPTION: Defines a class `IntOrd` implementing `Ord[Int]` and provides a default instance of this class as a given using the `given ClassName()` syntax. This form is used when the given instance is a simple instantiation without requiring additional alias names or members.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/more-givens.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass IntOrd extends Ord[Int]:\n  def compare(x: Int, y: Int) =\n    if x < y then -1 else if x > y then +1 else 0\n\ngiven IntOrd()\n```\n\n----------------------------------------\n\nTITLE: New `=>` Syntax for Anonymous Conditional Givens in Scala 3\nDESCRIPTION: Shows the proposed new experimental `=>` syntax applied to anonymous conditional `given` instances. `[T]: Ord[T] => Ord[List[T]]` indicates that for any type T, a given `Ord[T]` implies a given `Ord[List[T]]`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ngiven [T]: Ord[T] => Ord[List[T]] ...\n```\n\n----------------------------------------\n\nTITLE: Defining the Syntax of 'opaque' Modifier in EBNF\nDESCRIPTION: Shows the extended EBNF syntax rule that includes the ‘opaque’ modifier, which is a soft modifier usable before a definition keyword in Scala 3. This snippet clarifies that 'opaque' acts syntactically as a modifier but can still be used as an identifier elsewhere.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/opaques-details.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nModifier          ::=  ...\n                    |  ‘opaque’\n```\n\n----------------------------------------\n\nTITLE: Error Handling in FromDigits Implementations\nDESCRIPTION: This code defines exceptions used for signaling errors during string-to-number conversions in FromDigits instances, including cases such as number too large, too small, or malformed inputs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class FromDigitsException(msg: String) extends NumberFormatException(msg)\n\nclass NumberTooLarge (msg: String = \"number too large\") extends FromDigitsException(msg)\nclass NumberTooSmall (msg: String = \"number too small\") extends FromDigitsException(msg)\nclass MalformedNumber(msg: String = \"malformed number literal\") extends FromDigitsException(msg)\n```\n\n----------------------------------------\n\nTITLE: Applying Scala 3 Compiler Plugins via `scalac` (Shell)\nDESCRIPTION: Demonstrates the usage of the `-Xplugin:` command-line option with `scalac` to load and apply one or more compiler plugins (packaged as JAR files) during the compilation of a Scala source file (`Test.scala`). Each `-Xplugin:` flag specifies a path to a plugin JAR.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/compiler-plugins.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nscalac -Xplugin:pluginA.jar -Xplugin:pluginB.jar Test.scala\n```\n\n----------------------------------------\n\nTITLE: Matching nullable unions with 'OrNull' extractor pattern\nDESCRIPTION: Demonstrates pattern matching on a 'Type' to extract its non-null component from a nullable union type using the 'OrNull' extractor. This pattern is used within internal type analysis to handle nullability decisions effectively during type checking and transformations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/explicit-nulls.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n(tp: Type) match\n  case OrNull(tp1) => // if tp is a nullable union: tp1 | Null\n  case _ => // otherwise\n```\n\n----------------------------------------\n\nTITLE: Defining a Given Conversion Instance in Scala 3 - Scala\nDESCRIPTION: Demonstrates two ways of providing a conversion from String to Token in Scala 3: explicitly implementing the apply method in an anonymous given instance, or using a function value. Needs Conversion, Keyword class. Used to automatically convert Strings to Tokens.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ngiven stringToToken: Conversion[String, Token] with\n  def apply(str: String): Token = KeyWord(str)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ngiven stringToToken: Conversion[String, Token] = KeyWord(_)\n```\n\n----------------------------------------\n\nTITLE: Defining Types and Implicits for Ambiguity Example (Scala)\nDESCRIPTION: Defines simple classes A, B, C and several implicit values/methods (a1, a2, b, c) to illustrate changes in implicit search ambiguity resolution in Dotty 0.5.0-RC1. This setup is used to show how Dotty's new rules handle ambiguous implicit searches differently than Scala 2 when querying `implicitly[C]`, where both `b(a1)` and `b(a2)` are valid paths.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-12-01-fifth-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass A\nclass B extends C\nclass C\nimplicit def a1: A\nimplicit def a2: A\nimplicit def b(implicit a: A): B\nimplicit def c: C\n```\n\n----------------------------------------\n\nTITLE: Type Error Examples for Opaque Types in Scala 3\nDESCRIPTION: This snippet illustrates invalid operations involving the opaque type 'Logarithm' outside its defining scope, including assigning a 'Logarithm' to a 'Double' variable, and using raw numeric literals or incompatible types with the extension methods, demonstrating type safety enforced by opaque types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/opaques.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval d: Double = l       // error: found: Logarithm, required: Double\nval l2: Logarithm = 1.0 // error: found: Double, required: Logarithm\nl * 2                   // error: found: Int(2), required: Logarithm\nl / l2                  // error: `/` is not a member of Logarithm\n```\n\n----------------------------------------\n\nTITLE: Using the `Typeable` Alias with Context Bounds in Scala\nDESCRIPTION: Demonstrates using the `Typeable[T]` alias as a context bound (`T: Typeable`). This implicitly provides a `TypeTest[Any, T]` instance, allowing runtime type checks like `case x: T` within the generic function `f`. Example calls show its behavior.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef f[T: Typeable]: Boolean =\n  \"abc\" match\n    case x: T => true\n    case _ => false\n\nf[String] // true\nf[Int] // false\n```\n\n----------------------------------------\n\nTITLE: Comparing Parameter Types (By-Value, By-Name, Inline) in Scala Inline Methods\nDESCRIPTION: Defines an inline method `funkyAssertEquals` with three parameters: `actual` (by-value), `expected` (by-name, using `=>`), and `delta` (`inline`). The translated code shows that the by-value argument is evaluated once and stored, the by-name argument becomes a `def`, and the `inline` argument's expression is duplicated wherever `delta` is used in the method body.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ninline def funkyAssertEquals(actual: Double, expected: =>Double, inline delta: Double): Unit =\n  if (actual - expected).abs > delta then\n    throw new AssertionError(s\"difference between ${expected} and ${actual} was larger than ${delta}\")\n\nfunkyAssertEquals(computeActual(), computeExpected(), computeDelta())\n// translates to\n//\n//   val actual = computeActual()\n//   def expected = computeExpected()\n//   if (actual - expected).abs > computeDelta() then\n//     throw new AssertionError(s\"difference between ${expected} and ${actual} was larger than ${computeDelta()}\")\n```\n\n----------------------------------------\n\nTITLE: Examples Distinguishing Leading Infix Operators from Separate Statements in Scala 3\nDESCRIPTION: Provides code demonstrating the difference between recognizing combined infix expressions using leading symbolic operators with spaces and interpreting lines as separate statements otherwise. It clarifies compiler behavior with indentation and trailing spaces affecting semicolon inference in multi-line expressions containing symbolic identifiers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/operators.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n    freezing\n  | boiling\n```\n\nLANGUAGE: scala\nCODE:\n```\n    freezing\n  !boiling\n```\n\nLANGUAGE: scala\nCODE:\n```\n  println(\"hello\")\n  ???\n  ??? match { case 0 => 1 }\n```\n\n----------------------------------------\n\nTITLE: Staging Implicit Arguments in Scala 3 Macros\nDESCRIPTION: Demonstrates how to pass an implicit `Ordering[T]` available at the macro call site (`treeSetFor`) as an explicit `Expr[Ordering[T]]` (`'ord`) to the macro implementation (`setExpr`). The implementation then uses this expression to provide the implicit instance within the generated code (`'{ given Ordering[T] = $ord; ... }`), effectively staging the implicit.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\ninline def treeSetFor[T](using ord: Ordering[T]): Set[T] =\n  ${ setExpr[T](using 'ord) }\n\ndef setExpr[T:Type](using ord: Expr[Ordering[T]])(using Quotes): Expr[Set[T]] =\n  '{ given Ordering[T] = $ord; new TreeSet[T]() }\n```\n\n----------------------------------------\n\nTITLE: Implementing Monad for ConfigDependent\nDESCRIPTION: Provides a `given` instance of `Monad` for the `ConfigDependent` type, defining `pure` to ignore the environment and produce a constant value, and `flatMap` to compose functions while passing the `Config` environment.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ngiven configDependentMonad: Monad[ConfigDependent]:\n\n  def pure[A](x: A): ConfigDependent[A] =\n    config => x\n\n  extension [A](x: ConfigDependent[A])\n    def flatMap[B](f: A => ConfigDependent[B]): ConfigDependent[B] =\n      config => f(x(config))(config)\n```\n\n----------------------------------------\n\nTITLE: Defining Tuple Expression Syntax Using EBNF in Scala\nDESCRIPTION: This EBNF fragment precisely expresses how tuple expressions are formed: a parenthesized, comma-separated list of expressions is parsed as 'SimpleExpr', typically creating a tuple value. The construct is central to understanding how tuples are created in Scala. No input or output is produced and no dependencies are required.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_12\n\nLANGUAGE: EBNF\nCODE:\n```\nSimpleExpr   ::=  ‘(’ [Exprs] ‘)’\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Stable Identifier Pattern Syntax (EBNF)\nDESCRIPTION: Provides the EBNF rule for `SimplePattern` using `StableId`. This rule indicates that a stable identifier, such as a reference to a `val`, `object`, or a path, can be used as a pattern. It matches values that are strictly equal to the value referenced by the identifier.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_8\n\nLANGUAGE: ebnf\nCODE:\n```\n  SimplePattern   ::=  StableId\n```\n\n----------------------------------------\n\nTITLE: Monad instance for List using given\nDESCRIPTION: Provides a `given` instance of `Monad` for `List`, defining `pure` to wrap a value in a list and `flatMap` to flatten a list of lists, leveraging existing List methods. The `map` function is inherited from `Functor`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ngiven listMonad: Monad[List]:\n  def pure[A](x: A): List[A] = List(x)\n  extension [A](xs: List[A])\n    def flatMap[B](f: A => List[B]): List[B] = xs.flatMap(f)\n```\n\n----------------------------------------\n\nTITLE: Defining Method with Multiple Type/Term/Using Clauses (Scala 3)\nDESCRIPTION: Demonstrates the generalized method syntax in Scala 3, allowing multiple non-adjacent type parameter clauses [T, U], [V], [A] interspersed with term and using clauses. This flexibility enables new design patterns previously impossible or cumbersome.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/generalized-method-syntax.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef foo[T, U](x: T)(y: U)[V](z: V, s: String)(using Ord[Int])[A](a: Array[A])(implicit List[U])\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Method in Scala 3\nDESCRIPTION: Defines an extension method `circumference` for the `Circle` class using Scala 3's dedicated `extension` syntax. This allows calling `circumference` directly on instances of `Circle`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n```\n\n----------------------------------------\n\nTITLE: Defining a GADT for Equality Constraints in Scala\nDESCRIPTION: Presents an `enum EQ[S, T]` with a single case `Refl[U]`. Matching on `Refl` introduces an equality constraint between the type parameters `S` and `T` (specifically, that they are both equal to some type `U`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/gadts.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nenum EQ[S, T] {\n  case Refl[U]() extends EQ[U, U]\n}\n```\n\n----------------------------------------\n\nTITLE: Running Quoted Code with scala.quoted.staging in Scala\nDESCRIPTION: This example shows how to define a quoted expression using `Quotes` and then execute it at run-time using the `run` function from `scala.quoted.staging`. The `run` function compiles and evaluates the provided quoted expression, enabling execution of generated code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef mkPower2()(using Quotes): Expr[Double => Double] = ...\n\nrun(mkPower2())\n```\n\n----------------------------------------\n\nTITLE: Encoding Pattern Variables and Type Variables in Patterns\nDESCRIPTION: Illustrates how pattern variables and type variables within quote patterns are normalized, annotated, and extracted during pattern matching. These variables are introduced explicitly in `TypeBindings` and annotated in patterns for correct scope and type inference during macro expansion.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\ncase '{ type t; ($xs: List[t]).map[t](identity[t]) } =>\n// is elaborated to\ncase ExprMatch[(t), (Type[t], Expr[List[t]])]((using t, xs))(using p) =>\n```\n\n----------------------------------------\n\nTITLE: Reducing Redundant Nullable Types When Translating Java Generics - Java\nDESCRIPTION: These Java classes illustrate nested generics (Box and BoxFactory) to demonstrate how Scala 3 minimizes redundant nullable (`T?`) annotations by applying nullification only at necessary levels. The snippet serves as raw input for subsequent Scala translation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_11\n\nLANGUAGE: Java\nCODE:\n```\nclass Box<T> { T get(); }\nclass BoxFactory<T> { Box<T> makeBox(); }\n\n```\n\n----------------------------------------\n\nTITLE: Specify Language Version using Import in Scala\nDESCRIPTION: This Scala snippet demonstrates how to use a `scala.language` import statement at the top of a source file to specify the desired language version for that particular file. This method supersedes any `-source` command-line settings for the file. The import must appear before any definitions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/language-versions/source-compatibility.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage p\nimport scala.language.`future-migration`\n\nclass C { ... }\n```\n\n----------------------------------------\n\nTITLE: Transparent Inline Method for Return Type Specialization\nDESCRIPTION: Introduces the `transparent inline` method `choose`, which allows the return type to be specialized based on its input argument. This improves static type information and enables precise type checking after inlining, especially useful for polymorphic code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/inline.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ntransparent inline def choose(b: Boolean): A =\n  if b then new A else new B\n```\n\n----------------------------------------\n\nTITLE: Using the `@equalityClass` Annotation for Automatic `Eq` Generation\nDESCRIPTION: Shows the proposed `@equalityClass` annotation applied to the `Option` class definition. This annotation would trigger the automatic generation of the corresponding `Eq` instance (like `eqOption` shown previously) in the class's companion object, simplifying the process for developers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-05-05-multiversal-equality.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n@equalityClass class Option[+T] { ... }\n```\n\n----------------------------------------\n\nTITLE: Previous Syntax for Anonymous Conditional Givens in Scala 3\nDESCRIPTION: Shows the older syntax for defining anonymous parameterized conditional `given` instances. This syntax, using `given [T](given Ord[T])`, is considered potentially awkward, motivating the exploration of new syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ngiven [T](given Ord[T]): Ord[List[T]] ...\n```\n\n----------------------------------------\n\nTITLE: Mapping List of Tuples with Parameter Untupling (Scala)\nDESCRIPTION: Shows the new Scala 3 syntax for parameter untupling. A lambda function expecting two `Int` parameters `(x, y)` is directly applied to the tuple elements from the list `xs`, performing the `x + y` operation without requiring explicit pattern matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/parameter-untupling.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nxs.map {\n  (x, y) => x + y\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using Scala Sequence Match Extractor (unapplySeq Option[Seq])\nDESCRIPTION: Shows an example of a Sequence match extractor using an `unapplySeq` method returning `Option[Seq[Char]]`. The `match` expression demonstrates pattern matching against a fixed number of elements in the sequence.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nobject CharList:\n  def unapplySeq(s: String): Option[Seq[Char]] = Some(s.toList)\n\n\"example\" match\n  case CharList(c1, c2, c3, c4, _, _, _) =>\n    println(s\"$c1,$c2,$c3,$c4\")\n  case _ =>\n    println(\"Expected *exactly* 7 characters!\")\n\n// e,x,a,m\n```\n\n----------------------------------------\n\nTITLE: Defining Similarly Named Inner Classes in Scala 2\nDESCRIPTION: This Scala 2 code demonstrates a pattern where a subclass `Sub` defines an inner class `Ops` with the same name as an inner class `Ops` in its superclass `Base`. This pattern, known as class shadowing, was permitted in Scala 2 but is disallowed in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/class-shadowing.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Base {\n  class Ops { ... }\n}\n\nclass Sub extends Base {\n  class Ops { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and using reach capabilities with variables in Scala\nDESCRIPTION: Demonstrates how to store impure functions and successive values in variables with reach capabilities, illustrating how reachability sets (`ops*`) are used to express capabilities accessible through a reference. Highlights the distinction between pure capabilities and reach capabilities in variable typing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_35\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(op: A => B)\n  var x: A ->{op} B = op\n  ...\n\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(ops: List[A => B])\n  var xs = ops\n  var x: ??? = xs.head\n  while xs.nonEmpty do\n    xs = xs.tail\n    x = xs.head\n  ...\n\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(ops: List[A => B])\n  var xs = ops\n  var x: A ->{ops*} B = xs.head\n  ...\n\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Lexical Syntax using EBNF\nDESCRIPTION: EBNF grammar rules defining the lexical tokens of Scala 3. This includes whitespace, identifiers (upper, lower, letter, varid, etc.), operators, literals (integer, floating-point, boolean, character, string, interpolated string), comments, and escape sequences. These rules form the basic building blocks recognized by the Scala compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/13-syntax-summary.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nwhiteSpace       ::=  ‘\\u0020’ | ‘\\u0009’ | ‘\\u000D’ | ‘\\u000A’\nupper            ::=  ‘A’ | ... | ‘Z’ | ‘$’ and any character in Unicode categories Lu, Lt or Nl,\n                      and any character in Unicode categories Lo and Lm that doesn't have\n                      contributory property Other_Lowercase\nlower            ::=  ‘a’ | ... | ‘z’ | ‘_’ and any character in Unicode category Ll,\n                      and any character in Unicode categories Lo or Lm that has contributory\n                      property Other_Lowercase\nletter           ::=  upper | lower\ndigit            ::=  ‘0’ | ... | ‘9’\nparen            ::=  ‘(’ | ‘)’ | ‘[’ | ‘]’ | ‘{’ | ‘}’\ndelim            ::=  ‘`’ | ‘'’ | ‘\"’ | ‘.’ | ‘;’ | ‘,’\nopchar           ::=  ‘!’ | ‘#’ | ‘%’ | ‘&’ | ‘*’ | ‘+’ | ‘-’ | ‘/’ | ‘:’ |\n                      ‘<’ | ‘=’ | ‘>’ | ‘?’ | ‘@’ | ‘\\’ | ‘^’ | ‘|’ | ‘~’\n                      and any character in Unicode categories Sm or So\nprintableChar    ::=  all characters in [\\u0020, \\u007E] inclusive\nUnicodeEscape    ::=  ‘\\’ ‘u’ {‘u’} hexDigit hexDigit hexDigit hexDigit\nhexDigit         ::=  ‘0’ | ... | ‘9’ | ‘A’ | ... | ‘F’ | ‘a’ | ... | ‘f’\ncharEscapeSeq    ::=  ‘\\’ (‘b’ | ‘t’ | ‘n’ | ‘f’ | ‘r’ | ‘\"’ | ‘'’ | ‘\\’)\nescapeSeq        ::=  UnicodeEscape | charEscapeSeq\n\nop               ::=  opchar {opchar}\nvarid            ::=  lower idrest\nboundvarid       ::=  varid\n                   |  ‘`’ varid ‘`’\nalphaid          ::=  upper idrest\n                   |  varid\nplainid          ::=  alphaid\n                   |  op\nid               ::=  plainid\n                   |  ‘`’ { charNoBackQuoteOrNewline | escapeSeq } ‘`’\nidrest           ::=  {letter | digit} [‘_’ op]\nquoteId          ::=  ‘'’ alphaid\nspliceId         ::=  ‘$’ alphaid ;\n\nintegerLiteral   ::=  (decimalNumeral | hexNumeral | binaryNumeral) [‘L’ | ‘l’]\ndecimalNumeral   ::=  ‘0’ | digit [{digit | ‘_’} digit]\nhexNumeral       ::=  ‘0’ (‘x’ | ‘X’) hexDigit [{hexDigit | ‘_’} hexDigit]\nbinaryNumeral    ::=  ‘0’ (‘b’ | ‘B’) binaryDigit [{binaryDigit | ‘_’} binaryDigit]\n\nfloatingPointLiteral\n                 ::=  [decimalNumeral] ‘.’ digit [{digit | ‘_’} digit] [exponentPart] [floatType]\n                   |  decimalNumeral exponentPart [floatType]\n                   |  decimalNumeral floatType\nexponentPart     ::=  (‘E’ | ‘e’) [‘+’ | ‘-’] digit [{digit | ‘_’} digit]\nfloatType        ::=  ‘F’ | ‘f’ | ‘D’ | ‘d’\n\nbooleanLiteral   ::=  ‘true’ | ‘false’\n\ncharacterLiteral ::=  ‘'’ (charNoQuoteOrNewline | escapeSeq) ‘'’\n\nstringLiteral    ::=  ‘\"’ {stringElement} ‘\"’\n                   |  ‘\"\"\"’ multiLineChars ‘\"\"\"’\nstringElement    ::=  charNoDoubleQuoteOrNewline\n                   |  escapeSeq\nmultiLineChars   ::=  {[‘\"’] [‘\"’] charNoDoubleQuote} {‘\"’}\n\ninterpolatedString\n                 ::=  alphaid ‘\"’ {[‘\\’] interpolatedStringPart | ‘\\\\’ | ‘\\\"’} ‘\"’\n                   |  alphaid ‘\"\"\"’ {[‘\"’] [‘\"’] char \\ (‘\"’ | ‘\\$’) | escape} {‘\"’} ‘\"\"\"’\ninterpolatedStringPart\n                 ::= printableChar \\ (‘\"’ | ‘$’ | ‘\\’) | escape\nescape           ::=  ‘\\$\\$’\n                   |  ‘\\$\"’\n                   |  ‘\\$’ alphaid\n                   |  ‘\\$’ BlockExpr\n\ncomment          ::=  ‘/*’ “any sequence of characters; nested comments are allowed” ‘*/’\n                   |  ‘//’ “any sequence of characters up to end of line”\n\nnl               ::=  ´\\mathit{“new line character”}´\nsemi             ::=  ‘;’ |  nl {nl}\n```\n\n----------------------------------------\n\nTITLE: Invalid Usage of Named Type Arguments in Scala 3\nDESCRIPTION: Demonstrates incorrect attempts to use named type arguments (`T = Int`) when defining a variable's type, instantiating a class, or extending a class in Scala 3. Named type arguments are only permitted in method calls, not in these type constructor applications.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/named-typeargs-spec.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass C[T]\n\nval x: C[T = Int] = // error\n  new C[T = Int] // error\n\nclass E extends C[T = Int] // error\n```\n\n----------------------------------------\n\nTITLE: Executing @main Scala Program with Missing Arguments\nDESCRIPTION: Demonstrates the automatic argument count validation provided by the code generated from a `@main` method. If insufficient arguments are provided on the command line, the program terminates with an error message indicating the expectation. Requires a compiled `@main` program.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/main-functions.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n> scala happyBirthday 22\nIllegal command line after first argument: more arguments expected\n```\n\n----------------------------------------\n\nTITLE: Adding Printing and Reading to Predef\nDESCRIPTION: Defines standard console output methods within `scala.Predef` that delegate to `scala.Console`. These methods provide convenient access to basic printing functionality like printing values, newlines, and formatted strings.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\n  // Printing and reading -----------------------------------------------\n\n  def print(x: Any) = Console.print(x)\n  def println() = Console.println()\n  def println(x: Any) = Console.println(x)\n  def printf(text: String, xs: Any*) = Console.printf(text.format(xs: _*))\n\n  // Implicit conversions ------------------------------------------------\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Given Extension Methods with `extended with` in Scala 3\nDESCRIPTION: Shows an alternative proposed experimental syntax for defining `given` extension methods in Scala 3. This syntax uses `extended with` after the parameter list to achieve similar clarity as the `extension` keyword proposal, associating parameters directly with the extension.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ngiven listOps: [T](xs: List[T]) extended with { ... }\n\ngiven (s: String) extended with { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining Covariant Option Enum ADT in Scala\nDESCRIPTION: Defines an algebraic data type Option as an enum with covariant type parameter T, featuring two cases: Some which holds a value x of type T, and None representing the empty option. This snippet shows the concise case syntax without explicit extends clauses, where Some acts as a case class and None as a singleton case value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/adts.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nenum Option[+T]:\n  case Some(x: T)\n  case None\n```\n\n----------------------------------------\n\nTITLE: Import and Export Syntax for Givens in Scala 3 (EBNF)\nDESCRIPTION: This EBNF snippet formally specifies the grammar for import and export expressions, including the new 'given' selectors, in Scala 3. Understanding the syntax is necessary for developing tools or parsers that handle the Scala 3 import/export grammar. It defines the allowable structure of import/export clauses and selector combinations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/given-imports.md#_snippet_7\n\nLANGUAGE: EBNF\nCODE:\n```\nImport            ::=  ‘import’ ImportExpr {'’,’ ImportExpr}\nExport            ::=  ‘export’ ImportExpr {'’,’ ImportExpr}\nImportExpr        ::=  SimpleRef {'.' id} '.' ImportSpec\nImportSpec        ::=  NamedSelector\n                    |  WildcardSelector\n                    | '‘{'’ ImportSelectors) '‘}’'\nNamedSelector     ::=  id [‘as’ (id | '‘_’')]\nWildCardSelector  ::=  '‘*' | '‘given’ [InfixType]\nImportSelectors   ::=  NamedSelector [‘,’ ImportSelectors]\n                    |  WildCardSelector {‘,’ WildCardSelector}\n```\n\n----------------------------------------\n\nTITLE: Executing a Scala Program using the Java Command\nDESCRIPTION: Shows the alternative command-line syntax using the `java` command to execute a compiled Scala program (`test.HelloWorld`) in a Java environment.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/09-top-level-definitions.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\njava test.HelloWorld\n```\n\n----------------------------------------\n\nTITLE: New `=>` Syntax for Multiple Conditional Givens in Scala 3\nDESCRIPTION: Illustrates how the proposed new experimental `=>` syntax handles multiple `given` dependencies by chaining the `=>` operator. `(ctx: Context) => (ctx.Type[T]) => Zero[ctx.Expr[T]]` reads as 'a given Context and a given ctx.Type[T] implies a given Zero[ctx.Expr[T]]'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ngiven [T]: (ctx: Context) => (ctx.Type[T]) => Zero[ctx.Expr[T]]\n```\n\n----------------------------------------\n\nTITLE: BNF Grammar for Named Type Arguments in Scala 3\nDESCRIPTION: Defines the Backus-Naur Form (BNF) grammar extension for incorporating named type arguments (`NamedTypeArgs`) into Scala 3 expressions (`SimpleExpr1`). It specifies the structure of named type arguments, consisting of an identifier, an equals sign, and a type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/named-typeargs-spec.md#_snippet_0\n\nLANGUAGE: BNF\nCODE:\n```\nSimpleExpr1       ::=  ...\n                    |  SimpleExpr (TypeArgs | NamedTypeArgs)\nNamedTypeArgs     ::=  ‘[’ NamedTypeArg {‘,’ NamedTypeArg} ‘]’\nNamedTypeArg      ::=  id ‘=’ Type\n```\n\n----------------------------------------\n\nTITLE: Illustrating Problem with Direct Package Object Reference in Scala\nDESCRIPTION: This Scala code snippet demonstrates the issue addressed by the `packageObjectValues` extension. Attempting to assign a package object `a.b` directly to a value `z` results in a compilation error (\"package is not a value\") in standard Scala.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/package-object-values.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage a\npackage object b\n\nval z = a.b // Currently fails with \"package is not a value\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating Class Linearization with Inheritance Example in Scala\nDESCRIPTION: Provides a set of Scala class and trait definitions (`AbsIterator`, `RichIterator`, `StringIterator`, `Iter`) that serve as a concrete example to demonstrate and explain the concept and calculation of class linearization in Scala's complex inheritance hierarchy involving traits and classes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class AbsIterator extends AnyRef { ... }\ntrait RichIterator extends AbsIterator { ... }\nclass StringIterator extends AbsIterator { ... }\nclass Iter extends StringIterator with RichIterator { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining an Initial Method (V1) in Scala\nDESCRIPTION: Shows the initial definition (version V1) of a final method `foo` in a library. This version takes a `String` and an `Int` parameter and returns their concatenation as a `String`. It serves as the base for demonstrating binary compatibility preservation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/unrolled-defs.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// V1\nfinal def foo(\n  s: String,\n  i: Int\n): String = s + i\n```\n\n----------------------------------------\n\nTITLE: Method value syntax in Scala 3\nDESCRIPTION: Defines the syntax for creating method values (eta-expansion) in Scala 3, allowing a method or call-by-name parameter `e` to be converted into a function value of a suitable function type. The transformation depends on whether `e` is a parameterless, call-by-name, or method with parameters, enabling methods to be treated as first-class functions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_10\n\nLANGUAGE: EBNF\nCODE:\n```\nSimpleExpr    ::=  SimpleExpr1 ‘_’\n```\n\n----------------------------------------\n\nTITLE: Scala Example of Equivialent Extends With Syntax\nDESCRIPTION: A simple Scala code snippet demonstrating the older, pre-Scala 3 syntax where multiple types extended by a class (`B` and `C`) must be separated by the `with` keyword. This snippet shows the syntax that is equivalent to the newer comma-separated `extends` syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nclass A extends B with C { ... }\n```\n\n----------------------------------------\n\nTITLE: Definition of YprintPos Setting - Scala\nDESCRIPTION: Defines the 'YprintPos' compiler flag as a Boolean setting, allowing users to include tree position information in output. The flag can be enabled by passing '-Yprint-pos' to 'scalac', enhancing debugging with precise source positions attached to printed trees.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval YprintPos: Setting[Boolean] = BooleanSetting(\"-Yprint-pos\", \"show tree positions.\")\n```\n\n----------------------------------------\n\nTITLE: Decomposing Function Expression with Quoted Pattern in Scala\nDESCRIPTION: Demonstrates matching and decomposing a non-polymorphic function expression using standard quoted patterns. It extracts the function body represented by `$y` and uses it to construct a new expression. Requires `Expr` and `Quotes`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/quoted-patterns-with-polymorphic-functions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef decomposeFunc(x: Expr[Any])(using Quotes): Expr[Int] =\n  x match\n    case '{ (a: Int, b: Int) => $y(a, b) : Int } =>\n      '{ $y(0, 0) }\n    case _ => Expr(0)\n```\n\n----------------------------------------\n\nTITLE: Extension Method Resolution via Visible `given` Instance in Scala\nDESCRIPTION: Demonstrates Rule 2 for extension method resolution: a method is applicable if it's a member of a `given` instance visible at the point of reference. Here, defining `given ops1: IntOps()` makes the `safeMod` extension method (defined in `IntOps`) available for `Int` values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ngiven ops1: IntOps()  // brings safeMod into scope\n\n1.safeMod(2)\n```\n\n----------------------------------------\n\nTITLE: Embedding XML Literals in Scala\nDESCRIPTION: Demonstrates how to embed XML literals directly within Scala code. The Scala compiler handles the XML structure, and Scala expressions can be embedded within the XML using curly braces ({}). This allows for concise representation of XML fragments within code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nval b = <book>\n          <title>The Scala Language Specification</title>\n          <version>{scalaBook.version}</version>\n          <authors>{scalaBook.authors.mkList(\"\", \", \", \"\")}</authors>\n        </book>\n```\n\n----------------------------------------\n\nTITLE: Using Extractors with Quote Reflection\nDESCRIPTION: Demonstrates how to use extractors from the quotes.reflect API to analyze and pattern match on an expression's structure, along with error reporting and converting back to expressions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/reflection.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef natConstImpl(x: Expr[Int])(using Quotes): Expr[Int] =\n  import quotes.reflect.*\n  val tree: Term = x.asTerm\n  tree match\n    case Inlined(_, _, Literal(IntConstant(n))) =>\n      if n <= 0 then\n        report.error(\"Parameter must be natural number\")\n        '{0}\n      else\n        tree.asExprOf[Int]\n    case _ =>\n      report.error(\"Parameter must be a known constant\")\n      '{0}\n```\n\n----------------------------------------\n\nTITLE: Representing Context Functions with Trait in Scala\nDESCRIPTION: This Scala snippet illustrates the `ContextFunctionN` trait, which is the internal representation (shorthand) for N-ary context function types `T1, ..., TN ?=> R`. It defines an `apply` method that takes context parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions-spec.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\ntrait ContextFunctionN[-T1, ..., -TN, +R]:\n  def apply(using x1: T1, ..., xN: TN): R\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unsafe Operations with unsafeNulls in Scala 3\nDESCRIPTION: Provides examples of the unsafe operations permitted within a `scala.language.unsafeNulls` scope. This includes unsafely converting `String | Null` to `String`, calling members (`trim`, `length`) on nullable types, passing nullable types to non-nullable parameters, assigning `null` to non-nullable variables, unsafe array conversions, defining unsafe type bounds, and applying unsafe type bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: String): String = ???\ndef nullOf[T >: Null]: T = null\n\nimport scala.language.unsafeNulls\n\nval s: String | Null = ???\nval a: String = s // unsafely convert String | Null to String\n\nval b1 = s.trim // call .trim on String | Null unsafely\nval b2 = b1.length\n\nf(s).trim // pass String | Null as an argument of type String unsafely\n\nval c: String = null // Null to String\n\nval d1: Array[String] = ???\nval d2: Array[String | Null] = d1 // unsafely convert Array[String] to Array[String | Null]\nval d3: Array[String] = Array(null) // unsafe\n\nclass C[T >: Null <: String] // define a type bound with unsafe conflict bound\n\nval n = nullOf[String] // apply a type bound unsafely\n```\n\n----------------------------------------\n\nTITLE: Defining Objects without Colons in Scala 3 (Dotty 0.19)\nDESCRIPTION: Shows the simplified syntax for defining objects (and similarly classes, traits, enums) in Scala 3 (Dotty 0.19+), where the colon after the name is no longer mandatory when the body is indented.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-09-23-19th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject Bar\n  val x = 10\n\n@main def Test = println(Bar.x)  // 10\n```\n\n----------------------------------------\n\nTITLE: Expansion of Value Definitions with Single-Variable Patterns in Scala\nDESCRIPTION: Demonstrates the expansion of a Scala value definition `val p = e` when the pattern `p` binds exactly one variable `x`. The expansion simplifies to a `val` definition that assigns the result of matching `e` against `p` (extracting `x`) directly to `x`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval ´x´ = ´e´ match { case ´p´ => ´x´ }\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using Scala Boolean Match Extractor\nDESCRIPTION: Provides an example of implementing a Boolean match extractor by defining an `object` with an `unapply` method returning `Boolean`. It demonstrates how to use this extractor in a `match` expression to check a simple condition.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nobject Even:\n  def unapply(s: String): Boolean = s.size % 2 == 0\n\n\"even\" match\n  case s @ Even() => println(s\"$s has an even number of characters\")\n  case s          => println(s\"$s has an odd number of characters\")\n\n// even has an even number of characters\n```\n\n----------------------------------------\n\nTITLE: Initial Scala 3 Quote Example for Pickling\nDESCRIPTION: Demonstrates a simple Scala 3 quote containing value definitions and splices involving function calls with nested quoted arguments. This quote serves as the initial input for the pickling transformation process discussed in the text.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\n'{\n  val (x, n): (Double, Int) = (5, 2)\n  ${ powerCode('{x}, '{n}) } * ${ powerCode('{2}, '{n}) }\n}\n```\n\n----------------------------------------\n\nTITLE: Sub-pattern Matching with Value Extraction in Scala 3 Quotes\nDESCRIPTION: Demonstrates how to extract known values from quoted expressions using sub-patterns, enabling compile-time optimizations based on constant values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\ndef fusedUnrolledPowCode(x: Expr[Double], n: Int)(using Quotes): Expr[Double] =\n  x match\n    case '{ power($y, ${Expr(m)}) } => // we have (y^m)^n\n      fusedUnrolledPowCode(y, n * m) // generate code for y * ... * y\n    case _ =>                        //                  ( n*m times )\n      unrolledPowerCode(x, n)\n```\n\n----------------------------------------\n\nTITLE: Anonymous context parameter forwarding in 'maximum' function\nDESCRIPTION: Defines a maximum function that uses an anonymous context parameter of type Ord[T], which is passed down to the 'max' function. Highlights how parameter names can be omitted when the parameter is used only for inference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/using-clauses.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef maximum[T](xs: List[T])(using Ord[T]): T =\n  xs.reduceLeft(max)\n```\n\n----------------------------------------\n\nTITLE: Type-checked Pattern Binding in Scala 3\nDESCRIPTION: This code demonstrates a pattern binding where the pattern's type is more specialized than the right-hand side's type, leading to a compile-time warning in Scala 3.2. It exemplifies the rule that pattern's type must conform to the RHS type for safe deconstruction.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/pattern-bindings.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval xs: List[Any] = List(1, 2, 3)\nval (x: String) :: _ = xs\n```\n\n----------------------------------------\n\nTITLE: Creating a Record instance and casting to a structural type\nDESCRIPTION: This snippet shows how to instantiate a Record with key-value pairs and cast it to a structural type such as Person, which includes fields 'name' and 'age'. It demonstrates how to work with dynamically created records using static type assertions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval person = Record(\"name\" -> \"Emma\", \"age\" -> 42).asInstanceOf[Person]\n```\n\n----------------------------------------\n\nTITLE: Defining a Macro Function for Code Generation\nDESCRIPTION: Defines a macro function `mkPower2` using Quotes context, which generates an expression representing a power-of-two function. The macro is run via `run`, which compiles and evaluates the generated code in a new class scope using reflection.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ndef mkPower2()(using Quotes): Expr[Double => Double] = ...\n```\n\n----------------------------------------\n\nTITLE: Declaring Infix Types in Scala 3\nDESCRIPTION: Shows the use of the `infix` modifier on type aliases with exactly two type parameters, enabling infix syntax for type applications. It illustrates declaring a custom infix type and using it to declare a value, enhancing readability and consistency when working with binary type operators.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/operators.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ninfix type or[X, Y]\nval x: String or Int = ...\n```\n\n----------------------------------------\n\nTITLE: Applying Flow Typing in Match Cases for Null Checks in Scala 3\nDESCRIPTION: Demonstrates that flow typing can detect non-null cases within a pattern match. If a match case handles the `String` type specifically (or any non-null type), the variable is known to be non-null within that case's scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nval s: String | Null = ???\n\ns match\n  case _: String => // s: String\n  case _ =>\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Eq Type Class Trait\nDESCRIPTION: Defines the `Eq` type class interface in Scala, requiring implementers to provide an `eqv` method for comparing two values of the type `T`. This trait serves as the basis for automatic derivation, allowing comparison logic to be abstracted and provided contextually.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Eq[T]:\n  def eqv(x: T, y: T): Boolean\n```\n\n----------------------------------------\n\nTITLE: Adding Dotty Compiler Scripts to Shell PATH - Shell\nDESCRIPTION: Instructions for adding the 'bin' directory of a local Dotty compiler clone to the system PATH environment variable. This allows running compilation and execution commands like scalac and scala directly from the console.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/getting-started.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ export PATH=<path to cloned dotty>/bin:$PATH\n```\n\n----------------------------------------\n\nTITLE: Function Composition without Explicit Capabilities in Scala 3\nDESCRIPTION: Defines a second version of function composition `compose2` without explicit reach capabilities in the function type, demonstrating a more traditional function composition that is accepted by the type system but may not track capability information.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef compose2[A, B, C](f: A => B, g: B => C): A => C =\n  z => g(f(z))\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Object for Import Examples\nDESCRIPTION: Defines a simple Scala object named `M` containing integer value methods `z` and `one`, and an integer addition method `add`. This object serves as the source for demonstrating various import functionalities discussed in the text.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nobject M {\n  def z = 0\n  def one = 1\n  def add(x: Int, y: Int): Int = x + y\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Splice Syntax Grammar\nDESCRIPTION: Provides pseudo-BNF grammar rules for the different splice forms in Scala 3 macros: spliced identifiers (`$ident`), spliced blocks (`${ Block }`), and splice patterns (`${ Pattern }`). Explains that spliced identifiers are only valid within quoted blocks (`inQuoteBlock`) to avoid conflicts with existing Scala 2 code using `$` in identifiers. The distinction between spliced blocks and splice patterns depends on whether the surrounding context is a quote pattern (`inQuotePattern`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_2\n\nLANGUAGE: BNF\nCODE:\n```\nSimpleExpr ::= ...\n             |  `$` alphaid         if  inQuoteBlock    // spliced identifier\n             |  `$` `{` Block `}`   if !inQuotePattern  // spliced block\n             |  `$` `{` Pattern `}` if  inQuotePattern  // splice pattern\n```\n\n----------------------------------------\n\nTITLE: Rules for Determining Numeric Literal Types in Scala 3\nDESCRIPTION: This snippet explains the rules that determine the type of a numeric literal based on its suffix or context. It covers suffix conventions ('l', 'f', 'd'), expected types, and the use of FromDigits instances to convert string literals to user-defined types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Defining Collective Extension Methods Sharing a Receiver in Scala\nDESCRIPTION: Shows how to group multiple extension methods with the same extended receiver type by pulling out the parameter (e.g., ss: Seq[String]) and defining multiple methods within a block or indented scope. These methods can call each other directly with implicit receiver usage. This is shorthand for defining each method as a separate extension. Collective extensions support type parameters and using clauses.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nextension (ss: Seq[String])\n\n  def longestStrings: Seq[String] =\n    val maxLength = ss.map(_.length).max\n    ss.filter(_.length == maxLength)\n\n  def longestString: String = longestStrings.head\n```\n\n----------------------------------------\n\nTITLE: Examples of Pure Function Type Syntax in Scala 3 - Scala\nDESCRIPTION: This collection of examples shows the various pure function type syntaxes supported in Scala 3 when the experimental feature is enabled. Each form illustrates how to specify single or multi-argument pure functions, dependent pure functions, context pure functions, and call-by-name pure parameters. No additional libraries are needed beyond standard Scala 3, and these signatures are meant for documentation and codebase preparation; enforcement of purity is currently manual.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/purefuns.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n(A1, ..., An) -> B           // a multi-argument pure function\n(x1: A1, ..., xn: An) -> B   // a dependent pure function\nA ?-> B                      // a pure context function\n(A1, ..., An) ?-> B          // a multi-argument pure context function\n(x1: A1, ..., xn: An) ?-> B  // a dependent pure context function\n-> B                         // a pure call-by-name parameter\n```\n\n----------------------------------------\n\nTITLE: Example of a minimal Scala 3 main method for runtime test verification\nDESCRIPTION: Scala 3 examples of main methods used in runtime tests located in the tests/run directory. Tests require a `@main def Test` method or an object `Test` extending `scala.App` to verify runtime behaviour and outputs during test execution.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n@main def Test: Unit = assert(1 > 0)\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject Test extends scala.App:\n  assert(1 > 0)\n```\n\n----------------------------------------\n\nTITLE: Unsafe Capture Usage Example with LazyList in Scala 3\nDESCRIPTION: This snippet illustrates unsafe capture usage with `LazyList`, which is lazy and retains the capability `f` in its closure beyond the allowed scope. Capture checking issues an error because the capability escapes and may be used when invalid.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval xs = usingLogFile { f =>\n  LazyList(1, 2, 3).map { x => f.write(x); x * x }\n}\n```\n\n----------------------------------------\n\nTITLE: Contributor Statistics Output for Scala 3.5.0-RC2\nDESCRIPTION: Lists the contributors to the Scala 3.5.0-RC2 release along with their commit counts. The data shows five contributors with Hamza Remmal and Wojciech Mazur having the most commits at 4 each.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.5.0-RC2.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n     4  Hamza Remmal\n     4  Wojciech Mazur\n     3  Martin Odersky\n     1  Jamie Thompson\n     1  Guillaume Martres\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Compilation Error for Class Shadowing\nDESCRIPTION: This output shows the error message generated by the Scala 3 compiler when encountering the class shadowing pattern previously allowed in Scala 2. The error clarifies that classes cannot be overridden and requires the inner class in the subclass to be renamed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/class-shadowing.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n6 |      class Ops {  }\n  |            ^\n  |class Ops cannot have the same name as class Ops in class Base\n  | -- class definitions cannot be overridden\n```\n\n----------------------------------------\n\nTITLE: Installing and Updating Dotty Compiler Using Homebrew\nDESCRIPTION: Shows shell commands to install Dotty (Scala 3 compiler) via Homebrew package manager and update it if already installed. This simplifies Dotty setup on macOS or Linux systems supporting Homebrew.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-03-05-seventh-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nbrew install lampepfl/brew/dotty\n```\n\nLANGUAGE: shell\nCODE:\n```\nbrew upgrade dotty\n```\n\n----------------------------------------\n\nTITLE: Displaying Git Contributor Statistics for Scala 3.5.0-RC2\nDESCRIPTION: Shows the output of a git command that lists contributors and their commit counts between Scala 3.5.0-RC1 and 3.5.0-RC2 releases. The command excludes merge commits to focus on direct code contributions.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.5.0-RC2.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit shortlog -sn --no-merges 3.5.0-RC1..3.5.0-RC2\n```\n\n----------------------------------------\n\nTITLE: Declaring Binary Integer Literals in Scala\nDESCRIPTION: Demonstrates how to define an integer variable using the binary literal syntax (`0b` prefix) in Scala. Underscores (`_`) can be used as separators for improved readability. The example `0b0010_0000` represents the decimal value 32 (hex 0x20).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/binary-literals.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval bitmask = 0b0010_0000 // equivalent to 32, 0x20\n```\n\n----------------------------------------\n\nTITLE: Analyzing Export Clauses and Elaboration Order in Scala 3\nDESCRIPTION: This snippet presents an example Scala class and export clauses, raising questions about the legality and semantics of export statements. It explains the sequential steps in the elaboration of export clauses, highlighting the importance of processing order to resolve export path types and aliases correctly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nclass B { val c: Int }\nobject a { val b = new B }\nexport a.*\nexport b.*\n```\n\nLANGUAGE: Scala\nCODE:\n```\nexport b.*\nexport a.*\n```\n\n----------------------------------------\n\nTITLE: Replacing deprecated wildcard initializer with 'uninitialized' in Scala 3\nDESCRIPTION: This snippet shows the modern approach to declare an uninitialized variable using the `uninitialized` value from `scala.compiletime`, replacing the deprecated `_` syntax. It highlights the recommended import and assignment to ensure compatibility in Scala 3 projects.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/wildcard-init.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.compiletime.uninitialized\n\nvar x: A = uninitialized\n```\n\n----------------------------------------\n\nTITLE: Understanding Extension Method Translation in Scala\nDESCRIPTION: Illustrates how the Scala compiler translates an extension method definition into a regular method. The extension method `circumference` becomes a method taking the `Circle` instance as its first argument. An assertion confirms both invocation forms yield the same result.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n<extension> def circumference(c: Circle): Double = c.radius * math.Pi * 2\n\nassert(circle.circumference == circumference(circle))\n```\n\n----------------------------------------\n\nTITLE: Unsupported Flow Typing Idiom: Tracking Aliasing in Scala 3\nDESCRIPTION: Highlights an idiom not currently supported by flow typing: tracking aliasing between different paths. Even if `s != null` and `s == s2`, the compiler infers `s` as `String` but does not propagate this fact to infer `s2` is also `String` based on the equality.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nval s: String | Null = ???\nval s2: String | Null = ???\nif s != null && s == s2 then\n  // s:  String inferred\n  // s2: String not inferred\n```\n\n----------------------------------------\n\nTITLE: Implementing Functor List Instance with Extension Method in Scala\nDESCRIPTION: Provides a `given` instance for the redefined `Functor` trait (using extension methods) specifically for the `List` type constructor. The implementation of the `map` extension method still delegates to the built-in `map` method of the `List` class.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/type-classes.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Functor[List] with\n  extension [A](xs: List[A])\n    def map[B](f: A => B): List[B] =\n      xs.map(f) // List already has a `map` method\n```\n\n----------------------------------------\n\nTITLE: Handling Nullable Type Parameters from Java in Scala 3 - Java\nDESCRIPTION: This Java snippet defines a generic class where the type parameter T is always nullable. The example demonstrates how Java type parameters are interpreted as nullable within Scala 3's type system, serving as the basis for Scala's type adaptation of generics.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_9\n\nLANGUAGE: Java\nCODE:\n```\nclass C<T> { T foo() { return null; } }\n\n```\n\n----------------------------------------\n\nTITLE: Chaining Match Expressions with Braces in Scala 3\nDESCRIPTION: Demonstrates chaining two `match` expressions in Scala 3 using traditional curly braces. The result of the first match expression (`xs match { ... }`) becomes the scrutinee for the second match expression, illustrating the new operator-like precedence.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/match-syntax.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nxs match {\n  case Nil => \"empty\"\n  case _   => \"nonempty\"\n} match {\n  case \"empty\"    => 0\n  case \"nonempty\" => 1\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Scala Code Using sbt - Bash\nDESCRIPTION: Demonstrates how to launch sbt, the Scala build tool, to compile a standalone Scala file and run the compiled program. Requires the Scala source file to be located in the specified tests directory.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/getting-started.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\n> scalac tests/pos/HelloWorld.scala\n> scala HelloWorld\n```\n\n----------------------------------------\n\nTITLE: Normalized Splices in Quotes for Serialization\nDESCRIPTION: The transformation of splices in quotes into lambda expressions that capture referenced variables. This normalization is crucial for serialization as it explicitly identifies captured variables.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\n'{\\n  val (x, n): (Double, Int) = (5, 2)\\n  ${\\n    ((y: Expr[Double], m: Expr[Int]) => powerCode(y, m)).apply('x, 'n)\\n  } * ${\\n    ((m: Expr[Int]) => powerCode('{2}, m)).apply('n)\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Conflicting Type Alias in Scala\nDESCRIPTION: Shows a conflicting definition of the type alias `T` as `Int` in a different scope. Combining this with a previous definition (`type T = String`) can lead to type unsoundness if the scopes are merged, allowing invalid assignments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-02-17-scaling-dot-soundness.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntype T = Int\n```\n\n----------------------------------------\n\nTITLE: Using Wildcard Arguments in Scala Types\nDESCRIPTION: Demonstrates the new syntax for wildcard arguments in types, changing from `_` to `?`. This change aims to improve syntax consistency and aligns with Java's syntax for wildcards.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-06-11-16th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nList[?]\nMap[? <: AnyRef, ? >: Null]\n```\n\n----------------------------------------\n\nTITLE: Representing Higher-Kinded Type Classes with Lambda Types in Scala\nDESCRIPTION: This snippet shows the translation of a higher-kinded type class into a form where the type parameter F is expected to conform to a Lambda1 type. The map method signature explicitly refines F with type arguments for both source and target types, and the return type uses the #Apply projection. This pattern is needed for explicit higher-kinded type encoding in Scala 3. Dependencies: Lambda1 syntax must be in scope; key parameters are the type members and their substitutions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nclass Functor[F <: Lambda1] {\n   def map[A, B](f: A => B): F { type $hkArg$0 = A } # Apply  =>  F { type $hkArg$0 = B } # Apply\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Overloading Resolution Calls in Scala\nDESCRIPTION: Shows how different argument types affect overloading resolution when calling the `f` method defined previously. `f(b, b)` resolves to `def f(x: B, y: B)`, while `f(a, a)` resolves to `def f(x: A, y: B)` because `A` is a subtype of `B`, and the second definition is more specific for arguments of type `A`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_51\n\nLANGUAGE: Scala\nCODE:\n```\nf(b, b)\nf(a, a)\n```\n\n----------------------------------------\n\nTITLE: Defining Plugin Metadata - Properties File\nDESCRIPTION: This properties file specifies the entry point class for a Scala 3 compiler plugin by providing the fully qualified class name under the `pluginClass` key. The file must be named `plugin.properties` and placed at the root of the plugin `.jar`. This approach replaces the `scalac-plugin.xml` from earlier Scala versions, and the specified class should implement the required plugin trait.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/compiler-plugins.md#_snippet_1\n\nLANGUAGE: properties\nCODE:\n```\npluginClass=dividezero.DivideZero\n```\n\n----------------------------------------\n\nTITLE: Replacing Do-While with While Loop in Scala 3\nDESCRIPTION: Shows the recommended `while` loop structure to replace the deprecated `do-while`. The body and condition are combined within the `while` condition block, ensuring the body executes before the condition is fully evaluated in the first iteration. The empty `do ()` part signifies an empty loop body for the `while` itself.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/do-while.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nwhile ({ <body> ; <cond> }) ()\n```\n\n----------------------------------------\n\nTITLE: Scope of Experimental Definitions in Scala 3\nDESCRIPTION: This snippet illustrates the various scopes where experimental definitions can be referenced, including within the RHS of defs, vals, vars, givens, types, signatures, class and trait constructors, class bodies, annotations, inheritance hierarchies, and test frameworks. Examples show how references are restricted or permitted based on whether they are marked as experimental, emphasizing the scope rules and constraints.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/experimental-defs.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.experimental\n\n@experimental\ndef x = ()\n\n@experimental\nval x = ()\n\n@experimental\ndef f() = ()\n\n@experimental\nobject X:\n  def fx() = 1\n\ndef test1: Unit =\n  f() // error: def f is marked @experimental and therefore ...\n  x // error: value x is marked @experimental and therefore ...\n  X.fx() // error: object X is marked @experimental and therefore ...\n  import X.fx\n  fx() // error: object X is marked @experimental and therefore ...\n\n@experimental\ndef test2: Unit =\n  // references to f, x and X are ok because `test2` is experimental\n  f()\n  x\n  X.fx()\n  import X.fx\n  fx()\n\n// Definitions with experimental scope in signatures and constructors\n@experimental\ndef x = 2\n\n@experimental\nclass A\n@experimental\ntype X\n@experimental\ntype Y = Int\n@experimental\nopaque type Z = Int\n\ndef test1(\n  p1: A, // error: class A is marked @experimental and therefore ...\n  p2: List[A], // error: class A is marked @experimental and therefore ...\n  p3: X, // error: type X is marked @experimental and therefore ...\n  p4: Y, // error: type Y is marked @experimental and therefore ...\n  p5: Z, // error: type Z is marked @experimental and therefore ...\n  p6: Any = x // error: def x is marked @experimental and therefore ...\n): A = ??? // error: class A is marked @experimental and therefore ...\n\n@experimental\ndef test2(\n  p1: A,\n  p2: List[A],\n  p3: X,\n  p4: Y,\n  p5: Z,\n  p6: Any = x\n): A = ???\n\nclass Test1(\n  p1: A, // error\n  p2: List[A], // error\n  p3: X, // error\n  p4: Y, // error\n  p5: Z, // error\n  p6: Any = x // error\n) {}\n\n@experimental class Test2(\n  p1: A,\n  p2: List[A],\n  p3: X,\n  p4: Y,\n  p5: Z,\n  p6: Any = x\n) {}\n\ntrait Test1(\n  p1: A, // error\n  p2: List[A], // error\n  p3: X, // error\n  p4: Y, // error\n  p5: Z, // error\n  p6: Any = x // error\n) {}\n\n@experimental trait Test2(\n  p1: A,\n  p2: List[A],\n  p3: X,\n  p4: Y,\n  p5: Z,\n  p6: Any = x\n) {}\n\n// Inheritance scope examples\n@experimental\ndef x = 2\n\n@experimental\nclass A1(x: Any)\nclass A2(x: Any)\n\n@experimental\nclass B1 extends A1(1)\nclass B2 extends A1(1) // error: class A1 is marked @experimental and therefore marked @experimental and therefore ...\n\n@experimental\nclass C1 extends A2(x)\nclass C2 extends A2(x) // error def x is marked @experimental and therefore ...\n\n// Body scope examples\n@experimental\ndef x = 2\n\n@experimental\nclass A {\n  def f = x // ok because A is experimental\n}\n\n@experimental\nclass B {\n  def f = x // ok because B is experimental\n}\n\n@experimental object C {\n  def f = x // ok because C is experimental\n}\n\n@experimental\nclass D {\n  def f = {\n    object B {\n      x // ok because D is experimental\n    }\n  }\n}\n\n// Annotation scope example\n@experimental\nclass myExperimentalAnnot extends scala.annotation.Annotation\n\n@myExperimentalAnnot // error\n def test: Unit = ()\n\n@experimental\n@myExperimentalAnnot\n def test: Unit = ()\n```\n\n----------------------------------------\n\nTITLE: Abstract Table Class Implementing Map-Like Behavior in Scala\nDESCRIPTION: This snippet defines an abstract generic class modeling a map from keys to values. It declares abstract `get` and `set` methods for retrieving and adding entries, and defines an `apply` method returning a default value if the key is absent. The default value is supplied via the constructor parameter `defaultValue`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Table[A, B](defaultValue: B) {\n  def get(key: A): Option[B]\n  def set(key: A, value: B): Unit\n  def apply(key: A) = get(key) match {\n    case Some(value) => value\n    case None => defaultValue\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Given Extension Methods with `extension` Keyword in Scala 3\nDESCRIPTION: Presents one proposed experimental syntax for defining `given` instances that provide extension methods in Scala 3. This syntax uses the `extension` keyword explicitly after the optional name and before the parameter list (`[T](xs: List[T])` or `(s: String)`) to clarify that these parameters belong to the extension method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-12-20-21th-dotty-milestone-release.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ngiven listOps: extension [T](xs: List[T]) { ... }\n\ngiven extension (s: String) { ... }\n```\n\n----------------------------------------\n\nTITLE: Expansion of Declarations with Erased Classes in Scala\nDESCRIPTION: Displays the expanded forms (after Scala 3's type-checking rewriting) of vals, defs, and givens referencing erased classes. The compiler automatically inserts 'erased' to declarations whose type is, or depends on, an erased class. Highlights implicit conversion from syntactic to macro-erased signatures.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nerased class CanRead\n\nerased val x: CanRead = ...\nval y: (erased CanRead) => Int = ...\ndef f(erased x: CanRead) = ...\nerased def g(): CanRead = ...\nerased given CanRead = ...\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Variant: Using Colon `:` to Indicate Argument Blocks\nDESCRIPTION: Describes an optional syntax variant that recognizes a colon `:` as a marker for argument blocks, allowing indentation to substitute braces without restricting function argument syntax. Enabled by importing `fewerBraces`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nimport language.experimental.fewerBraces\n\n// Example usage:\ntimes(10):\n  println(\"ah\")\n  println(\"ha\")\n\n// Lambda with colon:\nxs.map:\n  x =>\n    val y = x - 1\n    y * y\n\n// Fold example:\nxs.foldLeft(0): (x, y) =>\n  x + y\n```\n\n----------------------------------------\n\nTITLE: Recursive Match Type with Bounds for Tuple Concatenation\nDESCRIPTION: This snippet introduces a recursive match type `Concat[Xs <: Tuple, +Ys <: Tuple]` with an upper bound `Tuple`, enabling concatenation of tuples at the type level. It illustrates how bounds facilitate recursive definitions ensuring the resulting type remains within a specific upper bound. The pattern matching on `EmptyTuple` and `x *: xs` demonstrates a common pattern for list-like recursion in type-level programming.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/new-types/match-types.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntype Concat[Xs <: Tuple, +Ys <: Tuple] <: Tuple = Xs match\n  case EmptyTuple => Ys\n  case x *: xs => x *: Concat[xs, Ys]\n```\n\n----------------------------------------\n\nTITLE: Subtyping Checks in Scala 3\nDESCRIPTION: This code snippet describes the `topLevelSubType` function used for subtype checking between two types in Scala 3, facilitating type comparison during compilation. It helps determine if one type is a subtype of another based on the internal type representations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/type-system.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntopLevelSubType(tp1, tp2) // Checks if tp1 is a subtype of tp2 in Scala 3 compiler\n```\n\n----------------------------------------\n\nTITLE: Encoding Wildcard Types Using Partial Instantiation of Type Members\nDESCRIPTION: Shows that wildcard type parameters omit instantiations for certain type members, effectively leaving them abstract. Demonstrates encoding wildcards and bounded wildcards by partially instantiating type members with bounds or concrete types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nMap[_, Int]\n```\n\nLANGUAGE: scala\nCODE:\n```\nMap { type Map$V = Int }\n```\n\nLANGUAGE: scala\nCODE:\n```\nMap[_ <: AnyRef, Int]\n```\n\nLANGUAGE: scala\nCODE:\n```\nMap { type Map$K <: AnyRef; type Map$V = Int }\n```\n\n----------------------------------------\n\nTITLE: Importing Implied Instances Separately from Normal Imports\nDESCRIPTION: Demonstrates how to import implied instances specifically using 'import implied ...' versus normal 'import' statements. This distinction controls scope and visibility of implied versus normal members.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nobject A {\n  class TC\n  implied tc for TC\n  def f given TC = ???\n}\nobject B {\n  import A._         // normal import clause\n  import implied A._ // implied import clause\n}\n```\n\n----------------------------------------\n\nTITLE: XML Attributes and Character Data in EBNF\nDESCRIPTION: Grammar definition for XML attributes, attribute values and character data in Scala. This includes rules for embedding Scala expressions within XML attributes and content.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/10-xml-expressions-and-patterns.md#_snippet_2\n\nLANGUAGE: EBNF\nCODE:\n```\nAttribute  ::=    Name Eq AttValue\n\nAttValue      ::=    '\"' {CharQ | CharRef} '\"'\n                |    ''' {CharA | CharRef} '''\n                |    ScalaExpr\n\nScalaExpr     ::=    Block\n\nCharData      ::=   { CharNoRef } ´\\textit{ without}´ {CharNoRef}'{' CharB {CharNoRef}\n                                  ´\\textit{ and without}´ {CharNoRef}']]>'{CharNoRef}\n```\n\n----------------------------------------\n\nTITLE: Defining an Implicit Conversion Alias from String to Token in Scala\nDESCRIPTION: Illustrates a more concise syntax for defining the same implicit conversion from String to Token by assigning a new KeyWord instance created from the input string to a given Conversion instance. This style uses an anonymous function as the conversion implementation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/conversions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ngiven Conversion[String, Token] = new KeyWord(_)\n```\n\n----------------------------------------\n\nTITLE: Creating a TASTy Inspector Project with sbt Template\nDESCRIPTION: Shows the sbt command using `sbt new` to generate a project structure from the official `scala/scala3-tasty-inspector.g8` template. This provides a convenient starting point for developing TASTy-based tools.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/tasty-inspect.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nsbt new scala/scala3-tasty-inspector.g8\n```\n\n----------------------------------------\n\nTITLE: Defining Type Alias for Reflexive Equality (Scala 3)\nDESCRIPTION: Defines a type alias `Eq[-T]` that serves as a shorthand for `CanEqual[T, T]`. This alias represents reflexive equality for a single type and is primarily useful in scenarios where `-language:strictEquality` is enabled and universal equality instances are not available.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ntype Eq[-T] = CanEqual[T, T]\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Grammar Extensions for Colon Argument Syntax\nDESCRIPTION: Defines how the grammar accommodates colon `:` as an alternative to braces for function arguments and lambda parameters, allowing indentation to be used for argument blocks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nSimpleExpr       ::=  ... |  SimpleExpr ColonArgument\nInfixExpr        ::=  ... |  InfixExpr id ColonArgument\nColonArgument    ::=  colon [LambdaStart]\nLambdaStart      ::=  FunParams (‘=>’ | ‘?=>’)\n                   |  HkTypeParamClause ‘=>’\n```\n\n----------------------------------------\n\nTITLE: Defining a Procedure Function with an Explicit Unit Return Type in Scala\nDESCRIPTION: Presents a Scala 3-compliant function declaration with an explicit return type Unit. This form makes the function's side-effect-only intent clear. It is supported in both Scala 2 and 3. No input parameters or dependencies are required.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/procedure-syntax.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(): Unit = { ... }\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Unpickling: Evaluating Splice Hole Lambda\nDESCRIPTION: Shows the conceptual code evaluation during unpickling to compute the content of a splice hole. The original splice lambda is applied to quoted versions of the hole's arguments, typically executed via reflection.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\n((y: Expr[Double], m: Expr[Int]) => powerCode(y, m)).apply('x, 'n)\n```\n\n----------------------------------------\n\nTITLE: Defining Designator Expression Grammar (EBNF)\nDESCRIPTION: Provides EBNF rules for 'SimpleExpr' forms related to designators: a 'Path' or a 'SimpleExpr' followed by a dot and an identifier. These rules define how named values and member selections are represented in the grammar as basic expression forms.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_2\n\nLANGUAGE: ebnf\nCODE:\n```\nSimpleExpr  ::=  Path\n              |  SimpleExpr ‘.’ id\n```\n\n----------------------------------------\n\nTITLE: Declaring List of Tuples (Scala)\nDESCRIPTION: Declares a variable `xs` as a `List` containing tuples of two `Int` elements. This serves as the input data structure for subsequent examples demonstrating parameter untupling, representing a common scenario where this feature is useful.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/parameter-untupling.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval xs: List[(Int, Int)]\n```\n\n----------------------------------------\n\nTITLE: Updated Macro Parameter Syntax in Scala 3\nDESCRIPTION: New syntax for handling inline parameters in macro implementations, showing that inline parameters must now be quoted when passed to a macro.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-02-05-22nd-dotty-milestone-release.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ninline def power(x: Double, inline n: Int) = ${ powerCode('x, 'n) }\nprivate def powerCode(x: Expr[Double], n: Expr[Int])(given QuoteContext): Expr[Double] = ???\n```\n\n----------------------------------------\n\nTITLE: Defining the Plugin Class in `plugin.properties` (Properties)\nDESCRIPTION: Illustrates the content of the `plugin.properties` file required in the root of a Scala 3 compiler plugin JAR. This file specifies the fully qualified name of the main plugin class using the `pluginClass` property. This format replaces the `scalac-plugin.xml` used in Scala 2.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/compiler-plugins.md#_snippet_1\n\nLANGUAGE: properties\nCODE:\n```\npluginClass=dividezero.DivideZero\n```\n\n----------------------------------------\n\nTITLE: Chaining Match Expressions with Indentation in Scala 3\nDESCRIPTION: Illustrates chaining two `match` expressions in Scala 3 using the new indentation-based syntax, omitting the optional braces. This shows an alternative way to write chained matches, consistent with Scala 3's syntax flexibility.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/match-syntax.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nxs match\n  case Nil => \"empty\"\n  case _   => \"nonempty\"\nmatch\n  case \"empty\" => 0\n  case \"nonempty\" => 1\n```\n\n----------------------------------------\n\nTITLE: Running Code within a Transaction in Scala\nDESCRIPTION: Defines a `transaction` method that takes a function `op` as a parameter. It creates a new `Transaction` instance, executes the provided function `op` with the transaction object, and then attempts to commit the transaction.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n  def transaction[T](op: Transaction => T) = {\n    val trans: Transaction = new Transaction\n    op(trans)\n    trans.commit()\n  }\n```\n\n----------------------------------------\n\nTITLE: Import Statement for Experimental Numeric Literals in Scala 3\nDESCRIPTION: This snippet shows how to enable experimental numeric literals in Scala 3 by importing the relevant language feature. Necessary for using user-defined numeric literals, this import must be present in the code that utilizes such literals.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.experimental.genericNumberLiterals\n```\n\n----------------------------------------\n\nTITLE: Demonstrating unsafe usage of the try-with-resources pattern\nDESCRIPTION: An example showing how the unmodified usingLogFile method can be misused by capturing the file resource in a closure and using it after the file has been closed, leading to a runtime crash.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval later = usingLogFile { file => () => file.write(0) }\nlater() // crash\n```\n\n----------------------------------------\n\nTITLE: Encoding Java-Style Inner Classes with Type Projection in Scala\nDESCRIPTION: These code snippets illustrate Java's inner class pattern and how it is represented in Scala via type projection using the '#' operator. The classes Outer, Sub1, and Sub2 demonstrate how inner class types can be projected out of an outer class, leading to types like Outer#Inner, Sub1#Inner, and Sub2#Inner. The examples provide context for design decisions around the '#' operator in Scala's type system; no dependencies or special input/output requirements exist beyond basic class syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nclass Outer { class Inner }\nclass Sub1 extends Outer\nclass Sub2 extends Outer\n```\n\n----------------------------------------\n\nTITLE: State Machine Implementation Using erasedValue and Inline in Scala\nDESCRIPTION: Alternative implementation of a state machine using the erasedValue function and inline matches for compile-time state validation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.*\n\nsealed trait State\nfinal class On extends State\nfinal class Off extends State\n\nclass Machine[S <: State]:\n  transparent inline def turnOn(): Machine[On] =\n    inline erasedValue[S] match\n      case _: Off => new Machine[On]\n      case _: On  => error(\"Turning on an already turned on machine\")\n\n  transparent inline def turnOff(): Machine[Off] =\n    inline erasedValue[S] match\n      case _: On  => new Machine[Off]\n      case _: Off => error(\"Turning off an already turned off machine\")\n\nobject Machine:\n  def newMachine(): Machine[Off] =\n    println(\"newMachine\")\n    new Machine[Off]\nend Machine\n\n@main def test =\n  val m = Machine.newMachine()\n  m.turnOn()\n  m.turnOn().turnOff()\n  m.turnOn().turnOn() // error: Turning on an already turned on machine\n```\n\n----------------------------------------\n\nTITLE: Accessing Enum Ordinal Scala (REPL)\nDESCRIPTION: Demonstrates accessing the integer ordinal value associated with an enum case using the built-in `ordinal` method in the Scala REPL.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val red = Color.Red\nval red: Color = Red\nscala> red.ordinal\nval res0: Int = 0\n```\n\n----------------------------------------\n\nTITLE: Valid Template Body Using Optional Braces with Colon and Indented Statements - Scala\nDESCRIPTION: Demonstrates usage of a colon ':' followed by an indented block to specify class, trait, object, enum, or package template bodies without braces, per Scala 3's optional braces syntax. No dependency other than Scala 3 compiler supporting optional braces. Shows multiple valid constructs replacing traditional brace-enclosed bodies with an indentation based syntax that is syntactically equivalent.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait A:\n  def f: Int\n\nclass C(x: Int) extends A:\n  def f = x\n\nobject O:\n  def f = 3\n\nenum Color:\n  case Red, Green, Blue\n\nnew A:\n  def f = 3\n\npackage p:\n  def a = 1\n\npackage q:\n  def b = 2\n```\n\n----------------------------------------\n\nTITLE: Defining Collective Extension Methods (Indented Syntax) in Scala\nDESCRIPTION: Illustrates how to group multiple extension methods (`longestStrings`, `longestString`) that apply to the same type (`Seq[String]`) under a single `extension` definition using indentation. This syntax avoids repeating the `extension (ss: Seq[String])` part.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nextension (ss: Seq[String])\n\n  def longestStrings: Seq[String] =\n    val maxLength = ss.map(_.length).max\n    ss.filter(_.length == maxLength)\n\n  def longestString: String = longestStrings.head\n```\n\n----------------------------------------\n\nTITLE: Current Scala 3 Pattern Matching Syntax (M3)\nDESCRIPTION: This snippet shows the standard Scala 2 syntax using the '@' symbol to bind a variable to the matched pattern, which is the accepted syntax in Scala 3.0.0-M3 after reverting the change from M2.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-12-18-scala3-m3.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase opt @ Some(foo)\n```\n\n----------------------------------------\n\nTITLE: Comparing Scala and Java Call Styles\nDESCRIPTION: Contrasts the explicit `()` needed for Java method calls with the idiomatic Scala style of omitting `()` for parameterless accessors (Uniform Access Principle). Scala 3 permits the latter style when calling methods defined in Java or Scala 2.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/auto-apply.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nxs.toString().length()\n\n```\n\nLANGUAGE: Scala\nCODE:\n```\nxs.toString.length\n```\n\n----------------------------------------\n\nTITLE: Calling an Extension Method on a Scala Instance\nDESCRIPTION: Demonstrates how to instantiate a Circle object and invoke the defined extension method \"circumference\" via normal dot notation. Input is a Circle instance positioned at the origin with radius 1, output is the computed circumference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/extension-methods.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval circle = Circle(0, 0, 1)\ncircle.circumference\n```\n\n----------------------------------------\n\nTITLE: Compilation options for capture checking in Scala3\nDESCRIPTION: Lists compiler options that influence capture type inference and debugging during capture checking, such as printing inferred types and detailed diagnostics. These options are used with the Scala3 compiler to support capture checking in the current development branch.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_37\n\nLANGUAGE: Scala\nCODE:\n```\n-Xprint:cc\n-Ycc-debug\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with a Context Bound in Scala\nDESCRIPTION: Demonstrates the use of a context bound `: Ord` on a type parameter `T` as a shorthand for requiring a context parameter `using Ord[T]`. This function finds the maximum element in a list, requiring an implicit `Ord` instance for the element type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-bounds.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef maximum[T: Ord](xs: List[T]): T = xs.reduceLeft(max)\n```\n\n----------------------------------------\n\nTITLE: Deprecated Vararg Splice Syntax in Scala 3\nDESCRIPTION: Shows the old vararg splice syntax that will be phased out in Scala 3. The first line demonstrates a syntax error with the old splice argument style, while the second shows the alternative pattern matching syntax that is still supported.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/vararg-splices.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n/*!*/ val lst = List(arr: _*)      // syntax error\n      lst match\n        case List(0, 1, xs @ _*)  // ok, equivalent to `xs*`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Default Infix Operator Behavior in Scala 3\nDESCRIPTION: Shows how symbolic methods like '+' are allowed to be used in infix position by default in Scala 3, using a case class with a custom '+' method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-05-23-15th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Foo(x: Int) { def +(other: Foo) = x + other.x }\nFoo(1) + Foo(2)\n```\n\n----------------------------------------\n\nTITLE: Creating Lazy Lists with Tabulate Method in Scala\nDESCRIPTION: Method to create a lazy list of given length using a generator function, which may have side effects. The capture annotation indicates the lazy list captures the generator.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\ndef tabulate[A](n: Int)(gen: Int => A) =\n  def recur(i: Int): {gen} LzyList[A] =\n    if i == n then LzyNil\n    else gen(i) #: recur(i + 1)\n  recur(0)\n```\n\n----------------------------------------\n\nTITLE: Listing Contributors with Git Command in Shell\nDESCRIPTION: A shell command that uses git shortlog to display the number of commits by each contributor between the 3.2.2-RC1 and 3.2.2-RC2 tags, excluding merge commits.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.2.2-RC2.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit shortlog -sn --no-merges 3.2.2-RC1..3.2.2-RC2\n```\n\n----------------------------------------\n\nTITLE: Throwing Exception Evaluation Example - Scala 3 Debug Test - Plaintext\nDESCRIPTION: This snippet provides an example of evaluating an expression that throws an exception during a debug test. The thrown exception is returned as a result rather than an error, illustrating the custom handling of debugger outcomes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_14\n\nLANGUAGE: plaintext\nCODE:\n```\neval throw new Exception(\"foo\")\nresult java.lang.Exception: foo\n```\n\n----------------------------------------\n\nTITLE: Basic Quote Pattern Matching in Scala 3\nDESCRIPTION: Implements a function that analyzes quoted code to detect and optimize nested power operations by fusing exponents.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\ndef fusedPowCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] =\n  x match\n    case '{ power($y, $m) } => // we have (y^m)^n\n      fusedPowCode(y, '{ $n * $m }) // generate code for y^(n*m)\n    case _ =>\n      '{ power($x, $n) }\n```\n\n----------------------------------------\n\nTITLE: Simplified assertTransformation with extension method\nDESCRIPTION: Rewrites the `assertTransformation` function to invoke `map` directly on `original`, leveraging extension methods defined in the `Functor` type class. This results in cleaner, more natural usage.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/type-classes.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef assertTransformation[F[_]: Functor, A, B](expected: F[B], original: F[A], mapping: A => B): Unit =\n  assert(expected == original.map(mapping))\n```\n\n----------------------------------------\n\nTITLE: Defining a polymorphic method in Scala 3\nDESCRIPTION: Defines a generic method `foo` that accepts a list of elements of type `A` and returns the reversed list. It demonstrates how to write a method with a type parameter, which is essential for creating polymorphic functions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/polymorphic-function-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef foo[A](xs: List[A]): List[A] = xs.reverse\n```\n\n----------------------------------------\n\nTITLE: Applying Escape Checking to Shared Capabilities in Scala\nDESCRIPTION: Shows that the same separation checking rules preventing capability escape apply equally to shared capabilities (`File^{shared}`). Even with shared access, capabilities cannot be leaked outside their designated scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef withFile[T](body: File^{shared} => T): T =\n```\n\n----------------------------------------\n\nTITLE: QuoteUnpickler Usage for Expression Reconstruction\nDESCRIPTION: Final step in unpickling where the QuoteUnpickler reconstructs the quoted expression from the pickled TASTy data, type information, and hole handlers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nquotes.asInstanceOf[runtime.QuoteUnpickler].unpickleExpr[T](\\n  pickled = tasty\"...\",\\n  types = Seq(...),\\n  holes = (idx: Int, args: Seq[Any]) => idx match ...\\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Dotty via Homebrew on macOS\nDESCRIPTION: Installs the Dotty compiler using the Homebrew package manager on macOS. This command adds the necessary tap (lampepfl/brew) if not already present and installs the 'dotty' package. Requires Homebrew to be installed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-09-07-third-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nbrew install lampepfl/brew/dotty\n```\n\n----------------------------------------\n\nTITLE: Contributor Statistics for Dotty 0.4.0-RC1\nDESCRIPTION: Git shortlog showing the number of commits per contributor between versions 0.3.0-RC2 and 0.4.0-RC1.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-10-16-fourth-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n   226  Martin Odersky\n   112  Felix Mulder\n   104  Nicolas Stucki\n    41  Allan Renucci\n    41  Guillaume Martres\n    33  liu fengyun\n     8  Olivier Blanvillain\n     4  Aggelos Biboudis\n     3  Dmitry Petrashko\n     2  Raymond Tay\n     2  esarbe\n     2  Enno Runne\n     1  Brandon Elam Barker\n     1  Raphael Bosshard\n     1  Jacob J\n     1  Aleksander Boruch-Gruszecki\n     1  Jim Van Horn\n     1  Matthias Sperl\n     1  Michal Gutowski\n```\n\n----------------------------------------\n\nTITLE: Printing Tree Structure in Scala 3 Reflection\nDESCRIPTION: Shows how to print the structure of a reflected AST using the TreeStructure printer, which helps identify which extractors are needed for pattern matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/reflection.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntree.show(using Printer.TreeStructure)\n// or\nPrinter.TreeStructure.show(tree)\n```\n\n----------------------------------------\n\nTITLE: Listing Default Transparent Types in Scala Standard Library\nDESCRIPTION: This listing provides a reference of classes and traits automatically treated as transparent in Scala 3. It is for documentation and does not serve as executable code. Contains names of built-in types; no inputs or outputs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/transparent-traits.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n    scala.Any\n    scala.AnyVal\n    scala.Matchable\n    scala.Product\n    java.lang.Object\n    java.lang.Comparable\n    java.io.Serializable\n```\n\n----------------------------------------\n\nTITLE: Literal Type Inference for Inline Vals in Scala\nDESCRIPTION: Shows that the type of an `inline val` initialized with a literal constant expression is inferred as the literal type itself. For example, `inline val four = 4` is equivalent to explicitly stating `inline val four: 4 = 4`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ninline val four = 4\n// equivalent to\ninline val four: 4 = 4\n```\n\n----------------------------------------\n\nTITLE: Syntax Definition for Pattern Alternatives (EBNF)\nDESCRIPTION: Defines the EBNF syntax for pattern alternatives. Multiple patterns (`Pattern1`) can be combined using the pipe symbol (`|`) to indicate that a match occurs if any of the alternatives match.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_19\n\nLANGUAGE: ebnf\nCODE:\n```\n  Pattern   ::=  Pattern1 { ‘|’ Pattern1 }\n```\n\n----------------------------------------\n\nTITLE: Defining Enum with Members Scala\nDESCRIPTION: Illustrates adding user-defined fields and methods directly within the enum definition in Scala 3. This example adds physical properties and calculation methods to a `Planet` enum.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nenum Planet(mass: Double, radius: Double):\n  private final val G = 6.67300E-11\n  def surfaceGravity = G * mass / (radius * radius)\n  def surfaceWeight(otherMass: Double) = otherMass * surfaceGravity\n\n  case Mercury extends Planet(3.303e+23, 2.4397e6)\n  case Venus   extends Planet(4.869e+24, 6.0518e6)\n  case Earth   extends Planet(5.976e+24, 6.37814e6)\n  case Mars    extends Planet(6.421e+23, 3.3972e6)\n  case Jupiter extends Planet(1.9e+27,   7.1492e7)\n  case Saturn  extends Planet(5.688e+26, 6.0268e7)\n  case Uranus  extends Planet(8.686e+25, 2.5559e7)\n  case Neptune extends Planet(1.024e+26, 2.4746e7)\nend Planet\n```\n\n----------------------------------------\n\nTITLE: Unsupported Alias Tracking for Nullable Variable Paths in Scala\nDESCRIPTION: This code demonstrates the unsupported idiom of tracking nullability through aliasing of different nullable variables in Scala 3. While 's' and 's2' both have type 'String | Null', the condition 'if s != null && s == s2' refines only 's' to 'String', but not 's2'. Dependencies: basic null check and value equality. Inputs: two nullable Strings; output: only 's' is type-refined. Alias analysis and path-sensitive tracking are not supported for non-local variables.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_29\n\nLANGUAGE: Scala\nCODE:\n```\nval s: String | Null = ???\nval s2: String | Null = ???\nif s != null && s == s2 then\n  // s:  String inferred\n  // s2: String not inferred\n```\n\n----------------------------------------\n\nTITLE: Generating Scala Documentation Using sbt - Bash\nDESCRIPTION: Command sequence to generate static Scala documentation pages from the project sources by running the dedicated sbt scaladoc task. Assumes sbt environment is properly set up.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/getting-started.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\n> scaladoc/generateScalaDocumentation\n```\n\n----------------------------------------\n\nTITLE: Example of Effect Polymorphism with Pure Functions in Scala\nDESCRIPTION: Example showing how capture checking provides effect polymorphism - pure functions used with map don't appear in the capture set of the result.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nval xs = squares(10)\nval ys: {xs} LzyList[Int] = xs.map(_ + 1)\n```\n\n----------------------------------------\n\nTITLE: Using the 'App' Trait in Scala 3 (Simple Example)\nDESCRIPTION: Demonstrates using the `scala.App` trait to create a simple main program in Scala 3. Although `DelayedInit`'s special handling is dropped, `App` still works for basic cases by executing the code within the object's initializer. However, this approach might lead to interpretation on some JVMs (impacting performance) and prohibits direct command-line argument access within the `App` body.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/delayed-init.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject HelloWorld extends App {\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Synthesizing By-Name Context Parameter Argument (Step 3)\nDESCRIPTION: Shows the final step of argument synthesis for by-name context parameters. If the inferred argument expression `E` refers back to the conceptually created local `given lv` (indicating recursion), the compiler wraps the expression in a block `{ given lv: T = E; lv }` to define and use the local given. Otherwise, if `E` does not reference `lv`, it is returned unchanged.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/by-name-context-parameters.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n{\n  given lv: T = E;\n  lv\n}\n```\n\n----------------------------------------\n\nTITLE: Shapeless-based Scala Eq Derivation Example\nDESCRIPTION: Demonstrates an alternative approach to implementing type class derivation in Scala using the Shapeless library. It defines `given` instances (`eqSum`, `eqProduct`) tailored for Shapeless's generic representations (`K0.CoproductInstances`, `K0.ProductInstances`) and then defines an `inline derived` method that delegates the derivation logic to Shapeless's `gen.derive` method. Requires the Shapeless library and its specific types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\ngiven eqSum: [A] => (inst: => K0.CoproductInstances[Eq, A]) => Eq[A]:\n  def eqv(x: A, y: A): Boolean = inst.fold2(x, y)(false)(\n    [t] => (eqt: Eq[t], t0: t, t1: t) => eqt.eqv(t0, t1)\n  )\n\ngiven eqProduct: [A] => (inst: => K0.ProductInstances[Eq, A]) => Eq[A]:\n  def eqv(x: A, y: Any): Boolean = inst.foldLeft2(x, y)(true: Boolean)(\n    [t] => (acc: Boolean, eqt: Eq[t], t0: t, t1: t) =>\n      Complete(!eqt.eqv(t0, t1))(false)(true)\n  )\n\ninline def derived[A](using gen: K0.Generic[A]): Eq[A] = \n  gen.derive(eqProduct, eqSum)\n```\n\n----------------------------------------\n\nTITLE: Deprecating Enum Case (Diff) Scala\nDESCRIPTION: Shows a diff illustrating the addition of the `@deprecated` annotation to an enum case (`Pluto`) to mark it as deprecated.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\ndiff\n enum Planet(mass: Double, radius: Double):\n   ...\n   case Neptune extends Planet(1.024e+26, 2.4746e7)\n-  case Pluto   extends Planet(1.309e+22, 1.1883e3)\n+\n+  @deprecated(\"refer to IAU definition of planet\")\n+  case Pluto extends Planet(1.309e+22, 1.1883e3)\n end Planet\n```\n\n----------------------------------------\n\nTITLE: Using inline modifier in Scala 3\nDESCRIPTION: The inline modifier guarantees that a definition will be inlined at the point of use, reducing function call overhead. It's executed during the Typer compiler phase and is a command rather than a request to the compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/metaprogramming.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ninline def example() = { /* implementation */ }\n```\n\n----------------------------------------\n\nTITLE: Implementing Builder Pattern Classes in Scala\nDESCRIPTION: Definition of Table, Row, and Cell classes that will be used in the builder pattern implementation, with methods for adding elements.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n  class Table:\n    val rows = new ArrayBuffer[Row]\n    def add(r: Row): Unit = rows += r\n    override def toString = rows.mkString(\"Table(\", \", \", \")\")\n\n  class Row:\n    val cells = new ArrayBuffer[Cell]\n    def add(c: Cell): Unit = cells += c\n    override def toString = cells.mkString(\"Row(\", \", \", \")\")\n\n  case class Cell(elem: String)\n```\n\n----------------------------------------\n\nTITLE: Calling an Inline Logging Method in Scala\nDESCRIPTION: Illustrates a recursive `factorial` function calling the `Logger.log` inline method. This setup is used to demonstrate the effects of inlining in subsequent examples based on the `Config.logging` value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/inline.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nvar indentSetting = 2\n\ndef factorial(n: BigInt): BigInt =\n  log(s\"factorial($n)\", indentSetting) {\n    if n == 0 then 1\n    else n * factorial(n - 1)\n  }\n```\n\n----------------------------------------\n\nTITLE: Splice Transformation to Holes for Pickling\nDESCRIPTION: Example showing how a splice is replaced with a hole during the pickling process. Holes contain an index, type information, and references to the argument variables.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\n  ${ ((y: Expr[Double], m: Expr[Int]) => powerCode(y, m)).apply('x, 'n) }\\n// becomes\\n  << 0; Double; x, n >>\n```\n\n----------------------------------------\n\nTITLE: Defining Annotations Syntax in EBNF\nDESCRIPTION: Specifies the syntax rules for annotations in Scala using EBNF notation. Defines an annotation as starting with '@' followed by a simple type and optional argument expressions, supporting annotations on definitions, types, and expressions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/11-annotations.md#_snippet_0\n\nLANGUAGE: EBNF\nCODE:\n```\nAnnotation       ::=  ‘@’ SimpleType {ArgumentExprs}\nConstrAnnotation ::=  ‘@’ SimpleType ArgumentExprs\n```\n\n----------------------------------------\n\nTITLE: New Context Parameters Syntax in Scala 3\nDESCRIPTION: Updated syntax for context parameters in Scala 3, using 'using' keyword instead of 'given' for context argument groups and for explicitly specifying context parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-02-05-22nd-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ngiven String = \"10\"\ngiven (using str: String) as Int = str.toInt\ndef f(x: Int)(using y: Int) = x * y\n```\n\n----------------------------------------\n\nTITLE: Creating Staged Classes with Quotes in Scala 3\nDESCRIPTION: Creates a new Runnable implementation at compile-time, allowing for custom generated code that utilizes values available during macro expansion.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\ndef mkRunnable(x: Int)(using Quotes): Expr[Runnable] = '{\n  class MyRunnable extends Runnable:\n    def run(): Unit = ... // generate some custom code that uses `x`\n  new MyRunnable\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the nn Extension Method for Null Safety in Scala 3\nDESCRIPTION: This utility extension method casts away nullability from a union type. It performs a runtime assertion to verify the value is not null, then returns it as the non-nullable type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nextension [T](x: T | Null)\n  inline def nn: T =\n    assert(x != null)\n    x.asInstanceOf[T]\n```\n\n----------------------------------------\n\nTITLE: Defining an Extension Method in Scala 3 - Scala\nDESCRIPTION: Defines an extension method 'circumference' for Circle instances directly in Scala 3 using the extension keyword. Requires math.Pi, Circle class with radius member. Adds circumference as an additional method to Circle.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n```\n\n----------------------------------------\n\nTITLE: Encoding Parameterized Classes as Type Members in Scala\nDESCRIPTION: Demonstrates the equivalence between a parameterized Scala class and a class using refined type members with name mangling to avoid conflicts. Shows how type instances instantiate these type members with concrete types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/higher-kinded-v2.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Map[K, V]\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Map { type Map$K; type Map$V }\n```\n\nLANGUAGE: scala\nCODE:\n```\nMap { type Map$K = String; type Map$V = Int }\n```\n\n----------------------------------------\n\nTITLE: Implicit Lazy Value and Def in Scala 2 - Scala\nDESCRIPTION: Simulates Scala 3 alias givens using a lazy val and an implicit def in Scala 2. Requires ExecutionContext and Context variables. Provides implicit resolution for global and ctx, matching their Scala 3 counterparts.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nfinal implicit lazy val global: ExecutionContext = new ForkJoinContext()\nfinal implicit def given_Context = ctx\n```\n\n----------------------------------------\n\nTITLE: Defining a package object in Scala\nDESCRIPTION: Represents the old syntax for package objects, which have been deprecated in favor of top-level definitions. It shows a package object with a val and a def, illustrating the previous way of grouping package-wide definitions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/dropped-features/package-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage object p {\n  val a = ...\n  def b = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring Methods Using Transactional Type\nDESCRIPTION: Example of refactoring methods to use the Transactional type alias, eliminating explicit implicit parameter sections.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n  def f1(x: Int): Transactional[Int] = {\n    thisTransaction.println(s\"first step: $x\")\n    f2(x + 1)\n  }\n  def f2(x: Int): Transactional[Int] = {\n    thisTransaction.println(s\"second step: $x\")\n    f3(x * x)\n  }\n  def f3(x: Int): Transactional[Int] = {\n    thisTransaction.println(s\"third step: $x\")\n    if (x % 2 != 0) thisTransaction.abort()\n    x\n  }\n```\n\n----------------------------------------\n\nTITLE: Generated Main Method Implementation in Scala\nDESCRIPTION: Example of a generated main method for a method annotated with @myMain. It shows how arguments are processed, validated, and passed to the original method using the MainAnnotation framework.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/main-annotation.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject foo {\n  def main(args: Array[String]): Unit = {\n    val mainAnnot = new myMain()\n    val info = new Info(\n      name = \"foo.main\",\n      documentation = \"Sum all the numbers\",\n      parameters = Seq(\n        new Parameter(\"first\", \"scala.Int\", hasDefault=false, isVarargs=false, \"Fist number to sum\", Seq()),\n        new Parameter(\"second\", \"scala.Int\", hasDefault=true, isVarargs=false, \"\", Seq()),\n        new Parameter(\"rest\", \"scala.Int\" , hasDefault=false, isVarargs=true, \"The rest of the numbers to sum\", Seq())\n      )\n    )\n    val mainArgsOpt = mainAnnot.command(info, args)\n    if mainArgsOpt.isDefined then\n      val mainArgs = mainArgsOpt.get\n      val args0 = mainAnnot.argGetter[Int](info.parameters(0), mainArgs(0), None) // using a parser of Int\n      val args1 = mainAnnot.argGetter[Int](info.parameters(1), mainArgs(1), Some(() => sum$default$1())) // using a parser of Int\n      val args2 = mainAnnot.varargGetter[Int](info.parameters(2), mainArgs.drop(2)) // using a parser of Int\n      mainAnnot.run(() => sum(args0(), args1(), args2()*))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Capture Set Dependencies Debug Output Example\nDESCRIPTION: Example output from the -Ycc-debug option showing capture set variable dependencies, including empty variables, mappings, and fixed supersets.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\nCapture set dependencies:\n  {}2V                 ::\n  {}3V                 ::\n  {}4V                 ::\n  {f, xs}5V            :: {f, xs}31M5V, {f, xs}32M5V\n  {f, xs}31M5V         :: {xs, f}\n  {f, xs}32M5V         ::\n```\n\n----------------------------------------\n\nTITLE: Mapping List of Tuples with Pattern Matching (Scala)\nDESCRIPTION: Demonstrates the traditional Scala 2 approach to mapping over a list of tuples using pattern matching within a lambda function. Each tuple `(x, y)` is explicitly destructured before the `x + y` operation is applied.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/parameter-untupling.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nxs map {\n  case (x, y) => x + y\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for Lazy List Operations in Scala\nDESCRIPTION: Implementation of common operations (map, filter, concat, drop) for lazy lists with appropriate capture annotations to track capabilities through transformations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\nextension [A](xs: {*} LzyList[A])\n  def map[B](f: A => B): {xs, f} LzyList[B] =\n    if xs.isEmpty then LzyNil\n    else f(xs.head) #: xs.tail.map(f)\n\n  def filter(p: A => Boolean): {xs, p} LzyList[A] =\n    if xs.isEmpty then LzyNil\n    else if p(xs.head) then xs.head #: xs.tail.filter(p)\n    else xs.tail.filter(p)\n\n  def concat(ys: {*} LzyList[A]): {xs, ys} LzyList[A] =\n    if xs.isEmpty then ys\n    else xs.head #: xs.tail.concat(ys)\n\n  def drop(n: Int): {xs} LzyList[A] =\n    if n == 0 then xs else xs.tail.drop(n - 1)\n```\n\n----------------------------------------\n\nTITLE: Declaring Nullable Types Using Union Types in Scala\nDESCRIPTION: Shows the correct way to declare a variable that can hold a reference type (like `String`) or `null` when explicit nulls are enabled. This is done using a union type `| Null`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/explicit-nulls.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval x: String | Null = null // ok\n```\n\n----------------------------------------\n\nTITLE: Compiled Result of Inline Parameters in Scala 3\nDESCRIPTION: The compiled result of the sumTwice function call, showing how by-name parameters are bound to definitions instead of being inlined.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-02-05-22nd-dotty-milestone-release.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval a = f()\ndef b = g()\na + a + b + b + h() + h()\n```\n\n----------------------------------------\n\nTITLE: Defining Collective Extension Methods (Brace Syntax) in Scala\nDESCRIPTION: Shows the equivalent way to define collective extension methods using braces `{}` instead of pure indentation to group the methods (`longestStrings`, `longestString`) for the target type (`Seq[String]`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nextension (ss: Seq[String]) {\n\n  def longestStrings: Seq[String] = {\n    val maxLength = ss.map(_.length).max\n    ss.filter(_.length == maxLength)\n  }\n\n  def longestString: String = longestStrings.head\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Magnet Pattern with Scala given Conversions for Completions\nDESCRIPTION: Shows a complex example where implicit conversions are used to implement the magnet pattern to handle multiple argument types in a single method. It defines an enum CompletionArg with cases representing different argument types and provides given conversions from various input types (String, Future[HttpResponse], Future[StatusCode]) to CompletionArg. This pattern helps avoid combinatorial overloads and supports implicit transformation of different argument types to a unified magnet argument handled by the complete method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/conversions.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject Completions:\n\n  // The argument \"magnet\" type\n  enum CompletionArg:\n    case Error(s: String)\n    case Response(f: Future[HttpResponse])\n    case Status(code: Future[StatusCode])\n\n  object CompletionArg:\n\n    // conversions defining the possible arguments to pass to `complete`\n    // these always come with CompletionArg\n    // They can be invoked explicitly, e.g.\n    //\n    //   CompletionArg.fromStatusCode(statusCode)\n\n    given fromString    : Conversion[String, CompletionArg]               = Error(_)\n    given fromFuture    : Conversion[Future[HttpResponse], CompletionArg] = Response(_)\n    given fromStatusCode: Conversion[Future[StatusCode], CompletionArg]   = Status(_)\n  end CompletionArg\n  import CompletionArg.*\n\n  def complete[T](arg: CompletionArg) = arg match\n    case Error(s) => ...\n    case Response(f) => ...\n    case Status(code) => ...\n\nend Completions\n```\n\n----------------------------------------\n\nTITLE: Chaining Match Expressions without Braces in Scala\nDESCRIPTION: This example shows how match expressions can be chained in Scala 3 using the optional braces-free syntax. It performs the same operation as the previous example but with more concise syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/match-syntax.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nxs match\n  case Nil => \"empty\"\n  case _   => \"nonempty\"\nmatch\n  case \"empty\" => 0\n  case \"nonempty\" => 1\n```\n\n----------------------------------------\n\nTITLE: Setting up a Dotty Project with sbt\nDESCRIPTION: Uses the 'sbt new' command with the 'lampepfl/dotty.g8' giter8 template to scaffold a new sbt project configured to use the Dotty compiler. Requires sbt version 0.13.13 or newer to be installed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-09-07-third-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nsbt new lampepfl/dotty.g8\n```\n\n----------------------------------------\n\nTITLE: Defining a Large BigFloat Literal in Scala\nDESCRIPTION: Demonstrates the syntax for defining a `BigFloat` literal using scientific notation. This specific example represents a number potentially too large for standard handling, leading to runtime errors without compile-time checks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n1e10_0000_000_000: BigFloat\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Extension Method in Scala\nDESCRIPTION: Demonstrates the basic syntax for defining an extension method `circumference` for an existing `Circle` case class. The extension method takes the `Circle` instance `c` as a parameter and calculates its circumference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Circle(x: Double, y: Double, radius: Double)\n\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n```\n\n----------------------------------------\n\nTITLE: Scala 2 Inconsistent Nullary Definition\nDESCRIPTION: Presents an example from the Scala 2 library (`scala.math.Numeric`) showing a nullary method defined with `()`, highlighting the type of inconsistency that led Scala 3 to introduce compatibility exceptions for calls to Scala 2 overrides.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/auto-apply.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef toInt(): Int\n```\n\n----------------------------------------\n\nTITLE: Installing Dotty on macOS via Homebrew (Shell)\nDESCRIPTION: Installs the Dotty (Scala 3) compiler on macOS using the Homebrew package manager. It utilizes the `lampepfl/brew` tap to fetch the Dotty package. This is intended for first-time installations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nbrew install lampepfl/brew/dotty\n```\n\n----------------------------------------\n\nTITLE: Running compilation tests on bootstrapped Dotty compiler with sbt\nDESCRIPTION: Command to run compilation tests using the bootstrapped Dotty compiler. This target is used for tests that require the bootstrapped compiler stage and includes tests with the `with-compiler` tag.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nscala3-compiler-bootstrapped/testCompilation\n```\n\n----------------------------------------\n\nTITLE: Basic Method to Function Conversion in Scala 3\nDESCRIPTION: Demonstrates how a method with parameters is automatically converted to a function value when assigned to a val, without requiring the underscore syntax that was needed in Scala 2.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/eta-expansion-spec.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef m(x: Int, y: String) = ???\nval f = m // becomes: val f = (x: Int, y: String) => m(x, y)\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion Function in Scala 2 - Scala\nDESCRIPTION: Defines an implicit conversion from String to Token in Scala 2 using an implicit def, allowing automatic conversion where needed. Requires Token and Keyword classes. Input is a String, output is a new Keyword token.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def stringToToken(str: String): Token = new Keyword(str)\n```\n\n----------------------------------------\n\nTITLE: Using 'the' for Context Queries\nDESCRIPTION: Depicts the use of the synonym 'the' to summon implied instances, streamlining code that retrieves context information. For example, 'the[Ord[List[Int]]]' explicitly requests an implied 'Ord' instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-03-05-13th-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nthe[Ord[List[Int]]]\n```\n\n----------------------------------------\n\nTITLE: Quoted Type Pattern Matching in Scala 3\nDESCRIPTION: Demonstrates how to match on quoted types to generate type-specific code, using type variables to extract and reuse type information.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\ndef empty[T: Type](using Quotes): Expr[T] =\n  Type.of[T] match\n    case '[String] => '{ \"\" }\n    case '[List[t]] => '{ List.empty[t] }\n    case '[type t <: Option[Int]; List[t]] => '{ List.empty[t] }\n    ...\n```\n\n----------------------------------------\n\nTITLE: Annotations on Experimental Definitions in Scala 3\nDESCRIPTION: Demonstrates that annotations of an experimental definition are within experimental scopes. Using an experimental annotation class on non-experimental definitions causes errors, but using it on experimental definitions is allowed, enforcing experimental context propagation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/experimental-defs.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.experimental\n\n@experimental class myExperimentalAnnot extends scala.annotation.Annotation\n\n@myExperimentalAnnot // error\ndef test: Unit = ()\n\n@experimental\n@myExperimentalAnnot\ndef test: Unit = ()\n```\n\n----------------------------------------\n\nTITLE: Synthesizing Name for Anonymous Parameterized Given Instance (Scala 3)\nDESCRIPTION: Shows the compiler-synthesized name `given_Ord_List` for an anonymous parameterized given instance implementing `Ord[List]` in Scala 3. This illustrates the default naming convention for more complex anonymous given instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ngiven given_Ord_List: [T] => (ord: Ord[T]) => Ord[List[T]] { ... }\n```\n\n----------------------------------------\n\nTITLE: Cloning Scala 3 Repository Using Git - Bash\nDESCRIPTION: Shows the commands to clone the Scala 3 source code repository using git and navigate into the project directory. Assumes git is installed and configured in the system environment.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/getting-started.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/scala/scala3.git\n$ cd scala3\n```\n\n----------------------------------------\n\nTITLE: Escaping double-quotes in Scala 3 string interpolations\nDESCRIPTION: Example demonstrating how to use the $ meta character to escape double-quote characters within a string interpolation in Scala 3, allowing quotes to be embedded directly in the interpolated string.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/interpolation-escapes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n  val inventor = \"Thomas Edison\"\n  val interpolation = s\"as $inventor said: $\"The three great essentials to achieve anything worth while are: Hard work, Stick-to-itiveness, and Common sense.$\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating CanEqual Instances for Cross-Type Comparisons\nDESCRIPTION: Shows how to set up CanEqual instances to allow two different types (A and B) to be comparable with each other but not with other types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ngiven CanEqual[A, A] = CanEqual.derived\ngiven CanEqual[B, B] = CanEqual.derived\ngiven CanEqual[A, B] = CanEqual.derived\ngiven CanEqual[B, A] = CanEqual.derived\n```\n\n----------------------------------------\n\nTITLE: Example of Implicit Parameter Declaration Syntax (Scala)\nDESCRIPTION: Highlights the syntax pattern `(implicit thisTransaction: Transaction)` used repeatedly in the example functions (`f1`, `f2`, `f3`) to declare an implicit parameter. This syntax is presented as the source of boilerplate.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n(implicit thisTransaction: Transaction)\n```\n\n----------------------------------------\n\nTITLE: EBNF Syntax for Scala String Literals\nDESCRIPTION: This snippet describes the structure of string literals in Scala as sequences of characters inside double quotes, excluding unescaped double quotes or newline characters, with escape sequences allowed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_14\n\nLANGUAGE: EBNF\nCODE:\n```\nstringLiteral  ::=  ‘\"’ {stringElement} ‘\"’\nstringElement  ::=  charNoDoubleQuoteOrNewline | escapeSeq\n```\n\n----------------------------------------\n\nTITLE: Defining Skolem Type Syntax in Scala 3 EBNF\nDESCRIPTION: EBNF syntax definition for Skolem types in Scala 3. Skolem types cannot be directly written in concrete syntax and are exclusively used temporarily during subtyping derivations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_34\n\nLANGUAGE: EBNF\nCODE:\n```\nSkolemType  ::=  '∃' skolemid ':' Type\n```\n\n----------------------------------------\n\nTITLE: Initializing Scala 3 Macro Compiler with Class Loader\nDESCRIPTION: Sets up an instance of the staging compiler using the application's class loader, necessary for macro code generation and code loading during runtime with proper dependency context.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.quoted.staging.*\ngiven Compiler = Compiler.make(getClass.getClassLoader)\n```\n\n----------------------------------------\n\nTITLE: Builder Pattern Expansion with Context Functions\nDESCRIPTION: Shows how the compiler expands the table construction code with context functions, demonstrating the implicit parameter passing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n  table { ($t: Table) ?=>\n\n    row { ($r: Row) ?=>\n      cell(\"top left\")(using $r)\n      cell(\"top right\")(using $r)\n    }(using $t)\n\n    row { ($r: Row) ?=>\n      cell(\"bottom left\")(using $r)\n      cell(\"bottom right\")(using $r)\n    }(using $t)\n  }\n```\n\n----------------------------------------\n\nTITLE: Complex Type Parameter Inference with Method Type Parameters in Scala\nDESCRIPTION: Demonstrates inference involving method type parameters where the constraint Number <: Term[B] leads to B being inferred as Int, allowing the pattern match to type-check correctly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nclass Term[A]\nclass Number(val n: Int) extends Term[Int]\ndef f[B](t: Term[B]): B = t match {\n  case y: Number => y.n\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Example of Match Expression with Indentation Rules\nDESCRIPTION: Provides an example of a `match` expression where case clauses are not indented, demonstrating the indentation rule application.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/indentation.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nx match\ncase 1 => print(\"I\")\ncase 2 => print(\"II\")\ncase 3 => print(\"III\")\ncase 4 => print(\"IV\")\ncase 5 => print(\"V\")\n\nprintln(\".\")\n```\n\n----------------------------------------\n\nTITLE: CanEqual Trait and Companion Object Definition\nDESCRIPTION: Shows the core definition of the CanEqual trait and its companion object, which includes the derived value that can be used to create instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\nimport annotation.implicitNotFound\n\n@implicitNotFound(\"Values of types ${L} and ${R} cannot be compared with == or !=\")\nsealed trait CanEqual[-L, -R]\n\nobject CanEqual:\n  object derived extends CanEqual[Any, Any]\n```\n\n----------------------------------------\n\nTITLE: Defining an implicit conversion from Int to java.lang.Integer in Scala\nDESCRIPTION: This example from scala.Predef demonstrates how to define an implicit conversion method that converts a Scala Int to a Java Integer. This enables passing Scala Int values to Java methods that expect java.lang.Integer objects.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-conversions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.implicitConversions\nimplicit def int2Integer(x: Int): java.lang.Integer =\n  x.asInstanceOf[java.lang.Integer]\n```\n\n----------------------------------------\n\nTITLE: Defining Nullary Method in Scala 3\nDESCRIPTION: This snippet defines a simple nullary method `next` that takes an empty parameter list `()`. This type of method is specifically excluded from Scala 3's automatic eta expansion when simply referenced without parentheses.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/eta-expansion.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef next(): T\n```\n\n----------------------------------------\n\nTITLE: Defining Type Member with Inconsistent Bounds in Scala\nDESCRIPTION: Illustrates the definition of a type member `T` with contradictory bounds (`Any <: T <: Nothing`). This setup, where `T` must be a supertype of `Any` and a subtype of `Nothing` simultaneously, is impossible to satisfy and is used as a basis for demonstrating soundness exploits.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-02-17-scaling-dot-soundness.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nAny <: T <: Nothing\n```\n\n----------------------------------------\n\nTITLE: Extension methods for map, filter, concat, and drop on effectful lazy lists in Scala 3\nDESCRIPTION: These extension methods enable functional transformations on `LzyList` with effect tracking. `map` applies a function to each element, capturing both the list and the function; `filter` retains elements satisfying a predicate; `concat` joins two lazy lists; `drop` discards the first `n` elements. They respect effect annotations ensuring effects are correctly propagated and captured after each operation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_32\n\nLANGUAGE: Scala\nCODE:\n```\nextension [A](xs: LzyList[A]^)\n  def map[B](f: A => B): LzyList[B]^{xs, f} =\n    if xs.isEmpty then LzyNil\n    else f(xs.head) #: xs.tail.map(f)\n\n  def filter(p: A => Boolean): LzyList[A]^{xs, p} =\n    if xs.isEmpty then LzyNil\n    else if p(xs.head) then xs.head #: xs.tail.filter(p)\n    else xs.tail.filter(p)\n\n  def concat(ys: LzyList[A]^): LzyList[A]^{xs, ys} =\n    if xs.isEmpty then ys\n    else xs.head #: xs.tail.concat(ys)\n\n  def drop(n: Int): LzyList[A]^{xs} =\n    if n == 0 then xs else xs.tail.drop(n - 1)\n```\n\n----------------------------------------\n\nTITLE: Tracing Variable Assignments in Scala Compiler Code\nDESCRIPTION: This Scala snippet demonstrates a technique to track assignments to a specific variable (e.g., `myInfo` of type `Type`) within the compiler's codebase. It involves renaming the original variable (e.g., to `myInfo_debug`), creating a getter (`myInfo`), a setter (`myInfo_=`), and a `tracer` string variable. The custom setter intercepts assignments, records the current stack trace into the `tracer` variable, and then performs the actual assignment, allowing developers to identify where and when the variable's value was last modified.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/issues/cause.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nvar tracer = \"\",\ndef myInfo: Type = myInfo_debug,\ndef myInfo_=(x: Type) = { tracer = Thread.currentThread.getStackTrace.mkString(\"\\n\"); myInfo_debug = x }\n```\n\n----------------------------------------\n\nTITLE: Chaining Match Expressions in Scala\nDESCRIPTION: This example demonstrates how match expressions can be chained in Scala 3. The first match checks if a list is empty, returning a string, and the second match uses that string to return a numeric value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/match-syntax.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nxs match {\n  case Nil => \"empty\"\n  case _   => \"nonempty\"\n} match {\n  case \"empty\"    => 0\n  case \"nonempty\" => 1\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Unsoundness with Null Prefix Values in Scala\nDESCRIPTION: Demonstrates how initializing a value `p` of type `S` to `null` prevents runtime checks for the bounds of its type member `T` when used in a type selection `p.T`. Since `p` is not initialized via `new`, the consistency of `T`'s bounds is not verified, creating a potential soundness loophole.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-02-17-scaling-dot-soundness.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval p: S = null\n... p.T ...\n```\n\n----------------------------------------\n\nTITLE: Defining the Record class with selectDynamic method\nDESCRIPTION: This snippet defines the Record class implementing the Selectable trait, allowing dynamic member selection via selectDynamic. It facilitates representing generic records with string keys and any type of value, enabling flexible object-like access with type casting.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Record(elems: (String, Any)*) extends Selectable:\n  private val fields = elems.toMap\n  def selectDynamic(name: String): Any = fields(name)\n```\n\n----------------------------------------\n\nTITLE: Expressing Do-While Loop with Parenthesized While in Scala\nDESCRIPTION: This snippet shows how to replicate the behavior of the deprecated 'do-while' loop by embedding the loop body and condition inside a single 'while' statement using braces and parentheses. It requires Scala 3 syntax and highlights the migration path from 'do-while' to 'while' for maintaining equivalent control flow. The block inside the parentheses executes the body, then evaluates the condition for repetition; no additional dependencies are needed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/do-while.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nwhile ({ <body> ; <cond> }) ()\n```\n\n----------------------------------------\n\nTITLE: Name Clash via @targetName in Inheritance Hierarchies (Scala)\nDESCRIPTION: This Scala code demonstrates a compiler error where a method in a subclass is defined with a @targetName that clashes with an inherited method's erased name. Class 'A' defines method 'f'; subclass 'B' defines a method named 'g' but assigns the target name 'f' using @targetName. The result is a compile-time error due to the name clash in the generated code, as both methods have the same signature and erased name after applying @targetName, even though their Scala source names differ.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/targetName.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport annotation.targetName\nclass A:\n  def f(): Int = 1\nclass B extends A:\n  @targetName(\"f\") def g(): Int = 2\n```\n\n----------------------------------------\n\nTITLE: Compiler Expansion Parameterized Enum Case Scala\nDESCRIPTION: Shows the compiler's internal representation for a parameterized enum case (`Venus`), which is expanded into an anonymous class instance inheriting from the enum class.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval Venus: Planet = new Planet(4.869E24, 6051800.0):\n  def ordinal: Int = 1\n  override def productPrefix: String = \"Venus\"\n  override def toString: String = \"Venus\"\n```\n\n----------------------------------------\n\nTITLE: Mapping Tuples using Pattern Matching in Scala (Pre-Scala 3)\nDESCRIPTION: Demonstrates the traditional way to map a list of tuples (`xs`) to their sums before Scala 3. It uses pattern matching within a `map` operation to decompose each tuple.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nxs map {\n  case (x, y) => x + y\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Tree Structure\nDESCRIPTION: Shows how to use the Printer.TreeStructure module to get a string representation of a tree's structure, which helps in identifying which extractors are needed for pattern matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/reflection.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntree.show(using Printer.TreeStructure)\n// or\nPrinter.TreeStructure.show(tree)\n```\n\n----------------------------------------\n\nTITLE: Replacement for Do-While Loops\nDESCRIPTION: Alternative approach to achieve do-while functionality using a regular while loop with a block expression.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval iterator = Iterator.from(10, -1)\n\n@main def test = {\n  var x: Int = 0\n  while ({\n    x = iterator.next\n    println(x)\n    x > 0\n  }) ()\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Implicit Parameter Declaration Syntax (Scala)\nDESCRIPTION: Another example of implicit parameter syntax `(implicit ctx: Context)` used frequently in the Dotty compiler codebase, further illustrating the boilerplate issue associated with this declaration pattern.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n(implicit ctx: Context)\n```\n\n----------------------------------------\n\nTITLE: Implementing Transaction Management with Implicit Functions\nDESCRIPTION: Methods for transaction management that utilize implicit function types to simplify the API and reduce boilerplate.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\n  def transaction[T](op: Transactional[T]) = {\n    implicit val trans: Transaction = new Transaction\n    op\n    trans.commit()\n  }\n  def main(args: Array[String]) = {\n    transaction {\n      val res = f1(args.length)\n      println(if (thisTransaction.isAborted) \"aborted\" else s\"result: $res\")\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Using ValDef.let for Variable Binding\nDESCRIPTION: Shows the type signatures of ValDef.let and ValDef.lets methods that allow binding right-hand sides to vals and using them in a body expression.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/reflection.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef let(rhs: Term)(body: Ident => Term): Term = ...\n\ndef lets(terms: List[Term])(body: List[Term] => Term): Term = ...\n```\n\n----------------------------------------\n\nTITLE: Creating a Class with Exposed Context Parameters in Scala\nDESCRIPTION: Defines a class 'GivenIntBox' that exposes its context parameter as a member by using the 'val' modifier, making it accessible from outside.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass GivenIntBox(using val usingParameter: Int):\n  def myInt = summon[Int]\n\nval b = GivenIntBox(using 23)\nimport b.usingParameter\nsummon[Int]  // 23\n```\n\n----------------------------------------\n\nTITLE: Listing Contributors to Scala 3.0.1-RC2 using Git\nDESCRIPTION: Output of git shortlog command showing the contributors who made the 3.0.1-RC2 release possible, listing them by number of commits.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2021-06-25-scala301-rc2.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n     3  Guillaume Martres\n     2  Krzysztof Romanowski\n     1  Anatolii Kmetiuk\n     1  Markus Sutter\n     1  Martin Odersky\n     1  Vadim Chelyshov\n```\n\n----------------------------------------\n\nTITLE: Preventing unintended implicit conversions in Scala 3\nDESCRIPTION: Example demonstrating how Scala 3 prevents surprising behavior by restricting which implicit values can be used as conversions. Map values will no longer be used as implicit conversions, unlike in Scala 2.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-conversions-spec.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimplicit val m: Map[Int, String] = Map(1 -> \"abc\")\n\nval x: String = 1  // Scala 2: assigns \"abc\" to x\n                   // Scala 3: type error\n```\n\n----------------------------------------\n\nTITLE: EBNF Syntax for Scala Character Literals\nDESCRIPTION: This snippet specifies the syntax of character literals in Scala, requiring a single character or escape sequence enclosed by single quote delimiters, excluding unescaped quotes or newline characters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_13\n\nLANGUAGE: EBNF\nCODE:\n```\ncharacterLiteral  ::=  ‘'’ (charNoQuoteOrNewline | escapeSeq) ‘'’\n```\n\n----------------------------------------\n\nTITLE: Current Scala 3 Context Function Syntax (M3)\nDESCRIPTION: This code shows the current syntax for defining a context function closure in Scala 3.0.0-M3 using the '?=>' symbol, reverting to an earlier syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-12-18-scala3-m3.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n(s: Show[String]) ?=> s.show(\"foobar\")\n```\n\n----------------------------------------\n\nTITLE: Defining Fixed-Arity Scala Extractor Signature (unapply)\nDESCRIPTION: Specifies the signature for the `unapply` method used in fixed-arity extractors. The return type `U` determines the type of match (Boolean, Product, or isEmpty/get based).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef unapply[A](x: T)(implicit x: B): U\n```\n\n----------------------------------------\n\nTITLE: Combining Subtype and Context Bounds in Scala\nDESCRIPTION: Demonstrates the syntax for applying both a subtype bound (`<: B`) and a context bound (`: C`) to a single type parameter `T`. Subtype bounds must precede context bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-bounds.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef g[T <: B : C](x: T): R = ...\n```\n\n----------------------------------------\n\nTITLE: Attempting List contains with covariant parameter (Scala)\nDESCRIPTION: Presents a seemingly intuitive, but incorrect, definition for `contains` that attempts to use the list's covariant type parameter `T` directly. This definition is invalid because it uses the covariant parameter `T` in a nonvariant position (as an input parameter type), violating Scala's variance rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n  def contains(x: T): Boolean\n```\n\n----------------------------------------\n\nTITLE: List of Contributors for Scala 3.5.0-RC6\nDESCRIPTION: Output of git shortlog command showing contributors who made commits between 3.5.0-RC5 and 3.5.0-RC6, listing Wojciech Mazur with 4 contributions.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.5.0-RC6.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n     4  Wojciech Mazur\n```\n\n----------------------------------------\n\nTITLE: Method Overriding Error in Scala 3\nDESCRIPTION: Demonstrates how Scala 3 enforces strict parameter list matching when overriding methods, showing the error when a nullary method tries to override a parameterless method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/auto-apply.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass A:\n  def next(): Int\n\nclass B extends A:\n  def next: Int // overriding error: incompatible type\n```\n\n----------------------------------------\n\nTITLE: Scalar Product Example Using Pattern Matching Anonymous Function\nDESCRIPTION: A practical example showing how to compute the scalar product of two arrays using foldLeft with a pattern matching anonymous function for concise destructuring of tuples.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\ndef scalarProduct(xs: Array[Double], ys: Array[Double]) =\n  (xs zip ys).foldLeft(0.0) {\n    case (a, (b, c)) => a + b * c\n  }\n```\n\n----------------------------------------\n\nTITLE: Object Export with Wildcard Selector in Scala\nDESCRIPTION: Example showing how to export all eligible members from an object using a wildcard selector, generating type and method definitions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/export.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject O:\n  class C(val x: Int)\n  def m(c: C): Int = c.x + 1\nexport O.*\n  // generates\n  //   type C = O.C\n  //   def m(c: O.C): Int = O.m(c)\n```\n\n----------------------------------------\n\nTITLE: Example of using the deprecated App trait in Scala\nDESCRIPTION: A simple Scala object extending App to create a 'Hello, world!' program. Demonstrates the traditional approach affected by the removal of DelayedInit.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/delayed-init.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject HelloWorld extends App {\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Ambiguity with Context Parameters in Classes in Scala\nDESCRIPTION: Demonstrates an ambiguous situation where both a context parameter and an explicit given member match the same type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass GivenIntBox2(using usingParameter: Int):\n  given givenMember: Int = usingParameter\n  def n = summon[Int]  // ambiguous given instances: both usingParameter and givenMember match type Int\n```\n\n----------------------------------------\n\nTITLE: Well-formed Type Parameter Clauses in Scala 3\nDESCRIPTION: Examples of valid type parameter clauses showing various combinations of type parameters with variance annotations and bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\n[S, T]\n[@specialized T, U]\n[Ex <: Throwable]\n[A <: Comparable[B], B <: A]\n[A, B >: A, C >: A <: B]\n[M[X], N[X]]\n[M[_], N[_]] // equivalent to previous clause\n[M[X <: Bound[X]], Bound[_]]\n[M[+X] <: Iterable[X]]\n```\n\n----------------------------------------\n\nTITLE: EBNF Grammar for Scala Package Object Definition\nDESCRIPTION: Defines the Extended Backus-Naur Form (EBNF) grammar for a Scala package object (`PackageObject`), which uses the `package object` keywords followed by a standard object definition (`ObjectDef`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/09-top-level-definitions.md#_snippet_4\n\nLANGUAGE: EBNF\nCODE:\n```\nPackageObject   ::=  ‘package’ ‘object’ ObjectDef\n```\n\n----------------------------------------\n\nTITLE: Do-While Loop Example in Scala 2\nDESCRIPTION: Example of the do-while syntax that is being removed in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nscala> var x = 0\nx: Int = 0\n\nscala> val iterator = Iterator.from(10, -1)\niterator: Iterator[Int] = <iterator>\n\nscala> do {\n     |   x = iterator.next()\n     |   println(x)\n     | } while (x > 0)\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Match Types in Scala 3\nDESCRIPTION: Demonstrates how to define a basic match type that resolves to different types depending on the input type. The example shows the Elem type that extracts the element type from containers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/match-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Elem[X] = X match\n  case String => Char\n  case Array[t] => t\n  case Iterable[t] => t\n```\n\n----------------------------------------\n\nTITLE: Invoking an Extension Method in Scala\nDESCRIPTION: Shows how to call the defined `circumference` extension method on an instance of the `Circle` class using standard infix dot notation, just like a regular method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval circle = Circle(0, 0, 1)\ncircle.circumference\n```\n\n----------------------------------------\n\nTITLE: Setting Current Directory Classpath in Scala Build Configuration\nDESCRIPTION: This configuration directive sets the classpath to the current directory, indicated by the dot symbol. This is commonly used in build systems to specify where the compiler should look for classes.\nSOURCE: https://github.com/scala/scala3/blob/main/compiler/test-coursier/run/myargs.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-classpath .\n```\n\n----------------------------------------\n\nTITLE: Creating New sbt Project with Dotty (Shell)\nDESCRIPTION: Provides the sbt command to quickly set up a new project pre-configured to use Dotty as the Scala compiler. This command uses an sbt template (`lampepfl/dotty.g8`) to generate the project structure and build file, simplifying the process of starting a new Dotty project with sbt.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-12-01-fifth-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nsbt new lampepfl/dotty.g8\n```\n\n----------------------------------------\n\nTITLE: Displaying Scala 3 Compiler Package Structure in Scala\nDESCRIPTION: This Scala code snippet outlines the internal file and package structure of the Scala 3 compiler, highlighting how components are organized in the `dotty.tools` package and its submodules. There are no executable statements; instead, it uses comments and ASCII-art to visually document the compiler's architecture. Its purpose is to inform developers about where to find specific functionalities within the codebase. No dependencies are required, and the snippet only expects to be used for documentation or onboarding reference.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/architecture/lifecycle.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntools // contains helpers and the `scala` generic runner\n├── backend // Compiler backends (currently JVM and JS)\n├── dotc // The main compiler, with subpackages:\n│   ├── ast // Abstract syntax trees\n│\\t ├── classpath\n│\\t ├── config // Compiler configuration, settings, platform specific definitions.\n│\\t ├── core // Core data structures and operations, with specific subpackages for:\n│\\t │\\t ├── classfile // Reading of Java classfiles into core data structures\n│\\t │\\t ├── tasty // Reading and writing of TASTY files to/from core data structures\n│\\t │\\t └── unpickleScala2 // Reading of Scala2 symbol information into core data structures\n│\\t ├── decompiler // pretty printing TASTY as code\n│\\t ├── fromtasty // driver for recompilation from TASTY\n│\\t ├── interactive // presentation compiler and code completions\n│\\t ├── parsing // Scanner and parser\n│\\t ├── plugins // compile plugin definitions\n│\\t ├── printing // Pretty-printing trees, types and other data\n│\\t ├── profile // internals for profiling the compiler\n│\\t ├── quoted // internals for quoted reflection\n│\\t ├── reporting // Reporting of error messages, warnings and other info.\n│\\t ├── rewrites // Helpers for rewriting Scala 2's constructs into Scala 3's.\n│\\t ├── sbt // Helpers for communicating with the Zinc compiler.\n│\\t ├── semanticdb // Helpers for exporting semanticdb from trees.\n│\\t ├── transform // Miniphases and helpers for tree transformations.\n│\\t ├── typer // Type-checking\n│\\t └── util // General purpose utility classes and modules.\n├── io // Helper modules for file access and classpath handling.\n├── repl // REPL driver and interaction with the terminal\n├── runner // helpers for the `scala` generic runner script\n└── scripting // scala runner for the -script argument\n```\n\n----------------------------------------\n\nTITLE: Enabling Experimental Numeric Literals in Scala\nDESCRIPTION: Imports the necessary language feature flag (`experimental.genericNumberLiterals`) to activate the experimental support for generic numeric literals in Scala 3. This allows the compiler to interpret numeric literals for types beyond the built-in primitives.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.experimental.genericNumberLiterals\n```\n\n----------------------------------------\n\nTITLE: Using Export Clauses within Extensions in Scala 3\nDESCRIPTION: Shows how an `export` clause can be used inside an `extension` block. It exports members (`*`) from a helper instance (`moreOps`), created by a private method within the extension, making the helper's methods (`*`, `capitalize`) available as extension methods on the extended type (`String`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nclass StringOps(x: String):\n  def *(n: Int): String = ...\n  def capitalize: String = ...\n\nextension (x: String)\n  def take(n: Int): String = x.substring(0, n)\n  def drop(n: Int): String = x.substring(n)\n  private def moreOps = new StringOps(x)\n  export moreOps.*\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Context Parameters in Scala\nDESCRIPTION: A 'max' function that takes type parameter T and uses a context parameter 'ord' of type Ord[T] to determine the maximum of two values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef max[T](x: T, y: T)(using ord: Ord[T]): T =\n  if ord.compare(x, y) < 0 then y else x\n```\n\n----------------------------------------\n\nTITLE: Understanding the Expansion of Collective Extensions in Scala\nDESCRIPTION: Explains that collective extensions are syntactic sugar. This snippet shows how the previous collective extension example expands into two separate, individual `extension` definitions. Note how the call `longestStrings` inside `longestString` implicitly becomes `ss.longestStrings` in the expanded form.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/extension-methods.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nextension (ss: Seq[String])\n  def longestStrings: Seq[String] =\n    val maxLength = ss.map(_.length).max\n    ss.filter(_.length == maxLength)\n\nextension (ss: Seq[String])\n  def longestString: String = ss.longestStrings.head\n```\n\n----------------------------------------\n\nTITLE: Defining Nullary Method - Scala 3\nDESCRIPTION: This snippet defines a 'nullary' method `next` that takes no parameters (`()`). It serves as an example to illustrate the case where automatic eta expansion does *not* apply in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/eta-expansion.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef next(): T\n```\n\n----------------------------------------\n\nTITLE: Defining a Transaction Class in Scala\nDESCRIPTION: Defines a simple `Transaction` class to encapsulate a log and state (aborted, committed). It provides a `println` method to add messages to the log, and `abort`/`commit` methods to manage the transaction state.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Transaction {\n  private val log = new ListBuffer[String]\n  def println(s: String): Unit = log += s\n\n  private var aborted = false\n  private var committed = false\n\n  def abort(): Unit = { aborted = true }\n  def isAborted = aborted\n\n  def commit(): Unit =\n    if (!aborted && !committed) {\n      Console.println(\"******* log ********\")\n      log.foreach(Console.println)\n      committed = true\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Structural Type and Accessing Members in Scala\nDESCRIPTION: This snippet illustrates instantiating a Record object as a structural type Person and accessing its name and age fields using dot notation. It demonstrates the need for explicit type casting to Person, as well as usage of interpolated strings for output. Prerequisites are the Record and Person definitions and an understanding of Scala's asInstanceOf for type casting. Input is a Record instance and output is a formatted string containing the person's details.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval person = Record(\"name\" -> \"Emma\", \"age\" -> 42).asInstanceOf[Person]\nprintln(s\"${person.name} is ${person.age} years old.\")\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Conversion Method in Scala 2\nDESCRIPTION: Defines an implicit method `stringToToken` in Scala 2 that automatically converts a `String` to a `Token`. This is the traditional Scala 2 way to define implicit conversions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def stringToToken(str: String): Token = new Keyword(str)\n```\n\n----------------------------------------\n\nTITLE: Programmatically Handling Deprecated Enum Cases in Scala\nDESCRIPTION: Defines a `Deprecations` type class and provides an instance for `Planet` within its companion object. This allows checking if a specific `Planet` instance (`p`) corresponds to the deprecated `Pluto` case using `p.isDeprecatedCase`, without triggering deprecation warnings within this scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntrait Deprecations[T <: reflect.Enum] {\n  extension (t: T) def isDeprecatedCase: Boolean\n}\n\nobject Planet {\n  given Deprecations[Planet] with {\n    extension (p: Planet)\n      def isDeprecatedCase = p == Pluto\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Experimental Class, Trait, Object Bodies in Scala 3\nDESCRIPTION: Shows the body of experimental classes, traits, and objects is an experimental scope, allowing access to experimental definitions inside. Non-experimental classes or objects cannot freely access such experimental definitions, but experimental bodies permit such usage without error.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/experimental-defs.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.experimental\n\n@experimental def x = 2\n\n@experimental class A {\n  def f = x // ok because A is experimental\n}\n\n@experimental class B {\n  def f = x // ok because A is experimental\n}\n\n@experimental object C {\n  def f = x // ok because A is experimental\n}\n\n@experimental class D {\n  def f = {\n    object B {\n      x // ok because A is experimental\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying @threadUnsafe to a lazy val in Scala\nDESCRIPTION: This snippet illustrates how to annotate a lazy val with @threadUnsafe to optimize its initialization. It imports the necessary annotation and applies it to a class field, which results in faster, non-thread-safe lazy value initialization. Dependencies include the scala.annotation.threadUnsafe import, and the annotated lazy val is expected to initialize with improved performance but without thread safety guarantees.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/threadUnsafe-annotation.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.threadUnsafe\n\nclass Hello:\n   @threadUnsafe lazy val x: Int = 1\n```\n\n----------------------------------------\n\nTITLE: Illustrating Method Type Inference in Scala 3\nDESCRIPTION: Shows Scala definitions for methods with different parameter lists and their corresponding inferred method types. This demonstrates how `def` declarations map to specific method type signatures in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\ndef a: Int\ndef b (x: Int): Boolean\ndef c (x: Int) (y: String, z: String): String\n```\n\nLANGUAGE: scala\nCODE:\n```\na: Int\nb: (Int) Boolean\nc: (Int) (String, String) String\n```\n\n----------------------------------------\n\nTITLE: runtimeChecked Does Not Suppress Unchecked Type Test Warnings\nDESCRIPTION: Example demonstrating that `runtimeChecked` only suppresses checks that can be soundly performed at runtime (like exhaustivity). It does *not* silence warnings related to unchecked type tests (like testing for `::[Int]` on a `List[Any]`), because the type argument `Int` cannot be reliably checked at runtime due to type erasure.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/runtimeChecked.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> val xs = List(1: Any)\n     | xs.runtimeChecked match {\n     |   case is: ::[Int] => is.head\n     | }\n1 warning found\n-- Unchecked Warning: ---------------------------------------\n3 |  case is: ::[Int] => is.head\n  |       ^\n  |the type test for ::[Int] cannot be checked at runtime\n  |because its type arguments can't be determined from List[Any]\nval res0: Int = 1\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Implicit Base Class Inheritance in Scala\nDESCRIPTION: Illustrates how Scala implicitly includes the base class of the first trait in the parent list if the list starts with a trait. The provided example shows an `object O` inheriting `Mixin` (which extends `Base`), resulting in `Base` being implicitly added before `Mixin` in the linearization, effectively expanding to `object O extends Base with Mixin {}`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass Base extends Object {}\ntrait Mixin extends Base {}\nobject O extends Mixin {}\n```\n\n----------------------------------------\n\nTITLE: Defining Variadic Scala Extractor Signature (unapplySeq)\nDESCRIPTION: Specifies the signature for the `unapplySeq` method used in variadic extractors. The return type `U` determines the type of match (Sequence, Product-Sequence, or isEmpty/get based on a sequence).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/pattern-matching.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef unapplySeq[A](x: T)(implicit x: B): U\n```\n\n----------------------------------------\n\nTITLE: Using Implicit Conversions and Extension Methods with Unsafe Nulls in Scala\nDESCRIPTION: This code demonstrates that in a scope where 'unsafeNulls' is enabled, implicit conversions and extension methods for base types can operate on nullable values ('T | Null'). The snippet shows applying '.split' and '.map' to a 'String', using a user-defined implicit conversion from 'String' to 'Array[String]', and then assigning a nullable String to an Array of nullable Strings. Prerequisites: 'import scala.language.unsafeNulls', definition of an implicit conversion. Inputs: Strings and nullable Strings. Limitation: Without 'unsafeNulls', implicit conversions and extensions involving nullable types would not apply.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_31\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.unsafeNulls\n\nval x = \"hello, world!\".split(\" \").map(_.length)\n\ngiven Conversion[String, Array[String]] = _ => ???\n\nval y: String | Null = ???\nval z: Array[String | Null] = y\n```\n\n----------------------------------------\n\nTITLE: Workaround for Accessing Scala Package Objects\nDESCRIPTION: This Scala snippet shows the standard workaround required before the `packageObjectValues` extension. To access the members of a package object `a.b` as a value, one must explicitly append the `.package` suffix.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/package-object-values.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval z = a.b.`package`\n```\n\n----------------------------------------\n\nTITLE: Implementing Compile-Time Validation for BigFloat Literals in Scala\nDESCRIPTION: Shows the modified `BigFloat` companion object. It defines an inner `FromDigits` class with a fallback implementation and an `inline given` instance that overrides `fromDigits`. This inline method uses a macro splice `${ fromDigitsImpl('digits) }` to enable compile-time processing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nobject BigFloat:\n  ...\n\n  class FromDigits extends FromDigits.Floating[BigFloat]:\n    def fromDigits(digits: String) = apply(digits)\n\n  given FromDigits:\n    override inline def fromDigits(digits: String) = ${ \n      fromDigitsImpl('digits)\n    }\n```\n\n----------------------------------------\n\nTITLE: Illustrating Equivalent Compilation Unit Structures in Scala\nDESCRIPTION: Shows two equivalent ways to structure a Scala compilation unit with nested packages. The first uses multiple `package` clauses sequentially, while the second uses a single `package` clause with nested braces.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/09-top-level-definitions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage ´p_1´;\n...\npackage ´p_n´;\n´\\mathit{stats}´\n```\n\nLANGUAGE: Scala\nCODE:\n```\npackage ´p_1´ { ...\n  package ´p_n´ {\n    ´\\mathit{stats}´\n  } ...\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Enum Case (Diff) Scala\nDESCRIPTION: Shows a diff illustrating the addition of a new case (`Pluto`) to the `Planet` enum definition.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\ndiff\n enum Planet(mass: Double, radius: Double):\n   ...\n   case Neptune extends Planet(1.024e+26, 2.4746e7)\n+  case Pluto   extends Planet(1.309e+22, 1.1883e3)\n end Planet\n```\n\n----------------------------------------\n\nTITLE: Generating a Simple Compile-Time Error using error (Scala)\nDESCRIPTION: This snippet demonstrates a basic use of `scala.compiletime.error`. The inline function `fail` calls `error` with a static string. Calling `fail()` results in a compilation error with the specified message.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.{error, codeOf}\n\ninline def fail() =\n  error(\"failed for a reason\")\n\nfail() // error: failed for a reason\n```\n\n----------------------------------------\n\nTITLE: Definition of ImplicitFunction1 Trait\nDESCRIPTION: A conceptual implementation of the ImplicitFunction1 trait that underlies implicit function types, extending Function1 with an implicit parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntrait ImplicitFunction1[-T0, R] extends Function1[T0, R] {\n  override def apply(implicit x: T0): R\n}\n```\n\n----------------------------------------\n\nTITLE: Special Compiler Options for Experimental Features in Scala 3\nDESCRIPTION: Examples of compiler options that enable experimental features still in research and development. These include -Yexplicit-nulls for tracking null references in the type system and -Ycc for support of capture checking.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/overview.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n-Yexplicit-nulls\n```\n\nLANGUAGE: scala\nCODE:\n```\n-Ycc\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Type Variable References in Scala 3 Quotes\nDESCRIPTION: Shows how to use the same type variable multiple times in a pattern to ensure type equality across parts of the quoted expression.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\n  case '{ $x: (t, t) } =>\n```\n\n----------------------------------------\n\nTITLE: EBNF Syntax for Scala Boolean Literals\nDESCRIPTION: This snippet defines the boolean literals 'true' and 'false' as members of the Scala Boolean type in EBNF syntax, specifying their use as literal tokens in Scala.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_12\n\nLANGUAGE: EBNF\nCODE:\n```\nbooleanLiteral  ::=  ‘true’ | ‘false’\n```\n\n----------------------------------------\n\nTITLE: Defining Context Function Syntax in Grammar\nDESCRIPTION: This snippet shows the grammar rules added to Scala 3 syntax to accommodate context function types and expressions using the `?=>` operator.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions-spec.md#_snippet_0\n\nLANGUAGE: Grammar\nCODE:\n```\nType              ::=  ...\n                    |  FunArgTypes ‘?=>’ Type\nExpr              ::=  ...\n                    |  FunParams ‘?=>’ Expr\n```\n\n----------------------------------------\n\nTITLE: Definition of CanThrow erased class in Scala 3\nDESCRIPTION: Defines the CanThrow class as an erased Scala class, indicating it is a compile-time only artifact with no runtime footprint, used for effect capabilities related to exceptions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/canthrow.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nerased class CanThrow[-E <: Exception]\n```\n\n----------------------------------------\n\nTITLE: Invalid Covariant Type Parameters with Mutable Fields\nDESCRIPTION: Example showing illegal use of covariant type parameters with mutable fields, which would violate type safety.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Q[+A, +B](x: A, y: B) {\n  var fst: A = x           // **** error: illegal variance:\n  var snd: B = y           // `A', `B' occur in invariant position.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Debug Scenario Script - Scala 3 Debugger - Plaintext\nDESCRIPTION: This snippet demonstrates a sample .check file format used for debug tests in the Scala 3 compiler. Each line describes a step for the debugger, such as setting breakpoints, stepping through code, and evaluating expressions. The scenario enables automated verification of debugging behavior by executing these steps and comparing results to expectations. This format is interpreted by the test suite and is not meant to be run directly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n// Pause on a breakpoint in class Test$ on line 5\nbreak Test$ 5\n\n// Stepping in should go to line 10\nstep 10\n\n// Next should go to line 11\nnext 11\n\n// Evaluating the expression x should return 42\neval x\nresult 42\n```\n\n----------------------------------------\n\nTITLE: Java Method Calls with Parentheses\nDESCRIPTION: Shows how Java method calls would look if strict parentheses were enforced everywhere, demonstrating why exceptions are made for Java methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/auto-apply.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nxs.toString().length()\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterless Given Instance in Scala 3\nDESCRIPTION: Defines a given instance for the type `Ord[Int]` without parameters. This is the Scala 3 syntax for providing a contextual value or capability of a specific type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ngiven intOrd: Ord[Int] { ... }\n```\n\n----------------------------------------\n\nTITLE: Generated Code for Running Quoted Expressions in Scala\nDESCRIPTION: This snippet represents the class structure internally generated by the Scala 3 compiler when using the `run` function with a quoted expression. The quoted code `${ mkPower2() }` is embedded within the `exec` method, which is then compiled and invoked via reflection. This shows the compiler's intermediate step for executing staged code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass RunInstance:\n  def exec(): Double => Double = ${ mkPower2() }\n```\n\n----------------------------------------\n\nTITLE: Fallback CanEqual Instance Definition\nDESCRIPTION: Defines the canEqualAny method that provides backward compatibility by allowing comparisons between any types that don't have specific CanEqual instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef canEqualAny[L, R]: CanEqual[L, R] = CanEqual.derived\n```\n\n----------------------------------------\n\nTITLE: Extension Export Expansion in Scala\nDESCRIPTION: Shows how the compiler expands an export clause in an extension to individual extension methods for each exported member.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/export.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nextension (x: String)\n  def take(n: Int): String = x.substring(0, n)\n  def drop(n: Int): String = x.substring(n)\n  private def moreOps = StringOps(x)\n  def *(n: Int): String = moreOps.*(n)\n  def capitalize: String = moreOps.capitalize\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Context Parameter Clauses in Scala\nDESCRIPTION: Defines a function with multiple 'using' clauses that depend on each other, showing how context parameters can build upon previous ones.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef f(u: Universe)(using ctx: u.Context)(using s: ctx.Symbol, k: ctx.Kind) = ...\n```\n\n----------------------------------------\n\nTITLE: Enabling Experimental Quoted Patterns Feature in Scala\nDESCRIPTION: Enables the `experimental.quotedPatternsWithPolymorphicFunctions` language feature via import, necessary to use quoted patterns with polymorphic functions. This feature is not yet standard.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/quoted-patterns-with-polymorphic-functions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.experimental.quotedPatternsWithPolymorphicFunctions\n```\n\n----------------------------------------\n\nTITLE: Compiler Expansion Simple Enum Case Scala\nDESCRIPTION: Shows the compiler's internal representation for a simple enum case (`Red`), which is expanded into a call to a private internal method `$new` for efficient instantiation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nval Red: Color = $new(0, \"Red\")\n```\n\n----------------------------------------\n\nTITLE: Command-Line Arguments Parsing with @main Functions\nDESCRIPTION: Example of using @main with parameters to enable automatic command-line argument parsing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n@main def sayHello(name: String, age: Int): Unit =\n  println(s\"Hello $name, you are $age years old\")\n```\n\n----------------------------------------\n\nTITLE: Old Style Infix Operators with Parentheses\nDESCRIPTION: Previous approach to formatting infix operators across lines, requiring parentheses.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef isABorC(x: Char) = (x == 'A'\n  || x == 'B'\n  || x == 'C')\n```\n\n----------------------------------------\n\nTITLE: Defining a Standard Main Method in Scala 2\nDESCRIPTION: Traditional way of defining a main method in Scala 2, requiring an object definition and args parameter.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Test {\n  def main(args: Array[String]): Unit = println(s\"Hello World\")\n}\n```\n\n----------------------------------------\n\nTITLE: Internal scala.reflect.Enum Trait Scala\nDESCRIPTION: Provides the definition of the `scala.reflect.Enum` trait, which is the base trait extended by all Scala 3 enums. It defines the `ordinal` method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\npackage scala.reflect\n\n/** A base trait of all Scala enum definitions */\ntransparent trait Enum extends Any, Product, Serializable:\n\n  /** A number uniquely identifying a case of an enum */\n  def ordinal: Int\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Capture Set Subtyping Relations in Scala\nDESCRIPTION: Shows examples of capture sets and their subcapturing relations using variables representing capabilities such as FileSystem, CanThrow, and Logger. Illustrates the coverage relation where the root capability set {cap} covers all other sets, demonstrating subcapturing conceptually with sets of capabilities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nfs: FileSystem^\nct: CanThrow[Exception]^ \nl : Logger^{fs}\n\n{l}  <: {fs}     <: {cap}\n{fs} <: {fs, ct} <: {cap}\n{ct} <: {fs, ct} <: {cap}\n```\n\n----------------------------------------\n\nTITLE: Resolving Ambiguous Implicits by Shadowing in Scala\nDESCRIPTION: This Scala snippet provides a corrected version of the ambiguous implicit example. By naming the nested implicit parameter in `bar` also as `a`, it shadows the outer implicit parameter `a`. This allows the compiler to correctly resolve `implicitly[A]` inside `bar` to the innermost implicit, demonstrating how naming can be used for implicit shadowing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/contexts.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> def foo(implicit a: A) { def bar(implicit a: A) { println(implicitly[A]) } }\nfoo: (implicit a: A)Unit\n```\n\n----------------------------------------\n\nTITLE: While Loop Expression Syntax and Implementation in Scala3 - EBNF and Scala\nDESCRIPTION: Defines the syntax for while loops in Scala3 supporting classic `while (expr) expr` and new `while expr do expr` forms. Also provides the semantic desugaring of the while loop into a recursive function `whileLoop` that evaluates the loop condition and executes the body repeatedly while true, mimicking imperative loop behavior.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_28\n\nLANGUAGE: ebnf\nCODE:\n```\nExpr1          ::=  ‘while’ ‘(’ Expr ‘)’ {nl} Expr\n                 |  ‘while’ Expr ‘do’ Expr\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef whileLoop(cond: => Boolean)(body: => Unit): Unit  =\n  if (cond) { body ; whileLoop(cond)(body) } else {}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Refutable Patterns Motivation for runtimeChecked\nDESCRIPTION: Presents an example of a refutable pattern binding (`val y :: ys = xs`) where `xs` is a `List[Any]`. This pattern might fail at runtime (if `xs` is empty). Under future Scala source versions (`-source:future`), this becomes an error. `runtimeChecked` provides a clearer alternative to `: @unchecked` for indicating that this runtime check is intentional.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/runtimeChecked.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef xs: List[Any] = ???\nval y :: ys = xs\n```\n\n----------------------------------------\n\nTITLE: Deriving CanEqual for a Generic Class\nDESCRIPTION: Demonstrates how to derive CanEqual for a generic class Box, which will allow comparing boxes if their element types can be compared.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nclass Box[T](x: T) derives CanEqual\n```\n\n----------------------------------------\n\nTITLE: Standard List Map Function Signature in Scala\nDESCRIPTION: The traditional signature of the map function on List[A] in Scala, which doesn't account for exceptions that might be thrown by the mapping function f.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/canthrow.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef map[B](f: A => B): List[B]\n```\n\n----------------------------------------\n\nTITLE: Defining thisTransaction Global Function\nDESCRIPTION: Creating a helper function that implicitly retrieves the current Transaction from context, illustrating how to access implicit parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n  def thisTransaction: Transactional[Transaction] = implicitly[Transaction]\n```\n\n----------------------------------------\n\nTITLE: Simple Enum Example with RGB Colors\nDESCRIPTION: Example of a basic enum definition with simple cases representing RGB colors, and how it expands in the companion object with ordinal values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\nenum RGB:\n  case Red, Green, Blue\n```\n\nLANGUAGE: scala\nCODE:\n```\nval Red = $new(0, \"Red\")\nval Green = $new(1, \"Green\")\nval Blue = $new(2, \"Blue\")\n\nprivate def $new(_$ordinal: Int, $name: String) =\n  new RGB with scala.runtime.EnumValue:\n    def ordinal = _$ordinal\n    override def productPrefix = $name\n    override def toString = $name\n```\n\n----------------------------------------\n\nTITLE: Implementing Tree Traversal with TreeAccumulator\nDESCRIPTION: Shows how to use TreeAccumulator to traverse a tree and collect values, in this case collecting all val definitions in the tree.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/reflection.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef collectPatternVariables(tree: Tree)(using ctx: Context): List[Symbol] =\n  val acc = new TreeAccumulator[List[Symbol]]:\n    def foldTree(syms: List[Symbol], tree: Tree)(owner: Symbol): List[Symbol] = tree match\n      case ValDef(_, _, rhs) =>\n        val newSyms = tree.symbol :: syms\n        foldTree(newSyms, body)(tree.symbol)\n      case _ =>\n        foldOverTree(syms, tree)(owner)\n  acc(Nil, tree)\n```\n\n----------------------------------------\n\nTITLE: Summoning Given Instances in Scala\nDESCRIPTION: Demonstrates the 'summon' method which retrieves the given instance of a specific type, showing how it reduces to the appropriate instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/using-clauses.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nsummon[Ord[List[Int]]]  // reduces to listOrd(using intOrd)\n```\n\n----------------------------------------\n\nTITLE: Using Context Functions with Explicit and Inferred Arguments\nDESCRIPTION: Example showing how to define and call a context function with both explicit and inferred arguments, demonstrating the context parameter syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n  given ec: ExecutionContext = ...\n\n  def f(x: Int): ExecutionContext ?=> Int = ...\n\n  // could be written as follows with the type alias from above\n  // def f(x: Int): Executable[Int] = ...\n\n  f(2)(using ec)   // explicit argument\n  f(2)             // argument is inferred\n```\n\n----------------------------------------\n\nTITLE: Accessing Invalid Member Without Selectable in Scala (Expected Compilation Error)\nDESCRIPTION: This snippet shows an attempt to access a field 'range' on an object of type 'Vehicle' that does not extend 'reflect.Selectable'. Without the 'Selectable' trait, Scala's type system prevents access to members that are not defined in the base trait. This would result in a compilation error. Intended for Scala 3/Dotty 0.26.0-RC1+ to illustrate new type safety features.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-07-27-26th-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ni3.range: // error: range is not a member of `Vehicle`\n```\n\n----------------------------------------\n\nTITLE: Equivalent Hand-Written Code for Postconditions\nDESCRIPTION: Shows the manual implementation equivalent to using the ensuring postcondition, demonstrating the efficiency of the context function approach.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval s =\n  val result = List(1, 2, 3).sum\n  assert(result == 6)\n  result\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Implicit Def in Scala 2\nDESCRIPTION: Declares an abstract implicit method `symDecorator` without an implementation in Scala 2. This requires concrete subclasses or traits to provide an implicit implementation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def symDecorator: SymDecorator\n```\n\n----------------------------------------\n\nTITLE: Using Java Enum Methods Scala (REPL)\nDESCRIPTION: Demonstrates using a method inherited from `java.lang.Enum` (`compareTo`) on a Scala enum that extends `java.lang.Enum`, shown in the Scala REPL.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nscala> Color.Red.compareTo(Color.Green)\nval res15: Int = -1\n```\n\n----------------------------------------\n\nTITLE: Defining an Implicit Function in Scala 3\nDESCRIPTION: Example showing how to move a parameter section to create an implicit function that receives a Transaction parameter implicitly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n  def f1(x: Int) = { implicit thisTransaction: Transaction =>\n    thisTransaction.println(s\"first step: $x\")\n    f2(x + 1)\n  }\n```\n\n----------------------------------------\n\nTITLE: Implicit Copy Method Definition in Scala 3 Case Classes\nDESCRIPTION: This snippet illustrates the automatically added `copy` method for Scala 3 case classes, facilitating the creation of modified object copies with optional parameter changes. The method is omitted if the class already defines the method or has repeated parameters. It accepts named parameters with defaults referring to existing instance fields, returning a new instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\ndef copy[´\\mathit{tps}\\,´](´\\mathit{ps}'_1´)...(´\\mathit{ps}'_n´): ´c´[´\\mathit{tps}\\,´] = new ´c´[´\\mathit{Ts}\\,´](´\\mathit{xs}_1´)...(´\\mathit{xs}_n´)\n```\n\n----------------------------------------\n\nTITLE: Syntax Definition for Infix Operation Patterns (EBNF)\nDESCRIPTION: Defines the EBNF syntax for infix operation patterns. It shows that such patterns consist of a simple pattern, followed by an identifier (the operator), and another simple pattern.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_18\n\nLANGUAGE: ebnf\nCODE:\n```\n  Pattern3  ::=  SimplePattern {id [nl] SimplePattern}\n```\n\n----------------------------------------\n\nTITLE: Defining and Instantiating a Structural Type with Refinement in Scala\nDESCRIPTION: This snippet presents a trait Vehicle extending reflect.Selectable, declares a wheels field, and then instantiates a local anonymous subclass that adds a range member. The instantiation i3 is shown to possess the refined type Vehicle { val range: Int }, enabling dot notation for i3.range. This illustrates both extensibility and the refined typing process for local or anonymous classes extending Selectable. Dependencies are the Selectable trait, and Scala's structural typing support. Inputs are base trait and refinements; output is an object with enriched structural type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Vehicle extends reflect.Selectable:\n  val wheels: Int\n\nval i3 = new Vehicle: // i3: Vehicle { val range: Int }\n  val wheels = 4\n  val range = 240\n\ni3.range\n```\n\n----------------------------------------\n\nTITLE: Simulating Parameterized Given with Class and Implicit Def in Scala 2 - Scala\nDESCRIPTION: Emulates Scala 3's parameterized given by defining a class listOrd and an implicit def for implicit instance resolution in Scala 2. Requires Ord and knowledge of implicit classes/methods. Accepts an implicit Ord[T], outputs a new listOrd[T] available implicitly.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass listOrd[T](implicit ord: Ord[T]) extends Ord[List[T]] { ... }\nfinal implicit def listOrd[T](implicit ord: Ord[T]): listOrd[T] =\n new listOrd[T]\n```\n\n----------------------------------------\n\nTITLE: Reimplemented fromProduct for Case Class with @unroll in Scala\nDESCRIPTION: Illustrates how the `fromProduct` method in a case class companion object is reimplemented when `@unroll` is used on the primary constructor parameters. It uses pattern matching on the input `Product`'s `productArity` to instantiate the case class correctly, handling calls corresponding to older constructor signatures (forwarders) by supplying default values (`ds...`) and preserving the original logic for the full parameter list.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/unrolled-defs.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ncase class C(ps0...) // ps0 has z parameters\n\nobject C:\n  def fromProduct(p: Product): C =\n    p.productArity match\n      case ... => ...\n      case n   => new C(...p.productElement(n - 1), ds...)\n      case _   => new C(...p.productElement(z - 1))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Generic Numeric Literals in Scala\nDESCRIPTION: Shows examples of using numeric literals with various types, including standard `Long`, user-defined `BigInt` (using a hexadecimal literal with underscores as separators), and `BigDecimal` (with decimal points and separators). It also demonstrates using such literals within a pattern match expression.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval x: Long = -10_000_000_000\nval y: BigInt = 0x123_abc_789_def_345_678_901\nval z: BigDecimal = 110_222_799_799.99\n\n(y: BigInt) match\n  case 123_456_789_012_345_678_901 =>\n```\n\n----------------------------------------\n\nTITLE: Optimizing Power Calculation Macro using valueOrAbort for Unlifting in Scala\nDESCRIPTION: Presents an alternative `powerCode` implementation using `n.valueOrAbort` to extract the constant value from the `Expr[Int]` argument `n`. This approach generates optimized code via `unrolledPowerCode` but results in a compilation error if `n` is not a constant known at compile time. Requires `scala.quoted.*`, `unrolledPowerCode`, and a `using Quotes` context.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef powerCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] =\n  // emits an error message if `n` is not a constant\n  unrolledPowerCode(x, n.valueOrAbort)\n```\n\n----------------------------------------\n\nTITLE: Defining the scala.Conversion Abstract Class in Scala\nDESCRIPTION: This snippet defines the abstract scala.Conversion class which is a subtype of the function type from T to U. It establishes the basis for implicit conversions by requiring an apply method that converts a value of type T to type U. This class resides in the scala package and serves as the type class used by Scala 3's given instances for implicit conversions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/conversions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Conversion[-T, +U] extends (T => U):\n  def apply (x: T): U\n```\n\n----------------------------------------\n\nTITLE: Using local anonymous classes extending Selectable with refined types\nDESCRIPTION: This snippet illustrates defining a local trait 'Vehicle' extending Reflective.Selectable, with an anonymous class adding a 'range' field. It shows how the type of the anonymous class becomes a refinement over 'Vehicle', allowing access to the 'range' member via structural dispatch.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Vehicle extends reflect.Selectable:\n  val wheels: Int\n\nval i3 = new Vehicle:\n  val wheels = 4\n  val range = 240\n\ni3.range\n```\n\n----------------------------------------\n\nTITLE: Mapping Compose Functions with Capture Sets in Scala 3\nDESCRIPTION: Shows a function `mapCompose` taking a list of composed function pairs and mapping them using `compose1`. The capture sets are expressed with `ps*` denoting reachability through the parameter list, exemplifying how capture sets propagate through higher-order functions and collections.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndef mapCompose[A](ps: List[(A => A, A => A)]): List[A ->{ps*} A] =\n  ps.map(compose1)\n    // ps: List[(A ->{ps*} A, A ->{ps*} A)]\n    // Hence compose1's parameters are both of type A ->{ps*} A\n    // Hence its result type is A ->{ps*} A\n    // So map's type parameter is A ->{ps*} A\n    // Expanded typing:\n    //   (ps: List[(A ->{ps*} A, A ->{ps*} A)])\n    //     .map[A ->{ps*} A]: (f: A ->{ps*} A, g: A ->{ps*} A) =>\n    //       compose1[A ->{ps*} A, A ->{ps*} A, A ->{ps*} A](f, g)\n    //         : A -> {f, g} A\n    //  The closure is widened to the non-dependent function type\n    //    (f: A ->{ps*} A, g: A ->{ps*} A) -> A ->{ps*} A\n```\n\n----------------------------------------\n\nTITLE: Declaring a Method with an Implicit Parameter in Scala\nDESCRIPTION: Shows how to define a method `currentMap` that takes an implicit parameter `ctx` of type `Context` and returns a `Map[String, Int]`. The snippet also implicitly refers to the challenge in calling such methods due to implicit arguments being indistinguishable syntactically from explicit ones, requiring awkward workarounds like using `apply` explicitly when passing arguments to implicit parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/contextual.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef currentMap(implicit ctx: Context): Map[String, Int]\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Variable Definition in Scala 3 Quotes\nDESCRIPTION: Demonstrates the explicit form of type variable definition in quoted patterns, which allows for more control including type bounds specification.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\n  case '{ type t; $x: t } =>\n```\n\n----------------------------------------\n\nTITLE: Signatures of selectDynamic and applyDynamic Methods in Scala\nDESCRIPTION: These snippets illustrate the expected signatures of selectDynamic and applyDynamic methods that implementations of scala.Selectable should provide. selectDynamic takes a single field name String parameter and returns a value of type T, while applyDynamic handles dynamic method invocation, taking a method name and either variadic arguments or variadic Class tags plus arguments, returning type T. These methods support implementation of structural member selection with Java reflection or alternative mechanisms.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types-spec.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef selectDynamic(name: String): T\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef applyDynamic(name: String)(args: Any*): T\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef applyDynamic(name: String, ctags: Class[?]*)(args: Any*): T\n```\n\n----------------------------------------\n\nTITLE: Examples of Scala Constant Identifiers\nDESCRIPTION: Provides a list of valid identifiers in Scala that are classified as \"constant identifiers\", meaning they do not start with a lowercase letter or underscore, distinguishing them in pattern matching contexts.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n    +    Object  $reserved  ǅul    ǂnûm\n    ⅰ_ⅲ  Ⅰ_Ⅲ     ↁelerious  ǃqhàà  ʹthatsaletter\n```\n\n----------------------------------------\n\nTITLE: Enum with Contravariant Type Parameter Example\nDESCRIPTION: Example showing enum with contravariant type parameter and a case that needs explicit type parameter specification to be correctly typed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nenum View[-´T´]:\n  case Refl(f: ´T´ => ´T´)\n```\n\nLANGUAGE: scala\nCODE:\n```\nenum View[-´T´]:\n  case Refl[-´T'´](f: ´T'´ => ´T'´) extends View[´T'´]\n```\n\nLANGUAGE: scala\nCODE:\n```\nenum View[-´T´]:\n  case Refl[´R´](f: ´R´ => ´R´) extends View[´R´]\n```\n\n----------------------------------------\n\nTITLE: Defining Transactional Type Alias in Scala 3\nDESCRIPTION: Creating a type alias for functions that take an implicit Transaction parameter, demonstrating type abstraction for implicit function types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-12-05-implicit-function-types.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ntype Transactional[T] = implicit Transaction => T\n```\n\n----------------------------------------\n\nTITLE: Defining the Generic Scala `FunctionN` Trait\nDESCRIPTION: Defines the generic structure of `scala.FunctionN` traits for ´n \\geq 0´. These traits have type parameters for inputs (contravariant `-T_i`) and output (covariant `+R`), and define an `apply` method. They are involved in desugaring function types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\ntrait Function´_n´[-´T_1´, ..., -´T_n´, +´R´]:\n  def apply(´x_1´: ´T_1´, ..., ´x_n´: ´T_n´): ´R´\n```\n\n----------------------------------------\n\nTITLE: No code snippets found\nDESCRIPTION: The provided content is a detailed textual explanation and specification of union types in Scala 3 without any embedded code snippets.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/union-types-spec.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Defining the Enum trait in Scala 3\nDESCRIPTION: The foundational Enum trait in the scala.reflect package that provides the ordinal method required by all enum implementations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.reflect\n\ntransparent trait Enum extends Any, Product, Serializable:\n\n  def ordinal: Int\n```\n\n----------------------------------------\n\nTITLE: Setting up Dotty with sbt\nDESCRIPTION: Command to create a new sbt project with Dotty as the compiler using the official template.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-10-16-fourth-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsbt new lampepfl/dotty.g8\n```\n\n----------------------------------------\n\nTITLE: Using Erased Vals and Passing as Erased Arguments in Scala\nDESCRIPTION: Defines an erased val and demonstrates its use as an argument to a method expecting an erased parameter. This applies only where erased definitions are enabled and cannot be used outside erased parameter contexts. The snippet illustrates constraints on erased vals: accessible as erased arguments but not directly computable.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nerased val erasedEvidence: Ev = ...\nmethodWithErasedEv(erasedEvidence, 40) // 42\n```\n\n----------------------------------------\n\nTITLE: Macro Pattern Matching with `Unlifted` to Extract Constant Values in Scala 3 Quoted Macros\nDESCRIPTION: This snippet demonstrates quoting macros that pattern match on constant expressions using the renamed `Unlifted`. It extracts a constant `Int` value and computes its square, enabling compile-time macro transformations with pattern matching on expressions. It depends on `scala.quoted` and macro quoting syntax.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-03-18-23rd-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.quoted._\n\ninline def square(inline x: Int): Int = ${ squareImpl('x) }\n\ndef squareImpl(x: Expr[Int])(using QuoteContext): Expr[Int] =\n  x match\n    case Unlifted(value: Int) => Expr(value * value)\n```\n\n----------------------------------------\n\nTITLE: Definition of the Fallback CanEqual Method\nDESCRIPTION: The definition of the canEqualAny method that provides backward compatibility by allowing comparisons between types that don't explicitly have CanEqual instances.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/multiversal-equality.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef canEqualAny[L, R]: CanEqual[L, R] = CanEqual.derived\n```\n\n----------------------------------------\n\nTITLE: Extracting Constant Values at Compile-time Using scala.compiletime.constValue in Scala\nDESCRIPTION: Defines a transparent inline recursive function `toIntC` that converts a singleton type representing a natural number (modeled using Peano numerals) into an Int at compile-time by pattern matching on constValue. It recursively decomposes the type-level number using the successor type S and zero case, producing an Int literal result. The snippet requires importing `constValue` and the successor type S from scala.compiletime.ops.int. Inputs are singleton types representing natural numbers; outputs are integer values known at compile time.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/compiletime-ops.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.compiletime.constValue\nimport scala.compiletime.ops.int.S\n\ntransparent inline def toIntC[N]: Int =\n  inline constValue[N] match\n    case 0        => 0\n    case _: S[n1] => 1 + toIntC[n1]\n\ninline val ctwo = toIntC[2]\n```\n\n----------------------------------------\n\nTITLE: Defining a Context Function Type in Scala\nDESCRIPTION: Example of defining a context function type using the ?=> syntax to create a type alias that requires an ExecutionContext.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Executable[T] = ExecutionContext ?=> T\n```\n\n----------------------------------------\n\nTITLE: Enabling Modularity Features in Scala 3\nDESCRIPTION: Shows how to enable the experimental modularity features using command-line options when compiling Scala code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/modularity.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n  scala compile -source:future -language:experimental.modularity\n```\n\n----------------------------------------\n\nTITLE: Workaround for Java Checked Exceptions Using Wrapper Exceptions - Scala\nDESCRIPTION: Illustrates a convoluted workaround to circumvent Java's checked exception restrictions by wrapping a checked exception inside an unchecked RuntimeException (referred to as Wrapper here). The caller catches the Wrapper and unwraps the original exception to rethrow it. This workaround is verbose, error-prone, and demonstrates why Java's checked exceptions are unpopular.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/canthrow.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntry\n  xs.map(x => if x < limit then x * x else throw Wrapper(LimitExceeded()))\ncatch case Wrapper(ex) => throw ex\n```\n\n----------------------------------------\n\nTITLE: Accessing Java Reserved Words with Backticks (Scala)\nDESCRIPTION: Demonstrates the technique of using backticks (`) around an identifier. This allows referencing names that are reserved keywords in Scala but might be valid identifiers (like method names) in other languages like Java, such as accessing `Thread.yield()`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n Thread.`yield`() \n```\n\n----------------------------------------\n\nTITLE: Defining Erased Values and Using Them with Erased Parameters\nDESCRIPTION: Shows how to define erased val and def, which can only be used as arguments to methods with erased parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nerased val erasedEvidence: Ev = ...\nmethodWithErasedEv(erasedEvidence)\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Macro fromDigits with Given in BigFloat (Scala)\nDESCRIPTION: Defines the BigFloat companion object structure, including a regular FromDigits class and a macro-enabled given instance with an inline fromDigits method. The inline method leverages a macro implementation (fromDigitsImpl) to perform compile-time validation, raising compile-time errors for invalid digit strings. Requires Scala 3's metaprogramming facilities and the Quotes context.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/numeric-literals.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nobject BigFloat:\n  ...\n\n  class FromDigits extends FromDigits.Floating[BigFloat]:\n    def fromDigits(digits: String) = apply(digits)\n\n  given FromDigits with\n    override inline def fromDigits(digits: String) = ${\n      fromDigitsImpl('digits)\n    }\n```\n\n----------------------------------------\n\nTITLE: Context Function Instance Creation - Scala - Scala\nDESCRIPTION: This snippet demonstrates the creation of an instance of a context function as a subclass of ContextFunctionN in Scala 3. It defines an inline implementation of the apply method, which takes context parameters and evaluates the provided expression, returning a value of type T. Requires contextual parameters to be available in scope upon invocation. Inputs are T1...Tn (types), x1...xn (context variables), and output is T. Restrictions include a fresh parameter name for wildcards and that the result type must not refer to the context variables.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/context-functions-spec.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nnew scala.ContextFunctionN[T1, ..., Tn, T]:\n  def apply(using x1: T1, ..., xn: Tn): T = e\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unsoundness with Uninitialized Fields in Scala 3\nDESCRIPTION: This example shows how Scala's type system can be unsound with respect to null. Field f has a non-nullable type but contains null during initialization because it's being used before it's fully initialized.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/explicit-nulls.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass C:\n  val f: String = foo(f)\n  def foo(f2: String): String = f2\n\nval c = new C()\n// c.f == \"field is null\"\n```\n\n----------------------------------------\n\nTITLE: Safe usage of usingLogFile with capture checking\nDESCRIPTION: An example of code that passes capture checking because the file operation is performed eagerly within the scope of usingLogFile, rather than being deferred for later execution.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval xs = usingLogFile { f =>\n  List(1, 2, 3).map { x => f.write(x); x * x }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining List contains with Any parameter (Scala 2)\nDESCRIPTION: Illustrates the original, unsafe `contains` method on `List[T]` from the standard library. This definition accepts an `Any` parameter, allowing potentially nonsensical comparisons between the list's elements and arguments of any type due to universal equality.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass List[+T]:\n  ...\n  def contains(x: Any): Boolean\n```\n\n----------------------------------------\n\nTITLE: Generated Main Method Implementation in Scala\nDESCRIPTION: Example of the code generated for a class with a main method from a @myMain annotation. Shows how command-line arguments are processed, parsed, and passed to the annotated method.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/main-annotation.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject foo {\n  def main(args: Array[String]): Unit = {\n    val mainAnnot = new myMain()\n    val info = new Info(\n      name = \"foo.main\",\n      documentation = \"Sum all the numbers\",\n      parameters = Seq(\n        new Parameter(\"first\", \"scala.Int\", hasDefault=false, isVarargs=false, \"Fist number to sum\", Seq()),\n        new Parameter(\"second\", \"scala.Int\", hasDefault=true, isVarargs=false, \"\", Seq()),\n        new Parameter(\"rest\", \"scala.Int\" , hasDefault=false, isVarargs=true, \"The rest of the numbers to sum\", Seq())\n      )\n    )\n    val mainArgsOpt = mainAnnot.command(info, args)\n    if mainArgsOpt.isDefined then\n      val mainArgs = mainArgsOpt.get\n      val args0 = mainAnnot.argGetter[Int](info.parameters(0), mainArgs(0), None) // using a parser of Int\n      val args1 = mainAnnot.argGetter[Int](info.parameters(1), mainArgs(1), Some(() => sum$default$1())) // using a parser of Int\n      val args2 = mainAnnot.varargGetter[Int](info.parameters(2), mainArgs.drop(2)) // using a parser of Int\n      mainAnnot.run(() => sum(args0(), args1(), args2()*))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Existing Scala Warning for Incompatible Type Comparison (Int vs String)\nDESCRIPTION: Demonstrates a scenario where the current Scala compiler issues a warning because an `Int` is compared directly with a `String` using `==`, correctly identifying that this comparison will always result in `false`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-05-05-multiversal-equality.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> 1 == \"abc\"\n<console>:12: warning: comparing values of types Int and String using `==' will always yield false\n```\n\n----------------------------------------\n\nTITLE: Formal Syntax Definition for Vararg Splices in Scala 3\nDESCRIPTION: Provides the formal syntax definition for argument patterns and parameter argument expressions in Scala 3, including the new vararg splice notation with postfix asterisk.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/vararg-splices.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nArgumentPatterns  ::=  '(' [Patterns] ')'\n                    |  '(' [Patterns ','] Pattern2 '*' ')'\n\nParArgumentExprs  ::=  '(' ['using'] ExprsInParens ')'\n                    |  '(' [ExprsInParens ','] PostfixExpr '*' ')'\n```\n\n----------------------------------------\n\nTITLE: Nested Compiler-Supplied Imports Demonstrating Import Precedence in Scala 3\nDESCRIPTION: This snippet conceptually shows the compiler-supplied implicit imports made in each Scala source file, nested to illustrate their precedence levels. The nested blocks represent increasing nesting depth with the lowest precedence imports in the outer blocks, implying that user-defined imports shadow these system imports. It depicts the import of java.lang.*, scala.*, and Predef.* as a preamble around source code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/02-identifiers-names-and-scopes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport java.lang.*\n{\n  import scala.*\n  {\n    import Predef.*\n    { /* source */ }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Expanded Erased Class Auto-Erasure in Scala\nDESCRIPTION: Shows the expanded form of definitions using erased classes, demonstrating how the compiler automatically adds the erased modifier.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nerased class CanRead\n\nerased val x: CanRead = ...\nval y: (erased CanRead) => Int = ...\ndef f(erased x: CanRead) = ...\nerased def g(): CanRead = ...\nerased given CanRead = ...\n```\n\n----------------------------------------\n\nTITLE: Definition of erasedValue (Scala)\nDESCRIPTION: Shows the definition of `scala.compiletime.erasedValue`. This function pretends to return a value of its type argument `T` but always causes a compile-time error unless the call is removed during inlining. It's used for type-based computations within inline methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/compiletime-ops.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef erasedValue[T]: T\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Matchable Pattern Match Warning Example\nDESCRIPTION: This code demonstrates a pattern matching attempt on an 'IArray' which is not 'Matchable'. In Scala 3.0.0-M3 with '3.1-migration' language mode, this will trigger a warning to prevent unsound runtime behavior.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-12-18-scala3-m3.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval imm = IArray(1,2,3) // supposedly immutable...\nimm match\n  case a: Array[Int] => a(0) = 0  // but that's shown to be lie\n```\n\n----------------------------------------\n\nTITLE: Capturing the Type of \"this\" with Self-Type Annotations in Scala\nDESCRIPTION: Shows how the capture checker infers the capture set for the type of this in a class unless an explicit self-type annotation is given. The constraints for this type ensure all captured references are included and the type is compatible with parent classes. An example illustrates a capture checking error when a local capability used inside class methods is not included in the inferred capture set, resulting in a reference error.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nclass C:\n  self: D^{a, b} => ...\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Cap extends caps.Capability\ndef test(c: Cap) =\n  class A:\n    val x: A = this\n    def f = println(c)  // error\n```\n\nLANGUAGE: scala\nCODE:\n```\n16 |    def f = println(c)  // error\n   |                    ^\n   |(c : Cap) cannot be referenced here; it is not included in the allowed capture set {}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Missing Arguments Error\nDESCRIPTION: Shows the compiler error message in Scala 3 when attempting to call a nullary method defined with `()` without including the parentheses, demonstrating the stricter syntax enforcement.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/auto-apply.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nnext\n^\nmissing arguments for method next\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Val in Scala 2\nDESCRIPTION: Defines an implicit lazy val `pos` of type `Position` in Scala 2. This makes the computed value implicitly available within the scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/relationship-implicits.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nlazy implicit val pos: Position = tree.sourcePos\n```\n\n----------------------------------------\n\nTITLE: Adding compose Extension Method using TupledFunction in Scala\nDESCRIPTION: This extension method adds a `compose` capability to a function `F`, allowing it to be composed with another function `G`, provided the necessary implicit `TupledFunction` instances exist. It returns a new function `GArgs => R` that first applies the tupled version of `G` and then the tupled version of `F`. It demonstrates how `TupledFunction` can generalize function composition.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/tupled-function.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n/** Composes two instances of TupledFunction into a new TupledFunction, with this function applied last.\n *\n *  @tparam F a function type\n *  @tparam G a function type\n *  @tparam FArgs the tuple type with the same types as the function arguments of F and return type of G\n *  @tparam GArgs the tuple type with the same types as the function arguments of G\n *  @tparam R the return type of F\n */\nextension [F, G, FArgs <: Tuple, GArgs <: Tuple, R](f: F)\n  def compose(g: G)(using tg: TupledFunction[G, GArgs => FArgs], tf: TupledFunction[F, FArgs => R]): GArgs => R = {\n  (x: GArgs) => tf.tupled(f)(tg.tupled(g)(x))\n}\n```\n\n----------------------------------------\n\nTITLE: Field retention for private class parameters in Scala 3\nDESCRIPTION: This example demonstrates that private fields declared in class parameters are not eliminated by the compiler, even when they are only accessed through 'this', as class parameters are treated specially.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/this-qualifier.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n  class C(private val c: Int)\n```\n\n----------------------------------------\n\nTITLE: Setting up Reflection in Scala 3 Macros\nDESCRIPTION: Shows how to set up a macro implementation with reflection capabilities by adding an implicit Quotes parameter and importing quotes.reflect.* to access reflection utilities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/reflection.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.quoted.*\n\ninline def natConst(inline x: Int): Int = ${natConstImpl('{x})}\n\ndef natConstImpl(x: Expr[Int])(using Quotes): Expr[Int] =\n  import quotes.reflect.*\n  ...\n```\n\n----------------------------------------\n\nTITLE: Combining Local and Argument Capabilities in Scala Class Capture\nDESCRIPTION: Illustrates how a class's capture set includes local capabilities (referenced from outside, like `a` and `b`) and argument capabilities (passed via constructor, like `c` instantiated from `x`). Local capabilities are inherited (`a` from `Super` to `Sub`). The final capture set for `Sub(c)` is `{a, b, c}`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\n@capability class Cap\n\ndef test(a: Cap, b: Cap, c: Cap) =\n  class Super(y: Cap):\n    def f = a\n  class Sub(x: Cap) extends Super(x)\n    def g = b\n  Sub(c)\n```\n\n----------------------------------------\n\nTITLE: Syntax for Structural Type Refinements\nDESCRIPTION: This snippet defines the grammar rules for structural type refinements in Scala. It shows how a `SimpleType` can include a `Refinement` block, which contains a sequence of `RefineStat` definitions for values (`val`), methods (`def`), or types (`type`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/structural-types-spec.md#_snippet_0\n\nLANGUAGE: Syntax\nCODE:\n```\nSimpleType    ::= ... | Refinement\nRefinement    ::= ‘{’ RefineStatSeq ‘}’\nRefineStatSeq ::=  RefineStat {semi RefineStat}\nRefineStat    ::= ‘val’ VarDcl | ‘def’ DefDcl | ‘type’ {nl} TypeDcl\n```\n\n----------------------------------------\n\nTITLE: Adding TASTy Inspector Dependency in sbt\nDESCRIPTION: Adds the `scala3-tasty-inspector` library as a dependency in an sbt build file. This is necessary to use the TASTy inspection capabilities. The version is tied to the project's Scala version.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/tasty-inspect.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"org.scala-lang\" %% \"scala3-tasty-inspector\" % scalaVersion.value\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Implicit Conversions with Call-by-Name vs Call-by-Value Parameters Scala\nDESCRIPTION: Demonstrates that Scala 3 removes the previous lower priority given to implicit conversions with call-by-name parameters compared to call-by-value parameters, leading to ambiguity in cases where both conversion forms are applicable. The example shows that calls with an Int argument are ambiguous when both implicit defs are available.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-resolution.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n  implicit def conv1(x: Int): A = new A(x)\n  implicit def conv2(x: => Int): A = new A(x)\n  def buzz(y: A) = ???\n  buzz(1)   // error: ambiguous\n```\n\n----------------------------------------\n\nTITLE: Compiler Warning for Pattern Match Using Non-Matchable Selector in Scala 3\nDESCRIPTION: Example compiler warning message shown when pattern matching is performed on a selector type that does not conform to the Matchable trait, indicating a potential abstraction leak. This enforces the use of Matchable in pattern selector types for safer matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/matchable.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n-- Warning: ../new/test.scala:4:12 ---------------------------------------------\n4 |    case a: Array[Int] => a(0) = 0\n  |            ^^^^^^^^^^\n  |            pattern selector should be an instance of Matchable,\n  |            but it has unmatchable type IArray[Int] instead\n```\n\n----------------------------------------\n\nTITLE: Instantiating Generic Class with Capturing Types in Scala\nDESCRIPTION: Sets up an example for capture tunnelling by defining two values, `x` and `y`, with distinct capturing types (`{ct} Int -> String` and `{fs} Logger`). It then creates a `Pair` instance `p` using these values.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ndef x: {ct} Int -> String\ndef y: {fs} Logger\ndef p = Pair(x, y)\n```\n\n----------------------------------------\n\nTITLE: Desugaring a Simple Quote Pattern Match in Scala\nDESCRIPTION: This example illustrates how a simple quote pattern match like `case '{ 1 }` is desugared by the Scala 3 compiler into a call to the internal `ExprMatch.unapply` extractor. The pattern `EmptyTuple` indicates no captured variables (splices), and the `given` parameter is the quoted expression `'{1}` representing the pattern literal that the scrutinee is matched against.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n  case '{ 1 } =>\n// is elaborated to\n  case ExprMatch(EmptyTuple)(using '{1}) =>\n//               ^^^^^^^^^^  ^^^^^^^^^^\n//                pattern    expression\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with a Typeless Conditional in Scala\nDESCRIPTION: Defines a Scala function `f` intended to return `Int`, but the `if` expression lacks an `else` clause, resulting in a `Unit` return type. This code snippet is used to illustrate the improved error message reporting in Dotty 0.24.0-RC1 when such type mismatches occur.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-04-29-24th-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef f: Int = if ??? then 1\n```\n\n----------------------------------------\n\nTITLE: Syntax Definition for Extractor SimplePattern (EBNF)\nDESCRIPTION: Defines the EBNF syntax for a simple extractor pattern. It consists of a stable identifier (the extractor object) followed by an optional list of nested patterns enclosed in parentheses.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_12\n\nLANGUAGE: ebnf\nCODE:\n```\n  SimplePattern   ::=  StableId ‘(’ [Patterns] ‘)’\n```\n\n----------------------------------------\n\nTITLE: Referencing Experimental SAMs in Scala 3\nDESCRIPTION: Shows that traits annotated @experimental with single abstract methods (SAMs) cannot be referenced from non-experimental contexts. Passing a lambda to a method expecting an experimental SAM parameter results in a compilation error enforcing safe usage.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/experimental-defs.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n@experimental\ntrait ExpSAM {\n  def foo(x: Int): Int\n}\n\ndef bar(f: ExpSAM): Unit = {} // error: error form rule 2\n\ndef test: Unit =\n  bar(x => x) // error: reference to experimental SAM\n  ()\n```\n\n----------------------------------------\n\nTITLE: Generated Secondary Constructor Forwarder for @unroll in Scala\nDESCRIPTION: Provides an example of an invisible secondary constructor (`def this`) that is generated as a forwarder when `@unroll` is applied to a parameter in the primary constructor. This forwarder accepts parameters corresponding to the signature before unrolling (`ps...`) and calls the primary constructor, supplying default values (`ds...`) for the unrolled parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/unrolled-defs.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n`<invisible>` def this(ps...) = this(ps..., ds...)\n```\n\n----------------------------------------\n\nTITLE: Enabling and Removing Macro Annotations Transformations in Scala 3\nDESCRIPTION: This snippet deals with macro annotations, allowing transformation of companion objects through macros and removing deprecated or experimental annotations like `MainAnnotation`. It facilitates enhanced macro-based code generation and annotation handling in the compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.5.0-RC1.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n# Macro Annotations\n\n- Allow macro annotation to transform companion [#19677]\n- Remove experimental `MainAnnotation`/`newMain` (replaced with `MacroAnnotation`) [#19937]\n```\n\n----------------------------------------\n\nTITLE: Desugaring Scala Objects into Classes and Values\nDESCRIPTION: This conceptual Scala code illustrates how the Dotty compiler represents a Scala `object` after the Typer phase. An `object O` is desugared into a corresponding `class O$` (with a singleton self-type `O.type`) containing the object's members and a `val O` of that class type, creating the singleton instance. This involves a type symbol for the class and a term symbol for the value.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/dotty-internals-1-notes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject O {\n  val s = 1\n}\n\n// is represented (after Typer) as\n\nclass O$ { this: O.type =>\n  val s = 1\n}\nval O = new O$\n```\n\n----------------------------------------\n\nTITLE: Example of Package Prefix Behavior in Implicit Search Scope Scala\nDESCRIPTION: Shows the effect that package prefixes no longer extend the implicit search scope in Scala 3. Two givens are declared in nested scopes within a package, but the implicit scope for a type outside the package excludes certain implicits, demonstrating how anchors and implicit scopes interact in practice.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/implicit-resolution.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n  package p\n\n  given a: A = A()\n\n  object o:\n    given b: B = B()\n    type C\n```\n\n----------------------------------------\n\nTITLE: Defining and Implementing a Macro to Inspect Syntax Trees - Scala\nDESCRIPTION: This snippet defines a macro 'showTree' which inspects a given expression's syntax tree and formats details about function applications. The macro relies on 'scala.quoted._' for Expr and macros, and accesses TASTy Reflect APIs via 'import qctx.tasty._' inside the macro implementation. The function matches on 'Inlined' and 'Apply' nodes, extracting functions and arguments, and returns a string representation. Key parameters include the input expression 'x', and usage requires enabling macros and having an implicit QuoteContext.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-03-18-23rd-dotty-milestone-release.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.quoted._\n\ninline def showTree(inline x: Any): String = ${ showTreeImpl('x) }\ndef showTreeImpl(x: Expr[Any])(using qctx: QuoteContext): Expr[String] =\n  import qctx.tasty._\n  x.unseal match\n    case Inlined(_, _, app: Apply) =>\n      val fun: Term = app.fun\n      val args: List[Term] = app.args\n      val res = s\"Function: $fun\\nApplied to: $args\"\n      Expr(res)\n```\n\n----------------------------------------\n\nTITLE: Defining a Kind-Polymorphic Function in Scala\nDESCRIPTION: Defines a Scala function 'f' with a type parameter 'T' bounded by scala.AnyKind to enable kind polymorphism. This allows the function to accept type arguments of any kind, including simple types, type constructors, or higher-kinded types. The snippet requires Scala 3 and the availability of the scala.AnyKind type, and illustrates how kind polymorphism can be expressed syntactically in Scala. The expected input is any type argument T conforming to the AnyKind bound, but usage of such any-kinded types is limited as they cannot be instantiated or used as concrete value types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/kind-polymorphism.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef f[T <: AnyKind] = ...\n```\n\n----------------------------------------\n\nTITLE: Creating a New Dotty sbt Project Using Shell Command\nDESCRIPTION: This shell snippet shows the command to setup a new sbt project configured to use Dotty as the compiler. It uses the sbt new template for the Dotty project and provides an entry point for users to quickly start developing with Dotty in an sbt environment.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-10-10-10th-dotty-milestone-release.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nsbt new lampepfl/dotty.g8\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Deprecated Symbol Literal Compiler Error in Scala 3\nDESCRIPTION: This snippet shows the output from compiling a Scala 3 file (`Test.scala`) containing a deprecated symbol literal (`'abc`). It illustrates the compiler error message and the helpful suggestions provided by the compiler regarding alternatives like string literals (`\"abc\"`), `Symbol(\"abc\")`, or quoted expressions (`'{abc}`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/A1-deprecated.md#_snippet_0\n\nLANGUAGE: Command Line\nCODE:\n```\nscalac Test.scala\n-- Error: Test.scala:1:25 ------------------------------------------------------------------------------------------------\n\n1 |@main def test = println('abc)\n  |                         ^\n  |                         symbol literal 'abc is no longer supported,\n  |                         use a string literal \"abc\" or an application Symbol(\"abc\") instead,\n  |                         or enclose in braces '{abc} if you want a quoted expression.\n  |                         For now, you can also `import language.deprecated.symbolLiterals` to accept\n  |                         the idiom, but this possibility might no longer be available in the future.\n1 error found\n```\n\n----------------------------------------\n\nTITLE: Examples of Illegal Scala 3 Type Definitions\nDESCRIPTION: Highlights incorrect type member definitions causing compile-time errors such as recursive type aliases, self-referential bounds, and incomplete type constructor applications. It emphasizes the need for proper type parameterization and bounded subtype-supertype relationships in type definitions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\ntype Abs = Comparable[Abs]      // recursive type alias\n\ntype S <: T                     // S, T are bounded by themselves.\ntype T <: S\n\ntype T >: Comparable[T.That]    // Cannot select from T.\n                                // T is a type, not a value\ntype MyCollection <: Iterable   // The reference to the type constructor\n                                // Iterable must explicitly state its type arguments.\n```\n\n----------------------------------------\n\nTITLE: Complete State Machine with Erased Evidence in Scala\nDESCRIPTION: Full implementation of a state machine using erased context parameters for compile-time state validation without runtime overhead.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.implicitNotFound\n\nsealed trait State\nfinal class On extends State\nfinal class Off extends State\n\n@implicitNotFound(\"State must be Off\")\nclass IsOff[S <: State]\nobject IsOff:\n  // will not be called at runtime for turnedOn, the\n  // compiler will only require that this evidence exists\n  given IsOff[Off] = new IsOff[Off]\n\n@implicitNotFound(\"State must be On\")\nclass IsOn[S <: State]\nobject IsOn:\n  // will not exist at runtime, the compiler will only\n  // require that this evidence exists at compile time\n  erased given IsOn[On] = new IsOn[On]\n\nclass Machine[S <: State] private ():\n  // ev will disappear from both functions\n  def turnedOn(using erased ev: IsOff[S]): Machine[On] = new Machine[On]\n  def turnedOff(using erased ev: IsOn[S]): Machine[Off] = new Machine[Off]\n\nobject Machine:\n  def newMachine(): Machine[Off] = new Machine[Off]\n\n@main def test =\n  val m = Machine.newMachine()\n  m.turnedOn\n  m.turnedOn.turnedOff\n\n  // m.turnedOff\n  //            ^\n  //            State must be On\n\n  // m.turnedOn.turnedOn\n  //                    ^\n  //                    State must be Off\n```\n\n----------------------------------------\n\nTITLE: Defining the `Typeable` Alias for `TypeTest` in Scala Reflect\nDESCRIPTION: Introduces the `scala.reflect.Typeable[T]` type alias. This alias simplifies the common use case of `TypeTest[Any, T]`, making it easier to use in context bounds for generic functions that need to perform type tests.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/type-test.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.reflect\n\ntype Typeable[T] = TypeTest[Any, T]\n```\n\n----------------------------------------\n\nTITLE: Returning a Closure That May Escape an Exception Capability in Scala\nDESCRIPTION: This snippet defines a function escaped that returns a closure (() => Double) potentially throwing a LimitExceeded exception due to its body involving a computation that can throw. The example shows how the try/catch expression attempts to protect the result, but escape checking will reject this code since the returned closure could be called outside the intended scope, possibly leading to an unhandled checked exception. The code demonstrates the interplay of capability and exception checking in Scala 3 when using the saferExceptions feature.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\ndef escaped(xs: Double*): (() => Double) throws LimitExceeded =\n  try () => xs.map(f).sum\n  catch case ex: LimitExceeded => () => -1\nval crasher = escaped(1, 2, 10e+11)\ncrasher()\n```\n\n----------------------------------------\n\nTITLE: Extending Java Enum Scala\nDESCRIPTION: Shows how to make a Scala 3 enum compatible with Java by having it extend `java.lang.Enum`. This allows the enum to be used from Java code and provides access to Java enum methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/enums/enums.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color extends Enum[Color]:\n  case Red, Green, Blue\n```\n\n----------------------------------------\n\nTITLE: Setting up Quote Reflection in a Macro\nDESCRIPTION: Shows how to set up reflection capabilities in a Scala 3 macro by adding an implicit Quotes parameter and importing quotes.reflect.* to access reflection APIs.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/reflection.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.quoted.*\n\ninline def natConst(inline x: Int): Int = ${natConstImpl('{x})}\n\ndef natConstImpl(x: Expr[Int])(using Quotes): Expr[Int] =\n  import quotes.reflect.*\n  ...\n```\n\n----------------------------------------\n\nTITLE: Defining the runtimeChecked Extension Method in Predef\nDESCRIPTION: Shows the implementation of the `runtimeChecked` extension method within `scala.Predef`. This `inline` method takes any value `x` of type `T` and returns it unchanged but with its type refined by the `@RuntimeChecked` annotation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/runtimeChecked.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\n\nimport scala.annotation.internal.RuntimeChecked\n\nobject Predef:\n  ...\n  extension [T](x: T)\n    inline def runtimeChecked: x.type @RuntimeChecked =\n      x: @RuntimeChecked\n```\n\n----------------------------------------\n\nTITLE: Defining Core Scala Expression Grammar (EBNF)\nDESCRIPTION: Provides the Extended Backus-Naur Form (EBNF) rules for the main Scala expression syntax, including lambdas, conditionals, loops, exception handling, assignments, selections, and postfix/infix/prefix expressions. It defines the structure of complex expressions based on simpler forms.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nExpr         ::=  (Bindings | id | ‘_’) ‘=>’ Expr\n               |  Expr1\nExpr1        ::=  ‘if’ ‘(’ Expr ‘)’ {nl} Expr [[semi] ‘else’ Expr]\n               |  ‘if‘ Expr ‘then‘ Expr [[semi] ‘else’ Expr]\n               |  ‘while’ ‘(’ Expr ‘)’ {nl} Expr\n               |  ‘while’ Expr ‘do’ Expr\n               |  ‘try’ Expr [Catches] [‘finally’ Expr]\n               |  ‘for’ (‘(’ Enumerators ‘)’ | ‘{’ Enumerators ‘}’) {nl} [‘do‘ | ‘yield’] Expr\n               |  ‘for’ Enumerators (‘do‘ | ‘yield’) Expr\n               |  ‘throw’ Expr\n               |  ‘return’ [Expr]\n               |  [SimpleExpr ‘.’] id ‘=’ Expr\n               |  SimpleExpr1 ArgumentExprs ‘=’ Expr\n               |  PostfixExpr\n               |  PostfixExpr Ascription\nPostfixExpr  ::=  InfixExpr [id [nl]]\nInfixExpr    ::=  PrefixExpr\n               |  InfixExpr id [nl] InfixExpr\n               |  InfixExpr MatchClause\nPrefixExpr   ::=  [‘-’ | ‘+’ | ‘~’ | ‘!’] SimpleExpr\nSimpleExpr   ::=  ‘new’ (ClassTemplate | TemplateBody)\n               |  BlockExpr\n               |  SimpleExpr ‘.’ MatchClause\n               |  SimpleExpr1 [‘_’]\nSimpleExpr1  ::=  Literal\n               |  Path\n               |  ‘_’\n               |  ‘(’ [Exprs] ‘)’\n               |  SimpleExpr ‘.’ id\n               |  SimpleExpr TypeArgs\n               |  SimpleExpr1 ArgumentExprs\n               |  XmlExpr\nExprs        ::=  Expr {‘,’ Expr}\nMatchClause  ::=  ‘match’ ‘{’ CaseClauses ‘}’\nBlockExpr    ::=  ‘{’ CaseClauses ‘}’\n               |  ‘{’ Block ‘}’\nBlock        ::=  BlockStat {semi BlockStat} [ResultExpr]\nResultExpr   ::=  Expr1\n               |  (Bindings | ([‘implicit’] id | ‘_’) ‘:’ CompoundType) ‘=>’ Block\nAscription   ::=  ‘:’ InfixType\n               |  ‘:’ Annotation {Annotation}\n               |  ‘:’ ‘_’ ‘*’\nCatches      ::=  ‘catch‘ (Expr | ExprCaseClause)\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala `EmptyTuple`\nDESCRIPTION: Defines the `scala.EmptyTuple` type alias and the corresponding `case object EmptyTuple`. This represents a tuple with zero elements and extends the `Tuple` trait.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n/** A tuple of 0 elements. */\ntype EmptyTuple = EmptyTuple.type\n\n/** A tuple of 0 elements. */\ncase object EmptyTuple extends Tuple:\n  override def toString(): String = \"()\"\n```\n\n----------------------------------------\n\nTITLE: Handling cases where 'DerivingType' has fewer parameters than the lambda\nDESCRIPTION: This snippet explains the scenario where 'DerivingType' has fewer parameters than expected by the type lambda, and demonstrates using only the rightmost parameters to match the 'DerivingType' arguments, facilitating partial application in complex derivations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ngiven TC[ [A_1, ..., A_K] =>> DerivingType[A_{K-N+1}, ..., A_K] ] = TC.derived\n```\n\n----------------------------------------\n\nTITLE: Illegal Reference to Erased Class in Scala\nDESCRIPTION: Demonstrates a compile error that occurs when trying to reference an erased class from a non-erased context.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval err: Any = CanRead() // error: illegal reference to erased class CanRead\n```\n\n----------------------------------------\n\nTITLE: Scala Recursive Instance Summoning Helpers\nDESCRIPTION: Provides helper `inline` functions (`summonInstances`, `deriveOrSummon`, `deriveRec`) to recursively gather `Eq` instances for the constituent types (`Elems`) of an ADT. `summonInstances` iterates tuple types. `deriveOrSummon` checks if an element is the parent type `T` to prevent infinite recursion by using `deriveRec` (which calls `Eq.derived`) or by calling `summonInline` to find an existing instance. Requires intrinsics like `erasedValue` and `summonInline`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/derivation.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ninline def summonInstances[T, Elems <: Tuple]: List[Eq[?]] = \n  inline erasedValue[Elems] match\n    case _: (elem *: elems) => deriveOrSummon[T, elem] :: summonInstances[T, elems]\n    case _: EmptyTuple => Nil\n\ninline def deriveOrSummon[T, Elem]: Eq[Elem] = \n  inline erasedValue[Elem] match\n    case _: T => deriveRec[T, Elem]\n    case _    => summonInline[Eq[Elem]]\n\ninline def deriveRec[T, Elem]: Eq[Elem] = \n  inline erasedValue[T] match\n    case _: Elem => error(\"infinite recursive derivation\")\n    case _       => Eq.derived[Elem](using summonInline[Mirror.Of[Elem]]) // recursive derivation\n```\n\n----------------------------------------\n\nTITLE: Defining Dependent Function Types by Desugaring to FunctionN - Scala\nDESCRIPTION: Describes how dependent function types in Scala 3 are implemented by desugaring to refinement types of scala.FunctionN, which define apply methods with dependent result types. The snippet conceptually shows how a dependent function type of arity N translates into a FunctionN subclass with an apply method. The key aspect is the least upper approximation of the result type without value references. This snippet is conceptual and does not include runnable code, illustrating the underlying type transformation mechanism.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/dependent-function-types-spec.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nFunctionN[K1, ..., Kn, R']:\n  def apply(x1: K1, ..., xN: KN): R\n```\n\n----------------------------------------\n\nTITLE: Expanded Representation of Top-Level Opaque Types in Synthetic Package Object\nDESCRIPTION: Clarifies the underlying representation produced by Scala when compiling top-level opaque types, showing that such definitions are placed in synthetic package objects. Assignment outside the original declaration scope (e.g., in 'obj') results in a type error, reinforcing how source file and object boundaries govern opaque alias visibility. This code mirrors the example for educational completeness.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/other-new-features/opaques.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nobject test1$package:\n  opaque type A = String\n  val x: A = \"abc\"\n\nobject obj:\n  val y: A = \"abc\"  // error: cannot assign \"abc\" to opaque type alias A\n```\n\n----------------------------------------\n\nTITLE: Desugaring Parameterized Abstract Type Members in Scala 3\nDESCRIPTION: Illustrates how parameterized abstract type members are transformed into unparameterized abstract types with type lambdas representing the original type parameters and their bounds. Dependencies include understanding Scala's higher-kinded types and variance inference. The snippet shows separate cases for when lower bound L conforms to `Nothing` and when it does not, affecting the structure of resulting type lambdas.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ntype ´t´[´\\mathit{tps}¬¬´] >: ´L´ <: ´H´\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype ´t´ >: Nothing\n       <: [´\\mathit{tps'}¬¬´] =>> ´H´\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype ´t´ >: [´\\mathit{tps'}¬¬´] =>> ´L´\n       <: [´\\mathit{tps'}¬¬´] =>> ´H´\n```\n\n----------------------------------------\n\nTITLE: Name-Based Match Extractor with Always Failing Example in Scala\nDESCRIPTION: Shows how to build name-based match extractors using isEmpty/get returning a custom object with named (_1, _2) members. The provided code always fails to match, illustrating form rather than practical use. Requires implementing wrapper objects with appropriate val/def members. Input is a string; output is a match on (_1, _2) or fallback. Limitation: This specific AlwaysEmpty example always returns isEmpty = true, so pattern never matches.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/pattern-matching.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject MyPatternMatcher:\n  def unapply(s: String) = AlwaysEmpty\n\nobject AlwaysEmpty:\n  def isEmpty = true\n  def get = NameBased\n\nobject NameBased:\n  def _1: Int = ???\n  def _2: String = ???\n\n\"\" match\n  case MyPatternMatcher(_, _) => ???\n  case _ => ()\n```\n\n----------------------------------------\n\nTITLE: Function Instance Creation for Pattern Matching Anonymous Functions\nDESCRIPTION: Shows how a pattern matching anonymous function is further desugared into an instance creation expression of Function when the expected type is Function.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nnew scala.Function´k´[´S_1, ..., S_k´, ´T´] {\n  def apply(´x_1: S_1, ..., x_k: S_k´): ´T´ = (´x_1, ..., x_k´) match {\n    case ´p_1´ => ´b_1´ ... case ´p_n´ => ´b_n´\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Polymorphic Method Type Inference in Scala 3\nDESCRIPTION: Demonstrates Scala definitions for generic methods using type parameters (with and without bounds) and shows their inferred polymorphic method types (poly types). This illustrates how type parameters and bounds are represented in the type signature.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_39\n\nLANGUAGE: scala\nCODE:\n```\ndef empty[A]: List[A]\ndef union[A <: Comparable[A]] (x: Set[A], xs: Set[A]): Set[A]\n```\n\nLANGUAGE: scala\nCODE:\n```\nempty : [A >: Nothing <: Any] List[A]\nunion : [A >: Nothing <: Comparable[A]] (x: Set[A], xs: Set[A]) Set[A]\n```\n\n----------------------------------------\n\nTITLE: Enabling Ad-Hoc Extensions in Scala\nDESCRIPTION: Illustrates how to explicitly enable the `adhocExtensions` language feature in Scala using an import statement. This allows extending classes that are not marked `open` or `final`, opting into potentially fragile extensions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/open-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.adhocExtensions\n```\n\n----------------------------------------\n\nTITLE: Representing Existential Types in Scala 3 Using Wildcards Scala\nDESCRIPTION: Shows how Scala 3 interprets existential types from Scala 2 when expressed using wildcards instead of 'forSome'. The example uses a Map with a wildcard upper bound for the key type and a concrete Int for the value type, demonstrating the approximation of existential types with refined types. No additional dependencies are required beyond Scala standard library. The input is a Scala 2 existential type expression, and the output is its Scala 3 refined type approximation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/A2-scala-2-compatibility.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nMap[_ <: AnyRef, Int]\n```\n\n----------------------------------------\n\nTITLE: Expansion of Value Definitions with Multi-Variable Patterns in Scala\nDESCRIPTION: Shows how a Scala value definition `val p = e` is expanded when the pattern `p` binds multiple variables (`x_1, ..., x_n`). The expansion involves matching `e` against `p` to extract the variables into a tuple assigned to a fresh temporary name (`\\$x`), followed by individual `val` definitions extracting each variable from the tuple.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval ´\\$x´ = ´e´ match {case ´p´ => (´x_1, ..., x_n´)}\nval ´x_1´ = ´\\$x´._1\n...\nval ´x_n´ = ´\\$x´._n\n```\n\n----------------------------------------\n\nTITLE: Declaring a List of Tuples in Scala\nDESCRIPTION: Defines a variable `xs` as an immutable list containing pairs (tuples) of integers. This serves as the input data for subsequent mapping examples.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/parameter-untupling.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval xs: List[(Int, Int)]\n```\n\n----------------------------------------\n\nTITLE: Typed Expression Example in Scala3 - Scala\nDESCRIPTION: Example showing legal and illegal typed expressions. Literals such as `1: Int` and `1: Long` are valid typed expressions, while `1: string` (using lowercase 'string') is illegal because it does not conform to Scala's type system.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\n1: Int               // legal, of type Int\n1: Long              // legal, of type Long\n// 1: string         // ***** illegal\n```\n\n----------------------------------------\n\nTITLE: Enabling Macro and Compiler Checks in Scala 3\nDESCRIPTION: Enable Scala 3 compiler flags `-Xcheck-macros` and optionally `-Ycheck:all` to activate runtime checks that help identify issues within macro implementations. `-Xcheck-macros` is recommended for all macro development, while `-Ycheck:all` enables broader compiler checks.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/debug-macros.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-Xcheck-macros\n-Ycheck:all\n```\n\n----------------------------------------\n\nTITLE: Shell Commands for Cleaning and Managing Build Artifacts\nDESCRIPTION: This section provides shell commands for cleaning up build artifacts and untracked files in Scala 3 projects. 'rm -rv' removes generated class files and tasty files, while 'git clean -fdx' performs a comprehensive cleanup of all untracked files, ensuring a fresh build environment.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/cheatsheet.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nrm -rv *.tasty *.class out || true\n```\n\nLANGUAGE: Shell\nCODE:\n```\ngit clean -fdx\n```\n\n----------------------------------------\n\nTITLE: Defining Methods and Functions with Erased Parameters in Scala\nDESCRIPTION: Shows how to define methods and lambda functions with erased parameters that will be removed at runtime but checked at compile time.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef methodWithErasedEv(erased ev: Ev): Int = 42\n\nval lambdaWithErasedEv: erased Ev => Int =\n  (erased ev: Ev) => 42\n```\n\n----------------------------------------\n\nTITLE: Adding an Enum Case (Before Deprecation) in Scala\nDESCRIPTION: Shows adding a new `Pluto` case to the `Planet` enum as part of a diff, setting the stage for demonstrating deprecation in a subsequent step.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/enums/enums.md#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\n enum Planet(mass: Double, radius: Double):\n   ...\n   case Neptune extends Planet(1.024e+26, 2.4746e7)\n+  case Pluto   extends Planet(1.309e+22, 1.1883e3)\n end Planet\n```\n\n----------------------------------------\n\nTITLE: Successful Instantiation of Generic Set with Captured Functions in Scala 3\nDESCRIPTION: Demonstrates how changing the type parameter to a function type annotated with reach capabilities `x` and `xs*` allows successful instantiation of a generic Set, illustrating how capture-aware types enable more flexible but safe generic type arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef cons(x: Proc, xs: Set[Proc]): Set[() ->{x,xs*} Unit] =\n  Set.include[() ->{x,xs*} Unit](x, xs) // ok\n```\n\n----------------------------------------\n\nTITLE: Quote Pattern Matching using Quotes and QuoteMatching Traits\nDESCRIPTION: Explains pattern matching on quoted expressions via `QuoteMatching`, which provides `ExprMatch` and `TypeMatch` extractors for quote patterns. Patterns are encoded as tuples and embedded in expressions, enabling compiler-generated pattern matching and extraction logic for macros.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Quotes:\n  self: runtime.QuoteMatching & ...  =>\n  ...\n\ntrait QuoteMatching:\n  object ExprMatch:\n    def unapply[TypeBindings <: Tuple, Tup <: Tuple](scrutinee: Expr[Any])(using pattern: Expr[Any]): Option[Tup] = ...\n  object TypeMatch:\n    ... \n```\n\n----------------------------------------\n\nTITLE: Abstract Implicit Def in Scala 2 - Scala\nDESCRIPTION: Declares an abstract implicit def symDecorator returning SymDecorator in Scala 2. The implementation is deferred to subclasses or concrete definitions. Used to enable implicit decoration of symbols, requires SymDecorator type.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/relationship-implicits.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def symDecorator: SymDecorator\n```\n\n----------------------------------------\n\nTITLE: Utility Methods in the Scala 3 `Expr` Companion Object\nDESCRIPTION: Details the static utility methods provided by the `Expr` companion object for working with `Expr` instances. These include `apply`/`unapply` for easy use with `ToExpr`/`FromExpr` typeclasses, `betaReduce` for expression simplification, `summon` for retrieving implicit `Expr` instances, and methods like `block`, `ofSeq`, `ofList`, `ofTupleFromSeq`, `ofTuple` for constructing `Expr` values from collections or tuples. Most methods require an implicit `Quotes` instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject Expr:\n  def apply[T](x: T)(using ToExpr[T])(using Quotes): Expr[T] = ...\n  def unapply[T](x: Expr[T])(using FromExpr[T])(using Quotes): Option[T] = ...\n  def betaReduce[T](e: Expr[T])(using Quotes): Expr[T] = ...\n  def summon[T: Type](using Quotes): Option[Expr[T]] = ...\n  def block[T](stats: List[Expr[Any]], e: Expr[T])(using Quotes): Expr[T] = ...\n  def ofSeq[T: Type](xs: Seq[Expr[T]])(using Quotes): Expr[Seq[T]] = ...\n  def ofList[T: Type](xs: Seq[Expr[T]])(using Quotes): Expr[List[T]] = ...\n  def ofTupleFromSeq(xs: Seq[Expr[Any]])(using Quotes): Expr[Tuple] = ...\n  def ofTuple[T <: Tuple: Tuple.IsMappedBy[Expr]: Type](tup: T)(using Quotes):\n      Expr[Tuple.InverseMap[T, Expr]] = ...\n```\n\n----------------------------------------\n\nTITLE: Implementing summonAll using summonInline in Scala\nDESCRIPTION: Defines an inline helper function `summonAll` that recursively collects `Eq` instances for each type in a tuple `T`. It uses `erasedValue` and `inline match` for compile-time recursion over the tuple structure and `summonInline` to materialize each element's `Eq` instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ninline def summonAll[T <: Tuple]: List[Eq[_]] =\n  inline erasedValue[T] match\n    case _: EmptyTuple => Nil\n    case _: (t *: ts) => summonInline[Eq[t]] :: summonAll[ts]\n```\n\n----------------------------------------\n\nTITLE: Expanded Summon Call for Non-Recursive By-Name Parameter\nDESCRIPTION: Shows the expanded code generated by the compiler for the `summon[Codec[Option[Int]]]` call from the first example. It demonstrates how the `optionCodec` is applied with the `intCodec` supplied via a `using` clause. Since the synthesized argument `optionCodec[Int](using intCodec)` is not recursive, no local `given` definition (as described in the synthesis steps) was necessary.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/by-name-context-parameters.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval s = summon[Test.Codec[Option[Int]]](\n  using optionCodec[Int](using intCodec)\n)\n```\n\n----------------------------------------\n\nTITLE: Using the 'consume' Modifier for Capabilities in Scala\nDESCRIPTION: Illustrates the `consume` modifier on parameters and methods. When applied to a parameter (e.g., `consume x: T`), it implies the parameter type captures `^` (e.g., `T^`) and signifies that the capability associated with the argument is consumed (made permanently inaccessible) upon calling the method. Examples include channel sending, buffer operations, and iterator methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends Capability\n\nclass Channel[T]:\n  def send(consume x: T)\n\nclass Buffer[+T] extends Mutable:\n  consume def append(x: T): Buffer[T]^\n\n// Example calls\nb.append(x)\nb1.append(y)\n\ndef concat[T](consume buf1: Buffer[T]^, buf2: Buffer[T]): Buffer[T]^\n\nclass Iterator[T]:\n  consume def filter(p: T => Boolean): Iterator[T]^\n  consume def exists(p: T => Boolean): Boolean\n```\n\n----------------------------------------\n\nTITLE: Scala 2 Auto-Application Example\nDESCRIPTION: Illustrates how Scala 2 automatically inserted an empty argument list `()` when calling a nullary method defined with `()`. This implicit expansion is no longer standard behavior in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/auto-apply.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef next(): T = ...\nnext     // is expanded to next()\n```\n\n----------------------------------------\n\nTITLE: Adding a Procedure with Combined Reach Capabilities in Scala 3\nDESCRIPTION: Illustrates a function `addOneProc` that creates a list containing a procedure with combined reach capabilities `x` and `xs*`. The example shows how the function type is widened to a non-dependent capture set, demonstrating flexibility in capture set typing.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef addOneProc(xs: List[Proc]): List[Proc] =\n  def x: Proc = () => write(\"hello\")\n  val result: List[() ->{x, xs*} Unit] = x :: xs\n  result // OK, we can widen () ->{x, xs*} Unit to cap here.\n```\n\n----------------------------------------\n\nTITLE: Setting Scala Version in build.sbt for Local Dotty Testing - Bash\nDESCRIPTION: Shows how to set the Scala version in a test project's build.sbt file to the local Dotty snapshot version after publishing it locally. The dotty-version string is obtained from the project’s Build.scala file.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/getting-started.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nThisBuild / scalaVersion := \"<dotty-version>-bin-SNAPSHOT\"\n```\n\n----------------------------------------\n\nTITLE: Comparing Scala Implicit Value and Implicit Conversion Definitions\nDESCRIPTION: Demonstrates two Scala `implicit def` definitions to highlight syntactic ambiguity. `i1` defines a conditional implicit value (common in type classes) requiring an implicit parameter `x` of type `T`. `i2` defines an implicit conversion from type `T` to `C[T]`. The example illustrates how similar syntax can represent vastly different concepts (a key criticism leading to Scala 3's redesign), with conditional values being fundamental and conversions often discouraged.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/contextual.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimplicit def i1(implicit x: T): C[T] = ...\nimplicit def i2(x: T): C[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Example Illustrating Same-Erasure Restriction in Structural Types in Scala\nDESCRIPTION: This snippet shows a type system limitation where subtyping with structural refinements requires parameter types to have the same erasure. The example with class Sink demonstrates that a refined type requiring def put(x: String): Unit is not subtype-compatible if Sink's method put erases the parameter to Object. This enforces runtime compatibility for reflection-driven calls and avoids runtime errors due to method signature mismatches.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/changed-features/structural-types-spec.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Sink[A] { def put(x: A): Unit = {} }\nval a = Sink[String]()\nval b: { def put(x: String): Unit } = a  // error\nb.put(\"abc\") // looks for a method with a `String` parameter\n```\n\n----------------------------------------\n\nTITLE: Compiler Printer Settings Definition - Scala\nDESCRIPTION: Lists various Boolean and Int setting definitions employed by the Scala 3 compiler for controlling debug output and tree printing behavior. Each setting specifies a CLI flag, a description, and occasionally an abbreviation. These settings are defined in 'ScalaSettings.scala' and allow fine-grained control of compiler output, positions, unique IDs, symbol information, and more.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval printLines        = BooleanSetting(\"-print-lines\"        , \"Show source code line numbers.\") withAbbreviation \"--print-lines\"\nval uniqid            = BooleanSetting(\"-uniqid\"             , \"Uniquely tag all identifiers in debugging output.\") withAbbreviation \"--unique-id\"\nval XprintInline      = BooleanSetting(\"-Xprint-inline\"      , \"Show  where inlined code comes from\")\nval XprintTypes       = BooleanSetting(\"-Xprint-types\"       , \"Print tree types (debugging option).\")\nval Ydebug            = BooleanSetting(\"-Ydebug\"             , \"Increase the quantity of debugging output.\")\nval YdebugFlags       = BooleanSetting(\"-Ydebug-flags\"       , \"Print all flags of definitions\")\nval YdebugMissingRefs = BooleanSetting(\"-Ydebug-missing-refs\", \"Print a stacktrace when a required symbol is missing\")\nval YdebugNames       = BooleanSetting(\"-Ydebug-names\"       , \"Show internal representation of names\")\nval YdebugPos         = BooleanSetting(\"-Ydebug-pos\"         , \"Show full source positions including spans\")\nval YdebugTrace       = BooleanSetting(\"-Ydebug-trace\"       , \"Trace core operations\")\nval YdebugTreeWithId  = IntSetting    (\"-Ydebug-tree-with-id\", \"Print the stack trace when the tree with the given id is created\", Int.MinValue)\nval YprintDebug       = BooleanSetting(\"-Yprint-debug\"       , \"when printing trees, print some extra information useful for debugging.\")\nval YprintDebugOwners = BooleanSetting(\"-Yprint-debug-owners\", \"when printing trees, print owners of definitions.\")\nval YprintPos         = BooleanSetting(\"-Yprint-pos\"         , \"show tree positions.\")\nval YprintPosSyms     = BooleanSetting(\"-Yprint-pos-syms\"    , \"show symbol definitions positions.\")\nval YprintSyms        = BooleanSetting(\"-Yprint-syms\"        , \"when printing trees print info in symbols instead of corresponding info in trees.\")\nval YshowTreeIds      = BooleanSetting(\"-Yshow-tree-ids\"     , \"Uniquely tag all tree nodes in debugging output.\")\nval YshowVarBounds    = BooleanSetting(\"-Yshow-var-bounds\"   , \"Print type variables with their bounds\")\nval YtestPickler      = BooleanSetting(\"-Ytest-pickler\"      , \"self-test for pickling functionality; should be used with -Ystop-after:pickler\")\n```\n\n----------------------------------------\n\nTITLE: Importing Experimental Language Features in Scala 3\nDESCRIPTION: Examples of experimental features in Scala 3 that can be imported from the scala.language.experimental package. These include erasedDefinitions, fewerBraces, genericNumberLiterals, namedTypeArguments, and saferExceptions. Each feature enables different language capabilities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/overview.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala.language.experimental\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Unpickling: Calling QuoteUnpickler\nDESCRIPTION: Shows the main function call used to reconstruct the quote during unpickling. The `unpickleExpr` method of `QuoteUnpickler` takes the pickled TASTy string, a sequence of types corresponding to type holes, and the combined lambda for evaluating splice holes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nquotes.asInstanceOf[runtime.QuoteUnpickler].unpickleExpr[T](\n  pickled = tasty\"...\",\n  types = Seq(...),\n  holes = (idx: Int, args: Seq[Any]) => idx match ...\n)\n```\n\n----------------------------------------\n\nTITLE: Implicit Resolution Stack and Divergence Detection (Conceptual Summary)\nDESCRIPTION: Provides an in-depth explanation of the Scala 3 compiler's strategy to detect divergence in implicit resolution. Describes how it maintains a stack of ‘open implicit types,’ checks for equivalent types or domination via core type analysis, and manages recursive searches. These mechanisms prevent infinite implicit expansion while allowing controlled recursive definitions via by-name implicit arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/07-implicits.md#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Illustrating a Capability Escape Error with Closures in Scala\nDESCRIPTION: This snippet exemplifies a compile-time error arising from capturing the root capability `cap` in the return type of a closure. The example attempts to assign a closure that writes to a file stream `f` to a `var` declared as `() => Unit`. The capture checker disallows this because mutable variables cannot have universal capture sets, ensuring capabilities do not escape their scope. The snippet highlights how capture sets affect type safety in closures.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nvar loophole: () => Unit = () => ()\nusingLogFile { f =>\n  loophole = () => f.write(0)\n}\nloophole()\n```\n\n----------------------------------------\n\nTITLE: Type Checking Quotes and Splices in Scala 3\nDESCRIPTION: Describes the process of type checking quoted expressions and splices, including handling of staging levels, reference to `Quotes`, and management of nested splices using `nestedSplice`. Ensures correctness of code transformation stages and preserves quote integrity.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef quote[T](x: T): Quotes ?=> Expr[T]\ndef splice[T](x: Quotes ?=> Expr[T]): T\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef nestedSplice[T](q: Quotes)(x: q.Nested ?=> Expr[T]): T\n```\n\n----------------------------------------\n\nTITLE: Desugaring a Quote Pattern Match with Type Variables and Splices in Scala\nDESCRIPTION: This example demonstrates the desugaring of a quote pattern match that includes both type variables (`type t`) and splices (`$xs`). The type variable `t` is captured as a `Type[t]` and included in both the `TypeBindings` type parameter and the result tuple pattern `(using t, xs)`. The splice `$xs` is captured as `Expr[List[t]]`. The `using p` parameter holds the transformed pattern with fresh type variables and `pat` markers. The `using` keyword for the type variable capture `t` makes it implicitly available in this case branch scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n  case '{ type t; ($xs: List[t]).map[t](identity[t]) } =>\n// is elaborated to\n  case ExprMatch[(t), (Type[t], Expr[List[t]])]((using t, xs))(using p) =>\n//               ^^^  ^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^\n//     type bindings        result type            pattern     expression\n// p = '{ @patternType type u; pat[List[u]]().map[u](identity[u]) }\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Quote After Splice Normalization\nDESCRIPTION: Illustrates the transformation of a Scala 3 quote after splice normalization. Each splice is replaced by an explicit application of a lambda that captures the arguments from the surrounding quote, ensuring arguments refer only to variables defined within the quote.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\n'{\n  val (x, n): (Double, Int) = (5, 2)\n  ${\n    ((y: Expr[Double], m: Expr[Int]) => powerCode(y, m)).apply('x, 'n)\n  } * ${\n    ((m: Expr[Int]) => powerCode('{2}, m)).apply('n)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Compiler Plugins with scalac - Shell Command\nDESCRIPTION: This command demonstrates how to include multiple compiler plugins when invoking the Scala 3 compiler (`scalac`). By specifying multiple `-Xplugin:` options, each pointing to a separate plugin `.jar`, the compiler can load and apply these extensions when compiling the target Scala source file. Each plugin jar must be properly packaged and built beforehand; the plugin discovery relies on the correct internal plugin metadata structure.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/changed-features/compiler-plugins.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nscalac -Xplugin:pluginA.jar -Xplugin:pluginB.jar Test.scala\n```\n\n----------------------------------------\n\nTITLE: Enabling erased definitions with language import in Scala 3\nDESCRIPTION: Shows how to enable the experimental.erasedDefinitions language feature using an import statement, which is required to use the 'erased' modifier.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.experimental.erasedDefinitions\n```\n\n----------------------------------------\n\nTITLE: Running All Debug Tests - Scala 3 Compiler - Bash\nDESCRIPTION: This command-line snippet shows how to execute all debug tests in the Scala 3 compiler project. The sbt (Scala Build Tool) command invokes the DebugTests test suite, which attaches a debugger and verifies predefined debug scenarios. Dependencies include the sbt tool and having the project compiled.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsbt 'scala3-compiler/testOnly dotty.tools.debug.DebugTests'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Improved Match Type Error Reporting - Scala\nDESCRIPTION: This Scala snippet illustrates the enhanced error reporting for match types that fail to reduce as expected. It defines a match type `M[X]` that should resolve to `Int` for `A` and `String` for `B`. Assigning a value of type `M[B]` to a `String` variable triggers the improved diagnostic, explaining why the reduction failed and couldn't advance to the matching case.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2021-06-07-scala3.0.1-rc1-release.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait A\ntrait B\ntype M[X] = X match\n  case A => Int\n  case B => String\nval x: String = ??? : M[B] // error\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Dotty Project with sbt\nDESCRIPTION: Command to create a new Dotty project using sbt 1.1.5 or newer, which sets up a project with Dotty as the compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-07-06-ninth-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nsbt new lampepfl/dotty.g8\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Parameter Clauses in Scala 3\nDESCRIPTION: Examples of illegal type parameter clauses that violate Scala's rules for type parameter bounds and relationships.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\n[A >: A]                  // illegal, `A' has itself as bound\n[A <: B, B <: C, C <: A]  // illegal, `A' has itself as bound\n[A, B, C >: A <: B]       // illegal lower bound `A' of `C' does\n                          // not conform to upper bound `B'.\n```\n\n----------------------------------------\n\nTITLE: Setting up a Scala 3 Staging Project with sbt\nDESCRIPTION: Shows the sbt command to create a new Scala 3 project pre-configured for multi-stage programming using a specific giter8 template. This template includes necessary dependencies and example code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/staging.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsbt new scala/scala3-staging.g8\n```\n\n----------------------------------------\n\nTITLE: Illustrating Invalid Escape of Exception Capability in Closure with Throws Clause in Scala\nDESCRIPTION: This snippet attempts to return closures that throw checked exceptions from a method `escaped`, demonstrating invalid capability escapes. Under the experimental capture checking, such code is rejected because the closure would persist beyond the lifetime of the local capability `CanThrow[LimitExceeded]`. This enforces that capabilities do not escape their valid scopes, preventing unhandled exceptions at runtime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\ndef escaped(xs: Double*): (() => Double) throws LimitExceeded =\n  try () => xs.map(f).sum\n  catch case ex: LimitExceeded => () => -1\nval crasher = escaped(1, 2, 10e+11)\ncrasher()\n```\n\n----------------------------------------\n\nTITLE: Step-In and Next Examples - Scala 3 Debug Test - Plaintext\nDESCRIPTION: This code snippet shows practical examples of both 'step' and 'next' commands in debug scripts, used to control the flow and frame checking during the debugging session. These allow the test runner to verify movement to specific lines or method calls.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\nstep 10\nstep println\nnext 10\nnext println\n```\n\n----------------------------------------\n\nTITLE: Providing FromDigits Instance for BigFloat in Scala\nDESCRIPTION: Defines the required `given` instance of `FromDigits.Floating[BigFloat]` within the `BigFloat` companion object. This instance makes `BigFloat` compatible with generic numeric literals that can have decimal points and exponents. Its `fromDigits` method simply delegates the parsing logic to the `BigFloat.apply(String)` constructor implemented previously.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n  given FromDigits: FromDigits.Floating[BigFloat]:\n    def fromDigits(digits: String) = apply(digits)\nend BigFloat\n```\n\n----------------------------------------\n\nTITLE: Desugaring a Quote Pattern Match with Splices in Scala\nDESCRIPTION: This example shows the compiler's desugaring of a quote pattern match that includes splices (`$f`, `$x`). The splices are captured into a tuple pattern `(f, x)`, and their types are explicitly specified in the `Tup` type parameter of `ExprMatch`. The `using pattern` parameter contains a transformed version of the original pattern where splices are replaced by `pat` markers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n  case '{ ((y: Int) => $f(y)).apply($x) } =>\n// is elaborated to\n  case ExprMatch[.., (Expr[Int => Int], Expr[Int])]((f, x))(using pattern) =>\n// pattern = '{ ((y: Int) => pat[Int](y)).apply(pat[Int]()) }\n```\n\n----------------------------------------\n\nTITLE: Extension Method to Tuple Functions for Arbitrary Arity in Scala\nDESCRIPTION: Provides an extension method named tupled on any function type F with arguments Args (subtype of Tuple) returning R. This method uses an implicit TupledFunction instance to convert the function into a tupled version that accepts a single tuple containing all arguments. The Args tuple type matches the input argument types of the input function F. This approach generalizes Scala's Function1.tupled through Function22.tupled to any arity.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/tupled-function.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n/** Creates a tupled version of this function: instead of N arguments,\\n *  it accepts a single [[scala.Tuple]] with N elements as argument.\\n *\\n *  @tparam F the function type\\n *  @tparam Args the tuple type with the same types as the function arguments of F\\n *  @tparam R the return type of F\\n */\\nextension [F, Args <: Tuple, R](f: F)\\n  def tupled(using tf: TupledFunction[F, Args => R]): Args => R = tf.tupled(f)\n```\n\n----------------------------------------\n\nTITLE: Resolving Overloading Clash with @targetName in Scala\nDESCRIPTION: Demonstrates using the `@targetName(\"f_string\")` annotation to disambiguate two method definitions (`f`) that would otherwise clash due to type erasure of their by-name parameters. This allows both methods to coexist by assigning them different erased names (`f_string` and `f`) in the generated bytecode.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/targetName.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n@targetName(\"f_string\")\ndef f(x: => String): Int = x.length\ndef f(x: => Int): Int = x + 1  // OK\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running TASTy Inspector with Scala Compiler\nDESCRIPTION: Provides shell commands for compiling the Scala source file (`Test.scala`) containing the inspector and its runner, placing the output in the `out` directory. It then shows how to run the compiled code using the `scala` command with the `-with-compiler` flag, which makes the compiler internals (required for TASTy inspection) available at runtime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/tasty-inspect.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nscalac -d out Test.scala\nscala -with-compiler -classpath out Test\n```\n\n----------------------------------------\n\nTITLE: Warning for Redundant Capture Set on Capability Class Parameter\nDESCRIPTION: Illustrates a Scala compiler warning issued when explicitly specifying the capture set `{*}` for a parameter whose type is a capability class (`FileSystem`), as the `@capability` annotation already implies this capture set.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass Logger(using {*} FileSystem):\n                   ^^^^^^^^^^^^^^\n             redundant capture: FileSystem already accounts for *\n```\n\n----------------------------------------\n\nTITLE: Using Leading Symbolic Infix Operators to Combine Values in Scala\nDESCRIPTION: This example shows a symbolic infix operator (e.g., '|') placed as a leading operator on a new line, resulting in a single infix operation. It highlights indentation rules and the requirement to follow the leading operator with at least one whitespace and a valid expression-starting token. No external dependencies beyond Scala 3's syntax rules are required. Inputs: Two values (e.g., 'freezing' and 'boiling'); Output: A result from the infix operation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/changed-features/operators.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n    freezing\n  | boiling\n```\n\n----------------------------------------\n\nTITLE: Polymorphic map Signature Allowing Function to Throw Exceptions - Scala\nDESCRIPTION: Proposes a polymorphic signature for the map method that includes an exception type parameter 'E', indicating the function argument may throw exceptions of type 'E'. This snippet uses a hypothetical type notation 'A throws E' to denote computations that might throw exceptions of type E, and the overall map returns a list that may also throw E. It highlights the complexity and verbosity introduced by this approach, motivating the capability-based alternative.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/canthrow.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef map[B, E](f: A => B throws E): List[B] throws E\n```\n\n----------------------------------------\n\nTITLE: Example Usage Triggering BigFloat Compile-Time Error in Scala\nDESCRIPTION: Provides an example of defining a `BigFloat` variable with a literal value whose exponent is too large. This demonstrates how the compile-time validation implemented via the macro catches the error before runtime.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval x: BigFloat = 1234.45e3333333333\n```\n\n----------------------------------------\n\nTITLE: Scope Management in Scala 3 Macros for Splicing Contexts\nDESCRIPTION: Represents the current macro splicing context as a linked list of Scope objects. Each Scope tracks the position of the splice and references its parent scope, forming a hierarchy to manage nested splices. This structure enforces scope integrity during macro expansion, such as detecting scope extrusions when inserting spliced expressions or types.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass Scope(\n  val position: String, // position of the splice for error reporting\n  val parent: Option[Scope] // reference to enclosing scope\n) {\n  def isSubScopeOf(other: Scope): Boolean = ... // Checks scope hierarchy\n}\n```\n\n----------------------------------------\n\nTITLE: Obsolete Scala 3 Pattern Matching Syntax (M2)\nDESCRIPTION: This snippet shows the pattern matching syntax used in Scala 3.0.0-M2 where the 'as' keyword was used to bind the matched value to a variable, a syntax that is now obsolete.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2020-12-18-scala3-m3.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase opt as Some(foo)\n```\n\n----------------------------------------\n\nTITLE: Example Delegate Instances for Import Demonstration in Scala\nDESCRIPTION: Defines an object containing several example delegate instances of different types. This object serves as the source for demonstrating the `import delegate` syntax that follows, showing which delegates might be imported.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-06-11-16th-dotty-milestone-release.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nobject Delegates {\n  delegate intOrd for Ordering[Int]\n  delegate [T: Ordering] listOrd for Ordering[List[T]]\n  delegate ec for ExecutionContext = ...\n  delegate im for Monoid[Int]\n}\n```\n\n----------------------------------------\n\nTITLE: New, simplified desugaring of for-comprehensions with aliases in Scala\nDESCRIPTION: This snippet reflects the updated compiler desugaring for for-comprehensions that involve aliases but no guards. The generator is directly mapped, and the alias is introduced as a local variable in the same block. This reduces nesting and eliminates unnecessary intermediate structures, enhancing both performance and code clarity.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/preview/better-fors.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndoSth(arg).map { a =>\n  val b = a\n  a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Transformation and Quote Content Encoding\nDESCRIPTION: Describes how quote patterns are transformed into `ExprMatch` extractor calls with tuple patterns and quoted expressions, handling unquotes `${...}`. Demonstrates how HOAS patterns are embedded and how type variables are normalized and declared in pattern matching, ensuring correct pattern extraction and type safety.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros-spec.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ncase '{ 1 } =>\n// is elaborated to\ncase ExprMatch(EmptyTuple)(using '{1}) =>\n```\n\nLANGUAGE: Scala\nCODE:\n```\ncase '{ ((y: Int) => $f(y)).apply($x) } =>\n// is elaborated to\ncase ExprMatch[.., (Expr[Int => Int], Expr[Int])]((f, x))(using pattern) =>\n```\n\n----------------------------------------\n\nTITLE: Breakpoint Step Examples - Scala 3 Debug Test - Plaintext\nDESCRIPTION: These examples illustrate how to set breakpoints for various class names and line numbers in debug test scenarios. The scenarios cover both standard and nested or local classes, demonstrating flexibility when targeting lines for debugging. These lines are placed in .check files.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\nbreak Test$ 5\nbreak example.A 10\nbreak example.A$B$1 12\n```\n\n----------------------------------------\n\nTITLE: Conceptual Expansion of Mutable Variables for Tracking in Scala\nDESCRIPTION: Illustrates how local mutable variables (`var`) are conceptually handled for capability tracking. A `var x: T` is treated as if it were backed by a private `Ref[T]` instance with getter (`x`) and setter (`x_=`) methods, allowing fine-grained tracking of read (`x.rd`) and write (`x`) capabilities.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/exclusive-capabilities.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n// Original mutable variable\nvar x: T = init\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Conceptual expansion for tracking\nval x$ = Ref[T](init)\ndef x = x$.get\nmut def x_=(y: T) = x$.put(y)\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Expressions and Patterns Grammar Definition (EBNF)\nDESCRIPTION: This EBNF block defines the precise syntactic structure for a wide range of Scala 3 constructs, including function literals, conditional statements (if/while), exception handling (try/catch/finally), returns, loops (for), assignments, operator precedence, pattern matching, and various forms of expressions and patterns. Comments within the grammar often suggest the corresponding Abstract Syntax Tree (AST) node types generated during parsing. This grammar serves as a foundational specification for Scala compilers and parsing tools.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/syntax.md#_snippet_4\n\nLANGUAGE: EBNF\nCODE:\n```\nExpr              ::=  FunParams (‘=>’ | ‘?=>’) Expr                            Function(args, expr), Function(ValDef([implicit], id, TypeTree(), EmptyTree), expr)\n                    |  TypTypeParamClause ‘=>’ Expr                             PolyFunction(ts, expr)\n                    |  Expr1\nBlockResult       ::=  FunParams (‘=>’ | ‘?=>’) Block\n                    |  TypTypeParamClause ‘=>’ Block\n                    |  Expr1\nFunParams         ::=  Bindings\n                    |  id\n                    |  ‘_’\nExpr1             ::=  [‘inline’] ‘if’ ‘(’ Expr ‘)’ {nl} Expr [[semi] ‘else’ Expr] If(Parens(cond), thenp, elsep?)\n                    |  [‘inline’] ‘if’  Expr ‘then’ Expr [[semi] ‘else’ Expr]    If(cond, thenp, elsep?)\n                    |  ‘while’ ‘(’ Expr ‘)’ {nl} Expr                           WhileDo(Parens(cond), body)\n                    |  ‘while’ Expr ‘do’ Expr                                   WhileDo(cond, body)\n                    |  ‘try’ Expr Catches [‘finally’ Expr]                      Try(expr, catches, expr?)\n                    |  ‘try’ Expr [‘finally’ Expr]                              Try(expr, Nil, expr?)\n                    |  ‘throw’ Expr                                             Throw(expr)\n                    |  ‘return’ [Expr]                                          Return(expr?)\n                    |  ForExpr\n                    |  [SimpleExpr ‘.’] id ‘=’ Expr                             Assign(expr, expr)\n                    |  PrefixOperator SimpleExpr ‘=’ Expr                       Assign(expr, expr)\n                    |  SimpleExpr ArgumentExprs ‘=’ Expr                        Assign(expr, expr)\n                    |  PostfixExpr [Ascription]\n                    |  ‘inline’ InfixExpr MatchClause\nAscription        ::=  ‘:’ InfixType                                            Typed(expr, tp)\n                    |  ‘:’ Annotation {Annotation}                              Typed(expr, Annotated(EmptyTree, annot)*)\nCatches           ::=  ‘catch’ (Expr | ExprCaseClause)\nPostfixExpr       ::=  InfixExpr [id]                                           PostfixOp(expr, op) -- only if language.postfixOperators is enabled\nInfixExpr         ::=  PrefixExpr\n                    |  InfixExpr id [nl] InfixExpr                              InfixOp(expr, op, expr)\n                    |  InfixExpr id ColonArgument\n                    |  InfixExpr MatchClause\nMatchClause       ::=  ‘match’ <<< CaseClauses >>>                              Match(expr, cases)\nPrefixExpr        ::=  [PrefixOperator] SimpleExpr                              PrefixOp(expr, op)\nPrefixOperator    ::=  ‘-’ | ‘+’ | ‘~’ | ‘!’                                    -- unless backquoted\nSimpleExpr        ::=  SimpleRef\n                    |  Literal\n                    |  ‘_’\n                    |  BlockExpr\n                    |  ExprSplice\n                    |  Quoted\n                    |  quoteId                                                  -- only inside splices\n                    |  ‘new’ ConstrApp {‘with’ ConstrApp} [TemplateBody]        New(constr | templ)\n                    |  ‘new’ TemplateBody\n                    |  ‘(’ ExprsInParens ‘)’                                    Parens(exprs)\n                    |  SimpleExpr ‘.’ id                                        Select(expr, id)\n                    |  SimpleExpr ‘.’ MatchClause\n                    |  SimpleExpr TypeArgs                                      TypeApply(expr, args)\n                    |  SimpleExpr ArgumentExprs                                 Apply(expr, args)\n                    |  SimpleExpr ColonArgument                                 -- under language.experimental.fewerBraces\n                    |  SimpleExpr ‘_’                                           PostfixOp(expr, _) (to be dropped)\n                    |  XmlExpr\t\t\t\t\t\t-- to be dropped\nColonArgument     ::=  colon [LambdaStart]\n                       indent (CaseClauses | Block) outdent\nLambdaStart       ::=  FunParams (‘=>’ | ‘?=>’)\n                    |  TypTypeParamClause ‘=>’\nQuoted            ::=  ‘'’ ‘{’ Block ‘}’\n                    |  ‘'’ ‘[’ TypeBlock ‘]’\nExprSplice        ::= spliceId                                                  -- if inside quoted block\n                    |  ‘$’ ‘{’ Block ‘}’                                        -- unless inside quoted pattern\n                    |  ‘$’ ‘{’ Pattern ‘}’                                      -- when inside quoted pattern\nTypeSplice        ::= spliceId                                                  -- if inside quoted type -- deprecated syntax\n                    |  ‘$’ ‘{’ Block ‘}’                                        -- unless inside quoted type pattern -- deprecated syntax\n                    |  ‘$’ ‘{’ Pattern ‘}’                                      -- when inside quoted type pattern -- deprecated syntax\nExprsInParens     ::=  ExprInParens {‘,’ ExprInParens}\n                    |  NamedExprInParens {‘,’ NamedExprInParens}\nExprInParens      ::=  PostfixExpr ‘:’ Type                                     -- normal Expr allows only RefinedType here\n                    |  Expr\nNamedExprInParens ::=  id '=' ExprInParens\nParArgumentExprs  ::=  ‘(’ [ExprsInParens] ‘)’                          exprs\n                    |  ‘(’ ‘using’ ExprsInParens ‘)’\n                    |  ‘(’ [ExprsInParens ‘,’] PostfixExpr ‘*’ ‘)’              exprs :+ Typed(expr, Ident(wildcardStar))\nArgumentExprs     ::=  ParArgumentExprs\n                    |  BlockExpr\nBlockExpr         ::=  <<< CaseClauses | Block >>>\nBlock             ::=  {BlockStat semi} [BlockResult]                           Block(stats, expr?)\nBlockStat         ::=  Import\n                    |  {Annotation {nl}} {LocalModifier} Def\n                    |  Extension\n                    |  Expr1\n                    |  EndMarker\nTypeBlock         ::=  {TypeBlockStat semi} Type\nTypeBlockStat     ::=  ‘type’ {nl} TypeDef\n\nForExpr           ::=  ‘for’ ‘(’ Enumerators0 ‘)’ {nl} [‘do‘ | ‘yield’] Expr     ForYield(enums, expr) / ForDo(enums, expr)\n                    |  ‘for’ ‘{’ Enumerators0 ‘}’ {nl} [‘do‘ | ‘yield’] Expr\n                    |  ‘for’     Enumerators0          (‘do‘ | ‘yield’) Expr\nEnumerators0      ::=  {nl} Enumerators [semi]\nEnumerators       ::=  Generator {semi Enumerator | Guard}\nEnumerator        ::=  Generator\n                    |  Guard {Guard}\n                    |  Pattern1 ‘=’ Expr                                        GenAlias(pat, expr)\nGenerator         ::=  [‘case’] Pattern1 ‘<-’ Expr                              GenFrom(pat, expr)\nGuard             ::=  ‘if’ PostfixExpr\n\nCaseClauses       ::=  CaseClause { CaseClause }                                Match(EmptyTree, cases)\nCaseClause        ::=  ‘case’ Pattern [Guard] ‘=>’ Block                        CaseDef(pat, guard?, block)   // block starts at =>\nExprCaseClause    ::=  ‘case’ Pattern [Guard] ‘=>’ Expr\nTypeCaseClauses   ::=  TypeCaseClause { TypeCaseClause }\nTypeCaseClause    ::=  ‘case’ (InfixType | ‘_’) ‘=>’ Type [semi]\n\nPattern           ::=  Pattern1 { ‘|’ Pattern1 }                                Alternative(pats)\nPattern1          ::=  PatVar ‘:’ RefinedType                                   Bind(name, Typed(Ident(wildcard), tpe))\n                    |  [‘-’] integerLiteral ‘:’ RefinedType                     Typed(pat, tpe)\n                    |  [‘-’] floatingPointLiteral ‘:’ RefinedType               Typed(pat, tpe)\n                    |  Pattern2\nPattern2          ::=  [id ‘@’] InfixPattern                                    Bind(name, pat)\nInfixPattern      ::=  SimplePattern { id [nl] SimplePattern }                  InfixOp(pat, op, pat)\nSimplePattern     ::=  PatVar                                                   Ident(wildcard)\n                    |  Literal                                                  Bind(name, Ident(wildcard))\n                    |  ‘(’ [Patterns] ‘)’                                       Parens(pats) Tuple(pats)\n                    |  Quoted\n                    |  XmlPattern\t\t\t\t\t\t(to be dropped)\n                    |  SimplePattern1 [TypeArgs] [ArgumentPatterns]\n                    |  ‘given’ RefinedType\nSimplePattern1    ::=  SimpleRef\n                    |  SimplePattern1 ‘.’ id\nPatVar            ::=  varid\n                    |  ‘_’\nPatterns          ::=  Pattern {‘,’ Pattern}\n                    |  NamedPattern {‘,’ NamedPattern}\nNamedPattern      ::=  id '=' Pattern\n\nArgumentPatterns  ::=  ‘(’ [Patterns] ‘)’                                       Apply(fn, pats)\n                    |  ‘(’ [Patterns ‘,’] PatVar ‘*’ ‘)’\n\n```\n\n----------------------------------------\n\nTITLE: Defining Runtime Staging API in Scala\nDESCRIPTION: Defines the `run` and `withQuotes` methods within the `scala.quoted.staging` package. `run` compiles and executes a given staged expression (`Expr[T]`) at runtime, returning a value of type `T`. `withQuotes` provides a `Quotes` context without evaluating the expression. Both require an implicit `Compiler` instance.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/staging.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.quoted.staging\n\ndef run[T](expr: Quotes ?=> Expr[T])(using Compiler): T = ...\n\ndef withQuotes[T](thunk: Quotes ?=> T)(using Compiler): T = ...\n```\n\n----------------------------------------\n\nTITLE: Erased Definitions and Runtime Behavior in Scala\nDESCRIPTION: Explains how erased method and value parameters are removed from the generated bytecode and shows the transformation from source to runtime signature. Erased vals and defs are not present at runtime; providing evidence to erased parameters does not incur runtime cost. The example includes ordinary and erased defs/vals to show their differing runtime existence.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/erased-defs.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n// becomes def methodWithErasedEv(x: Int): Int at runtime\ndef methodWithErasedEv(x: Int, erased ev: Ev): Int = ...\n\ndef evidence1: Ev = ...\nerased def erasedEvidence2: Ev = ... // does not exist at runtime\nerased val erasedEvidence3: Ev = ... // does not exist at runtime\n\n// evidence1 is not evaluated and only `x` is passed to methodWithErasedEv\nmethodWithErasedEv(x, evidence1)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Scope Extrusion via run Method in Scala 3 Macros\nDESCRIPTION: This snippet demonstrates how the `run` method can cause scope extrusion in Scala 3 macros by consuming a quoted variable reference inside a splice. The resulting expression contains references to variables defined in the next stage, which may no longer be in scope in the current context. This example shows the evaluation behavior and how such extrusions are detected and restricted at runtime by the Scala macro system. It requires macro support with staging and runtime checks for quote scopes.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/macros.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\n'{ (x: Int) => ${ run('x); ... } }\n// evaluates to: '{ (x: Int) => ${ x; ... } 1\n\n```\n\n----------------------------------------\n\nTITLE: Illustrating Ill-Typed Quoted Pattern Type Dependency in Scala\nDESCRIPTION: Shows a quoted pattern that is ill-typed because the type variable `A` introduced in the pattern's type signature for `x` (`List[A]`) is not captured in the higher-order pattern `$y(x)`. Highlights the requirement to include dependent types in the higher-order pattern.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/quoted-patterns-with-polymorphic-functions.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase '{ [A] => (x: List[A]) => $y(x) : Int } =>\n```\n\n----------------------------------------\n\nTITLE: Function Composition with Explicit Reach Capabilities in Scala 3\nDESCRIPTION: Defines a generic function `compose1` that composes two functions `f` and `g`, combining their reach capabilities in the resulting function's capture set `{f, g}`. This example highlights how function composition is captured precisely within the modified capture checking system.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/cc/alternatives-to-sealed.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef compose1[A, B, C](f: A => B, g: B => C): A ->{f, g} C =\n  z => g(f(z))\n```\n\n----------------------------------------\n\nTITLE: Defining List contains with lower bound (Scala 2.13)\nDESCRIPTION: Shows the variance-correct definition of the `contains` method used in Scala 2.13. It introduces a lower bound type parameter `U >: T` for the input type to satisfy variance rules, but the text notes that this version still admits exactly the same potentially unsafe applications as the original `Any` version.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/multiversal-equality.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n  def contains[U >: T](x: U): Boolean\n```\n\n----------------------------------------\n\nTITLE: Flow typing support with 'toNotNullTermRef' in Scala's typechecker\nDESCRIPTION: Illustrates how Scala tracks variable nullability during type checking by casting values to more precise types when they are known to be non-null. When typing identity or selection trees, the system checks the 'NotNullInfo' and performs safe casts to enable flow-sensitive type refinement, enabling safe access to non-null members in nullable contexts.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/explicit-nulls.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef f = \n   val l: Node | Null = ???\n   if l != null && l.next != null then\n      val third: l.next.next.type = l.next.next\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Error Output for Invalid BigFloat Literal\nDESCRIPTION: Shows the error message generated by the Scala compiler when the `fromDigitsImpl` macro detects an invalid (too large) `BigFloat` literal during compilation. The error message indicates the location and the specific reason (exponent too large).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n3 |  val x: BigFloat = 1234.45e3333333333\n  |                    ^^^^^^^^^^^^^^^^^^\n  |                    exponent too large: 3333333333\n```\n\n----------------------------------------\n\nTITLE: Capture Tunneling in Generic Scala Classes\nDESCRIPTION: Defines a Pair class parametrized by two types A and B, and shows how capability captures inside instantiated type arguments do not propagate to the capture set of the Pair instance itself. Though Pair(x, y) captures capabilities via its elements, the Pair's capture set is empty at creation, but capabilities reappear when members are accessed, illustrating tunnel-like propagation of captures through generic instantiations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/cc.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nclass Pair[+A, +B](x: A, y: B):\n  def fst: A = x\n  def snd: B = y\n\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef x: Int ->{ct} String\ndef y: Logger^{fs}\ndef p = Pair(x, y)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef p: Pair[Int ->{ct} String, Logger^{fs}] = Pair(x, y)\n```\n\nLANGUAGE: scala\nCODE:\n```\n() => p.fst : () -> Int ->{ct} String\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Pattern Syntax (EBNF)\nDESCRIPTION: Provides the Extended Backus–Naur Form (EBNF) grammar rules defining the overall hierarchical syntax structure for patterns in Scala 3. It outlines the various levels of pattern composition, from the top-level `Pattern` to the foundational `SimplePattern` and the structure for sequences of patterns (`Patterns`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\n  Pattern         ::=  Pattern1 { ‘|’ Pattern1 }\n  Pattern1        ::=  boundvarid ‘:’ TypePat\n                    |  ‘_’ ‘:’ TypePat\n                    |  Pattern2\n  Pattern2        ::=  id [‘@’ Pattern3]\n                    |  Pattern3\n  Pattern3        ::=  SimplePattern\n                    |  SimplePattern {id [nl] SimplePattern}\n  SimplePattern   ::=  ‘_’\n                    |  varid\n                    |  Literal\n                    |  StableId\n                    |  StableId ‘(’ [Patterns] ‘)’\n                    |  StableId ‘(’ [Patterns ‘,’] [id ‘@’] ‘_’ ‘*’ ‘)’\n                    |  ‘(’ [Patterns] ‘)’\n                    |  XmlPattern\n  Patterns        ::=  Pattern {‘,’ Patterns}\n```\n\n----------------------------------------\n\nTITLE: Disallowed Quoted Pattern With Type Bounds in Scala\nDESCRIPTION: Example of a quoted pattern that is *disallowed* by the current experimental implementation because the type parameter `A` has a bound (`<: Int`). Highlights a current limitation of the feature due to unclear typing rules for such cases.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/quoted-patterns-with-polymorphic-functions.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ncase '{ [A <: Int] => (x: List[A]) => $y(x) : Int } => // Disallowed\n```\n\n----------------------------------------\n\nTITLE: Showing Inconsistency in Current Scala Warnings (String vs Int)\nDESCRIPTION: Highlights a limitation in the current Scala compiler's equality warnings. Unlike comparing an `Int` to a `String`, comparing a `String` to an `Int` using `==` does not produce a warning, even though it also always yields `false`, demonstrating the inconsistency the proposal aims to fix.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2016-05-05-multiversal-equality.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> \"abc\" == 1\nres2: Boolean = false\n```\n\n----------------------------------------\n\nTITLE: Printing Compiler Trees after All Phases - Shell\nDESCRIPTION: Uses the '-Xprint:all' flag with 'scalac' to print the state of compiler trees after every compilation phase. The output helps in tracking cumulative transformations and understanding the entire compilation pipeline. Applicable when extensive debugging or analysis of compiler transformation sequences is required.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nscalac -Xprint:all ../issues/Playground.scala\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Syntax for Derives and Extends Clauses\nDESCRIPTION: Provides a simplified BNF-like representation of the Scala 3 syntax for class/enum definitions, highlighting the `InheritClauses` which can include both `extends` and `derives` clauses. It notes the possibility of using commas in `extends` clauses.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/derivation.md#_snippet_15\n\nLANGUAGE: plaintext\nCODE:\n```\nTemplate          ::=  InheritClauses [TemplateBody]\nEnumDef           ::=  id ClassConstr InheritClauses EnumBody\nInheritClauses    ::=  [‘extends’ ConstrApps] [‘derives’ QualId {‘,’ QualId}]\nConstrApps        ::=  ConstrApp {‘with’ ConstrApp}\n                    |  ConstrApp {‘,’ ConstrApp}\n```\n\n----------------------------------------\n\nTITLE: Representation of Scala 3 Methods\nDESCRIPTION: This snippet demonstrates how Scala 3 method signatures, including type parameters, parameters, and return type, are represented internally using PolyType and MethodType. It shows the use of PolyParam objects to refer to type parameters by index, facilitating type inference and checking.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/type-system.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef f[A, B <: Ord[A]](x: A, y: B): Unit\n\nval p = PolyType(List(\"A\", \"B\"))(\n  List(TypeBounds(Nothing, Any),\n       TypeBounds(Nothing,\n         RefinedType(Ordering,\n           scala$math$Ordering$$T, TypeAlias(PolyParam(p, 0))))),\n  m)\n\nval m = MethodType(List(\"x\", \"y\"),\n  List(PolyParam(p, 0), PolyParam(p, 1)))(Unit)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Variable and Wildcard Pattern Syntax (EBNF)\nDESCRIPTION: Defines the EBNF syntax for `SimplePattern` specifically covering variable identifiers (`varid`) and the wildcard symbol (`_`). These are the simplest forms of patterns, used to match any value and bind a variable or ignore the matched value respectively.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_1\n\nLANGUAGE: ebnf\nCODE:\n```\n  SimplePattern   ::=  ‘_’\n                    |  varid\n```\n\n----------------------------------------\n\nTITLE: Handling `Nothing` Lower Bound in Abstract Type Expansion in Scala\nDESCRIPTION: This snippet shows a special case where if the lower bound `L` of a parameterized abstract type is `Nothing`, it's not parameterized in the type lambda expansion. `type T[X] <: X => X` expands to `type T >: Nothing <: ([X] =>> X => X)` because `Nothing` is treated as a universal bottom type, avoiding the potentially less intuitive `([X] =>> Nothing)` lower bound.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/type-lambdas-spec.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntype T[X] <: X => X\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype T >: Nothing <: ([X] =>> X => X)\n```\n\nLANGUAGE: scala\nCODE:\n```\n// instead of\ntype T >: ([X] =>> Nothing) <: ([X] =>> X => X)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Optional Braces Syntax using EBNF\nDESCRIPTION: EBNF grammar rules specifying the syntax for optional braces in Scala 3, primarily used with indentation-based syntax. Defines the `colon`, `<<< ts >>>` (indented block), and `:<<< ts >>>` (colon-prefixed indented block) constructs which allow omitting curly braces in certain contexts.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/13-syntax-summary.md#_snippet_1\n\nLANGUAGE: ebnf\nCODE:\n```\ncolon         ::=  ':'    -- with side conditions explained in 01-literal-syntax.md\n <<< ts >>>   ::=  ‘{’ ts ‘}’\n                |  indent ts outdent\n:<<< ts >>>   ::=  [nl] ‘{’ ts ‘}’\n                |  colon indent ts outdent\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala `String` Concatenation Method\nDESCRIPTION: Illustrates the `+` method supported by Scala's `String` class (typically derived from the host system's String). This method concatenates the string with the textual representation of any other object (`Any`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/12-the-scala-standard-library.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef + (that: Any): String\n```\n\n----------------------------------------\n\nTITLE: Illustrating Complex Left-Hand Sides in Scala Assignments\nDESCRIPTION: This Scala code demonstrates that the expression on the left-hand side of an assignment (`=`) in Dotty can be arbitrarily complex, not just a simple identifier or field selection (`RefTree`). It shows an assignment to a field `s` accessed through a complex block expression involving class definition, a loop, and object instantiation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/dotty-internals-1-notes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait T {\n  var s = 0\n}\n{\n  class T2 extends T\n  while (true) 1\n  new Bla\n}.s = 10\n```\n\n----------------------------------------\n\nTITLE: Erased Classes and Their Auto-Erasure Behavior in Scala\nDESCRIPTION: Demonstrates erased classes and how they automatically cause definitions using them to be treated as erased, including examples of valid and invalid usages.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/erased-defs.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nerased class CanRead\n\nval x: CanRead = ...        // `x` is turned into an erased val\nval y: CanRead => Int = ... // the function is turned into an erased function\ndef f(x: CanRead) = ...     // `f` takes an erased parameter\ndef g(): CanRead = ...      // `g` is turned into an erased def\ngiven CanRead = ...         // the anonymous given is assumed to be erased\n```\n\n----------------------------------------\n\nTITLE: Compiler Expansion of BigFloat Literal (Runtime Check)\nDESCRIPTION: Illustrates the default compiler expansion of a `BigFloat` literal into a method call. Without the macro implementation, this call to `fromDigits` happens at runtime, potentially throwing a `NumberTooLarge` exception.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/numeric-literals.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nBigFloat.FromDigits.fromDigits(\"1e100000000000\")\n```\n\n----------------------------------------\n\nTITLE: Scala Grammar: Literal Syntax Definitions Using EBNF\nDESCRIPTION: This snippet specifies the EBNF grammar rules for the various Scala literal forms, including integer, floating point, boolean, character, string, interpolated strings, and the null literal. It establishes the base syntactic forms used by the parser to recognize literals within Scala code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/01-lexical-syntax.md#_snippet_9\n\nLANGUAGE: EBNF\nCODE:\n```\nLiteral  ::=  [‘-’] integerLiteral\n           |  [‘-’] floatingPointLiteral\n           |  booleanLiteral\n           |  characterLiteral\n           |  stringLiteral\n           |  interpolatedString\n           |  ‘null’\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Literal Pattern Syntax (EBNF)\nDESCRIPTION: Shows the EBNF rule stating that a `Literal` can be used as a `SimplePattern`. This rule signifies that constant values (like numbers, strings, booleans) can serve as patterns to match values strictly equal to the literal itself.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_4\n\nLANGUAGE: ebnf\nCODE:\n```\n  SimplePattern   ::=  Literal\n```\n\n----------------------------------------\n\nTITLE: Defining Traits for baseType Examples in Scala 3\nDESCRIPTION: Provides Scala trait definitions (`Iterable`, `List`, `Map`, `Foo`) used as prerequisites for demonstrating the `baseType` meta-function examples. These traits establish an inheritance hierarchy and variance annotations (covariant `+`) necessary for understanding the subsequent `baseType` calculations.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterable[+A]\ntrait List[+A] extends Iterable[A]\ntrait Map[K, +V] extends Iterable[(K, V)]\ntrait Foo\n```\n\n----------------------------------------\n\nTITLE: Syntax Definition for Type Parameter Bounds in Scala 3\nDESCRIPTION: Provides the formal syntax rules (similar to EBNF) for defining type parameter bounds in Scala 3, including optional subtype bounds followed by zero or more context bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/contextual/context-bounds.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nTypeParamBounds   ::=  [SubtypeBounds] {ContextBound}\nContextBound      ::=  ‘:’ Type\n```\n\n----------------------------------------\n\nTITLE: Type Healing with Type Holes\nDESCRIPTION: Example demonstrating how type references are handled during serialization by replacing type references with type holes that include bounds information.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/metaprogramming/macros-spec.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\n'{ List.empty[T] }\\n// type healed to\\n'{ type U = t.Underlying; List.empty[U] }\\n\\n// replaced with type hole\\n'{ type U = << 0; Nothing..Any >>; List.empty[U] }\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Modifier Syntax in Scala 3 Grammar (EBNF)\nDESCRIPTION: This snippet specifies the EBNF grammar rules for defining 'implicit' as a local modifier and its usage within parameter clauses in Scala 3. It outlines how to denote implicit values in both template members and method parameters, providing the foundation for how implicit parameters are recognized and processed by the Scala compiler. There are no external dependencies; this is purely a syntactic specification for language designers or tool builders.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/07-implicits.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nLocalModifier  ::= ‘implicit’\nParamClauses   ::= {ParamClause} [nl] ‘(’ ‘implicit’ Params ‘)’\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Pattern Binder Syntax (EBNF)\nDESCRIPTION: Provides the EBNF rule for `Pattern2` that defines pattern binders. The syntax `varid ‘@’ Pattern3` indicates a pattern where a variable (`varid`) is bound to the entire value matched by the subsequent pattern (`Pattern3`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/08-pattern-matching.md#_snippet_3\n\nLANGUAGE: ebnf\nCODE:\n```\n  Pattern2        ::=  varid ‘@’ Pattern3\n```\n\n----------------------------------------\n\nTITLE: Defining Bindings and Import Syntax in Scala 3 (EBNF)\nDESCRIPTION: This EBNF snippet details the grammar for bindings (e.g., in destructuring), modifiers, annotations, import/export statements, and end markers in Scala 3. It defines how local and access modifiers, annotations, and binding forms map to abstract syntax tree nodes. It also describes import/export clauses, selector syntax, and marks the syntax for ending blocks. Dependencies include understanding of Scala keywords and AST node mappings. Inputs are structured token streams according to lexical rules; outputs are definitions ready for parser consumption.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/syntax.md#_snippet_6\n\nLANGUAGE: EBNF\nCODE:\n```\nBindings          ::=  ‘(’ [Binding {‘,’ Binding}] ‘)’\nBinding           ::=  [`erased`] (id | ‘_’) [‘:’ Type]                           ValDef(_, id, tpe, EmptyTree)\n\nModifier          ::=  LocalModifier\n                    |  AccessModifier\n                    |  ‘override’\n                    |  ‘opaque’\nLocalModifier     ::=  ‘abstract’\n                    |  ‘final’\n                    |  ‘sealed’\n                    |  ‘open’\n                    |  ‘implicit’\n                    |  ‘lazy’\n                    |  ‘inline’\n                    |  ‘transparent’\n                    |  ‘infix’\n                    |  ‘erased’\n                    |  ‘tracked’\n\nAccessModifier    ::=  (‘private’ | ‘protected’) [AccessQualifier]\nAccessQualifier   ::=  ‘[’ id ‘]’\n\nAnnotation        ::=  ‘@’ SimpleType1 {ParArgumentExprs}                         Apply(tpe, args)\n\nImport            ::=  ‘import’ ImportExpr {‘,’ ImportExpr}\nExport            ::=  ‘export’ ImportExpr {‘,’ ImportExpr}\nImportExpr        ::=  SimpleRef {‘.’ id} ‘.’ ImportSpec                          Import(expr, sels)\n                    |  SimpleRef ‘as’ id                                          Import(EmptyTree, ImportSelector(ref, id))\nImportSpec        ::=  NamedSelector\n                    |  WildCardSelector\n                    | ‘{’ ImportSelectors) ‘}’\nNamedSelector     ::=  id [‘as’ (id | ‘_’)]\nWildCardSelector  ::=  ‘*’ | ‘given’ [InfixType]\nImportSelectors   ::=  NamedSelector [‘,’ ImportSelectors]\n                    |  WildCardSelector {‘,’ WildCardSelector}\n\nEndMarker         ::=  ‘end’ EndMarkerTag    -- when followed by EOL\nEndMarkerTag      ::=  id | ‘if’ | ‘while’ | ‘for’ | ‘match’ | ‘try’\n                    |  ‘new’ | ‘this’ | ‘given’ | ‘extension’ | ‘val’\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Auto-Application in Scala 2\nDESCRIPTION: Shows how in Scala 2, a nullary method defined with parentheses could be called without them, as empty parentheses were implicitly inserted.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/auto-apply.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef next(): T = ...\nnext     // is expanded to next()\n```\n\n----------------------------------------\n\nTITLE: Defining Case Classes in Scala Using EBNF Syntax\nDESCRIPTION: This snippet presents the EBNF notation for defining a case class as a class definition prefixed with the keyword `case`. It establishes the syntactical foundation for case classes, which require a non-implicit parameter section and introduce elements for special handling such as pattern matching and automatic accessor generation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_14\n\nLANGUAGE: EBNF\nCODE:\n```\nTmplDef  ::=  ‘case’ ‘class’ ClassDef\n```\n\n----------------------------------------\n\nTITLE: Unsafe Casting of IArray to Array in Scala to Mutate Immutable Array\nDESCRIPTION: Illustrates a low-level, unsafe approach to modify a supposedly immutable IArray by casting it to its underlying Array type and performing an update. This method is discouraged as it breaks immutability but is explicitly recognized as unsafe unlike pattern matching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/other-new-features/matchable.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimm.asInstanceOf[Array[Int]](0) = 1\n```\n\n----------------------------------------\n\nTITLE: Comparing and Printing Extended Debug Info for Tree - Scala\nDESCRIPTION: Checks if the human-readable output of the compiler tree matches a specific literal string, and if so, prints extended debug information including tree details, its corresponding pretty-type, and a unique identifier. This approach helps zero in on particular trees during debugging, but color control codes in 'show' output may cause string comparisons to fail.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nif (tree.show == \"\"\"println(\"Hello World\")\"\"\")\n  println(s\"${tree.show}\\n${pt.show}\\n${tree.uniqueId}\\n===\\n\")\n```\n\n----------------------------------------\n\nTITLE: Deprecated Do-While Syntax in Scala\nDESCRIPTION: Illustrates the `do-while` syntax construct which is no longer supported in Scala 3. This structure executes the `<body>` at least once before checking the `<cond>`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/do-while.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndo <body> while <cond>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Captured Capabilities via Accessor (Tunnelling Effect)\nDESCRIPTION: Illustrates the effect of capture tunnelling. Although the `Pair` instance `p` is pure, accessing its element `p.fst` (which has type `{ct} Int -> String`) within a closure causes the closure to capture the capability `ct`. The resulting closure type is `{ct} () -> {ct} Int -> String`.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\n() => p.fst : {ct} () -> {ct} Int -> String\n```\n\n----------------------------------------\n\nTITLE: Example of Deprecated Do-While Usage in Scala\nDESCRIPTION: Provides a concrete example of the deprecated `do-while` loop. It increments `i` and then checks if `f(i)` equals 0, repeating as long as the condition holds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/APPLIEDreference/dropped-features/do-while.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndo\n  i += 1\nwhile (f(i) == 0)\n```\n\n----------------------------------------\n\nTITLE: EBNF Grammar for Scala Packaging\nDESCRIPTION: Defines the Extended Backus-Naur Form (EBNF) grammar for a Scala packaging (`Packaging`), which consists of the `package` keyword, a qualified identifier (`QualId`), and a block containing top-level statements (`TopStatSeq`).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/09-top-level-definitions.md#_snippet_2\n\nLANGUAGE: EBNF\nCODE:\n```\nPackaging       ::=  ‘package’ QualId [nl] ‘{’ TopStatSeq ‘}’\n```\n\n----------------------------------------\n\nTITLE: Defining a Procedure Function Without an Explicit Return Type in Scala\nDESCRIPTION: Demonstrates the deprecated way to declare a procedure function in Scala by omitting the equals sign and the return type. This style is no longer supported in Scala 3 without the -source:3.0-migration flag. The function does not specify a return type and has side effects only. No external dependencies are required.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/dropped-features/procedure-syntax.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef f() { ... }\n```\n\n----------------------------------------\n\nTITLE: Unsupported Simple Renaming Export Syntax in Scala 3\nDESCRIPTION: Highlights a current limitation (Restriction 5) where simple renaming syntax like `export member as alias` (without braces and a path prefix) is not yet implemented in Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/other-new-features/export.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nexport status as stat\n```\n\n----------------------------------------\n\nTITLE: Creating Playground Test Files Bash\nDESCRIPTION: Uses `mkdir` to create the necessary directory structure for playground tests (`tests/playground/run` and `tests/playground/neg`). Then, uses `echo` to create simple `Sample.scala` files in these directories, one for negative (error expected) and one for run tests (successful execution expected).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/procedures/vulpix.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -pv tests/playground/run tests/playground/neg\necho \"stuff\" > tests/playground/neg/Sample.scala\necho 'object Test { def main(args: Array[String]): Unit = {println(\"Hi\")} }' > tests/playground/run/Sample.scala\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Types Grammar Using EBNF\nDESCRIPTION: This snippet provides an extended EBNF grammar defining the Scala 3 type system. It includes rules for function types (FunType), lambda types with type parameters (TypTypeParamClause '=>>' Type), match types, infix types, refined types, annotated types, and simple types. Key elements such as function parameter clauses, type bounds, refinements, and context bounds are specified, which are essential for parsing and representing Scala 3 types in a compiler or language toolchain. The grammar also specifies deprecated constructs and complex nested structures like 'FunTypeArgs' and 'Refinement' to aid in Scala 3's expressive type system.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/syntax.md#_snippet_3\n\nLANGUAGE: ebnf\nCODE:\n```\nType              ::=  FunType\n                    |  TypTypeParamClause ‘=>>’ Type                            LambdaTypeTree(ps, t)\n                    |  FunParamClause ‘=>>’ Type                                TermLambdaTypeTree(ps, t)\n                    |  MatchType\n                    |  InfixType\nFunType           ::=  FunTypeArgs (‘=>’ | ‘?→’) Type                          Function(ts, t) | FunctionWithMods(ts, t, mods, erasedParams)\n                    |  TypTypeParamClause '→' Type                             PolyFunction(ps, t)\nFunTypeArgs       ::=  InfixType\n                    |  ‘(’ [ FunArgTypes ] ‘)’\n                    |  FunParamClause\nFunParamClause    ::=  ‘(’ TypedFunParam {‘,’ TypedFunParam } ‘)’\nTypedFunParam     ::=  [`erased`] id ‘:’ Type\nMatchType         ::=  InfixType `match` <<< TypeCaseClauses >>>\nInfixType         ::=  RefinedType {id [nl] RefinedType}                        InfixOp(t1, op, t2)\nRefinedType       ::=  AnnotType {[nl] Refinement}                              RefinedTypeTree(t, ds)\nAnnotType         ::=  SimpleType {Annotation}                                  Annotated(t, annot)\nAnnotType1        ::=  SimpleType1 {Annotation}                                 Annotated(t, annot)\n\nSimpleType        ::=  SimpleLiteral                                            SingletonTypeTree(l)\n                    |  ‘?’ TypeBounds\n                    |  SimpleType1\nSimpleType1       ::=  id                                                       Ident(name)\n                    |  Singleton ‘.’ id                                         Select(t, name)\n                    |  Singleton ‘.’ ‘type’                                     SingletonTypeTree(p)\n                    |  ‘(’ [Types | NamesAndTypes] ‘)’                          Tuple(ts)\n                    |  Refinement                                               RefinedTypeTree(EmptyTree, refinement)\n                    |  TypeSplice                                               -- deprecated syntax\n                    |  SimpleType1 TypeArgs                                     AppliedTypeTree(t, args)\n                    |  SimpleType1 ‘#’ id                                       Select(t, name)\nSingleton         ::=  SimpleRef\n                    |  SimpleLiteral\n                    |  Singleton ‘.’ id\nFunArgType        ::=  Type\n                    |  ‘=>’ Type                                                PrefixOp(→, t)\nFunArgTypes       ::=  FunArgType { ‘,’ FunArgType }\nParamType         ::=  [‘=>’] ParamValueType\nParamValueType    ::=  Type [‘*’]                                               PostfixOp(t, \"*\")\n                    |  IntoType\n                    |  ‘(’ IntoType ‘)’ ‘*’                                     PostfixOp(t, \"*\")\nIntoType          ::=  [‘into’] IntoTargetType                                  Into(t)\n                    |  ‘(’ IntoType ‘)’\nIntoTargetType    ::=  Type\n                    |  FunTypeArgs (‘=>’ | ‘?→’) IntoType\nTypeArgs          ::=  ‘[’ Types ‘]’                                            ts\nRefinement        ::=  :<<< [RefineDcl] {semi [RefineDcl]} >>>                  ds\nTypeBounds        ::=  [‘>:’ Type] [‘<:’ Type]                                  TypeBoundsTree(lo, hi)\nTypeAndCtxBounds  ::=  TypeBounds [‘:’ ContextBounds]                           ContextBounds(typeBounds, tps)\nContextBounds     ::=  ContextBound\n                    |  ContextBound `:` ContextBounds                           -- to be deprecated\n                    |  '{' ContextBound {',' ContextBound} '}'\nContextBound      ::=  Type [‘as’ id]\nTypes             ::=  Type {‘,’ Type}\nNamesAndTypes     ::=  NameAndType {‘,’ NameAndType}\nNameAndType       ::=  id ':' Type\n```\n\n----------------------------------------\n\nTITLE: Duplicate Object Definition Example - Scala\nDESCRIPTION: Defines two objects with the same name 'Foo', which is not allowed in Scala. Used as an example to trigger a compile-time error for demonstration of the '-Ydebug-error' flag and analysis of error stack traces.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nobject Foo\nobject Foo\n```\n\n----------------------------------------\n\nTITLE: Recompiling Class File with TASTY Frontend (Shell)\nDESCRIPTION: Presents the shell command to recompile a Dotty-compiled class file from its TASTY representation. This feature allows for linking and whole-world optimizations, taking a classpath and classname as input and using the TASTY data to recompile the code. It is a step towards enabling different backends.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-12-01-fifth-dotty-milestone-release.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ndotc -from-tasty -classpath <classpath> <classname>\n```\n\n----------------------------------------\n\nTITLE: Compiler Error Example for Polymorphic Tail-Recursive Call in Scala\nDESCRIPTION: This shell snippet shows an example compiler error message produced when attempting to optimize a polymorphic tail-recursive call with changing type arguments in previous Scala versions. It highlights the prior limitation that Dotty 0.10.0-RC1 removes to improve tail recursion optimization for polymorphic methods.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-10-10-10th-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n   loop[Int](1)\n   ^^^^^^^^^^^^\n  Cannot rewrite recursive call: it changes type arguments on a polymorphic recursive call\n```\n\n----------------------------------------\n\nTITLE: XML Element Structure and Content in EBNF\nDESCRIPTION: Grammar definition for XML elements in Scala, including empty elements, start/end tags, and content structure. This defines how XML elements can be constructed in Scala code.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/10-xml-expressions-and-patterns.md#_snippet_1\n\nLANGUAGE: EBNF\nCODE:\n```\nElement       ::=    EmptyElemTag\n                |    STag Content ETag\n\nEmptyElemTag  ::=    '<' Name {S Attribute} [S] '/>'\n\nSTag          ::=    '<' Name {S Attribute} [S] '>'\nETag          ::=    '</' Name [S] '>'\nContent       ::=    [CharData] {Content1 [CharData]}\nContent1      ::=    XmlContent\n                |    Reference\n                |    ScalaExpr\nXmlContent    ::=    Element\n                |    CDSect\n                |    PI\n                |    Comment\n```\n\n----------------------------------------\n\nTITLE: Enabling CanThrow Capabilities in Scala 3\nDESCRIPTION: Import statement required to enable the experimental CanThrow capabilities feature in Scala 3. This must be included in any file that wants to use the safer exception checking system.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/canthrow.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport language.experimental.saferExceptions\n```\n\n----------------------------------------\n\nTITLE: Defining Concrete Scala Types Grammar Using EBNF\nDESCRIPTION: This snippet specifies the concrete syntax of Scala types using EBNF rules. It details type constructions such as function types, type lambdas, infix types, refined types, annotated types, and various parametric forms. These definitions serve as the basis for parsing source code type expressions written by developers. Dependencies include a parser that supports EBNF syntax. The input is user-written Scala type expressions; the output is their parsed tree structure following the rules. Limitations include adherence to Scala's syntax and line breaks influencing some productions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_0\n\nLANGUAGE: EBNF\nCODE:\n```\nType                  ::=  FunType\n                        |  TypeLambda\n                        |  MatchType\n                        |  InfixType\nFunType               ::=  FunTypeArgs ‘=>’ Type\n                        |  TypeLambdaParams '→' Type\nTypeLambda            ::=  TypeLambdaParams ‘=>>’ Type\nMatchType             ::=  InfixType ‘match’ <<< TypeCaseClauses >>>\nInfixType             ::=  RefinedType\n                        |  RefinedTypeOrWildcard id [nl] RefinedTypeOrWildcard {id [nl] RefinedTypeOrWildcard}\nRefinedType           ::=  AnnotType {[nl] Refinement}\nAnnotType             ::=  SimpleType {Annotation}\nSimpleType            ::=  SimpleLiteral\n                        |  SimpleType1\nSimpleType1           ::=  id\n                        |  Singleton ‘.’ id\n                        |  Singleton ‘.’ ‘type’\n                        |  ‘(’ TypesOrWildcards ’)’\n                        |  Refinement\n                        |  SimpleType1 TypeArgs\n                        |  SimpleType1 ‘#’ id\nSingleton             ::=  SimpleRef\n                        |  SimpleLiteral\n                        |  Singleton ‘.’ id\nSimpleRef             ::=  id\n                        |  [id ‘.’] ‘this’\n                        |  [id ‘.’] ‘super’ [‘[’ id ‘]’] ‘.’ id\nParamType             ::=  [‘=>’] ParamValueType\nParamValueType        ::=  ParamValueType [‘*’]\nTypeArgs              ::=  ‘[’ TypesOrWildcards ’]’\nRefinement            ::=  :<<< [RefineDef] {semi [RefineDef]} >>>\n\nFunTypeArgs           ::=  InfixType\n                        |  ‘(’ [ FunArgTypes ] ’)’\n                        |  FunParamClause\nFunArgTypes           ::=  FunArgType { ‘,’ FunArgType }\nFunArgType            ::=  Type\n                        |  ‘=>’ Type\nFunParamClause        ::=  ‘(’ TypedFunParam {‘,’ TypedFunParam } ’)’\nTypedFunParam         ::=  id ‘:’ Type\n\nTypeLambdaParams      ::=  ‘[’ TypeLambdaParam {‘,’ TypeLambdaParam} ’]’\nTypeLambdaParam       ::=  {Annotation} (id | ‘_’) [TypeParamClause] TypeBounds\nTypeParamClause       ::=  ‘[’ VariantTypeParam {‘,’ VariantTypeParam} ’]’\nVariantTypeParam      ::=  {Annotation} [‘+’ | ‘-’] (id | ‘_’) [TypeParamClause] TypeBounds\n\nTypeCaseClauses       ::=  TypeCaseClause { TypeCaseClause }\nTypeCaseClause        ::=  ‘case’ (InfixType | ‘_’) ‘=>’ Type [semi]\n\nRefineDef             ::=  ‘val’ ValDef\n                        |  ‘def’ DefDef\n                        |  ‘type’ {nl} TypeDef\n\nTypeBounds            ::=  [‘>:’ Type] [‘<:’ Type]\n\nTypesOrWildcards      ::=  TypeOrWildcard {‘,’ TypeOrWildcard}\nTypeOrWildcard        ::=  Type\n                        |  WildcardType\nRefinedTypeOrWildcard ::=  RefinedType\n                        |  WildcardType\nWildcardType          ::=  (‘?’ | ‘_’) TypeBounds\n```\n\n----------------------------------------\n\nTITLE: Breakpoint Step Syntax - Scala 3 Debug Test - Plaintext\nDESCRIPTION: This snippet documents the syntax for defining breakpoints within .check files for Scala 3 debug tests. Each line specifies the class and line number for a breakpoint, which will be activated before program execution begins. This ensures that debugging scenarios are robustly reproducible. Prerequisite: familiarity with Java class naming conventions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\nbreak ${runtime class} ${line number}\n```\n\n----------------------------------------\n\nTITLE: Defining Context Function Types - EBNF - EBNF\nDESCRIPTION: This snippet defines the syntactic structure for context functions and function types in Scala 3 using EBNF notation. The grammar clarifies how context function types and expressions can be constructed and parsed in Scala source code. No dependencies are required, as this is formal specification rather than implementation. Intended for language tooling and specification readers, it shows how the '?=>' operator expands function signatures and expressions with context (using) parameters.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/contextual/context-functions-spec.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nType              ::=  ...\n                    |  FunArgTypes ‘?=>’ Type\nExpr              ::=  ...\n                    |  FunParams ‘?=>’ Expr\n```\n\n----------------------------------------\n\nTITLE: Printing Out Stack Traces of Compile-Time Errors - Shell\nDESCRIPTION: Compiles a Scala file with the '-Ydebug-error' flag to output complete stack traces for all compile-time errors. This aids in identifying which compiler method was responsible for generating specific errors. The technique requires that the file being compiled contains errors to trigger the stack trace output.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nscalac -Ydebug-error ../issues/Playground.scala\n```\n\n----------------------------------------\n\nTITLE: Adding a Project as a Git Submodule (Shell)\nDESCRIPTION: Adds a specified Git repository (replace the example URL and `XYZ` with the actual project details) as a Git submodule within the `community-build/community-projects/` directory. This command is a necessary step when adding a new project to the Scala 3 Community Build, typically pointing to a fork in the `dotty-staging` GitHub organization.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/community-build.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\ngit submodule add https://github.com/dotty-staging/XYZ.git community-build/community-projects/XYZ\n```\n\n----------------------------------------\n\nTITLE: Explicitly Passing CanThrow Capability for Checked Exceptions in Scala\nDESCRIPTION: This code shows the desugared form of a checked exception function, where f receives an implicit parameter of type CanThrow[LimitExceeded]. This enables the type system to ensure that the throwing of LimitExceeded is only possible when an explicit capability is present. The use of using CanThrow[LimitExceeded] as an implicit parameter is required to type-check such functions under saferExceptions. Dependencies are language.experimental.saferExceptions and the CanThrow trait/class in scope.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Double)(using CanThrow[LimitExceeded]): Double = ...\n```\n\n----------------------------------------\n\nTITLE: XML Name Definition in EBNF\nDESCRIPTION: Grammar definition for XML names in Scala, following W3C XML naming conventions but without colon support. This defines how element and attribute names are formed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/10-xml-expressions-and-patterns.md#_snippet_3\n\nLANGUAGE: EBNF\nCODE:\n```\nBaseChar, CDSect, Char, Comment, CombiningChar, Ideographic, NameChar, PI, S, Reference\n              ::=  ´\\textit{\"as in W3C XML\"}´\n\nChar1         ::=  Char ´\\textit{ without}´ '<' | '&'\nCharQ         ::=  Char1 ´\\textit{ without}´ '\"'\nCharA         ::=  Char1 ´\\textit{ without}´ '''\nCharB         ::=  Char1 ´\\textit{ without}´ '{'\n\nName          ::=  XNameStart {NameChar}\n\nXNameStart    ::= '_' | BaseChar | Ideographic\n                 ´\\textit{ (as in W3C XML, but without }´ ':'´)´\n```\n\n----------------------------------------\n\nTITLE: Concrete Refined Types Syntax in Scala 3 EBNF\nDESCRIPTION: Specifies the grammar for refined types in Scala 3's concrete syntax using EBNF notation. Refined types consist of an annotated type followed by one or more refinements, each defining abstract 'val', 'def', or 'type' members. This snippet outlines how complex type refinements are parsed and structured.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_6\n\nLANGUAGE: ebnf\nCODE:\n```\nRefinedType           ::=  AnnotType {[nl] Refinement}\nSimpleType1           ::=  ...\n                        |  Refinement\nRefinement            ::=  :<<< [RefineDef] {semi [RefineDef]} >>>\nRefineDef             ::=  ‘val’ ValDef\n                        |  ‘def’ DefDef\n                        |  ‘type’ {nl} TypeDef\n```\n\n----------------------------------------\n\nTITLE: Defining This Types in Scala 3 EBNF\nDESCRIPTION: This EBNF snippet specifies the grammar rule for 'this types' in Scala 3's type system as 'classid . this'. 'This types' define the specific 'this' reference for the enclosing class and can be implicitly used as prefixes for designator types. This rule is foundational for representing internal class references that contribute to type safety and precise type inference. No external dependencies or constraints beyond the standard EBNF/Scala specifications apply.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_17\n\nLANGUAGE: ebnf\nCODE:\n```\nThisType  ::=  classid ‘.‘ ‘this‘\n```\n\n----------------------------------------\n\nTITLE: Define Block and Template Statement Grammar - EBNF\nDESCRIPTION: This EBNF snippet defines the grammatical structure for statements (BlockStat, TemplateStat) in Scala. It lists the valid components of a statement, including imports, definitions (with optional annotations and modifiers), expressions, and empty statements, specifying where each type of statement is permitted (blocks or templates).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_49\n\nLANGUAGE: ebnf\nCODE:\n```\nBlockStat    ::=  Import\n               |  {Annotation} [‘implicit’] [‘lazy’] Def\n               |  {Annotation} {LocalModifier} TmplDef\n               |  Expr1\n               |\nTemplateStat ::=  Import\n               |  {Annotation} {Modifier} Def\n               |  {Annotation} {Modifier} Dcl\n               |  Expr\n               |\n```\n\n----------------------------------------\n\nTITLE: Instrumenting a Scala Method for Coverage Tracking\nDESCRIPTION: This snippet shows the same 'method' after it has been instrumented for coverage analysis using the Scala 3 compiler option '-coverage-out:target/cov'. Calls to 'Invoker.invoked' are inserted to record execution at each statement. This requires 'scala.runtime.Invoker' to be available on the classpath and depends on the coverage plugin or built-in functionality. Each instrumented call includes a unique statement id and the output directory, with the method structure re-organized to ensure coverage tracking while preserving original behavior.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/coverage.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef method() =\n  Invoker.invoked(2, \"target/cov\")\n  println({\n    Invoker.invoked(1, \"target/cov\")\n    f()\n  })\n```\n\n----------------------------------------\n\nTITLE: Debugging Capture Set Dependencies with -Ycc-debug\nDESCRIPTION: Example output generated by the Scala 3 compiler using the `-Ycc-debug` flag. This output shows the relationships and dependencies between capture set variables, including their IDs, known elements, provenance (e.g., V for regular, M for mapped), and supersets. This aids in understanding how the capture checker resolves constraints during compilation.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/TODOreference/experimental/cc.md#_snippet_38\n\nLANGUAGE: text\nCODE:\n```\nCapture set dependencies:\n  {}2V                 ::\n  {}3V                 ::\n  {}4V                 ::\n  {f, xs}5V            :: {f, xs}31M5V, {f, xs}32M5V\n  {f, xs}31M5V         :: {xs, f}\n  {f, xs}32M5V         ::\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion from Symbol to SymDenotation in Scala 3\nDESCRIPTION: Defines the implicit conversion `toDenot` located within the `core.Symbols` object. This conversion transforms a `Symbol` instance into its corresponding `SymDenotation`, enabling access to phase-dependent properties. The conversion requires an implicit `Context` to be available in the scope where it's invoked but does not need an explicit import due to Scala's implicit scope rules.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/dotc-scalac.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncore.Symbols.toDenot(sym: Symbol)(implicit ctx: Context): SymDenotation\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Function Types Grammar in EBNF\nDESCRIPTION: Defines the grammar of Scala 3 function types using EBNF notation. It specifies how function type arguments and parameter clauses are structured, serving as the basis for parsing function type expressions in the Scala 3 compiler or tooling. This snippet underpins how function types like '(T1, ..., Tn) => R' are syntactically composed.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_3\n\nLANGUAGE: ebnf\nCODE:\n```\nType              ::=  FunTypeArgs ‘=>’ Type\nFunTypeArgs       ::=  InfixType\n                    |  ‘(’ [ FunArgTypes ] ‘)’\n                    |  FunParamClause\nFunArgTypes       ::=  FunArgType { ‘,’ FunArgType }\nFunArgType        ::=  Type\n                    |  ‘=>’ Type\nFunParamClause    ::=  ‘(’ TypedFunParam {‘,’ TypedFunParam }‘)’\nTypedFunParam     ::=  id ‘:’ Type\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependent Function Type Syntax - EBNF\nDESCRIPTION: Defines the context-free grammar syntax for dependent function types using Extended Backus-Naur Form (EBNF). It specifies how function argument types and typed function parameters are structured. This forms the syntactic foundation for parsing dependent function types, distinguishing between infix types and parenthesized function argument lists. No dependencies are needed as it is a syntax definition.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/new-types/dependent-function-types-spec.md#_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nFunArgTypes       ::=  InfixType\n                    |  ‘(’ [ FunArgType {',' FunArgType } ] ’)’\n                    |  ‘(’ TypedFunParam {',' TypedFunParam } ’)’\nTypedFunParam     ::=  id ‘:’ Type\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala Trait with EBNF Syntax\nDESCRIPTION: The snippet employs EBNF to syntactically specify the definition of a trait as a variation of a class definition using the keyword `trait`. This sets the stage for understanding traits as modular components enabling mixin-based composition without constructor arguments.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_20\n\nLANGUAGE: EBNF\nCODE:\n```\nTmplDef          ::=  ‘trait’ ClassDef\n```\n\n----------------------------------------\n\nTITLE: Grammar for Literals and Reference Paths (EBNF)\nDESCRIPTION: This EBNF grammar fragment defines the rules for different literal forms (simple literals, interpolated strings, null) and constructs used for referencing names, including qualified identifiers (`QualId`), lists of identifiers (`ids`), and simple references (`SimpleRef`) potentially involving `this`, `super`, and class qualifiers.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/syntax.md#_snippet_2\n\nLANGUAGE: ebnf\nCODE:\n```\nSimpleLiteral     ::=  [‘-’] integerLiteral\n                    |  [‘-’] floatingPointLiteral\n                    |  booleanLiteral\n                    |  characterLiteral\n                    |  stringLiteral\nLiteral           ::=  SimpleLiteral\n                    |  interpolatedStringLiteral\n                    |  symbolLiteral\n                    |  ‘null’\n\nQualId            ::=  id {‘.’ id}\nids               ::=  id {‘,’ id}\n\nSimpleRef         ::=  id\n                    |  [id ‘.’] ‘this’\n                    |  [id ‘.’] ‘super’ [ClassQualifier] ‘.’ id\n\nClassQualifier    ::=  ‘[’ id ‘]’\n```\n\n----------------------------------------\n\nTITLE: Forcing Built-in Tracing in Scala Compiler\nDESCRIPTION: Shows how to use `trace.force` to unconditionally enable tracing for a specific block, overriding the global `tracingEnabled` setting. It takes the same arguments as the standard `trace` function: a message, a printer, and options.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\ntrace.force(i\"typing $tree\", typr, show = true) { // ...\n```\n\n----------------------------------------\n\nTITLE: Typing Rules for Symmetric Metaprogramming in EBNF\nDESCRIPTION: The typing judgments and rules for the two-stage metaprogramming calculus. These rules establish how to type variables, lambdas, applications, quotes, and splices within the context of two environments for the different phases.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/metaprogramming/simple-smp.md#_snippet_3\n\nLANGUAGE: ebnf\nCODE:\n```\n                          x: T in E2\n                       ---------------\n                       E1 * E2 |- x: T\n\n\n                   E1 * E2, x: T1 |- t: T2\n               --------------------------------\n               E1 * E2 |- (x: T1) => t: T -> T2\n\n\n         E1 * E2 |- t1: T2 -> T    E1 * E2 |- t2: T2\n         -------------------------------------------\n                     E1 * E2 |- t1 t2: T\n\n\n                       E2 ' E1 |- t: T\n                      -----------------\n                      E1 ~ E2 |- 't: 'T\n\n\n                       E2 ~ E1 |- t: 'T\n                       ----------------\n                       E1 ' E2 |- ~t: T\n```\n\n----------------------------------------\n\nTITLE: Extended Parameter Syntax with 'into' Modifier - Grammar\nDESCRIPTION: Presents the grammar extension required to support the 'into' modifier on parameter types in Scala 3. This formal description defines where 'into' is allowed, such as parameter types and top-level function result types. No direct dependencies; the grammar is intended for language implementors.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/reference/experimental/into-modifier.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nParamType         ::=  [‘=>’] ParamValueType\nParamValueType    ::=  Type [‘*’]\n                  |  IntoType\n                  |  ‘(’ IntoType ‘)’ ‘*’\nIntoType          ::=  [‘into’] IntoTargetType\n                  |  ‘(’ IntoType ‘)’\nIntoTargetType    ::=  Type\n                  |  FunTypeArgs (‘=>’ | ‘?=>’) IntoType\n```\n\n----------------------------------------\n\nTITLE: Metaprogramming improvements in Dotty\nDESCRIPTION: Highlights recent enhancements to Dotty's metaprogramming capabilities, including robust file handling, customizable quote definitions, symbol renaming, and the replacement of implicit classes with expression reduction. These features aim to improve the expressiveness, efficiency, and usability of metaprogramming within Scala 3.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-11-04-20th-dotty-milestone-release.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n# The relevant changes are in the metadata and PR references, not in executable code snippets.\n```\n\n----------------------------------------\n\nTITLE: Grammar Rules for Optional Braces and Indentation (EBNF)\nDESCRIPTION: This EBNF snippet describes the syntax rules for handling optional braces and indentation in Scala 3. It defines the context-dependent generation of the `colon` token and the `<<< ts >>>` and `:<<< ts >>>` constructs, which represent token sequences that can be enclosed in braces or be part of an indented block, potentially following a colon.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/internals/syntax.md#_snippet_1\n\nLANGUAGE: ebnf\nCODE:\n```\ncolon         ::=  ':'    -- with side conditions explained above\n <<< ts >>>   ::=  ‘{’ ts ‘}’\n                |  indent ts outdent\n:<<< ts >>>   ::=  [nl] ‘{’ ts ‘}’\n                |  colon indent ts outdent\n```\n\n----------------------------------------\n\nTITLE: EBNF Syntax for Method Definitions in Scala 3\nDESCRIPTION: Defines the EBNF grammar for method definitions, including function signatures, parameter clauses, and method bodies.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/04-basic-definitions.md#_snippet_27\n\nLANGUAGE: ebnf\nCODE:\n```\nDef                ::=  'def' FunDef\nFunDef             ::=  FunSig [':' Type] ['=' Expr]\nFunSig             ::=  id [FunTypeParamClause] ParamClauses\nFunTypeParamClause ::=  '[' TypeParam {',' TypeParam} ']'\nParamClauses       ::=  {ParamClause} [[nl] '(' 'implicit' Params ')']\nParamClause        ::=  [nl] '(' [Params] ')'\nParams             ::=  Param {',' Param}\nParam              ::=  {Annotation} id [':' ParamType] ['=' Expr]\nParamType          ::=  Type\n                     |  '=>' Type\n                     |  Type '*'\n```\n\n----------------------------------------\n\nTITLE: Compiling and Publishing Bootstrapped Scala 3 Artifacts (sbt)\nDESCRIPTION: This snippet provides the exact sbt shell commands required to compile and locally publish bootstrapped Scala 3 artifacts. The sequence first compiles the bootstrapped project and then publishes its output binaries. These steps are necessary for IDE-based features such as semantic analysis when compiler versions change. Prerequisites: sbt installed, Scala 3 project checked out. If errors occur, the workaround involves cleaning the output directory. Outputs the compiled binaries usable by IDE integration components.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/setting-up-your-ide.md#_snippet_1\n\nLANGUAGE: sbt\nCODE:\n```\nsbt> scala3-bootstrapped/compile\nsbt> scala3-bootstrapped/publishLocalBin\n```\n\n----------------------------------------\n\nTITLE: Using a Built-in Printer for Logging in Scala Compiler\nDESCRIPTION: An example demonstrating how to use a compiler 'Printer' instance (`typr` in this case) for logging debug information. Printers are enabled by replacing `noPrinter` with `default` in their definition. The `i\"\"` syntax is for interpolated strings used within the compiler.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\ntypr.println(i\"make contextual function $tree / $pt ---> $ifun\")\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Tuple Types Grammar in EBNF\nDESCRIPTION: Defines how tuple types are represented in Scala 3 concrete syntax using EBNF grammar. It specifies that tuple types are parenthesized sequences of types or wildcards, underpinning the syntactic sugar for nested infix types representing tuples internally.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_5\n\nLANGUAGE: ebnf\nCODE:\n```\nSimpleType1           ::=  ...\n                        |  ‘(’ TypesOrWildcards ’)’\n```\n\n----------------------------------------\n\nTITLE: Capturing Creation Stack Trace in Scala\nDESCRIPTION: Demonstrates the code to capture the current thread's stack trace as a string. This snippet is intended to be added as a member (`val tracer`) to a class (like compiler AST `Tree` nodes) to record the stack trace at the moment an instance of that class is created, enabling later debugging of its creation site.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nval tracer = Thread.currentThread.getStackTrace.mkString(\"\\n\")\n```\n\n----------------------------------------\n\nTITLE: EBNF Definition for Polymorphic Method Types (Poly Types) in Scala 3\nDESCRIPTION: Presents the EBNF grammar for polymorphic method types (poly types) in Scala 3. Poly types allow methods to be parameterized by types, specifying type parameters and their bounds.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/03-types.md#_snippet_38\n\nLANGUAGE: ebnf\nCODE:\n```\nPolyType          ::=  ‘[‘ PolyTypeParams ‘]‘ TypeOrMethodic\nPolyTypeParams    ::=  PolyTypeParam {‘,‘ PolyTypeParam}\nPolyTypeParam     ::=  ‘id‘ TypeBounds\n```\n\n----------------------------------------\n\nTITLE: Updating Dotty via Homebrew on macOS\nDESCRIPTION: Updates an existing installation of Dotty managed by Homebrew to the latest available version. Requires Dotty to have been previously installed via 'brew install lampepfl/brew/dotty'.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-09-07-third-dotty-milestone-release.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nbrew upgrade dotty\n```\n\n----------------------------------------\n\nTITLE: EBNF Syntax for Scala Object Definitions\nDESCRIPTION: Specifies the formal grammar for Scala object definitions using Extended Backus-Naur Form (EBNF). Defines the production rules for 'TmplDef' and 'ObjectDef' emphasizing the object keyword, identifier, and class template structure. This grammar underpins the syntax for defining singleton objects in Scala.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_29\n\nLANGUAGE: ebnf\nCODE:\n```\nTmplDef         ::=  ‘object’ ObjectDef\nObjectDef       ::=  id ClassTemplate\n```\n\n----------------------------------------\n\nTITLE: Comparing symbol typing information across compiler phases in Scala\nDESCRIPTION: Demonstrates how to use the Scala 3 compiler's Context and phase system to inspect the type information of a symbol at different compilation phases (typer and erasure). The snippet imports Context, atPhase method, and references to typerPhase and erasurePhase. It requires a valid compiler Context and a symbol definition fooDef representing a method. The code prints the method signature after the typer phase and after the erasure phase, illustrating how the method's type changes during compilation. Inputs are the compiler symbol and phase identifiers; outputs are textual representations of the symbol's info after specified phases.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/architecture/time.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport dotty.tools.dotc.core.Contexts.{Context, atPhase}\nimport dotty.tools.dotc.core.Phases.{typerPhase, erasurePhase}\nimport dotty.tools.dotc.core.Decorators.i\n\ngiven Context = …\n\nval fooDef: Symbol = … // `def foo(b: Box)(x: b.X): List[b.X]`\n\nprintln(i\"$fooDef after typer   => ${atPhase(typerPhase.next)(fooDef.info)}\")\nprintln(i\"$fooDef after erasure => ${atPhase(erasurePhase.next)(fooDef.info)}\")\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Constructor Syntax in EBNF\nDESCRIPTION: Specifies the EBNF grammar rule for `Constr`, detailing the syntax for constructor invocations used within template definitions. It shows how a constructor call can include type arguments (`targs`) and multiple argument lists (`args_1 ... args_n`), possibly prefixed by a stable identifier.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/05-classes-and-objects.md#_snippet_3\n\nLANGUAGE: EBNF\nCODE:\n```\nConstr  ::=  AnnotType {‘(’ [Exprs] ‘)’}\n```\n\n----------------------------------------\n\nTITLE: Listing Contributors using Git Shortlog (Shell)\nDESCRIPTION: Displays a Shell command using Git to generate a summarized log of contributors between two specific tags (3.2.1 and 3.2.2-RC1). The options '-sn' sort contributors by commit count and show only the count and name, while '--no-merges' excludes merge commits. The output lists the contributors and their commit counts for this release range.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.2.2-RC1.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit shortlog -sn --no-merges 3.2.1..3.2.2-RC1\n    83  Martin Odersky\n    24  Yichen Xu\n    23  Quentin Bernet\n    18  Michael Pollmeier\n    17  Dale Wijnand\n     8  Fengyun Liu\n     8  Paweł Marks\n     7  Guillaume Raffin\n     6  Som Snytt\n     6  Szymon Rodziewicz\n     5  Kacper Korban\n     4  Chris Kipp\n     3  Matt Bovel\n     3  Rikito Taniguchi\n     2  Ben Hutchison\n     2  Florian3k\n     2  Guillaume Martres\n     2  Jamie Thompson\n     2  João Costa\n     2  Julien Richard-Foy\n     2  Lukas Rytz\n     2  Sébastien Doeraene\n     1  Anton Sviridov\n     1  Gabriel Volpe\n     1  Liang Yan\n     1  Noah Rosamilia\n     1  Ondra Pelech\n     1  Seth Tisue\n     1  Tomasz Godzik\n     1  Vadim Chelyshov\n     1  nmc.borst\n     1  nmcb\n     1  olsdavis\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Compilation without Optimizations in Dotty (Java)\nDESCRIPTION: This Java code represents the output generated by Dotty 0.1.2-RC1 when compiling the Scala pattern matching example without optimizations enabled. The compilation emits verbose Java code using low-level control flow (gotos), manual tuple allocations, and type checks. Dependencies include internal Scala classes (e.g., 'CC', 'Tuple2', 'BoxesRunTime') and knowledge of JVM type conversion mechanisms. Inputs are generic Objects, outputs are integer or boolean, and performance is limited by redundant allocation and convoluted branching.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-07-12-second-dotty-milestone-release.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\n// output of dotc 0.1.2-RC1\n    public int foo(Object x) {\n        var3_2 = x;\n        if (!(var3_2 instanceof CC)) ** GOTO lbl-1000\n        var4_3 = (CC)var3_2;\n        if (CC$.MODULE$.unapply((CC)var3_2) == null) ** GOTO lbl-1000\n        var5_4 = CC$.MODULE$.unapply((CC)var3_2);\n        s = var5_4._1();\n        var7_6 = var5_4._2();\n        if (1 != s) ** GOTO lbl-1000\n        var8_7 = s;\n        if (!(var7_6 instanceof CC)) ** GOTO lbl-1000\n        var9_8 = (CC)var7_6;\n        if (CC$.MODULE$.unapply((CC)var7_6) != null) {\n            var10_9 = CC$.MODULE$.unapply((CC)var7_6);\n            var11_10 = var10_9._2();\n            v0 = Tuple2..MODULE$.apply((Object)BoxesRunTime.boxToInteger((int)1), (Object)BoxesRunTime.boxToInteger((int)2));\n        } else lbl-1000: // 5 sources:\n        {\n            v0 = Tuple2..MODULE$.apply((Object)BoxesRunTime.boxToInteger((int)42), (Object)BoxesRunTime.boxToInteger((int)43));\n        }\n        var2_11 = v0;\n        a = BoxesRunTime.unboxToInt((Object)var2_11._1());\n        b = BoxesRunTime.unboxToInt((Object)var2_11._2());\n        return a + b;\n    }\n\n    public boolean booleans(Object a) {\n        Tuple2 tuple2 = Tuple2..MODULE$.apply((Object)BoxesRunTime.boxToBoolean((boolean)(a instanceof CC)), (Object)BoxesRunTime.boxToBoolean((boolean)(a instanceof List)));\n        boolean b1 = BoxesRunTime.unboxToBoolean((Object)tuple2._1());\n        boolean b2 = BoxesRunTime.unboxToBoolean((Object)tuple2._2());\n        Tuple2 tuple22 = Tuple2..MODULE$.apply((Object)BoxesRunTime.boxToBoolean((boolean)b1), (Object)BoxesRunTime.boxToBoolean((boolean)b2));\n        Option option = Tuple2..MODULE$.unapply(tuple22);\n        if (!option.isEmpty()) {\n            Tuple2 tuple23 = (Tuple2)option.get();\n            boolean bl = BoxesRunTime.unboxToBoolean((Object)tuple23._1());\n            boolean bl2 = BoxesRunTime.unboxToBoolean((Object)tuple23._2());\n            if (bl) {\n                boolean bl3 = bl;\n                if (bl2) {\n                    boolean bl4 = bl2;\n                    return true;\n                }\n            }\n        }\n        Option option2 = Tuple2..MODULE$.unapply(tuple22);\n        if (option2.isEmpty()) return false;\n        Tuple2 tuple24 = (Tuple2)option2.get();\n        boolean bl = BoxesRunTime.unboxToBoolean((Object)tuple24._1());\n        boolean bl5 = BoxesRunTime.unboxToBoolean((Object)tuple24._2());\n        if (bl) return false;\n        boolean bl6 = bl;\n        if (bl5) return false;\n        boolean bl7 = bl5;\n        return true;\n    }\n```\n\n----------------------------------------\n\nTITLE: XML Pattern Matching in EBNF\nDESCRIPTION: Grammar definition for XML pattern matching in Scala 3. This defines how XML structures can be used in pattern matching expressions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/10-xml-expressions-and-patterns.md#_snippet_4\n\nLANGUAGE: EBNF\nCODE:\n```\nXmlPattern  ::= ElementPattern\n```\n\n----------------------------------------\n\nTITLE: Listing Contributors using Git Shortlog Output\nDESCRIPTION: Displays a summary of contributors and their commit counts between Scala 3.0.0-RC2 and 3.0.0-RC3, as generated by the 'git shortlog -sn --no-merges 3.0.0-RC2..3.0.0-RC3' command. The output lists contributors sorted by the number of non-merge commits.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2021-04-21-scala3-rc3.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n     8  Martin Odersky\n     7  Adrien Piquerez\n     6  Guillaume Martres\n     4  Liu Fengyun\n     1  Anatolii Kmetiuk\n     1  Nicolas Stucki\n```\n\n----------------------------------------\n\nTITLE: Generating Contributor List with Git Shortlog\nDESCRIPTION: This shell command utilizes `git shortlog` to generate a summarized list of contributors and their commit counts between two specified release candidate tags (`3.3.1-RC1` and `3.3.1-RC2`), excluding merge commits. The `-sn` flags provide a summary sorted numerically by commit count.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.3.1-RC2.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit shortlog -sn --no-merges 3.3.1-RC1..3.3.1-RC2\n```\n\n----------------------------------------\n\nTITLE: Accessing Captured Creation Trace in Scala Compiler\nDESCRIPTION: Shows how to access the `tracer` member, assuming it has been added to the `tree` object's class, to retrieve the stack trace captured during the tree's creation. This allows debugging the origin of a specific tree node identified elsewhere in the compiler's execution.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/debugging/other-debugging.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nif (tree.show == \"\"\"println(\"Hello World\")\"\"\") {\n  val creationSite = tree.tracer\n  println(creationSite)\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Scala 3 Release Steps using Bash\nDESCRIPTION: A sequence of Bash commands using Git to manage the Scala 3 release process. It covers finalizing a stable release from its branch (e.g., 0.14.0 from 0.14.x), tagging it, merging back to main, initiating the next RC (e.g., 0.15.0-RC1), creating its branch, tagging it, and updating the base version on main. Assumes 'git' is installed and 'origin' remote is configured for the main Dotty repository.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/procedures/release.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n######## Publish the 0.14.0 stable version – end the release cycle for 0.14.0 ########\ngit checkout 0.14.x\n\n# Change `val baseVersion = \"0.14.0-RC1\"` to `val baseVersion = \"0.14.0\"` in project/Build.scala\n\ngit commit -am 'Release Dotty 0.14.0'\ngit tag 0.14.0\ngit push origin 0.14.0\n\ngit checkout main\ngit merge 0.14.x\n\n# Make sure the merge doesn't break anything. In doubt, create a PR to run the CL\ngit push origin main\n\n######## Publish the 0.15.0-RC1 unstable version – begin the release cycle for 0.15.0 ########\n# Move all the unfinished tasks from Milestone 15 to Milestone 16 on GitHub – see https://github.com/scala/scala3/milestones\n\ngit checkout -b 0.15.x\n\n# Change val baseVersion = \"0.15.0\" to val baseVersion = \"0.15.0-RC1\"\n\ngit commit -am 'Release Dotty 0.15.0-RC1'\ngit tag 0.15.0-RC1\ngit push origin 0.15.x\ngit push origin 0.15.0-RC1\n\ngit checkout main\n\n# Change val baseVersion = \"0.15.0\" to val baseVersion = \"0.16.0\" - this will be the next version after `0.15.0-RC1` is promoted to `0.15.0`.\n\ngit commit -am 'Set baseVersion to 0.16.0'\ngit push origin main\n```\n\n----------------------------------------\n\nTITLE: Defining Literal Expression Rule (EBNF)\nDESCRIPTION: Specifies the EBNF rule indicating that a 'Literal' is a form of 'SimpleExpr'. This links the definition of literals (detailed elsewhere) into the overall expression grammar hierarchy, highlighting that literals are one of the simplest forms of expressions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/06-expressions.md#_snippet_1\n\nLANGUAGE: ebnf\nCODE:\n```\nSimpleExpr    ::=  Literal\n```\n\n----------------------------------------\n\nTITLE: Using sbt to automatically update checkfiles during compilation tests\nDESCRIPTION: Commands to run compilation tests and automatically update checkfiles that store the expected output of tests when they change. This eases maintenance of output expectations when tests or compiler outputs evolve.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/testing.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\n> testCompilation --update-checkfiles\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\n> sjsCompilerTests/testOnly -- -Ddotty.tests.updateCheckfiles=TRUE\n```\n\n----------------------------------------\n\nTITLE: XML Element Pattern Structure in EBNF\nDESCRIPTION: Detailed grammar for XML element patterns in Scala, including rules for embedding Scala patterns within XML. This enables matching complex XML structures in pattern matching expressions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_spec/10-xml-expressions-and-patterns.md#_snippet_5\n\nLANGUAGE: EBNF\nCODE:\n```\nElemPattern   ::=    EmptyElemTagP\n                |    STagP ContentP ETagP\n\nEmptyElemTagP ::=    '<'  Name [S] '/>'\nSTagP         ::=    '<'  Name [S] '>'\nETagP         ::=    '</' Name [S] '>'\nContentP      ::=    [CharData] {(ElemPattern|ScalaPatterns) [CharData]}\nContentP1     ::=    ElemPattern\n                |    Reference\n                |    CDSect\n                |    PI\n                |    Comment\n                |    ScalaPatterns\nScalaPatterns ::=    '{' Patterns '}'\n```\n\n----------------------------------------\n\nTITLE: Git Shortlog Command for Contributor Statistics in Scala 3.4.2\nDESCRIPTION: A Git command that generates a sorted list of contributors and their commit counts between Scala versions 3.4.1 and 3.4.2, excluding merge commits. The output shows Nicolas Stucki as the top contributor with 46 commits.\nSOURCE: https://github.com/scala/scala3/blob/main/changelogs/3.4.2.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit shortlog -sn --no-merges 3.4.1..3.4.2\n```\n\n----------------------------------------\n\nTITLE: Generating Release Checklist using Bash and curl\nDESCRIPTION: Downloads and executes the checklist.sh script from the Scala 3 repository using curl and bash to generate a release checklist. The output should be copied into a release issue. Requires bash and curl. Replace `<stable_release>` with the version number (e.g., 14).\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_docs/contributing/procedures/release.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nbash <(curl -sL https://raw.githubusercontent.com/scala/scala3/main/docs/docs/contributing/checklist.sh) <stable_release>\n```\n\nLANGUAGE: Bash\nCODE:\n```\n# Example for releasing 0.14.0\nbash <(curl -sL https://raw.githubusercontent.com/scala/scala3/main/docs/docs/contributing/checklist.sh) 14\n```\n\n----------------------------------------\n\nTITLE: Generating Git Contributor List with shortlog\nDESCRIPTION: Displays the sample output of the `git shortlog -sn --no-merges` command executed between release tags `0.13.0-RC1` and `0.14.0-RC1`. This command lists code contributors sorted by the number of commits in descending order, excluding merge commits, providing a summary of individual contributions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-04-15-14th-dotty-milestone-release.md#_snippet_4\n\nLANGUAGE: Git\nCODE:\n```\n   214  Martin Odersky\n   151  Nicolas Stucki\n    71  Liu Fengyun\n    53  Guillaume Martres\n    26  Olivier Blanvillain\n    10  Aleksander Boruch-Gruszecki\n     9  Aggelos Biboudis\n     6  Miles Sabin\n     4  Allan Renucci\n     4  Dale Wijnand\n     3  Anatolii Kmetiuk\n     2  Fengyun Liu\n     2  Alex Zolotko\n     1  gnp\n     1  tim-zh\n     1  Dmitry Petrashko\n     1  Dotty CI\n     1  Jasper Moeys\n     1  Jentsch\n     1  Jim Van Horn\n     1  Lionel Parreaux\n     1  Master-Killer\n     1  Olivier ROLAND\n     1  Robert Stoll\n     1  Seth Tisue\n     1  Tomasz Godzik\n     1  Victor\n```\n\n----------------------------------------\n\nTITLE: Update sbt build properties for Dotty 0.8.0-RC1 support\nDESCRIPTION: This snippet instructs to update the sbt build configuration to support Dotty 0.8.0-RC1 by modifying 'build.properties' and the sbt-dotty plugin version, ensuring compatibility with the latest compiler and incremental compiler improvements. It also includes replacing usage of '.withDottyCompat()' with a version-aware variant for proper setup.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-04-27-eighth-dotty-milestone-release.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\naddSbtPlugin(\"ch.epfl.lamp\" % \"sbt-dotty\" % \"0.2.2\")\n```\n\n----------------------------------------\n\nTITLE: Updating Dotty via Homebrew\nDESCRIPTION: Command for updating an existing Dotty installation using the Homebrew package manager.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2018-07-06-ninth-dotty-milestone-release.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nbrew upgrade dotty\n```\n\n----------------------------------------\n\nTITLE: Listing Contributors via Git Shortlog Output (Text)\nDESCRIPTION: Displays the output from a `git shortlog` command run between release tags `0.4.0-RC1` and `0.5.0-RC1`. This output lists the contributors to the Dotty project during this development cycle, showing the number of commits authored by each individual and serves to acknowledge the people who made the release possible.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2017-12-01-fifth-dotty-milestone-release.md#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n   112  Nicolas Stucki\n   108  Martin Odersky\n    33  Allan Renucci\n    18  Guillaume Martres\n    17  Martin Duhem\n    13  liu fengyun\n     9  Miron Aseev\n     4  Matt D'Souza\n     4  Raphael Bosshard\n     2  k0ala\n     2  Vitor Vieira\n     2  Fengyun Liu\n     2  Michal Gutowski\n     2  Robert Soeldner\n     2  Aurélien Richez\n     1  rsoeldner\n     1  Hermes Espínola González\n     1  Jean Detoeuf\n     1  Karol Chmist\n     1  Olivier Blanvillain\n     1  William Narmontas\n     1  Yevgen Nerush\n     1  gan74\n     1  gosubpl\n```\n\n----------------------------------------\n\nTITLE: Listing Contributors using Git Shortlog\nDESCRIPTION: Shows the output of the `git shortlog -sn --no-merges 0.17.0-RC1..0.18.1-RC1` command. It lists contributors to the project between the specified release candidate tags, sorted by the number of non-merge commits, acknowledging their contributions.\nSOURCE: https://github.com/scala/scala3/blob/main/docs/_blog/_posts/2019-08-30-18th-dotty-milestone-release.md#_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n   106  Nicolas Stucki\n    84  Martin Odersky\n    68  Guillaume Martres\n    26  Liu Fengyun\n    24  Jamie Thompson\n    23  Miles Sabin\n    16  Anatolii\n     8  Sébastien Doeraene\n     7  bishabosha\n     4  Aggelos Biboudis\n     4  Michał Gutowski\n     2  odersky\n     2  Nikolay\n     1  Master-Killer\n     1  Ashwin Bhaskar\n     1  Carlos Quiroz\n     1  =\n     1  Olivier Blanvillain\n     1  SrTobi\n```"
  }
]