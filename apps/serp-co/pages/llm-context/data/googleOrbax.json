[
  {
    "owner": "google",
    "repo": "orbax",
    "content": "TITLE: Importing Orbax and Setting Up Initial State\nDESCRIPTION: This snippet demonstrates how to import Orbax checkpoint, JAX, and NumPy libraries. It also sets up initial state, abstract state, metadata, and dataset variables for use in subsequent examples.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport orbax.checkpoint as ocp\nimport jax\nimport numpy as np\nfrom jax import numpy as jnp\n\npath = ocp.test_utils.erase_and_create_empty('/tmp/my-checkpoints/')\n\nstate = {'layer0': {'bias': np.ones((4,)), 'weight': jnp.arange(16)}}\nabstract_state = jax.tree.map(ocp.tree.to_shape_dtype_struct, state)\nmetadata = {'version': 1.0}\nextra_metadata = {'version': 1.0, 'step': 0}\ndataset = {'my_data': 2}\n```\n\n----------------------------------------\n\nTITLE: Creating CheckpointManager for Single Object\nDESCRIPTION: This snippet shows how to create a CheckpointManager for handling a single checkpointable object. It demonstrates setting up CheckpointManagerOptions and initializing the CheckpointManager.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n\ndirectory = ocp.test_utils.erase_and_create_empty('/tmp/checkpoint-manager-single/')\n```\n\nLANGUAGE: python\nCODE:\n```\noptions = ocp.CheckpointManagerOptions(\n    save_interval_steps=2,\n    max_to_keep=2,\n    # other options\n)\nmngr = ocp.CheckpointManager(\n    directory,\n    options=options,\n)\n```\n\n----------------------------------------\n\nTITLE: Defining and Training MNIST CNN Model with Flax\nDESCRIPTION: Implements a complete CNN model for MNIST classification including model definition, training and evaluation functions, gradient computation, and model update logic. Uses a simple CNN architecture with convolutional, pooling, and dense layers.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Define the model.\n\nclass Mnist(nn.Module):\n  \"\"\"A simple CNN model.\"\"\"\n\n  @nn.compact\n  def __call__(self, x):\n    x = nn.Conv(features=32, kernel_size=(3, 3))(x)\n    x = nn.relu(x)\n    x = nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2))\n    x = nn.Conv(features=64, kernel_size=(3, 3))(x)\n    x = nn.relu(x)\n    x = nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2))\n    x = x.reshape((x.shape[0], -1))  # flatten\n    x = nn.Dense(features=256)(x)\n    x = nn.relu(x)\n    x = nn.Dense(features=10)(x)\n    return x\n\n# Define train step.\n\n@jax.jit\ndef apply_model(state, images, labels):\n  \"\"\"Computes gradients, loss and accuracy for a single batch.\"\"\"\n\n  def loss_fn(params):\n    logits = state.apply_fn({'params': params}, images)\n    one_hot = jax.nn.one_hot(labels, 10)\n    loss = jnp.mean(optax.softmax_cross_entropy(logits=logits, labels=one_hot))\n    return loss, logits\n\n  grad_fn = jax.value_and_grad(loss_fn, has_aux=True)\n  (loss, logits), grads = grad_fn(state.params)\n  accuracy = jnp.mean(jnp.argmax(logits, -1) == labels)\n  return grads, loss, accuracy\n\n\n@jax.jit\ndef update_model(state, grads):\n  return state.apply_gradients(grads=grads)\n\n# Create train state.\n\ndef create_train_state(rng, config):\n  \"\"\"Creates initial `TrainState`.\"\"\"\n  mnist = Mnist()\n  params = mnist.init(rng, jnp.ones([1, 28, 28, 1]))['params']\n  tx = optax.sgd(config.learning_rate, config.momentum)\n  return train_state.TrainState.create(apply_fn=mnist.apply, params=params, tx=tx)\n\n# Define train loop.\n\ndef train_epoch(state, train_ds, batch_size, rng):\n  \"\"\"Train for a single epoch.\"\"\"\n  train_ds_size = len(train_ds['image'])\n  steps_per_epoch = train_ds_size // batch_size\n\n  perms = jax.random.permutation(rng, len(train_ds['image']))\n  perms = perms[: steps_per_epoch * batch_size]  # skip incomplete batch\n  perms = perms.reshape((steps_per_epoch, batch_size))\n\n  epoch_loss = []\n  epoch_accuracy = []\n\n  for perm in perms:\n    batch_images = train_ds['image'][perm, ...]\n    batch_labels = train_ds['label'][perm, ...]\n    grads, loss, accuracy = apply_model(state, batch_images, batch_labels)\n    state = update_model(state, grads)\n    epoch_loss.append(loss)\n    epoch_accuracy.append(accuracy)\n  train_loss = np.mean(epoch_loss)\n  train_accuracy = np.mean(epoch_accuracy)\n  return state, train_loss, train_accuracy\n\n# Define model training and evaluation loop.\ndef train_and_evaluate(\n    config: ml_collections.ConfigDict\n) -> train_state.TrainState:\n  \"\"\"Execute model training and evaluation loop.\n\n  Args:\n    config: Hyperparameter configuration for training and evaluation.\n\n  Returns:\n    The train state (which includes the `.params`).\n  \"\"\"\n  train_ds, test_ds = get_datasets()\n  rng = jax.random.key(0)\n\n  rng, init_rng = jax.random.split(rng)\n  state = create_train_state(init_rng, config)\n\n  for epoch in range(1, config.num_epochs + 1):\n    rng, input_rng = jax.random.split(rng)\n    state, train_loss, train_accuracy = train_epoch(\n        state, train_ds, config.batch_size, input_rng\n    )\n    # Evaluate model on test set.\n    _, test_loss, test_accuracy = apply_model(\n        state, test_ds['image'], test_ds['label']\n    )\n\n    print(\n        'epoch:% 3d, train_loss: %.4f, train_accuracy: %.2f, test_loss: %.4f,'\n        ' test_accuracy: %.2f'\n        % (\n            epoch,\n            train_loss,\n            train_accuracy * 100,\n            test_loss,\n            test_accuracy * 100,\n        )\n    )\n  # Return the train state (including the params/weights)\n  return state\n```\n\n----------------------------------------\n\nTITLE: Saving and Restoring a PyTree using Orbax StandardCheckpointer in Python\nDESCRIPTION: This code demonstrates how to save and restore a PyTree using Orbax's StandardCheckpointer. It creates a checkpointer, saves the tree to a specified path, and then restores it using the abstract tree structure.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_101.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncheckpointer = ocp.StandardCheckpointer()\n# 'checkpoint_name' must not already exist.\ncheckpointer.save(path / 'checkpoint_name', my_tree)\ncheckpointer.restore(\n    path / 'checkpoint_name/',\n    abstract_my_tree\n)\n```\n\n----------------------------------------\n\nTITLE: Managing Checkpoints with Orbax CheckpointManager in Python\nDESCRIPTION: This snippet shows how to use Orbax's CheckpointManager to save and manage multiple checkpoints over a series of steps. It demonstrates periodic saving, maximum checkpoint retention, and restoration of the latest checkpoint.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_101.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\npath = ocp.test_utils.erase_and_create_empty('/tmp/checkpoint_manager')\nstate = {\n    'a': np.arange(8),\n    'b': np.arange(16),\n}\nextra_params = [42, 43]\n\n# Keeps a maximum of 3 checkpoints, and only saves every other step.\noptions = ocp.CheckpointManagerOptions(max_to_keep=3, save_interval_steps=2)\nmngr = ocp.CheckpointManager(\n    path, options=options, item_names=('state', 'extra_params')\n)\n\nfor step in range(11):  # [0, 1, ..., 10]\n  mngr.save(\n      step,\n      args=ocp.args.Composite(\n          state=ocp.args.StandardSave(state),\n          extra_params=ocp.args.JsonSave(extra_params),\n      ),\n  )\nmngr.wait_until_finished()\nrestored = mngr.restore(10)\nrestored_state, restored_extra_params = restored.state, restored.extra_params\n```\n\n----------------------------------------\n\nTITLE: Setting Up JAX Mesh for Model Sharding\nDESCRIPTION: Creates a JAX sharding mesh to enable partitioning the model across multiple devices in two dimensions: 'data' and 'model'. This setup prepares for distributed model deployment.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport frozendict\nfrom jax.experimental import mesh_utils\n\n# Create mesh to enable sharding in 2 dimensions\nici_mesh = frozendict.frozendict({'data': 2, 'model': 2})\ndevices = mesh_utils.create_device_mesh(tuple(ici_mesh.values()))\nmesh = jax.sharding.Mesh(devices, tuple(ici_mesh.keys()))\nmesh\n```\n\n----------------------------------------\n\nTITLE: Saving a PyTree with StandardCheckpointHandler\nDESCRIPTION: Saves a PyTree of JAX arrays to disk using the asynchronous checkpointer and waits for the operation to complete.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nckptr.save(path / '1', args=ocp.args.StandardSave(state))\nckptr.wait_until_finished()\n```\n\n----------------------------------------\n\nTITLE: Exporting JAX Model to TensorFlow SavedModel\nDESCRIPTION: Demonstrates the core export process using Orbax's ExportManager. This combines the JAX module with serving configurations to create a TensorFlow SavedModel that can be reused in TensorFlow environments.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_101.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport tensorflow as tf\n\n# Construct a JaxModule where JAX->TF conversion happens.\njax_module = JaxModule(example1_params, example1_model_fn)\n# Export the JaxModule along with one or more serving configs.\nexport_mgr = ExportManager(\n  jax_module, [\n    ServingConfig(\n      'serving_default',\n      input_signature= [tf.TensorSpec(shape=[16], dtype=tf.float32)],\n      tf_preprocessor=example1_preprocess,\n      tf_postprocessor=example1_postprocess\n    ),\n])\noutput_dir='/tmp/example1_output_dir'\nexport_mgr.save(output_dir)\n```\n\n----------------------------------------\n\nTITLE: Creating Parameter Sharding Specification\nDESCRIPTION: Defines a function to create parameter sharding specifications for model deployment. Parameters are sharded across the 'model' dimension to distribute the model weights efficiently.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Create the parameter sharding spec.\nimport jax.sharding as jsharding\n\ndef create_params_sharding_spec(mesh, p):\n  specs = (None,) * (len(p.shape) - 1) + ('model',) if len(p.shape) > 0 else ()\n  return jax.sharding.NamedSharding(\n      mesh, jsharding.PartitionSpec(*specs))\n\nparams_sharding_spec = jax.tree_util.tree_map(\n    lambda p: create_params_sharding_spec(mesh, p), {'params':state.params})\n```\n\n----------------------------------------\n\nTITLE: Saving Model Parameters with Orbax Checkpoint\nDESCRIPTION: Saves the model parameters using Orbax Checkpoint and adds the checkpoint path to the OBM module.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n!rm -r  /tmp/model/my_checkpoint\ncheckpoint_path = 'my_checkpoint'\ncheckpoint_abs_path = os.path.join(save_dir_path, checkpoint_path)\ncheckpointer = ocp.Checkpointer(ocp.StandardCheckpointHandler())\ncheckpointer.save(checkpoint_abs_path, params)\nweights_name = 'my_weights'\nobm_module[weights_name] = jax2obm.main_lib.convert_path_to_value(\n    checkpoint_path,\n    mime_type='orbax_checkpoint',\n)\n```\n\n----------------------------------------\n\nTITLE: Training Loop with Checkpoint Saving using Orbax in Python\nDESCRIPTION: This snippet demonstrates a training loop that saves checkpoints periodically using Orbax's CheckpointManager. It includes a simple training function and saves the state at specified intervals.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_101.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nnum_steps = 10\noptions = ocp.CheckpointManagerOptions(max_to_keep=3, save_interval_steps=2)\nmngr = ocp.CheckpointManager(path, options=options)\n\n@jax.jit\ndef train_fn(state):\n  return jax.tree_util.tree_map(lambda x: x + 1, state)\n\nfor step in range(num_steps):\n  train_state = train_fn(train_state)\n  mngr.save(step, args=ocp.args.StandardSave(train_state))\nmngr.wait_until_finished()\n```\n\n----------------------------------------\n\nTITLE: Basic Preemption-Tolerant Training Loop with Orbax CheckpointManager\nDESCRIPTION: This example demonstrates how to set up a basic training loop with Orbax's CheckpointManager that automatically handles preemption. The checkpoint manager saves at regular intervals and can restore from the latest checkpoint when training restarts.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/preemption_checkpointing.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport orbax.checkpoint as ocp\n\nmngr = ocp.CheckpointManager(\n    '/tmp/mydir/',\n    ocp.PyTreeCheckpointer(),\n    ocp.CheckpointManagerOptions(save_interval_steps=4)\n)\n\ndef train_step(s):\n  return s\n\nstate = {'a': 1, 'b': 2}\nstart_step = 0\nnum_steps = 12\nif mngr.latest_step() is not None:\n  start_step = mngr.latest_step()\n  state = mngr.restore(start_step)\n\nfor step in range(start_step, num_steps):\n  state = train_step(state)\n  mngr.save(step, state)\n```\n\n----------------------------------------\n\nTITLE: Basic Checkpoint Manager Usage with Multiple Items in Python\nDESCRIPTION: Demonstrates how to save and restore multiple items (state and metadata) using Orbax's CheckpointManager with the Composite args approach. The example creates a directory, saves checkpoint data, and then restores it.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndirectory = ocp.test_utils.erase_and_create_empty('/tmp/checkpoint-manager-items-1/')\n\nmngr = ocp.CheckpointManager(directory)\nmngr.save(\n    0,\n    args=ocp.args.Composite(\n      state=ocp.args.StandardSave(state),\n      extra_metadata=ocp.args.JsonSave(extra_metadata),\n    )\n)\nrestored = mngr.restore(0)\nprint(restored.state)\nprint(restored.extra_metadata)\n```\n\n----------------------------------------\n\nTITLE: Averaging Weights with Multi-Value Transformations in Orbax\nDESCRIPTION: Example demonstrating how to compute derived values using multi_value_fn, specifically calculating the average of weights within each subtree.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Example: Average the weights\noriginal_tree = {\n    'a': {'a_1': 1, 'a_2': 2},\n    'b': {'b_1': 3, 'b_2': 4, 'b_3': 5},\n\n}\n\ntransformations = {\n    r'([a-z]+)': ocp.Transform(\n        multi_value_fn=lambda k, kv: sum(kv[k].values()) / len(kv[k])),\n}\n\n\nnew_tree = {\n    'a': ...,\n    'b': ...,\n}\n\nocp.apply_transformations(original_tree, transformations, new_tree)\n```\n\n----------------------------------------\n\nTITLE: Using asynchronous checkpointing with AsyncCheckpointer in Orbax\nDESCRIPTION: This demonstrates the recommended asynchronous checkpointing approach using AsyncCheckpointer. It initiates a save operation in a background thread, allowing the main thread to continue processing, and later uses wait_until_finished to ensure completion.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/async_checkpointing.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npath = epath.Path('/tmp/async_checkpoint')\nckptr = ocp.AsyncCheckpointer(ocp.StandardCheckpointHandler())\nckptr.save(path, args=ocp.args.StandardSave(train_state))\n### Do some other work...\nckptr.wait_until_finished()\n```\n\n----------------------------------------\n\nTITLE: Validating Exported Models with ValidationManager\nDESCRIPTION: Shows how to use Orbax's validation utilities to compare outputs between the original JAX model and the exported TensorFlow SavedModel. The ValidationManager automates the process of testing models with batch inputs and generating detailed comparison reports.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_101.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom orbax.export.validate import ValidationManager\nfrom orbax.export import JaxModule\nfrom orbax.export import ServingConfig\n\njax_module = JaxModule(example1_params, example1_model_fn)\nbatch_inputs = [inputs] * 16\n\nserving_configs = [\n  ServingConfig(\n      'serving_default',\n      input_signature= [tf.TensorSpec(shape=[16], dtype=tf.float32)],\n      tf_preprocessor=example1_preprocess,\n      tf_postprocessor=example1_postprocess\n    ),\n]\n# Provide computation method for the baseline.\nvalidation_mgr = ValidationManager(jax_module, serving_configs,\n                                       batch_inputs)\n\ntf_saved_model_path = \"/tmp/example1_output_dir\"\nloaded_model = tf.saved_model.load(tf_saved_model_path)\n\n# Provide the computation method for the candidate.\nvalidation_reports = validation_mgr.validate(loaded_model)\n\n# `validation_reports` is a python dict and the key is TF SavedModel serving_key.\nfor key in validation_reports:\n  assert(validation_reports[key].status.name == 'Pass')\n  # Users can also save the converted json to file.\n  print(validation_reports[key].to_json(indent=2))\n```\n\n----------------------------------------\n\nTITLE: Initializing PyTreeCheckpointHandler with OCDBT in Python\nDESCRIPTION: This snippet demonstrates how to initialize a PyTreeCheckpointHandler with the use_ocdbt option set to True, enabling the new optimized checkpoint format in Orbax.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/optimized_checkpointing.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport orbax.checkpoint as ocp\n\n# Initialize PyTreeCheckpointHandler with `use_ocdbt=True`.\n# This option already defaults to True, so it's optional to pass it in.\nckptr = ocp.Checkpointer(ocp.PyTreeCheckpointHandler(use_ocdbt=True))\n```\n\n----------------------------------------\n\nTITLE: Transforming Values with Regex Patterns in Orbax\nDESCRIPTION: Example showing how to use regex patterns to apply value transformations to multiple keys matching specific patterns, such as multiplying values by different factors.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Example 2: Transform values in a tree with regex (multiply all 'a' keys by 2\n# all 'b' keys by 3).\noriginal_tree = {\n    'a1': 1,\n    'a2': 2,\n    'b': 3\n}\n\ntransformations = {\n    r'a([0-9]?)\\*2': ocp.Transform(value_fn=lambda v: v * 2,\n                                     original_key=r'a\\1'),\n    r'b([0-9]?)\\*3': ocp.Transform(value_fn=lambda v: v * 3,\n                                     original_key=r'b\\1')\n}\n\nnew_tree = {\n    'a1*2': ...,\n    'a2*2': ...,\n    'b*3': ...\n}\n\nocp.apply_transformations(original_tree, transformations, new_tree)\n```\n\n----------------------------------------\n\nTITLE: Converting JAX Function to OBM Function\nDESCRIPTION: Demonstrates how to convert a JAX function to an OBM function using the jax2obm and tf2obm utilities. The conversion process includes handling structured outputs and specifications.\nSOURCE: https://github.com/google/orbax/blob/main/model/README.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom orbax_model import jax2obm\nfrom orbax_model import tf2obm\n\nargs_spec, kwargs_spec = tf2obm.tf_specs_to_jax(\n    pre_processor.structured_outputs)\nobm_apply_fn = jax2obm.convert(apply_fn, args_spec, kwargs_spec)\n```\n\n----------------------------------------\n\nTITLE: Restoring a Checkpoint with Transformations in Orbax\nDESCRIPTION: Example demonstrating how to save and restore a checkpoint with transformations, including defining dataclasses for different model versions and using the PyTreeCheckpointer.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport flax.struct\n\n@flax.struct.dataclass\nclass Small:\n    key1: int\n\n@flax.struct.dataclass\nclass Big:\n    key1: int\n    key2: int\n\nto_save = Big(key1=10, key2=100)\nto_restore = Small(key1=0)\n\npath = '/tmp/my-checkpoints/'\nckptr = ocp.PyTreeCheckpointer()\nckptr.save(path, to_save)\n\nrestored1 = ckptr.restore(\n  path, args=ocp.args.PyTreeRestore(\n    to_restore,\n    restore_args=ocp.checkpoint_utils.construct_restore_args(to_restore),\n    transforms={}\n  )\n)\nrestored2 = ckptr.restore(\n  path, args=ocp.args.PyTreeRestore(\n    to_restore,\n    restore_args=ocp.checkpoint_utils.construct_restore_args(to_restore),\n    transforms={\n        r'(.*)key1(.*)': ocp.Transform(original_key=r'\\1key2\\2')\n    }\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Using asynchronous checkpointing with CheckpointManager in Orbax\nDESCRIPTION: This shows how to use asynchronous checkpointing with Orbax's CheckpointManager in a training loop. The CheckpointManager handles saving checkpoints at different steps, and the wait_until_finished method ensures all checkpoint operations complete before exiting.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/async_checkpointing.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npath = epath.Path('/tmp/async_checkpoint_manager')\nckpt_mngr = ocp.CheckpointManager(path)\n\ndef train_step(step, state):\n  # update state values accordingly\n  return step + 1, state\n\nstep = 0\nnum_steps = 5\nwhile step < num_steps:\n  ckpt_mngr.save(step, args=ocp.args.StandardSave(train_state))\n  step, train_state = train_step(step, train_state)\n\nckpt_mngr.wait_until_finished()\n```\n\n----------------------------------------\n\nTITLE: Basic Key Renaming with Orbax Transform\nDESCRIPTION: Example demonstrating how to rename keys in a PyTree by providing Transform objects with original_key mappings. This allows migrating trees with different key structures.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example: Migrate original tree into the new_tree, which has the same\n# nested structure but different keys.\noriginal_tree = {\n    'a': 1,\n    'b': 2\n}\n\ntransformations = {\n    'a2': ocp.Transform(original_key='a'),\n    'b2': ocp.Transform(original_key='b')\n}\n\nnew_tree = {\n    'a2': ...,\n    'b2': ...\n}\n\nocp.apply_transformations(original_tree, transformations, new_tree)\n```\n\n----------------------------------------\n\nTITLE: Restoring Checkpoints with Different Sharding in Orbax and JAX\nDESCRIPTION: This code shows how to restore a checkpoint with different sharding constraints than how it was originally saved. It creates an abstract state and uses it to restore the checkpoint with new sharding specifications.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_101.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ntrain_state = jax.tree_util.tree_map(np.zeros_like, train_state)\nsharding = jax.sharding.NamedSharding(\n    jax.sharding.Mesh(jax.devices(), ('model',)),\n    jax.sharding.PartitionSpec(\n        None,\n    ),\n)\ncreate_sharded_array = lambda x: jax.device_put(x, sharding)\ntrain_state = jax.tree_util.tree_map(create_sharded_array, train_state)\nabstract_train_state = jax.tree_util.tree_map(\n    ocp.utils.to_shape_dtype_struct, train_state\n)\n\nrestored = mngr.restore(\n    mngr.latest_step(),\n    args=ocp.args.StandardRestore(abstract_train_state),\n)\n```\n\n----------------------------------------\n\nTITLE: Executing Model Training\nDESCRIPTION: Calls the train_and_evaluate function with the configured hyperparameters to train the MNIST model and obtain the final trained state.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Run model training and evaluation.\nstate = train_and_evaluate(get_config())\n```\n\n----------------------------------------\n\nTITLE: Saving Model Checkpoint with Orbax\nDESCRIPTION: Uses Orbax Checkpoint to save the trained model parameters to disk. Orbax provides a standardized checkpointing system for JAX-based models.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Write the checkpoint.\nimport orbax.checkpoint as ocp\nckpter = ocp.Checkpointer(ocp.StandardCheckpointHandler())\nckpter.save(\"/tmp/mnist/ckpt\", {'params': state.params})\n```\n\n----------------------------------------\n\nTITLE: Using Named Regex Groups with Orbax Transformations in Python\nDESCRIPTION: Demonstrates how to use named regex groups with (?P<name>...) syntax in Orbax transformations to map between different parameter naming conventions. The example shows transforming from a nested dictionary structure to a flattened one by capturing layer name, number, and weight components.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Example:\noriginal_tree = {\n    'dense_1': {'kernel': 2, 'bias': 3},\n}\n\ntransformations = {\n    r'(?P<layer>[a-z]+)_(?P<num>[0-9])_(?P<weight>[a-z]+)': ocp.Transform(\n        original_key=r'\\g<layer>_\\g<num>/\\g<weight>'),\n}\n\n\nnew_tree = {\n    'dense_1_kernel': ...,\n    'dense_1_bias': ...,\n}\n\nocp.apply_transformations(original_tree, transformations, new_tree)\n```\n\n----------------------------------------\n\nTITLE: Exporting to SavedModel\nDESCRIPTION: Exports the sharded JAX model to TensorFlow SavedModel format using Orbax and DTensor.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_work_together_with_dtensor.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport tempfile\nimport tensorflow as tf\nfrom orbax.export.validate import ValidationManager\nfrom orbax.export import ExportManager\nfrom orbax import export as obx_export\nfrom orbax.export import JaxModule\nfrom orbax.export import ServingConfig\n\nexport_dir =  tempfile.mkdtemp()\n\nwith mesh, dtensor_utils.maybe_enable_dtensor_export_on(mesh):\n  jax_module = JaxModule(sharded_params, sharded_model_fn, pspecs=params_pspecs)\n\n  serving_configs = [\n    ServingConfig(\n      'serving_default',\n      input_signature= [tf.TensorSpec(shape=[batch, dim_x], dtype=tf.float32, name='x')],\n    ),\n  ]\n  export_mgr = ExportManager(jax_module, serving_configs)\n  export_mgr.save(export_dir)\n```\n\n----------------------------------------\n\nTITLE: Model Layer Remapping Example in Orbax\nDESCRIPTION: Real-world example showing how to map parameters from an original model checkpoint to a new model with a different layer structure, handling both layer remapping and new layer initialization.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n transformations = {\n      # NewModel layer 0 is a newly inserted layer, thus use_fallback=True.\n      r'(.*)Dense_0(.*)': Transform(use_fallback=True),\n      # OriginalModel layer 0 maps to NewModel layer 1\n      r'(.*)Dense_1(.*)': Transform(original_key=r'\\1Dense_0\\2'),\n      # OriginalModel layer 1 maps to NewModel layer 2\n      r'(.*)Dense_2(.*)': Transform(original_key=r'\\1Dense_1\\2')\n  }  # Note: NewModel layer 3 is newly added.\n  restored_state = apply_transformations(original_state, transformations, new_state)\n```\n\n----------------------------------------\n\nTITLE: Creating Sharded JAX Arrays for Checkpointing\nDESCRIPTION: Creates a sharded state dictionary containing JAX arrays distributed across available devices, and prepares abstract representations for restoration.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsharding = jax.sharding.NamedSharding(\n    jax.sharding.Mesh(jax.devices(), ('model',)),\n    jax.sharding.PartitionSpec(\n        'model',\n    ),\n)\ncreate_sharded_array = lambda x: jax.device_put(x, sharding)\nstate = {\n    'a': np.arange(16),\n    'b': np.ones(16),\n}\nstate = jax.tree_util.tree_map(create_sharded_array, state)\nabstract_state = jax.tree_util.tree_map(ocp.utils.to_shape_dtype_struct, state)\n```\n\n----------------------------------------\n\nTITLE: Saving Multiple Objects with Orbax CompositeCheckpointHandler in Python\nDESCRIPTION: This code demonstrates how to save multiple objects with different types using Orbax's CompositeCheckpointHandler. It saves a PyTree state and JSON metadata as separate components of a single checkpoint.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_101.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmetadata = {\n    'version': 1.0,\n    'lang': 'en',\n}\n\ncheckpointer = ocp.Checkpointer(\n    ocp.CompositeCheckpointHandler()\n)\ncheckpointer.save(\n    path / 'composite_checkpoint',\n    args=ocp.args.Composite(\n        state=ocp.args.StandardSave(my_tree),\n        metadata=ocp.args.JsonSave(metadata),\n    ),\n)\nrestored = checkpointer.restore(path / 'composite_checkpoint')\n```\n\n----------------------------------------\n\nTITLE: Using StandardCheckpointer for PyTree Saving and Restoring\nDESCRIPTION: This snippet demonstrates how to use StandardCheckpointer to save and restore a PyTree of arrays to a given path.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nwith ocp.StandardCheckpointer() as ckptr:\n  ckptr.save(path / 'standard-ckpt-1', state)\n  result = ckptr.restore(path / 'standard-ckpt-1', abstract_state)\n  print(result)\n```\n\nLANGUAGE: python\nCODE:\n```\nwith ocp.AsyncCheckpointer(ocp.StandardCheckpointHandler()) as ckptr:\n  ckptr.save(path / 'standard-ckpt-2', args=ocp.args.StandardSave(state))\n```\n\n----------------------------------------\n\nTITLE: Using Custom CheckpointHandlers with Checkpointer\nDESCRIPTION: This snippet shows how to use custom CheckpointHandlers with Checkpointer for more specialized save and restore behavior, including JSON handling and asynchronous checkpointing.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nwith ocp.Checkpointer(ocp.JsonCheckpointHandler()) as ckptr:\n  ckptr.save(path / 'json-ckpt-1', args=ocp.args.JsonSave({'a': 'b'}))\n```\n\nLANGUAGE: python\nCODE:\n```\nckptr = ocp.AsyncCheckpointer(ocp.StandardCheckpointHandler())\n```\n\nLANGUAGE: python\nCODE:\n```\nwith ocp.Checkpointer(ocp.CompositeCheckpointHandler()) as ckptr:\n  ckptr.save(\n      path / 'composite-ckpt-1',\n      args=ocp.args.Composite(\n          state=ocp.args.StandardSave(state),\n          metadata=ocp.args.JsonSave(metadata),\n      )\n  )\n```\n\n----------------------------------------\n\nTITLE: Sharding JAX Model Across Devices\nDESCRIPTION: Creates a mesh of devices and shards the model parameters and input across them.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef get_mesh():\n  devices = mesh_utils.create_device_mesh((2, 2, 2))\n  return jax.sharding.Mesh(devices, ('b', 'x', 'y'))\n\n\nmesh = get_mesh()\n\nparams_sharding_spec = jax.tree_util.tree_map(\n    lambda _: NamedSharding(mesh, jax.sharding.PartitionSpec('y')), params\n)\ninput_sharding_spec = NamedSharding(mesh, PartitionSpec('b', 'x', None, None))\n\nmodel_apply_fn = jax.jit(\n    model.apply,\n    in_shardings=(\n        params_sharding_spec,\n        input_sharding_spec,\n    ),\n    out_shardings=NamedSharding(mesh, PartitionSpec('b', 'y')),\n)\n\nparams_args_spec = jax2obm.get_shape_dtype_struct(params)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Checkpoint Metadata in Orbax\nDESCRIPTION: Demonstrates how to obtain metadata about saved checkpoint items without specifying arguments, using the item_metadata method. Shows that CheckpointManager remembers how to interpret items from previous save operations.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmeta = mngr.item_metadata(1)\nprint(meta.state)\nmngr.close()\n```\n\n----------------------------------------\n\nTITLE: Creating a Sample Checkpoint with Orbax\nDESCRIPTION: Creates a sample checkpoint with nested dictionary structure containing NumPy arrays of various sizes. The checkpoint is saved to a temporary location using Orbax's StandardCheckpointer.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nstate = {\n    'a': {\n        'x': np.arange(2 ** 24),\n        'y': np.arange(1024),\n    },\n    'b': np.ones(8),\n    'c': 42,\n}\n\ndefault_param_name = 'a.x'\ndefault_path = epath.Path('/tmp/checkpoint')\nif default_path.exists():\n  default_path.rmtree()\nwith ocp.StandardCheckpointer() as ckptr:\n  ckptr.save(default_path, state)\n```\n\n----------------------------------------\n\nTITLE: Defining JAX MNIST Model\nDESCRIPTION: Creates a Flax MNIST model class with convolutional and dense layers.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Mnist(nn.Module):\n  \"\"\"Flax MNIST model.\"\"\"\n\n  @nn.compact\n  def __call__(self, x):\n    \"\"\"See base class.\"\"\"\n    x = nn.Conv(features=32, kernel_size=(4, 4))(x)\n    x = nn.relu(x)\n    x = nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2))\n    x = nn.Conv(features=64, kernel_size=(4, 4))(x)\n    x = nn.relu(x)\n    x = nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2))\n    x = x.reshape((x.shape[0], -1))  # flatten\n    x = nn.Dense(features=256)(x)\n    x = nn.relu(x)\n    x = nn.Dense(features=10)(x)\n    x = nn.log_softmax(x)\n    return x\n\n\nmodel = Mnist()\n```\n\n----------------------------------------\n\nTITLE: Exporting the Model with Orbax\nDESCRIPTION: Saves the complete model to disk using the Export Manager, including model parameters, computation graph, and serving configurations for later deployment.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n# Write model to disk.\nem.save(os.fspath(\"/tmp/mnist\"))\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Items with CheckpointManager\nDESCRIPTION: This snippet demonstrates how to use CheckpointManager to handle multiple items, such as training state, dataset, and custom metadata. It shows saving and restoring multiple items using Composite args.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndirectory = ocp.test_utils.erase_and_create_empty('/tmp/checkpoint-manager-multiple/')\n```\n\nLANGUAGE: python\nCODE:\n```\noptions = ocp.CheckpointManagerOptions(\n    save_interval_steps=2,\n    max_to_keep=2,\n    # other options\n)\nmngr = ocp.CheckpointManager(\n    directory,\n    options=options,\n)\n```\n\nLANGUAGE: python\nCODE:\n```\nnum_steps = 5\n\ndef train_step(step, _state, _extra_metadata):\n  return jax.tree_util.tree_map(lambda x: x + 1, _state), {**_extra_metadata, **{'step': step}}\n\nfor step in range(num_steps):\n  state, extra_metadata = train_step(step, state, extra_metadata)\n  mngr.save(\n      step,\n      args=ocp.args.Composite(\n        state=ocp.args.StandardSave(state),\n        extra_metadata=ocp.args.JsonSave(extra_metadata),\n      )\n  )\nmngr.wait_until_finished()\n```\n\nLANGUAGE: python\nCODE:\n```\nresult = mngr.restore(mngr.latest_step())\n```\n\nLANGUAGE: python\nCODE:\n```\nresult\n```\n\nLANGUAGE: python\nCODE:\n```\nresult.state\n```\n\nLANGUAGE: python\nCODE:\n```\nresult.extra_metadata\n```\n\nLANGUAGE: python\nCODE:\n```\nmngr.restore(mngr.latest_step(), args=ocp.args.Composite(extra_metadata=None))\n```\n\nLANGUAGE: python\nCODE:\n```\ndef set_dtype(abstract_arr):\n  abstract_arr.dtype = np.float32\n  return abstract_arr\n\nmngr.restore(\n    mngr.latest_step(),\n    args=ocp.args.Composite(\n      state=ocp.args.StandardRestore(jax.tree.map(set_dtype, abstract_state)),\n      extra_metadata=None\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a PyTree for Checkpointing with Orbax in Python\nDESCRIPTION: This snippet creates a basic PyTree structure, which is a nested dictionary containing numpy arrays. It also generates an abstract version of the tree for use in restoration.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_101.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmy_tree = {\n    'a': np.arange(8),\n    'b': {\n        'c': 42,\n        'd': np.arange(16),\n    },\n}\nabstract_my_tree = jax.tree_util.tree_map(\n    ocp.utils.to_shape_dtype_struct, my_tree)\n```\n\n----------------------------------------\n\nTITLE: Creating and Saving Orbax Checkpoint in Python\nDESCRIPTION: Demonstrates how to create a checkpoint for step 0, consisting of state and metadata, using Orbax CheckpointManager.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpoint_format.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npath = ocp.test_utils.erase_and_create_empty('/tmp/checkpoint')\n\nglobal_metadata = {'global_property': 'foo'}\nwith ocp.CheckpointManager(\n    path, item_names=('state', 'custom_data'), metadata=global_metadata\n) as mngr:\n  mngr.save(\n      0,\n      args=ocp.args.Composite(\n          state=ocp.args.PyTreeSave(state),\n          custom_data=ocp.args.JsonSave({'lang': 'en', 'version': 1.2}),\n      ),\n  )\n\nprint_directory(path)\n```\n\n----------------------------------------\n\nTITLE: Using synchronous checkpointing with Orbax (not recommended)\nDESCRIPTION: This demonstrates the traditional synchronous checkpointing approach in Orbax using the Checkpointer class with a StandardCheckpointHandler. This method blocks execution until the checkpoint is fully saved, which is less efficient than the async alternative.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/async_checkpointing.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n### PREFER NOT TO USE THIS. ###\n### PREFER TO USE ASYNC CHECKPOINTING INSTEAD (SEE BELOW). ###\n\npath = epath.Path('/tmp/sync_checkpoint')\nckptr = ocp.Checkpointer(ocp.StandardCheckpointHandler())\nckptr.save(path, args=ocp.args.StandardSave(train_state))\n```\n\n----------------------------------------\n\nTITLE: Extracting Parameter Value Metadata\nDESCRIPTION: Extracts metadata for a specific parameter from the checkpoint, providing a flattened view of the parameter's metadata that can be used for debugging.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nmetadata = ocp.StandardCheckpointer().metadata(path)\nvalue_metadata = {'.'.join(k): v for k, v in ocp.tree.to_flat_dict(metadata).items()}[param_name]\n```\n\n----------------------------------------\n\nTITLE: Saving Checkpoint with Custom Chunk Sizes Using Zarr3 in Python\nDESCRIPTION: This snippet demonstrates how to save a checkpoint using Orbax's CheckpointManager with custom chunk sizes and Zarr3 enabled. It shows the process of creating a temporary directory and saving the checkpoint with specified arguments.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/optimized_checkpointing.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntemp_dir = tempfile.TemporaryDirectory()\nmgr = ocp.CheckpointManager(epath.Path(temp_dir.name),\n                            item_handlers=ocp.PyTreeCheckpointHandler(use_zarr3=True)) # make sure zarr3 is enabled\n\nmgr.save(\n  0,\n  args=ocp.args.PyTreeSave(\n      pytree,\n      save_args=save_args,\n  ),\n)\n\nmgr.close()\n```\n\n----------------------------------------\n\nTITLE: Enhanced Preemption Handling with Immediate Exit\nDESCRIPTION: This code snippet extends the basic preemption-tolerant training loop by adding immediate exit after preemption checkpoint saving. It checks if a preemption was detected after each save, waits for the checkpoint to finish writing, then exits to save computing resources.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/preemption_checkpointing.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfor step in range(start_step, num_steps):\n  state = train_step(state)\n  mngr.save(step, state)\n  if mngr.reached_preemption(step):\n    mngr.wait_until_finished()\n    exit()\n```\n\n----------------------------------------\n\nTITLE: Creating Sharded Model Function\nDESCRIPTION: Instantiates a new MNIST model and creates a sharded version of the model's apply function using JAX's jit with appropriate input and output sharding specifications.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Create a new instance of the model.\nmodel = Mnist()\n\n# Shard the model function.\nmodel_apply_fn = jax.jit(\n  model.apply,\n  in_shardings=(\n      params_sharding_spec,\n      inputs_sharding_spec,\n  ),\n  out_shardings=jax.sharding.NamedSharding(\n      mesh,\n      jsharding.PartitionSpec(None),\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of CheckpointManager\nDESCRIPTION: This snippet demonstrates the basic usage of CheckpointManager, including saving checkpoints during a training loop, checking the latest step, retrieving all steps, and restoring from the latest checkpoint.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnum_steps = 5\n\ndef train_step(state):\n  return jax.tree_util.tree_map(lambda x: x + 1, state)\n\nfor step in range(num_steps):\n  state = train_step(state)\n  mngr.save(step, args=ocp.args.StandardSave(state))\nmngr.wait_until_finished()\n```\n\nLANGUAGE: python\nCODE:\n```\nmngr.latest_step()\n```\n\nLANGUAGE: python\nCODE:\n```\nmngr.all_steps()\n```\n\nLANGUAGE: python\nCODE:\n```\nmngr.restore(mngr.latest_step())\n```\n\n----------------------------------------\n\nTITLE: Flattening Nested PyTree Structures in Orbax\nDESCRIPTION: Example demonstrating how to restructure a nested PyTree into a flattened format by transforming nested keys into flat keys with naming patterns.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Example: Flatten nested structure\noriginal_tree = {\n    'a': 1,\n    'dense_1': {'kernel': 2, 'bias': 3},\n    'dense_2': {'kernel': 4, 'bias': 5},\n}\n\ntransformations = {\n    r'([a-z]+)': ocp.Transform(original_key=r'\\1'),\n    r'([a-z]+)_([0-9])_([a-z]+)': ocp.Transform(original_key=r'\\1_\\2/\\3'),\n}\n\n\nnew_tree = {\n    'a': ...,\n    'dense_1_kernel': ...,\n    'dense_1_bias': ...,\n    'dense_2_kernel': ...,\n    'dense_2_bias': ...,\n}\n\nocp.apply_transformations(original_tree, transformations, new_tree)\n```\n\n----------------------------------------\n\nTITLE: Creating Orbax Serving Configuration\nDESCRIPTION: Defines the serving configuration for the exported model, including the function signature key, input specifications, and pre/post-processing functions for end-to-end inference.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# Define the Orbax Export serving config.\nserving_config =osc.ServingConfig(\n    signature_key=model_function_name,\n    input_signature=input_args_spec,\n    tf_preprocessor=process_image,\n    tf_postprocessor=select_digit)\n```\n\n----------------------------------------\n\nTITLE: Customizing Data File Size for Improved I/O Parallelism in Python\nDESCRIPTION: This code snippet shows how to customize the data file size when saving checkpoints in Orbax. It uses the ocdbt_target_data_file_size parameter to control output file sizes, which can improve file I/O parallelism on remote storages like GCS.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/optimized_checkpointing.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntemp_dir = tempfile.TemporaryDirectory()\nmgr = ocp.CheckpointManager(temp_dir.name,\n                            item_handlers=ocp.PyTreeCheckpointHandler(use_zarr3=True))\n\nmgr.save(\n  0,\n  args=ocp.args.PyTreeSave(\n      pytree,\n      save_args=save_args,\n      ocdbt_target_data_file_size=10 * 1024, #10 KB, should be much larger than chunk_byte_size\n  ),\n)\n\nmgr.close()\n\ndata_dir = epath.Path(temp_dir.name) / '0'/ 'default'/ 'ocdbt.process_0'/ 'd'\nprint_directory_file_size(data_dir)\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Disk Usage Calculation for Checkpoints\nDESCRIPTION: Defines an asynchronous function to calculate the total size of a checkpoint on disk by recursively traversing the checkpoint directory structure and summing the sizes of all files.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def disk_usage(path: epath.Path) -> int:\n  \"\"\"Returns the size of the checkpoint on disk.\n\n  Note: this uses recurision because Orbax checkpoint directories are never\n  more than a few levels deep.\n\n  Args:\n    path: The path to the checkpoint.\n  Returns:\n    The size of the checkpoint on disk.\n  \"\"\"\n\n  async def helper(p):\n    if p.is_dir():\n      return await disk_usage(p)\n    else:\n      stat = await ocp.path.async_utils.async_stat(path)\n      return stat.length\n\n  futures = []\n  for p in path.iterdir():\n    futures.append(helper(p))\n  return sum(await asyncio.gather(*futures))\n```\n\n----------------------------------------\n\nTITLE: Initializing PyTreeCheckpointHandler for Advanced Options\nDESCRIPTION: Sets up an asynchronous checkpointer with PyTreeCheckpointHandler to access advanced saving and restoration options.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\npath = ocp.test_utils.erase_and_create_empty('/tmp/advanced/')\n# Make sure to use async for improved performance!\nckptr = ocp.AsyncCheckpointer(ocp.PyTreeCheckpointHandler())\n```\n\n----------------------------------------\n\nTITLE: Comparing Original and Loaded Model Results\nDESCRIPTION: Runs the original JAX function and the deserialized JAX function with their respective weights and compares the results.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nresult_from_original_jax_call = model_apply_fn(params, test_input_data)\nresult_from_deserialized_jax_call = deserialized_jax_exported.call(\n    jax.device_put(restored_params, params_sharding_spec),\n    test_input_data,\n)\n```\n\n----------------------------------------\n\nTITLE: Creating JAX Module for Orbax Export\nDESCRIPTION: Creates a JAX Module representation of the model for exporting with Orbax. Specifies parameter specs, model function, export version, and path to load checkpoints.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# Create a JAX Module.\nmodel_function_name = 'mnist_forward_fn'\n\norbax_module = jax_module.JaxModule(\n    params=params_arg_spec,\n    apply_fn={model_function_name: model_apply_fn},\n    export_version=constants.ExportModelType.ORBAX_MODEL, # Note this is a new version option.\n    jax2obm_kwargs={\n        constants.CHECKPOINT_PATH: os.fspath(\"ckpt\"),\n        },\n    )\n```\n\n----------------------------------------\n\nTITLE: Saving OBM Model to Disk\nDESCRIPTION: Shows how to save the complete OBM model to disk, including object dictionary, orchestration, and TensorFlow SavedModel components.\nSOURCE: https://github.com/google/orbax/blob/main/model/README.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nobm.save(obm_dict, \"path/to/my_orbax_model/\", obm.SaveOptions(\n    version=2,\n    supplemental_info={\n        \"orchestration\": obm.GlobalSupplemental(\n            orchestration, \"my_orchestration.pb\"),\n        \"tensorflow_saved_model\": obm.GlobalSupplemental(\n            tf2obm.tf_saved_model_as_obm_supplemental(\"tf_stuff/\"), None)}))\n```\n\n----------------------------------------\n\nTITLE: Setting Up Checkpoint Data with Custom Chunk Sizes in Python\nDESCRIPTION: This code sets up checkpoint data and creates save_args to customize the chunk_byte_size for Zarr3 storage in Orbax. It demonstrates how to prevent out-of-memory errors when reading on hosts with different sharding layouts.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/optimized_checkpointing.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# setup checkpoint data\narray_len = 8 * 1024\nkey = jax.random.PRNGKey(0)\nkey, subkey = jax.random.split(key)\npytree = {\n          'a': jax.random.normal(subkey, (array_len, ), dtype=jax.numpy.float32), # 32KB\n          'b': jax.random.normal(subkey, (array_len * 2, ), dtype=jax.numpy.float32), # 64KB\n}\n\n# create save_args to customize the chunk_byte_size\nsave_args = jax.tree_util.tree_map(\n    lambda x: ocp.SaveArgs(\n        chunk_byte_size=\n        1024,  # 1KB\n    ),\n    pytree,\n)\n```\n\n----------------------------------------\n\nTITLE: Restoring Custom-Saved PyTree\nDESCRIPTION: Restores the PyTree that was saved with custom dtype specifications.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nrestored = ckptr.restore(path / '2')\n```\n\n----------------------------------------\n\nTITLE: Preparing JAX Model Parameters and Functions for Export\nDESCRIPTION: Sets up the JAX model, its parameters, and preprocessing/postprocessing functions for export. The example model implements a simple function f(x) = a * sin(x) + b * x + c with configurable parameters.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_101.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Import Orbax Export classes.\nfrom orbax.export import ExportManager\nfrom orbax.export import JaxModule\nfrom orbax.export import ServingConfig\nimport numpy as np\nimport jax\nimport jax.numpy as jnp\nimport tensorflow as tf\n\n# Prepare the parameters and model function to export.\nexample1_params = {  'a': np.array(5.0), 'b': np.array(1.1), 'c': np.array(0.55)} # A pytree of the JAX model parameters.\n\n# model f(x) = a * sin(x) + b * x + c, here (a, b, c) are model parameters\ndef example1_model_fn(params, inputs):  # The JAX model function to export.\n  a, b, c = params['a'], params['b'], params['c']\n  return a * jnp.sin(inputs) + b * inputs + c\n\ndef example1_preprocess(inputs):  # Optional: preprocessor in TF.\n  norm_inputs = tf.nest.map_structure(lambda x: x/tf.math.reduce_max(x), inputs)\n  return norm_inputs\n\ndef example1_postprocess(model_fn_outputs):  # Optional: post-processor in TF.\n  return {'outputs': model_fn_outputs}\n```\n\n----------------------------------------\n\nTITLE: Checkpoint Item Type Locking in Orbax\nDESCRIPTION: Shows how an item's type is \"locked in\" after the first save. In this example, a new checkpoint is saved with the same item types, but the extra_metadata is set to None. Restoring still works without specifying args because the types are remembered.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmngr.save(1, args=ocp.args.Composite(\n    state=ocp.args.StandardSave(state), extra_metadata=None))\nrestored = mngr.restore(1)\nprint(restored.state)\nprint(restored.extra_metadata)\n```\n\n----------------------------------------\n\nTITLE: Using Multi-Value Transformations in Orbax\nDESCRIPTION: Example showing how to use multi_value_fn to create new values by combining or processing multiple values from the original tree, such as selecting specific elements or performing array operations.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Example: various multi_value_fn usage\noriginal_tree = {\n    'a': np.array([1, 2, 3, 4]),\n    'b': {'c': np.array([5, 6, 7, 8])},\n}\n\ntransformations = {\n    'a': ocp.Transform(multi_value_fn=lambda _, kv: kv['a'][-1]),\n    'b': {\n        'c': ocp.Transform(multi_value_fn=lambda _, kv: kv['a'] + kv['b']['c'])},\n}\n\n\nnew_tree = {\n    'a': ...,\n    'b': {'c': ...}\n}\n\nocp.apply_transformations(original_tree, transformations, new_tree)\n```\n\n----------------------------------------\n\nTITLE: Creating Sharded JAX Arrays for Checkpointing with Orbax in Python\nDESCRIPTION: This code creates a PyTree state with sharded JAX arrays as leaves, demonstrating how to set up a multi-host, multi-device environment for checkpointing with Orbax.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_101.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n\npath = ocp.test_utils.erase_and_create_empty('/tmp/checkpoint_manager_sharded')\n\nsharding = jax.sharding.NamedSharding(\n    jax.sharding.Mesh(jax.devices(), ('model',)),\n    jax.sharding.PartitionSpec(\n        'model',\n    ),\n)\ncreate_sharded_array = lambda x: jax.device_put(x, sharding)\ntrain_state = {\n    'a': np.arange(16),\n    'b': np.ones(16),\n}\ntrain_state = jax.tree_util.tree_map(create_sharded_array, train_state)\njax.tree_util.tree_map(lambda x: x.sharding, train_state)\n```\n\n----------------------------------------\n\nTITLE: Basic PyTree Restoration\nDESCRIPTION: Restores a PyTree saved with PyTreeCheckpointHandler using default options.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nrestored = ckptr.restore(path / '1')\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Inputs with JAX Model Export\nDESCRIPTION: Demonstrates how to work around the limitation that JAX modules can only take a single argument input. The example shows packaging multiple inputs into a single pytree structure through the preprocessor function.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_101.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nexample2_params = {} # A pytree of the JAX model parameters.\n\ndef example2_model_fn(params, inputs):\n  x, y = inputs\n  return x + y\n\ndef example2_preprocessor(x, y):\n  # put the normal tf_preprocessor codes here.\n  return [x, y] # pack it into a single list for jax model_func.\n\njax_module = JaxModule(example2_params, example2_model_fn)\nexport_mgr = ExportManager(\n  jax_module,\n  [\n      ServingConfig(\n          'serving_default',\n          input_signature=[tf.TensorSpec([16]), tf.TensorSpec([16])],\n          tf_preprocessor=example2_preprocessor,\n      )\n  ],\n)\noutput_dir='/tmp/example2_output_dir'\nexport_mgr.save(output_dir)\n\nloaded_model = tf.saved_model.load(output_dir)\nloaded_model_outputs = loaded_model(tf.random.normal([16]), tf.random.normal([16]))\nprint(\"loaded model output: \", loaded_model_outputs)\n```\n\n----------------------------------------\n\nTITLE: Pre-configuring Checkpoint Handler Registry in Orbax\nDESCRIPTION: Shows how to configure a CheckpointManager with a handler registry to specify behavior for restoring particular items. This example adds handlers for the 'state' item to enable restoration without providing the full arguments.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nregistry = ocp.handlers.DefaultCheckpointHandlerRegistry()\nregistry.add('state', ocp.args.StandardSave)\nregistry.add('state', ocp.args.StandardRestore)\nwith ocp.CheckpointManager(\n    directory,\n    handler_registry=registry,\n) as mngr:\n  print(mngr.restore(0, args=ocp.args.Composite(state=None)))\n  print('')\n  print(mngr.item_metadata(0))\n```\n\n----------------------------------------\n\nTITLE: Saving OBM Module with Orchestration\nDESCRIPTION: Saves the OBM module with additional orchestration information.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nobm.save(\n    obm_module,\n    save_dir_path,\n    obm.SaveOptions(\n        version=2,\n        supplemental_info=obm.GlobalSupplemental(\n            oex_orchestration.create(\n                signature=oex_orchestration.calculate_signature(\n                    model_function_signature=obm_shlo_fn.signature\n                ),\n                model_function_name=model_function_name,\n                weights_name=weights_name,\n            ),\n            'my_orchestration.pb',\n        ),\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Complex PyTree for Partial Restore Example\nDESCRIPTION: Prepares a nested PyTree with parameters, optimizer state, and step information to demonstrate partial restoration capabilities.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\noriginal_item = {\n    'params': {\n        'layer1': {\n            'kernel': np.arange(8),\n            'bias': np.arange(8),\n        },\n        'layer2': {\n            'kernel': np.arange(8),\n            'bias': np.arange(8),\n        },\n    },\n    'opt_state': [np.arange(8), np.arange(8)],\n    'step': 101,\n}\n\npath = ocp.test_utils.erase_and_create_empty('/tmp/partial/')\nckptr = ocp.PyTreeCheckpointer()\nckptr.save(path / '1', args=ocp.args.PyTreeSave(original_item))\n```\n\n----------------------------------------\n\nTITLE: Renaming Nested Trees in Orbax\nDESCRIPTION: Example showing how to rename keys in nested PyTrees using string representation with '/' separators or nested dictionaries of transformations.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example 3: Renaming nested trees\n\noriginal_tree = {\n    'a': 1,\n    'dense_1': {'kernel': 2, 'bias': 3},\n    'dense_2': {'kernel': 4, 'bias': 5},\n}\n\n# Nested keys can be represented by a single string by separating each level\n# with '/'.\ntransformations = {\n    r'([a-z]+)_NEW': ocp.Transform(original_key=r'\\1'),\n    r'([a-z]+)_([0-9])_NEW/([a-z]+)_1': ocp.Transform(original_key=r'\\1_\\2/\\3'),\n}\n\n# This is equivalent to:\ntransformations = {\n    r'([a-z]+)_NEW': ocp.Transform(original_key=r'\\1'),\n    r'([a-z]+)_([0-9])_NEW': {\n        '([a-z]+)_1': ocp.Transform(original_key=r'\\1_\\2/\\3'),}\n}\n\nnew_tree = {\n    'a_NEW': ...,\n    'dense_1_NEW': {'kernel_1': ..., 'bias_1': ...},\n    'dense_2_NEW': {'kernel_1': ..., 'bias_1': ...},\n}\n\nocp.apply_transformations(original_tree, transformations, new_tree)\n```\n\n----------------------------------------\n\nTITLE: Restoration with Key Transformation\nDESCRIPTION: Shows how to transform the PyTree structure during restoration by renaming keys and adding new elements.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nckptr.restore(\n    path / '2',\n    args=ocp.args.PyTreeRestore(\n        # `item` serves as a guide to what the result tree structure should look\n        # like.\n        item={\n            # Value doesn't really matter here, as long as it's not None.\n            'c': ...,\n            # Can add in extra keys.\n            'd': np.arange(8)\n        },\n        # `restore_args` must be relative to the result tree, not the\n        # checkpoint.\n        restore_args={\n          'c': ocp.RestoreArgs(restore_type=np.ndarray),\n        },\n        transforms={\n            'c': ocp.Transform(original_key='a')\n        },\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Loading and Preprocessing MNIST Dataset\nDESCRIPTION: Defines a function to download and prepare the MNIST dataset, normalizing pixel values to the range [0,1] for better training performance and converting to JAX NumPy arrays.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Load the MNIST train and test datasets into memory.\ndef get_datasets():\n\n  ds_builder = tfds.builder('mnist')\n  ds_builder.download_and_prepare()\n  train_ds = tfds.as_numpy(ds_builder.as_dataset(split='train', batch_size=-1))\n  test_ds = tfds.as_numpy(ds_builder.as_dataset(split='test', batch_size=-1))\n  train_ds['image'] = jnp.float32(train_ds['image']) / 255.0\n  test_ds['image'] = jnp.float32(test_ds['image']) / 255.0\n  return train_ds, test_ds\n```\n\n----------------------------------------\n\nTITLE: Basic PyTree Saving with PyTreeCheckpointHandler\nDESCRIPTION: Saves a PyTree using the PyTreeCheckpointHandler with default options to establish a baseline.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nckptr.save(path / '1', args=ocp.args.PyTreeSave(state))\nckptr.wait_until_finished()\n```\n\n----------------------------------------\n\nTITLE: Setting up the environment and sample data for Orbax checkpointing\nDESCRIPTION: This code snippet initializes the necessary imports and creates a sample train state to demonstrate checkpointing in Orbax. It sets up a simple neural network layer representation with kernel and bias parameters.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/async_checkpointing.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport orbax.checkpoint as ocp\nfrom etils import epath\n\ntrain_state = {\n    'layer0': {\n        'kernel': np.ones((8, 8), dtype=np.float32),\n        'bias': np.ones((8,), dtype=np.float32),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Saving with Custom Dtype Specification\nDESCRIPTION: Demonstrates saving a PyTree with custom save arguments that modify the dtype of one array during serialization.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nckptr.save(\n    path / '2',\n    args=ocp.args.PyTreeSave(\n        state,\n        save_args={\n          # We must set one ocp.SaveArgs per leaf.\n          'a': ocp.SaveArgs(dtype=np.dtype(np.int16)),\n          'b': ocp.SaveArgs()\n        }\n    ),\n)\nckptr.wait_until_finished()\n```\n\n----------------------------------------\n\nTITLE: Customizing Array Dtype During Restoration\nDESCRIPTION: Creates a modified abstract state that changes the dtype of restored arrays to int16, demonstrating how to control data types during restoration.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef set_restore_dtype(x: jax.ShapeDtypeStruct) -> jax.ShapeDtypeStruct:\n  x.dtype = np.int16\n  return x\n\ncast_dtype_abstract_state = jax.tree_util.tree_map(\n    set_restore_dtype, abstract_state)\n```\n\n----------------------------------------\n\nTITLE: Restoring with Additional Arguments in CheckpointManager\nDESCRIPTION: This snippet shows how to restore a checkpoint with additional arguments, such as modifying the dtype of the restored data.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef set_dtype(abstract_arr):\n  abstract_arr.dtype = np.float32\n  return abstract_arr\n\nmngr.restore(mngr.latest_step(), args=ocp.args.StandardRestore(\n    jax.tree.map(set_dtype, abstract_state)))\n```\n\n----------------------------------------\n\nTITLE: Initializing Orbax Checkpoint Environment in Python\nDESCRIPTION: Sets up the necessary imports and creates a sharded array state for demonstration purposes.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpoint_format.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom etils import epath\nimport jax\nimport numpy as np\nimport orbax.checkpoint as ocp\n\nsharding = jax.sharding.NamedSharding(\n    jax.sharding.Mesh(jax.devices(), ('model',)),\n    jax.sharding.PartitionSpec(\n        'model',\n    ),\n)\ncreate_sharded_array = lambda x: jax.device_put(x, sharding)\nstate = {\n    'a': np.arange(16),\n    'b': np.ones(16),\n}\nstate = jax.tree_util.tree_map(create_sharded_array, state)\nabstract_state = jax.tree_util.tree_map(ocp.utils.to_shape_dtype_struct, state)\nstate['c'] = np.arange(4)\nstate['d'] = 5\nstate['e'] = 'foo'\nstate\n```\n\n----------------------------------------\n\nTITLE: Restoring with Shape Padding/Truncation\nDESCRIPTION: Uses non-strict mode to allow arrays to be padded or truncated during restoration to match the requested target shapes.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nckptr.restore(\n    path / '1',\n    args=ocp.args.StandardRestore(different_shape_abstract_state, strict=False),\n)\n```\n\n----------------------------------------\n\nTITLE: Partial Restoration Using Placeholders\nDESCRIPTION: Demonstrates how to selectively restore parts of a PyTree by using placeholders to mark nodes that should be ignored during restoration.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nreference_item = {\n    'params': {\n        'layer1': {\n            'kernel': ocp.PLACEHOLDER,\n            'bias': ocp.PLACEHOLDER,\n        },\n        'layer2': {\n            'kernel': np.arange(8),\n            'bias': np.arange(8),\n        },\n    },\n    'opt_state': [ocp.PLACEHOLDER, ocp.PLACEHOLDER],\n    'step': 101,\n}\n\nckptr.restore(\n    path / '1',\n    args=ocp.args.PyTreeRestore(\n        item=reference_item,\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Advanced Restoration with Type and Dtype Customization\nDESCRIPTION: Demonstrates restoration with custom arguments to control the return type and dtype of specific arrays.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nckptr.restore(\n    path / '2',\n    args=ocp.args.PyTreeRestore(\n        restore_args={\n          # RestoreArgs is the parent class for ArrayRestoreArgs.\n          # We must set one RestoreArgs per leaf.\n          'a': ocp.RestoreArgs(restore_type=np.ndarray),\n          'b': ocp.ArrayRestoreArgs(dtype=np.dtype(np.int16), sharding=sharding)\n        }\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Working with TensorStore for Checkpoint Debugging in Python\nDESCRIPTION: Demonstrates how to use TensorStore API to debug individual parameters in a checkpoint, including setting up the context and reading array data.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpoint_format.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom etils import epath\nimport jax\nimport tensorstore as ts\n\nts_context = ts.Context(\n    {\n        # Provide cache pool for B-tree nodes to avoid repeated reads.\n        # 100MB limit.\n        'cache_pool#ocdbt': {'total_bytes_limit': 100000000},\n    },\n    parent=jax.experimental.array_serialization.serialization.TS_CONTEXT,\n)\n\nParamInfo = ocp.type_handlers.ParamInfo\nstate_dir = path / '0' / 'state'\nparam_name = 'a'\nparam_path = state_dir / param_name\ninfo = ParamInfo(name='a', path=path, parent_dir=state_dir, is_ocdbt_checkpoint=True, use_zarr3=True)\ntspec = ocp.type_handlers.get_json_tspec_read(info, use_ocdbt=True)\ntspec\n\nts.KvStore.open({\"driver\": \"ocdbt\", \"base\": \"file:///tmp/checkpoint/0/state/\"}).result().list().result()\n\ntspec = {'driver': 'zarr', 'kvstore': {'driver': 'ocdbt', 'base': 'file:///tmp/checkpoint/0/state/', 'path': 'a'}}\nt = ts.open(ts.Spec(tspec), open=True, context=ts_context).result()\nresult = t.read().result()\nresult\n```\n\n----------------------------------------\n\nTITLE: Retrieving Checkpoint Metadata with Orbax in Python\nDESCRIPTION: This snippet shows how to retrieve metadata about a saved checkpoint using Orbax's metadata function, which allows for easy inspection of checkpoint properties.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_101.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncheckpointer.metadata(path / 'checkpoint_name')\n```\n\n----------------------------------------\n\nTITLE: Modifying Sharding During Restoration\nDESCRIPTION: Creates a new sharding specification and applies it to the abstract state to change how arrays are distributed across devices during restoration.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nsharding = jax.sharding.NamedSharding(\n    jax.sharding.Mesh(jax.devices(), ('x',)),\n    jax.sharding.PartitionSpec(),\n)\ndef set_sharding(x: jax.ShapeDtypeStruct) -> jax.ShapeDtypeStruct:\n  x.sharding = sharding\n  return x\n\nchange_sharding_abstract_state = jax.tree_util.tree_map(\n    set_sharding, abstract_state)\nrestored = ckptr.restore(\n    path / '1',\n    args=ocp.args.StandardRestore(change_sharding_abstract_state),\n)\n```\n\n----------------------------------------\n\nTITLE: Converting JAX Function to SHLO and Creating OBM Module\nDESCRIPTION: Converts the JAX function to SHLO format and adds it to an OBM module.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nobm_shlo_fn = jax2obm.convert(\n    model_apply_fn,\n    (params_args_spec, input_args_spec),\n    {},\n)\n\nobm_module = dict()\nmodel_function_name = 'mnist_forward_fn'\nobm_module[model_function_name] = obm_shlo_fn\n```\n\n----------------------------------------\n\nTITLE: Restoring Model Parameters from Checkpoint\nDESCRIPTION: Loads the saved model parameters from the Orbax Checkpoint.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nloaded_weights_name = orch_proto.weights_name\nloaded_checkpoint_path = manifest_proto.objects[\n    loaded_weights_name\n].value.external.data.file_system_location.string_path\nrestored_params = checkpointer.restore(\n    os.path.join(save_dir_path, loaded_checkpoint_path)\n)\n```\n\n----------------------------------------\n\nTITLE: Restoring a PyTree with Abstract State\nDESCRIPTION: Restores a PyTree using an abstract state specification that defines the expected shapes, dtypes, and shardings of the arrays.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nrestored = ckptr.restore(path / '1', args=ocp.args.StandardRestore(abstract_state))\n```\n\n----------------------------------------\n\nTITLE: Updating Values in a PyTree with Orbax\nDESCRIPTION: Using Transform with value_fn to modify leaf node values in a PyTree. This approach can be useful for quantization, hyperparameter adjustments, or other value modifications.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Example: Transform the values in a tree.\noriginal_tree = {\n    'a': 1,\n    'b': 2\n}\n\ntransformations = {\n    'a': ocp.Transform(value_fn=lambda v: v * 2),\n    'b2': ocp.Transform(value_fn=lambda v: v * 3, original_key='b')\n}\n\nnew_tree = {\n    'a': ...,\n    'b2': ...  # Output different key\n}\n\nocp.apply_transformations(original_tree, transformations, new_tree)\n```\n\n----------------------------------------\n\nTITLE: Defining the apply_transformations Function in Orbax\nDESCRIPTION: Function signature for apply_transformations which transforms PyTrees using Transform objects. It takes an original tree, transformation specifications, and a target structure to produce a new PyTree.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef apply_transformations(\n    original_tree: PyTree,\n    transformations: PyTree,\n    new_tree: PyTree,\n    default_to_original: Optional[bool] = True) -> PyTree:\n```\n\n----------------------------------------\n\nTITLE: Plotting Prediction Results with Matplotlib in Python\nDESCRIPTION: This function plots the original image along with the predicted label using Matplotlib. It includes utility functions for image processing and display, ensuring proper formatting and clipping of pixel values.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_35\n\nLANGUAGE: Python\nCODE:\n```\n# # Plot result!\n\n# from matplotlib import pyplot as plt\n# import numpy as np\n# from PIL import Image\n\n# def plot_image(image, title=\"\"):\n#   \"\"\"Plots images from image tensors.\n\n#   Args:\n#     image: 3D image tensor. [height, width, channels].\n#     title: Title to display in the plot.\n#   \"\"\"\n#   image = np.asarray(image)\n#   image = tf.clip_by_value(image, 0, 255)\n#   image = Image.fromarray(tf.cast(image, tf.uint8).numpy())\n#   plt.imshow(image)\n#   plt.axis(\"off\")\n#   plt.title(title)\n\n# plot_image(original_image, title=f\"predicted_label={predicted_labels[0]}\")\n```\n\n----------------------------------------\n\nTITLE: New Multiple-Item Checkpointing Implementation\nDESCRIPTION: Demonstrates the new approach to checkpointing multiple items using Composite args\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/api_refactor.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\noptions = ocp.CheckpointManagerOptions()\nmngr = ocp.CheckpointManager(\n  ocp.test_utils.erase_and_create_empty('/tmp/ckpt4/'),\n  # `item_names` defines an up-front contract about what items the\n  # CheckpointManager will be dealing with.\n  options=options,\n)\n\nmngr.save(0, args=ocp.args.Composite(\n    state=ocp.args.StandardSave(pytree),\n    extra_metadata=ocp.args.JsonSave(extra_metadata))\n)\nmngr.wait_until_finished()\n```\n\n----------------------------------------\n\nTITLE: Cleaning Up Variables\nDESCRIPTION: Removes variables that will be provided by the manifest at load time.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndel model_function_name\ndel weights_name\ndel checkpoint_path\ndel checkpoint_abs_path\n```\n\n----------------------------------------\n\nTITLE: Defining Parameter Specifications for Export\nDESCRIPTION: Creates parameter specifications that capture the shape and data type of model parameters, needed for model export without loading actual parameter values.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Define the spec of the parameters.\nparams_arg_spec = jax.tree_util.tree_map(\n    lambda p: jax.ShapeDtypeStruct(p.shape, p.dtype), {'params':state.params})\n```\n\n----------------------------------------\n\nTITLE: Defining TensorFlow Preprocessing Function\nDESCRIPTION: Implements a TensorFlow preprocessing function to convert input images to the format expected by the model, including RGB to grayscale conversion, resizing to 28x28, and normalization.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Define TF pre- and post-processing functions for serving.\nimport tensorflow as tf\n\n# The data preprocessing function for resizing images\ndef process_image(x: tf.Tensor) -> tf.Tensor:\n  # x is a uint8 tensor of shape (b, length, width, 3).\n  gray_image = tf.image.rgb_to_grayscale(x)\n  resized_image = tf.image.resize(gray_image, [28, 28]) / 255.0\n  return resized_image\n\n```\n\n----------------------------------------\n\nTITLE: Asserting Equality of Model Results\nDESCRIPTION: Verifies that the results from the original and deserialized models are identical.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nassert jnp.array_equal(\n    result_from_deserialized_jax_call, result_from_original_jax_call\n)\n```\n\n----------------------------------------\n\nTITLE: Analyzing Implied Checkpoint Size from Metadata\nDESCRIPTION: Calculates the implied size of the checkpoint based on the checkpoint's metadata by summing the sizes of all parameters, and displays the distribution of data types across the checkpoint.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nmetadata = ocp.StandardCheckpointer().metadata(path)\nsize_counts = collections.defaultdict(int)\n\ndef get_arr_bytes(meta):\n  dtype = meta.dtype\n  shape = meta.shape\n  size_counts[dtype] += 1\n  return np.prod(shape) * np.dtype(dtype).itemsize\n\ntotal_bytes = jax.tree.reduce(operator.add, jax.tree.map(get_arr_bytes, metadata))\nprint('{0:0.3f} GB'.format(float(total_bytes) / 1e9))\nprint()\nprint('leaf dtype counts:')\nfor dtype, count in size_counts.items():\n  print(f'{dtype}: {count}')\n```\n\n----------------------------------------\n\nTITLE: Loading Model with Orbax Model Runner\nDESCRIPTION: Initializes the Orbax Model Runner with the exported model's path to prepare for inference. The runner provides a high-performance interface for model execution.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n# Runner is in C++ with a Python API.\nrunner = orbax_model_runner.ModelRunner(model_path=\"/tmp/mnist\")\nrunner\n```\n\n----------------------------------------\n\nTITLE: Verifying Output Equality Between JAX and TensorFlow Models\nDESCRIPTION: Uses NumPy's testing utilities to verify that the outputs from the original JAX model and the exported TensorFlow model are numerically equivalent within specified tolerance thresholds.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_101.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnp.testing.assert_allclose(model_outputs['outputs'], loaded_model_outputs['outputs'], atol=1e-5, rtol=1e-5)\n```\n\n----------------------------------------\n\nTITLE: Defining TensorFlow Postprocessing Function\nDESCRIPTION: Implements a TensorFlow postprocessing function to convert model outputs (logits) to predicted digit classes by taking the argmax along the class dimension.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# The post-processing function for selecting the most probable class.\ndef select_digit(x: tf.Tensor) -> tf.Tensor:\n  return tf.math.argmax(x, axis=1)\n```\n\n----------------------------------------\n\nTITLE: Creating OBM Dictionary\nDESCRIPTION: Shows how to create a Python dictionary containing OBM functions and values for model components.\nSOURCE: https://github.com/google/orbax/blob/main/model/README.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nobm_dict = {\"my_model_fn\": obm_apply_fn,\n     \"my_weights\": obm_weights,\n     \"my_pre_processor\": obm_pre_processor,\n     \"my_post_processor\": obm_post_processor}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Item Type Lock-in Constraints in Orbax\nDESCRIPTION: Illustrates the constraint that once an item type is \"locked in\", it cannot be changed without reinitializing the CheckpointManager. Attempting to save an item with a different handler type results in an error.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nwith ocp.CheckpointManager(\n    directory,\n    handler_registry=registry,\n) as mngr:\n  mngr.save(2, args=ocp.args.PyTreeSave({'a': 'b'}))\n  try:\n    print(mngr.save(3, args=ocp.args.JsonSave({'a': 'b'})))\n  except BaseException as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Testing JAX Model Execution with Pre/Post Processing\nDESCRIPTION: Tests the JAX model by generating random inputs, applying preprocessing, running the model, and then applying postprocessing to verify the complete pipeline works correctly before export.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_101.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ninputs = tf.random.normal([16], dtype=tf.float32)\n\nmodel_outputs = example1_postprocess(example1_model_fn(example1_params, np.array(example1_preprocess(inputs))))\nprint(\"model output: \", model_outputs)\n```\n\n----------------------------------------\n\nTITLE: Loading and Displaying Parameter Array Values\nDESCRIPTION: Uses TensorStore to load and display the actual array values for a specific parameter in the checkpoint, allowing direct inspection of parameter values for debugging purposes.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nParamInfo = ocp.type_handlers.ParamInfo\nts_context = ts.Context({\n    'file_io_concurrency': {'limit': 128},\n    'cache_pool#ocdbt': {'total_bytes_limit': 100000000},\n})\n\ninfo = ParamInfo(name=param_name, path=path / param_name, parent_dir=path, is_ocdbt_checkpoint=True, use_zarr3=False)\ntspec = ocp.type_handlers.get_json_tspec_read(info, use_ocdbt=True)\n\nt = ts.open(ts.Spec(tspec), open=True, context=ts_context).result()\narr = t.read().result()\nprint(arr)\n```\n\n----------------------------------------\n\nTITLE: Verifying TensorStore Consistency with Checkpoint Metadata\nDESCRIPTION: Lists parameters from TensorStore's perspective and verifies that they match the parameters tracked by the checkpoint metadata, which helps identify potential inconsistencies.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Note: instead of \"file\", use:\n#   - \"gfile\" on Google-internal filesystems.\n#   - \"gs\" on GCS (do not repeat the \"gs://\" prefix)\nts_contents = ts.KvStore.open({\"driver\": \"ocdbt\", \"base\": f\"file://{path.as_posix()}\"}).result().list().result()\nts_contents = [p.decode(\"utf-8\") for p in ts_contents]\nts_contents = [p.replace('.zarray', '')[:-1] for p in ts_contents if '.zarray' in p]\n\n# We can assert that the parameters tracked by the metadata file are\n# the same as those tracked by Tensorstore. If there is a discrepancy, there may\n# be a deeper underlying problem.\n\nassert len(metadata_contents) == len(ts_contents) and sorted(metadata_contents) == sorted(ts_contents)\n```\n\n----------------------------------------\n\nTITLE: Displaying Parameters in Checkpoint Tree\nDESCRIPTION: Prints all parameter paths present in the checkpoint tree, helping users verify that expected parameters exist in the checkpoint.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Here are the parameters present in the checkpoint tree.\nfor p in metadata_contents:\n  print(p)\n```\n\n----------------------------------------\n\nTITLE: Using CheckpointManager.metadata() with step parameter\nDESCRIPTION: Example of the new CheckpointManager.metadata() function that now accepts a step parameter to return StepMetadata. Without the step parameter, it returns RootMetadata.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_announcements.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nCheckpointManager.metadata()\n```\n\n----------------------------------------\n\nTITLE: Basic Checkpointing with StandardCheckpointHandler\nDESCRIPTION: Initializes an asynchronous checkpointer with StandardCheckpointHandler to efficiently work with PyTrees of JAX arrays.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npath = ocp.test_utils.erase_and_create_empty('/tmp/basic/')\n# Make sure to use async for improved performance!\nckptr = ocp.AsyncCheckpointer(ocp.StandardCheckpointHandler())\n```\n\n----------------------------------------\n\nTITLE: Restoring with Modified Dtype\nDESCRIPTION: Applies the modified abstract state to restore arrays with a different dtype than originally saved.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nckptr.restore(\n    path / '1',\n    args=ocp.args.StandardRestore(cast_dtype_abstract_state),\n)\n```\n\n----------------------------------------\n\nTITLE: Legacy Multiple-Item Checkpointing Implementation\nDESCRIPTION: Shows the old approach to checkpointing multiple items with different handlers\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/api_refactor.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\noptions = ocp.CheckpointManagerOptions()\nmngr = ocp.CheckpointManager(\n  ocp.test_utils.erase_and_create_empty('/tmp/ckpt3/'),\n  {\n      'state': ocp.Checkpointer(ocp.PyTreeCheckpointHandler()),\n      'extra_metadata': ocp.Checkpointer(ocp.JsonCheckpointHandler())\n  },\n  options=options,\n)\n\nrestore_args = ocp.checkpoint_utils.construct_restore_args(abstract_pytree)\nmngr.save(0, {'state': pytree, 'extra_metadata': extra_metadata})\nmngr.wait_until_finished()\n\nmngr.restore(\n    0,\n    items={'state': abstract_pytree, 'extra_metadata': None},\n    restore_kwargs={\n        'state': {'restore_args': restore_args},\n        'extra_metadata': None\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Extracting Checkpoint Tree Metadata\nDESCRIPTION: Extracts the checkpoint tree metadata to get a flat dictionary of parameter paths in the checkpoint, which is useful for debugging parameter loading issues.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmetadata = ocp.StandardCheckpointer().metadata(path)\nmetadata_contents = ['.'.join(k) for k in ocp.tree.to_flat_dict(metadata)]\n```\n\n----------------------------------------\n\nTITLE: Disabling asynchronous checkpointing in CheckpointManager\nDESCRIPTION: This code snippet shows how to disable asynchronous checkpointing in the CheckpointManager by setting the enable_async_checkpointing option to False when creating the CheckpointManagerOptions.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/async_checkpointing.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nocp.CheckpointManagerOptions(enable_async_checkpointing=False)\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Orbax Checkpoint Debugging\nDESCRIPTION: Imports necessary Python libraries for working with Orbax checkpoints, including JAX, NumPy, epath, Orbax checkpoint module, TensorStore, and other utilities for async operations and data manipulation.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport jax\nimport numpy as np\nfrom etils import epath\nimport orbax.checkpoint as ocp\nimport tensorstore as ts\nimport collections\nimport operator\nimport asyncio\n```\n\n----------------------------------------\n\nTITLE: Listing Exported Model Directory Contents\nDESCRIPTION: Lists the contents of the exported model directory to verify the export was successful and examine the exported artifacts.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n!ls /tmp/mnist\n```\n\n----------------------------------------\n\nTITLE: Handling Unconfigured Checkpoint Handler Error in Orbax\nDESCRIPTION: Illustrates the error that occurs when trying to restore items without properly configured handlers in a new CheckpointManager instance. Shows how item_metadata returns None for items that exist but can't be reconstructed.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_api_overview.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nwith ocp.CheckpointManager(directory) as mngr:\n  try:\n    print(mngr.restore(0))\n  except BaseException as e:\n    print(e)\n  print('')\n  print(mngr.item_metadata(0))\n```\n\n----------------------------------------\n\nTITLE: Creating Abstract State with Different Shapes\nDESCRIPTION: Prepares an abstract state with modified array shapes - one smaller and one larger than the original saved arrays.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndifferent_shape_abstract_state = {\n    'a': jax.ShapeDtypeStruct(\n        shape=(8,),\n        dtype=abstract_state['a'].dtype,\n        sharding=abstract_state['a'].sharding\n    ),\n    'b': jax.ShapeDtypeStruct(\n        shape=(32,),\n        dtype=abstract_state['b'].dtype,\n        sharding=abstract_state['b'].sharding\n    ),\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Orbax Export Manager\nDESCRIPTION: Initializes an Export Manager to handle the model export process, configuring it with the JAX module and serving configurations defined previously.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# Create the Orbax Export Manager.\nem = export_manager.ExportManager(\n    module = orbax_module,\n    serving_configs = [serving_config])\n```\n\n----------------------------------------\n\nTITLE: Checking Modified Sharding\nDESCRIPTION: Verifies that the restored array has the new sharding specification that was applied during restoration.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nrestored['a'].sharding\n```\n\n----------------------------------------\n\nTITLE: Installing Orbax Checkpoint from PyPi\nDESCRIPTION: Command to install the Orbax checkpoint library from the PyPi package repository, which provides the latest stable release.\nSOURCE: https://github.com/google/orbax/blob/main/checkpoint/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install orbax-checkpoint\n```\n\n----------------------------------------\n\nTITLE: Checking Sharding of Restored Array\nDESCRIPTION: Verifies that the sharding specification was correctly preserved during the restoration process.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nrestored['a'].sharding\n```\n\n----------------------------------------\n\nTITLE: Initializing Model Parameters\nDESCRIPTION: Initializes the model parameters with random values and specified input shape.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ninput_args_spec = jax.ShapeDtypeStruct((4, 28, 28, 1), jnp.float64)\nparams = model.init(\n    jax.random.PRNGKey(666),\n    jnp.ones(shape=input_args_spec.shape, dtype=input_args_spec.dtype),\n)\n```\n\n----------------------------------------\n\nTITLE: Attempting Strict Shape Restoration (Error Example)\nDESCRIPTION: Demonstrates that by default, attempting to restore arrays with different shapes results in an error when strict mode is enabled.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ntry:\n  ckptr.restore(\n      path / '1',\n      args=ocp.args.StandardRestore(different_shape_abstract_state),\n  )\nexcept BaseException as e:\n  print(e)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Restored JAX Array Data\nDESCRIPTION: Examines the content of the restored PyTree to verify its structure and data were preserved correctly.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nrestored\n```\n\n----------------------------------------\n\nTITLE: Implementing Directory Tree Printing Function in Python\nDESCRIPTION: Defines a function to print a directory tree for debugging purposes, useful for visualizing the checkpoint structure.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpoint_format.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef print_directory(directory: epath.PathLike, level: int = 0):\n  \"\"\"Prints a directory tree for debugging purposes.\"\"\"\n  directory = epath.Path(directory)\n  assert directory.is_dir()\n  level_str = '..' * level\n  if level == 0:\n    print(f'Printing directory tree: {directory}/')\n  else:\n    print(f'{level_str}{directory.name}/')\n\n  level_str = '..' * (level + 1)\n  for p in directory.iterdir():\n    if p.is_dir():\n      print_directory(p, level=level + 1)\n    else:\n      print(f'{level_str}{p.name}')\n```\n\n----------------------------------------\n\nTITLE: Displaying Parameter Shape and Data Type\nDESCRIPTION: Prints the shape and data type of a specific parameter from its metadata, which helps verify that the parameter has the expected dimensions and type.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nprint(f'shape: {value_metadata.shape}')\nprint(f'dtype: {value_metadata.dtype}')\n```\n\n----------------------------------------\n\nTITLE: Loading and Testing the Exported TensorFlow SavedModel\nDESCRIPTION: Loads the previously exported TensorFlow SavedModel and tests it with the same inputs to verify that it produces matching outputs compared to the original JAX model.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_101.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nloaded_model = tf.saved_model.load(output_dir)\nloaded_model_outputs = loaded_model(inputs)\nprint(\"loaded model output: \", loaded_model_outputs)\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for JAX and Orbax\nDESCRIPTION: Imports necessary libraries including JAX, Flax, and Orbax components for model creation, sharding, and checkpointing.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport re\nimport absl.flags as flags\nimport flax.linen as nn\nimport jax\nfrom jax.experimental import mesh_utils\nimport jax.numpy as jnp\nfrom jax.sharding import NamedSharding\nfrom jax.sharding import PartitionSpec\nimport orbax.checkpoint as ocp\n```\n\n----------------------------------------\n\nTITLE: Configuring JAX to Use CPU Devices\nDESCRIPTION: Sets up JAX to use CPU devices for training in this demo, configuring 8 CPU devices and updating JAX settings.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnum_cpu_devices = 8\nxla_flags = os.getenv('XLA_FLAGS', '')\nxla_flags = re.sub(\n    r'--xla_force_host_platform_device_count=\\S+', '', xla_flags\n).split()\nos.environ['XLA_FLAGS'] = ' '.join(\n    [f'--xla_force_host_platform_device_count={num_cpu_devices}'] + xla_flags\n)\njax.config.update('jax_platforms', 'cpu')\nflags.FLAGS.jax_allow_unused_tpus = True\njax.devices()\n```\n\n----------------------------------------\n\nTITLE: Deserializing JAX Function\nDESCRIPTION: Converts the loaded OBM function back into a JAX function.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndeserialized_jax_exported = obm_to_jax.obm_functions_to_jax_function(\n    loaded_obm_function,\n    jax_supplemental_proto,\n)\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for Flax Model Development\nDESCRIPTION: Imports essential libraries for building and training neural networks with JAX and Flax, including Flax's linen module for model definition, training utilities, NumPy variants, and TensorFlow datasets.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom flax import linen as nn\nfrom flax.training import train_state\nimport jax.numpy as jnp\nimport ml_collections\nimport numpy as np\nimport optax\nimport tensorflow_datasets as tfds\n```\n\n----------------------------------------\n\nTITLE: Setting up Checkpoint Path for Analysis\nDESCRIPTION: Configures the checkpoint path for analysis, allowing the user to specify a custom path or fall back to the default path created earlier.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npath = \"\"  # @param {type:\"string\"}\npath = default_path or epath.Path(path)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Parameter Sharding Configuration\nDESCRIPTION: Displays the parameter sharding specification to inspect how model parameters will be distributed across devices.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nparams_sharding_spec\n```\n\n----------------------------------------\n\nTITLE: Retrieving available checkpoint steps with CheckpointManager\nDESCRIPTION: This code snippet demonstrates how to retrieve all available checkpoint steps that have been saved by the CheckpointManager.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/async_checkpointing.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nckpt_mngr.all_steps()\n```\n\n----------------------------------------\n\nTITLE: Importing Orbax Model and Export Components\nDESCRIPTION: Imports specific Orbax modules for model conversion, export, and orchestration.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom orbax.experimental.model import core as obm\nfrom orbax.experimental.model import jax2obm\nfrom orbax.experimental.model.jax2obm import jax_supplemental_pb2\nfrom orbax.experimental.model.jax2obm import obm_to_jax\nfrom orbax.export import oex_orchestration\nfrom orbax.export import oex_orchestration_pb2\n```\n\n----------------------------------------\n\nTITLE: Renaming Keys with Regex in Orbax\nDESCRIPTION: Using regular expressions with Transform to match and rename keys in a PyTree, allowing for pattern-based transformations of tree structures.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example 2: Renaming with regex\n\noriginal_tree = {\n    'a1': 1,\n    'b5': 2\n}\n\ntransformations = {\n    r'([a-z])_([0-9])': ocp.Transform(original_key=r'\\1\\2'),\n}\n\nnew_tree = {\n    'a_1': ...,\n    'b_5': ...\n}\n\nocp.apply_transformations(original_tree, transformations, new_tree)\n```\n\n----------------------------------------\n\nTITLE: Setting up Parameter Inspection\nDESCRIPTION: Configures the checkpoint path and parameter name for individual parameter inspection, allowing the user to examine specific parameters in detail.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npath = \"\"  # @param {type:\"string\"}\n# The `param_name` can be obtained by inspecting tree metadata (see above).\nparam_name = \"\"  # @param {type:\"string\"}\npath = default_path or epath.Path(path)\nparam_name = default_param_name or param_name\n```\n\n----------------------------------------\n\nTITLE: Using wait_until_finished with async CheckpointManager\nDESCRIPTION: Example of calling wait_until_finished for async CheckpointManager.save() operations to ensure completion before proceeding with dependent operations.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_announcements.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nwait_until_finished\n```\n\n----------------------------------------\n\nTITLE: Decoding Image Data with TensorFlow in Python\nDESCRIPTION: This snippet decodes the captured image data using TensorFlow's image decoding function. It converts the binary image data into a TensorFlow tensor representation.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_33\n\nLANGUAGE: Python\nCODE:\n```\n# original_image = tf.image.decode_image(image_data, 3)\n# original_image\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Directory for Checkpoints using Orbax in Python\nDESCRIPTION: This code creates an empty directory for storing checkpoints using Orbax's test utilities. It ensures a clean starting point for saving checkpoints.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_101.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npath = ocp.test_utils.erase_and_create_empty('/tmp/my-checkpoints/')\n```\n\n----------------------------------------\n\nTITLE: Importing Orbax Export Libraries\nDESCRIPTION: Imports Orbax Export modules for model exporting, including constants, JAX module handling, export management, and serving configuration utilities.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom orbax.export import constants\nfrom orbax.export import jax_module\nfrom orbax.export import export_manager\nfrom orbax.export import serving_config as osc\n```\n\n----------------------------------------\n\nTITLE: Converting Input Data\nDESCRIPTION: Converts JAX input data to TensorFlow tensor format.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_work_together_with_dtensor.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntf_inputs = tf.convert_to_tensor(example3_inputs)\n```\n\n----------------------------------------\n\nTITLE: Implementing Canvas Drawing Interface in JavaScript\nDESCRIPTION: This snippet sets up a canvas drawing interface with mouse event listeners for drawing and capturing the drawn image as a data URL. It includes functions for handling mouse movements, drawing, and capturing the final image data.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_31\n\nLANGUAGE: JavaScript\nCODE:\n```\n# ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n# var button = document.querySelector('button')\n# var mouse = {x: 0, y: 0}\n# canvas.addEventListener('mousemove', function(e) {\n#   mouse.x = e.pageX - this.offsetLeft\n#   mouse.y = e.pageY - this.offsetTop\n# })\n# canvas.onmousedown = ()=>{\n#   ctx.beginPath()\n#   ctx.moveTo(mouse.x, mouse.y)\n#   canvas.addEventListener('mousemove', onPaint)\n# }\n# canvas.onmouseup = ()=>{\n#   canvas.removeEventListener('mousemove', onPaint)\n# }\n# var onPaint = ()=>{\n#   ctx.lineTo(mouse.x, mouse.y)\n#   ctx.stroke()\n# }\n# var data = new Promise(resolve=>{\n#   button.onclick = ()=>{\n#     resolve(canvas.toDataURL('image/png'))\n#   }\n# })\n# </script>\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Orbax Checkpointing\nDESCRIPTION: Import necessary libraries for working with Orbax checkpointing, including numpy for array operations and JAX for array handling and sharding.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport orbax.checkpoint as ocp\nimport jax\n```\n\n----------------------------------------\n\nTITLE: Configuring JAX Sharding\nDESCRIPTION: Sets up mesh-based sharding configuration and creates sharded arrays for model parameters.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_work_together_with_dtensor.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nfrom jax.sharding import PartitionSpec as P\nfrom jax.experimental import pjit\n\nmesh_shape = (1, 8)\ndevices = np.asarray(jax.devices()).reshape(*mesh_shape)\nmesh = jax.sharding.Mesh(devices, ('x', 'y'))\nparams_pspecs = {'w': P('x', 'y'), 'b': P('y')}\n\nsharded_params = {}\nsharded_params['w'] = jax.device_put(example3_params['w'], jax.sharding.NamedSharding(mesh, params_pspecs['w']))\nsharded_params['b'] = jax.device_put(example3_params['b'], jax.sharding.NamedSharding(mesh, params_pspecs['b']))\n\nsharded_inputs = jax.device_put(example3_inputs, jax.sharding.NamedSharding(mesh, None))\n\nsharded_model_fn = pjit.pjit(example3_model_fn, in_shardings=(params_pspecs, None), out_shardings=None)\n```\n\n----------------------------------------\n\nTITLE: New Single-Item Checkpointing Implementation\nDESCRIPTION: Shows the new approach to single-item checkpointing with context manager and StandardSave/Restore args\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/api_refactor.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\noptions = ocp.CheckpointManagerOptions()\nwith ocp.CheckpointManager(\n  ocp.test_utils.erase_and_create_empty('/tmp/ckpt2/'),\n  options=options,\n) as mngr:\n  mngr.save(0, args=ocp.args.StandardSave(pytree))\n\n  # The `CheckpointManager` already knows that the object is saved and restored\n  # using \"standard\" pytree logic. In many cases, you can restore exactly as\n  # saved without specifying additional arguments.\n  mngr.restore(0)\n  # If customization of properties like sharding or dtype is desired, just provide\n  # the abstract target PyTree, the properties of which will be used to set\n  # the properties of the restored arrays.\n  mngr.restore(0, args=ocp.args.StandardRestore(abstract_pytree))\n```\n\n----------------------------------------\n\nTITLE: Checking Restored Array Dtypes\nDESCRIPTION: Inspects the dtypes of restored arrays to verify they match the original data.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nrestored['a'].dtype\n```\n\n----------------------------------------\n\nTITLE: Removing Previous Model Checkpoint\nDESCRIPTION: Cleans up any existing model checkpoint directory to prepare for saving a new checkpoint.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n!rm -r /tmp/mnist\n```\n\n----------------------------------------\n\nTITLE: Creating Directory for Model Saving\nDESCRIPTION: Creates a directory to save the model checkpoint.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nsave_dir_path = \"/tmp/model\"\n!mkdir /tmp/model\n```\n\n----------------------------------------\n\nTITLE: Defining Input Tensor Sharding\nDESCRIPTION: Configures how input tensors are sharded across devices. This example shows sharding across both 'data' and 'model' dimensions, which is noted as being not supported by DTensor.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Note here that the input tensor is sharded in two dimensions, which is not supported by DTensor.\ninputs_sharding_spec = jax.sharding.NamedSharding(\n    mesh, jsharding.PartitionSpec('data', 'model', None, None))\n```\n\n----------------------------------------\n\nTITLE: Importing Orbax Export in Python\nDESCRIPTION: Code snippet showing how to import the Orbax Export library in Python after installation.\nSOURCE: https://github.com/google/orbax/blob/main/export/README.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport orbax.export\n```\n\n----------------------------------------\n\nTITLE: Simple Restoration without Explicit Sharding\nDESCRIPTION: Shows that when restoring on the same topology, it's possible to omit sharding specification and get the original sharding.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nrestored = ckptr.restore(path / '1')\n```\n\n----------------------------------------\n\nTITLE: Converting TF Concrete Functions to OBM\nDESCRIPTION: Shows the process of converting TensorFlow concrete functions to OBM functions and saving them to disk, including handling pre-processors and post-processors.\nSOURCE: https://github.com/google/orbax/blob/main/model/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nobm_pre_processor = tf2obm.tf_concrete_function_name_to_obm_function(\n    \"my_tf_pre_processor\", pre_processor)\nobm_post_processor = tf2obm.tf_concrete_function_name_to_obm_function(\n    \"my_tf_post_processor\", post_processor)\n\n\ntf2obm.save_tf_concrete_functions(\n    \"path/to/my_orbax_model/tf_stuff/\",\n    {\"my_tf_pre_processor\": pre_processor,\n     \"my_tf_post_processor\": post_processor},\n    trackable_resources)\n```\n\n----------------------------------------\n\nTITLE: Configuring Training Hyperparameters\nDESCRIPTION: Defines a function to create a configuration dictionary with hyperparameters for model training, including learning rate, momentum, batch size, and number of epochs.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Create the configuration of hyperparameters, feel free to tune them.\ndef get_config():\n  config = ml_collections.ConfigDict()\n  config.learning_rate = 0.1\n  config.momentum = 0.9\n  config.batch_size = 128\n  config.num_epochs = 1\n  return config\n\n\n```\n\n----------------------------------------\n\nTITLE: Checking Default Restored Sharding\nDESCRIPTION: Verifies the sharding of the restored array when no explicit sharding was provided during restoration.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nrestored['a'].sharding\n```\n\n----------------------------------------\n\nTITLE: Path Configuration for Tree Metadata Inspection\nDESCRIPTION: Sets up the checkpoint path for inspecting the tree metadata, allowing the user to specify a custom path or use the default path.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npath = \"\"  # @param {type:\"string\"}\npath = default_path or epath.Path(path)\n```\n\n----------------------------------------\n\nTITLE: Displaying Loaded OBM Function\nDESCRIPTION: Displays the contents of the loaded OBM function.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nloaded_obm_function\n```\n\n----------------------------------------\n\nTITLE: Initializing DTensor\nDESCRIPTION: Initializes DTensor communication and accelerator setup with safety checks.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_work_together_with_dtensor.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom orbax.export import dtensor_utils\nif dtensor_utils.dtensor_initialized():\n  dtensor_utils.shutdown_dtensor()\ndtensor_utils.initialize_dtensor(reset_context=True)\nassert(dtensor_utils.dtensor_initialized())\n```\n\n----------------------------------------\n\nTITLE: Loading Manifest from Saved Model\nDESCRIPTION: Loads the manifest proto from the saved model directory.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nmanifest_proto = obm.manifest_pb2.Manifest()\nwith open(os.path.join(save_dir_path, obm.MANIFEST_FILENAME), 'rb') as f:\n  manifest_proto.ParseFromString(f.read())\n```\n\n----------------------------------------\n\nTITLE: Loading JAX Supplemental Information\nDESCRIPTION: Loads the JAX supplemental information from the saved model directory.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\njax_supplemental_filename = (\n    loaded_obm_function.body.stable_hlo_body.supplemental_info.file_system_location.string_path\n)\njax_supplemental_proto = jax_supplemental_pb2.Function()\nwith open(os.path.join(save_dir_path, jax_supplemental_filename), 'rb') as f:\n  jax_supplemental_proto.ParseFromString(f.read())\n```\n\n----------------------------------------\n\nTITLE: Displaying Restored Object with Transformation in Orbax\nDESCRIPTION: Simple command to display the second restored object after applying a different transformation.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nrestored2\n```\n\n----------------------------------------\n\nTITLE: Configuring JAX to Use CPU for Training\nDESCRIPTION: Sets up JAX to use CPU devices for training by configuring XLA flags and environment variables. Forces JAX to use a specific number of CPU devices and updates platform configuration.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# This needs to be run first before any JAX code, to force JAX to use CPU in our demo for training.\nnum_cpu_devices = 4\nxla_flags = os.getenv('XLA_FLAGS', '')\nxla_flags = re.sub(\n    r'--xla_force_host_platform_device_count=\\S+', '', xla_flags\n).split()\nos.environ['XLA_FLAGS'] = ' '.join(\n    [f'--xla_force_host_platform_device_count={num_cpu_devices}'] + xla_flags\n)\njax.config.update('jax_platforms', 'cpu')\nflags.FLAGS.jax_allow_unused_tpus = True\njax.devices()\n```\n\n----------------------------------------\n\nTITLE: Restoring with Concrete Target State\nDESCRIPTION: Demonstrates restoring a checkpoint using a concrete (initialized) state, though this is less efficient than using abstract states.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nckptr.restore(path / '1', args=ocp.args.StandardRestore(state))\n```\n\n----------------------------------------\n\nTITLE: Using ArrayRestoreArgs with strict option\nDESCRIPTION: Example showing the ArrayRestoreArgs with the new strict option that defaults to True. This option prevents silently padding or truncating when loading jax.Arrays.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_announcements.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nArrayRestoreArgs\n```\n\n----------------------------------------\n\nTITLE: Loading Orchestration Proto\nDESCRIPTION: Loads the orchestration proto from the saved model directory.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\norch_filename = (\n    manifest_proto.supplemental_info.single.file_system_location.string_path\n)\norch_proto = oex_orchestration_pb2.Pipeline()\nwith open(os.path.join(save_dir_path, orch_filename), 'rb') as f:\n  orch_proto.ParseFromString(f.read())\n```\n\n----------------------------------------\n\nTITLE: Path Configuration for Implied Size Analysis\nDESCRIPTION: Sets up the checkpoint path for implied size analysis, allowing the user to specify a custom path or use the default path.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npath = \"\"  # @param {type:\"string\"}\npath = default_path or epath.Path(path)\n```\n\n----------------------------------------\n\nTITLE: Displaying Loaded Orchestration Proto\nDESCRIPTION: Displays the contents of the loaded orchestration proto.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\norch_proto\n```\n\n----------------------------------------\n\nTITLE: Installing Orbax Checkpoint from GitHub\nDESCRIPTION: Command to install the orbax-checkpoint package directly from the GitHub repository. This can be used to obtain the most recent version of the package.\nSOURCE: https://github.com/google/orbax/blob/main/docs/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install 'git+https://github.com/google/orbax/#subdirectory=checkpoint'\n```\n\n----------------------------------------\n\nTITLE: Importing Orbax Checkpoint in Python\nDESCRIPTION: Python import statement to access the Orbax checkpoint functionality after installation.\nSOURCE: https://github.com/google/orbax/blob/main/checkpoint/README.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport orbax.checkpoint\n```\n\n----------------------------------------\n\nTITLE: Closing CheckpointManager explicitly\nDESCRIPTION: Alternative method to close a CheckpointManager explicitly by calling the close() method, ensuring proper resource handling.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_announcements.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmanager.close()\n```\n\n----------------------------------------\n\nTITLE: Loading Model Function from Manifest\nDESCRIPTION: Extracts the model function from the loaded manifest.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nloaded_model_function_name = orch_proto.model_function_name\nloaded_obm_function = manifest_proto.objects[\n    loaded_model_function_name\n].function\n```\n\n----------------------------------------\n\nTITLE: Inspecting PyTree Checkpoint Structure in Python\nDESCRIPTION: Shows how to inspect the structure of a PyTree checkpoint, including metadata and sharding information.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpoint_format.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint_directory(path / '0' / 'state')\n\nimport json\n\njson.loads((path / '0' / 'state' / '_METADATA').read_text())\n```\n\n----------------------------------------\n\nTITLE: Installing Orbax Export from GitHub\nDESCRIPTION: Command to install the orbax-export package directly from the GitHub repository. This provides access to the most recent version of the package.\nSOURCE: https://github.com/google/orbax/blob/main/docs/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install 'git+https://github.com/google/orbax/#subdirectory=export'\n```\n\n----------------------------------------\n\nTITLE: Displaying JAX Supplemental Proto\nDESCRIPTION: Displays the contents of the loaded JAX supplemental proto.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\njax_supplemental_proto\n```\n\n----------------------------------------\n\nTITLE: Using CheckpointManager with context manager\nDESCRIPTION: Proper way to use CheckpointManager with a context manager to ensure resources are properly handled, replacing the deprecated checkpoint_manager_context() function.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_announcements.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nwith CheckpointManager(...) as manager:\n```\n\n----------------------------------------\n\nTITLE: Testing Loaded Model\nDESCRIPTION: Performs inference using the loaded TensorFlow model.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_work_together_with_dtensor.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nloaded_model(tf_inputs)\n```\n\n----------------------------------------\n\nTITLE: Installing Orbax Export Package\nDESCRIPTION: Instructions for installing the Orbax export package either from PyPI or directly from GitHub repository.\nSOURCE: https://github.com/google/orbax/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install orbax-export\n```\n\nLANGUAGE: bash\nCODE:\n```\npip install 'git+https://github.com/google/orbax/#subdirectory=export'\n```\n\n----------------------------------------\n\nTITLE: Displaying Loaded Manifest\nDESCRIPTION: Displays the contents of the loaded manifest proto.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nmanifest_proto\n```\n\n----------------------------------------\n\nTITLE: Converting Arrays to Shape-Dtype Structures in Orbax Checkpoint\nDESCRIPTION: The to_shape_dtype_struct function in the orbax.checkpoint.arrays module converts array-like objects to a structure representing the shape and data type. This is likely used during checkpoint serialization or deserialization processes.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.arrays.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nto_shape_dtype_struct\n```\n\n----------------------------------------\n\nTITLE: Checking Available JAX Devices\nDESCRIPTION: Queries the available JAX devices to understand the hardware environment for model execution.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\njax.devices()\n```\n\n----------------------------------------\n\nTITLE: Defining Input Argument Specifications\nDESCRIPTION: Specifies the expected input tensor shape and data type for the TensorFlow preprocessing function. Sets a batch size of 100 and accommodates variable image dimensions.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# Define the spec of input arg (e.g., for the TF Preprocessing function).\ninput_args_spec = [tf.TensorSpec((100, None, None, 3), tf.uint8)] # Set the batch size to 100.\n```\n\n----------------------------------------\n\nTITLE: Setup for Transformation Examples with Orbax\nDESCRIPTION: Importing the necessary modules and libraries for working with Orbax's checkpoint transformation utilities.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Setup\nimport orbax.checkpoint as ocp\nimport numpy as np\n```\n\n----------------------------------------\n\nTITLE: Importing MultiprocessingOptions from Orbax\nDESCRIPTION: Demonstrates the import of the MultiprocessingOptions class, used for configuring multiprocessing options in checkpoint management.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.checkpoint_manager.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom orbax.checkpoint.checkpoint_manager import MultiprocessingOptions\n```\n\n----------------------------------------\n\nTITLE: Importing CheckpointManager from Orbax\nDESCRIPTION: Shows how to import the CheckpointManager class from the orbax.checkpoint.checkpoint_manager module. This class is likely the main interface for managing checkpoints in Orbax.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.checkpoint_manager.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom orbax.checkpoint.checkpoint_manager import CheckpointManager\n```\n\n----------------------------------------\n\nTITLE: Displaying Restored Object in Orbax\nDESCRIPTION: Simple command to display the restored object after applying transformations.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/transformations.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nrestored1\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Classes in Orbax Checkpoint System\nDESCRIPTION: Module defines the logging hierarchy for Orbax checkpointing system with AbstractLogger as the base class and specialized implementations including CompositeLogger, StandardLogger, and CloudLogger with associated configuration options.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.logging.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nAbstractLogger\nCompositeLogger\nStandardLogger\nCloudLogger\nCloudLoggerOptions\n```\n\n----------------------------------------\n\nTITLE: Importing CheckpointManagerOptions from Orbax\nDESCRIPTION: Demonstrates the import of the CheckpointManagerOptions class, which is used to configure options for the CheckpointManager.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.checkpoint_manager.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom orbax.checkpoint.checkpoint_manager import CheckpointManagerOptions\n```\n\n----------------------------------------\n\nTITLE: Displaying Checkpoint Size on Disk\nDESCRIPTION: Calculates and displays the actual size of the checkpoint on disk in gigabytes by running the disk_usage function asynchronously.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/debug_guide.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint('{0:0.3f} GB'.format(float(asyncio.run(disk_usage(path))) / 1e9))\n```\n\n----------------------------------------\n\nTITLE: Importing AsyncOptions from Orbax\nDESCRIPTION: Shows how to import the AsyncOptions class, which is likely used to configure asynchronous operations in checkpoint management.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.checkpoint_manager.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom orbax.checkpoint.checkpoint_manager import AsyncOptions\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Documentation for Orbax Type Protocol\nDESCRIPTION: Sphinx documentation configuration directives for the Orbax experimental model core type protocol module. Sets up auto-documentation for all members of the module.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/model.core.python.type_proto.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. currentmodule:: orbax.experimental.model.core.python.type_proto\n\n.. automodule:: orbax.experimental.model.core.python.type_proto\n  :members:\n```\n\n----------------------------------------\n\nTITLE: Importing is_async_checkpointer utility function from Orbax\nDESCRIPTION: Shows how to import the is_async_checkpointer utility function, which likely checks if a given checkpointer supports asynchronous operations.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.checkpoint_manager.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom orbax.checkpoint.checkpoint_manager import is_async_checkpointer\n```\n\n----------------------------------------\n\nTITLE: Msgpack Serialization and Restoration Functions in Python\nDESCRIPTION: Module containing two primary functions: msgpack_serialize for converting data to MessagePack format, and msgpack_restore for deserializing MessagePack data back to its original form.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.msgpack_utils.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. currentmodule:: orbax.checkpoint.msgpack_utils\n\n.. automodule:: orbax.checkpoint.msgpack_utils\n\n.. autofunction:: msgpack_serialize\n.. autofunction:: msgpack_restore\n```\n\n----------------------------------------\n\nTITLE: Installing Orbax Checkpoint from GitHub\nDESCRIPTION: Command to install the Orbax checkpoint library directly from the GitHub repository, which provides the latest development version from the HEAD of the repository.\nSOURCE: https://github.com/google/orbax/blob/main/checkpoint/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install 'git+https://github.com/google/orbax/#subdirectory=checkpoint'\n```\n\n----------------------------------------\n\nTITLE: Setting up documentation for Orbax model.core.python.value module in restructuredText\nDESCRIPTION: This snippet defines the documentation structure for the Orbax experimental model core Python value module using reStructuredText directives. It sets the current module context and includes autodoc instructions to document all members of the module.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/model.core.python.value.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. currentmodule:: orbax.experimental.model.core.python.value\n\n.. automodule:: orbax.experimental.model.core.python.value\n  :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring async behavior via CheckpointManagerOptions\nDESCRIPTION: Setting the enable_async_checkpointing option in CheckpointManagerOptions to control the default async behavior of CheckpointManager.save().\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_announcements.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nCheckpointManagerOptions.enable_async_checkpointing\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Orbax Checkpointing in Python\nDESCRIPTION: This snippet imports the necessary libraries for working with Orbax checkpointing, including numpy for array operations and jax for advanced array handling.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_101.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport orbax.checkpoint as ocp\nimport jax\n```\n\n----------------------------------------\n\nTITLE: ReStructuredText Documentation for JaxModule in orbax.export.jax_module\nDESCRIPTION: This snippet defines the documentation structure for the JaxModule class in the orbax.export.jax_module module. It uses Sphinx's automodule and autoclass directives to generate API documentation from docstrings in the source code.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/export.jax_module.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nJaxModule\n============================================================================\n\n.. currentmodule:: orbax.export.jax_module\n\n.. automodule:: orbax.export.jax_module\n\nJaxModule\n------------------------------------------------\n.. autoclass:: JaxModule\n  :members:\n```\n\n----------------------------------------\n\nTITLE: Drawing Function for Canvas Interaction in Python\nDESCRIPTION: This function displays an HTML canvas for drawing and captures the drawn image data. It uses the `display` function to show the canvas and `eval_js` to execute JavaScript for retrieving the image data.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_32\n\nLANGUAGE: Python\nCODE:\n```\n# def draw(w=300, h=300, line_width=20):\n#   display(HTML(canvas_html % (w, h, line_width)))\n#   data = eval_js(\"data\")\n#   binary = b64decode(data.split(',')[1])\n#   return binary\n\n# image_data = draw()\n```\n\n----------------------------------------\n\nTITLE: Configuring XLA Virtual Cores\nDESCRIPTION: Sets up CPU emulation of 8 virtual cores for testing purposes by configuring XLA flags.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_work_together_with_dtensor.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# emulate the multi-core from the single CPU.\nimport os\nflags = os.environ.get('XLA_FLAGS', '')\nos.environ['XLA_FLAGS'] = flags + \" --xla_force_host_platform_device_count=8\"\nprint(os.environ['XLA_FLAGS'])\n```\n\n----------------------------------------\n\nTITLE: Importing Orbax Export Module\nDESCRIPTION: Code snippet showing how to import the Orbax export module in Python.\nSOURCE: https://github.com/google/orbax/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport orbax.export\n```\n\n----------------------------------------\n\nTITLE: Running TensorFlow Model Predictions in Python\nDESCRIPTION: This function prepares the input for a TensorFlow model and runs predictions. It creates a batch of inputs from a single image and uses a pre-defined runner to execute the model.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_34\n\nLANGUAGE: Python\nCODE:\n```\n# # Run the model\n# def create_model_inputs(image, batch_size):\n#   inputs = [np.asarray(image) for _ in range(batch_size)]\n#   batched_inputs = np.stack(inputs, axis=0)\n#   return batched_inputs\n\n# predicted_labels = runner.run(create_model_inputs(original_image, batch_size=100))\n```\n\n----------------------------------------\n\nTITLE: Importing Orbax Model Runner\nDESCRIPTION: Imports the Orbax Model Runner module, which provides a C++ implementation with Python API for efficiently running exported models.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n# Load the model using Orbax Model Runner (new!)\nfrom .learning.infra.mira.experimental.orbax_model.python import orbax_model_runner\n```\n\n----------------------------------------\n\nTITLE: Importing Orbax Checkpoint Module\nDESCRIPTION: Code snippet showing how to import the Orbax checkpoint module in Python.\nSOURCE: https://github.com/google/orbax/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport orbax.checkpoint\n```\n\n----------------------------------------\n\nTITLE: Installing Orbax Export from PyPI\nDESCRIPTION: Command to install the orbax-export package from PyPI using pip. This installs the latest release version of the exporting functionality.\nSOURCE: https://github.com/google/orbax/blob/main/docs/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install orbax-export\n```\n\n----------------------------------------\n\nTITLE: Importing Orbax Checkpoint Dependencies\nDESCRIPTION: Basic imports required for using the Orbax checkpoint functionality\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/api_refactor.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport orbax.checkpoint as ocp\nfrom etils import epath\n```\n\n----------------------------------------\n\nTITLE: Displaying Runner Platform Information\nDESCRIPTION: Prints information about the platform and device configuration that the Stable HLO code will run on, showing the underlying execution environment for the model.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nprint(f\"Stable HLO will run on {runner.ifrt_platform_name()} platform with {runner.ifrt_device_count()} devices.\")\n```\n\n----------------------------------------\n\nTITLE: Installing Orbax Checkpoint Package\nDESCRIPTION: Instructions for installing the Orbax checkpointing package either from PyPI or directly from GitHub repository.\nSOURCE: https://github.com/google/orbax/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install orbax-checkpoint\n```\n\nLANGUAGE: bash\nCODE:\n```\npip install 'git+https://github.com/google/orbax/#subdirectory=checkpoint'\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Setup for Orbax SHLO Function Module\nDESCRIPTION: Sphinx documentation configuration for the SHLO function module in Orbax. The code sets up the current module with automodule directive to document all members of the specified module.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/model.core.python.shlo_function.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. currentmodule:: orbax.experimental.model.core.python.shlo_function\n\n.. automodule:: orbax.experimental.model.core.python.shlo_function\n  :members:\n```\n\n----------------------------------------\n\nTITLE: Converting OCP Folder to OBM Value\nDESCRIPTION: Demonstrates converting an Orbax Checkpointing (OCP) folder path into an OBM value using the core OBM functionality.\nSOURCE: https://github.com/google/orbax/blob/main/model/README.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom orbax_model import core as obm\n\nobm_weights = obm.convert_path_to_value(\n    \"path/to/my_orbax_model/my_checkpoint/\",\n    mime_type=\"orbax_checkpoint\")\n```\n\n----------------------------------------\n\nTITLE: Importing Essential Libraries for JAX-based ML\nDESCRIPTION: Imports basic libraries required for JAX-based machine learning applications, including OS operations, regular expressions, JAX itself, and Abseil flags.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport re\nimport jax\nimport absl.flags as flags\n```\n\n----------------------------------------\n\nTITLE: Formatting Changelog in Markdown\nDESCRIPTION: The changelog is formatted using Markdown syntax, with headers for version numbers and categories for types of changes (Added, Changed, Fixed). It includes links to external resources for changelog format and semantic versioning.\nSOURCE: https://github.com/google/orbax/blob/main/CHANGELOG.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n### Added\n- Local type handler registries.\n\n### Changed\n- The PyPi `orbax` package is deprecated in favor of domain-specific namespace\npackages, namely `orbax-checkpoint` and `orbax-export`. Imports are unchanged,\nand still of the form `import orbax.checkpoint` or `import orbax.export`.\n- Finer scoped jax.monitoring calls on the save path.\n- `CheckpointManager.metadata()` now accepts a `step` parameter. If provided, it\nwill return `StepMetadata`, and will otherwise return `RootMetadata`.\n- `CheckpointManager.restore()` will now attempt to initialize checkpoint\nhandlers using `StepMetadata.item_handlers` and the global `HandlerTypeRegistry`\nif no args are provided.\n- `CompositeCheckpointHandler.metadata()` now returns `StepMetadata`.\n\n## [0.1.7] - 2022-03-29\n\n### Added\n- Support for OCDBT driver in Tensorstore.\n\n## [0.1.6] - 2022-03-22\n\n### Fixed\n- Small bug fixes.\n\n## [0.1.5] - 2022-03-17\n\n### Added\n- Use a more precise timestamp when generating temporary directory names to\npermit more than one concurrent checkpointing attempt per second.\n\n## [0.1.4] - 2022-03-15\n\n### Added\n- Support for generic transformation function in PyTreeCheckpointHandler.\n- Support n-digit checkpoint step format.\n\n### Fixed\n- Eliminate Flax dependency to fix circular dependency problem.\n\n## [0.1.3] - 2022-03-03\n\n### Added\n- `sharding` option on `ArrayRestoreArgs`\n\n## [0.1.2] - 2022-02-17\n\n### Added\n- Add \"standard user recipe\" to documentation.\n- Add unit tests using mock to simulate preemption.\n- Logging to increase transparency around why checkpoints are kept vs. deleted.\n- Expand on uses of restore_args in colab.\n- Expose utils_test.\n- Add msgpack_utils to move toward eliminating Flax dependency.\n- CheckpointManager starts a background thread to finalize checkpoints so that\ncheckpoints are finalized as soon as possible in async case.\n\n### Changed\n- Remove CheckpointManager update API.\n- Remove support for deprecated GDA.\n- Add tmp suffix on step directory creation in CheckpointManager.save.\n\n### Fixed\n- Preemption when using keep_time_interval caused the most recent steps before\npreemption to be kept, despite not falling on the keep time interval.\n\n## [0.1.1] - 2022-01-30\n\n### Added\n- A util function that constructs restore_args from a target PyTree.\n- CheckpointManager `delete` API, which allows deleting an existing step.\n- Made dev dependencies optional to minimize import overhead.\n\n### Changed\n- Refactored higher-level utils in checkpoint_utils, which provides\nuser-convenience functions.\n- Guard option to create top-level directory behind `create` option.\n- Remove support for Python 3.7.\n\n## [0.1.0] - 2022-01-04\n\n### Added\n\n- Check for metric file in addition to item directory in CheckpointManager.\n- Additional logs to indicate save/restore completion.\n- Support for None leaves in PyTree save/restore.\n- ArrayCheckpointHandler for individual arrays/scalars.\n- `read: bool` option on all_steps to force read from storage location instead\nof using cached steps.\n- Simplified \"Getting Started\" section in the docs.\n- CheckpointManager creates the top level directory if it does not yet exist.\n- Write msgpack bytes asynchronously.\n\n### Changed\n- Removed some unused test_utils methods for filtering empty nodes.\n- Update docs on `PyTreeCheckpointHandler`.\n- Removed unneeded AbstractCheckpointManager.\n\n### Fixed\n\n- Usage of bytes_limiter to prevent too many bytes from being read during a\nsingle restore call.\n- Temp checkpoint cleanup when using a step prefix (i.e. 'checkpoint_0').\n\n## [0.0.23] - 2022-12-08\n\n### Added\n\n- Option to customize metadata file name for Tensorstore.\n\n### Fixed\n\n- Restore failure on GCS due to misidentification of checkpoint as\n\"not finalized\".\n\n## [0.0.22] - 2022-12-05\n\n### Added\n\n- Added CHANGELOG.md for version updates (additions and changes), ingested by\nauto-publish functionality.\n\n## [0.0.21] - 2022-12-05\n\n### Changed\n\n- Fix mistaken usages of placeholder \"AGGREGATED\" where \"NOT-AGGREGATED\" would\nbe more appropriate. Ensure backwards compatibility is maintained.\n```\n\n----------------------------------------\n\nTITLE: Defining JAX Model and Parameters\nDESCRIPTION: Creates a simple linear model with random parameters and input data.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_work_together_with_dtensor.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport jax\nimport jax.numpy as jnp\ndim_x = 16000\ndim_y = 8000\nbatch = 1\n\nk1, k2, k3 = jax.random.split(jax.random.PRNGKey(0), 3)\nexample3_params =  {\n    'w': jax.random.uniform(k1, (dim_x, dim_y)), 'b': jax.random.uniform(k2, (dim_y,))\n}\nexample3_inputs = jax.random.uniform(k3, (batch, dim_x))\n\n# model f(x) = a * sin(x) + b * x + c, here (a, b, c) are model parameters\ndef example3_model_fn(params, x):  # The JAX model function to export.\n  w, b = params['w'], params['b']\n  return jnp.matmul(x, w) + b\n```\n\n----------------------------------------\n\nTITLE: Preparing Interactive Drawing Interface (Commented)\nDESCRIPTION: Contains commented code for an interactive drawing interface that would allow users to draw digits and have the model predict them. The code is provided for reference but not executed.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n# # Create prediction data.\n\n# from IPython.display import HTML, display\n# from google.colab.output import eval_js\n# from base64 import b64decode\n\n\n# canvas_html = \"\"\"\n# <canvas width=%d height=%d></canvas>\n# <button>Finish</button>\n# <script>\n# var canvas = document.querySelector('canvas')\n# var ctx = canvas.getContext('2d')\n# ctx.lineWidth = %d\n# ctx.strokeStyle = 'rgba(255,255,0,1)';\n# ctx.fillStyle = 'rgba(0,0,0,0.9)';\n\n```\n\n----------------------------------------\n\nTITLE: Installing Orbax Checkpoint from PyPI\nDESCRIPTION: Command to install the orbax-checkpoint package from PyPI using pip. This installs the latest release version of the checkpointing functionality.\nSOURCE: https://github.com/google/orbax/blob/main/docs/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install orbax-checkpoint\n```\n\n----------------------------------------\n\nTITLE: Generating Test Input Data\nDESCRIPTION: Creates random test input data for model comparison.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ntest_input_data = jax.device_put(\n    jax.random.uniform(\n        jax.random.PRNGKey(999), (4, 28, 28, 1), dtype=jnp.float64\n    ),\n    input_sharding_spec,\n)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Input Sharding Configuration\nDESCRIPTION: Displays the input sharding specification to inspect how input tensors will be distributed across devices for parallel processing.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ninputs_sharding_spec\n```\n\n----------------------------------------\n\nTITLE: Defining Sphinx Documentation Structure for Orbax ExportManager\nDESCRIPTION: This reStructuredText (RST) snippet defines the documentation structure for the ExportManager class in the orbax.export.export_manager module. It includes directives for the current module, automodule, and autoclass to automatically generate class documentation.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/export.export_manager.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nExportManager\n============================================================================\n\n.. currentmodule:: orbax.export.export_manager\n\n.. automodule:: orbax.export.export_manager\n\nExportManager\n------------------------------------------------\n.. autoclass:: ExportManager\n  :members:\n```\n\n----------------------------------------\n\nTITLE: Checking Modified Array Dtype\nDESCRIPTION: Verifies that the array's dtype was modified during saving as specified.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nrestored['a'].dtype\n```\n\n----------------------------------------\n\nTITLE: Listing Saved Model Directory Contents\nDESCRIPTION: Lists the contents of the directory where the model was saved.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n!ls /tmp/model\n```\n\n----------------------------------------\n\nTITLE: Checking Unmodified Array Dtype\nDESCRIPTION: Confirms that the unmodified array retained its original dtype.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nrestored['b'].dtype\n```\n\n----------------------------------------\n\nTITLE: Documenting Tree Utility Functions in Orbax Checkpoint Module\nDESCRIPTION: This snippet lists the available tree utility functions in the Orbax checkpoint module. These functions are used for operations such as getting parameter names, serializing and deserializing trees, converting to and from flat dictionaries, and creating shape-dtype structures.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.tree.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. autofunction:: get_param_names\n.. autofunction:: serialize_tree\n.. autofunction:: deserialize_tree\n.. autofunction:: to_flat_dict\n.. autofunction:: from_flat_dict\n.. autofunction:: to_shape_dtype_struct\n```\n\n----------------------------------------\n\nTITLE: Listing Checkpoint Directory Contents\nDESCRIPTION: Lists the contents of the checkpoint directory to verify that the model checkpoint was successfully saved.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_mira_runtime_mnist_demo.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n!ls /tmp/mnist/ckpt\n```\n\n----------------------------------------\n\nTITLE: Listing Checkpoint Directory Contents\nDESCRIPTION: Lists the contents of the checkpoint directory to verify the saved files.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n!ls /tmp/model/my_checkpoint/\n```\n\n----------------------------------------\n\nTITLE: Loading SavedModel\nDESCRIPTION: Loads the exported TensorFlow SavedModel.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_work_together_with_dtensor.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nloaded_model = tf.saved_model.load(export_dir)\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Orbax Atomicity\nDESCRIPTION: Sphinx/RST documentation structure defining the API reference for Orbax's atomicity module, including class and function documentation directives.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.path.atomicity.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. currentmodule:: orbax.checkpoint.path.atomicity\n\n.. automodule:: orbax.checkpoint.path.atomicity\n\n.. autoclass:: AtomicRenameTemporaryPath\n  :members:\n\n.. autoclass:: CommitFileTemporaryPath\n  :members:\n\n.. autofunction:: on_commit_callback\n```\n\n----------------------------------------\n\nTITLE: Installing Orbax Export from PyPi\nDESCRIPTION: Command to install the latest Orbax Export release from PyPi using pip.\nSOURCE: https://github.com/google/orbax/blob/main/export/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install orbax-export\n```\n\n----------------------------------------\n\nTITLE: Installing Orbax Export with TensorFlow Dependencies\nDESCRIPTION: Command to install Orbax Export with standard TensorFlow dependencies included using the 'all' extra option.\nSOURCE: https://github.com/google/orbax/blob/main/export/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install orbax-export[all]\n```\n\n----------------------------------------\n\nTITLE: Checking JAX Devices\nDESCRIPTION: Prints available JAX devices after configuration.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/export/orbax_export_work_together_with_dtensor.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport jax\nprint(jax.devices())\n```\n\n----------------------------------------\n\nTITLE: Installing Orbax Export from GitHub\nDESCRIPTION: Command to install Orbax Export directly from the GitHub repository at HEAD using the export subdirectory.\nSOURCE: https://github.com/google/orbax/blob/main/export/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install 'git+https://github.com/google/orbax/#subdirectory=export'\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Documentation and Notebook Execution\nDESCRIPTION: This code snippet lists the required Python packages and their specific versions for documentation generation using Sphinx and related tools, as well as packages needed for notebook execution. The packages are grouped into two sections: documentation-related packages and notebook execution packages.\nSOURCE: https://github.com/google/orbax/blob/main/docs/requirements/requirements-docs.txt#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nsphinx==8.2.3\nsphinx-book-theme==1.1.4\nsphinxcontrib-katex==0.9.0\nsphinxcontrib-applehelp==2.0.0\nsphinxcontrib-devhelp==2.0.0\nsphinxcontrib-htmlhelp==2.1.0\nsphinxcontrib-serializinghtml==2.0.0\nsphinxcontrib-bibtex==2.4.2\nsphinx-autodoc-typehints==1.11.1\nsphinx-design==0.6.1\ndocutils==0.21.2\nmyst-parser==4.0.1\nprotobuf==6.30.0\n\n# Packages used for notebook execution\nipython==9.0.1\nipykernel==6.29.5\nmyst-nb==1.2.0\ncached_property==2.0.1\nimportlib_resources==6.5.2\n```\n\n----------------------------------------\n\nTITLE: Checking Second Array Dtype\nDESCRIPTION: Verifies the dtype of another array in the restored PyTree.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/checkpointing_pytrees.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nrestored['b'].dtype\n```\n\n----------------------------------------\n\nTITLE: Verifying JAX Configuration\nDESCRIPTION: Asserts that 8 JAX devices are available and enables 64-bit precision.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/model/orbax_model_jax_roundtripping_demo.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nassert len(jax.devices()) == 8\n\njax.config.update('jax_enable_x64', True)\n```\n\n----------------------------------------\n\nTITLE: Importing Orbax Polymorphic Function Module\nDESCRIPTION: This snippet shows how to reference the polymorphic_function module in Sphinx documentation. It sets the current module and uses automodule to generate documentation for all members.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/model.core.python.polymorphic_function.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. currentmodule:: orbax.experimental.model.core.python.polymorphic_function\n\n.. automodule:: orbax.experimental.model.core.python.polymorphic_function\n  :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Documentation for orbax.experimental.model.core.python.function Module\nDESCRIPTION: This reStructuredText directive sets up the automatic documentation generation for the orbax.experimental.model.core.python.function module. It establishes the current module context and instructs Sphinx to document all members of the module.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/model.core.python.function.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. currentmodule:: orbax.experimental.model.core.python.function\n\n.. automodule:: orbax.experimental.model.core.python.function\n  :members:\n```\n\n----------------------------------------\n\nTITLE: Deprecated SaveArgs.aggregate option\nDESCRIPTION: Reference to the deprecated SaveArgs.aggregate option that users should replace with custom TypeHandler implementation.\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/orbax_checkpoint_announcements.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nSaveArgs.aggregate\n```\n\n----------------------------------------\n\nTITLE: Sphinx RST Documentation for Orbax Multi-host Module\nDESCRIPTION: ReStructuredText documentation defining the API documentation structure for Orbax's multi-host utilities, including function and class autodoc directives.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.multihost.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. currentmodule:: orbax.checkpoint.multihost\n\n.. automodule:: orbax.checkpoint.multihost\n\n.. autofunction:: broadcast_one_to_all\n.. autofunction:: is_primary_host\n.. autofunction:: reached_preemption\n.. autofunction:: sync_global_processes\n.. autofunction:: process_index\n\n.. autoclass:: BarrierSyncFn\n  :members:\n\n.. autofunction:: get_barrier_sync_fn\n```\n\n----------------------------------------\n\nTITLE: Defining Example PyTree Data Structures\nDESCRIPTION: Setup of dummy PyTree structures for demonstration purposes, including a basic tree and its abstract representation\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/api_refactor.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Dummy PyTrees for simplicity.\n\n# In reality, this would be a tree of np.ndarray or jax.Array.\npytree = {'a': 0}\n# In reality, this would be a tree of jax.ShapeDtypeStruct (metadata\n# for restoration).\nabstract_pytree = {'a': 0}\n\nextra_metadata = {'version': 1.0}\n```\n\n----------------------------------------\n\nTITLE: Orbax Internal Package Path Definition\nDESCRIPTION: Defines the _src package path which contains internal checkpoint implementations. Specifies that this is for internal use and external users should use orbax.checkpoint instead.\nSOURCE: https://github.com/google/orbax/blob/main/checkpoint/orbax/checkpoint/_src/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `_src` package\n```\n\n----------------------------------------\n\nTITLE: Legacy Single-Item Checkpointing Implementation\nDESCRIPTION: Demonstrates the old approach to single-item checkpointing using CheckpointManager\nSOURCE: https://github.com/google/orbax/blob/main/docs/guides/checkpoint/api_refactor.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\noptions = ocp.CheckpointManagerOptions()\nmngr = ocp.CheckpointManager(\n  ocp.test_utils.erase_and_create_empty('/tmp/ckpt1/'),\n  ocp.Checkpointer(ocp.PyTreeCheckpointHandler()),\n  options=options,\n)\n\nrestore_args = ocp.checkpoint_utils.construct_restore_args(abstract_pytree)\nmngr.save(0, pytree)\nmngr.wait_until_finished()\n\nmngr.restore(\n    0,\n    items=abstract_pytree,\n    restore_kwargs={'restore_args': restore_args}\n)\n```\n\n----------------------------------------\n\nTITLE: Creating OBM Orchestration\nDESCRIPTION: Demonstrates creating an orchestration to define interactions between OBM objects using reference names.\nSOURCE: https://github.com/google/orbax/blob/main/model/README.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport orbax_export as oex\n\norchestration = oex.orchestration(\n    model_function_name=\"my_model_fn\",\n    weights_name=\"my_weights\",\n    pre_processor_name=\"my_pre_processor\",\n    post_processor_name=\"my_post_processor\")\n```\n\n----------------------------------------\n\nTITLE: ReStructuredText Module Documentation Directive\nDESCRIPTION: Documentation directives for the Orbax checkpoint deleter module using Sphinx/ReStructuredText format. Sets up automodule documentation for the orbax.checkpoint.path.deleter module.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/checkpoint.path.deleter.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. currentmodule:: orbax.checkpoint.path.deleter\n\n.. automodule:: orbax.checkpoint.path.deleter\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Configuration for Orbax Module\nDESCRIPTION: RestructuredText directives for configuring Sphinx documentation of the orbax.experimental.model.core.python.unstructured_data module. Sets up module reference documentation with automatic member inclusion.\nSOURCE: https://github.com/google/orbax/blob/main/docs/api_reference/model.core.python.unstructured_data.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. currentmodule:: orbax.experimental.model.core.python.unstructured_data\n\n.. automodule:: orbax.experimental.model.core.python.unstructured_data\n  :members:\n```"
  }
]