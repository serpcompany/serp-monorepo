[
  {
    "owner": "langchain-ai",
    "repo": "langsmith-sdk",
    "content": "TITLE: Creating a dataset from existing runs in LangSmith\nDESCRIPTION: Code example demonstrating how to use the LangSmith Client to create a dataset from existing runs stored in LangSmith, filtering for specific runs and converting them into examples for evaluation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom langsmith import Client\n\nclient = Client()\ndataset_name = \"Example Dataset\"\n# We will only use examples from the top level AgentExecutor run here,\n# and exclude runs that errored.\nruns = client.list_runs(\n    project_name=\"my_project\",\n    execution_order=1,\n    error=False,\n)\n\ndataset = client.create_dataset(dataset_name, description=\"An example dataset\")\nfor run in runs:\n    client.create_example(\n        inputs=run.inputs,\n        outputs=run.outputs,\n        dataset_id=dataset.id,\n    )\n```\n\n----------------------------------------\n\nTITLE: PyO3 Rust Implementation\nDESCRIPTION: Example Rust code implementing a Python module with a simple string formatting function\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/getting-started.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n/// Formats the sum of two numbers as string.\n#[pyfunction]\nfn sum_as_string(a: usize, b: usize) -> PyResult<String> {\n    Ok((a + b).to_string())\n}\n\n/// A Python module implemented in Rust. The name of this function must match\n/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able to\n/// import the module.\n#[pymodule]\nfn pyo3_example(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(sum_as_string, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Methods in Rust for Python Classes\nDESCRIPTION: This snippet shows how to create class methods for Python classes using the #[classmethod] attribute. It demonstrates how to access the class type object.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyType;\n\n#[pyclass]\nstruct MyClass {\n    num: i32,\n}\n\n#[pymethods]\nimpl MyClass {\n    #[classmethod]\n    fn cls_method(cls: &Bound<'_, PyType>) -> PyResult<i32> {\n        Ok(10)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PyO3 Method Arguments with Signature Attributes\nDESCRIPTION: This snippet demonstrates how to use the #[pyo3(signature = (...))] attribute to specify default values, positional arguments, and keyword arguments for Python method bindings.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    #[new]\n    #[pyo3(signature = (num=-1))]\n    fn new(num: i32) -> Self {\n        MyClass { num }\n    }\n\n    #[pyo3(signature = (num=10, *py_args, name=\"Hello\", **py_kwargs))]\n    fn method(\n        &mut self,\n        num: i32,\n        py_args: &Bound<'_, PyTuple>,\n        name: &str,\n        py_kwargs: Option<&Bound<'_, PyDict>>,\n    ) -> String {\n        let num_before = self.num;\n        self.num = num;\n        format!(\n            \"num={} (was previously={}), py_args={:?}, name={}, py_kwargs={:?} \",\n            num, num_before, py_args, name, py_kwargs,\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tracing OpenAI API calls with the @traceable decorator\nDESCRIPTION: Comprehensive example of using the @traceable decorator to log traces of functions that use the OpenAI API, showing nested function calls and how they are automatically traced in LangSmith.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom typing import List, Optional, Tuple\n\nimport openai\nfrom langsmith import traceable\nfrom langsmith.wrappers import wrap_openai\n\nclient = wrap_openai(openai.Client())\n\n@traceable\ndef argument_generator(query: str, additional_description: str = \"\") -> str:\n    return client.chat.completions.create(\n        [\n            {\"role\": \"system\", \"content\": \"You are a debater making an argument on a topic.\"\n             f\"{additional_description}\"\n             f\" The current time is {datetime.now()}\"},\n            {\"role\": \"user\", \"content\": f\"The discussion topic is {query}\"}\n        ]\n    ).choices[0].message.content\n\n\n\n@traceable\ndef argument_chain(query: str, additional_description: str = \"\") -> str:\n    argument = argument_generator(query, additional_description)\n    # ... Do other processing or call other functions...\n    return argument\n\nargument_chain(\"Why is blue better than orange?\")\n```\n\n----------------------------------------\n\nTITLE: Tracing OpenAI API calls using LangSmith wrappers and decorators\nDESCRIPTION: Example of how to use LangSmith's wrappers and decorators to automatically trace OpenAI API calls, demonstrating integration with the OpenAI client and the @traceable decorator for function tracing.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport openai\nfrom langsmith.wrappers import wrap_openai\nfrom langsmith import traceable\n\n# Auto-trace LLM calls in-context\nclient = wrap_openai(openai.Client())\n\n@traceable # Auto-trace this function\ndef pipeline(user_input: str):\n    result = client.chat.completions.create(\n        messages=[{\"role\": \"user\", \"content\": user_input}],\n        model=\"gpt-3.5-turbo\"\n    )\n    return result.choices[0].message.content\n\npipeline(\"Hello, world!\")\n```\n\n----------------------------------------\n\nTITLE: Installing LangSmith SDK with pip and setting environment variables\nDESCRIPTION: Commands to install the LangSmith SDK via pip and set necessary environment variables for tracing and authentication with the LangSmith platform.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -U langsmith\nexport LANGSMITH_TRACING=true\nexport LANGSMITH_API_KEY=ls_...\n```\n\n----------------------------------------\n\nTITLE: Manually logging traces with RunTree in LangSmith\nDESCRIPTION: Example of manually creating and managing run trees for tracking application flow in LangSmith. Shows how to create parent and child runs, handle errors, and post results to the LangSmith platform.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom langsmith.run_trees import RunTree\n\nparent_run = RunTree(\n    name=\"My Chat Bot\",\n    run_type=\"chain\",\n    inputs={\"text\": \"Summarize this morning's meetings.\"},\n    # project_name= \"Defaults to the LANGSMITH_PROJECT env var\"\n)\nparent_run.post()\n# .. My Chat Bot calls an LLM\nchild_llm_run = parent_run.create_child(\n    name=\"My Proprietary LLM\",\n    run_type=\"llm\",\n    inputs={\n        \"prompts\": [\n            \"You are an AI Assistant. The time is XYZ.\"\n            \" Summarize this morning's meetings.\"\n        ]\n    },\n)\nchild_llm_run.post()\nchild_llm_run.end(\n    outputs={\n        \"generations\": [\n            \"I should use the transcript_loader tool\"\n            \" to fetch meeting_transcripts from XYZ\"\n        ]\n    }\n)\nchild_llm_run.patch()\n# ..  My Chat Bot takes the LLM output and calls\n# a tool / function for fetching transcripts ..\nchild_tool_run = parent_run.create_child(\n    name=\"transcript_loader\",\n    run_type=\"tool\",\n    inputs={\"date\": \"XYZ\", \"content_type\": \"meeting_transcripts\"},\n)\nchild_tool_run.post()\n# The tool returns meeting notes to the chat bot\nchild_tool_run.end(outputs={\"meetings\": [\"Meeting1 notes..\"]})\nchild_tool_run.patch()\n\nchild_chain_run = parent_run.create_child(\n    name=\"Unreliable Component\",\n    run_type=\"tool\",\n    inputs={\"input\": \"Summarize these notes...\"},\n)\nchild_chain_run.post()\n\ntry:\n    # .... the component does work\n    raise ValueError(\"Something went wrong\")\n    child_chain_run.end(outputs={\"output\": \"foo\"}\n    child_chain_run.patch()\nexcept Exception as e:\n    child_chain_run.end(error=f\"I errored again {e}\")\n    child_chain_run.patch()\n    pass\n# .. The chat agent recovers\n\nparent_run.end(outputs={\"output\": [\"The meeting notes are as follows:...\"]})\nres = parent_run.patch()\nres.result()\n```\n\n----------------------------------------\n\nTITLE: Setting Python Text Signatures for PyO3 Methods\nDESCRIPTION: This snippet shows how to use the #[pyo3(text_signature = \"...\")] attribute to provide custom Python function signatures for class methods, including different handling for regular methods, class methods, and static methods.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct MyClass {}\n\n#[pymethods]\nimpl MyClass {\n    #[new]\n    #[pyo3(text_signature = \"(c, d)\")]\n    fn new(c: i32, d: &str) -> Self {\n        Self {}\n    }\n    // the self argument should be written $self\n    #[pyo3(text_signature = \"($self, e, f)\")]\n    fn my_method(&self, e: i32, f: i32) -> i32 {\n        e + f\n    }\n    // similarly for classmethod arguments, use $cls\n    #[classmethod]\n    #[pyo3(text_signature = \"($cls, e, f)\")]\n    fn my_class_method(cls: &Bound<'_, PyType>, e: i32, f: i32) -> i32 {\n        e + f\n    }\n    #[staticmethod]\n    #[pyo3(text_signature = \"(e, f)\")]\n    fn my_static_method(e: i32, f: i32) -> i32 {\n        e + f\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Python Classes in Rust with PyO3\nDESCRIPTION: Examples of defining Python classes using PyO3's #[pyclass] attribute on Rust structs and enums. Shows basic struct definitions, tuple structs, and various enum patterns including unit-only and complex variants.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {\n    inner: i32,\n}\n\n// A \"tuple\" struct\n#[pyclass]\nstruct Number(i32);\n\n// PyO3 supports unit-only enums (which contain only unit variants)\n// These simple enums behave similarly to Python's enumerations (enum.Enum)\n#[pyclass(eq, eq_int)]\n#[derive(PartialEq)]\nenum MyEnum {\n    Variant,\n    OtherVariant = 30, // PyO3 supports custom discriminants.\n}\n\n// PyO3 supports custom discriminants in unit-only enums\n#[pyclass(eq, eq_int)]\n#[derive(PartialEq)]\nenum HttpResponse {\n    Ok = 200,\n    NotFound = 404,\n    Teapot = 418,\n    // ...\n}\n\n// PyO3 also supports enums with Struct and Tuple variants\n#[pyclass]\nenum Shape {\n    Circle { radius: f64 },\n    Rectangle { width: f64, height: f64 },\n    RegularPolygon(u32, f64),\n    Nothing(),\n}\n```\n\n----------------------------------------\n\nTITLE: Setting LangChain environment variables for LangSmith integration\nDESCRIPTION: Python code showing how to set the necessary environment variables to enable LangSmith tracing with LangChain applications, including the endpoint URL, API key, and optional project name.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport os\nos.environ[\"LANGSMITH_TRACING\"] = \"true\"\nos.environ[\"LANGSMITH_ENDPOINT\"] = \"https://api.smith.langchain.com\"\n# os.environ[\"LANGSMITH_ENDPOINT\"] = \"https://eu.api.smith.langchain.com\" # If signed up in the EU region\nos.environ[\"LANGSMITH_API_KEY\"] = \"<YOUR-LANGSMITH-API-KEY>\"\n# os.environ[\"LANGSMITH_PROJECT\"] = \"My Project Name\" # Optional: \"default\" is used if not set\n```\n\n----------------------------------------\n\nTITLE: Evaluating runs with custom evaluation functions in LangSmith\nDESCRIPTION: Example showing how to create custom evaluation functions and use the StringEvaluator to automatically grade runs in LangSmith, including computing similarity scores and assigning correctness labels.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\nfrom langsmith.evaluation import StringEvaluator\n\n\ndef jaccard_chars(output: str, answer: str) -> float:\n    \"\"\"Naive Jaccard similarity between two strings.\"\"\"\n    prediction_chars = set(output.strip().lower())\n    answer_chars = set(answer.strip().lower())\n    intersection = prediction_chars.intersection(answer_chars)\n    union = prediction_chars.union(answer_chars)\n    return len(intersection) / len(union)\n\n\ndef grader(run_input: str, run_output: str, answer: Optional[str]) -> dict:\n    \"\"\"Compute the score and/or label for this run.\"\"\"\n    if answer is None:\n        value = \"AMBIGUOUS\"\n        score = 0.5\n    else:\n        score = jaccard_chars(run_output, answer)\n        value = \"CORRECT\" if score > 0.9 else \"INCORRECT\"\n    return dict(score=score, value=value)\n\nevaluator = StringEvaluator(evaluation_name=\"Jaccard\", grading_function=grader)\n\nruns = client.list_runs(\n    project_name=\"my_project\",\n    execution_order=1,\n    error=False,\n)\nfor run in runs:\n    client.evaluate_run(run, evaluator)\n```\n\n----------------------------------------\n\nTITLE: Basic PyO3 Function Definition\nDESCRIPTION: Demonstrates how to define a basic Python function 'double' in Rust using PyO3's #[pyfunction] attribute and add it to a Python module.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn double(x: usize) -> usize {\n    x * 2\n}\n\n#[pymodule]\nfn my_extension(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(double, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript OpenAI Integration Example\nDESCRIPTION: Example showing how to integrate LangSmith tracing with OpenAI's chat completions API using JavaScript/TypeScript. Demonstrates wrapping the OpenAI client and making API calls.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { OpenAI } from \"openai\";\nimport { traceable } from \"langsmith/traceable\";\nimport { wrapOpenAI } from \"langsmith/wrappers\";\n\nconst client = wrapOpenAI(new OpenAI());\n\nawait client.chat.completions.create({\n  model: \"gpt-3.5-turbo\",\n  messages: [{ content: \"Hi there!\", role: \"user\" }],\n});\n```\n\n----------------------------------------\n\nTITLE: Basic LangChain chain with automatic LangSmith tracing\nDESCRIPTION: Example of a simple LangChain chain function that will automatically be traced in LangSmith if the environment variables are correctly set, demonstrating the seamless integration.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_core.runnables import chain\n\n@chain\ndef add_val(x: dict) -> dict:\n    return {\"val\": x[\"val\"] + 1}\n\nadd_val({\"val\": 1})\n```\n\n----------------------------------------\n\nTITLE: Running Python Statements with py_run! Macro\nDESCRIPTION: Demonstrates executing Python statements using PyO3's py_run! macro. Shows interaction between Rust struct and Python code.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-from-rust/calling-existing-code.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::py_run;\n\n#[pyclass]\nstruct UserData {\n    id: u32,\n    name: String,\n}\n\n#[pymethods]\nimpl UserData {\n    fn as_tuple(&self) -> (u32, String) {\n        (self.id, self.name.clone())\n    }\n\n    fn __repr__(&self) -> PyResult<String> {\n        Ok(format!(\"User {}(id: {})\", self.name, self.id))\n    }\n}\n\nPython::with_gil(|py| {\n    let userdata = UserData {\n        id: 34,\n        name: \"Yu\".to_string(),\n    };\n    let userdata = Py::new(py, userdata).unwrap();\n    let userdata_as_tuple = (34, \"Yu\");\n    py_run!(py, userdata userdata_as_tuple, r#\"\nassert repr(userdata) == \"User Yu(id: 34)\"\nassert userdata.as_tuple() == userdata_as_tuple\n    \"#);\n})\n```\n\n----------------------------------------\n\nTITLE: Inheriting from Native Python Types in PyO3\nDESCRIPTION: Demonstrates how to inherit from native Python types like PyDict. This example creates a dictionary with a counter, showing how to interact with both the custom Rust fields and the base Python dictionary.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\nuse std::collections::HashMap;\n\n#[pyclass(extends=PyDict)]\n#[derive(Default)]\nstruct DictWithCounter {\n    counter: HashMap<String, usize>,\n}\n\n#[pymethods]\nimpl DictWithCounter {\n    #[new]\n    fn new() -> Self {\n        Self::default()\n    }\n\n    fn set(slf: &Bound<'_, Self>, key: String, value: Bound<'_, PyAny>) -> PyResult<()> {\n        slf.borrow_mut().counter.entry(key.clone()).or_insert(0);\n        let dict = slf.downcast::<PyDict>()?;\n        dict.set_item(key, value)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Class Attributes for Python Classes in Rust\nDESCRIPTION: This snippet shows how to create class attributes (class variables) for Python classes using the #[classattr] attribute. It demonstrates both method-based and constant-based class attributes.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {}\n\n#[pymethods]\nimpl MyClass {\n    #[classattr]\n    fn my_attribute() -> String {\n        \"hello\".to_string()\n    }\n\n    #[classattr]\n    const MY_CONST_ATTRIBUTE: &'static str = \"foobar\";\n}\n\nPython::with_gil(|py| {\n    let my_class = py.get_type::<MyClass>();\n    pyo3::py_run!(py, my_class, \"assert my_class.my_attribute == 'hello'\")\n});\n```\n\n----------------------------------------\n\nTITLE: Demonstrating PyO3 Type References\nDESCRIPTION: Code snippet showing the common PyO3 types used for Python integration: Python<'py> token, Bound<'py, T>, and Py<T>. These types handle GIL management and Python's reference counting system.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-from-rust.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nPython<'py>  // Token proving GIL acquisition\nBound<'py, T>  // Reference to Python object with GIL proof\nPy<T>          // Reference counted Python object\nBorrowed<'a, 'py, T>  // Borrowed reference to Python object\n```\n\n----------------------------------------\n\nTITLE: Logging Traces Using RunTree in LangSmith\nDESCRIPTION: This snippet demonstrates how to use RunTree to track application components in LangSmith. It shows creating parent and child runs, setting inputs and outputs, and handling errors. RunTree objects require a name and run_type, with optional inputs, outputs, and error attributes.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RunTree, RunTreeConfig } from \"langsmith\";\n\nconst parentRunConfig: RunTreeConfig = {\n  name: \"My Chat Bot\",\n  run_type: \"chain\",\n  inputs: {\n    text: \"Summarize this morning's meetings.\",\n  },\n  serialized: {}, // Serialized representation of this chain\n  // project_name: \"Defaults to the LANGSMITH_PROJECT env var\"\n  // apiUrl: \"Defaults to the LANGSMITH_ENDPOINT env var\"\n  // apiKey: \"Defaults to the LANGSMITH_API_KEY env var\"\n};\n\nconst parentRun = new RunTree(parentRunConfig);\n\nawait parentRun.postRun();\n\nconst childLlmRun = await parentRun.createChild({\n  name: \"My Proprietary LLM\",\n  run_type: \"llm\",\n  inputs: {\n    prompts: [\n      \"You are an AI Assistant. The time is XYZ.\" +\n        \" Summarize this morning's meetings.\",\n    ],\n  },\n});\n\nawait childLlmRun.postRun();\n\nawait childLlmRun.end({\n  outputs: {\n    generations: [\n      \"I should use the transcript_loader tool\" +\n        \" to fetch meeting_transcripts from XYZ\",\n    ],\n  },\n});\n\nawait childLlmRun.patchRun();\n\nconst childToolRun = await parentRun.createChild({\n  name: \"transcript_loader\",\n  run_type: \"tool\",\n  inputs: {\n    date: \"XYZ\",\n    content_type: \"meeting_transcripts\",\n  },\n});\nawait childToolRun.postRun();\n\nawait childToolRun.end({\n  outputs: {\n    meetings: [\"Meeting1 notes..\"],\n  },\n});\n\nawait childToolRun.patchRun();\n\nconst childChainRun = await parentRun.createChild({\n  name: \"Unreliable Component\",\n  run_type: \"tool\",\n  inputs: {\n    input: \"Summarize these notes...\",\n  },\n});\n\nawait childChainRun.postRun();\n\ntry {\n  // .... the component does work\n  throw new Error(\"Something went wrong\");\n} catch (e) {\n  await childChainRun.end({\n    error: `I errored again ${e.message}`,\n  });\n  await childChainRun.patchRun();\n  throw e;\n}\n\nawait childChainRun.patchRun();\n\nawait parentRun.end({\n  outputs: {\n    output: [\"The meeting notes are as follows:...\"],\n  },\n});\n\n// False directs to not exclude child runs\nawait parentRun.patchRun();\n```\n\n----------------------------------------\n\nTITLE: Tracing Next.js API Route Handler\nDESCRIPTION: TypeScript code demonstrating how to use LangSmith tracing in a Next.js API route handler with OpenAI integration.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NextRequest, NextResponse } from \"next/server\";\n\nimport { OpenAI } from \"openai\";\nimport { traceable } from \"langsmith/traceable\";\nimport { wrapOpenAI } from \"langsmith/wrappers\";\n\nexport const runtime = \"edge\";\n\nconst handler = traceable(\n  async function () {\n    const openai = wrapOpenAI(new OpenAI());\n\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-3.5-turbo\",\n      messages: [{ content: \"Why is the sky blue?\", role: \"user\" }],\n    });\n\n    const response1 = completion.choices[0].message.content;\n\n    const completion2 = await openai.chat.completions.create({\n      model: \"gpt-3.5-turbo\",\n      messages: [\n        { content: \"Why is the sky blue?\", role: \"user\" },\n        { content: response1, role: \"assistant\" },\n        { content: \"Cool thank you!\", role: \"user\" },\n      ],\n    });\n\n    const response2 = completion2.choices[0].message.content;\n\n    return {\n      text: response2,\n    };\n  },\n  {\n    name: \"Simple Next.js handler\",\n  }\n);\n\nexport async function POST(req: NextRequest) {\n  const result = await handler();\n  return NextResponse.json(result);\n}\n```\n\n----------------------------------------\n\nTITLE: Python OpenAI Integration Example\nDESCRIPTION: Example showing how to integrate LangSmith tracing with OpenAI's chat completions API using Python. Demonstrates wrapping the OpenAI client for automatic tracing.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport openai\nfrom langsmith import traceable\nfrom langsmith.wrappers import wrap_openai\n\nclient = wrap_openai(openai.Client())\n\nclient.chat.completions.create(\n    messages=[{\"role\": \"user\", \"content\": \"Hello, world\"}],\n    model=\"gpt-3.5-turbo\"\n)\n```\n\n----------------------------------------\n\nTITLE: Deriving IntoPyObject for Structs and Enums in Rust\nDESCRIPTION: This code shows how to use the IntoPyObject derive macro for structs and enums. It covers various scenarios including transparent implementations and handling of lifetimes and generics.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\n# use pyo3::prelude::*;\n# use std::collections::HashMap;\n# use std::hash::Hash;\n\n// structs convert into `PyDict` with field names as keys\n#[derive(IntoPyObject)]\nstruct Struct {\n    count: usize,\n    obj: Py<PyAny>,\n}\n\n// tuple structs convert into `PyTuple`\n// lifetimes and generics are supported, the impl will be bounded by\n// `K: IntoPyObject, V: IntoPyObject`\n#[derive(IntoPyObject)]\nstruct Tuple<'a, K: Hash + Eq, V>(&'a str, HashMap<K, V>);\n\n// newtype tuple structs are implicitly `transparent`\n#[derive(IntoPyObject)]\nstruct TransparentTuple(PyObject);\n\n#[derive(IntoPyObject)]\n#[pyo3(transparent)]\nstruct TransparentStruct<'py> {\n    inner: Bound<'py, PyAny>, // `'py` lifetime will be used as the Python lifetime\n}\n\n#[derive(IntoPyObject)]\nenum Enum<'a, 'py, K: Hash + Eq, V> { // enums are supported and convert using the same\n    TransparentTuple(PyObject),       // rules on the variants as the structs above\n    #[pyo3(transparent)]\n    TransparentStruct { inner: Bound<'py, PyAny> },\n    Tuple(&'a str, HashMap<K, V>),\n    Struct { count: usize, obj: Py<PyAny> }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterable and Iterator in PyO3\nDESCRIPTION: Shows how to implement both an iterable container and its corresponding iterator in PyO3. The Container class implements __iter__ to return a new Iter instance, while Iter implements both __iter__ and __next__.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/protocols.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct Iter {\n    inner: std::vec::IntoIter<usize>,\n}\n\n#[pymethods]\nimpl Iter {\n    fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {\n        slf\n    }\n\n    fn __next__(mut slf: PyRefMut<'_, Self>) -> Option<usize> {\n        slf.inner.next()\n    }\n}\n\n#[pyclass]\nstruct Container {\n    iter: Vec<usize>,\n}\n\n#[pymethods]\nimpl Container {\n    fn __iter__(slf: PyRef<'_, Self>) -> PyResult<Py<Iter>> {\n        let iter = Iter {\n            inner: slf.iter.clone().into_iter(),\n        };\n        Py::new(slf.py(), iter)\n    }\n}\n\nPython::with_gil(|py| {\n    let container = Container { iter: vec![1, 2, 3, 4] };\n    let inst = pyo3::Py::new(py, container).unwrap();\n    pyo3::py_run!(py, inst, \"assert list(inst) == [1, 2, 3, 4]\");\n    pyo3::py_run!(py, inst, \"assert list(iter(iter(inst))) == [1, 2, 3, 4]\");\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Complex Enums with Struct and Tuple Variants\nDESCRIPTION: Shows how to create complex enums with non-unit variants (struct and tuple) in PyO3. Each variant becomes a subclass in Python, with appropriate field access and pattern matching support.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n#[pyclass]\nenum Shape {\n    Circle { radius: f64 },\n    Rectangle { width: f64, height: f64 },\n    RegularPolygon(u32, f64),\n    Nothing { },\n}\n\n#[cfg(Py_3_10)]\nPython::with_gil(|py| {\n    let circle = Shape::Circle { radius: 10.0 }.into_pyobject(py)?;\n    let square = Shape::RegularPolygon(4, 10.0).into_pyobject(py)?;\n    let cls = py.get_type::<Shape>();\n    pyo3::py_run!(py, circle square cls, r#\"\n        assert isinstance(circle, cls)\n        assert isinstance(circle, cls.Circle)\n        assert circle.radius == 10.0\n\n        assert isinstance(square, cls)\n        assert isinstance(square, cls.RegularPolygon)\n        assert square[0] == 4 # Gets _0 field\n        assert square[1] == 10.0 # Gets _1 field\n\n        def count_vertices(cls, shape):\n            match shape:\n                case cls.Circle():\n                    return 0\n                case cls.Rectangle():\n                    return 4\n                case cls.RegularPolygon(n):\n                    return n\n                case cls.Nothing():\n                    return 0\n\n        assert count_vertices(cls, circle) == 0\n        assert count_vertices(cls, square) == 4\n    \"#);\n   Ok::<_, PyErr>(())\n})\n.unwrap();\n```\n\n----------------------------------------\n\nTITLE: Python Call Counter Implementation - Class Version\nDESCRIPTION: Pure Python implementation of a call counter decorator using a class-based approach. Tracks number of times a wrapped function is called using instance variables.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/call.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Counter:\n    def __init__(self, wraps):\n        self.count = 0\n        self.wraps = wraps\n\n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"{self.wraps.__name__} has been called {self.count} time(s)\")\n        self.wraps(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Wrapping OpenAI Client\nDESCRIPTION: Demonstrates how to wrap the OpenAI client with LangSmith for logging capabilities.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom openai import OpenAI\nfrom langsmith import wrappers\n\nclient = wrappers.wrap_openai(OpenAI())\n```\n\n----------------------------------------\n\nTITLE: Setting environment variables for LangSmith without LangChain\nDESCRIPTION: Example of how to set environment variables for using LangSmith independently of LangChain, showing the minimal required configuration for the SDK.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport os\nos.environ[\"LANGSMITH_ENDPOINT\"] = \"https://api.smith.langchain.com\"\nos.environ[\"LANGSMITH_API_KEY\"] = \"<YOUR-LANGSMITH-API-KEY>\"\n# os.environ[\"LANGSMITH_PROJECT\"] = \"My Project Name\" # Optional: \"default\" is used if not set\n```\n\n----------------------------------------\n\nTITLE: Using Traceable Function with OpenAI SDK\nDESCRIPTION: TypeScript code demonstrating how to use the traceable function to wrap OpenAI SDK methods for LangSmith tracing.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { traceable } from \"langsmith/traceable\";\n\nconst openai = new OpenAI();\n\nconst createCompletion = traceable(\n  openai.chat.completions.create.bind(openai.chat.completions),\n  { name: \"OpenAI Chat Completion\", run_type: \"llm\" }\n);\n\nawait createCompletion({\n  model: \"gpt-3.5-turbo\",\n  messages: [{ content: \"Hi there!\", role: \"user\" }],\n});\n```\n\n----------------------------------------\n\nTITLE: Evaluating Runs with Custom Evaluator in LangSmith\nDESCRIPTION: This snippet shows how to create a custom evaluator using the StringEvaluator class from LangSmith. It implements a Jaccard similarity-based grading function and applies it to evaluate runs from a specific project.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { StringEvaluator } from \"langsmith/evaluation\";\n\nfunction jaccardChars(output: string, answer: string): number {\n  const predictionChars = new Set(output.trim().toLowerCase());\n  const answerChars = new Set(answer.trim().toLowerCase());\n  const intersection = [...predictionChars].filter((x) => answerChars.has(x));\n  const union = new Set([...predictionChars, ...answerChars]);\n  return intersection.length / union.size;\n}\n\nasync function grader(config: {\n  input: string;\n  prediction: string;\n  answer?: string;\n}): Promise<{ score: number; value: string }> {\n  let value: string;\n  let score: number;\n  if (config.answer === null || config.answer === undefined) {\n    value = \"AMBIGUOUS\";\n    score = 0.5;\n  } else {\n    score = jaccardChars(config.prediction, config.answer);\n    value = score > 0.9 ? \"CORRECT\" : \"INCORRECT\";\n  }\n  return { score: score, value: value };\n}\n\nconst evaluator = new StringEvaluator({\n  evaluationName: \"Jaccard\",\n  gradingFunction: grader,\n});\n\nconst runs = await client.listRuns({\n  projectName: \"my_project\",\n  executionOrder: 1,\n  error: false,\n});\n\nfor (const run of runs) {\n  client.evaluateRun(run, evaluator);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GC Support in PyO3 Rust Class\nDESCRIPTION: Example implementation of a Rust class with garbage collector support using PyO3. Shows how to implement __traverse__ and __clear__ methods to properly handle Python object references and prevent memory leaks. The class maintains an optional reference to a Python object that needs to be properly tracked by the garbage collector.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/protocols.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::PyTraverseError;\nuse pyo3::gc::PyVisit;\n\n#[pyclass]\nstruct ClassWithGCSupport {\n    obj: Option<PyObject>,\n}\n\n#[pymethods]\nimpl ClassWithGCSupport {\n    fn __traverse__(&self, visit: PyVisit<'_>) -> Result<(), PyTraverseError> {\n        if let Some(obj) = &self.obj {\n            visit.call(obj)?\n        }\n        Ok(())\n    }\n\n    fn __clear__(&mut self) {\n        // Clear reference, this decrements ref counter.\n        self.obj = None;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Number Class Implementation with All Methods\nDESCRIPTION: Final comprehensive implementation of the Number class including all methods: constructor, representation, comparison operators, arithmetic operations, type conversions, and the module initialization function.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\nuse pyo3::exceptions::{PyValueError, PyZeroDivisionError};\nuse pyo3::prelude::*;\nuse pyo3::class::basic::CompareOp;\nuse pyo3::types::{PyComplex, PyString};\n\nfn wrap(obj: &Bound<'_, PyAny>) -> PyResult<i32> {\n    let val = obj.call_method1(\"__and__\", (0xFFFFFFFF_u32,))?;\n    let val: u32 = val.extract()?;\n    Ok(val as i32)\n}\n/// Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought not.\n/// It's not a story C would tell you. It's a Rust legend.\n#[pyclass(module = \"my_module\")]\nstruct Number(i32);\n\n#[pymethods]\nimpl Number {\n    #[new]\n    fn new(#[pyo3(from_py_with = \"wrap\")] value: i32) -> Self {\n        Self(value)\n    }\n\n    fn __repr__(slf: &Bound<'_, Self>) -> PyResult<String> {\n       // Get the class name dynamically in case `Number` is subclassed\n       let class_name: Bound<'_, PyString> = slf.get_type().qualname()?;\n        Ok(format!(\"{}{}\", class_name, slf.borrow().0))\n    }\n\n    fn __str__(&self) -> String {\n        self.0.to_string()\n    }\n\n    fn __hash__(&self) -> u64 {\n        let mut hasher = DefaultHasher::new();\n        self.0.hash(&mut hasher);\n        hasher.finish()\n    }\n\n    fn __richcmp__(&self, other: &Self, op: CompareOp) -> PyResult<bool> {\n        match op {\n            CompareOp::Lt => Ok(self.0 < other.0),\n            CompareOp::Le => Ok(self.0 <= other.0),\n            CompareOp::Eq => Ok(self.0 == other.0),\n            CompareOp::Ne => Ok(self.0 != other.0),\n            CompareOp::Gt => Ok(self.0 > other.0),\n            CompareOp::Ge => Ok(self.0 >= other.0),\n        }\n    }\n\n    fn __bool__(&self) -> bool {\n        self.0 != 0\n    }\n\n    fn __add__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_add(other.0))\n    }\n\n    fn __sub__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_sub(other.0))\n    }\n\n    fn __mul__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_mul(other.0))\n    }\n\n    fn __truediv__(&self, other: &Self) -> PyResult<Self> {\n        match self.0.checked_div(other.0) {\n            Some(i) => Ok(Self(i)),\n            None => Err(PyZeroDivisionError::new_err(\"division by zero\")),\n        }\n    }\n\n    fn __floordiv__(&self, other: &Self) -> PyResult<Self> {\n        match self.0.checked_div(other.0) {\n            Some(i) => Ok(Self(i)),\n            None => Err(PyZeroDivisionError::new_err(\"division by zero\")),\n        }\n    }\n\n    fn __rshift__(&self, other: &Self) -> PyResult<Self> {\n        match other.0.try_into() {\n            Ok(rhs) => Ok(Self(self.0.wrapping_shr(rhs))),\n            Err(_) => Err(PyValueError::new_err(\"negative shift count\")),\n        }\n    }\n\n    fn __lshift__(&self, other: &Self) -> PyResult<Self> {\n        match other.0.try_into() {\n            Ok(rhs) => Ok(Self(self.0.wrapping_shl(rhs))),\n            Err(_) => Err(PyValueError::new_err(\"negative shift count\")),\n        }\n    }\n\n    fn __xor__(&self, other: &Self) -> Self {\n        Self(self.0 ^ other.0)\n    }\n\n    fn __or__(&self, other: &Self) -> Self {\n        Self(self.0 | other.0)\n    }\n\n    fn __and__(&self, other: &Self) -> Self {\n        Self(self.0 & other.0)\n    }\n\n    fn __int__(&self) -> i32 {\n        self.0\n    }\n\n    fn __float__(&self) -> f64 {\n        self.0 as f64\n    }\n\n    fn __complex__<'py>(&self, py: Python<'py>) -> Bound<'py, PyComplex> {\n        PyComplex::from_doubles(py, self.0 as f64, 0.0)\n    }\n}\n\n#[pymodule]\nfn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<Number>()?;\n    Ok(())\n}\n# const SCRIPT: &'static std::ffi::CStr = pyo3::ffi::c_str!(r#\"\n# def hash_djb2(s: str):\n#     n = Number(0)\n#     five = Number(5)\n#\n#     for x in s:\n#         n = Number(ord(x)) + ((n << five) - n)\n#     return n\n#\n# assert hash_djb2('l50_50') == Number(-1152549421)\n# assert hash_djb2('logo') == Number(3327403)\n# assert hash_djb2('horizon') == Number(1097468315)\n#\n#\n# assert Number(2) + Number(2) == Number(4)\n# assert Number(2) + Number(2) != Number(5)\n#\n# assert Number(13) - Number(7) == Number(6)\n# assert Number(13) - Number(-7) == Number(20)\n#\n# assert Number(13) / Number(7) == Number(1)\n# assert Number(13) // Number(7) == Number(1)\n#\n# assert Number(13) * Number(7) == Number(13*7)\n#\n# assert Number(13) > Number(7)\n# assert Number(13) < Number(20)\n# assert Number(13) == Number(13)\n# assert Number(13) >= Number(7)\n# assert Number(13) <= Number(20)\n# assert Number(13) == Number(13)\n#\n#\n# assert (True if Number(1) else False)\n# assert (False if Number(0) else True)\n#\n#\n# assert int(Number(13)) == 13\n# assert float(Number(13)) == 13\n# assert Number.__doc__ == \"Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought not.\\nIt's not a story C would tell you. It's a Rust legend.\"\n# assert Number(12345234523452) == Number(1498514748)\n# try:\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Multi-level Inheritance in PyO3\nDESCRIPTION: Shows how to create a class that inherits from a derived class, demonstrating multi-level inheritance. It uses PyClassInitializer for complex initialization and demonstrates accessing methods from multiple levels of inheritance.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(extends=SubClass)]\nstruct SubSubClass {\n    val3: usize,\n}\n\n#[pymethods]\nimpl SubSubClass {\n    #[new]\n    fn new() -> PyClassInitializer<Self> {\n        PyClassInitializer::from(SubClass::new()).add_subclass(SubSubClass { val3: 20 })\n    }\n\n    fn method3(self_: PyRef<'_, Self>) -> PyResult<usize> {\n        let base = self_.as_super().as_super(); // Get &PyRef<'_, BaseClass>\n        base.method1().map(|x| x * self_.val3)\n    }\n\n    fn method4(self_: PyRef<'_, Self>) -> PyResult<usize> {\n        let v = self_.val3;\n        let super_ = self_.into_super(); // Get PyRef<'_, SubClass>\n        SubClass::method2(super_).map(|x| x * v)\n    }\n\n    fn get_values(self_: PyRef<'_, Self>) -> (usize, usize, usize) {\n        let val1 = self_.as_super().as_super().val1;\n        let val2 = self_.as_super().val2;\n        (val1, val2, self_.val3)\n    }\n\n    fn double_values(mut self_: PyRefMut<'_, Self>) {\n        self_.as_super().as_super().val1 *= 2;\n        self_.as_super().val2 *= 2;\n        self_.val3 *= 2;\n    }\n\n    #[staticmethod]\n    fn factory_method(py: Python<'_>, val: usize) -> PyResult<PyObject> {\n        let base = PyClassInitializer::from(BaseClass::new());\n        let sub = base.add_subclass(SubClass { val2: val });\n        if val % 2 == 0 {\n            Ok(Py::new(py, sub)?.into_any())\n        } else {\n            let sub_sub = sub.add_subclass(SubSubClass { val3: val });\n            Ok(Py::new(py, sub_sub)?.into_any())\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Error Type Implementation\nDESCRIPTION: Comprehensive example showing how to create a custom IO error type and convert it to Python OSError, including implementation of necessary traits.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/error-handling.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::exceptions::PyOSError;\nuse pyo3::prelude::*;\nuse std::fmt;\n\n#[derive(Debug)]\nstruct CustomIOError;\n\nimpl std::error::Error for CustomIOError {}\n\nimpl fmt::Display for CustomIOError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Oh no!\")\n    }\n}\n\nimpl std::convert::From<CustomIOError> for PyErr {\n    fn from(err: CustomIOError) -> PyErr {\n        PyOSError::new_err(err.to_string())\n    }\n}\n\npub struct Connection {/* ... */}\n\nfn bind(addr: String) -> Result<Connection, CustomIOError> {\n    if &addr == \"0.0.0.0\" {\n        Err(CustomIOError)\n    } else {\n        Ok(Connection{ /* ... */})\n    }\n}\n\n#[pyfunction]\nfn connect(s: String) -> Result<(), CustomIOError> {\n    bind(s)?;\n    // etc.\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Constructor Implementation in PyO3\nDESCRIPTION: Examples of implementing constructors for Python classes using #[new] attribute, including basic constructor and error handling patterns.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl Number {\n    #[new]\n    fn new(value: i32) -> Self {\n        Number(value)\n    }\n}\n\n#[pymethods]\nimpl Nonzero {\n    #[new]\n    fn py_new(value: i32) -> PyResult<Self> {\n        if value == 0 {\n            Err(PyValueError::new_err(\"cannot be zero\"))\n        } else {\n            Ok(Nonzero(value))\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Testing a PyO3 Module\nDESCRIPTION: Commands to build a PyO3 module with maturin and test it in Python. Demonstrates importing the module and calling a function from Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ maturin develop\n# lots of progress output as maturin runs the compilation...\n$ python\n>>> import string_sum\n>>> string_sum.sum_as_string(5, 20)\n'25'\n```\n\n----------------------------------------\n\nTITLE: Basic Python Module Creation in Rust\nDESCRIPTION: Demonstrates creating a basic Python module with a single function using PyO3's pymodule macro. Includes a simple double function and module initialization.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/module.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn double(x: usize) -> usize {\n    x * 2\n}\n\n/// This module is implemented in Rust.\n#[pymodule]\nfn my_extension(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(double, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Basic OpenAI Chat Completion\nDESCRIPTION: Shows a basic chat completion request using the wrapped OpenAI client.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclient.chat.completions.create(\n    model=\"gpt-4\",\n    messages=[{\"role\": \"user\", \"content\": \"Say this is a test\"}],\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Dataset from Existing Runs in LangSmith\nDESCRIPTION: This example demonstrates how to create a dataset from existing runs stored in LangSmith using the Client. It filters runs based on specific criteria and creates examples for the dataset using the run inputs and outputs.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"langsmith/client\";\nconst client = new Client({\n  // apiUrl: \"https://api.langchain.com\", // Defaults to the LANGSMITH_ENDPOINT env var\n  // apiKey: \"my_api_key\", // Defaults to the LANGSMITH_API_KEY env var\n  /* callerOptions: {\n         maxConcurrency?: Infinity; // Maximum number of concurrent requests to make\n         maxRetries?: 6; // Maximum number of retries to make\n    */\n});\nconst datasetName = \"Example Dataset\";\n// We will only use examples from the top level AgentExecutor run here,\n// and exclude runs that errored.\nconst runs = await client.listRuns({\n  projectName: \"my_project\",\n  executionOrder: 1,\n  error: false,\n});\n\nconst dataset = await client.createDataset(datasetName, {\n  description: \"An example dataset\",\n});\n\nfor (const run of runs) {\n  await client.createExample(run.inputs, run.outputs ?? {}, {\n    datasetId: dataset.id,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Converting between Py<T> and Borrowed<'a, 'py, T> Smart Pointers in Rust\nDESCRIPTION: Shows how to convert between `Py<T>` and `Borrowed<'a, 'py, T>` smart pointer types using `bind_borrowed()`, and how to convert back using either `as_unbound()` or by creating a new owned reference.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet obj: Py<PyAny> = ...;\nlet borrowed: Borrowed<'_, 'py, PyAny> = bound.as_borrowed();\n\n// via deref coercion to Bound and then using Bound::as_unbound\nlet obj: &Py<PyAny> = borrowed.as_unbound();\n\n// via a new Bound by increasing the Python reference count, and unbind it\nlet obj: Py<PyAny> = borrowed.to_owned().unbind().\n```\n\n----------------------------------------\n\nTITLE: Implementing C-like Enums with PyO3 in Rust\nDESCRIPTION: This snippet demonstrates creating a simple enum (C-like enum) with PyO3, including automatic implementation of comparison operations, integer conversion, and string representation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(eq, eq_int)]\n#[derive(PartialEq)]\nenum MyEnum {\n    Variant,\n    OtherVariant,\n}\n\nPython::with_gil(|py| {\n    let x = Py::new(py, MyEnum::Variant).unwrap();\n    let y = Py::new(py, MyEnum::OtherVariant).unwrap();\n    let cls = py.get_type::<MyEnum>();\n    pyo3::py_run!(py, x y cls, r#\"\n        assert x == cls.Variant\n        assert y == cls.OtherVariant\n        assert x != y\n    \"#)\n})\n```\n\n----------------------------------------\n\nTITLE: Embedding Python in a Rust Application\nDESCRIPTION: Example Rust program that embeds a Python interpreter. Demonstrates accessing Python's sys module, evaluating Python code, and interacting with the Python environment from Rust.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/README.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::IntoPyDict;\nuse pyo3::ffi::c_str;\n\nfn main() -> PyResult<()> {\n    Python::with_gil(|py| {\n        let sys = py.import(\"sys\")?;\n        let version: String = sys.getattr(\"version\")?.extract()?;\n\n        let locals = [(\"os\", py.import(\"os\")?)].into_py_dict(py)?;\n        let code = c_str!(\"os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'\");\n        let user: String = py.eval(code, None, Some(&locals))?.extract()?;\n\n        println!(\"Hello {}, I'm Python {}\", user, version);\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Parallel Word Count Implementation in Rust with PyO3\nDESCRIPTION: Implementation of a parallel word counting function using rayon for parallel string processing. Uses PyO3 to expose the functionality to Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/parallelism.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nuse rayon::str::ParallelString;\nuse rayon::iter::ParallelIterator;\n\nfn count_line(line: &str, needle: &str) -> usize {\n    let mut total = 0;\n    for word in line.split(' ') {\n        if word == needle {\n            total += 1;\n        }\n    }\n    total\n}\n\n#[pyfunction]\nfn search(contents: &str, needle: &str) -> usize {\n    contents\n        .par_lines()\n        .map(|line| count_line(line, needle))\n        .sum()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Python Module in Rust\nDESCRIPTION: Implementation of a Python module in Rust using PyO3. Includes a function that sums two numbers and returns the result as a string, and the module definition that exposes the function to Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/README.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n/// Formats the sum of two numbers as string.\n#[pyfunction]\nfn sum_as_string(a: usize, b: usize) -> PyResult<String> {\n    Ok((a + b).to_string())\n}\n\n/// A Python module implemented in Rust. The name of this function must match\n/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able to\n/// import the module.\n#[pymodule]\nfn string_sum(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing with orjson in Python\nDESCRIPTION: Demonstrates how to use orjson to serialize complex data structures including datetime and numpy arrays, and then deserialize the result.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, datetime, numpy\n>>> data = {\n    \"type\": \"job\",\n    \"created_at\": datetime.datetime(1970, 1, 1),\n    \"status\": \"\",\n    \"payload\": numpy.array([[1, 2], [3, 4]]),\n}\n>>> orjson.dumps(data, option=orjson.OPT_NAIVE_UTC | orjson.OPT_SERIALIZE_NUMPY)\nb'{\"type\":\"job\",\"created_at\":\"1970-01-01T00:00:00+00:00\",\"status\":\"\\xf0\\x9f\\x86\\x97\",\"payload\":[[1,2],[3,4]]}'\n>>> orjson.loads(_)\n{'type': 'job', 'created_at': '1970-01-01T00:00:00+00:00', 'status': '', 'payload': [[1, 2], [3, 4]]}\n```\n\n----------------------------------------\n\nTITLE: Installing and Configuring LangSmith Python SDK\nDESCRIPTION: Command line instructions for installing the LangSmith Python package and setting up required environment variables for tracing functionality.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -U langsmith\nexport LANGSMITH_TRACING=true\nexport LANGSMITH_API_KEY=ls_...\n```\n\n----------------------------------------\n\nTITLE: Async-Std Native Module Implementation\nDESCRIPTION: Rust implementation of a native Python module using async-std runtime.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::{prelude::*, wrap_pyfunction};\n\n#[pyfunction]\nfn rust_sleep(py: Python<'_>) -> PyResult<&Bound<'_, PyAny>> {\n    pyo3_asyncio::async_std::future_into_py(py, async {\n        async_std::task::sleep(std::time::Duration::from_secs(1)).await;\n        Ok(Python::with_gil(|py| py.None()))\n    })\n}\n\n#[pymodule]\nfn my_async_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(rust_sleep, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Handling System Signals (Ctrl-C) in Rust with PyO3\nDESCRIPTION: Shows how to handle system signals like Ctrl-C in Rust code that uses PyO3. This example demonstrates setting Python's signal module to use the default action for SIGINT, allowing interruption of Rust code execution.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-from-rust/calling-existing-code.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n# fn main() -> PyResult<()> {\nPython::with_gil(|py| -> PyResult<()> {\n    let signal = py.import(\"signal\")?;\n    // Set SIGINT to have the default action\n    signal\n        .getattr(\"signal\")?\n        .call1((signal.getattr(\"SIGINT\")?, signal.getattr(\"SIG_DFL\")?))?;\n    Ok(())\n})\n# }\n```\n\n----------------------------------------\n\nTITLE: Custom Argument Conversion\nDESCRIPTION: Demonstrates using from_py_with to specify custom conversion logic for function arguments from Python to Rust types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nfn get_length(obj: &Bound<'_, PyAny>) -> PyResult<usize> {\n    obj.len()\n}\n\n#[pyfunction]\nfn object_length(#[pyo3(from_py_with = \"get_length\")] argument: usize) -> usize {\n    argument\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Configuration for PyO3\nDESCRIPTION: Required Cargo.toml configuration for setting up a Rust library that can be used from Python\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/getting-started.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"pyo3_start\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\nname = \"pyo3_example\"\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npyo3 = { {{#PYO3_CRATE_VERSION}}, features = [\"extension-module\"] }\n```\n\n----------------------------------------\n\nTITLE: Creating and Passing Keyword Arguments in Python Function Calls from Rust\nDESCRIPTION: Shows different ways to create and pass keyword arguments when calling Python functions from Rust using PyO3. Demonstrates using PyDict, Vec, and HashMap to construct keyword arguments.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-from-rust/function-calls.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::IntoPyDict;\nuse std::collections::HashMap;\nuse pyo3_ffi::c_str;\n\nfn main() -> PyResult<()> {\n    let key1 = \"key1\";\n    let val1 = 1;\n    let key2 = \"key2\";\n    let val2 = 2;\n\n    Python::with_gil(|py| {\n        let fun: Py<PyAny> = PyModule::from_code(\n            py,\n            c_str!(\"def example(*args, **kwargs):\\n                if args != ():\\n                    print('called with args', args)\\n                if kwargs != {}:\\n                    print('called with kwargs', kwargs)\\n                if args == () and kwargs == {}:\\n                    print('called with no arguments')\"),\n            c_str!(\"\"),\n            c_str!(\"\"),\n        )?\n        .getattr(\"example\")?\n        .into();\n\n        // call object with PyDict\n        let kwargs = [(key1, val1)].into_py_dict(py)?;\n        fun.call(py, (), Some(&kwargs))?;\n\n        // pass arguments as Vec\n        let kwargs = vec![(key1, val1), (key2, val2)];\n        fun.call(py, (), Some(&kwargs.into_py_dict(py)?))?;\n\n        // pass arguments as HashMap\n        let mut kwargs = HashMap::<&str, i32>::new();\n        kwargs.insert(key1, 1);\n        fun.call(py, (), Some(&kwargs.into_py_dict(py)?))?;\n\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Python Module from Code with PyModule::from_code\nDESCRIPTION: Shows how to create a Python module from code string using PyO3's PyModule::from_code. Implements neural network activation functions as an example.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-from-rust/calling-existing-code.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::{prelude::*, types::IntoPyDict};\nuse pyo3_ffi::c_str;\n\nPython::with_gil(|py| {\n    let activators = PyModule::from_code(\n        py,\n        c_str!(r#\"\ndef relu(x):\n    \"\"\"see https://en.wikipedia.org/wiki/Rectifier_(neural_networks)\"\"\"\n    return max(0.0, x)\n\ndef leaky_relu(x, slope=0.01):\n    return x if x >= 0 else x * slope\n    \"#),\n        c_str!(\"activators.py\"),\n        c_str!(\"activators\"),\n    )?;\n\n    let relu_result: f64 = activators.getattr(\"relu\")?.call1((-1.0,))?.extract()?;\n    assert_eq!(relu_result, 0.0);\n\n    let kwargs = [(\"slope\", 0.2)].into_py_dict(py)?;\n    let lrelu_result: f64 = activators\n        .getattr(\"leaky_relu\")?\n        .call((-1.0,), Some(&kwargs))?\n        .extract()?;\n    assert_eq!(lrelu_result, -0.2);\n    Ok(())\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Builtin Function Support for Number Class\nDESCRIPTION: Implementation of special methods (__int__, __float__, __complex__) to support Python's builtin type conversion functions when used with Number objects.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#\n# #[pyclass]\n# struct Number(i32);\n#\nuse pyo3::types::PyComplex;\n\n#[pymethods]\nimpl Number {\n    fn __int__(&self) -> i32 {\n        self.0\n    }\n\n    fn __float__(&self) -> f64 {\n        self.0 as f64\n    }\n\n    fn __complex__<'py>(&self, py: Python<'py>) -> Bound<'py, PyComplex> {\n        PyComplex::from_doubles(py, self.0 as f64, 0.0)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Non-String Dictionary Keys in Python orjson\nDESCRIPTION: Demonstrates the OPT_NON_STR_KEYS option for serializing dictionary keys of types other than str. This allows keys to be of various types including int, float, bool, None, datetime, date, time, Enum, and UUID.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, datetime, uuid\n>>> orjson.dumps(\n        {uuid.UUID(\"7202d115-7ff3-4c81-a7c1-2a1f067b1ece\"): [1, 2, 3]},\n        option=orjson.OPT_NON_STR_KEYS,\n    )\nb'{\"7202d115-7ff3-4c81-a7c1-2a1f067b1ece\":[1,2,3]}'\n>>> orjson.dumps(\n        {datetime.datetime(1970, 1, 1, 0, 0, 0): [1, 2, 3]},\n        option=orjson.OPT_NON_STR_KEYS | orjson.OPT_NAIVE_UTC,\n    )\nb'{\"1970-01-01T00:00:00+00:00\":[1,2,3]}'\n```\n\n----------------------------------------\n\nTITLE: Using Python Context Managers in Rust with PyO3\nDESCRIPTION: Demonstrates how to use Python context managers in Rust by directly invoking __enter__ and __exit__ methods. The example creates a custom context manager class in Python, instantiates it, and then manually handles the context lifecycle including error propagation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-from-rust/calling-existing-code.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::ffi::c_str;\n\nfn main() {\n    Python::with_gil(|py| {\n        let custom_manager = PyModule::from_code(\n            py,\n            c_str!(r#\"\nclass House(object):\n    def __init__(self, address):\n        self.address = address\n    def __enter__(self):\n        print(f\"Welcome to {self.address}!\")\n    def __exit__(self, type, value, traceback):\n        if type:\n            print(f\"Sorry you had {type} trouble at {self.address}\")\n        else:\n            print(f\"Thank you for visiting {self.address}, come again soon!\")\n\n        \"#),\n            c_str!(\"house.py\"),\n            c_str!(\"house\"),\n        )\n        .unwrap();\n\n        let house_class = custom_manager.getattr(\"House\").unwrap();\n        let house = house_class.call1((\"123 Main Street\",)).unwrap();\n\n        house.call_method0(\"__enter__\").unwrap();\n\n        let result = py.eval(c_str!(\"undefined_variable + 1\"), None, None);\n\n        // If the eval threw an exception we'll pass it through to the context manager.\n        // Otherwise, __exit__  is called with empty arguments (Python \"None\").\n        match result {\n            Ok(_) => {\n                let none = py.None();\n                house\n                    .call_method1(\"__exit__\", (&none, &none, &none))\n                    .unwrap();\n            }\n            Err(e) => {\n                house\n                    .call_method1(\n                        \"__exit__\",\n                        (\n                            e.get_type(py),\n                            e.value(py),\n                            e.traceback(py),\n                        ),\n                    )\n                    .unwrap();\n            }\n        }\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Model Trait and Solve Function in Rust\nDESCRIPTION: Basic implementation of a Model trait and solve function that operates on any type implementing the Model trait.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/trait-bounds.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Model {\n    fn set_variables(&mut self, inputs: &Vec<f64>);\n    fn compute(&mut self);\n    fn get_results(&self) -> Vec<f64>;\n}\n\npub fn solve<T: Model>(model: &mut T) {\n    println!(\"Magic solver that mutates the model into a resolved state\");\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing Python Objects Between Rust Threads\nDESCRIPTION: Example demonstrating how to safely share Python objects between Rust threads while properly managing the GIL.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/parallelism.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nuse rayon::iter::{IntoParallelRefIterator, ParallelIterator};\n\n#[pyclass]\nstruct UserID {\n    id: i64,\n}\n\nlet allowed_ids: Vec<bool> = Python::with_gil(|outer_py| {\n    let instances: Vec<Py<UserID>> = (0..10).map(|x| Py::new(outer_py, UserID { id: x }).unwrap()).collect();\n    outer_py.allow_threads(|| {\n        instances.par_iter().map(|instance| {\n            Python::with_gil(|inner_py| {\n                instance.borrow(inner_py).id > 5\n            })\n        }).collect()\n    })\n});\nassert!(allowed_ids.into_iter().filter(|b| *b).count() == 4);\n```\n\n----------------------------------------\n\nTITLE: Converting Rust Future to Python Awaitable\nDESCRIPTION: Demonstrates how to convert a Rust future into a Python-awaitable object using pyo3_asyncio.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nasync fn rust_sleep() {\n    async_std::task::sleep(std::time::Duration::from_secs(1)).await;\n}\n\n#[pyfunction]\nfn call_rust_sleep(py: Python<'_>) -> PyResult<&Bound<'_, PyAny>> {\n    pyo3_asyncio::async_std::future_into_py(py, async move {\n        rust_sleep().await;\n        Ok(Python::with_gil(|py| py.None()))\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Base and Derived Classes in PyO3\nDESCRIPTION: Demonstrates how to create a base class and derived class using PyO3. The BaseClass has a simple constructor and method, while SubClass extends it and shows how to access the base class methods.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass(subclass)]\nstruct BaseClass {\n    val1: usize,\n}\n\n#[pymethods]\nimpl BaseClass {\n    #[new]\n    fn new() -> Self {\n        BaseClass { val1: 10 }\n    }\n\n    pub fn method1(&self) -> PyResult<usize> {\n        Ok(self.val1)\n    }\n}\n\n#[pyclass(extends=BaseClass, subclass)]\nstruct SubClass {\n    val2: usize,\n}\n\n#[pymethods]\nimpl SubClass {\n    #[new]\n    fn new() -> (Self, BaseClass) {\n        (SubClass { val2: 15 }, BaseClass::new())\n    }\n\n    fn method2(self_: PyRef<'_, Self>) -> PyResult<usize> {\n        let super_ = self_.as_super(); // Get &PyRef<BaseClass>\n        super_.method1().map(|x| x * self_.val2)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Documentation and Implementing Number Constructor\nDESCRIPTION: Complete implementation of the Number struct with documentation comments and the constructor method using the custom wrapping function for overflow handling.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\nuse pyo3::prelude::*;\n\nfn wrap(obj: &Bound<'_, PyAny>) -> PyResult<i32> {\n    let val = obj.call_method1(\"__and__\", (0xFFFFFFFF_u32,))?;\n    let val: u32 = val.extract()?;\n    Ok(val as i32)\n}\n\n/// Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought not.\n/// It's not a story C would tell you. It's a Rust legend.\n#[pyclass(module = \"my_module\")]\nstruct Number(i32);\n\n#[pymethods]\nimpl Number {\n    #[new]\n    fn new(#[pyo3(from_py_with = \"wrap\")] value: i32) -> Self {\n        Self(value)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for LangSmith in Shell\nDESCRIPTION: Shell commands to set environment variables for LangSmith tracing outside of LangChain.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nexport LANGSMITH_TRACING=\"true\";\nexport LANGSMITH_API_KEY=<YOUR-LANGSMITH-API-KEY>\n# export LANGSMITH_PROJECT=\"My Project Name\" #  Optional: \"default\" is used if not set\n# export LANGSMITH_ENDPOINT=https://api.smith.langchain.com # or your own server\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterator Protocol in PyO3\nDESCRIPTION: Demonstrates how to implement the iterator protocol in PyO3 by defining __iter__ and __next__ methods. This example shows a basic iterator that wraps a Rust iterator of PyObjects.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/protocols.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nuse std::sync::Mutex;\n\n#[pyclass]\nstruct MyIterator {\n    iter: Mutex<Box<dyn Iterator<Item = PyObject> + Send>>,\n}\n\n#[pymethods]\nimpl MyIterator {\n    fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {\n        slf\n    }\n    fn __next__(slf: PyRefMut<'_, Self>) -> Option<PyObject> {\n        slf.iter.lock().unwrap().next()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Numpy Arrays with orjson\nDESCRIPTION: Demonstrates how to serialize numpy arrays using orjson with the OPT_SERIALIZE_NUMPY option. This example shows serialization of a 2D integer array into JSON format.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, numpy\n>>> orjson.dumps(\n        numpy.array([[1, 2, 3], [4, 5, 6]]),\n        option=orjson.OPT_SERIALIZE_NUMPY,\n)\nb'[[1,2,3],[4,5,6]]'\n```\n\n----------------------------------------\n\nTITLE: Basic Exception Raising in PyO3\nDESCRIPTION: Example showing how to raise a ValueError exception from a Rust function using PyO3. The function checks if a number is positive and raises an error if negative.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/error-handling.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::exceptions::PyValueError;\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn check_positive(x: i32) -> PyResult<()> {\n    if x < 0 {\n        Err(PyValueError::new_err(\"x is negative\"))\n    } else {\n        Ok(())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting between Bound<'py, T> and Borrowed<'a, 'py, T> Smart Pointers in Rust\nDESCRIPTION: Demonstrates conversion between `Bound<'py, T>` and `Borrowed<'a, 'py, T>` smart pointer types using `as_borrowed()` method, with deref coercion from borrowed to bound, and reference count management with `to_owned()`.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet bound: Bound<'py, PyAny> = ...;\nlet borrowed: Borrowed<'_, 'py, PyAny> = bound.as_borrowed();\n\n// deref coercion\nlet bound: &Bound<'py, PyAny> = &borrowed;\n\n// create a new Bound by increase the Python reference count\nlet bound: Bound<'py, PyAny> = borrowed.to_owned();\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoPy<PyObject> for Custom Wrapper Types in PyO3\nDESCRIPTION: Demonstrates how to implement the IntoPy<PyObject> trait for custom wrapper types that map to Python objects without creating unique Python types. The example shows a simple wrapper that can be converted to a PyObject.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n# #[allow(dead_code)]\nstruct MyPyObjectWrapper(PyObject);\n\n#[allow(deprecated)]\nimpl IntoPy<PyObject> for MyPyObjectWrapper {\n    fn into_py(self, py: Python<'_>) -> PyObject {\n        self.0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FromPyObject Derivation with from_item_all\nDESCRIPTION: Demonstrates using #[pyo3(from_item_all)] to extract all fields using get_item method.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\n#[pyo3(from_item_all)]\nstruct RustyStruct {\n    foo: String,\n    bar: String,\n    #[pyo3(item(\"foobar\"))]\n    baz: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Iterator Implementation in PyO3\nDESCRIPTION: Examples showing different approaches to implementing Python iterators in Rust using PyO3, including basic iterator pattern, exception handling, and async iterators.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::iter::IterNextOutput;\n\n#[pyclass]\nstruct PyClassIter {\n    count: usize,\n}\n\n#[pymethods]\nimpl PyClassIter {\n    fn __next__(&mut self) -> IterNextOutput<usize, &'static str> {\n        if self.count < 5 {\n            self.count += 1;\n            IterNextOutput::Yield(self.count)\n        } else {\n            IterNextOutput::Return(\"done\")\n        }\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct PyClassIter {\n    count: usize,\n}\n\n#[pymethods]\nimpl PyClassIter {\n    fn __next__(&mut self) -> Option<usize> {\n        if self.count < 5 {\n            self.count += 1;\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::exceptions::PyStopIteration;\n\n#[pyclass]\nstruct PyClassIter {\n    count: usize,\n}\n\n#[pymethods]\nimpl PyClassIter {\n    fn __next__(&mut self) -> PyResult<usize> {\n        if self.count < 5 {\n            self.count += 1;\n            Ok(self.count)\n        } else {\n            Err(PyStopIteration::new_err(\"done\"))\n        }\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct PyClassAwaitable {\n    number: usize,\n}\n\n#[pymethods]\nimpl PyClassAwaitable {\n    fn __next__(&self) -> usize {\n        self.number\n    }\n\n    fn __await__(slf: Py<Self>) -> Py<Self> {\n        slf\n    }\n}\n\n#[pyclass]\nstruct PyClassAsyncIter {\n    number: usize,\n}\n\n#[pymethods]\nimpl PyClassAsyncIter {\n    fn __anext__(&mut self) -> PyClassAwaitable {\n        self.number += 1;\n        PyClassAwaitable {\n            number: self.number,\n        }\n    }\n\n    fn __aiter__(slf: Py<Self>) -> Py<Self> {\n        slf\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Naive Datetime as UTC in Python orjson\nDESCRIPTION: Illustrates the use of OPT_NAIVE_UTC option to serialize datetime objects without tzinfo as UTC. This option has no effect on datetime objects that already have tzinfo set.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, datetime\n>>> orjson.dumps(\n        datetime.datetime(1970, 1, 1, 0, 0, 0),\n    )\nb'\"1970-01-01T00:00:00\"'\n>>> orjson.dumps(\n        datetime.datetime(1970, 1, 1, 0, 0, 0),\n        option=orjson.OPT_NAIVE_UTC,\n    )\nb'\"1970-01-01T00:00:00+00:00\"'\n```\n\n----------------------------------------\n\nTITLE: Importing Python Modules with PyModule::import in Rust\nDESCRIPTION: Demonstrates how to import and use Python modules from Rust using PyO3's PyModule::import functionality. Shows accessing Python's builtin sum function as an example.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-from-rust/calling-existing-code.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nfn main() -> PyResult<()> {\n    Python::with_gil(|py| {\n        let builtins = PyModule::import(py, \"builtins\")?\n        let total: i32 = builtins\n            .getattr(\"sum\")?\n            .call1((vec![1, 2, 3],))?\n            .extract()?;\n        assert_eq!(total, 6);\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Async Function with Python Coroutine\nDESCRIPTION: Implementation of a Rust function that can await Python coroutines.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction]\nfn await_coro(coro: &Bound<'_, PyAny>>) -> PyResult<()> {\n    // convert the coroutine into a Rust future using the\n    // async_std runtime\n    let f = pyo3_asyncio::async_std::into_future(coro)?;\n\n    pyo3_asyncio::async_std::run_until_complete(coro.py(), async move {\n        // await the future\n        f.await?;\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PyO3 Macro Usage\nDESCRIPTION: Overview of the three main PyO3 macros used to create Python objects from Rust code. These macros enable creation of Python modules, functions, and classes with their associated methods.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/rust-from-python.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[pymodule]\n#[pyfunction]\n#[pyclass]\n```\n\n----------------------------------------\n\nTITLE: Implementing Unary Arithmetic Operations for Number Class\nDESCRIPTION: Implementation of unary operators (__pos__, __neg__, __abs__, __invert__) for the Number class. These operators handle operations like positive, negative, absolute value, and bitwise inversion.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymethods]\nimpl Number {\n    fn __pos__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {\n        slf\n    }\n\n    fn __neg__(&self) -> Self {\n        Self(-self.0)\n    }\n\n    fn __abs__(&self) -> Self {\n        Self(self.0.abs())\n    }\n\n    fn __invert__(&self) -> Self {\n        Self(!self.0)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting between Py<T> and Bound<'py, T> Smart Pointers in Rust\nDESCRIPTION: Shows how to convert between the `Py<T>` and `Bound<'py, T>` smart pointer types using `bind()`, `into_bound()`, `as_unbound()`, and `unbind()` methods.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet obj: Py<PyAny> = ...;\nlet bound: &Bound<'py, PyAny> = obj.bind(py);\nlet bound: Bound<'py, PyAny> = obj.into_bound(py);\n\nlet obj: &Py<PyAny> = bound.as_unbound();\nlet obj: Py<PyAny> = bound.unbind();\n```\n\n----------------------------------------\n\nTITLE: PyFn Shorthand Usage\nDESCRIPTION: Shows the simplified #[pyfn] syntax for defining Python functions directly within a module.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pymodule]\nfn my_extension(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    #[pyfn(m)]\n    fn double(x: usize) -> usize {\n        x * 2\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: FromPyObject for Tuple Structs\nDESCRIPTION: Shows how to derive FromPyObject for tuple structs that extract from Python tuples.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nstruct RustyTuple(String, String);\n```\n\n----------------------------------------\n\nTITLE: Traceable OpenAI Function\nDESCRIPTION: Demonstrates using the @traceable decorator with OpenAI chat completions for nested tracing.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom langsmith import traceable\n\n@traceable(name=\"Call OpenAI\")\ndef my_function(text: str):\n    return client.chat.completions.create(\n        model=\"gpt-4\",\n        messages=[{\"role\": \"user\", \"content\": f\"Say {text}\"}],\n    )\n\nmy_function(\"hello world\")\n```\n\n----------------------------------------\n\nTITLE: Basic PyO3 Type Extraction in Rust\nDESCRIPTION: Demonstrates basic usage of .extract() to convert a Python list into a Rust Vec<i32>.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet v: Vec<i32> = list.extract()?\n```\n\n----------------------------------------\n\nTITLE: Foreign Error Type Handling\nDESCRIPTION: Example demonstrating how to wrap and convert third-party error types for use with PyO3 using a newtype pattern.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/error-handling.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::exceptions::PyValueError;\n\nstruct MyOtherError(OtherError);\n\nimpl From<MyOtherError> for PyErr {\n    fn from(error: MyOtherError) -> Self {\n        PyValueError::new_err(error.0.message())\n    }\n}\n\nimpl From<OtherError> for MyOtherError {\n    fn from(other: OtherError) -> Self {\n        Self(other)\n    }\n}\n\n#[pyfunction]\nfn wrapped_get_x() -> Result<i32, MyOtherError> {\n    let x: i32 = get_x()?;\n    Ok(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Using OPT_SORT_KEYS in Python for Deterministic JSON Serialization\nDESCRIPTION: Demonstrates sorted key serialization in orjson using OPT_SORT_KEYS option for deterministic output. Shows performance comparison with other JSON libraries.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson\n>>> orjson.dumps({\"b\": 1, \"c\": 2, \"a\": 3})\nb'{\"b\":1,\"c\":2,\"a\":3}'\n>>> orjson.dumps({\"b\": 1, \"c\": 2, \"a\": 3}, option=orjson.OPT_SORT_KEYS)\nb'{\"a\":3,\"b\":1,\"c\":2}'\n```\n\n----------------------------------------\n\nTITLE: Implementing Computed Object Properties in Rust\nDESCRIPTION: This snippet shows how to implement computed object properties using #[getter] and #[setter] attributes. It allows for custom logic when getting or setting property values.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {\n    num: i32,\n}\n\n#[pymethods]\nimpl MyClass {\n    #[getter]\n    fn num(&self) -> PyResult<i32> {\n        Ok(self.num)\n    }\n\n    #[setter]\n    fn set_num(&mut self, value: i32) -> PyResult<()> {\n        self.num = value;\n        Ok(())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Python Expressions with eval in Rust\nDESCRIPTION: Shows how to evaluate Python expressions using PyO3's Python::eval method. Demonstrates list comprehension evaluation and result extraction.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-from-rust/calling-existing-code.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::ffi::c_str;\n\nPython::with_gil(|py| {\n    let result = py\n        .eval(c_str!(\"[i * 10 for i in range(5)]\"), None, None)\n        .map_err(|e| {\n            e.print_and_set_sys_last_vars(py);\n        })?;\n    let res: Vec<i64> = result.extract().unwrap();\n    assert_eq!(res, vec![0, 10, 20, 30, 40]);\n    Ok(())\n})\n```\n\n----------------------------------------\n\nTITLE: Complete Rust-Python bridging implementation\nDESCRIPTION: Full implementation showing how to expose a Rust trait to Python, including the Model trait definition, solve function wrapper, UserModel struct with PyMethods, and the implementation of the Model trait that handles Python interop with better error messages.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/trait-bounds.md#2025-04-22_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyList;\n\npub trait Model {\n    fn set_variables(&mut self, var: &Vec<f64>);\n    fn get_results(&self) -> Vec<f64>;\n    fn compute(&mut self);\n}\n\npub fn solve<T: Model>(model: &mut T) {\n    println!(\"Magic solver that mutates the model into a resolved state\");\n}\n\n#[pyfunction]\n#[pyo3(name = \"solve\")]\npub fn solve_wrapper(model: &mut UserModel) {\n    solve(model);\n}\n\n#[pyclass]\npub struct UserModel {\n    model: Py<PyAny>,\n}\n\n#[pymodule]\nfn trait_exposure(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<UserModel>()?;\n    m.add_function(wrap_pyfunction!(solve_wrapper, m)?)?;\n    Ok(())\n}\n\n#[pymethods]\nimpl UserModel {\n    #[new]\n    pub fn new(model: Py<PyAny>) -> Self {\n        UserModel { model }\n    }\n\n    pub fn set_variables(&mut self, var: Vec<f64>) {\n        println!(\"Set variables from Python calling Rust\");\n        Model::set_variables(self, &var)\n    }\n\n    pub fn get_results(&mut self) -> Vec<f64> {\n        println!(\"Get results from Python calling Rust\");\n        Model::get_results(self)\n    }\n\n    pub fn compute(&mut self) {\n        Model::compute(self)\n    }\n}\n\nimpl Model for UserModel {\n    fn set_variables(&mut self, var: &Vec<f64>) {\n        println!(\"Rust calling Python to set the variables\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"set_variables\", (PyList::new(py, var).unwrap(),), None)\n                .unwrap();\n        })\n    }\n\n    fn get_results(&self) -> Vec<f64> {\n        println!(\"Get results from Rust calling Python\");\n        Python::with_gil(|py| {\n            let py_result: Bound<'_, PyAny> = self\n                .model\n                .bind(py)\n                .call_method(\"get_results\", (), None)\n                .unwrap();\n\n            if py_result.get_type().name().unwrap() != \"list\" {\n                panic!(\n                    \"Expected a list for the get_results() method signature, got {}\",\n                    py_result.get_type().name().unwrap()\n                );\n            }\n            py_result.extract()\n        })\n        .unwrap()\n    }\n\n    fn compute(&mut self) {\n        println!(\"Rust calling Python to perform the computation\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"compute\", (), None)\n                .unwrap();\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FromPyObject Derivation for Basic Struct\nDESCRIPTION: Shows how to derive FromPyObject for a struct with a single string field, accessing Python object attributes.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nstruct RustyStruct {\n    my_string: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Unsafe Wrapping of Python Integers in Rust\nDESCRIPTION: An unsafe Rust function that wraps Python integers using the Python C API via PyO3's FFI. It handles the conversion of Python long objects to unsigned long values.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse std::os::raw::c_ulong;\nuse pyo3::prelude::*;\nuse pyo3::ffi;\n\nfn wrap(obj: &Bound<'_, PyAny>) -> Result<i32, PyErr> {\n    let py: Python<'_> = obj.py();\n\n    unsafe {\n        let ptr = obj.as_ptr();\n\n        let ret: c_ulong = ffi::PyLong_AsUnsignedLongMask(ptr);\n        if ret == c_ulong::MAX {\n            if let Some(err) = PyErr::take(py) {\n                return Err(err);\n            }\n        }\n\n        Ok(ret as i32)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Disabled PyO3 Function Signature in IPython\nDESCRIPTION: This text snippet demonstrates how the PyO3 function appears in IPython when the text signature is disabled. It shows that the __text_signature__ attribute is None and that IPython's help feature no longer displays a signature.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/signature.md#2025-04-22_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n>>> pyo3_test.add.__text_signature__ == None\nTrue\n>>> pyo3_test.add?\nDocstring: This function adds two unsigned 64-bit integers.\nType:      builtin_function_or_method\n```\n\n----------------------------------------\n\nTITLE: Implementing kwargs Dictionary in Rust with PyO3\nDESCRIPTION: Example showing how to create a Rust function that accepts arbitrary keyword arguments (kwargs) and returns their count using PyO3.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/signature.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\n\n#[pyfunction]\n#[pyo3(signature = (**kwds))]\nfn num_kwds(kwds: Option<&Bound<'_, PyDict>>) -> usize {\n    kwds.map_or(0, |dict| dict.len())\n}\n\n#[pymodule]\nfn module_with_functions(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(num_kwds, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Function Signatures with Text Signatures in PyO3\nDESCRIPTION: Demonstrates how to create a function with custom signature and text signature attributes for better Python integration.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/signature.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyfunction]\n#[pyo3(signature = (a, b=0, /), text_signature = \"(a, b=0, /)\")]\nfn add(a: u64, b: u64) -> u64 {\n    a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cancellable Coroutines in PyO3\nDESCRIPTION: An example of creating a cancellable async function in PyO3 that can respond to cancellation requests from Python. It uses the CancelHandle type to detect when a coroutine has been cancelled.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/async-await.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\n# #[cfg(feature = \"experimental-async\")] {\nuse futures::FutureExt;\nuse pyo3::prelude::*;\nuse pyo3::coroutine::CancelHandle;\n\n#[pyfunction]\nasync fn cancellable(#[pyo3(cancel_handle)] mut cancel: CancelHandle) {\n    futures::select! {\n        /* _ = ... => println!(\"done\"), */\n        _ = cancel.cancelled().fuse() => println!(\"cancelled\"),\n    }\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: PyO3 Asyncio Main Function Example\nDESCRIPTION: Complete example of PyO3 initialization with async-std runtime and Python integration.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyo3_asyncio::async_std::main]\nasync fn main() -> PyResult<()> {\n    // PyO3 is initialized - Ready to go\n\n    let fut = Python::with_gil(|py| -> PyResult<_> {\n        let asyncio = py.import(\"asyncio\")?;\n\n        // convert asyncio.sleep into a Rust Future\n        pyo3_asyncio::async_std::into_future(\n            asyncio.call_method1(\"sleep\", (1.into_py(py),))?\n        )\n    })?;\n\n    fut.await?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Tracing with LangSmith\nDESCRIPTION: TypeScript code showing how to create nested traces using LangSmith's traceable function with OpenAI SDK.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst nestedTrace = traceable(async (text: string) => {\n  const completion = await openai.chat.completions.create({\n    model: \"gpt-3.5-turbo\",\n    messages: [{ content: text, role: \"user\" }],\n  });\n  return completion;\n});\n\nawait nestedTrace(\"Why is the sky blue?\");\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Python Class Objects with PyO3 in Rust\nDESCRIPTION: Demonstrates how to create Python class objects in Rust using PyO3, showing the definition of a class and the implementation of an Object wrapper that safely manages Python objects with proper GIL handling.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct SomeClass {}\n\nstruct Object {\n    object: Py<SomeClass>,\n}\n\nimpl Object {\n    fn new(py: Python<'_>) -> Self {\n        let object = Py::new(py, SomeClass {}).unwrap();\n\n        Self { object }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Instance Methods for Python Classes in Rust\nDESCRIPTION: This example demonstrates how to define instance methods for Python classes using the #[pymethods] attribute. It shows both read-only and mutable methods.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {\n    num: i32,\n}\n\n#[pymethods]\nimpl MyClass {\n    fn method1(&self) -> PyResult<i32> {\n        Ok(10)\n    }\n\n    fn set_method(&mut self, value: i32) -> PyResult<()> {\n        self.num = value;\n        Ok(())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Exception with Context\nDESCRIPTION: Shows a complete example of creating and using a custom exception type with Python context verification.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/exception.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::create_exception;\nuse pyo3::types::IntoPyDict;\nuse pyo3::exceptions::PyException;\n\ncreate_exception!(mymodule, CustomError, PyException);\n\n# fn main() -> PyResult<()> {\nPython::with_gil(|py| {\n    let ctx = [(\"CustomError\", py.get_type::<CustomError>())].into_py_dict(py)?;\n    pyo3::py_run!(\n        py,\n        *ctx,\n        \"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\"\n    );\n    pyo3::py_run!(py, *ctx, \"assert CustomError('oops').args == ('oops',)\");\n#   Ok(())\n})\n# }\n```\n\n----------------------------------------\n\nTITLE: Testing PyO3 Module\nDESCRIPTION: Commands for building and testing the PyO3 module in Python\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/getting-started.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ maturin develop\n# lots of progress output as maturin runs the compilation...\n$ python\n>>> import pyo3_example\n>>> pyo3_example.sum_as_string(5, 20)\n'25'\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Python Function with PythonREPL\nDESCRIPTION: This snippet shows how to define a Python function and call it using PythonREPL. It demonstrates function definition, execution, and showcases how the output is returned as a string.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function-calls.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain.tools import PythonREPL\n\nrepl = PythonREPL()\nrepl.run(\"\"\"\ndef add(a, b):\n    return a + b\n\nresult = add(1, 2)\nprint(result)\n\"\"\")\n# Output: '3\\n'\n```\n\n----------------------------------------\n\nTITLE: Adding PyO3 Class to Python Module\nDESCRIPTION: Example showing how to add a PyO3 class to a Python module using the module initializer.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[pymodule]\nfn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<Number>()?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Thread-Safe Class Using Mutex Locks in PyO3\nDESCRIPTION: An implementation using Mutex locks to synchronize access to shared data. This approach ensures thread safety by making threads wait for exclusive access to the data using a mutex lock.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/thread-safety.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\nuse std::sync::Mutex;\n\nstruct MyClassInner {\n    x: i32,\n    y: i32,\n}\n\n#[pyclass(frozen)]\nstruct MyClass {\n    inner: Mutex<MyClassInner>\n}\n\n#[pymethods]\nimpl MyClass {\n    fn get_x(&self) -> i32 {\n        self.inner.lock().expect(\"lock not poisoned\").x\n    }\n\n    fn set_y(&self, value: i32) {\n        self.inner.lock().expect(\"lock not poisoned\").y = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Python-compatible Number Class in Rust with PyO3\nDESCRIPTION: This code snippet defines a Number struct in Rust that wraps an i32 value and implements various Python special methods using the PyO3 library. It includes implementations for __repr__, __str__, __hash__, __richcmp__, and __bool__, making it fully compatible with Python operations.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\nuse pyo3::prelude::*;\nuse pyo3::class::basic::CompareOp;\nuse pyo3::types::PyString;\n\n#[pyclass]\nstruct Number(i32);\n\n#[pymethods]\nimpl Number {\n    #[new]\n    fn new(value: i32) -> Self {\n        Self(value)\n    }\n\n    fn __repr__(slf: &Bound<'_, Self>) -> PyResult<String> {\n        let class_name: Bound<'_, PyString> = slf.get_type().qualname()?;\n        Ok(format!(\"{}({})\", class_name, slf.borrow().0))\n    }\n\n    fn __str__(&self) -> String {\n        self.0.to_string()\n    }\n\n    fn __hash__(&self) -> u64 {\n        let mut hasher = DefaultHasher::new();\n        self.0.hash(&mut hasher);\n        hasher.finish()\n    }\n\n    fn __richcmp__(&self, other: &Self, op: CompareOp) -> PyResult<bool> {\n        match op {\n            CompareOp::Lt => Ok(self.0 < other.0),\n            CompareOp::Le => Ok(self.0 <= other.0),\n            CompareOp::Eq => Ok(self.0 == other.0),\n            CompareOp::Ne => Ok(self.0 != other.0),\n            CompareOp::Gt => Ok(self.0 > other.0),\n            CompareOp::Ge => Ok(self.0 >= other.0),\n        }\n    }\n\n    fn __bool__(&self) -> bool {\n        self.0 != 0\n    }\n}\n\n#[pymodule]\nfn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<Number>()?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Thread-Safe Class with Runtime Checks in PyO3\nDESCRIPTION: A simple class that uses PyO3's default interior mutability pattern to provide thread safety with runtime checking for concurrent access. This approach automatically handles thread safety but may produce runtime errors if concurrent access occurs.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/thread-safety.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {\n    x: i32,\n    y: i32,\n}\n\n#[pymethods]\nimpl MyClass {\n    fn get_x(&self) -> i32 {\n        self.x\n    }\n\n    fn set_y(&mut self, value: i32) {\n        self.y = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Number Class in Python\nDESCRIPTION: Example Python code showing how to use the Number class to implement a string hashing algorithm (djb2) that relies on integer wrapping behavior.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom my_module import Number\n\ndef hash_djb2(s: str):\n\t'''\n\tA version of Daniel J. Bernstein's djb2 string hashing algorithm\n\tLike many hashing algorithms, it relies on integer wrapping.\n\t'''\n\n\tn = Number(0)\n\tfive = Number(5)\n\n\tfor x in s:\n\t\tn = Number(ord(x)) + ((n << five) - n)\n\treturn n\n\nassert hash_djb2('l50_50') == Number(-1152549421)\n```\n\n----------------------------------------\n\nTITLE: Thread-safe Word Count Implementation with GIL Release\nDESCRIPTION: Implementation that allows parallel execution by releasing the Python GIL using Python::allow_threads.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/parallelism.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction]\nfn search_sequential_allow_threads(py: Python<'_>, contents: &str, needle: &str) -> usize {\n    py.allow_threads(|| search_sequential(contents, needle))\n}\n```\n\n----------------------------------------\n\nTITLE: Package Installation Commands\nDESCRIPTION: Various commands for installing maturin package manager using different Python package management tools\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/getting-started.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install maturin --user\n```\n\nLANGUAGE: bash\nCODE:\n```\npipx install maturin\n```\n\nLANGUAGE: bash\nCODE:\n```\npyenv activate pyo3\npip install maturin\n```\n\nLANGUAGE: bash\nCODE:\n```\npoetry add -G dev maturin\n```\n\n----------------------------------------\n\nTITLE: Serde Serialization Example for PyO3\nDESCRIPTION: Example showing how to use serde serialization with PyO3 using the serde feature to handle Py<T> objects\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/features.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(feature = \"serde\")]\n# #[allow(dead_code)]\n# mod serde_only {\n# use pyo3::prelude::*;\n```\n\n----------------------------------------\n\nTITLE: Automatic __str__ Generation Using Display Trait\nDESCRIPTION: Demonstrates how to automatically generate __str__ implementation for a class by using the Display trait and the str attribute in the pyclass macro.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use std::fmt::{Display, Formatter};\n# use pyo3::prelude::*;\n#\n# #[allow(dead_code)]\n# #[pyclass(str)]\n# struct Coordinate {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nimpl Display for Coordinate {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"({}, {}, {})\", self.x, self.y, self.z)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pretty-printing JSON with 2-space Indentation using Python orjson\nDESCRIPTION: Shows how to use OPT_INDENT_2 option for pretty-printing JSON output with 2-space indentation. This option is compatible with all other options and is faster than pretty-printing in other libraries.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson\n>>> orjson.dumps({\"a\": \"b\", \"c\": {\"d\": True}, \"e\": [1, 2]})\nb'{\"a\":\"b\",\"c\":{\"d\":true},\"e\":[1,2]}'\n>>> orjson.dumps(\n    {\"a\": \"b\", \"c\": {\"d\": True}, \"e\": [1, 2]},\n    option=orjson.OPT_INDENT_2\n)\nb'{\\n  \"a\": \"b\",\\n  \"c\": {\\n    \"d\": true\\n  },\\n  \"e\": [\\n    1,\\n    2\\n  ]\\n}'\n```\n\n----------------------------------------\n\nTITLE: Python Submodule Creation in Rust\nDESCRIPTION: Demonstrates creating hierarchical module structures with submodules using PyO3. Shows parent and child module relationships.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/module.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pymodule]\nfn parent_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    register_child_module(m)?;\n    Ok(())\n}\n\nfn register_child_module(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {\n    let child_module = PyModule::new(parent_module.py(), \"child_module\")?;\n    child_module.add_function(wrap_pyfunction!(func, &child_module)?)?;\n    parent_module.add_submodule(&child_module)\n}\n\n#[pyfunction]\nfn func() -> String {\n    \"func\".to_string()\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Enum Variant Constructors in PyO3\nDESCRIPTION: Shows how to customize the constructors for enum variants using the #[pyo3(constructor = (...))] attribute. This allows defining custom parameter signatures, default values, and required parameters for each variant.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n#[pyclass]\nenum Shape {\n    #[pyo3(constructor = (radius=1.0))]\n    Circle { radius: f64 },\n    #[pyo3(constructor = (*, width, height))]\n    Rectangle { width: f64, height: f64 },\n    #[pyo3(constructor = (side_count, radius=1.0))]\n    RegularPolygon { side_count: u32, radius: f64 },\n    Nothing { },\n}\n\n#[cfg(Py_3_10)]\nPython::with_gil(|py| {\n    let cls = py.get_type::<Shape>();\n    pyo3::py_run!(py, cls, r#\"\n        circle = cls.Circle()\n        assert isinstance(circle, cls)\n        assert isinstance(circle, cls.Circle)\n        assert circle.radius == 1.0\n\n        square = cls.Rectangle(width = 1, height = 1)\n        assert isinstance(square, cls)\n        assert isinstance(square, cls.Rectangle)\n        assert square.width == 1\n        assert square.height == 1\n\n        hexagon = cls.RegularPolygon(6)\n        assert isinstance(hexagon, cls)\n        assert isinstance(hexagon, cls.RegularPolygon)\n        assert hexagon.side_count == 6\n        assert hexagon.radius == 1\n    \"#)\n})\n```\n\n----------------------------------------\n\nTITLE: Instructor Integration Setup\nDESCRIPTION: Shows how to integrate Instructor with the wrapped OpenAI client.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport instructor\n\nclient = instructor.patch(OpenAI())\n```\n\n----------------------------------------\n\nTITLE: PyO3 Add Function with Lifetime Parameters\nDESCRIPTION: Example of a function using PyO3's Bound smart pointer with explicit lifetime parameters to handle Python's addition operation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn add<'py>(\n    left: &Bound<'py, PyAny>,\n    right: &Bound<'py, PyAny>,\n) -> PyResult<Bound<'py, PyAny>> {\n    left.add(right)\n}\n```\n\n----------------------------------------\n\nTITLE: String Representation for PyO3 Enums\nDESCRIPTION: This snippet demonstrates how PyO3 provides automatic string representation for enum variants when used in Python, showing the default representation format.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(eq, eq_int)]\n#[derive(PartialEq)]\nenum MyEnum{\n    Variant,\n    OtherVariant,\n}\n\nPython::with_gil(|py| {\n    let cls = py.get_type::<MyEnum>();\n    let x = Py::new(py, MyEnum::Variant).unwrap();\n    pyo3::py_run!(py, cls x, r#\"\n        assert repr(x) == 'MyEnum.Variant'\n        assert repr(cls.OtherVariant) == 'MyEnum.OtherVariant'\n    \"#)\n})\n```\n\n----------------------------------------\n\nTITLE: Reference Pool Management in PyO3\nDESCRIPTION: Examples of proper reference management when using PyO3 with disabled reference pool. Shows how to safely handle object cleanup to avoid aborts or memory leaks.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/performance.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet numbers: Py<PyList> = Python::with_gil(|py| PyList::empty(py).unbind());\n\nPython::with_gil(|py| {\n    numbers.bind(py).append(23).unwrap();\n});\n\nPython::with_gil(|py| {\n    numbers.bind(py).append(42).unwrap();\n});\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet numbers: Py<PyList> = Python::with_gil(|py| PyList::empty(py).unbind());\n\nPython::with_gil(|py| {\n    numbers.bind(py).append(23).unwrap();\n});\n\nPython::with_gil(|py| {\n    numbers.bind(py).append(42).unwrap();\n});\n\nPython::with_gil(move |py| {\n    drop(numbers);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoPy for Python Object Conversion\nDESCRIPTION: Implementation of the IntoPy trait that allows converting MyClass instances into Python objects. This enables returning MyClass instances from Rust functions to Python code.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(deprecated)]\nimpl pyo3::IntoPy<PyObject> for MyClass {\n    fn into_py(self, py: pyo3::Python<'_>) -> pyo3::PyObject {\n        pyo3::IntoPy::into_py(pyo3::Py::new(py, self).unwrap(), py)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Arguments in PyO3\nDESCRIPTION: Shows how to implement a function with optional arguments using Option<T> in Rust with PyO3.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/signature.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(deprecated)]\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn increment(x: u64, amount: Option<u64>) -> u64 {\n    x + amount.unwrap_or(1)\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Named Python Module in Rust\nDESCRIPTION: Shows how to create a Python module with a custom name using the pyo3 name attribute. Demonstrates overriding the default module name.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/module.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn double(x: usize) -> usize {\n    x * 2\n}\n\n#[pymodule(name = \"custom_name\")]\nfn my_extension(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(double, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Python to Rust Logging with pyo3-pylogger\nDESCRIPTION: Shows how to configure Python logging to send messages to Rust's logging system using pyo3-pylogger. Includes initialization of both Rust and Python loggers and demonstrates logging from both languages.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/logging.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse log::{info, warn};\nuse pyo3::prelude::*;\n\nfn main() -> PyResult<()> {\n    // register the host handler with python logger, providing a logger target\n    // set the name here to something appropriate for your application\n    pyo3_pylogger::register(\"example_application_py_logger\");\n\n    // initialize up a logger\n    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(\"trace\")).init();\n\n    // Log some messages from Rust.\n    info!(\"Just some normal information!\");\n    warn!(\"Something spooky happened!\");\n\n    // Log some messages from Python\n    Python::with_gil(|py| {\n        py.run(\n            \"\nimport logging\nlogging.error('Something bad happened')\n\",\n            None,\n            None,\n        )\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Exception to Python Module\nDESCRIPTION: Example of adding a custom exception to a Python extension module for Python importability.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/exception.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::exceptions::PyException;\n\npyo3::create_exception!(mymodule, CustomError, PyException);\n\n#[pymodule]\nfn mymodule(py: Python<'_>, m: &Bound<'_, PyModule>) -> PyResult<()> {\n    // ... other elements added to module ...\n    m.add(\"CustomError\", py.get_type::<CustomError>())?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Casting to Custom PyClass Types in PyO3 with Rust\nDESCRIPTION: Demonstrates how to downcast Python objects to custom `#[pyclass]` types in Rust using the `downcast()` and `downcast_into()` methods, which work on types implementing the `PyTypeCheck` trait.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {}\n\n# fn example<'py>(py: Python<'py>) -> PyResult<()> {\n// create a new Python `tuple`, and use `.into_any()` to erase the type\nlet obj: Bound<'py, PyAny> = Bound::new(py, MyClass {})?.into_any();\n\n// use `.downcast()` to cast to `MyClass` without transferring ownership\nlet _: &Bound<'py, MyClass> = obj.downcast()?;\n\n// use `.downcast_into()` to cast to `MyClass` with transfer of ownership\nlet _: Bound<'py, MyClass> = obj.downcast_into()?;\n# Ok(())\n# }\n# Python::with_gil(example).unwrap()\n```\n\n----------------------------------------\n\nTITLE: Declarative Module Definition in Rust\nDESCRIPTION: Shows the declarative syntax for defining Python modules using Rust inline modules. Includes functions, classes, and submodules.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/module.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn double(x: usize) -> usize {\n    x * 2\n}\n\n#[pymodule]\nmod my_extension {\n    use super::*;\n\n    #[pymodule_export]\n    use super::double;\n\n    #[pyfunction]\n    fn triple(x: usize) -> usize {\n        x * 3\n    }\n\n    #[pyclass]\n    struct Unit;\n\n    #[pymodule]\n    mod submodule {\n    }\n\n    #[pymodule_init]\n    fn init(m: &Bound<'_, PyModule>) -> PyResult<()> {\n        m.add(\"double2\", m.getattr(\"double\")?)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: PyO3 List Operations without Type Annotations\nDESCRIPTION: Rust implementation using PyO3's smart pointers without explicit type annotations, showing more concise code while maintaining the same functionality.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyList;\n\nfn example(py: Python<'_>) -> PyResult<()> {\n    let x = PyList::empty(py);\n    x.append(1)?;\n    let y = x.clone();\n    drop(x);\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating #[pyclass] and #[pyo3] Attribute Usage in Rust\nDESCRIPTION: This snippet shows two equivalent ways of applying parameters to a PyO3 class: directly in the #[pyclass] attribute, and as separate #[pyo3] attributes. It demonstrates how to set the class name and enable subclassing.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/pyclass-parameters.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Argument supplied directly to the `#[pyclass]` annotation.\n#[pyclass(name = \"SomeName\", subclass)]\nstruct MyClass {}\n\n// Argument supplied as a separate annotation.\n#[pyclass]\n#[pyo3(name = \"SomeName\", subclass)]\nstruct MyClass {}\n```\n\n----------------------------------------\n\nTITLE: Module Attribution for Python Classes in Rust\nDESCRIPTION: Demonstrates how module attributes are automatically set for Python classes in nested modules.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/module.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct Ext;\n\n#[pymodule]\nmod my_extension {\n    use super::*;\n\n    #[pymodule_export]\n    use super::Ext;\n\n    #[pymodule]\n    mod submodule {\n        use super::*;\n\n        #[pyclass]\n        struct Unit;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Python Method Wrappers in Rust\nDESCRIPTION: Implementation of Python-compatible method wrappers for the UserModel with proper type conversion.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/trait-bounds.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl UserModel {\n    pub fn set_variables(&mut self, var: Vec<f64>) {\n        println!(\"Set variables from Python calling Rust\");\n        Model::set_variables(self, &var)\n    }\n\n    pub fn get_results(&mut self) -> Vec<f64> {\n        println!(\"Get results from Python calling Rust\");\n        Model::get_results(self)\n    }\n\n    pub fn compute(&mut self) {\n        println!(\"Compute from Python calling Rust\");\n        Model::compute(self)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Enum with Representation in PyO3\nDESCRIPTION: Demonstrates how to create a basic enum with custom string representation in Python using PyO3. The enum has a single variant 'Answer' with a value of 42 and implements __repr__ to return the string '42'.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n#[pyclass(eq, eq_int)]\n#[derive(PartialEq)]\nenum MyEnum {\n    Answer = 42,\n}\n\n#[pymethods]\nimpl MyEnum {\n    fn __repr__(&self) -> &'static str {\n        \"42\"\n    }\n}\n\nPython::with_gil(|py| {\n    let cls = py.get_type::<MyEnum>();\n    pyo3::py_run!(py, cls, \"assert repr(cls.Answer) == '42'\")\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Rust to Python Logging with pyo3-log\nDESCRIPTION: Demonstrates how to configure Rust logging to send messages to Python's logging system using pyo3-log. Shows the setup of a Python module with a logging function and the necessary initialization of the logger.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/logging.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse log::info;\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn log_something() {\n    // This will use the logger installed in `my_module` to send the `info`\n    // message to the Python logging facilities.\n    info!(\"Something!\");\n}\n\n#[pymodule]\nfn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    // A good place to install the Rust -> Python logger.\n    pyo3_log::init();\n\n    m.add_function(wrap_pyfunction!(log_something, m)?)?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Python Asyncio.run Usage Example\nDESCRIPTION: Demonstrates correct usage of asyncio.run with PyO3 async functions.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nfrom my_async_module import rust_sleep\n\nasync def main():\n    await rust_sleep()\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing an Async Sleep Function in PyO3\nDESCRIPTION: An example of an async function in Rust exposed to Python, which sleeps for a specified duration and returns an optional result. The function creates a oneshot channel and spawns a thread to wait for the specified duration.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/async-await.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\n# #[cfg(feature = \"experimental-async\")] {\nuse std::{thread, time::Duration};\nuse futures::channel::oneshot;\nuse pyo3::prelude::*;\n\n#[pyfunction]\n#[pyo3(signature=(seconds, result=None))]\nasync fn sleep(seconds: f64, result: Option<PyObject>) -> Option<PyObject> {\n    let (tx, rx) = oneshot::channel();\n    thread::spawn(move || {\n        thread::sleep(Duration::from_secs_f64(seconds));\n        tx.send(()).unwrap();\n    });\n    rx.await.unwrap();\n    result\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Automatic Implementation of __hash__ Using Rust's Hash Trait\nDESCRIPTION: Demonstrates how to automatically implement __hash__ for a frozen class using the hash attribute and Hash trait derivation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#\n# #[allow(dead_code)]\n#[pyclass(frozen, eq, hash)]\n#[derive(PartialEq, Hash)]\nstruct Number(i32);\n```\n\n----------------------------------------\n\nTITLE: Customizing Dataclass Serialization in Python orjson\nDESCRIPTION: Illustrates the use of OPT_PASSTHROUGH_DATACLASS option to pass dataclass instances to a custom default function for serialization. This allows for customized output but is slower than the default serialization.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, dataclasses\n>>>\n@dataclasses.dataclass\nclass User:\n    id: str\n    name: str\n    password: str\n\ndef default(obj):\n    if isinstance(obj, User):\n        return {\"id\": obj.id, \"name\": obj.name}\n    raise TypeError\n\n>>> orjson.dumps(User(\"3b1\", \"asd\", \"zxc\"))\nb'{\"id\":\"3b1\",\"name\":\"asd\",\"password\":\"zxc\"}'\n>>> orjson.dumps(User(\"3b1\", \"asd\", \"zxc\"), option=orjson.OPT_PASSTHROUGH_DATACLASS)\nTypeError: Type is not JSON serializable: User\n>>> orjson.dumps(\n        User(\"3b1\", \"asd\", \"zxc\"),\n        option=orjson.OPT_PASSTHROUGH_DATACLASS,\n        default=default,\n    )\nb'{\"id\":\"3b1\",\"name\":\"asd\"}'\n```\n\n----------------------------------------\n\nTITLE: Optimizing GIL Token Access in PyO3\nDESCRIPTION: Shows how to efficiently access the GIL token when implementing traits. Demonstrates avoiding unnecessary Python::with_gil calls by using the implicit GIL access available through Bound references.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/performance.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl PartialEq<Foo> for FooBound<'_> {\n    fn eq(&self, other: &Foo) -> bool {\n        Python::with_gil(|py| {\n            let len = other.0.bind(py).len();\n            self.0.len() == len\n        })\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nimpl PartialEq<Foo> for FooBound<'_> {\n    fn eq(&self, other: &Foo) -> bool {\n        // Access to `&Bound<'py, PyAny>` implies access to `Python<'py>`.\n        let py = self.0.py();\n        let len = other.0.bind(py).len();\n        self.0.len() == len\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Rust Future\nDESCRIPTION: Shows how to create a Rust future from an async function.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet future = rust_sleep();\n```\n\n----------------------------------------\n\nTITLE: Disabling Python's Default Hash in PyO3\nDESCRIPTION: Demonstrates how to disable the default hash implementation for a PyO3 class by setting __hash__ to None. This is equivalent to making a class unhashable in pure Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/protocols.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct NotHashable {}\n\n#[pymethods]\nimpl NotHashable {\n    #[classattr]\n    const __hash__: Option<PyObject> = None;\n}\n```\n\n----------------------------------------\n\nTITLE: Python Model Class Implementation\nDESCRIPTION: Python class implementing the methods required by the Rust Model trait.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/trait-bounds.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Model:\n    def set_variables(self, inputs):\n        self.inputs = inputs\n    def compute(self):\n        self.results = [elt**2 - 3 for elt in self.inputs]\n    def get_results(self):\n        return self.results\n```\n\n----------------------------------------\n\nTITLE: Using Orjson Fragment for Pre-serialized JSON\nDESCRIPTION: Shows how to include pre-serialized JSON using orjson.Fragment without requiring deserialization.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson\n>>> orjson.dumps({\"key\": \"zxc\", \"data\": orjson.Fragment(b'{\"a\": \"b\", \"c\": 1}')})\nb'{\"key\":\"zxc\",\"data\":{\"a\": \"b\", \"c\": 1}}'\n```\n\n----------------------------------------\n\nTITLE: Improved Rust implementation with better error handling\nDESCRIPTION: Enhanced implementation that checks the Python return type before performing the conversion, providing more helpful error messages to Python users when type mismatches occur.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/trait-bounds.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nimpl Model for UserModel {\n    fn get_results(&self) -> Vec<f64> {\n        println!(\"Get results from Rust calling Python\");\n        Python::with_gil(|py| {\n            let py_result: Bound<'_, PyAny> = self\n                .model\n                .bind(py)\n                .call_method(\"get_results\", (), None)\n                .unwrap();\n\n            if py_result.get_type().name().unwrap() != \"list\" {\n                panic!(\n                    \"Expected a list for the get_results() method signature, got {}\",\n                    py_result.get_type().name().unwrap()\n                );\n            }\n            py_result.extract()\n        })\n        .unwrap()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Python Exception in Rust\nDESCRIPTION: Demonstrates how to create a new Python exception type using the create_exception! macro in PyO3.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/exception.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::create_exception;\n\ncreate_exception!(module, MyError, pyo3::exceptions::PyException);\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of __hash__ Method\nDESCRIPTION: Shows how to implement the __hash__ special method for a class using Rust's DefaultHasher and Hash trait.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::hash_map::DefaultHasher;\n\n// Required to call the `.hash` and `.finish` methods, which are defined on traits.\nuse std::hash::{Hash, Hasher};\n\n# use pyo3::prelude::*;\n#\n# #[allow(dead_code)]\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymethods]\nimpl Number {\n    fn __hash__(&self) -> u64 {\n        let mut hasher = DefaultHasher::new();\n        self.0.hash(&mut hasher);\n        hasher.finish()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: PyO3 Module and Constructor Implementation\nDESCRIPTION: Rust code for exposing the UserModel to Python with PyO3 annotations and constructor.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/trait-bounds.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct UserModel {\n    model: Py<PyAny>,\n}\n\n#[pymodule]\nfn trait_exposure(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<UserModel>()?;\n    Ok(())\n}\n\n#[pymethods]\nimpl UserModel {\n    #[new]\n    pub fn new(model: Py<PyAny>) -> Self {\n        UserModel { model }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using OnceExt for Thread-Safe Single Initialization in Rust with PyO3\nDESCRIPTION: This code snippet shows how to use the OnceExt trait from PyO3 to perform thread-safe single initialization of a runtime cache holding a Py<PyDict>. It demonstrates the use of call_once_py_attached to ensure the initialization function is called exactly once.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/free-threading.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Once;\nuse pyo3::sync::OnceExt;\nuse pyo3::types::PyDict;\n\nstruct RuntimeCache {\n    once: Once,\n    cache: Option<Py<PyDict>>\n}\n\nlet mut cache = RuntimeCache {\n    once: Once::new(),\n    cache: None\n};\n\nPython::with_gil(|py| {\n    // guaranteed to be called once and only once\n    cache.once.call_once_py_attached(py, || {\n        cache.cache = Some(PyDict::new(py).unbind());\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Testing a PyO3 Project with Maturin\nDESCRIPTION: Bash commands for setting up a new PyO3 project using maturin. Creates a new package, sets up a Python virtual environment, initializes a PyO3 project, and demonstrates building and testing the module in Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# (replace string_sum with the desired package name)\n$ mkdir string_sum\n$ cd string_sum\n$ python -m venv .env\n$ source .env/bin/activate\n$ pip install maturin\n```\n\n----------------------------------------\n\nTITLE: Implementing String Representations with __repr__ and __str__\nDESCRIPTION: Adds custom string representations to the Number class using __repr__ and __str__ methods, improving its display in Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymethods]\nimpl Number {\n    // For `__repr__` we want to return a string that Python code could use to recreate\n    // the `Number`, like `Number(5)` for example.\n    fn __repr__(&self) -> String {\n        // We use the `format!` macro to create a string. Its first argument is a\n        // format string, followed by any number of parameters which replace the\n        // `{}`'s in the format string.\n        //\n        //                        Tuple field access in Rust uses a dot\n        format!(\"Number({})\", self.0)\n    }\n    // `__str__` is generally used to create an \"informal\" representation, so we\n    // just forward to `i32`'s `ToString` trait implementation to print a bare number.\n    fn __str__(&self) -> String {\n        self.0.to_string()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Python Class with Reference Handling in PyO3 (Rust)\nDESCRIPTION: This snippet demonstrates defining a Python class with PyO3 and different ways to handle references to Python objects. It shows various function patterns for borrowing, mutating, and referencing PyO3 class instances.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct MyClass {\n    my_field: i32,\n}\n\n// Take a reference when the underlying `Bound` is irrelevant.\n#[pyfunction]\nfn increment_field(my_class: &mut MyClass) {\n    my_class.my_field += 1;\n}\n\n// Take a reference wrapper when borrowing should be automatic,\n// but interaction with the underlying `Bound` is desired.\n#[pyfunction]\nfn print_field(my_class: PyRef<'_, MyClass>) {\n    println!(\"{}\", my_class.my_field);\n}\n\n// Take a reference to the underlying Bound\n// when borrowing needs to be managed manually.\n#[pyfunction]\nfn increment_then_print_field(my_class: &Bound<'_, MyClass>) {\n    my_class.borrow_mut().my_field += 1;\n\n    println!(\"{}\", my_class.borrow().my_field);\n}\n\n// Take a GIL-indepedent reference when you want to store the reference elsewhere.\n#[pyfunction]\nfn print_refcnt(my_class: Py<MyClass>, py: Python<'_>) {\n    println!(\"{}\", my_class.get_refcnt(py));\n}\n```\n\n----------------------------------------\n\nTITLE: Instructor Model Example\nDESCRIPTION: Demonstrates using Instructor with Pydantic models for structured outputs.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass UserDetail(BaseModel):\n    name: str\n    age: int\n\n\nuser = client.chat.completions.create(\n    model=\"gpt-3.5-turbo\",\n    response_model=UserDetail,\n    messages=[\n        {\"role\": \"user\", \"content\": \"Extract Jason is 25 years old\"},\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Casting Between Python Types with PyO3 in Rust\nDESCRIPTION: Shows how to cast between different Python types in Rust using the `downcast()` and `downcast_into()` methods for both library types like PyTuple and custom `#[pyclass]` types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::types::PyTuple;\n# fn example<'py>(py: Python<'py>) -> PyResult<()> {\n// create a new Python `tuple`, and use `.into_any()` to erase the type\nlet obj: Bound<'py, PyAny> = PyTuple::empty(py).into_any();\n\n// use `.downcast()` to cast to `PyTuple` without transferring ownership\nlet _: &Bound<'py, PyTuple> = obj.downcast()?;\n\n// use `.downcast_into()` to cast to `PyTuple` with transfer of ownership\nlet _: Bound<'py, PyTuple> = obj.downcast_into()?;\n# Ok(())\n# }\n# Python::with_gil(example).unwrap()\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of IntoPyObject in Rust\nDESCRIPTION: This example demonstrates how to manually implement the IntoPyObject trait for a custom type when the derive macro is not suitable. It includes implementations for both owned and referenced types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# #[allow(dead_code)]\nstruct MyPyObjectWrapper(PyObject);\n\nimpl<'py> IntoPyObject<'py> for MyPyObjectWrapper {\n    type Target = PyAny; // the Python type\n    type Output = Bound<'py, Self::Target>; // in most cases this will be `Bound`\n    type Error = std::convert::Infallible; // the conversion error type, has to be convertable to `PyErr`\n\n    fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {\n        Ok(self.0.into_bound(py))\n    }\n}\n\n// equivalent to former `ToPyObject` implementations\nimpl<'a, 'py> IntoPyObject<'py> for &'a MyPyObjectWrapper {\n    type Target = PyAny;\n    type Output = Borrowed<'a, 'py, Self::Target>; // `Borrowed` can be used to optimized reference counting\n    type Error = std::convert::Infallible;\n\n    fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {\n        Ok(self.0.bind_borrowed(py))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PyClass Trait for Python Class Creation\nDESCRIPTION: Implementation of the PyClass trait that defines MyClass as a Python class. This implementation specifies the mutability state of the class using the Frozen type parameter.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nimpl pyo3::PyClass for MyClass {\n    type Frozen = pyo3::pyclass::boolean_struct::False;\n}\n```\n\n----------------------------------------\n\nTITLE: Dataclass Serialization Example\nDESCRIPTION: Demonstrates orjson's native serialization of Python dataclasses with nested structures and default values.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> import dataclasses, orjson, typing\n\n@dataclasses.dataclass\nclass Member:\n    id: int\n    active: bool = dataclasses.field(default=False)\n\n@dataclasses.dataclass\nclass Object:\n    id: int\n    name: str\n    members: typing.List[Member]\n\n>>> orjson.dumps(Object(1, \"a\", [Member(1, True), Member(2)]))\nb'{\"id\":1,\"name\":\"a\",\"members\":[{\"id\":1,\"active\":true},{\"id\":2,\"active\":false}]}'\n```\n\n----------------------------------------\n\nTITLE: Implementing FromPyObject for HashSet and BTreeSet in Rust\nDESCRIPTION: Implements the FromPyObject trait for HashSet and BTreeSet types, allowing them to be created from Python objects.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_29\n\nLANGUAGE: Rust\nCODE:\n```\n`FromPyObject` implementations for `HashSet` and `BTreeSet`.\n```\n\n----------------------------------------\n\nTITLE: Calling Python Functions with Positional Arguments in Rust\nDESCRIPTION: Demonstrates calling Python functions with different argument patterns using PyO3. Shows how to call functions with no arguments, Rust tuples as positional arguments, and Python tuples as positional arguments.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-from-rust/function-calls.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyTuple;\nuse pyo3_ffi::c_str;\n\nfn main() -> PyResult<()> {\n    let arg1 = \"arg1\";\n    let arg2 = \"arg2\";\n    let arg3 = \"arg3\";\n\n    Python::with_gil(|py| {\n        let fun: Py<PyAny> = PyModule::from_code(\n            py,\n            c_str!(\"def example(*args, **kwargs):\\n                if args != ():\\n                    print('called with args', args)\\n                if kwargs != {}:\\n                    print('called with kwargs', kwargs)\\n                if args == () and kwargs == {}:\\n                    print('called with no arguments')\"),\n            c_str!(\"\"),\n            c_str!(\"\"),\n        )?\n        .getattr(\"example\")?\n        .into();\n\n        // call object without any arguments\n        fun.call0(py)?;\n\n        // pass object with Rust tuple of positional arguments\n        let args = (arg1, arg2, arg3);\n        fun.call1(py, args)?;\n\n        // call object with Python tuple of positional arguments\n        let args = PyTuple::new(py, &[arg1, arg2, arg3])?;\n        fun.call1(py, args)?;\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies for Async-Std Runtime\nDESCRIPTION: Cargo.toml configuration for setting up PyO3 with async-std runtime support.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# Cargo.toml dependencies\n[dependencies]\npyo3 = { version = \"0.14\" }\npyo3-asyncio = { version = \"0.14\", features = [\"attributes\", \"async-std-runtime\"] }\nasync-std = \"1.9\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Class Name in __repr__ Method\nDESCRIPTION: Demonstrates how to access the Python class name in __repr__ to support subclasses by using Bound self parameter instead of a regular reference.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::types::PyString;\n#\n# #[allow(dead_code)]\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymethods]\nimpl Number {\n    fn __repr__(slf: &Bound<'_, Self>) -> PyResult<String> {\n        // This is the equivalent of `self.__class__.__name__` in Python.\n        let class_name: Bound<'_, PyString> = slf.get_type().qualname()?;\n        // To access fields of the Rust struct, we need to borrow the `PyCell`.\n        Ok(format!(\"{}{}\", class_name, slf.borrow().0))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Ordering Implementation with PartialOrd Trait\nDESCRIPTION: Shows how to automatically implement comparison methods using Rust's PartialOrd trait and the ord attribute.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#\n# #[allow(dead_code)]\n#[pyclass(eq, ord)]\n#[derive(PartialEq, PartialOrd)]\nstruct Number(i32);\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Logging for Rust Integration\nDESCRIPTION: Shows how to set up Python's logging configuration to receive and format log messages from Rust. Includes format specification and log level configuration.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/logging.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nimport my_module\n\nFORMAT = '%(levelname)s %(name)s %(asctime)-15s %(filename)s:%(lineno)d %(message)s'\nlogging.basicConfig(format=FORMAT)\nlogging.getLogger().setLevel(logging.INFO)\nmy_module.log_something()\n```\n\n----------------------------------------\n\nTITLE: Initializing Package with PyO3 Bindings in __init__.py\nDESCRIPTION: Example of __init__.py content for a package using PyO3 bindings. It imports all items from the native module, allowing them to be imported directly from the package.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-typing-hints.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom .my_project import *\n```\n\n----------------------------------------\n\nTITLE: Customizing Subclass Serialization in Python orjson\nDESCRIPTION: Shows the use of OPT_PASSTHROUGH_SUBCLASS option to pass subclasses of builtin types to a custom default function for serialization. This allows for customized handling of subclassed types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson\n>>>\nclass Secret(str):\n    pass\n\ndef default(obj):\n    if isinstance(obj, Secret):\n        return \"******\"\n    raise TypeError\n\n>>> orjson.dumps(Secret(\"zxc\"))\nb'\"zxc\"'\n>>> orjson.dumps(Secret(\"zxc\"), option=orjson.OPT_PASSTHROUGH_SUBCLASS)\nTypeError: Type is not JSON serializable: Secret\n>>> orjson.dumps(Secret(\"zxc\"), option=orjson.OPT_PASSTHROUGH_SUBCLASS, default=default)\nb'\"******\"'\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Object Properties in Rust\nDESCRIPTION: This example demonstrates how to add simple object properties to a Python class using the #[pyo3(get, set)] attribute. It allows direct reading and writing of struct fields as Python properties.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {\n    #[pyo3(get, set)]\n    num: i32,\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Datetime Serialization in Python orjson\nDESCRIPTION: Demonstrates the OPT_PASSTHROUGH_DATETIME option to pass datetime instances to a custom default function. This allows for serializing datetimes to custom formats, such as HTTP dates.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, datetime\n>>>\ndef default(obj):\n    if isinstance(obj, datetime.datetime):\n        return obj.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n    raise TypeError\n\n>>> orjson.dumps({\"created_at\": datetime.datetime(1970, 1, 1)})\nb'{\"created_at\":\"1970-01-01T00:00:00\"}'\n>>> orjson.dumps({\"created_at\": datetime.datetime(1970, 1, 1)}, option=orjson.OPT_PASSTHROUGH_DATETIME)\nTypeError: Type is not JSON serializable: datetime.datetime\n>>> orjson.dumps(\n        {\"created_at\": datetime.datetime(1970, 1, 1)},\n        option=orjson.OPT_PASSTHROUGH_DATETIME,\n        default=default,\n    )\nb'{\"created_at\":\"Thu, 01 Jan 1970 00:00:00 GMT\"}'\n```\n\n----------------------------------------\n\nTITLE: Handling UTF-8 Invalid Strings with orjson\nDESCRIPTION: Demonstrates orjson's strict UTF-8 handling compared to other JSON libraries. The example shows how orjson rejects invalid UTF-8 strings like surrogate pairs, whereas other libraries may accept them.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, ujson, rapidjson, json\n>>> orjson.dumps('\\ud800')\nJSONEncodeError: str is not valid UTF-8: surrogates not allowed\n>>> ujson.dumps('\\ud800')\nUnicodeEncodeError: 'utf-8' codec ...\n>>> rapidjson.dumps('\\ud800')\nUnicodeEncodeError: 'utf-8' codec ...\n>>> json.dumps('\\ud800')\n'\"\\\\ud800\"'\n>>> orjson.loads('\"\\\\ud800\"')\nJSONDecodeError: unexpected end of hex escape at line 1 column 8: line 1 column 1 (char 0)\n>>> ujson.loads('\"\\\\ud800\"')\n''\n>>> rapidjson.loads('\"\\\\ud800\"')\nValueError: Parse error at offset 1: The surrogate pair in string is invalid.\n>>> json.loads('\"\\\\ud800\"')\n'\\ud800'\n```\n\n----------------------------------------\n\nTITLE: Using Python-defined Exceptions in Rust\nDESCRIPTION: Example of importing and using exceptions defined in Python code as native Rust types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/exception.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(dead_code)]\nuse pyo3::prelude::*;\n\nmod io {\n    pyo3::import_exception!(io, UnsupportedOperation);\n}\n\nfn tell(file: &Bound<'_, PyAny>) -> PyResult<u64> {\n    match file.call_method0(\"tell\") {\n        Err(_) => Err(io::UnsupportedOperation::new_err(\"not supported: tell\")),\n        Ok(x) => x.extract::<u64>(),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Word Count Functions in Python\nDESCRIPTION: Python code snippet demonstrating how to import and use the search functions from the word_count module. It shows examples of calling the Python, Rust single-threaded, and Rust multi-threaded search functions.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/word-count/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom word_count import search_py, search, search_sequential\n\nsearch_py(\"foo bar\", \"foo\")\nsearch(\"foo bar\", \"foo\")\nsearch_sequential(\"foo bar\", \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Integer Conversion for PyO3 Enums\nDESCRIPTION: This snippet shows how to implement integer conversion for PyO3 enums, including explicit integer values for enum variants and conversion between enum values and integers in Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(eq, eq_int)]\n#[derive(PartialEq)]\nenum MyEnum {\n    Variant,\n    OtherVariant = 10,\n}\n\nPython::with_gil(|py| {\n    let cls = py.get_type::<MyEnum>();\n    let x = MyEnum::Variant as i32; // The exact value is assigned by the compiler.\n    pyo3::py_run!(py, cls x, r#\"\n        assert int(cls.Variant) == x\n        assert int(cls.OtherVariant) == 10\n    \"#)\n})\n```\n\n----------------------------------------\n\nTITLE: Running Python Package with Rust GDB\nDESCRIPTION: This command demonstrates how to use rust-gdb to debug a Python package that includes Rust code. It allows setting breakpoints and examining the stack trace.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/debugging.md#2025-04-22_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nrust-gdb --args python -c \"import my_package; my_package.sum_to_string(1, 2)\"\n```\n\n----------------------------------------\n\nTITLE: Creating Static Methods for Python Classes in Rust\nDESCRIPTION: This example demonstrates how to implement static methods for Python classes using the #[staticmethod] attribute. These methods don't require a class or instance argument.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {\n    num: i32,\n}\n\n#[pymethods]\nimpl MyClass {\n    #[staticmethod]\n    fn static_method(param1: i32, param2: &str) -> PyResult<i32> {\n        Ok(10)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Runtime Python Version Checking\nDESCRIPTION: Demonstrates how to check the Python version at runtime using PyO3's APIs, which is useful when building with the abi3 feature.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution/multiple-python-versions.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::Python;\n\nPython::with_gil(|py| {\n    // PyO3 supports Python 3.7 and up.\n    assert!(py.version_info() >= (3, 7));\n    assert!(py.version_info() >= (3, 7, 0));\n});\n```\n\n----------------------------------------\n\nTITLE: Testing PyO3 Function Signature and Docstring in Rust\nDESCRIPTION: This Rust code snippet demonstrates how to test the automatically generated signature and docstring for a PyO3 function. It uses the Python inspect module to verify the signature and checks the docstring directly.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/signature.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#         let doc: String = fun.getattr(\"__doc__\")?.extract()?;\n#         assert_eq!(doc, \"This function adds two unsigned 64-bit integers.\");\n#\n#         let inspect = PyModule::import(py, \"inspect\")?.getattr(\"signature\")?\n#         let sig: String = inspect\n#             .call1((fun,))?\n#             .call_method0(\"__str__\")?\n#             .extract()?;\n#         assert_eq!(sig, \"(a, b=0, /)\");\n#\n#         Ok(())\n#     })\n# }\n```\n\n----------------------------------------\n\nTITLE: Comparing Extract vs Downcast Methods in PyO3\nDESCRIPTION: Demonstrates the performance difference between using extract() and downcast() for type conversion. The extract method has higher overhead due to error conversion costs, while downcast is more efficient for native types when error details aren't needed.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/performance.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction]\nfn frobnicate<'py>(value: &Bound<'py, PyAny>) -> PyResult<Bound<'py, PyAny>> {\n    if let Ok(list) = value.extract::<Bound<'_, PyList>>() {\n        frobnicate_list(&list)\n    } else if let Ok(vec) = value.extract::<Vec<Bound<'_, PyAny>>>() {\n        frobnicate_vec(vec)\n    } else {\n        Err(PyTypeError::new_err(\"Cannot frobnicate that type.\"))\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction]\nfn frobnicate<'py>(value: &Bound<'py, PyAny>) -> PyResult<Bound<'py, PyAny>> {\n    // Use `downcast` instead of `extract` as turning `PyDowncastError` into `PyErr` is quite costly.\n    if let Ok(list) = value.downcast::<PyList>() {\n        frobnicate_list(list)\n    } else if let Ok(vec) = value.extract::<Vec<Bound<'_, PyAny>>>() {\n        frobnicate_vec(vec)\n    } else {\n        Err(PyTypeError::new_err(\"Cannot frobnicate that type.\"))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing UUID Objects with orjson\nDESCRIPTION: Demonstrates orjson's native support for serializing uuid.UUID objects to RFC 4122 format. The example shows serialization of both predefined and generated UUIDs.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, uuid\n>>> orjson.dumps(uuid.UUID('f81d4fae-7dec-11d0-a765-00a0c91e6bf6'))\nb'\"f81d4fae-7dec-11d0-a765-00a0c91e6bf6\"'\n>>> orjson.dumps(uuid.uuid5(uuid.NAMESPACE_DNS, \"python.org\"))\nb'\"886313e1-3b8a-5372-9b90-0c9aee199e5d\"'\n```\n\n----------------------------------------\n\nTITLE: Type Checking Python Objects in PyO3\nDESCRIPTION: Shows how to check Python object types using is_instance and is_instance_of methods.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/exception.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::{PyBool, PyList};\n\n# fn main() -> PyResult<()> {\nPython::with_gil(|py| {\n    assert!(PyBool::new(py, true).is_instance_of::<PyBool>());\n    let list = PyList::new(py, &[1, 2, 3, 4])?;\n    assert!(!list.is_instance_of::<PyBool>());\n    assert!(list.is_instance_of::<PyList>());\n# Ok(())\n})\n# }\n```\n\n----------------------------------------\n\nTITLE: Python Threading Example with PyO3\nDESCRIPTION: Example showing how to use Python's ThreadPoolExecutor with the PyO3 implementation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/parallelism.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom concurrent.futures import ThreadPoolExecutor\nfrom word_count import search_sequential_allow_threads\n\nexecutor = ThreadPoolExecutor(max_workers=2)\n\nfuture_1 = executor.submit(\n    word_count.search_sequential_allow_threads, contents, needle\n)\nfuture_2 = executor.submit(\n    word_count.search_sequential_allow_threads, contents, needle\n)\nresult_1 = future_1.result()\nresult_2 = future_2.result()\n```\n\n----------------------------------------\n\nTITLE: Automatic Equality Implementation with PartialEq Trait\nDESCRIPTION: Demonstrates how to automatically implement __eq__ using Rust's PartialEq trait and the eq attribute.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#\n# #[allow(dead_code)]\n#[pyclass(eq)]\n#[derive(PartialEq)]\nstruct Number(i32);\n```\n\n----------------------------------------\n\nTITLE: Using Shorthand Format String for __str__ Generation\nDESCRIPTION: Shows how to use a shorthand format string with the str attribute to automatically generate the __str__ method for struct fields.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#\n# #[allow(dead_code)]\n# #[pyclass(str=\"({x}, {y}, {z})\")]\n# struct Coordinate {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Rust Data from Python Objects with PyO3\nDESCRIPTION: Shows how to extract Rust data from Python objects using the `.extract()` method, which works with types that implement the `FromPyObject` trait. The example extracts a Rust tuple from a Python tuple.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::types::PyTuple;\n# fn example<'py>(py: Python<'py>) -> PyResult<()> {\n// create a new Python `tuple`, and use `.into_any()` to erase the type\nlet obj: Bound<'py, PyAny> = PyTuple::new(py, [1, 2, 3])?.into_any();\n\n// extracting the Python `tuple` to a rust `(i32, i32, i32)` tuple\nlet (x, y, z) = obj.extract::<(i32, i32, i32)>()?;\nassert_eq!((x, y, z), (1, 2, 3));\n# Ok(())\n# }\n# Python::with_gil(example).unwrap()\n```\n\n----------------------------------------\n\nTITLE: Replacing GILProtected with Mutex in Free-Threaded Python\nDESCRIPTION: This code example demonstrates how to replace the GILProtected type with a std::sync::Mutex when working with free-threaded Python. It shows the before and after versions of code that manages a global collection of PyDict objects.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/free-threading.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::types::{PyDict, PyNone};\nuse std::sync::Mutex;\n\nstatic OBJECTS: Mutex<Vec<Py<PyDict>>> = Mutex::new(Vec::new());\n\nPython::with_gil(|py| {\n    // stand-in for something that executes arbitrary Python code\n    let d = PyDict::new(py);\n    d.set_item(PyNone::get(py), PyNone::get(py)).unwrap();\n    // as with any `Mutex` usage, lock the mutex for as little time as possible\n    // in this case, we do it just while pushing into the `Vec`\n    OBJECTS.lock().unwrap().push(d.unbind());\n});\n```\n\n----------------------------------------\n\nTITLE: PyO3 Borrowed Type Usage Example\nDESCRIPTION: Demonstration of using PyO3's Borrowed smart pointer type with Python tuples, showing iteration and value extraction.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyTuple;\n\nlet t = PyTuple::new(py, [0, 1, 2])?;\nfor i in 0..=2 {\n    let entry: Borrowed<'_, 'py, PyAny> = t.get_borrowed_item(i)?;\n    let value: usize = entry.extract()?;\n    assert_eq!(i, value);\n}\n```\n\n----------------------------------------\n\nTITLE: Python Async Function Using Rust Implementation\nDESCRIPTION: Shows how to use the converted Rust function in Python async code.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom example import call_rust_sleep\n\nasync def rust_sleep():\n    await call_rust_sleep()\n```\n\n----------------------------------------\n\nTITLE: Serializing Numpy Datetime64 with Options\nDESCRIPTION: Shows how to serialize numpy.datetime64 instances with different formatting options. The example demonstrates both basic serialization and applying additional options like UTC timezone and microsecond omission.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, numpy\n>>> orjson.dumps(\n        numpy.datetime64(\"2021-01-01T00:00:00.172\"),\n        option=orjson.OPT_SERIALIZE_NUMPY,\n)\nb'\"2021-01-01T00:00:00.172000\"'\n>>> orjson.dumps(\n        numpy.datetime64(\"2021-01-01T00:00:00.172\"),\n        option=(\n            orjson.OPT_SERIALIZE_NUMPY |\n            orjson.OPT_NAIVE_UTC |\n            orjson.OPT_OMIT_MICROSECONDS\n        ),\n)\nb'\"2021-01-01T00:00:00+00:00\"'\n```\n\n----------------------------------------\n\nTITLE: Python Call Counter Implementation - Functional Version\nDESCRIPTION: Alternative implementation of the call counter using a higher-order function approach with closure to maintain state.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/call.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef Counter(wraps):\n    count = 0\n    def call(*args, **kwargs):\n        nonlocal count\n        count += 1\n        print(f\"{wraps.__name__} has been called {count} time(s)\")\n        return wraps(*args, **kwargs)\n    return call\n```\n\n----------------------------------------\n\nTITLE: Tracing Outputs in Next.js Handler with Vercel AI SDK and Mistral\nDESCRIPTION: This snippet demonstrates how to trace outputs in a Next.js handler using the Vercel AI SDK and Mistral API. It uses the traceable function from LangSmith to wrap the Mistral chat stream and convert the response into a text stream compatible with Vercel AI SDK.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { traceable } from \"langsmith/traceable\";\nimport { OpenAIStream, StreamingTextResponse } from \"ai\";\n\n// Note: There are no types for the Mistral API client yet.\nimport MistralClient from \"@mistralai/mistralai\";\n\nconst client = new MistralClient(process.env.MISTRAL_API_KEY || \"\");\n\nexport async function POST(req: Request) {\n  // Extract the `messages` from the body of the request\n  const { messages } = await req.json();\n\n  const mistralChatStream = traceable(client.chatStream.bind(client), {\n    name: \"Mistral Stream\",\n    run_type: \"llm\",\n  });\n\n  const response = await mistralChatStream({\n    model: \"mistral-tiny\",\n    maxTokens: 1000,\n    messages,\n  });\n\n  // Convert the response into a friendly text-stream. The Mistral client responses are\n  // compatible with the Vercel AI SDK OpenAIStream adapter.\n  const stream = OpenAIStream(response as any);\n\n  // Respond with the stream\n  return new StreamingTextResponse(stream);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PyCell struct in Rust for Python object allocation\nDESCRIPTION: This struct definition shows how PyCell is used to ensure proper memory layout for Python objects implemented in Rust. It includes the Python object base and the inner Rust type T that implements PyClass.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Architecture.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)]\npub struct PyCell<T: PyClass> {\n    ob_base: crate::ffi::PyObject,\n    inner: T,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rich Comparison in PyO3\nDESCRIPTION: Shows how to implement the __richcmp__ method in PyO3 to handle all comparison operations (==, !=, <, <=, >, >=) in a single method. It demonstrates handling specific operations and returning NotImplemented for unimplemented comparisons.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/protocols.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::class::basic::CompareOp;\nuse pyo3::types::PyNotImplemented;\n\nuse pyo3::prelude::*;\nuse pyo3::BoundObject;\n\n#[pyclass]\nstruct Number(i32);\n\n#[pymethods]\nimpl Number {\n    fn __richcmp__<'py>(&self, other: &Self, op: CompareOp, py: Python<'py>) -> PyResult<Borrowed<'py, 'py, PyAny>> {\n        match op {\n            CompareOp::Eq => Ok((self.0 == other.0).into_pyobject(py)?.into_any()),\n            CompareOp::Ne => Ok((self.0 != other.0).into_pyobject(py)?.into_any()),\n            _ => Ok(PyNotImplemented::get(py).into_any()),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Class Implementation with PyO3\nDESCRIPTION: Example showing how to work around PyO3's restriction on generic parameters by using a macro to generate concrete implementations for different types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nstruct GenericClass<T> {\n    data: T,\n}\n\nmacro_rules! create_interface {\n    ($name: ident, $type: ident) => {\n        #[pyclass]\n        pub struct $name {\n            inner: GenericClass<$type>,\n        }\n        #[pymethods]\n        impl $name {\n            #[new]\n            pub fn new(data: $type) -> Self {\n                Self {\n                    inner: GenericClass { data: data },\n                }\n            }\n        }\n    };\n}\n\ncreate_interface!(IntClass, i64);\ncreate_interface!(FloatClass, String);\n```\n\n----------------------------------------\n\nTITLE: Avoiding Dangling Pointers with Option<Bound<PyAny>> in Rust PyO3\nDESCRIPTION: Demonstrates the correct way to handle Option<Bound<PyAny>> to avoid creating dangling pointers when converting to raw pointers. Uses as_ref() to prevent premature dropping of the Bound<PyAny>.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nlet opt: Option<&PyAny> = ...;\nlet p: *mut ffi::PyObject = opt.map_or(std::ptr::null_mut(), |any| any.as_ptr());\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet opt: Option<Bound<PyAny>> = ...;\nlet p: *mut ffi::PyObject = opt.as_ref().map_or(std::ptr::null_mut(), Bound::as_ptr);\n```\n\n----------------------------------------\n\nTITLE: Implementing FromPyObject for Custom Enum in Rust\nDESCRIPTION: This snippet demonstrates how to implement FromPyObject for a custom enum using the derive macro. It includes examples of using annotations to customize error messages.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[derive(FromPyObject)]\n# #[derive(Debug)]\nenum RustyEnum {\n    #[pyo3(transparent, annotation = \"str\")]\n    String(String),\n    #[pyo3(transparent, annotation = \"int\")]\n    Int(isize),\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Free-Threaded Python Module with PyO3\nDESCRIPTION: Example showing how to declare a Python module that supports free-threading by using the gil_used = false parameter in the pymodule macro.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/free-threading.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n/// This module supports free-threaded Python\n#[pymodule(gil_used = false)]\nfn my_extension(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    // add members to the module that you know are thread-safe\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Adding PyAny::dir Method in Rust\nDESCRIPTION: Adds a new dir method to the PyAny struct, providing functionality similar to Python's built-in dir() function.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\nAdd `PyAny::dir` method.\n```\n\n----------------------------------------\n\nTITLE: Converting Between Py<T> and Bound<T> in Rust PyO3\nDESCRIPTION: Shows how to convert between Py<T> and Bound<T> objects using bind()/into_bound() methods, and how to convert back using as_unbound()/unbind().\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet obj: Py<PyList> = ...;\nlet bound: &Bound<'py, PyList> = obj.bind(py);\nlet bound: Bound<'py, PyList> = obj.into_bound(py);\n\nlet obj: &Py<PyList> = bound.as_unbound();\nlet obj: Py<PyList> = bound.unbind();\n```\n\n----------------------------------------\n\nTITLE: Adding Extension Module Link Arguments in Rust\nDESCRIPTION: This code snippet demonstrates how to add the necessary linker arguments for PyO3 on macOS using a build.rs file. It uses the pyo3_build_config crate to automatically set the correct arguments.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    pyo3_build_config::add_extension_module_link_args();\n}\n```\n\n----------------------------------------\n\nTITLE: FromPyObject for Complex Enums\nDESCRIPTION: Shows deriving FromPyObject for enums with multiple variant types and attributes.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nenum RustyEnum<'py> {\n    Int(usize),\n    String(String),\n    IntTuple(usize, usize),\n    StringIntTuple(String, usize),\n    Coordinates3d {\n        x: usize,\n        y: usize,\n        z: usize,\n    },\n    Coordinates2d {\n        #[pyo3(attribute(\"x\"))]\n        a: usize,\n        #[pyo3(attribute(\"y\"))]\n        b: usize,\n    },\n    #[pyo3(transparent)]\n    CatchAll(Bound<'py, PyAny>),\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning PyO3 Class Instances in Rust\nDESCRIPTION: This snippet shows how to make a PyO3 class cloneable by implementing the Clone trait, allowing the class to be passed by value instead of by reference.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\n#[derive(Clone)]\nstruct MyClass {\n    my_field: Box<i32>,\n}\n\n#[pyfunction]\nfn dissamble_clone(my_class: MyClass) {\n    let MyClass { mut my_field } = my_class;\n    *my_field += 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Concurrent Access to Thread-Unsafe Iterator in Python\nDESCRIPTION: This Python code demonstrates how to trigger a runtime error by concurrently accessing a thread-unsafe iterator implemented in Rust. It uses the concurrent.futures module to create multiple threads.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/free-threading.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport concurrent.futures\nfrom my_module import ThreadIter\n\ni = ThreadIter()\n\ndef increment():\n    next(i)\n\nwith concurrent.futures.ThreadPoolExecutor(max_workers=16) as tpe:\n    futures = [tpe.submit(increment) for _ in range(100)]\n    [f.result() for f in futures]\n```\n\n----------------------------------------\n\nTITLE: Using the PyList API with Bound Smart Pointers in Rust\nDESCRIPTION: Demonstrates how to use the API for concrete Python types like PyList through their respective trait methods. The example accesses the first item of a Python list using the PyListMethods trait.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyList;\n\nfn get_first_item<'py>(list: &Bound<'py, PyList>) -> PyResult<Bound<'py, PyAny>> {\n    list.get_item(0)\n}\n# Python::with_gil(|py| {\n#     let l = PyList::new(py, [\"hello world\"]).unwrap();\n#     assert!(get_first_item(&l).unwrap().eq(\"hello world\").unwrap());\n# })\n```\n\n----------------------------------------\n\nTITLE: Complete Setup Script for PyO3 Project\nDESCRIPTION: Complete bash script to set up, build, and test a PyO3 project in one go. Creates a directory, sets up a Python virtual environment, installs maturin, initializes a PyO3 project, and builds it.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmkdir string_sum && cd \"$_\"\npython -m venv .env\nsource .env/bin/activate\npip install maturin\nmaturin init --bindings pyo3\nmaturin develop\n```\n\n----------------------------------------\n\nTITLE: Original Rust implementation with unsafe type conversion\nDESCRIPTION: Initial implementation of the Model trait for UserModel, showing how Rust calls Python methods using PyO3. This implementation uses unwrap() directly on the result, which can lead to unhelpful error messages.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/trait-bounds.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nimpl Model for UserModel {\n    fn get_results(&self) -> Vec<f64> {\n        println!(\"Rust calling Python to get the results\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"get_results\", (), None)\n                .unwrap()\n                .extract()\n                .unwrap()\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Python Container Implementation Example\nDESCRIPTION: Demonstration of implementing a Python sequence container with __len__ and __getitem__ methods.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nclass ExampleContainer:\n\n    def __len__(self):\n        return 5\n\n    def __getitem__(self, idx: int) -> int:\n        if idx < 0 or idx > 5:\n            raise IndexError()\n        return idx\n```\n\n----------------------------------------\n\nTITLE: Testing Number Class Implementation in Python\nDESCRIPTION: A Python script to test the implementation of a Number class, including assertions for string representation and creation from integer values.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n#     import inspect\n#     assert inspect.signature(Number).__str__() == '(value)'\n# except ValueError:\n#     # Not supported with `abi3` before Python 3.10\n#     pass\n# assert Number(1337).__str__() == '1337'\n# assert Number(1337).__repr__() == 'Number(1337)'\n```\n\n----------------------------------------\n\nTITLE: Nested GIL Acquisition with PyO3\nDESCRIPTION: Demonstrates proper nesting of GIL acquisition using PyO3's with_gil method. This pattern ensures proper release of inner locks before outer ones, preventing potential deadlocks in Python extensions.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n// Or it ensures releasing the inner lock before the outer one.\nPython::with_gil(|py| {\n    let first = Object::new(py);\n    let second = Python::with_gil(|py| Object::new(py));\n    drop(first);\n    drop(second);\n});\n```\n\n----------------------------------------\n\nTITLE: Demonstrating PyO3 Function Signature in IPython\nDESCRIPTION: This text snippet shows how the PyO3 function signature appears in IPython. It demonstrates that the __text_signature__ attribute is set correctly and how the function's signature and docstring are displayed when using IPython's help feature.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/signature.md#2025-04-22_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n>>> pyo3_test.add.__text_signature__\n'(a, b=0, /)'\n>>> pyo3_test.add?\nSignature: pyo3_test.add(a, b=0, /)\nDocstring: This function adds two unsigned 64-bit integers.\nType:      builtin_function_or_method\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation Examples for Python Versions\nDESCRIPTION: Demonstrates conditional compilation for different Python versions using #[cfg] flags provided by pyo3-build-config.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution/multiple-python-versions.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(Py_3_7)]\nfn function_only_supported_on_python_3_7_and_up() {}\n\n#[cfg(not(Py_3_8))]\nfn function_only_supported_before_python_3_8() {}\n\n#[cfg(not(Py_LIMITED_API))]\nfn function_incompatible_with_abi3_feature() {}\n```\n\n----------------------------------------\n\nTITLE: Running Python Script in Rust using PyO3\nDESCRIPTION: A Rust function that uses PyO3 to run a Python script, setting up the Python environment and executing the script within the Python GIL.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::PyTypeInfo;\n#\n# fn main() -> PyResult<()> {\n#     Python::with_gil(|py| -> PyResult<()> {\n#         let globals = PyModule::import(py, \"__main__\")?.dict();\n#         globals.set_item(\"Number\", Number::type_object(py))?;\n#\n#         py.run(SCRIPT, Some(&globals), None)?;\n#         Ok(())\n#     })\n# }\n```\n\n----------------------------------------\n\nTITLE: Working with Invalid UTF-8 Input in orjson\nDESCRIPTION: Shows how to handle potentially invalid UTF-8 input by first decoding bytes with replacement characters. This provides a workaround for processing malformed UTF-8 data with orjson.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson\n>>> orjson.loads(b'\"\\xed\\xa0\\x80\"')\nJSONDecodeError: str is not valid UTF-8: surrogates not allowed\n>>> orjson.loads(b'\"\\xed\\xa0\\x80\"'.decode(\"utf-8\", \"replace\"))\n''\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Python Extension Module\nDESCRIPTION: Example Cargo.toml configuration for a Python extension module using PyO3. Specifies package metadata, library type as cdylib for Python compatibility, and PyO3 dependency with extension-module feature.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/README.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"string_sum\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\n# The name of the native library. This is the name which will be used in Python to import the\n# library (i.e. `import string_sum`). If you change this, you must also change the name of the\n# `#[pymodule]` in `src/lib.rs`.\nname = \"string_sum\"\n# \"cdylib\" is necessary to produce a shared library for Python to import from.\n#\n# Downstream Rust code (including code in `bin/`, `examples/`, and `tests/`) will not be able\n# to `use string_sum;` unless the \"rlib\" or \"lib\" crate type is also included, e.g.:\n# crate-type = [\"cdylib\", \"rlib\"]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npyo3 = { version = \"0.23.4\", features = [\"extension-module\"] }\n```\n\n----------------------------------------\n\nTITLE: PyO3 List Operations with Type Annotations\nDESCRIPTION: Rust implementation using PyO3's Bound<'py, PyList> smart pointer with explicit type annotations, demonstrating equivalent list operations to the Python example.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyList;\n\nfn example<'py>(py: Python<'py>) -> PyResult<()> {\n    let x: Bound<'py, PyList> = PyList::empty(py);\n    x.append(1)?;\n    let y: Bound<'py, PyList> = x.clone(); // y is a new reference to the same list\n    drop(x); // release the original reference x\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Equality with __eq__ Method\nDESCRIPTION: Shows how to implement just the equality comparison using the __eq__ special method instead of the full __richcmp__.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymethods]\nimpl Number {\n    fn __eq__(&self, other: &Self) -> bool {\n        self.0 == other.0\n    }\n}\n\n# fn main() -> PyResult<()> {\n#     Python::with_gil(|py| {\n#         let x = &Bound::new(py, Number(4))?;\n#         let y = &Bound::new(py, Number(4))?;\n#         assert!(x.eq(y)?);\n#         assert!(!x.ne(y)?); \n#         Ok(())\n#     })\n# }\n```\n\n----------------------------------------\n\nTITLE: Traceable Instructor Function\nDESCRIPTION: Shows how to use the @traceable decorator with Instructor for structured output extraction.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n@traceable()\ndef my_function(text: str) -> UserDetail:\n    return client.chat.completions.create(\n        model=\"gpt-3.5-turbo\",\n        response_model=UserDetail,\n        messages=[\n            {\"role\": \"user\", \"content\": f\"Extract {text}\"},\n        ]\n    )\n\n\nmy_function(\"Jason is 25 years old\")\n```\n\n----------------------------------------\n\nTITLE: Using Custom Default Function with orjson in Python\nDESCRIPTION: Shows how to use a custom default function to handle serialization of unsupported types like Decimal, and demonstrates error handling for unhandled types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, decimal\n>>>\ndef default(obj):\n    if isinstance(obj, decimal.Decimal):\n        return str(obj)\n    raise TypeError\n\n>>> orjson.dumps(decimal.Decimal(\"0.0842389659712649442845\"))\nJSONEncodeError: Type is not JSON serializable: decimal.Decimal\n>>> orjson.dumps(decimal.Decimal(\"0.0842389659712649442845\"), default=default)\nb'\"0.0842389659712649442845\"'\n>>> orjson.dumps({1, 2}, default=default)\norjson.JSONEncodeError: Type is not JSON serializable: set\n```\n\n----------------------------------------\n\nTITLE: Implementing Integer Wrapping in Rust\nDESCRIPTION: Basic implementation of a wrapping function that masks Python integers to fit within 32 bits, used to handle overflow in the Number constructor.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\nuse pyo3::prelude::*;\n\nfn wrap(obj: &Bound<'_, PyAny>) -> PyResult<i32> {\n    let val = obj.call_method1(\"__and__\", (0xFFFFFFFF_u32,))?;\n    let val: u32 = val.extract()?;\n    //      This intentionally overflows!\n    Ok(val as i32)\n}\n```\n\n----------------------------------------\n\nTITLE: Integer Parsing with Error Handling\nDESCRIPTION: Demonstrates handling ParseIntError by converting it to a Python exception using PyO3's built-in error conversion.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/error-handling.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::num::ParseIntError;\n\n#[pyfunction]\nfn parse_int(x: &str) -> Result<usize, ParseIntError> {\n    x.parse()\n}\n```\n\n----------------------------------------\n\nTITLE: Installing orjson with Package Managers\nDESCRIPTION: Examples of how to specify orjson as a dependency in requirements.txt and Poetry configuration files.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\norjson>=3.10,<4\n```\n\nLANGUAGE: toml\nCODE:\n```\norjson = \"^3\"\n```\n\n----------------------------------------\n\nTITLE: Rich Comparison Implementation with __richcmp__\nDESCRIPTION: Implements all six Python comparison operations using the __richcmp__ special method with CompareOp enum.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::class::basic::CompareOp;\n\n# use pyo3::prelude::*;\n#\n# #[allow(dead_code)]\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymethods]\nimpl Number {\n    fn __richcmp__(&self, other: &Self, op: CompareOp) -> PyResult<bool> {\n        match op {\n            CompareOp::Lt => Ok(self.0 < other.0),\n            CompareOp::Le => Ok(self.0 <= other.0),\n            CompareOp::Eq => Ok(self.0 == other.0),\n            CompareOp::Ne => Ok(self.0 != other.0),\n            CompareOp::Gt => Ok(self.0 > other.0),\n            CompareOp::Ge => Ok(self.0 >= other.0),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FromPyObject Derivation with Custom Keys\nDESCRIPTION: Shows how to customize attribute and item keys when deriving FromPyObject.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nstruct RustyStruct {\n    #[pyo3(item(\"key\"))]\n    string_in_mapping: String,\n    #[pyo3(attribute(\"name\"))]\n    string_attr: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PyAny struct in Rust for Python object representation\nDESCRIPTION: This code snippet shows the definition of the PyAny struct, which is a wrapper for Python's object type in PyO3. It uses a transparent representation and an UnsafeCell to wrap the low-level PyObject from the FFI.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Architecture.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(transparent)]\npub struct PyAny(UnsafeCell<ffi::PyObject>);\n```\n\n----------------------------------------\n\nTITLE: Thread-Safe Class Using Atomic Data Structures in PyO3\nDESCRIPTION: An implementation using atomic integers with a frozen PyClass to prevent runtime borrowing errors. This approach uses atomic operations to ensure thread safety without runtime borrow checking errors.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/thread-safety.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\n#[pyclass(frozen)]\nstruct MyClass {\n    x: AtomicI32,\n    y: AtomicI32,\n}\n\n#[pymethods]\nimpl MyClass {\n    fn get_x(&self) -> i32 {\n        self.x.load(Ordering::Relaxed)\n    }\n\n    fn set_y(&self, value: i32) {\n        self.y.store(value, Ordering::Relaxed)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Async Sleep Function\nDESCRIPTION: Implements a simple async sleep function in Rust using async-std runtime.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n/// Sleep for 1 second\nasync fn rust_sleep() {\n    async_std::task::sleep(std::time::Duration::from_secs(1)).await;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for macOS Python Framework\nDESCRIPTION: This TOML configuration adds the rpath to the Python framework on macOS, which helps resolve runtime errors related to loading the Python library.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution.md#2025-04-22_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nrustflags = [\n  \"-C\", \"link-args=-Wl,-rpath,/Library/Developer/CommandLineTools/Library/Frameworks\",\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing DerefToPyAny Trait for Python Interoperability\nDESCRIPTION: Implementation of the DerefToPyAny trait from PyO3 for MyClass to allow dereferencing to Python's Any type, enabling generic Python operations on the struct.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nimpl pyo3::types::DerefToPyAny for MyClass {}\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of IntoPyObject - Legacy Approach\nDESCRIPTION: Example of the old way to implement Python object conversion using IntoPy and ToPyObject traits.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyPyObjectWrapper(PyObject);\n\nimpl IntoPy<PyObject> for MyPyObjectWrapper {\n    fn into_py(self, py: Python<'_>) -> PyObject {\n        self.0\n    }\n}\n\nimpl ToPyObject for MyPyObjectWrapper {\n    fn to_object(&self, py: Python<'_>) -> PyObject {\n        self.0.clone_ref(py)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updated PyDict get_item Implementation\nDESCRIPTION: Shows updated PyDict get_item implementation that returns Results instead of suppressing exceptions, following newer Python core developer recommendations.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::exceptions::PyTypeError;\nuse pyo3::types::{PyDict, IntoPyDict};\n\nPython::with_gil(|py| -> PyResult<()> {\n    let dict: &PyDict = [(\"a\", 1)].into_py_dict(py);\n    assert!(dict.get_item(\"a\")?.map_or(Ok(false), |x| x.eq(1))?); \n    assert!(dict.get_item(\"b\")?.is_none());\n    assert!(dict\n        .get_item(dict)\n        .unwrap_err()\n        .is_instance_of::<PyTypeError>(py));\n    Ok(())\n});\n```\n\n----------------------------------------\n\nTITLE: Installing LangSmith and OpenAI SDKs\nDESCRIPTION: npm command to install both LangSmith and OpenAI SDKs for integration.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nnpm install langsmith openai\n```\n\n----------------------------------------\n\nTITLE: Simplified Rich Comparison Using CompareOp::matches\nDESCRIPTION: Shows a shortcut for implementing __richcmp__ using Rust's standard library comparison and CompareOp::matches.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::class::basic::CompareOp;\n\n# use pyo3::prelude::*;\n#\n# #[allow(dead_code)]\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymethods]\nimpl Number {\n    fn __richcmp__(&self, other: &Self, op: CompareOp) -> bool {\n        op.matches(self.0.cmp(&other.0))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Truthiness with __bool__ Method\nDESCRIPTION: Implements the __bool__ special method to determine if an object is considered True or False in a boolean context.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#\n# #[allow(dead_code)]\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymethods]\nimpl Number {\n    fn __bool__(&self) -> bool {\n        self.0 != 0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Thread-Unsafe Iterator in Rust with PyO3\nDESCRIPTION: This code snippet demonstrates a PyO3 class implementation of an iterator that is not thread-safe. It shows how to define a pyclass with a counter and implement the __next__ method.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/free-threading.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\n#[derive(Default)]\nstruct ThreadIter {\n    count: usize,\n}\n\n#[pymethods]\nimpl ThreadIter {\n    #[new]\n    pub fn new() -> Self {\n        Default::default()\n    }\n\n    fn __next__(&mut self, py: Python<'_>) -> usize {\n        self.count += 1;\n        self.count\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing the Python GIL in External Contexts\nDESCRIPTION: Shows how to safely acquire and release the Python GIL when creating objects outside of a function context. This approach forces releasing the GIL after each object creation to avoid deadlocks.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n// It either forces us to release the GIL before aquiring it again.\nlet first = Python::with_gil(|py| Object::new(py));\nlet second = Python::with_gil(|py| Object::new(py));\ndrop(first);\ndrop(second);\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for macOS Targets\nDESCRIPTION: This TOML configuration sets the necessary rustflags for x86_64 and aarch64 macOS targets to enable dynamic lookup of symbols, which is required for PyO3 on macOS.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[target.x86_64-apple-darwin]\nrustflags = [\n  \"-C\", \"link-arg=-undefined\",\n  \"-C\", \"link-arg=dynamic_lookup\",\n]\n\n[target.aarch64-apple-darwin]\nrustflags = [\n  \"-C\", \"link-arg=-undefined\",\n  \"-C\", \"link-arg=dynamic_lookup\",\n]\n```\n\n----------------------------------------\n\nTITLE: Updated Constructor Pattern with #[new] in PyO3\nDESCRIPTION: Shows the change in PyO3's constructor syntax from using PyRawObject to directly returning Self or Result<Self>. This simplifies the class construction pattern in Rust PyO3 bindings.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_38\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct MyClass {}\n\n#[pymethods]\nimpl MyClass {\n    #[new]\n    fn new(obj: &PyRawObject) {\n        obj.init(MyClass {})\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#[pyclass]\nstruct MyClass {}\n\n#[pymethods]\nimpl MyClass {\n    #[new]\n    fn new() -> Self {\n        MyClass {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating String Extraction with gil-refs Feature Disabled in Rust PyO3\nDESCRIPTION: Shows how to update code that extracts string references from Python objects when the gil-refs feature is disabled. With gil-refs disabled, data extraction requires managing lifetimes differently.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(deprecated)] // GIL Ref API\nlet obj: &'py PyType = py.get_type::<PyList>();\nlet name: &'py str = obj.getattr(\"__name__\")?.extract()?;\nassert_eq!(name, \"list\");\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet obj: Bound<'py, PyType> = py.get_type_bound::<PyList>();\nlet name_obj: Bound<'py, PyAny> = obj.getattr(\"__name__\")?;\n// the lifetime of the data is no longer `'py` but the much shorter\n// lifetime of the `name_obj` smart pointer above\nlet name: &'_ str = name_obj.extract()?;\nassert_eq!(name, \"list\");\n```\n\n----------------------------------------\n\nTITLE: Safe FFI Call in PyO3\nDESCRIPTION: Example of a safe FFI call in PyO3 using owned PyObject wrapper, which is the preferred approach.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet name: PyObject = name.to_object(py);\npyo3::ffi::Something(name.as_ptr())\n// name will automatically be freed when it falls out of scope\n```\n\n----------------------------------------\n\nTITLE: Renaming Enums and Variants in PyO3\nDESCRIPTION: Shows how to rename enum types and their variants using the #[pyo3(name)] attribute. The example renames an enum to 'RenamedEnum' and its variant to 'UPPERCASE' for Python exposure.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n#[pyclass(eq, eq_int, name = \"RenamedEnum\")]\n#[derive(PartialEq)]\nenum MyEnum {\n    #[pyo3(name = \"UPPERCASE\")]\n    Variant,\n}\n\nPython::with_gil(|py| {\n    let x = Py::new(py, MyEnum::Variant).unwrap();\n    let cls = py.get_type::<MyEnum>();\n    pyo3::py_run!(py, x cls, r#\"\n        assert repr(x) == 'RenamedEnum.UPPERCASE'\n        assert x == cls.UPPERCASE\n    \"#)\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Permission and User Structs with Python Bindings\nDESCRIPTION: Defines two Rust structs (Permission and User) that are decorated for Python interop and serde serialization. The User struct contains a vector of Permission objects wrapped in Python references.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/features.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse serde::{Deserialize, Serialize};\n\n#[pyclass]\n#[derive(Serialize, Deserialize)]\nstruct Permission {\n    name: String,\n}\n\n#[pyclass]\n#[derive(Serialize, Deserialize)]\nstruct User {\n    username: String,\n    permissions: Vec<Py<Permission>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Future Wrapper to Release GIL\nDESCRIPTION: A workaround to release the GIL (Global Interpreter Lock) when awaiting a future in Python. This wrapper allows other Python threads to run while waiting for async operations to complete.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/async-await.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std:{\n    future::Future,\n    pin::{Pin, pin},\n    task::{Context, Poll},\n};\nuse pyo3::prelude::*;\n\nstruct AllowThreads<F>(F);\n\nimpl<F> Future for AllowThreads<F>\nwhere\n    F: Future + Unpin + Send,\n    F::Output: Send,\n{\n    type Output = F::Output;\n\n    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        let waker = cx.waker();\n        Python::with_gil(|gil| {\n            gil.allow_threads(|| pin!(&mut self.0).poll(&mut Context::from_waker(waker)))\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Python Function Name\nDESCRIPTION: Shows how to override the Python-exposed name of a Rust function using the #[pyo3(name = \"...\")] attribute.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyfunction]\n#[pyo3(name = \"no_args\")]\nfn no_args_py() -> usize {\n    42\n}\n\n#[pymodule]\nfn module_with_functions(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(no_args_py, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Number Class with PyO3\nDESCRIPTION: Defines a simple Number class with a PyO3 class definition that can be imported and instantiated in Python, but lacks customization for display and behavior.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct Number(i32);\n\n#[pymethods]\nimpl Number {\n    #[new]\n    fn new(value: i32) -> Self {\n        Self(value)\n    }\n}\n\n#[pymodule]\nfn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<Number>()?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of IntoPyObject - New Approach\nDESCRIPTION: Updated implementation showing the new way to implement Python object conversion using IntoPyObject trait for both owned and reference types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'py> IntoPyObject<'py> for MyPyObjectWrapper {\n    type Target = PyAny;\n    type Output = Bound<'py, Self::Target>;\n    type Error = std::convert::Infallible;\n\n    fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {\n        Ok(self.0.into_bound(py))\n    }\n}\n\nimpl<'a, 'py> IntoPyObject<'py> for &'a MyPyObjectWrapper {\n    type Target = PyAny;\n    type Output = Borrowed<'a, 'py, Self::Target>;\n    type Error = std::convert::Infallible;\n\n    fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {\n        Ok(self.0.bind_borrowed(py))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Async-Std Main Function Implementation\nDESCRIPTION: Rust implementation of a main function using async-std runtime to execute Python asyncio code.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyo3_asyncio::async_std::main]\nasync fn main() -> PyResult<()> {\n    let fut = Python::with_gil(|py| {\n        let asyncio = py.import(\"asyncio\")?;\n        // convert asyncio.sleep into a Rust Future\n        pyo3_asyncio::async_std::into_future(asyncio.call_method1(\"sleep\", (1.into_py(py),))?)\n    })?;\n\n    fut.await?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating PyProto to PyMethods in Rust\nDESCRIPTION: Example showing how to migrate from deprecated #[pyproto] attribute to #[pymethods] for implementing Python magic methods in PyO3.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::class::{PyObjectProtocol, PyIterProtocol};\nuse pyo3::types::PyString;\n\n#[pyclass]\nstruct MyClass {}\n\n#[pyproto]\nimpl PyObjectProtocol for MyClass {\n    fn __str__(&self) -> &'static [u8] {\n        b\"hello, world\"\n    }\n}\n\n#[pyproto]\nimpl PyIterProtocol for MyClass {\n    fn __iter__(slf: PyRef<self>) -> PyResult<&PyAny> {\n        PyString::new(slf.py(), \"hello, world\").iter()\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyString;\n\n#[pyclass]\nstruct MyClass {}\n\n#[pymethods]\nimpl MyClass {\n    fn __str__(&self) -> &'static [u8] {\n        b\"hello, world\"\n    }\n\n    fn __iter__(slf: PyRef<self>) -> PyResult<&PyAny> {\n        PyString::new(slf.py(), \"hello, world\").iter()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Working with PyCell for Reference Management in PyO3\nDESCRIPTION: Demonstrates the PyCell type introduced in PyO3 0.9 for enforcing Rust's reference rules. The example shows a class with a method that takes mutable references, which would raise a PyBorrowMutError when called incorrectly from Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_39\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n\n#[pyclass]\nstruct Names {\n    names: Vec<String>,\n}\n\n#[pymethods]\nimpl Names {\n    #[new]\n    fn new() -> Self {\n        Names { names: vec![] }\n    }\n    fn merge(&mut self, other: &mut Names) {\n        self.names.append(&mut other.names)\n    }\n}\n# Python::with_gil(|py| {\n#     let names = Py::new(py, Names::new()).unwrap();\n#     pyo3::py_run!(py, names, r\"\n#     try:\n#        names.merge(names)\n#        assert False, 'Unreachable'\n#     except RuntimeError as e:\n#        assert str(e) == 'Already borrowed'\n#     \");\n# })\n```\n\n----------------------------------------\n\nTITLE: Replacing IntoPyObject with IntoPy<PyObject> in Rust\nDESCRIPTION: Replaces the IntoPyObject trait with IntoPy<PyObject> for more flexible type conversions.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_39\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoPy<PyObject> for MyType { /* implementation */ }\n```\n\n----------------------------------------\n\nTITLE: Migrating FromPyObject Implementation to Bound API in Rust PyO3\nDESCRIPTION: Shows how to update a FromPyObject trait implementation from using extract with GIL Refs to extract_bound with the new Bound<T> API. This migration is required for PyO3 0.22+ compatibility.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'py> FromPyObject<'py> for MyType {\n    fn extract(obj: &'py PyAny) -> PyResult<Self> {\n        /* ... */\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'py> FromPyObject<'py> for MyType {\n    fn extract_bound(obj: &Bound<'py, PyAny>) -> PyResult<Self> {\n        /* ... */\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Working with BoundObject for Converting Different Types in PyO3\nDESCRIPTION: Demonstrates how to handle both Bound and Borrowed objects produced by the IntoPyObject trait. The example shows converting vectors of integers and booleans into Python objects, highlighting the different smart pointer types returned.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::IntoPyObject;\nuse pyo3::types::{PyBool, PyInt};\n\nlet ints: Vec<u32> = vec![1, 2, 3, 4];\nlet bools = vec![true, false, false, true];\n\nPython::with_gil(|py| {\n    let ints_as_pyint: Vec<Bound<'_, PyInt>> = ints\n        .iter()\n        .map(|x| Ok(x.into_pyobject(py)?))\n        .collect::<PyResult<_>>()\n        .unwrap();\n\n    let bools_as_pybool: Vec<Borrowed<'_, '_, PyBool>> = bools\n        .iter()\n        .map(|x| Ok(x.into_pyobject(py)?))\n        .collect::<PyResult<_>>()\n        .unwrap();\n});\n```\n\n----------------------------------------\n\nTITLE: IntoPy Implementation (After)\nDESCRIPTION: Updated implementation using IntoPy instead of FromPy after the conversion trait simplification in PyO3 0.12.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# #[allow(dead_code)]\nstruct MyPyObjectWrapper(PyObject);\n\n# #[allow(deprecated)]\nimpl IntoPy<PyObject> for MyPyObjectWrapper {\n    fn into_py(self, _py: Python<'_>) -> PyObject {\n        self.0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Module Access in PyO3 Functions\nDESCRIPTION: Example of using pass_module to access the containing module from within a PyO3 function implementation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyString;\n\n#[pyfunction]\n#[pyo3(pass_module)]\nfn pyfunction_with_module<'py>(\n    module: &Bound<'py, PyModule>,\n) -> PyResult<Bound<'py, PyString>> {\n    module.name()\n}\n\n#[pymodule]\nfn module_with_fn(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(pyfunction_with_module, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Native Module in Rust\nDESCRIPTION: This Rust code implements a Python native module named 'string_sum' with a function 'sum_as_string'. It demonstrates low-level FFI usage with pyo3-ffi, including module definition, method registration, and argument parsing.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/README.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::os::raw::{c_char, c_long};\nuse std::ptr;\n\nuse pyo3_ffi::*;\n\nstatic mut MODULE_DEF: PyModuleDef = PyModuleDef {\n    m_base: PyModuleDef_HEAD_INIT,\n    m_name: c_str!(\"string_sum\").as_ptr(),\n    m_doc: c_str!(\"A Python module written in Rust.\").as_ptr(),\n    m_size: 0,\n    m_methods: unsafe { METHODS as *const [PyMethodDef] as *mut PyMethodDef },\n    m_slots: std::ptr::null_mut(),\n    m_traverse: None,\n    m_clear: None,\n    m_free: None,\n};\n\nstatic mut METHODS: &[PyMethodDef] = &[\n    PyMethodDef {\n        ml_name: c_str!(\"sum_as_string\").as_ptr(),\n        ml_meth: PyMethodDefPointer {\n            PyCFunctionFast: sum_as_string,\n        },\n        ml_flags: METH_FASTCALL,\n        ml_doc: c_str!(\"returns the sum of two integers as a string\").as_ptr(),\n    },\n    PyMethodDef::zeroed(),\n];\n\n#[allow(non_snake_case)]\n#[no_mangle]\npub unsafe extern \"C\" fn PyInit_string_sum() -> *mut PyObject {\n    let module = PyModule_Create(ptr::addr_of_mut!(MODULE_DEF));\n    if module.is_null() {\n        return module;\n    }\n    #[cfg(Py_GIL_DISABLED)]\n    {\n        if PyUnstable_Module_SetGIL(module, Py_MOD_GIL_NOT_USED) < 0 {\n            Py_DECREF(module);\n            return std::ptr::null_mut();\n        }\n    }\n    module\n}\n\nunsafe fn parse_arg_as_i32(obj: *mut PyObject, n_arg: usize) -> Option<i32> {\n    if PyLong_Check(obj) == 0 {\n        let msg = format!(\n            \"sum_as_string expected an int for positional argument {}\\0\",\n            n_arg\n        );\n        PyErr_SetString(PyExc_TypeError, msg.as_ptr().cast::<c_char>());\n        return None;\n    }\n\n    let mut overflow = 0;\n    let i_long: c_long = PyLong_AsLongAndOverflow(obj, &mut overflow);\n\n    #[allow(irrefutable_let_patterns)]\n    if overflow != 0 {\n        raise_overflowerror(obj);\n        None\n    } else if let Ok(i) = i_long.try_into() {\n        Some(i)\n    } else {\n        raise_overflowerror(obj);\n        None\n    }\n}\n\nunsafe fn raise_overflowerror(obj: *mut PyObject) {\n    let obj_repr = PyObject_Str(obj);\n    if !obj_repr.is_null() {\n        let mut size = 0;\n        let p = PyUnicode_AsUTF8AndSize(obj_repr, &mut size);\n        if !p.is_null() {\n            let s = std::str::from_utf8_unchecked(std::slice::from_raw_parts(\n                p.cast::<u8>(),\n                size as usize,\n            ));\n            let msg = format!(\"cannot fit {} in 32 bits\\0\", s);\n\n            PyErr_SetString(PyExc_OverflowError, msg.as_ptr().cast::<c_char>());\n        }\n        Py_DECREF(obj_repr);\n    }\n}\n\npub unsafe extern \"C\" fn sum_as_string(\n    _self: *mut PyObject,\n    args: *mut *mut PyObject,\n    nargs: Py_ssize_t,\n) -> *mut PyObject {\n    if nargs != 2 {\n        PyErr_SetString(\n            PyExc_TypeError,\n            c_str!(\"sum_as_string expected 2 positional arguments\").as_ptr(),\n        );\n        return std::ptr::null_mut();\n    }\n\n    let (first, second) = (*args, *args.add(1));\n\n    let first = match parse_arg_as_i32(first, 1) {\n        Some(x) => x,\n        None => return std::ptr::null_mut(),\n    };\n    let second = match parse_arg_as_i32(second, 2) {\n        Some(x) => x,\n        None => return std::ptr::null_mut(),\n    };\n\n    match first.checked_add(second) {\n        Some(sum) => {\n            let string = sum.to_string();\n            PyUnicode_FromStringAndSize(string.as_ptr().cast::<c_char>(), string.len() as isize)\n        }\n        None => {\n            PyErr_SetString(\n                PyExc_OverflowError,\n                c_str!(\"arguments too large to add\").as_ptr(),\n            );\n            std::ptr::null_mut()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Python Async Function Example\nDESCRIPTION: Example of a simple async Python function that sleeps for 1 second.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Sleep for 1 second\nasync def py_sleep():\n    await asyncio.sleep(1)\n```\n\n----------------------------------------\n\nTITLE: Converting Heterogeneous Python Types to Vec<Py<PyAny>> Using BoundObject\nDESCRIPTION: Shows a generic function to convert vectors of different Rust types into a unified Vec<Py<PyAny>> for Python interoperability. The example utilizes BoundObject trait methods like into_any() and unbind() to handle type conversion regardless of whether the source is Bound or Borrowed.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::BoundObject;\n# use pyo3::IntoPyObject;\n\n# let bools = vec![true, false, false, true];\n# let ints = vec![1, 2, 3, 4];\n\nfn convert_to_vec_of_pyobj<'py, T>(py: Python<'py>, the_vec: Vec<T>) -> PyResult<Vec<Py<PyAny>>>\nwhere\n   T: IntoPyObject<'py> + Copy\n{\n    the_vec.iter()\n        .map(|x| {\n            Ok(\n                // Note: the below is equivalent to `x.into_py_any()`\n                // from the `IntoPyObjectExt` trait\n                x.into_pyobject(py)\n                .map_err(Into::into)?\n                .into_any()\n                .unbind()\n            )\n        })\n        .collect()\n}\n\nlet vec_of_pyobjs: Vec<Py<PyAny>> = Python::with_gil(|py| {\n    let mut bools_as_pyany = convert_to_vec_of_pyobj(py, bools).unwrap();\n    let mut ints_as_pyany = convert_to_vec_of_pyobj(py, ints).unwrap();\n    let mut result: Vec<Py<PyAny>> = vec![];\n    result.append(&mut bools_as_pyany);\n    result.append(&mut ints_as_pyany);\n    result\n});\n```\n\n----------------------------------------\n\nTITLE: Tracing OpenAI SDK with LangSmith\nDESCRIPTION: TypeScript code showing how to wrap OpenAI SDK with LangSmith for tracing completions and chat completions.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { OpenAI } from \"openai\";\nimport { wrapOpenAI } from \"langsmith/wrappers\";\n\nconst openai = wrapOpenAI(new OpenAI());\n\nawait openai.chat.completions.create({\n  model: \"gpt-3.5-turbo\",\n  messages: [{ content: \"Hi there!\", role: \"user\" }],\n});\n```\n\n----------------------------------------\n\nTITLE: Removing ObjectProtocol After Migration in Rust PyO3\nDESCRIPTION: Demonstrates code migration after ObjectProtocol was removed from PyO3. All methods were moved to PyAny and native types implement Deref<Target=PyAny>, making the removal of ObjectProtocol import the only necessary change.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_37\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::ObjectProtocol;\n\n# pyo3::Python::with_gil(|py| {\nlet obj = py.eval(\"lambda: 'Hi :)'$\", None, None).unwrap();\nlet hi: &pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();\nassert_eq!(hi.len().unwrap(), 5);\n# })\n```\n\nLANGUAGE: rust\nCODE:\n```\n# pyo3::Python::with_gil(|py| {\nlet obj = py.eval(\"lambda: 'Hi :)'$\", None, None).unwrap();\nlet hi: &pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();\nassert_eq!(hi.len().unwrap(), 5);\n# })\n```\n\n----------------------------------------\n\nTITLE: Using gc parameter in pyclass macro in Rust\nDESCRIPTION: Demonstrates the use of the 'gc' parameter in the pyclass macro, which now requires implementing the PyGCProtocol trait.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_36\n\nLANGUAGE: Rust\nCODE:\n```\n#[pyclass(gc)]\n```\n\n----------------------------------------\n\nTITLE: Implementing py_run! macro in Rust\nDESCRIPTION: Adds a new 'py_run!' macro to execute Python code within Rust.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_33\n\nLANGUAGE: Rust\nCODE:\n```\npy_run!(\"python_code_here\")\n```\n\n----------------------------------------\n\nTITLE: Updating PySequenceProtocol Implementation for PyO3\nDESCRIPTION: Shows how to update protocol implementations that previously took &T or &mut T parameters to use PyRef and PyRefMut. This change is necessary due to updates in PyO3's FromPyObject implementation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_42\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::class::PySequenceProtocol;\n#[pyclass]\nstruct ByteSequence {\n    elements: Vec<u8>,\n}\n#[pyproto]\nimpl PySequenceProtocol for ByteSequence {\n    fn __concat__(&self, other: &Self) -> PyResult<Self> {\n        let mut elements = self.elements.clone();\n        elements.extend_from_slice(&other.elements);\n        Ok(Self { elements })\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::class::PySequenceProtocol;\n#[pyclass]\nstruct ByteSequence {\n    elements: Vec<u8>,\n}\n#[pyproto]\nimpl PySequenceProtocol for ByteSequence {\n    fn __concat__(&self, other: PyRef<'p, Self>) -> PyResult<Self> {\n        let mut elements = self.elements.clone();\n        elements.extend_from_slice(&other.elements);\n        Ok(Self { elements })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Thread-Safe PyClass Implementation\nDESCRIPTION: Updated implementation of a Python class using thread-safe types to satisfy the Send requirement introduced in PyO3 0.11.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\nuse pyo3::prelude::*;\nuse std::sync::{Arc, Mutex};\n\n#[pyclass]\nstruct ThreadSafe {\n    shared_bools: Arc<Mutex<Vec<bool>>>,\n    closure: Box<dyn Fn() + Send>,\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Integer Parsing with PyResult\nDESCRIPTION: Shows how to use the try operator (?) with PyResult for handling parsing errors directly.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/error-handling.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nfn parse_int(s: String) -> PyResult<usize> {\n    let x = s.parse()?;\n    Ok(x)\n}\n```\n\n----------------------------------------\n\nTITLE: FromPyObject for Transparent Types\nDESCRIPTION: Demonstrates transparent wrapper types using pyo3(transparent) attribute.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nstruct RustyTransparentTupleStruct(String);\n\n#[derive(FromPyObject)]\n#[pyo3(transparent)]\nstruct RustyTransparentStruct {\n    inner: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Tracing Arbitrary SDKs with LangSmith using Anthropic SDK\nDESCRIPTION: This example shows how to use the generic wrapSDK method from LangSmith to add tracing for arbitrary SDKs. It demonstrates tracing all methods in the Anthropic SDK, which is recommended for LLM calls only.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { wrapSDK } from \"langsmith/wrappers\";\nimport { Anthropic } from \"@anthropic-ai/sdk\";\n\nconst originalSDK = new Anthropic();\nconst sdkWithTracing = wrapSDK(originalSDK);\n\nconst response = await sdkWithTracing.messages.create({\n  messages: [\n    {\n      role: \"user\",\n      content: `What is 1 + 1? Respond only with \"2\" and nothing else.`,\n    },\n  ],\n  model: \"claude-3-sonnet-20240229\",\n  max_tokens: 1024,\n});\n```\n\n----------------------------------------\n\nTITLE: Using PyRef<T> in pyclass methods in Rust\nDESCRIPTION: Allows using PyRef<T> as the self parameter in pyclass methods.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_40\n\nLANGUAGE: Rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    fn my_method(slf: PyRef<Self>) { /* implementation */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Thread-Safe PyClass (Before)\nDESCRIPTION: Example of a Python class that doesn't implement Send, which became invalid in PyO3 0.11 due to thread safety requirements.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[pyclass]\nstruct NotThreadSafe {\n    shared_bools: Rc<RefCell<Vec<bool>>>,\n    closure: Box<dyn Fn()>,\n}\n```\n\n----------------------------------------\n\nTITLE: UTC Timezone Serialization with OPT_UTC_Z\nDESCRIPTION: Demonstrates how to serialize UTC timezone using Z suffix instead of +00:00 with OPT_UTC_Z option.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, datetime, zoneinfo\n>>> orjson.dumps(\n        datetime.datetime(1970, 1, 1, 0, 0, 0, tzinfo=zoneinfo.ZoneInfo(\"UTC\")),\n    )\nb'\"1970-01-01T00:00:00+00:00\"'\n>>> orjson.dumps(\n        datetime.datetime(1970, 1, 1, 0, 0, 0, tzinfo=zoneinfo.ZoneInfo(\"UTC\")),\n        option=orjson.OPT_UTC_Z\n    )\nb'\"1970-01-01T00:00:00Z\"'\n```\n\n----------------------------------------\n\nTITLE: PyO3 Nested Struct with Python Heap Allocation\nDESCRIPTION: Shows how to implement nested structs using Py<T> to store references on the Python heap.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/faq.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct Inner {/* fields omitted */}\n\n#[pyclass]\nstruct Outer {\n    inner: Py<Inner>,\n}\n\n#[pymethods]\nimpl Outer {\n    #[new]\n    fn __new__(py: Python<'_>) -> PyResult<Self> {\n        Ok(Self {\n            inner: Py::new(py, Inner {})?,\n        })\n    }\n\n    #[getter]\n    fn inner(&self, py: Python<'_>) -> Py<Inner> {\n        self.inner.clone_ref(py)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Ordering to Enum Variants in PyO3\nDESCRIPTION: Demonstrates how to implement ordering for enum variants using the #[pyo3(ord)] attribute. This requires implementing the PartialOrd trait and enables Python comparison operations like <, <=, >, and >=.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n#[pyclass(eq, ord)]\n#[derive(PartialEq, PartialOrd)]\nenum MyEnum{\n    A,\n    B,\n    C,\n}\n\nPython::with_gil(|py| {\n    let cls = py.get_type::<MyEnum>();\n    let a = Py::new(py, MyEnum::A).unwrap();\n    let b = Py::new(py, MyEnum::B).unwrap();\n    let c = Py::new(py, MyEnum::C).unwrap();\n    pyo3::py_run!(py, cls a b c, r#\"\n        assert (a < b) == True\n        assert (c <= b) == False\n        assert (c > a) == True\n    \"#)\n})\n```\n\n----------------------------------------\n\nTITLE: Using the Updated Exception Types\nDESCRIPTION: Examples demonstrating the reworked exception types in PyO3 0.12, which are now full types that can be interacted with like other PyO3 types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::{PyErr, PyResult, Python, type_object::PyTypeObject};\n# use pyo3::exceptions::{PyBaseException, PyTypeError};\n# Python::with_gil(|py| -> PyResult<()> {\nlet err: PyErr = PyTypeError::new_err(\"error message\");\n\n// Uses Display for PyErr, new for PyO3 0.12\nassert_eq!(err.to_string(), \"TypeError: error message\");\n\n// Now possible to interact with exception instances, new for PyO3 0.12\nlet instance: &PyBaseException = err.instance(py);\nassert_eq!(\n    instance.getattr(\"__class__\")?,\n    PyTypeError::type_object(py).as_ref()\n);\n# Ok(())\n# }).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Module Documentation Access in Python\nDESCRIPTION: Example showing how to access Rust documentation comments as Python docstrings.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/module.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport my_extension\n\nprint(my_extension.__doc__)\n```\n\n----------------------------------------\n\nTITLE: Required Arguments After Optional Arguments\nDESCRIPTION: Demonstrates the updated syntax for handling required arguments that appear after optional arguments using the signature attribute.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction]\n#[pyo3(signature = (x, y))] \nfn x_or_y(x: Option<u64>, y: u64) -> u64 {\n    x.unwrap_or(y)\n}\n```\n\n----------------------------------------\n\nTITLE: Omitting Microseconds in Datetime Serialization with Python orjson\nDESCRIPTION: Shows the usage of OPT_OMIT_MICROSECONDS option to exclude the microsecond field when serializing datetime.datetime and datetime.time instances.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, datetime\n>>> orjson.dumps(\n        datetime.datetime(1970, 1, 1, 0, 0, 0, 1),\n    )\nb'\"1970-01-01T00:00:00.000001\"'\n>>> orjson.dumps(\n        datetime.datetime(1970, 1, 1, 0, 0, 0, 1),\n        option=orjson.OPT_OMIT_MICROSECONDS,\n    )\nb'\"1970-01-01T00:00:00\"'\n```\n\n----------------------------------------\n\nTITLE: Omitting PyResult in getter and setter methods in Rust\nDESCRIPTION: Allows getter and setter methods to omit wrapping the result in PyResult if they don't raise exceptions.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_42\n\nLANGUAGE: Rust\nCODE:\n```\n#[getter]\nfn get_value(&self) -> i32 { /* implementation */ }\n```\n\n----------------------------------------\n\nTITLE: FFI Definition Example\nDESCRIPTION: Example of FFI function definition changes showing parameter type corrections\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_22\n\nLANGUAGE: Rust\nCODE:\n```\nPy_SetProgramName(*const) // Changed from *mut\nPy_SetPythonHome(*const) // Changed from *mut\n_PyLong_AsByteArray(*mut c_uchar) // Changed from *const c_uchar\n```\n\n----------------------------------------\n\nTITLE: Querying Python Platform Tag\nDESCRIPTION: Example commands showing how to query the platform tag from Python's sysconfig module, which is used for naming compiled extension modules.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# CPython 3.10 on macOS\n.cpython-310-darwin.so\n\n# PyPy 7.3 (Python 3.9) on Linux\n$ python -c 'import sysconfig; print(sysconfig.get_config_var(\"EXT_SUFFIX\"))'\n.pypy39-pp73-x86_64-linux-gnu.so\n```\n\n----------------------------------------\n\nTITLE: Adding Python Framework Link Arguments in Rust\nDESCRIPTION: This build.rs script adds the necessary linker arguments to link against the Python framework on macOS, which is useful when using the system Python installation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    pyo3_build_config::add_python_framework_link_args();\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Rust Host Application\nDESCRIPTION: Instructions for building and running the main Rust application which loads a Python plugin.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/plugin/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Thread Safety without Macro\nDESCRIPTION: Demonstrates how to manually configure a Python module for free-threading support without using the pymodule macro, by directly calling gil_used(false).\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/free-threading.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n# #[allow(dead_code)]\nfn register_child_module(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {\n    let child_module = PyModule::new(parent_module.py(), \"child_module\")?\n    child_module.gil_used(false)?;\n    parent_module.add_submodule(&child_module)\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Object Creation from PyRef to PyCell in PyO3\nDESCRIPTION: Shows how to update code that used PyRef::new and PyRefMut::new to the new PyCell::new pattern. PyCell provides a RefCell-like API for managing Rust's borrowing rules in Python objects.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_40\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# #[pyclass]\n# struct MyClass {}\n# Python::with_gil(|py| {\nlet obj_ref = PyRef::new(py, MyClass {}).unwrap();\n# })\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# #[pyclass]\n# struct MyClass {}\n# Python::with_gil(|py| {\nlet obj = PyCell::new(py, MyClass {}).unwrap();\nlet obj_ref = obj.borrow();\n# })\n```\n\n----------------------------------------\n\nTITLE: Indexing PyBytes like Vec<u8> in Rust\nDESCRIPTION: Allows indexing of PyBytes objects in the same way as Vec<u8>.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_34\n\nLANGUAGE: Rust\nCODE:\n```\nlet byte = py_bytes[index];\n```\n\n----------------------------------------\n\nTITLE: Implementing FromPyObject and IntoPy<PyObject> for Arrays in Rust\nDESCRIPTION: Implements FromPyObject and IntoPy<PyObject> traits for arrays up to size 32, allowing conversion between Rust arrays and Python lists.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_31\n\nLANGUAGE: Rust\nCODE:\n```\nImplement `FromPyObject` and `IntoPy<PyObject>` traits for arrays (up to 32).\n```\n\n----------------------------------------\n\nTITLE: Appending Newline in JSON Serialization with Python orjson\nDESCRIPTION: Demonstrates the use of OPT_APPEND_NEWLINE option to append a newline character to the JSON output. This is useful for the common pattern of adding a newline after serialization.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson\n>>> orjson.dumps([])\nb\"[]\"\n>>> orjson.dumps([], option=orjson.OPT_APPEND_NEWLINE)\nb\"[]\\n\"\n```\n\n----------------------------------------\n\nTITLE: Using Python Critical Section API\nDESCRIPTION: Adds a wrapper around the Python Critical Section API introduced in Python 3.13.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npyo3::sync::with_critical_section\n```\n\n----------------------------------------\n\nTITLE: Replacing PyByteArray::data with PyDataArray::to_vec in Rust\nDESCRIPTION: Replaces the potentially unsound PyByteArray::data method with PyDataArray::to_vec for safer byte array handling.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_37\n\nLANGUAGE: Rust\nCODE:\n```\nlet vec = py_data_array.to_vec();\n```\n\n----------------------------------------\n\nTITLE: Printing PyO3 Configuration Output\nDESCRIPTION: Example console output when running a PyO3 build with PYO3_PRINT_CONFIG=1 set, showing the configuration details including Python version, implementation, and build settings.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution.md#2025-04-22_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ PYO3_PRINT_CONFIG=1 cargo build\n   Compiling pyo3 v0.14.1 (/home/david/dev/pyo3)\nerror: failed to run custom build command for `pyo3 v0.14.1 (/home/david/dev/pyo3)`\n\nCaused by:\n  process didn't exit successfully: `/home/david/dev/pyo3/target/debug/build/pyo3-7a8cf4fe22e959b7/build-script-build` (exit status: 101)\n  --- stdout\n  cargo:rerun-if-env-changed=PYO3_CROSS\n  cargo:rerun-if-env-changed=PYO3_CROSS_LIB_DIR\n  cargo:rerun-if-env-changed=PYO3_CROSS_PYTHON_VERSION\n  cargo:rerun-if-env-changed=PYO3_PRINT_CONFIG\n\n  -- PYO3_PRINT_CONFIG=1 is set, printing configuration and halting compile --\n  implementation=CPython\n  version=3.8\n  shared=true\n  abi3=false\n  lib_name=python3.8\n  lib_dir=/usr/lib\n  executable=/usr/bin/python\n  pointer_width=64\n  build_flags=\n  suppress_build_script_link_lines=false\n```\n\n----------------------------------------\n\nTITLE: Disabling Default __contains__ Method in Rust PyO3\nDESCRIPTION: Demonstrates how to disable the default __contains__ method implementation for a PyO3 class in Rust. This is done by setting the __contains__ class attribute to None.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/protocols.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n\n#[pyclass]\nstruct NoContains {}\n\n#[pymethods]\nimpl NoContains {\n    #[classattr]\n    const __contains__: Option<PyObject> = None;\n}\n```\n\n----------------------------------------\n\nTITLE: Rust UserModel Wrapper Implementation\nDESCRIPTION: Rust wrapper struct and trait implementation to bridge Python model with Rust trait requirements.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/trait-bounds.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyList;\n\nstruct UserModel {\n    model: Py<PyAny>,\n}\n\nimpl Model for UserModel {\n    fn set_variables(&mut self, var: &Vec<f64>) {\n        println!(\"Rust calling Python to set the variables\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"set_variables\", (PyList::new(py, var).unwrap(),), None)\n                .unwrap();\n        })\n    }\n\n    fn get_results(&self) -> Vec<f64> {\n        println!(\"Rust calling Python to get the results\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"get_results\", (), None)\n                .unwrap()\n                .extract()\n                .unwrap()\n        })\n    }\n\n    fn compute(&mut self) {\n        println!(\"Rust calling Python to perform the computation\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"compute\", (), None)\n                .unwrap();\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Py::as_ref (After)\nDESCRIPTION: Updated pattern using the direct Py::as_ref method after the AsPyRef trait removal.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::{Py, types::PyList};\n# pyo3::Python::with_gil(|py| {\nlet list_py: Py<PyList> = PyList::empty(py).into();\nlet list_ref: &PyList = list_py.as_ref(py);\n# })\n```\n\n----------------------------------------\n\nTITLE: Adding module argument to pyclass macro in Rust\nDESCRIPTION: Adds a 'module' argument to the 'pyclass' macro, allowing specification of the Python module for a class.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_32\n\nLANGUAGE: Rust\nCODE:\n```\n#[pyclass(module = \"my_module\")]\n```\n\n----------------------------------------\n\nTITLE: Declaring Module Support for Free-Threaded Build\nDESCRIPTION: Adds an option to declare that a Python module supports the free-threaded build of Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[pymodule(gil_used = false)]\n```\n\n----------------------------------------\n\nTITLE: Adding Python marker to GILPool in Rust\nDESCRIPTION: Adds a Python marker to GILPool to prevent misuse in releasing Python objects without the GIL held.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_38\n\nLANGUAGE: Rust\nCODE:\n```\nlet gil_pool = GILPool::new();\n```\n\n----------------------------------------\n\nTITLE: Creating New PyO3 Projects with cargo-generate\nDESCRIPTION: Commands to install cargo-generate and use it to create a new project based on a PyO3 example. The user needs to replace <example> with the desired example name.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/<example>\n```\n\n----------------------------------------\n\nTITLE: Adding PyDict::get_item_with_error Method in Rust\nDESCRIPTION: Adds a new method get_item_with_error to PyDict for dictionary item retrieval with error handling.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\nPyDict::get_item_with_error\n```\n\n----------------------------------------\n\nTITLE: Defining Car Class in Python Stub File\nDESCRIPTION: Example of a Python stub file (.pyi) defining a Car class with its methods and docstrings. It includes type hints for parameters and return values, demonstrating how to provide type information for a PyO3-created class.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-typing-hints.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Car:\n    \"\"\"\n    A class representing a car.\n\n    :param body_type: the name of body type, e.g. hatchback, sedan\n    :param horsepower: power of the engine in horsepower\n    \"\"\"\n    def __init__(self, body_type: str, horsepower: int) -> None: ...\n\n    @classmethod\n    def from_unique_name(cls, name: str) -> 'Car':\n        \"\"\"\n        Creates a Car based on unique name\n\n        :param name: model name of a car to be created\n        :return: a Car instance with default data\n        \"\"\"\n\n    def best_color(self) -> str:\n        \"\"\"\n        Gets the best color for the car.\n\n        :return: the name of the color our great algorithm thinks is the best for this car\n        \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoIterator for PySet and PyFrozenSet in Rust\nDESCRIPTION: Implements the IntoIterator trait for PySet and PyFrozenSet types, allowing them to be used in Rust for loops.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_30\n\nLANGUAGE: Rust\nCODE:\n```\nImplemented `IntoIterator` for `PySet` and `PyFrozenSet`.\n```\n\n----------------------------------------\n\nTITLE: Implementing Deref<Target = PyAny> for Builtin Types in Rust\nDESCRIPTION: Implements Deref<Target = PyAny> for all builtin types like PyList, PyTuple, PyDict, etc., allowing them to be dereferenced to PyAny.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\nImplement `Deref<Target = PyAny>` for all builtin types. (`PyList`, `PyTuple`, `PyDict` etc.)\n```\n\n----------------------------------------\n\nTITLE: Implementing ExactSizeIterator for PyListIterator in Rust\nDESCRIPTION: Implements the ExactSizeIterator trait for PyListIterator, PyDictIterator, PySetIterator and PyFrozenSetIterator, providing exact size information for these iterators.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\nimpl ExactSizeIterator for PyListIterator\n```\n\n----------------------------------------\n\nTITLE: Implementing Clone for PyObject and Py<T> in Rust\nDESCRIPTION: Implements the Clone trait for PyObject and Py<T> types, allowing them to be cloned.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\nImplement `Clone` for `PyObject` and `Py<T>`.\n```\n\n----------------------------------------\n\nTITLE: PyTuple Creation - Legacy vs New API\nDESCRIPTION: Examples showing the old and new ways to create PyTuple objects after the removal of the gil-refs feature.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet tup = PyTuple::new_bound(py, [1, 2, 3]);\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet tup = PyTuple::new(py, [1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Running Maturin Init for PyO3 Project\nDESCRIPTION: Interactive command for initializing a new PyO3 project using maturin. Shows the selection of PyO3 bindings during project creation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ maturin init\n  What kind of bindings to use?  pyo3\n   Done! New project created string_sum\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Embedding Python in Rust\nDESCRIPTION: Cargo.toml configuration for embedding Python in a Rust application. Specifies PyO3 dependency with auto-initialize feature for automatic Python interpreter setup.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/README.md#2025-04-22_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.pyo3]\nversion = \"0.23.4\"\nfeatures = [\"auto-initialize\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoPy<PyObject> for PyRef and PyRefMut in Rust\nDESCRIPTION: Implements the IntoPy<PyObject> trait for PyRef and PyRefMut types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_35\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoPy<PyObject> for PyRef { /* implementation */ }\n```\n\n----------------------------------------\n\nTITLE: Error Traceback for Integer Overflow\nDESCRIPTION: Error message showing what happens without proper overflow handling when trying to construct a Number with a large integer value.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nTraceback (most recent call last):\n  File \"example.py\", line 3, in <module>\n    n = Number(1 << 1337)\nOverflowError: Python int too large to convert to C long\n```\n\n----------------------------------------\n\nTITLE: Implementing PyFunctionArgument for Immutable References\nDESCRIPTION: Implementation of PyFunctionArgument for immutable references to MyClass. This enables extracting MyClass instances from Python objects when passed as function arguments.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a, 'py> pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a MyClass\n{\n    type Holder = ::std::option::Option<pyo3::PyRef<'py, MyClass>>;\n\n    #[inline]\n    fn extract(obj: &'a pyo3::Bound<'py, PyAny>, holder: &'a mut Self::Holder) -> pyo3::PyResult<Self> {\n        pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PyClassImpl for Python Class Configuration\nDESCRIPTION: Comprehensive implementation of the PyClassImpl trait that configures the Python class behavior. This includes type relationships, thread safety, attribute accessibility, and documentation generation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\nimpl pyo3::impl_::pyclass::PyClassImpl for MyClass {\n    const IS_BASETYPE: bool = false;\n    const IS_SUBCLASS: bool = false;\n    const IS_MAPPING: bool = false;\n    const IS_SEQUENCE: bool = false;\n    type BaseType = PyAny;\n    type ThreadChecker = pyo3::impl_::pyclass::SendablePyClass<MyClass>;\n    type PyClassMutability = <<pyo3::PyAny as pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as pyo3::impl_::pycell::PyClassMutability>::MutableChild;\n    type Dict = pyo3::impl_::pyclass::PyClassDummySlot;\n    type WeakRef = pyo3::impl_::pyclass::PyClassDummySlot;\n    type BaseNativeType = pyo3::PyAny;\n\n    fn items_iter() -> pyo3::impl_::pyclass::PyClassItemsIter {\n        use pyo3::impl_::pyclass::*;\n        let collector = PyClassImplCollector::<MyClass>::new();\n        static INTRINSIC_ITEMS: PyClassItems = PyClassItems { slots: &[], methods: &[] };\n        PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())\n    }\n\n    fn lazy_type_object() -> &'static pyo3::impl_::pyclass::LazyTypeObject<MyClass> {\n        use pyo3::impl_::pyclass::LazyTypeObject;\n        static TYPE_OBJECT: LazyTypeObject<MyClass> = LazyTypeObject::new();\n        &TYPE_OBJECT\n    }\n\n    fn doc(py: Python<'_>) -> pyo3::PyResult<&'static ::std::ffi::CStr> {\n        use pyo3::impl_::pyclass::*;\n        static DOC: pyo3::sync::GILOnceCell<::std::borrow::Cow<'static, ::std::ffi::CStr>> = pyo3::sync::GILOnceCell::new();\n        DOC.get_or_try_init(py, || {\n            let collector = PyClassImplCollector::<Self>::new();\n            build_pyclass_doc(<MyClass as pyo3::PyTypeInfo>::NAME, pyo3::ffi::c_str!(\"\"), collector.new_text_signature())\n        }).map(::std::ops::Deref::deref)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Python List Operations Example in Python\nDESCRIPTION: Example showing basic Python list operations including creation, appending, and reference handling.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/types.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef example():\n    x = list()   # create a Python list\n    x.append(1)  # append the integer 1 to it\n    y = x        # create a second reference to the list\n    del x        # delete the original reference\n```\n\n----------------------------------------\n\nTITLE: PyO3 Capsule Type Updates\nDESCRIPTION: Changes to PyCapsule API including new constructor parameters and updated method signatures.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_18\n\nLANGUAGE: Rust\nCODE:\n```\nPyCapsule::new(name: Option<CString>)\nPyCapsule::new_with_destructor(name: Option<CString>, destructor: F) where F: Send\nPyCapsule::context() -> Context \nPyCapsule::set_context(context: Context)\nPyCapsule::name() -> PyResult<Option<&CStr>>\n```\n\n----------------------------------------\n\nTITLE: Initializing Number Object with Overflow Handling in Python\nDESCRIPTION: Example showing how Number class handles large integer values. This demonstrates the need for overflow handling in the Rust implementation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom my_module import Number\n\nn = Number(1 << 1337)\n```\n\n----------------------------------------\n\nTITLE: Running PyO3 Tests\nDESCRIPTION: Commands to run various test suites for PyO3 using Nox and Cargo.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nnox -s test\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo test\n```\n\nLANGUAGE: shell\nCODE:\n```\nnox -f pytests/noxfile.py -s test\n```\n\n----------------------------------------\n\nTITLE: Adding PyModule_Add Function Declaration for Python 3.13\nDESCRIPTION: Adds FFI binding declaration for PyModule_Add function that will be available in Python 3.13. The function allows adding values to Python modules with a name and value parameter.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3-info.txt#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(Py_3_13)]\npub fn PyModule_Add(\n    module: *mut PyObject,\n    name: *const c_char,\n    value: *mut PyObject,\n) -> core::ffi::c_int;\n```\n\n----------------------------------------\n\nTITLE: Module Privacy Rules in PyO3\nDESCRIPTION: Examples showing incorrect and correct implementations of module privacy rules in PyO3 0.16+.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    use pyo3::prelude::*;\n\n    #[pymodule]\n    fn private_submodule(_py: Python<'_>, m: &PyModule) -> PyResult<()> {\n        Ok(())\n    }\n}\n\nuse pyo3::prelude::*;\nuse foo::*;\n\n#[pymodule]\nfn my_module(_py: Python<'_>, m: &PyModule) -> PyResult<()> {\n    m.add_wrapped(wrap_pymodule!(private_submodule))?;\n    Ok(())\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    use pyo3::prelude::*;\n\n    #[pymodule]\n    pub(crate) fn private_submodule(_py: Python<'_>, m: &PyModule) -> PyResult<()> {\n        Ok(())\n    }\n}\n\nuse pyo3::prelude::*;\nuse pyo3::wrap_pymodule;\nuse foo::*;\n\n#[pymodule]\nfn my_module(_py: Python<'_>, m: &PyModule) -> PyResult<()> {\n    m.add_wrapped(wrap_pymodule!(private_submodule))?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Testing PyO3 Module with Maturin\nDESCRIPTION: Basic setup commands for installing maturin, building the module, and running tests with pytest\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pytests/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\nmaturin develop\npytest\n```\n\n----------------------------------------\n\nTITLE: Implementing a Model class in Python with incorrect return type\nDESCRIPTION: A Python Model class that sets variables, computes results, and returns them. The get_results method has an incorrect return type (returning a single value instead of a list), which will cause errors when called from Rust code.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/trait-bounds.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Model:\n    def set_variables(self, inputs):\n        self.inputs = inputs\n    def compute(self):\n        self.results = [elt**2 -3 for elt in self.inputs]\n    def get_results(self):\n        return self.results[0]\n        #return self.results <-- this is the expected output\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoPy<PyObject> for HashSet and BTreeSet in Rust\nDESCRIPTION: Implements the IntoPy<PyObject> trait for HashSet and BTreeSet types, allowing them to be converted into Python objects.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\nImplement `IntoPy<PyObject>` for `HashSet` and `BTreeSet`.\n```\n\n----------------------------------------\n\nTITLE: Implementing PyTypeInfo for Python Type System Integration\nDESCRIPTION: Unsafe implementation of the PyTypeInfo trait that provides essential type metadata for Python. This includes the class name, module information, and type object retrieval functionality.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nunsafe impl pyo3::type_object::PyTypeInfo for MyClass {\n    const NAME: &'static str = \"MyClass\";\n    const MODULE: ::std::option::Option<&'static str> = ::std::option::Option::None;\n    #[inline]\n    fn type_object_raw(py: pyo3::Python<'_>) -> *mut pyo3::ffi::PyTypeObject {\n        <Self as pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()\n            .get_or_init(py)\n            .as_type_ptr()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Python-Compatible Rust Struct with PyO3\nDESCRIPTION: Basic Rust struct definition with PyO3 annotations. The struct has a single numeric field and includes the necessary dead_code attribute to prevent warnings about unused fields.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\n# #[allow(dead_code)]\nstruct MyClass {\n    # #[allow(dead_code)]\n    num: i32,\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating PyList with Critical Section Lock in Free-Threaded Build\nDESCRIPTION: Adds a method to iterate over a PyList using a critical section lock in the free-threaded build of Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nPyList::locked_for_each\n```\n\n----------------------------------------\n\nTITLE: Using PyBackedStr Type with PyO3\nDESCRIPTION: Demonstrates how to use PyBackedStr type to handle Python strings without lifetime management in PyO3, particularly useful for abi3 builds on Python versions older than 3.10.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::{PyList, PyType};\nuse pyo3::pybacked::PyBackedStr;\n\nlet obj: Bound<'py, PyType> = py.get_type_bound::<PyList>();\nlet name: PyBackedStr = obj.getattr(\"__name__\")?.extract()?;\nassert_eq!(&*name, \"list\");\n```\n\n----------------------------------------\n\nTITLE: Running Clippy Lints for PyO3\nDESCRIPTION: Command to run Clippy lints on all PyO3 code using Nox.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nnox -s clippy-all\n```\n\n----------------------------------------\n\nTITLE: Implementing PyFunctionArgument for Mutable References\nDESCRIPTION: Implementation of PyFunctionArgument for mutable references to MyClass. This allows MyClass instances to be modified when passed as arguments to Rust functions from Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a, 'py> pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a mut MyClass\n{\n    type Holder = ::std::option::Option<pyo3::PyRefMut<'py, MyClass>>;\n\n    #[inline]\n    fn extract(obj: &'a pyo3::Bound<'py, PyAny>, holder: &'a mut Self::Holder) -> pyo3::PyResult<Self> {\n        pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating PyTryFrom to PyTypeCheck Pattern in Rust\nDESCRIPTION: Example showing migration from deprecated PyTryFrom trait usage to the new PyTypeCheck approach for type casting in PyO3. The new approach uses downcast() method instead of try_from().\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nPython::with_gil(|py| {\n    let list = PyList::new(py, 0..5);\n    let b = <PyInt as PyTryFrom>::try_from(list.get_item(0).unwrap())?;\n    Ok(())\n})\n```\n\nLANGUAGE: rust\nCODE:\n```\nPython::with_gil(|py| {\n    // Note that PyList::new is deprecated for PyList::new_bound as part of the GIL Refs API removal,\n    // see the section below on migration to Bound<T>.\n    #[allow(deprecated)]\n    let list = PyList::new(py, 0..5);\n    let b = list.get_item(0).unwrap().downcast::<PyInt>()?;\n    Ok(())\n})\n```\n\n----------------------------------------\n\nTITLE: Building and Testing PyO3 Project with Maturin\nDESCRIPTION: These commands install development dependencies, build the project, and run tests using Maturin and pytest.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/decorator/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-dev.txt\nmaturin develop\npytest\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin for Python Extension Building\nDESCRIPTION: Command to install maturin, which is required for building the Python extension module from Rust code.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/plugin/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: Adding GILOnceCell::get_or_try_init for Fallible Initialization in Rust\nDESCRIPTION: Adds a new method get_or_try_init to GILOnceCell for fallible initialization, allowing for error handling during cell initialization.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\nGILOnceCell::get_or_try_init\n```\n\n----------------------------------------\n\nTITLE: Setting Up build.rs for PyO3 Configurations\nDESCRIPTION: Code for a build.rs file that enables the pyo3-build-config flags for conditional compilation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution/multiple-python-versions.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // If you have an existing build.rs file, just add this line to it.\n    pyo3_build_config::use_pyo3_cfgs();\n}\n```\n\n----------------------------------------\n\nTITLE: Unsendable PyClass (Before)\nDESCRIPTION: Example of a Python class that cannot implement Send, which became invalid in PyO3 0.11.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct Unsendable {\n    pointers: Vec<*mut std::os::raw::c_char>,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies for Tokio Runtime\nDESCRIPTION: Cargo.toml configuration for setting up PyO3 with tokio runtime support.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n# Cargo.toml dependencies\n[dependencies]\npyo3 = { version = \"0.14\" }\npyo3-asyncio = { version = \"0.14\", features = [\"attributes\", \"tokio-runtime\"] }\ntokio = \"1.4\"\n```\n\n----------------------------------------\n\nTITLE: Function Attribute Example\nDESCRIPTION: Example showing module passing attribute syntax for Python functions\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\n#[pyfunction(pass_module)]\n#[pyfn(pass_module)]\n```\n\n----------------------------------------\n\nTITLE: Using ChatOpenAI with LangChain\nDESCRIPTION: TypeScript code demonstrating how to use ChatOpenAI model from LangChain with automatic LangSmith tracing.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ChatOpenAI } from \"langchain/chat_models/openai\";\n\nconst chat = new ChatOpenAI({ temperature: 0 });\nconst response = await chat.predict(\n  \"Translate this sentence from English to French. I love programming.\"\n);\nconsole.log(response);\n```\n\n----------------------------------------\n\nTITLE: FromPy Implementation (Before)\nDESCRIPTION: Example of the deprecated FromPy trait implementation which was removed in PyO3 0.12 in favor of IntoPy.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\nstruct MyPyObjectWrapper(PyObject);\n\nimpl FromPy<MyPyObjectWrapper> for PyObject {\n    fn from_py(other: MyPyObjectWrapper, _py: Python<'_>) -> Self {\n        other.0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin Package Builder\nDESCRIPTION: Command to install maturin Python package builder using pip\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/examples/sequential/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: Non-Collation Aware Sorting in Orjson\nDESCRIPTION: Shows how orjson handles special characters in key sorting, demonstrating that sorting is not collation/locale-aware.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson\n>>> orjson.dumps({\"a\": 1, \"\": 2, \"A\": 3}, option=orjson.OPT_SORT_KEYS)\nb'{\"A\":3,\"a\":1,\"\\xc3\\xa4\":2}'\n```\n\n----------------------------------------\n\nTITLE: PyO3 GIL Management Functions\nDESCRIPTION: Unsafe variant of the GIL management API that allows obtaining a Python token in scenarios where the standard API would fail.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_21\n\nLANGUAGE: Rust\nCODE:\n```\nPython::with_gil_unchecked\n```\n\n----------------------------------------\n\nTITLE: OpenAI API Response Example\nDESCRIPTION: Example response structure from the OpenAI chat completions API showing the format of returned data including message content, usage statistics, and metadata.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/README.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  id: 'chatcmpl-8sOWEOYVyehDlyPcBiaDtTxWvr9v6',\n  object: 'chat.completion',\n  created: 1707974654,\n  model: 'gpt-3.5-turbo-0613',\n  choices: [\n    {\n      index: 0,\n      message: { role: 'assistant', content: 'Hello! How can I help you today?' },\n      logprobs: null,\n      finish_reason: 'stop'\n    }\n  ],\n  usage: { prompt_tokens: 10, completion_tokens: 9, total_tokens: 19 },\n  system_fingerprint: null\n}\n```\n\n----------------------------------------\n\nTITLE: Updated Function Signature Syntax\nDESCRIPTION: Shows the new way to specify function signatures in PyO3 0.20+ after removal of deprecated function forms.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction]\n#[pyo3(signature = (a, b=0, /))]\nfn add(a: u64, b: u64) -> u64 {\n    a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Between GIL Refs and Bound<T> in Rust PyO3\nDESCRIPTION: Demonstrates how to convert between a GIL reference (&PyAny) and a borrowed Bound reference (&Bound<PyAny>) using the as_borrowed() method.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet gil_ref: &PyAny = ...;\nlet bound: &Bound<PyAny> = &gil_ref.as_borrowed();\n```\n\n----------------------------------------\n\nTITLE: PyO3 API Methods Return Type Changes\nDESCRIPTION: Method signature changes showing updates to PyList, PyTuple and PySequence APIs to use usize indices and return PyResult types instead of panicking.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_19\n\nLANGUAGE: Rust\nCODE:\n```\nPyList::get_item() -> PyResult<&PyAny>\nPyTuple::get_item() -> PyResult<&PyAny>\nPySequence::in_place_repeat() -> PyResult<&PySequence>\nPySequence::in_place_concat() -> PyResult<&PySequence>\nPySequence::get_slice() -> PyResult<&PySequence>\n```\n\n----------------------------------------\n\nTITLE: Adding CompareOp::matches Method in Rust\nDESCRIPTION: Adds a matches method to CompareOp to implement __richcmp__ as the result of a Rust std::cmp::Ordering comparison.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\nCompareOp::matches\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Windows Package Dependencies\nDESCRIPTION: Specifies required Python packages with system platform constraints that exclude Windows. Includes Flask web framework, Gunicorn WSGI server, and HTTPX HTTP client version 0.24.1.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/integration/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: requirements.txt\nCODE:\n```\nflask;sys_platform!=\"win\"\ngunicorn;sys_platform!=\"win\"\nhttpx==0.24.1;sys_platform!=\"win\"\n```\n\n----------------------------------------\n\nTITLE: Generating Project from Template\nDESCRIPTION: Commands to install cargo-generate and create a new project from the PyO3 sequential example template\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/examples/sequential/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/sequential\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nox\nDESCRIPTION: Shell command to run tests using Nox. Nox should be installed globally before running this command.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/word-count/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Defining Exception Classes in Python Stub File\nDESCRIPTION: Example of how to define exception classes in a Python stub file (.pyi). It shows the structure for BaseException, SystemExit, Exception, and StopIteration classes with their attributes and methods.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-typing-hints.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass BaseException(object):\n    args: Tuple[Any, ...]\n    __cause__: BaseException | None\n    __context__: BaseException | None\n    __suppress_context__: bool\n    __traceback__: TracebackType | None\n    def __init__(self, *args: object) -> None: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def with_traceback(self: _TBE, tb: TracebackType | None) -> _TBE: ...\n\nclass SystemExit(BaseException):\n    code: int\n\nclass Exception(BaseException): ...\n\nclass StopIteration(Exception):\n    value: Any\n```\n\n----------------------------------------\n\nTITLE: PyO3 Array Type Implementation\nDESCRIPTION: Implementation of IntoPy trait for fixed-size arrays requiring T: IntoPy instead of T: ToPyObject.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_17\n\nLANGUAGE: Rust\nCODE:\n```\nimpl<T, const N: usize> IntoPy<PyObject> for [T; N] where T: IntoPy\n```\n\n----------------------------------------\n\nTITLE: Cross-Compilation with Python Version Specification\nDESCRIPTION: Shell commands showing cross-compilation setup with explicit Python version specification for multiple Python installations.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution.md#2025-04-22_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nexport PYO3_CROSS_PYTHON_VERSION=3.8\nexport PYO3_CROSS_LIB_DIR=\"/home/pyo3/cross/sysroot/usr/lib\"\n\ncargo build --target armv7-unknown-linux-gnueabihf\n```\n\n----------------------------------------\n\nTITLE: Building orjson Package with Maturin\nDESCRIPTION: Command for building the orjson package using maturin with release optimization and binary stripping. This is the recommended build command for packaging orjson.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_22\n\nLANGUAGE: sh\nCODE:\n```\nmaturin build --release --strip\n```\n\n----------------------------------------\n\nTITLE: Expanding PyO3 Macros in Rust\nDESCRIPTION: This command expands PyO3's procedural macros and other macros, allowing developers to view the generated source code. It requires the nightly build of Rust.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/debugging.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo rustc --profile=check -- -Z unstable-options --pretty=expanded > expanded.rs; rustfmt expanded.rs\n```\n\n----------------------------------------\n\nTITLE: PyClass Initializer Pattern\nDESCRIPTION: Example of an unsafe pattern using PyClassInitializer that now triggers a panic when attempting to add a subclass to an existing base class instance.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\nPyClassInitializer::from(Py<BaseClass>).add_subclass(SubClass)\n```\n\n----------------------------------------\n\nTITLE: Rust Native Extension with UVLoop Support\nDESCRIPTION: Configuration and implementation of a Rust native extension supporting uvloop.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\n[lib]\nname = \"my_async_module\"\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npyo3 = { version = \"0.14\", features = [\"extension-module\"] }\npyo3-asyncio = { version = \"0.14\", features = [\"tokio-runtime\"] }\nasync-std = \"1.9\"\ntokio = \"1.4\"\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::{prelude::*, wrap_pyfunction};\n\n#[pyfunction]\nfn rust_sleep(py: Python<'_>) -> PyResult<&Bound<'_, PyAny>> {\n    pyo3_asyncio::tokio::future_into_py(py, async {\n        tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n        Ok(Python::with_gil(|py| py.None()))\n    })\n}\n\n#[pymodule]\nfn my_async_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(rust_sleep, m)?)?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Byte Collection Conversion Examples\nDESCRIPTION: Examples showing how byte collections are converted to Python objects, demonstrating the difference between Vec<u8> converting to PyBytes and Vec<u16> converting to PyList.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction]\nfn foo() -> Vec<u8> {\n    vec![0, 1, 2, 3]\n}\n\n#[pyfunction]\nfn bar() -> Vec<u16> {\n    vec![0, 1, 2, 3]\n}\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks with Nox\nDESCRIPTION: Shell command to run benchmarks using Nox. This requires Nox to be installed globally.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/word-count/README.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnox -s bench\n```\n\n----------------------------------------\n\nTITLE: PyO3 Feature Flag Definition\nDESCRIPTION: Conditional compilation flag to disable reference pool functionality for performance optimization at the cost of known limitations.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\npyo3_disable_reference_pool\n```\n\n----------------------------------------\n\nTITLE: Disabling PyO3 Function Signature in Rust\nDESCRIPTION: This Rust code snippet demonstrates how to disable the automatic signature generation in PyO3 using the #[pyo3(text_signature = None)] attribute. It defines a function 'add' with a custom signature and no text signature.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/signature.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n/// This function adds two unsigned 64-bit integers.\n#[pyfunction]\n#[pyo3(signature = (a, b=0, /), text_signature = None)]\nfn add(a: u64, b: u64) -> u64 {\n    a + b\n}\n#\n# fn main() -> PyResult<()> {\n#     Python::with_gil(|py| {\n#         let fun = pyo3::wrap_pyfunction!(add, py)?;\n#\n#         let doc: String = fun.getattr(\"__doc__\")?.extract()?;\n#         assert_eq!(doc, \"This function adds two unsigned 64-bit integers.\");\n#         assert!(fun.getattr(\"__text_signature__\")?.is_none());\n#\n#         Ok(())\n#     })\n# }\n```\n\n----------------------------------------\n\nTITLE: Converting from PyErr to PyResult (After)\nDESCRIPTION: Updated example showing how to create a PyResult containing an error after the PyErr changes in PyO3 0.12, using the new exception types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::{PyResult, exceptions::PyTypeError};\nlet result: PyResult<()> = Err(PyTypeError::new_err(\"error message\"));\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies Requirements\nDESCRIPTION: Specifies the required Python packages with version constraints needed for development and testing. Includes pytest for testing, setuptools_rust for Rust extensions, and core Python packaging tools pip and wheel.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/setuptools-rust-starter/requirements-dev.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npytest>=3.5.0\nsetuptools_rust~=1.0.0\npip>=21.3\nwheel\n```\n\n----------------------------------------\n\nTITLE: Configuring build.rs for Python Version Detection\nDESCRIPTION: This build.rs file uses pyo3_build_config to set up conditional compilation based on Python version or compilation settings.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/README.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    pyo3_build_config::use_pyo3_cfgs()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PyDict struct in Rust for Python dict representation\nDESCRIPTION: This code defines the PyDict struct, which represents Python's dict type in PyO3. It wraps the PyAny struct using a transparent representation.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Architecture.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(transparent)]\npub struct PyDict(PyAny);\n```\n\n----------------------------------------\n\nTITLE: Installing Python with pyenv\nDESCRIPTION: Command to install Python 3.12 using pyenv while preserving source files for debugging\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/getting-started.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npyenv install 3.12 --keep\n```\n\n----------------------------------------\n\nTITLE: Adding PyDateTime::new_with_fold Method in Rust for PyPy\nDESCRIPTION: Adds new methods new_with_fold, get_fold for PyDateTime and PyTime types, specifically for PyPy, to handle datetime folding.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\nPyDateTime::new_with_fold\n```\n\n----------------------------------------\n\nTITLE: PyObject Method With Python Argument (After)\nDESCRIPTION: Updated pattern passing the Python token to PyObject methods as required in PyO3 0.10 for soundness.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\n# pyo3::Python::with_gil(|py| {\npy.None().get_refcnt(py);\n# })\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nox\nDESCRIPTION: Alternative testing approach using nox for isolated environment testing\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pytests/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks with Nox\nDESCRIPTION: Alternative benchmark execution using nox bench session\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pytests/README.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnox -s bench\n```\n\n----------------------------------------\n\nTITLE: Copying Maturin-Starter Example using Cargo Generate\nDESCRIPTION: These commands install cargo-generate and use it to create a new project based on the maturin-starter example from the PyO3 repository.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/maturin-starter/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/maturin-starter\n```\n\n----------------------------------------\n\nTITLE: Copying the Plugin Example with Cargo-Generate\nDESCRIPTION: Instructions for using cargo-generate to clone and set up a copy of this plugin example project.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/plugin/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/plugin\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Python Native Module\nDESCRIPTION: This snippet shows the Cargo.toml configuration for building a Python native module using pyo3-ffi. It specifies the crate type as 'cdylib' and includes necessary dependencies.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/README.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[lib]\nname = \"string_sum\"\ncrate-type = [\"cdylib\"]\n\n[dependencies.pyo3-ffi]\nversion = \"0.23.4\"\nfeatures = [\"extension-module\"]\n\n[build-dependencies]\npyo3_build_config = \"0.23.4\"\n```\n\n----------------------------------------\n\nTITLE: Updated Object Extraction Pattern in PyO3\nDESCRIPTION: Illustrates the changes in object extraction patterns for PyClass types. Instead of extracting &T or &mut T, code should now extract PyRef<T>, PyRefMut<T>, or T itself if it implements Clone.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_41\n\nLANGUAGE: rust\nCODE:\n```\nlet obj: &PyAny = create_obj();\nlet obj_ref: &MyClass = obj.extract().unwrap();\nlet obj_ref_mut: &mut MyClass = obj.extract().unwrap();\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::types::IntoPyDict;\n# #[pyclass] #[derive(Clone)] struct MyClass {}\n# #[pymethods] impl MyClass { #[new]fn new() -> Self { MyClass {} }}\n# Python::with_gil(|py| {\n# let typeobj = py.get_type::<MyClass>();\n# let d = [(\"c\", typeobj)].into_py_dict(py);\n# let create_obj = || py.eval(\"c()\", None, Some(d)).unwrap();\nlet obj: &PyAny = create_obj();\nlet obj_cell: &PyCell<MyClass> = obj.extract().unwrap();\nlet obj_cloned: MyClass = obj.extract().unwrap(); // extracted by cloning the object\n{\n    let obj_ref: PyRef<'_, MyClass> = obj.extract().unwrap();\n    // we need to drop obj_ref before we can extract a PyRefMut due to Rust's rules of references\n}\nlet obj_ref_mut: PyRefMut<'_, MyClass> = obj.extract().unwrap();\n# })\n```\n\n----------------------------------------\n\nTITLE: Building the Plugin API with Maturin\nDESCRIPTION: Commands to build the plugin API with the required extension-module feature for PyO3 compatibility.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/plugin/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd plugin_api\nmaturin build --features \"extension-module\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Optional Extension Module in Cargo.toml\nDESCRIPTION: Shows how to make the extension-module feature optional in PyO3 dependencies to avoid linking errors during testing.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/faq.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.pyo3]\n\n[features]\nextension-module = [\"pyo3/extension-module\"]\n```\n\n----------------------------------------\n\nTITLE: FromPyObject Derivation with Item Attribute\nDESCRIPTION: Demonstrates using the #[pyo3(item)] attribute to extract values using get_item method instead of getattr.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/conversions/traits.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nstruct RustyStruct {\n    #[pyo3(item)]\n    my_string: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin for Python Package Building\nDESCRIPTION: This command installs Maturin, a tool for building and publishing Rust-based Python packages.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/decorator/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: Using FromPy (Before)\nDESCRIPTION: Example of the old FromPy usage pattern for converting values to Python objects.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# Python::with_gil(|py| {\nlet obj = PyObject::from_py(1.234, py);\n# })\n```\n\n----------------------------------------\n\nTITLE: Declaring an Unsendable PyClass\nDESCRIPTION: Updated implementation using the unsendable attribute to explicitly mark a Python class as not thread-safe in PyO3 0.11.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\nuse pyo3::prelude::*;\n\n#[pyclass(unsendable)]\nstruct Unsendable {\n    pointers: Vec<*mut std::os::raw::c_char>,\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nox\nDESCRIPTION: Alternative testing approach using nox for isolated environment testing\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/getitem/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Copying the Example Project using cargo-generate\nDESCRIPTION: This snippet demonstrates how to use cargo-generate to create a new project based on the string_sum example. It includes installing cargo-generate and generating the project from the PyO3 repository.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/examples/string-sum/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/string_sum\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Isolated Environment with Nox\nDESCRIPTION: This command uses nox to run tests in an isolated environment, providing an alternative to direct maturin and pytest usage.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/maturin-starter/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Using lifetime specifiers in pymethods in Rust\nDESCRIPTION: Enables the use of lifetime specifiers in pymethod declarations.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_41\n\nLANGUAGE: Rust\nCODE:\n```\n#[pymethod]\nfn my_method<'a>(&self, arg: &'a PyAny) -> PyResult<&'a PyAny> { /* implementation */ }\n```\n\n----------------------------------------\n\nTITLE: Installing the Word Count Project\nDESCRIPTION: Command to install the project using pip. This should be run in the project directory to set up the necessary dependencies.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/word-count/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install .\n```\n\n----------------------------------------\n\nTITLE: Using IntoPy (After)\nDESCRIPTION: Updated pattern using IntoPy for converting values to Python objects after the FromPy removal.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(deprecated)]\n# use pyo3::prelude::*;\n# Python::with_gil(|py| {\nlet obj: PyObject = 1.234.into_py(py);\n# })\n```\n\n----------------------------------------\n\nTITLE: Adding Python Framework Link Arguments in macOS Build Script\nDESCRIPTION: Adds a build script API to set rpath when using macOS system Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npyo3_build_config::add_python_framework_link_args\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Isolated Environment with Nox\nDESCRIPTION: This snippet shows an alternative method to run tests using Nox, which creates an isolated environment for testing.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/examples/string-sum/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Function Documentation Template in reStructuredText\nDESCRIPTION: This template provides the structure for documenting Python functions in Sphinx documentation. It uses the autofunction directive to automatically generate function documentation from docstrings and includes placeholders for the function name, module, and example links.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/docs/templates/function.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n{{ objname }}\n{{ underline }}==============\n\n.. currentmodule:: {{ module }}\n\n.. autofunction:: {{ objname }}\n\n.. example_links:: {{ objname }}\n```\n\n----------------------------------------\n\nTITLE: Checking Module Support for Free-Threaded Build\nDESCRIPTION: Adds a method to check if a Python module supports the free-threaded build of Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nPyModule::gil_used\n```\n\n----------------------------------------\n\nTITLE: Running Semver Checks for PyO3\nDESCRIPTION: Command to run semantic versioning checks for PyO3 using cargo-semver-checks.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncargo semver-checks check-release\n```\n\n----------------------------------------\n\nTITLE: Building and Testing Python Extension Module with Maturin\nDESCRIPTION: These commands install development dependencies, build the extension module using maturin, and run tests with pytest.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/maturin-starter/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-dev.txt\nmaturin develop && pytest\n```\n\n----------------------------------------\n\nTITLE: Python Project Configuration\nDESCRIPTION: PyProject.toml configuration for setting up Python package metadata and build requirements\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/getting-started.md#2025-04-22_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[build-system]\nrequires = [\"maturin>=1,<2\"]\nbuild-backend = \"maturin\"\n\n[project]\nname = \"pyo3_example\"\nrequires-python = \">=3.7\"\nclassifiers = [\n    \"Programming Language :: Rust\",\n    \"Programming Language :: Python :: Implementation :: CPython\",\n    \"Programming Language :: Python :: Implementation :: PyPy\",\n]\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nox\nDESCRIPTION: Alternative testing command using nox for isolated environment testing.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/setuptools-rust-starter/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Building and Testing Python Extension with Maturin\nDESCRIPTION: This snippet demonstrates how to build the Python extension using Maturin and run tests. It installs development dependencies, builds the package, and runs pytest.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/examples/string-sum/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-dev.txt\nmaturin develop\npytest\n```\n\n----------------------------------------\n\nTITLE: Cross-Compilation Environment Setup\nDESCRIPTION: Shell commands demonstrating how to set up environment variables for cross-compiling Python extensions using PyO3 for ARM target.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution.md#2025-04-22_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nexport PYO3_CROSS_LIB_DIR=\"/home/pyo3/cross/sysroot/usr/lib\"\n\ncargo build --target armv7-unknown-linux-gnueabihf\n```\n\n----------------------------------------\n\nTITLE: Project Generation with Cargo\nDESCRIPTION: Commands to install cargo-generate and create a new project using the setuptools-rust-starter template from PyO3.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/setuptools-rust-starter/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/setuptools-rust-starter\n```\n\n----------------------------------------\n\nTITLE: Linting Rust Code in PyO3\nDESCRIPTION: Command to lint Rust code in the PyO3 project using Nox and rustfmt.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nnox -s rustfmt\n```\n\n----------------------------------------\n\nTITLE: Checking PyO3 Guide Links with Nox\nDESCRIPTION: Command to check all links in the PyO3 guide for validity using Nox and lychee.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox -s check-guide\n```\n\n----------------------------------------\n\nTITLE: Sequential Word Count Implementation in Rust\nDESCRIPTION: Basic sequential implementation of word counting function for comparison purposes.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/parallelism.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn search_sequential(contents: &str, needle: &str) -> usize {\n    contents.lines().map(|line| count_line(line, needle)).sum()\n}\n```\n\n----------------------------------------\n\nTITLE: Updating UI Tests for PyO3\nDESCRIPTION: Command to update UI tests for PyO3 using Nox, helpful for new Rust compiler versions.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nnox -s update-ui-tests\n```\n\n----------------------------------------\n\nTITLE: Installing and Using cargo-generate with PyO3 Examples\nDESCRIPTION: Commands to install cargo-generate and create new projects from PyO3 examples. cargo-generate is used to clone and customize example projects from the PyO3 repository.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/examples/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/<example>\n```\n\n----------------------------------------\n\nTITLE: PyO3 DateType Constructor Changes\nDESCRIPTION: Changes to datetime constructors in PyO3 to use Option<&PyTzInfo> instead of Option<&PyObject> for timezone info parameters.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_16\n\nLANGUAGE: Rust\nCODE:\n```\nPyDateTime::new(/* with Option<&PyTzInfo> */)\nPyDateTime::new_with_fold(/* with Option<&PyTzInfo> */)\nPyTime::new(/* with Option<&PyTzInfo> */)\nPyTime::new_with_fold(/* with Option<&PyTzInfo> */)\n```\n\n----------------------------------------\n\nTITLE: Installing Setuptools-Rust Dependencies\nDESCRIPTION: Command to install the required setuptools-rust package via pip for building Python extensions.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/setuptools-rust-starter/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install setuptools_rust\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for LangSmith\nDESCRIPTION: TypeScript code snippet showing how to set environment variables for LangSmith tracing.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nprocess.env.LANGSMITH_TRACING = \"true\";\nprocess.env.LANGSMITH_ENDPOINT = \"https://api.smith.langchain.com\";\n// process.env.LANGSMITH_ENDPOINT = \"https://eu.api.smith.langchain.com\"; // If signed up in the EU region\nprocess.env.LANGSMITH_API_KEY = \"<YOUR-LANGSMITH-API-KEY>\";\n// process.env.LANGSMITH_PROJECT = \"My Project Name\"; // Optional: \"default\" is used if not set\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoPyObject and IntoPyObjectRef with Derive Macros\nDESCRIPTION: Example showing how to derive IntoPyObject and IntoPyObjectRef traits for a struct containing a count and Python object.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(IntoPyObject, IntoPyObjectRef)]\nstruct Struct {\n    count: usize,\n    obj: Py<PyAny>,\n}\n```\n\n----------------------------------------\n\nTITLE: Building PyO3 Documentation with Nox\nDESCRIPTION: Command to build and open the PyO3 documentation using Nox, including all features.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnox -s docs -- open\n```\n\n----------------------------------------\n\nTITLE: Copying the Word Count Example using Cargo Generate\nDESCRIPTION: Bash commands to install cargo-generate and use it to copy the word-count example from the PyO3 repository. This allows users to quickly set up their own version of the project.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/word-count/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/word-count\n```\n\n----------------------------------------\n\nTITLE: Copying PyO3 Decorator Example Project\nDESCRIPTION: These commands install cargo-generate and use it to create a new project based on the PyO3 decorator example.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/decorator/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/decorator\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Arithmetic Operators for Number Class\nDESCRIPTION: Implementation of arithmetic operators (__add__, __sub__, __mul__, __truediv__, __floordiv__, __rshift__, __lshift__) for the Number class with proper error handling for division by zero and negative shift counts.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/numeric.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::exceptions::{PyZeroDivisionError, PyValueError};\n\n# use pyo3::prelude::*;\n#\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymethods]\nimpl Number {\n    fn __add__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_add(other.0))\n    }\n\n    fn __sub__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_sub(other.0))\n    }\n\n    fn __mul__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_mul(other.0))\n    }\n\n    fn __truediv__(&self, other: &Self) -> PyResult<Self> {\n        match self.0.checked_div(other.0) {\n            Some(i) => Ok(Self(i)),\n            None => Err(PyZeroDivisionError::new_err(\"division by zero\")),\n        }\n    }\n\n    fn __floordiv__(&self, other: &Self) -> PyResult<Self> {\n        match self.0.checked_div(other.0) {\n            Some(i) => Ok(Self(i)),\n            None => Err(PyZeroDivisionError::new_err(\"division by zero\")),\n        }\n    }\n\n    fn __rshift__(&self, other: &Self) -> PyResult<Self> {\n        match other.0.try_into() {\n            Ok(rhs) => Ok(Self(self.0.wrapping_shr(rhs))),\n            Err(_) => Err(PyValueError::new_err(\"negative shift count\")),\n        }\n    }\n\n    fn __lshift__(&self, other: &Self) -> PyResult<Self> {\n        match other.0.try_into() {\n            Ok(rhs) => Ok(Self(self.0.wrapping_shl(rhs))),\n            Err(_) => Err(PyValueError::new_err(\"negative shift count\")),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests for LangSmith PyO3 Bindings\nDESCRIPTION: This command demonstrates how to run tests for the LangSmith PyO3 project using cargo-nextest. It disables default features to include Python in the built code, allowing tests to run in a Python environment.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/rust/crates/langsmith-pyo3/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo nextest run --no-default-features\n```\n\n----------------------------------------\n\nTITLE: Windows Cross-Compilation Setup\nDESCRIPTION: Shell commands for setting up cross-compilation environment variables when targeting Windows platform.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution.md#2025-04-22_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nexport PYO3_CROSS_PYTHON_VERSION=3.9\nexport PYO3_CROSS_LIB_DIR=\"/home/pyo3/cross/sysroot/usr/lib\"\n\ncargo build --target x86_64-pc-windows-gnu\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Isolated Environment with Nox\nDESCRIPTION: This command uses Nox to run tests in an isolated environment, providing an alternative to the Maturin approach.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/decorator/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Python Extension Module Link Arguments\nDESCRIPTION: Build script helper function to configure linker arguments for macOS builds of Python extension modules.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_20\n\nLANGUAGE: Rust\nCODE:\n```\npyo3_build_config::add_extension_module_link_args\n```\n\n----------------------------------------\n\nTITLE: Manual Exception Handling in PyO3\nDESCRIPTION: Demonstrates manual writing and fetching of Python errors in the interpreter's global state.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/exception.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::{Python, PyErr};\nuse pyo3::exceptions::PyTypeError;\n\nPython::with_gil(|py| {\n    PyTypeError::new_err(\"Error\").restore(py);\n    assert!(PyErr::occurred(py));\n    drop(PyErr::fetch(py));\n});\n```\n\n----------------------------------------\n\nTITLE: Linting Python Code in PyO3\nDESCRIPTION: Command to lint Python code in the PyO3 project using Nox and ruff.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnox -s ruff\n```\n\n----------------------------------------\n\nTITLE: Example error message from PyO3 runtime panic\nDESCRIPTION: Error message shown when the Python Model class returns an incorrect type that Rust code cannot process, resulting in a panic that is not user-friendly to Python developers.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/trait-bounds.md#2025-04-22_snippet_7\n\nLANGUAGE: text\nCODE:\n```\npyo3_runtime.PanicException: called `Result::unwrap()` on an `Err` value: PyErr { type: Py(0x10dcf79f0, PhantomData) }\n```\n\n----------------------------------------\n\nTITLE: Installing LangChain via Yarn\nDESCRIPTION: Command to install the LangChain library using Yarn package manager.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add langchain\n```\n\n----------------------------------------\n\nTITLE: Installing Development Dependencies for LangSmith PyO3 Bindings\nDESCRIPTION: This snippet shows the commands to install the necessary development dependencies for the LangSmith PyO3 project. It includes installing cargo-nextest, creating a virtual environment, and installing patchelf.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/rust/crates/langsmith-pyo3/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install --locked cargo-nextest\nuv venv --seed\nsource .venv/bin/activate\npip install patchelf\n```\n\n----------------------------------------\n\nTITLE: Using AsPyRef (Before)\nDESCRIPTION: Example showing the old pattern using the AsPyRef trait which was removed in PyO3 0.12.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::{AsPyRef, Py, types::PyList};\n# pyo3::Python::with_gil(|py| {\nlet list_py: Py<PyList> = PyList::empty(py).into();\nlet list_ref: &PyList = list_py.as_ref(py);\n# })\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nox\nDESCRIPTION: Alternative testing command using nox for isolated environment testing\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/examples/sequential/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Sphinx Class Documentation Template using Jinja2\nDESCRIPTION: A template that generates documentation structure for a class, including the class title, module reference, class description, attributes list, and example links. Uses Jinja2 templating syntax with variables for dynamic content insertion.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/docs/templates/typeddict.rst#2025-04-22_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{{ objname }}\n{{ underline }}==============\n\n.. currentmodule:: {{ module }}\n\n.. autoclass:: {{ objname }}\n\n    {% block attributes %}\n   {% for item in attributes %}\n  .. autoattribute:: {{ item }}\n   {% endfor %}\n   {% endblock %}\n\n.. example_links:: {{ objname }}\n```\n\n----------------------------------------\n\nTITLE: Rust Call Counter Implementation with Mutable Self\nDESCRIPTION: Example of problematic implementation using mutable self receiver, which can lead to borrowing issues when Python code attempts recursive calls.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/call.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[pyo3(signature = (*args, **kwargs))]\nfn __call__(\n    &mut self,\n    py: Python<'_>,\n    args: &Bound<'_, PyTuple>,\n    kwargs: Option<&Bound<'_, PyDict>>,\n) -> PyResult<Py<PyAny>> {\n    self.count += 1;\n    let name = self.wraps.getattr(py, \"__name__\")?;\n\n    println!(\"{} has been called {} time(s).\", name, self.count);\n\n    // After doing something, we finally forward the call to the wrapped function\n    let ret = self.wraps.call(py, args, kwargs)?;\n\n    // We could do something with the return value of\n    // the function before returning it\n    Ok(ret)\n}\n```\n\n----------------------------------------\n\nTITLE: Debugging Classic Macros in Rust\nDESCRIPTION: This command expands classic '!'-macros in Rust, providing additional debugging information. It also requires the nightly build of Rust.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/debugging.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo rustc --profile=check -- -Z unstable-options --pretty=expanded -Z trace-macros > expanded.rs; rustfmt expanded.rs\n```\n\n----------------------------------------\n\nTITLE: PyClass Attribute Example\nDESCRIPTION: Example of PyClass attribute usage for marking unsendable classes\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\n#[pyclass(unsendable)]\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nox in Isolated Environment\nDESCRIPTION: Command to use nox for running tests in an isolated environment, which handles dependencies and configuration automatically.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/plugin/README.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Generating Code Coverage Report\nDESCRIPTION: Command to generate an lcov.info coverage report file using nox.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nnox -s coverage -- lcov\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Extension Module in Cargo.toml\nDESCRIPTION: Demonstrates how to set extension-module as an optional but default feature in PyO3 dependencies.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/faq.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.pyo3]\n\n[features]\nextension-module = [\"pyo3/extension-module\"]\ndefault = [\"extension-module\"]\n```\n\n----------------------------------------\n\nTITLE: Using the Number Class in Python\nDESCRIPTION: Shows how to import and use the Number class in Python, demonstrating the default string representation without customization.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom my_module import Number\n\nn = Number(5)\nprint(n)\n```\n\n----------------------------------------\n\nTITLE: Building PyO3 User Guide with Nox\nDESCRIPTION: Command to build and open the PyO3 user guide locally using Nox and mdbook.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnox -s build-guide -- --open\n```\n\n----------------------------------------\n\nTITLE: Implementing Complex Method Signatures in PyO3\nDESCRIPTION: Demonstrates implementing a Python class method with various argument types including default values, *args, and **kwargs.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function/signature.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    #[new]\n    #[pyo3(signature = (num=-1))]\n    fn new(num: i32) -> Self {\n        MyClass { num }\n    }\n\n    #[pyo3(signature = (num=10, *py_args, name=\"Hello\", **py_kwargs))]\n    fn method(\n        &mut self,\n        num: i32,\n        py_args: &Bound<'_, PyTuple>,\n        name: &str,\n        py_kwargs: Option<&Bound<'_, PyDict>>,\n    ) -> String {\n        let num_before = self.num;\n        self.num = num;\n        format!(\n            \"num={} (was previously={}), py_args={:?}, name={}, py_kwargs={:?} \",\n            num, num_before, py_args, name, py_kwargs,\n        )\n    }\n```\n\n----------------------------------------\n\nTITLE: PyO3 Crate Re-export Configuration\nDESCRIPTION: Shows how to configure PyO3 proc-macros when using a re-exported PyO3 dependency.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/faq.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\n#[pyo3(crate = \"reexported::pyo3\")]\nstruct MyClass;\n```\n\n----------------------------------------\n\nTITLE: Invalid Use of Enum as Subclass\nDESCRIPTION: Demonstrates compile-time errors when attempting to use enums as derived classes. This example shows that enums cannot inherit from other Python classes in PyO3.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass(subclass)]\nstruct Base;\n\n#[pyclass(extends=Base)]\nenum BadSubclass {\n    Var1,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PyO3 Nested Struct Example\nDESCRIPTION: Demonstrates a nested struct implementation with PyO3 attributes showing cloning behavior.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/faq.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\n#[derive(Clone)]\nstruct Inner {/* fields omitted */}\n\n#[pyclass]\nstruct Outer {\n    #[pyo3(get)]\n    inner: Inner,\n}\n\n#[pymethods]\nimpl Outer {\n    #[new]\n    fn __new__() -> Self {\n        Self { inner: Inner {} }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Code Coverage Tools\nDESCRIPTION: Commands for installing and executing the llvm-cov cargo plugin to generate code coverage data for PyO3.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\ncargo install cargo-llvm-cov\ncargo llvm-cov\n```\n\n----------------------------------------\n\nTITLE: Configuring Maturin Features in pyproject.toml\nDESCRIPTION: Shows how to configure PyO3 extension module features in a maturin project file.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/faq.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.maturin]\nfeatures = [\"pyo3/extension-module\"]\n```\n\n----------------------------------------\n\nTITLE: Rendering Class Documentation with Jinja Template for Sphinx\nDESCRIPTION: A Jinja template for Sphinx documentation that displays a class name, its attributes, and example links. The template uses Sphinx directives to automatically generate documentation from Python docstrings.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/docs/templates/enum.rst#2025-04-22_snippet_0\n\nLANGUAGE: jinja\nCODE:\n```\n{{ objname }}\n{{ underline }}==============\n\n.. currentmodule:: {{ module }}\n\n.. autoclass:: {{ objname }}\n\n    {% block attributes %}\n    {% for item in attributes %}\n    .. autoattribute:: {{ item }}\n    {% endfor %}\n    {% endblock %}\n\n.. example_links:: {{ objname }}\n\n```\n\n----------------------------------------\n\nTITLE: Checking Conditional Compilation in PyO3\nDESCRIPTION: Command to check all conditional compilation configurations in PyO3 using Nox.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nnox -s check-feature-powerset\n```\n\n----------------------------------------\n\nTITLE: LTO Version Error in Static Linking\nDESCRIPTION: Example error message when encountering version mismatch between compiler bytecode streams during static linking of Python interpreter.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution.md#2025-04-22_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nlto1: fatal error: bytecode stream in file 'rust-numpy/target/release/deps/libpyo3-6a7fb2ed970dbf26.rlib' generated with LTO version 6.0 instead of the expected 6.2\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo Library Types\nDESCRIPTION: Shows how to configure a crate to build both cdylib and rlib types for testing compatibility.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/faq.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[lib]\ncrate-type = [\"cdylib\", \"rlib\"]\n```\n\n----------------------------------------\n\nTITLE: Warning about Py::new and into_pyobject Inconsistency\nDESCRIPTION: Demonstrates an inconsistency between Py::new and into_pyobject methods when creating enum instances. Values created with Py::new are not instances of the specific variant classes.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n#[pyclass]\nenum MyEnum {\n    Variant { i: i32 },\n}\n\nPython::with_gil(|py| {\n    let x = Py::new(py, MyEnum::Variant { i: 42 }).unwrap();\n    let cls = py.get_type::<MyEnum>();\n    pyo3::py_run!(py, x cls, r#\"\n        assert isinstance(x, cls)\n        assert not isinstance(x, cls.Variant)\n    \"#)\n})\n```\n\n----------------------------------------\n\nTITLE: Python Usage Example\nDESCRIPTION: Example Python code demonstrating how to use the exposed Rust functionality.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/trait-bounds.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Model:\n    def set_variables(self, inputs):\n        self.inputs = inputs\n    def compute(self):\n        self.results = [elt**2 - 3 for elt in self.inputs]\n    def get_results(self):\n        return self.results\n\nif __name__==\"__main__\":\n  import trait_exposure\n\n  myModel = Model()\n  my_rust_model = trait_exposure.UserModel(myModel)\n  my_rust_model.set_variables([2.0])\n  print(\"Print value from Python: \", myModel.inputs)\n  my_rust_model.compute()\n  print(\"Print value from Python through Rust: \", my_rust_model.get_results())\n  print(\"Print value directly from Python: \", myModel.get_results())\n```\n\n----------------------------------------\n\nTITLE: FFI Definition Change for Python 3.13\nDESCRIPTION: Updated type signature for PyArg_ParseTupleAndKeywords FFI function to use const pointers instead of mutable pointers on Python 3.13 and above.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nPyArg_ParseTupleAndKeywords(*const *const c_char) // Python 3.13+\nPyArg_ParseTupleAndKeywords(*mut *mut c_char)   // Pre-Python 3.13\n```\n\n----------------------------------------\n\nTITLE: Updating pyo3 Dependency Paths in Cargo.toml\nDESCRIPTION: This diff shows changes to dependency paths in Cargo.toml for the LangSmith SDK project. The paths for pyo3-ffi and pyo3-build-config are updated from 'include/pyo3/' to '../pyo3/', likely to reference a different location of these dependencies.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson-info.txt#2025-04-22_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 516f4d0..b1b2727 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -65,7 +65,7 @@ itoa = { version = \"1\", default-features = false }\n itoap = { version = \"1\", default-features = false, features = [\"std\", \"simd\"] }\n jiff = { version = \"^0.1\", default-features = false, features = [\"alloc\"] }\n once_cell = { version = \"1\", default-features = false, features = [\"alloc\", \"race\"] }\n-pyo3-ffi = { path = \"include/pyo3/pyo3-ffi\", default-features = false, features = [\"extension-module\"]}\n+pyo3-ffi = { path = \"../pyo3/pyo3-ffi\", default-features = false, features = [\"extension-module\"]}\n ryu = { version = \"1\", default-features = false }\n serde = { version = \"1\", default-features = false }\n serde_json = { version = \"1\", default-features = false, features = [\"std\", \"float_roundtrip\"] }\n@@ -77,7 +77,7 @@ xxhash-rust = { version = \"^0.8\", default-features = false, features = [\"xxh3\"]}\n \n [build-dependencies]\n cc = { version = \"1\" }\n-pyo3-build-config = { path = \"include/pyo3/pyo3-build-config\" }\n+pyo3-build-config = { path = \"../pyo3/pyo3-build-config\" }\n version_check = { version = \"0.9\" }\n \n [profile.dev]\n```\n\n----------------------------------------\n\nTITLE: Project Initialization Commands\nDESCRIPTION: Commands for creating a new PyO3 project directory and setting up the Python virtual environment\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/getting-started.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir pyo3-example\ncd pyo3-example\npyenv virtualenv pyo3\npyenv local pyo3\n```\n\n----------------------------------------\n\nTITLE: Python Documentation Dependencies Requirements\nDESCRIPTION: A requirements file listing all Python packages needed for generating documentation. Includes Sphinx and its extensions, Markdown parsing with MyST, notebook integration, theming packages, and API client libraries like OpenAI.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/docs/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nautodoc_pydantic\nsphinx\nmyst-parser>=3\nsphinx-autobuild>=2024\npydata-sphinx-theme>=0.15\ntoml>=0.10.2\nmyst-nb>=1.1.1\npyyaml\nsphinx-design\nsphinx-copybutton\nbeautifulsoup4\nopenai\n```\n\n----------------------------------------\n\nTITLE: Invalid Use of Enum with Subclass Feature\nDESCRIPTION: Demonstrates compile-time errors when attempting to use enums with inheritance. This example shows that enums cannot be used as base classes with the 'subclass' attribute in PyO3.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n#[pyclass(subclass)]\nenum BadBase {\n    Var1,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Python Subclass of dict in Rust\nDESCRIPTION: This snippet shows how to create a Python subclass of dict using PyO3. It defines a custom constructor that accepts *args and **kwargs, allowing for flexible initialization.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\n\n#[pyclass(extends=PyDict)]\nstruct MyDict {\n    private: i32,\n}\n\n#[pymethods]\nimpl MyDict {\n    #[new]\n    #[pyo3(signature = (*args, **kwargs))]\n    fn new(args: &Bound<'_, PyAny>, kwargs: Option<&Bound<'_, PyAny>>) -> Self {\n        Self { private: 0 }\n    }\n\n    // some custom methods that use `private` here...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting LangSmith API Key\nDESCRIPTION: Sets the required environment variable for LangSmith API key authentication.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nexport LANGSMITH_API_KEY=<your-api-key>\n```\n\n----------------------------------------\n\nTITLE: VSCode Coverage Settings Configuration\nDESCRIPTION: JSON configuration for VSCode settings.json to enable code coverage visualization using the coverage-gutters extension.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"coverage-gutters.coverageFileNames\": [\n        \"lcov.info\",\n        \"cov.xml\",\n        \"coverage.xml\",\n    ],\n    \"coverage-gutters.showLineCoverage\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Making a Class Not Hashable\nDESCRIPTION: Shows how to make a class not hashable by setting __hash__ to None as a class attribute.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#[pyclass]\nstruct NotHashable {}\n\n#[pymethods]\nimpl NotHashable {\n    #[classattr]\n    const __hash__: Option<Py<PyAny>> = None;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Configuring LangSmith JavaScript SDK\nDESCRIPTION: Command line instructions for installing the LangSmith JavaScript package and setting up required environment variables.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add langsmith\nexport LANGSMITH_TRACING=true\nexport LANGSMITH_API_KEY=ls_...\n```\n\n----------------------------------------\n\nTITLE: Building and Testing with Maturin\nDESCRIPTION: Commands to install development dependencies, build the package with maturin, and run tests\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/examples/sequential/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-dev.txt\nmaturin develop\npytest\n```\n\n----------------------------------------\n\nTITLE: Including CHANGELOG.md Using Markdown Include Directive\nDESCRIPTION: Uses a Markdown include directive to embed the contents of a CHANGELOG.md file located two directories up from the current location.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/changelog.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n{{#include ../../CHANGELOG.md}}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incorrect Default Function Behavior in Python JSON Libraries\nDESCRIPTION: Illustrates how various JSON libraries, including orjson, json, and rapidjson, handle default functions that don't raise exceptions for unsupported types.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/README.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import orjson, json, rapidjson\n>>>\ndef default(obj):\n    if isinstance(obj, decimal.Decimal):\n        return str(obj)\n\n>>> orjson.dumps({\"set\":{1, 2}}, default=default)\nb'{\"set\":null}'\n>>> json.dumps({\"set\":{1, 2}}, default=default)\n'{\"set\":null}'\n>>> rapidjson.dumps({\"set\":{1, 2}}, default=default)\n'{\"set\":null}'\n```\n\n----------------------------------------\n\nTITLE: Installing LangSmith SDK\nDESCRIPTION: Installs or updates the LangSmith SDK package using pip.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/README.md#2025-04-22_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\npip install -U langsmith\n```\n\n----------------------------------------\n\nTITLE: Unsafe FFI Call in PyO3\nDESCRIPTION: Example of an unsafe FFI call in PyO3 using pointers-to-temporaries, which should be avoided.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/Contributing.md#2025-04-22_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n// dangerous\npyo3::ffi::Something(name.to_object(py).as_ptr());\n\n// because the following refactoring is a use-after-free error:\nlet name = name.to_object(py).as_ptr();\npyo3::ffi::Something(name)\n```\n\n----------------------------------------\n\nTITLE: PyObject Method Without Python Argument (Before)\nDESCRIPTION: Example showing a PyObject method call without a Python argument, which became invalid in PyO3 0.10.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\n# pyo3::Python::with_gil(|py| {\npy.None().get_refcnt();\n# })\n```\n\n----------------------------------------\n\nTITLE: Building and Testing Extension Module\nDESCRIPTION: Commands to install development dependencies, build the extension module in development mode, and run tests.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/setuptools-rust-starter/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-dev.txt\npython setup.py develop && pytest\n```\n\n----------------------------------------\n\nTITLE: FFI Function Deprecation Example\nDESCRIPTION: Example of deprecated FFI function signatures that were removed from the PyO3 public API.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n_Py_IMMORTAL_REFCNT\n_Py_IsImmortal\n_Py_TPFLAGS_STATIC_BUILTIN\n_Py_Dealloc\n_Py_IncRef\n_Py_DecRef\n```\n\n----------------------------------------\n\nTITLE: Installing LangSmith SDK via Yarn\nDESCRIPTION: Command to install the LangSmith SDK using Yarn package manager.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/js/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add langsmith\n```\n\n----------------------------------------\n\nTITLE: Sphinx Pydantic Model Documentation Template in Jinja2\nDESCRIPTION: A Sphinx documentation template that configures the autopydantic_model directive with specific settings for model member display, exclusions, and inheritance documentation. It defines how Pydantic model documentation should be rendered.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/docs/templates/pydantic.rst#2025-04-22_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{{ objname }}\n{{ underline }}==============\n\n.. currentmodule:: {{ module }}\n\n.. autopydantic_model:: {{ objname }}\n    :model-show-json: False\n    :model-show-config-summary: False\n    :model-show-validator-members: False\n    :model-show-field-summary: False\n    :field-signature-prefix: param\n    :members:\n    :undoc-members:\n    :inherited-members:\n    :member-order: groupwise\n    :show-inheritance: True\n    :special-members: __call__\n    :exclude-members: construct, copy, dict, from_orm, parse_file, parse_obj, parse_raw, schema, schema_json, update_forward_refs, validate, json, is_lc_serializable, to_json, to_json_not_implemented, lc_secrets, lc_attributes, lc_id, get_lc_namespace, model_construct, model_copy, model_dump, model_dump_json, model_parametrized_name, model_post_init, model_rebuild, model_validate, model_validate_json, model_validate_strings, model_extra, model_fields_set, model_json_schema\n\n\n    {% block attributes %}\n    {% endblock %}\n\n.. example_links:: {{ objname }}\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks with Pytest\nDESCRIPTION: Commands for installing the module and running benchmarks using pytest with the benchmark flag enabled\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pytests/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npip install .\npytest --benchmark-enable\n```\n\n----------------------------------------\n\nTITLE: Complex Math FFI Function Removals\nDESCRIPTION: List of removed private FFI definitions for complex number operations.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n_Py_c_sum\n_Py_c_diff\n_Py_c_neg\n_Py_c_prod\n_Py_c_quot\n_Py_c_pow\n_Py_c_abs\n```\n\n----------------------------------------\n\nTITLE: Converting from PyErr to PyResult (Before)\nDESCRIPTION: Example showing the old pattern of converting a PyErr to PyResult using the Into trait, which was removed in PyO3 0.12.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/migration.md#2025-04-22_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nlet result: PyResult<()> = PyErr::new::<TypeError, _>(\"error message\").into();\n```\n\n----------------------------------------\n\nTITLE: Project Setup Using cargo-generate\nDESCRIPTION: Commands to install cargo-generate and create a new project based on the PyO3 decorator example template\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/getitem/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/decorator\n```\n\n----------------------------------------\n\nTITLE: PIE Object Compilation Error\nDESCRIPTION: Error message when encountering relocation issues during static linking due to mismatched compilation flags.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution.md#2025-04-22_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/libpython3.9.a(zlibmodule.o): relocation R_X86_64_32 against `.data' can not be used when making a PIE object; recompile with -fPIE\n```\n\n----------------------------------------\n\nTITLE: Installing Development Dependencies with pip\nDESCRIPTION: Commands for installing the required development tools and dependencies using pip package manager\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/getitem/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\\npip install -r requirements-dev.txt\\nmaturin develop\\npytest\n```\n\n----------------------------------------\n\nTITLE: Specifying LangSmith SDK Dependencies in Python\nDESCRIPTION: This requirements file lists the necessary dependencies for the LangSmith SDK project. It includes references to other requirement files for benchmarking, integration, and testing. Additionally, it specifies tools for Python package building (maturin) and code quality (mypy and ruff).\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n-r bench/requirements.txt\n-r integration/requirements.txt\n-r test/requirements.txt\nmaturin\nmypy==1.13.0\nruff==0.7.1\n```\n\n----------------------------------------\n\nTITLE: Generating Sphinx Documentation for Python Classes using Jinja2\nDESCRIPTION: This Jinja2 template creates a Sphinx documentation structure for a Python class. It includes sections for the class name, attributes, and methods. The template uses Sphinx directives to auto-generate summaries and detailed documentation for each component of the class.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/python/docs/templates/class.rst#2025-04-22_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{{ objname }}\n{{ underline }}==============\n\n.. currentmodule:: {{ module }}\n\n.. autoclass:: {{ objname }}\n\n   {% block attributes %}\n   {% if attributes %}\n   .. rubric:: {{ _('Attributes') }}\n\n   .. autosummary::\n   {% for item in attributes %}\n      ~{{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block methods %}\n   {% if methods %}\n   .. rubric:: {{ _('Methods') }}\n\n   .. autosummary::\n   {% for item in methods %}\n      ~{{ item }}\n   {%- endfor %}\n\n   {% for item in methods %}\n   .. automethod:: {{ item }}\n   {%- endfor %}\n\n   {% endif %}\n   {% endblock %}\n\n\n.. example_links:: {{ objname }}\n```\n\n----------------------------------------\n\nTITLE: Modifying _Py_IsImmortal Function Visibility\nDESCRIPTION: Changes visibility of _Py_IsImmortal function from private to public for Python 3.12 compatibility when GIL is not disabled. The function checks if a Python object is immortal.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3-info.txt#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[inline(always)]\n#[cfg(all(Py_3_12, not(Py_GIL_DISABLED)))]\npub unsafe fn _Py_IsImmortal(op: *mut PyObject) -> c_int {\n    #[cfg(target_pointer_width = \"64\")]\n    {\n        (((*op).ob_refcnt.ob_refcnt as crate::PY_INT32_T) < 0) as c_int\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Output of Default String Representation\nDESCRIPTION: Shows the default string representation of the Number object, which is not user-friendly and only displays object memory location.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/class/object.md#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n<builtins.Number object at 0x000002B4D185D7D0>\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies Configuration\nDESCRIPTION: Lists required Python packages with their version constraints and platform-specific requirements. Includes conditional dependencies based on system platform (Linux/macOS), machine architecture (x86_64/aarch64), and Python version compatibility.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/orjson/test/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\narrow\nfaker\nnumpy;(platform_machine==\"x86_64\" or (platform_machine==\"aarch64\" and sys_platform == \"linux\")) and python_version<\"3.13\"\npendulum;sys_platform==\"linux\" and platform_machine==\"x86_64\" and python_version<\"3.12\"\ntime-machine < 2.15;sys_platform==\"linux\" and platform_machine==\"x86_64\" and python_version<\"3.12\"\npsutil;(sys_platform==\"linux\" or sys_platform == \"macos\") and platform_machine==\"x86_64\" and python_version<\"3.13\"\npytest\npytz\ntyping_extensions;python_version<\"3.8\"\nxxhash==1.4.3;sys_platform==\"linux\" and platform_machine==\"x86_64\" and python_version<\"3.9\" # creates non-compact ASCII for test_str_ascii\n```\n\n----------------------------------------\n\nTITLE: Generating Structured Changelog with Jinja2\nDESCRIPTION: This Jinja2 template generates a structured changelog by iterating through sections and predefined categories. It formats entries differently based on category definitions and handles cases with or without content.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/.towncrier.template.md#2025-04-22_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{% for section_text, section in sections.items() %}{%- if section %}{{section_text}}{% endif -%}\n{% if section %}\n{% for category in ['packaging', 'added', 'changed', 'removed', 'fixed' ] if category in section %}\n### {{ definitions[category]['name'] }}\n\n{% if definitions[category]['showcontent'] %}\n{% for text, pull_requests in section[category].items() %}\n- {{ text }} {{ pull_requests|join(', ') }}\n{% endfor %}\n{% else %}\n- {{ section[category]['']|join(', ') }}\n{% endif %}\n\n{% endfor %}{% else %}No significant changes.{% endif %}{% endfor %}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in Python Function Calls with PythonREPL\nDESCRIPTION: This example demonstrates error handling when calling Python functions using PythonREPL. It shows how syntax errors and runtime errors are captured and returned as string output.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/function-calls.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nrepl.run(\"\"\"\ndef divide(a, b):\n    return a / b\n\nresult = divide(1, 0)\nprint(result)\n\"\"\")\n# Output: 'Traceback (most recent call last):\\n  File \"<string>\", line 4, in <module>\\n  File \"<string>\", line 2, in divide\\nZeroDivisionError: division by zero\\n'\n```\n\n----------------------------------------\n\nTITLE: Adding pyo3-build-config to Cargo.toml\nDESCRIPTION: Shows how to add pyo3-build-config with the resolve-config feature to a project's build dependencies.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/building-and-distribution/multiple-python-versions.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[build-dependencies]\npyo3-build-config = { {{#PYO3_CRATE_VERSION}}, features = [\"resolve-config\"] }\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin for Python Extension Development\nDESCRIPTION: This snippet shows how to install Maturin, a tool for building and publishing Rust-based Python extensions.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/pyo3-ffi/examples/string-sum/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin for Python Extension Module Development\nDESCRIPTION: This command installs maturin, a tool for building and publishing Rust-based Python extensions.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/examples/maturin-starter/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: PyO3 Method Signature Example\nDESCRIPTION: Example showing a typical PyO3 method signature using shared references due to Python's lack of exclusive references\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/python-from-rust.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nPyListMethods::append\n```\n\n----------------------------------------\n\nTITLE: Iterating PyDict with Critical Section Lock in Free-Threaded Build\nDESCRIPTION: Adds a method to iterate efficiently over a PyDict in the free-threaded build of Python.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/CHANGELOG.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nPyDict::locked_for_each\n```\n\n----------------------------------------\n\nTITLE: Native Module Configuration\nDESCRIPTION: Cargo.toml configuration for creating a native Python module using PyO3.\nSOURCE: https://github.com/langchain-ai/langsmith-sdk/blob/main/vendor/pyo3/guide/src/ecosystem/async-await.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[lib]\nname = \"my_async_module\"\ncrate-type = [\"cdylib\"]\n```"
  }
]