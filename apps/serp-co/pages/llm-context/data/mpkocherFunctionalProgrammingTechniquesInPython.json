[
  {
    "owner": "mpkocher",
    "repo": "functional-programming-techniques-in-python",
    "content": "TITLE: Implementing Optional Response Transformation for Handling 404s\nDESCRIPTION: A transformation function that converts a response to a Todo object or returns None if the resource doesn't exist, enabling dict.get-like behavior for the API client.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\ndef to_todo_or_none(response):\n    try:\n        return Todo.from_d(response.json())\n    except (KeyError, AttributeError):\n        # this is extremely bad form. Don't do this.\n        # this should only catch the 404 case.\n        return None\n```\n\n----------------------------------------\n\nTITLE: Enhanced TodoClient with Optional Response Handling\nDESCRIPTION: An improved TodoClient that includes method for fetching a Todo by ID with optional response handling, returning None instead of raising exceptions for non-existent resources.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nclass TodoClient(object):\n    \n    DEFAULT_HEADER = DEFAULT_HEADER\n    \n    def __init__(self, base_url, headers=None, logger=simple_logger, error_handler=default_error_handler):\n        self.base_url = base_url\n        self.headers = TodoClient.DEFAULT_HEADER if headers is None else headers\n        self.logger = logger\n        self.error_handler = error_handler\n        self.rget = to_get(base_url, headers=self.headers, error_handler=error_handler, logger=logger)\n        \n    def __repr__(self):\n        return \"<TodoClient {} >\".format(self.rget)\n    \n    def get_todos(self):\n        return self.rget('todos', transform=to_todos)\n    \n    def get_todo_by_id(self, ix):\n        rg = to_get(self.base_url, headers=self.headers, logger=simple_logger, error_handler=None)\n        return rg('todos/{}'.format(ix), transform=to_todo_or_none)\n```\n\n----------------------------------------\n\nTITLE: Testing Error Handling\nDESCRIPTION: This line attempts to fetch a non-existent resource at the endpoint 'does-not-exist', and then uses `handle_error_to_todo` to transform the (erroneous) response.  The `handle_error_to_todo` function will catch the error and raise an exception.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n# Now trigger an error\nrget('does-not-exist', transform=handle_error_to_todo)\n```\n\n----------------------------------------\n\nTITLE: Defining a Default Error Handler\nDESCRIPTION: This function `default_error_handler` takes a `response` object as input. It checks if the response's `ok` attribute is `True` (indicating a successful HTTP status code). If not, it raises an `Exception` with an error message that includes the URL, status code, and part of the response content.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef default_error_handler(response):\n    if not response.ok:\n        # This can also be done via .raise_for_status()\n        raise Exception(\"Failed request to {} status:{} {}\".format(response.url, response.status_code, response.content[:25]))\n    return response\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Usage of the GET Request Function\nDESCRIPTION: Examples showing how to use the configured GET request function to fetch and transform data from a REST API endpoint.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nrget('todos/1', transform=to_todo)\n```\n\nLANGUAGE: python\nCODE:\n```\n# As expected, no logging\nrget('todos/1', transform=to_todo)\n```\n\n----------------------------------------\n\nTITLE: Creating a Configurable HTTP GET Request Function with Response Pipeline\nDESCRIPTION: A factory function that produces a customized HTTP GET request function with configurable headers, error handling, and logging. The result includes a transformation pipeline to process API responses.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\ndef to_get(base_url, headers=None, error_handler=None, logger=None):\n    def f(segment, **kw):\n        url = \"/\".join([base_url, segment])\n        \n        h = kw.get('headers', {})\n        headers.update(h)\n        kw['headers'] = headers\n        \n        transform_func = kw.pop('transform', null_tranform)\n        err_handler = null_tranform if error_handler is None else error_handler\n        logger_func = null_tranform if logger is None else logger\n        \n        # Building custom response pipeline processor\n        transform = compose(transform_func, err_handler, logger_func)\n\n        return transform(requests.get(url, **kw))\n    return f\n```\n\n----------------------------------------\n\nTITLE: Defining the Base URL for the API\nDESCRIPTION: This line defines a constant `BASE_URL` which stores the base URL of the REST API.  This simplifies code by making it easier to update the base URL if the API's location changes.  It is a string value.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nBASE_URL = \"https://jsonplaceholder.typicode.com\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Transforming a List of Todos\nDESCRIPTION: This code calls `rget` which fetches data from the 'todos' endpoint. It then uses `transform=to_todos` to transform the response into a list of `Todo` objects. The code then prints the total count of todos found, and also prints the last todo object in the `todos` list.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ntodos = rget('todos', transform=to_todos)\nprint(\"Found {} todos\".format(len(todos)))\ntodos[-1]\n```\n\n----------------------------------------\n\nTITLE: Defining a Compose Function\nDESCRIPTION: This defines a `compose` function, which takes two functions, `f` and `g`, as arguments and returns a new function. The new function applies `g` to the input and then applies `f` to the result of `g`, effectively composing the two functions.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndef compose(f, g):\n    # this will return f(g(x))\n    def func(*args, **kw):\n        return f(g(*args, **kw))\n    return func\n```\n\n----------------------------------------\n\nTITLE: Defining a Todo Dataclass\nDESCRIPTION: This code defines a `Todo` dataclass using the `@dataclass` decorator. It specifies the fields `id`, `user_id`, `title`, and `completed`.  The `__post_init__` method calls the `validate` function to ensure that the dataclass is instantiated with the correct data types for its fields.  It also includes a `from_d` method that converts a dictionary to a Todo object.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass Todo:\n    id: int\n    user_id: int\n    title: str\n    completed: bool\n        \n    def __post_init__(self):\n        validate(self)\n        \n    @staticmethod\n    def from_d(d):\n        # Note, we've decoupled the response field names of the server from our data models.\n        # this renaming may or may not be a useful layer of abstraction for your use case\n        return Todo(d['id'], d['userId'], d['title'], d['completed'])\n```\n\n----------------------------------------\n\nTITLE: Applying Error Handling and Transformation\nDESCRIPTION: This line calls the `rget` function which makes a request to 'todos/1', and then passes the result to the `handle_error_to_todo` function. This transformation first handles any errors in the response using `default_error_handler`, and then converts the response to a `Todo` object using `to_todo`.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nhandle_error_to_todo(rget('todos/1'))\n```\n\n----------------------------------------\n\nTITLE: Basic Argparse CLI with Subcommands\nDESCRIPTION: Provides a standard implementation of a command-line interface using `argparse` with two subparsers: 'hello' and 'goodbye'. Each subparser defines a 'name' argument and uses `set_defaults` to associate itself with a specific handler function (`hello` or `goodbye`). The `runner` function parses arguments and calls the associated handler.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef hello(args):\n    print('Hello, {0}!'.format(args.name))\n\ndef goodbye(args):\n    print('Goodbye, {0}!'.format(args.name))\n\ndef get_parser(version=\"0.1.0\"):\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--version', action='version', version=version)\n    \n    subparsers = parser.add_subparsers()\n\n    hello_parser = subparsers.add_parser('hello')\n    hello_parser.add_argument('name')  # add the name argument\n    hello_parser.set_defaults(func=hello)  # set the default function to hello\n\n    goodbye_parser = subparsers.add_parser('goodbye')\n    goodbye_parser.add_argument('name')\n    goodbye_parser.set_defaults(func=goodbye)\n    return parser\n\ndef runner(argv):\n    parser = get_parser()\n    args = parser.parse_args(argv)\n    return(args.func(args))\n```\n\n----------------------------------------\n\nTITLE: Creating a Todo from JSON Response\nDESCRIPTION: This line calls the `rget` function (which is a result of the closure) to fetch data from the '/todos/1' endpoint, parses the JSON, and then calls the `Todo.from_d()` to instantiate a `Todo` object from the parsed JSON. This demonstrates the transformation from the JSON response to the concrete `Todo` data model.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nTodo.from_d(rget('todos/1').json())\n```\n\n----------------------------------------\n\nTITLE: Creating and Using the TodoClient\nDESCRIPTION: Examples showing how to initialize and use the TodoClient class to fetch todos from the API in a clean, high-level manner.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nclient = TodoClient(BASE_URL, logger=null_logger)\nclient\n```\n\nLANGUAGE: python\nCODE:\n```\ntodos = client.get_todos()\n```\n\nLANGUAGE: python\nCODE:\n```\nlen(todos)\n```\n\nLANGUAGE: python\nCODE:\n```\nclient.get_todo_by_id(2)\n```\n\n----------------------------------------\n\nTITLE: Creating an Instance with Default Headers\nDESCRIPTION: This line creates a new instance of the `to_get` closure named `rget`, passing in the `BASE_URL` and `DEFAULT_HEADER`. This configures the `rget` function to include the default headers in all subsequent requests.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nrget = to_get(BASE_URL, DEFAULT_HEADER)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Timing Decorator using Python Closures and datetime\nDESCRIPTION: Defines a custom_timer decorator that times function execution using datetime.datetime.now(), printing function name, args, kwargs, and elapsed seconds. Also defines adder, a test function using custom_timer, and run_example to demonstrate decorator usage. Inputs: arbitrary args/kwargs to decorated function; Output: function result, printed timing statement. Requires Python standard library (time, datetime).\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_20\n\nLANGUAGE: Python\nCODE:\n```\nimport time\n\ndef custom_timer(f):\n    def g(*args, **kw):\n        started_at = datetime.datetime.now()\n        result = f(*args, **kw)\n        completed_at = datetime.datetime.now()\n        dt = completed_at - started_at \n        msg = \"Ran func {} at {} in {:.2f} sec with args={} kw={}\".format(f.__name__, started_at, dt.total_seconds(), args, kw)\n        print(msg)\n        return result\n    return g\n\n@custom_timer    \ndef adder(a, b):\n    time.sleep(0.25)\n    return a + b\n\ndef run_example():\n    nums = zip(range(1, 5), range(7, 11))\n    for a, b in nums:\n        out = adder(a, b)\n```\n\n----------------------------------------\n\nTITLE: Defining a Transformer for a list of Todos\nDESCRIPTION: This defines a function `to_todos` to convert a list of JSON objects to a list of `Todo` objects. It uses a list comprehension and `Todo.from_d` to transform the data.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\ndef to_todos(response):\n    return [Todo.from_d(x) for x in response.json()]\n```\n\n----------------------------------------\n\nTITLE: Using to_get with error handling and transformation\nDESCRIPTION: This line calls `rget`, which makes a request to the 'todos/1' endpoint. It also specifies `transform=to_todo` which will transform a response using the `to_todo` transformer. The `error_handler` is included in the `rget` call, so that any errors will be handled.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nrget('todos/1', transform=to_todo)\n```\n\n----------------------------------------\n\nTITLE: Implementing a User-Friendly TodoClient Class\nDESCRIPTION: A client class that provides a high-level interface to the Todo API while internally using the functional request pipeline. This creates a better developer experience while maintaining extensibility.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nclass TodoClient(object):\n    \n    DEFAULT_HEADER = DEFAULT_HEADER\n    \n    def __init__(self, base_url, headers=None, logger=simple_logger, error_handler=default_error_handler):\n        # making this public so one-off cases can leverage the rget model. This is dipping\n        # down into the internals a bit. \n        h = TodoClient.DEFAULT_HEADER if headers is None else headers\n        self.rget = to_get(base_url, headers=h, error_handler=error_handler, logger=logger)\n        \n    def __repr__(self):\n        return \"<TodoClient {} >\".format(self.rget)\n    \n    def get_todos(self):\n        return self.rget('todos', transform=to_todos)\n    \n    def get_todo_by_id(self, ix):\n        return self.rget('todos/{}'.format(ix), transform=to_todo)\n```\n\n----------------------------------------\n\nTITLE: Defining a Closure for GET Requests\nDESCRIPTION: This closure takes a `base_url` and returns a function `f`. Function `f` takes a `segment` (relative URL path) and keyword arguments (`**kwgs`). It constructs the full URL by joining the `base_url` and the `segment`. Then, it uses `requests.get` to make a GET request to the constructed URL and returns the response. This is the core of the REST client.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef to_get(base_url):\n    def f(segment, **kwgs):\n        url = \"/\".join([base_url, segment])\n        return requests.get(url)\n    return f\n```\n\n----------------------------------------\n\nTITLE: Applying Pipeline and Retrieving Top N Users\nDESCRIPTION: This code demonstrates the use of the `to_pipeline` function. It filters users whose first name starts with 'R' and then retrieves the top 3 users and converts the output into a list. The output will be a list containing a maximum of 3 User instances.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nlist(to_pipeline(to_users(), filter_user_by_name('R'), 3))\n```\n\n----------------------------------------\n\nTITLE: Extending to_get to include error_handler\nDESCRIPTION: This updated `to_get` closure includes an `error_handler` parameter.  It now retrieves the `error_handler` from its arguments, or defaults to `null_tranform`.  Then, it composes the `transform_func` with the `error_handler` to enable easier and more direct control of error handling.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ndef to_get(base_url, headers=None, error_handler=None):\n    def f(segment, **kw):\n        url = \"/\".join([base_url, segment])\n        \n        h = kw.get('headers', {})\n        headers.update(h)\n        kw['headers'] = headers\n        \n        transform_func = kw.pop('transform', null_tranform)\n        err_handler = null_tranform if error_handler is None else error_handler\n        transform = compose(transform_func, err_handler)\n        \n        print(\"Making request {} with headers:{} with transform {}\".format(url, headers, transform))\n        return transform(requests.get(url, **kw))\n    return f\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple Filter Functions into a Single Filter in Python\nDESCRIPTION: Defines compose_two_filters to combine two boolean filters, and compose_filter to combine N filters into a single function returning a bool. Uses functools.reduce for N-ary composition. Resultant function can be passed to filter for pipeline processing. Useful for creating complex logical pipelines from basic predicates.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\ndef compose_two_filters(f, g):\n    def func(x):\n        if g(x):\n            return f(x)\n        return False\n    return func\n\ndef example():\n    filter_min_4 = functools.partial(custom_filter, 4)\n    f = compose_two_filters(f1, filter_min_4)\n    return filter(f, XS)\n\nlist(example())\n```\n\nLANGUAGE: python\nCODE:\n```\ndef compose_filter(funcs):\n    def compose_two_filters(f, g):\n        def func(x):\n            if g(x):\n                return f(x)\n            return False\n        return func\n    return functools.reduce(compose_two_filters, funcs)\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Composition in Python\nDESCRIPTION: A utility function that takes multiple functions and composes them together where the output of one function becomes the input of the next. This enables building functional pipelines for data transformation.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\ndef compose(*funcs):\n    \"\"\"Functional composition\n    [f, g, h] will be f(g(h(x)))\n    \"\"\"\n    def compose_two(f, g):\n        def c(x):\n            return f(g(x))\n        return c\n    return functools.reduce(compose_two, funcs)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Counting Closure with nonlocal Statement in Python 3\nDESCRIPTION: Defines a compute factory that properly increments num_times_called within the closure using the nonlocal keyword, avoiding UnboundLocalError. The returned f2 function tracks invocation count, exposing it through get_num_times. Inputs: m, n (function parameters); Outputs: result of f(m, n) and callable f2.get_num_times() for the count. Requires Python 3+.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\ndef compute(f=op.add):\n    \n    num_times_called = 0\n    \n    def get_num_times():\n        \"\"\"Return the cache size\"\"\"\n        return num_times_called\n\n    def f2(m, n):\n        nonlocal num_times_called\n        \n        num_times_called += 1\n        return f(m, n)\n\n    f2.get_num_times = get_num_times\n    return f2\n```\n\n----------------------------------------\n\nTITLE: Extending Closure to include Headers\nDESCRIPTION: This revised `to_get` function includes a `headers` parameter to add headers to the request. The function `f` now merges provided headers with default headers, constructs the URL, adds the headers to the request and returns the response.  This adds the functionality of setting HTTP headers.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef to_get(base_url, headers=None):\n    def f(segment, **kw):\n        h = kw.get('headers', {})\n        headers.update(h)\n        url = \"/\".join([base_url, segment])\n        kw['headers'] = headers\n        print(\"Making request {} with headers:{}\".format(url, headers))\n        return requests.get(url, **kw)\n    return f\n```\n\n----------------------------------------\n\nTITLE: Making a GET Request with Default Headers\nDESCRIPTION: This line calls `rget` with the endpoint 'todos/1'. The request automatically includes the `DEFAULT_HEADER` from the previous step, and the `.json()` method parses the response.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nrget('todos/1').json()\n```\n\n----------------------------------------\n\nTITLE: Creating and Using an Alpha CLI Argument Parser in Python\nDESCRIPTION: Demonstrates instantiating an argument parser using to_alpha_parser and parsing CLI arguments. Shows integration with argparse, handling of options and positional arguments, and the effect of function composition on parser configuration. Passing CLI arguments and accessing parsed output are shown. Requires previous parser construction utilities.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\np = to_alpha_parser(\"Alpha\")\n```\n\nLANGUAGE: python\nCODE:\n```\np.parse_args(\"1 2 3 --level=DEBUG\".split())\n```\n\n----------------------------------------\n\nTITLE: Testing the Enhanced TodoClient with Optional Response Handling\nDESCRIPTION: Examples demonstrating how the enhanced TodoClient handles both existing and non-existent resources gracefully.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nclient = TodoClient(BASE_URL)\n```\n\nLANGUAGE: python\nCODE:\n```\nclient.get_todo_by_id(1)\n```\n\nLANGUAGE: python\nCODE:\n```\nbad_todo = client.get_todo_by_id(\"DOES-NOT-EXIST\")\n```\n\nLANGUAGE: python\nCODE:\n```\nbad_todo is None\n```\n\n----------------------------------------\n\nTITLE: Applying Partial Application with Functools.partial\nDESCRIPTION: Uses `functools.partial` to create a new function `filter_lte_3` from `filter_min_value`. By binding the `min_value` argument to 3, the resulting function only requires one argument (`x`), effectively creating a specialized version.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfilter_lte_3 = functools.partial(filter_min_value, 3)\nprint(filter_lte_3)\n\n[x for x in XS if filter_lte_3(x)]\n```\n\n----------------------------------------\n\nTITLE: Using the transform parameter to parse the response\nDESCRIPTION: This code calls `rget` and makes a request to '/todos/1'. It then uses the `transform` keyword argument to apply the `handle_error_to_todo` function to the response. This handles errors and transforms the response into a `Todo` object.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nrget('todos/1', transform=handle_error_to_todo)\n```\n\n----------------------------------------\n\nTITLE: Composing Error Handling and Transformation\nDESCRIPTION: This code defines `handle_error_to_todo` by composing the `to_todo` function (which converts a JSON response to a `Todo` object) and the `default_error_handler` function (which handles errors). The result is a single function that first handles potential errors and then transforms the (successful) response into a `Todo` object.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# this has a type signtuare of (response) -> Todo\nhandle_error_to_todo = compose(to_todo, default_error_handler)\n```\n\n----------------------------------------\n\nTITLE: Instantiating a GET Request with Transformation\nDESCRIPTION: This line creates a new instance of the `to_get` closure, `rget`, and passes in the `BASE_URL` and the `DEFAULT_HEADER`, which will be used in every subsequent requests. This instance will be used to make requests to the server, and the requests will include the default header.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nrget = to_get(BASE_URL, DEFAULT_HEADER)\n```\n\n----------------------------------------\n\nTITLE: Reducing List with Initial Value Using Operator.add\nDESCRIPTION: Shows how to use the optional `init_value` argument with `functools.reduce` and `operator.add`. The reduction starts with the accumulator initialized to 11, adding all elements of the `range(10)` to it.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ninit_value = 11\nfunctools.reduce(op.add, range(10), init_value)\n```\n\n----------------------------------------\n\nTITLE: Repeatedly Accessing Cached Values Using Python Closures\nDESCRIPTION: Runs a for loop two times, each iteration calling f(1, 2). For already cached arguments, the function retrieves the result from the closure’s cache and prints a cache-hit message. Input: fixed arguments (1, 2); Output: repeated sum with cache messages.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nfor _ in range(2):\n    f(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Counting Closure with Mutable State (UnboundLocalError Example) in Python\nDESCRIPTION: Defines a compute factory intended to return a function f2 that counts invocations via num_times_called in its closure scope. An embedded get_num_times method exposes the call count, but due to Python’s scoping rules (without nonlocal), attempts to update num_times_called raise UnboundLocalError. Demonstrates pitfalls of mutating outer-scope variables in closures without proper scoping keywords. Inputs: two numbers (m, n); Outputs: result of executing f, with side effect tracking call count. Limitation: not functional in Python 3 until nonlocal is used.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\ndef compute(f=op.add):\n    \n    num_times_called = 0\n    \n    def get_num_times():\n        \"\"\"Return the cache size\"\"\"\n        return num_times_called\n\n    def f2(m, n):\n        # In scoping rules in Python num_times_called is never defined\n        num_times_called += 1\n        return f(m, n)\n\n\n    f2.get_num_times = get_num_times\n    return f2\n```\n\n----------------------------------------\n\nTITLE: Reducing via Map to Find Minimum Distance with Context in Python\nDESCRIPTION: Maps a lambda returning tuples (distance, point) over a sequence, then uses functools.reduce with min to find the closest point. Shows combining mapping, tuple context, and reduction to solve pipeline problems. Requires functools and to_distance as dependencies. Inputs are tuples representing coordinates.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\ndef example():\n    points = ((5, 12), (6, 8), (3, 4))\n    # let's return a tuple so we have the context of that data points\n    # were used. \n    f = lambda x: (to_distance(*x), x)\n    mx = map(f, points)\n    # this is arguably a bit sloppy and abusing tuple sorting. \n    return functools.reduce(min, mx)\n```\n\nLANGUAGE: python\nCODE:\n```\nexample()\n```\n\n----------------------------------------\n\nTITLE: Reducing Max Age User in Python\nDESCRIPTION: This function defines a reducer for finding the user with the maximum age within a stream of users. It takes an accumulator (`acc`) and a value (`value`) as input, comparing the age of the current value to the accumulator's age. It returns the user with the larger age.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\ndef reduce_max_age_user(acc, value):\n    if value.age < acc.age:\n        return acc\n    return value\n```\n\n----------------------------------------\n\nTITLE: Generalizing List Filtering Using Closures\nDESCRIPTION: Refactors the filtering logic using a closure. The `to_filter` function returns a function (the closure) that filters based on a `min_value` argument passed to the outer function, allowing the creation of reusable filter functions like `filter_3`.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef to_filter(min_value):\n    def func(x):\n        return x <= min_value\n    return func\n\nfilter_3 = to_filter(3)\n[x for x in XS if filter_3(x)]\n```\n\n----------------------------------------\n\nTITLE: Initializing GET Request Functions with Different Configurations\nDESCRIPTION: Examples of creating configured GET request functions with different parameters for logging and error handling to demonstrate the flexibility of the approach.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nrget = to_get(BASE_URL, headers=DEFAULT_HEADER, error_handler=default_error_handler, logger=simple_logger)\n```\n\nLANGUAGE: python\nCODE:\n```\nrget = to_get(BASE_URL, headers=DEFAULT_HEADER, error_handler=default_error_handler)\n```\n\n----------------------------------------\n\nTITLE: Reusable and Composable CLI Argument Parsers for Multiple Tools in Python\nDESCRIPTION: Refactors argument parser building using higher-order functions. Defines _to_opt for generating new argument additions, restructures _to_opt_xy, and implements to_parser for generic parser assembly via composition. Constructs individual parsers for Alpha, Beta, and Gamma tools, showing how to eliminate duplication using composition patterns. Depends on argparse and earlier compose utility.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ndef _to_opt(achar, default, help):\n    def func(p):\n        p.add_argument(achar, type=int, default=default, help=help)\n        return p\n    return func\n\ndef _to_opt_xy(p):\n    opts = [('X', 10, \"X Value\"), ('Y', 20, \"Y Value\")]\n    f_opt = lambda x: _to_opt(*x)\n    opt_funcs = map(f_opt, opts)\n    f = compose(*opt_funcs)\n    return f(p)\n\ndef to_parser(name, funcs):\n    p = argparse.ArgumentParser(description=\"Test Tool {}\".format(name))\n    f = compose(*funcs)\n    return f(p)    \n\ndef to_alpha_parser():\n    funcs = (_to_opt_xy, _to_log_opt)\n    return to_parser(\"Alpha\", funcs)\n\ndef to_beta_parser():\n    #let define this inline since it's not shared\n    def f(p):\n        p.add_argument('--min-radius', help=\"min radius\", default=10)\n        return p\n    funcs = (f, _to_log_opt)\n    return to_parser(\"Beta\", funcs)\n\ndef to_gamma_parser():\n    _to_opt_z = _to_opt('Z', 30, \"Z Value\")\n    funcs = (_to_opt_z, _to_opt_xy, _to_log_opt)\n    return to_parser(\"Gamma\", funcs)\n```\n\n----------------------------------------\n\nTITLE: Initializing Logger for Iteration 3\nDESCRIPTION: Imports the `Optional` type hint from `typing` and initializes a logger instance using Python's `logging` module. This sets up the basic components needed to integrate logging configuration and usage into the CLI structure in Iteration 3.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import Optional\n\nlogger = logging.getLogger(__name__)\n```\n\n----------------------------------------\n\nTITLE: Executing Basic CLI Example Test\nDESCRIPTION: Calls the `run_example` helper function to test the basic `argparse` CLI implementation (`runner` from the previous snippet) using the predefined default list of test arguments (`ARGS`). This demonstrates the execution flow for the 'hello' and 'goodbye' subcommands.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nrun_example(runner)\n```\n\n----------------------------------------\n\nTITLE: Defining Function for Partial Application Example\nDESCRIPTION: Defines a standard function `filter_min_value` that takes two arguments. This function serves as the base example to demonstrate how `functools.partial` can be used to fix one or more arguments.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef filter_min_value(min_value, x):\n    return x <= min_value\n\nfor x, y in [(2, 4),(4, 3)]:\n    print(\"min={} x={} {}\".format(x, y, filter_min_value(x, y)))\n```\n\n----------------------------------------\n\nTITLE: Caching New Values in Closure-based Function in Python\nDESCRIPTION: Invokes f(1, 3) to compute and cache a new pair of arguments. This demonstrates that the closure pattern supports multiple, independent input combinations. Input: two integers (1, 3); Output: their sum and caching side effect.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nf(1, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Simple Pure Functions in Python\nDESCRIPTION: Defines three pure functions: squarer (squares input), doubler (doubles input), and incrementer (increments input by 1). Demonstrates their composition through nested function calls in forgetting_basics_of_programming, which contains redundant logic for combining the function results. No external dependencies are required. Inputs are integers and output is a list of computed values using chained function applications.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndef squarer(a):\n    return a * a\n\ndef doubler(a):\n    return 2 * a\n\ndef incrementer(a):\n    return a + 1\n\ndef forgetting_basics_of_programming():\n    # This is terrible for so many reasons\n    a = squarer(doubler(1))\n    b = squarer(doubler(2))\n    c = squarer(doubler(3))\n    abc = [a,b,c]\n    return abc\n```\n\n----------------------------------------\n\nTITLE: Implementing function composition in Python using functools\nDESCRIPTION: This snippet defines a 'compose' function that combines multiple functions into a single callable, executing from right to left (h(g(f(x)))). It utilizes functools.reduce and demonstrates how to chain functions in a functional style with a core focus on composition. The snippet also includes simple functions like adder and multiply, as well as partial applications for adding constants, culminating in applying the composed function to an integer input.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport functools\n\ndef compose(*funcs):\n    \"\"\"Functional composition [f, g, h] will be h(g(f(x))) \"\"\"\n    def compose_two(f, g):\n        def c(x):\n            return f(g(x))\n        return c\n    return functools.reduce(compose_two, reversed(funcs))\n\n\ndef adder(a: int, b: int) -> int:\n    return a + b\n\n\ndef multiply(n: int):\n    def wrapper(m: int) -> int:\n        return m * n\n    return wrapper\n\nadd_one = functools.partial(adder, 1)\nadd_two = functools.partial(adder, 2)\n\nf = compose(add_one, multiply(3), add_two)\nassert f(7) == 26\n\nfp = compose(f, print)\nfp(7)\n```\n\n----------------------------------------\n\nTITLE: Modifying Name of Partially Applied Function\nDESCRIPTION: Demonstrates manually setting the `__name__` attribute of the partially applied function (`filter_lte_3`) to a more descriptive string, improving its representation for introspection or debugging.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfilter_lte_3.__name__ = \"Filter lte 3\"\nprint(filter_lte_3.__name__)\n```\n\n----------------------------------------\n\nTITLE: Abusing Mutation within a Python Closure Example\nDESCRIPTION: Defines bad_example, returning a function that mutates multiple enclosed variables (alpha, beta, gamma) using nonlocal within inner functions. Shows the dangers and opacity of excessive stateful mutation in closures, analogizing to highly mutable classes. Inputs: integer m for outer, integer n for inner; Outputs: formatted string with state. Prerequisite: Python 3 for nonlocal keyword.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\ndef bad_example(m):\n    \n    alpha = 1\n    beta = 2\n    gamma = 3.0\n    \n    def to_gamma(n):\n        nonlocal gamma \n        gamma = (alpha + 1) * (beta + 2) + (n + m)\n        \n    def to_alpha(n):\n        nonlocal alpha \n        alpha = beta * (n + m)\n        \n    def to_beta(n):\n        nonlocal beta \n        beta = alpha * 3.14 * m\n    \n    def f(n):\n        to_gamma(n)\n        to_alpha(n)\n        to_beta(n)\n        return \"alpha={:.2f}, beta={:.2f}, gamma={:.2f}\".format(alpha, beta, gamma)\n    \n    return f\n```\n\n----------------------------------------\n\nTITLE: Refactoring Argparse - Iteration 1\nDESCRIPTION: The first iteration of refactoring the `argparse` CLI structure using functional programming. It separates library logic (`lib_hello`, `lib_goodbye`) from the CLI wrapper functions (`run_hello`, `run_goodbye`) and introduces a nested helper function `_add_to_sp` within `get_parser` to reduce boilerplate when adding subparsers.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n# Ideally, this should from my lib code and shouldn't\n# mix the IO layer from CLI interface\n\ndef lib_hello(name):\n    print('Hello, {0}!'.format(name))\n    \ndef lib_goodbye(name):\n    print('Goodbye, {0}!'.format(name))\n    \n\n# CLI. Wrapper funcs of (arg) -> f(a, b, c)\ndef run_hello(args):\n    return lib_hello(args.name)\n\ndef run_goodbye(args):\n    return lib_goodbye(args.name)\n\ndef _add_opt_name(p):\n    p.add_argument('name', help=\"User Name\")\n    return p\n\n\ndef get_parser(version='0.1.0'):    \n\n    parser = argparse.ArgumentParser(description=\"Help for Tool\")\n    parser.add_argument('--version', action='version', version=version)\n    subparsers = parser.add_subparsers()\n    \n    def _add_to_sp(name, add_opts, func):\n        p = subparsers.add_parser(name)\n        add_opts(p)\n        p.set_defaults(func=func)\n        return p\n\n    _add_to_sp('hello', _add_opt_name, run_hello)\n    _add_to_sp('goodbye', _add_opt_name, run_goodbye)\n    \n    return parser\n\ndef runner(argv):\n    p = get_parser()\n    pargs = p.parse_args(argv)\n    return pargs.func(pargs)\n```\n\n----------------------------------------\n\nTITLE: Defining a Closure for Addition in Python\nDESCRIPTION: Similar to the previous example, this code defines a closure that encapsulates an integer `n`. The inner function `f` takes an integer `m` and returns the sum of `n` and `m`. This illustrates how closures can be used to create functions with pre-set parameters or state.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef adder(n):\n    def f(m):\n        return n + m\n    return f\n\nadd_two = adder(2)\nx = add_two(9)\nprint(x)\n```\n\n----------------------------------------\n\nTITLE: Triggering a Counting Function and Observing UnboundLocalError in Python\nDESCRIPTION: Calls the faulty closure-based function f with arguments (2, 3), which raises an UnboundLocalError. This snippet is designed to showcase the necessity of nonlocal when modifying closure variables in Python 3. Inputs: (2, 3); Output: Exception raised.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nf(2, 3)\n```\n\n----------------------------------------\n\nTITLE: Creating a Cached Function using Closures in Python\nDESCRIPTION: Defines a function factory compute that returns a function f2 which uses a closure-scoped cache dictionary to memoize results of the provided binary function f (defaulting to operator.add). Each call to f2 with the same arguments retrieves from cache; new arguments compute and store the result. Requires no external dependencies beyond the standard library. Inputs: two arguments m, n; Outputs: cached function result. Limitation: cache persists only for the closure’s lifecycle.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef compute(f=op.add):\n    \n    cache = {}\n\n    def f2(m, n):\n        key = (m, n)\n        if key in cache:\n            value = cache[key]\n            print(\"Loading from cache {}={}\".format(key, value))\n            return value\n        else:\n            v = f(m, n)\n            cache[key] = v\n            return v\n    return f2\n```\n\n----------------------------------------\n\nTITLE: Incrementing Call Count with nonlocal-enabled Counting Closure in Python 3\nDESCRIPTION: Further demonstrates the counting closure by calling f(2, 3). This increments and maintains the call count within the closure. Input: (2, 3); Output: sum; side effect: increments call count.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nf(2, 3)\n```\n\n----------------------------------------\n\nTITLE: Calling the Example Function for Composed Operations in Python\nDESCRIPTION: Invokes the forgetting_basics_of_programming function, demonstrating the output from the redundant function chaining of squarer and doubler. Evaluates code correctness and output data structure. No dependencies beyond the previous function definitions are necessary.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nforgetting_basics_of_programming()\n```\n\n----------------------------------------\n\nTITLE: Extending Argparse - Iteration 2\nDESCRIPTION: The second iteration builds upon the first, extending the 'hello' subparser to include a new `--num-times` option using the `add_opt_hello` function. This demonstrates adding specific options to a subparser and potentially reusing shared option logic (`_add_opt_name`), improving modularity and extensibility.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\ndef lib_hello(name, num_times=1):\n    for _ in range(0, num_times):\n        print('Hello, {0}!'.format(name))\n    \ndef run_hello(args):\n    return lib_hello(args.name, args.num_times)\n\ndef add_opt_hello(p):\n    _add_opt_name(p)\n    p.add_argument('--num-times', help=\"Number of times to print hello\", default=1, type=int)\n    return p\n\n\ndef get_parser(version='0.1.0'):    \n\n    parser = argparse.ArgumentParser(description=\"Help for Tool\")\n    parser.add_argument('--version', action='version', version=version)\n    subparsers = parser.add_subparsers()\n    \n    def _add_to_sp(name, add_opts, func):\n        p = subparsers.add_parser(name)\n        add_opts(p)\n        p.set_defaults(func=func)\n        return p\n\n    _add_to_sp('hello', add_opt_hello, run_hello)\n    _add_to_sp('goodbye', _add_opt_name, run_goodbye)\n    \n    return parser\n\ndef runner(argv):\n    p = get_parser()\n    pargs = p.parse_args(argv)\n    return pargs.func(pargs)\n```\n\n----------------------------------------\n\nTITLE: Creating a GET Request Function Instance\nDESCRIPTION: This creates an instance of the `to_get` closure, named `rget`, by passing the `BASE_URL`. This `rget` function is then used to make requests to specific API endpoints. It simplifies calling the REST API endpoints.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nrget = to_get(BASE_URL)\n```\n\n----------------------------------------\n\nTITLE: Composing Argument Parser Functions for CLI Tools in Python\nDESCRIPTION: Defines utility functions to add arguments to an argparse parser instance. Shows how to combine argument-adding functions with compose for CLI code reuse, building complex parsers. External dependency: argparse, and compose from previous sections. Functions modify the parser in-place and return the modified parser. Each utility adds specific CLI options with default values and helps.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ndef _to_log_opt(p):\n    p.add_argument('--level', help=\"Logging Level\", default=\"INFO\")\n    return p\n\ndef _to_opt_xy(p):\n    p.add_argument('x', type=int, default=10, help=\"X Value\")\n    p.add_argument('y', type=int, default=20, help=\"Y Value\")\n    return p\n\ndef _to_opt_z(p):\n    p.add_argument('z', type=int, default=30, help=\"Z Value\")\n    return p\n\ndef to_alpha_parser(name):\n    p = argparse.ArgumentParser(description=\"Test Tool {}\".format(name))\n    f = compose(_to_opt_z, _to_opt_xy, _to_log_opt)\n    return f(p)\n```\n\n----------------------------------------\n\nTITLE: Building Advanced Data Pipeline in Python\nDESCRIPTION: This function creates a more complex data pipeline that retrieves the top `max_users` users, filtered by a user filter. It uses `filter`, `map`, and the `compute_max_n` function. The `user_to_tuple` is used to convert user objects to tuples compatible with the heap, and `from_tuple` is used to convert back to users.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_44\n\nLANGUAGE: python\nCODE:\n```\ndef to_pipeline(users_it, user_filter, max_users):\n    \n    reducer = compute_max_n(max_users)\n    \n    # Note, the map and filter are Iterables\n    p1 = filter(user_filter, users_it)\n    p2 = map(user_to_tuple, p1)\n    \n    # this is effectively the reduce step,\n    # however, it results a list\n    p3 = reducer(p2)\n    \n    # transform back to list[User]\n    p4 = map(from_tuple, p3)\n    return p4\n```\n\n----------------------------------------\n\nTITLE: Tracking Function Calls with Mutable List Container in Python 2-style Closure\nDESCRIPTION: Implements a workaround for Python 2 closure scoping by storing a mutable integer in a single-element list (total). The closure increments total[0] and exposes get_total as a callable attribute. Demonstrates legacy patterns for managing mutable closure state prior to nonlocal. Inputs: single integer n; Outputs: sum and current call count. Not recommended for Python 3, where nonlocal is available.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\ndef two_seven(n):\n    # DONT do this in Python 3. Use nonlocal.\n    total = [0]\n    \n    def f(m):\n        total[0] += 1\n        return n + m\n    \n    def get_total():\n        return total[0]\n    \n    # see comments below about use of this pattern\n    f.get_total = get_total\n    return f\n```\n\n----------------------------------------\n\nTITLE: Executing Iteration 1 Refactoring Test\nDESCRIPTION: Runs the `run_example` utility with the default test arguments (`ARGS`) against the `runner` function from Iteration 1. This verifies that the first refactored version of the CLI handles the basic 'hello' and 'goodbye' commands correctly.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nrun_example(runner)\n```\n\n----------------------------------------\n\nTITLE: Defining runner function with error handling in Python\nDESCRIPTION: This code defines a `runner` function that orchestrates the execution of a command-line tool. It parses arguments, sets up logging, executes the selected function, and handles exceptions.  It accepts `argv`, `setup_logger`, `error_handler`, and `run_epilogue` as arguments. The return value is the exit code (0 for success, non-zero for failure).\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndef runner(argv,\n           setup_logger=setup_logger,\n           error_handler=error_handler,\n           run_epilogue=run_epilogue) -> int:\n    \n    exit_code = 1\n    started_at = datetime.datetime.now()\n    \n    p = get_parser()\n    pargs = p.parse_args(argv)\n    \n    setup_logger(pargs.level, pargs.log_file)\n    logger.debug(pargs)\n    \n    try:\n        out = pargs.func(pargs)\n        exit_code = 0\n    except Exception as ex:\n        exit_code = error_handler(ex)\n\n    run_epilogue(exit_code, started_at)\n    return(exit_code)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nonlocal and Python 2 Closure State\nDESCRIPTION: Explains how to modify variables in an enclosing scope within a closure using the `nonlocal` keyword (Python 3). Provides a `two_seven` function example showing a less ideal technique used in Python 2 (modifying a mutable list) to achieve similar state persistence in a closure, advising against this method in Python 3.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef two_seven(n):\n    # DONT do this in Python 3. Use nonlocal.\n    total = [0]\n    \n    def f(m):\n        total[0] += 1\n        return n + m\n    \n    def get_total():\n        return total[0]\n    \n    # see comments below about use of this pattern\n    f.get_total = get_total\n    return f\n\ndef two_seven_example():\n    f27 = two_seven(2)\n    def fx():\n        return f27(1)\n    for _ in range(5):\n        for name, func in ((\"calling func\", fx), (\"total times called\", f27.get_total)):\n            print(\"{}={}\".format(name, func()))\n\ntwo_seven_example()\n```\n\n----------------------------------------\n\nTITLE: Creating Callable Objects Using Classes\nDESCRIPTION: Shows how to create callable objects by defining classes (`F3`, `F4`) that implement the `__call__` method. This is useful for creating functions with internal state (`F4`). Also demonstrates accessing a bound method (`f5`) from the callable object.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Or using a class style. \nclass F3(Callable):\n    def __call__(self, n):\n        return n * n\n    \nf3 = F3()\nprint((\"Callable class {} {}\".format(f3, f3(3))))\n\nassert f3(3) == f1(3)\n\n# Perhaps a better example. \nclass F4(Callable):\n    def __init__(self, n):\n        self.n = n\n    \n    def __repr__(self):\n        _d = dict(k=self.__class__.__name__, n=self.n)\n        return \"<{k} n:{n}>\".format(**_d)\n    \n    def __call__(self, n):\n        return self.n * n\n    \ndef compute(self, n):\n        return self.n * n\n\nf4 = F4(2)\nprint(f4)\n\nassert f4(3) == 6\n\n# You can also define a bound function\nf5 = f4.compute\nprint(f5)\n\nassert f5(3) == 6\n```\n\n----------------------------------------\n\nTITLE: Building Data Pipeline in Python\nDESCRIPTION: This function constructs a simple data pipeline using `filter` and `functools.reduce`. It takes an iterable of users (`users_it`) and a user filter function (`user_filter`) as input. It applies the filter to the user stream and then reduces the stream using `reduce_max_age_user` to find the user with the maximum age.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\ndef to_pipeline(users_it, user_filter):\n    # Simple pipeline will only one step. \n    # Note, this doesn't store the entire user's list in memory.\n    s1 = filter(user_filter, to_users())\n    result = functools.reduce(reduce_max_age_user, s1)\n    return result\n```\n\n----------------------------------------\n\nTITLE: Implementing Max N Users Function\nDESCRIPTION: This function implements the 'reduce' step to retrieve the top N users by age using a max heap. It leverages the `heapq` module. The function takes an iterable of users (`it`) and the desired number of top users (`n`). It uses `heapq.heappush` and `heapq.heappop` to maintain a heap of size `n`, and `heapq.nlargest` to return the `n` largest elements.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nimport heapq as H\n\n# https://docs.python.org/3.7/library/heapq.html\n\ndef compute_max_n(n):\n    def f(it):\n        h = []\n        H.heapify(h)\n        for item in it:\n            if len(h) < n:\n                H.heappush(h, item)\n            else:\n                # this will keep the heap to size `n`\n                # Therefore keeping the space complexity to approximately O(1)\n                _ = H.heappushpop(h, item)\n        return H.nlargest(n, h)\n    return f\n```\n\n----------------------------------------\n\nTITLE: Composing N Functions Using a Closure and functools.reduce in Python\nDESCRIPTION: Implements a generic compose function to combine an arbitrary number of unary functions into a single callable, using a closure and functools.reduce. compose_two composes two functions, and compose applies this recursively over N inputs. Requires functools from the standard library. Inputs are functions, output is a new composed function. Adheres to function composition semantics: compose(f, g, h)(x) == f(g(h(x))).\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndef compose(*funcs):\n    \"\"\"\n    Functional composition\n    [f, g, h] will be f(g(h(x)))\n    \"\"\"\n    def compose_two(f, g):\n        def c(x):\n            return f(g(x))\n        return c\n    return functools.reduce(compose_two, funcs)\n```\n\n----------------------------------------\n\nTITLE: Defining argparse parser with subparsers in Python\nDESCRIPTION: This code defines a function `get_parser` that creates and configures an `argparse.ArgumentParser` instance for a command-line tool. It sets up version information and adds subparsers to handle different commands. The function takes a version string as input and returns the configured parser.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef get_parser(version='0.1.0'):    \n\n    parser = argparse.ArgumentParser(description=\"Help for Tool\")\n    parser.add_argument('--version', action='version', version=version)\n    subparsers = parser.add_subparsers()\n    \n    def _add_to_sp(name, add_opts, func):\n        p = subparsers.add_parser(name)\n        # For consistency we want the logging opts to be\n        # added to all subparsers\n        f = compose(add_opts, _add_opt_logging)\n        _ = f(p)\n        p.set_defaults(func=func)\n        return p\n\n    _add_to_sp('hello', add_opt_hello, run_hello)\n    _add_to_sp('goodbye', _add_opt_name, run_goodbye)\n    \n    return parser\n```\n\n----------------------------------------\n\nTITLE: Extending to_get to include transform\nDESCRIPTION: This updated version of the `to_get` closure adds a `transform` parameter. Inside the closure, the code now uses `kw.pop('transform', null_tranform)` to retrieve a transform function from the keyword arguments, defaulting to `null_tranform` if none is provided.  It then calls the transform on the result of the GET request.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndef null_tranform(response):\n    return response\n\ndef to_get(base_url, headers=None):\n    def f(segment, **kw):\n        url = \"/\".join([base_url, segment])\n        \n        h = kw.get('headers', {})\n        headers.update(h)\n        kw['headers'] = headers\n        \n        transform_func = kw.pop('transform', null_tranform)\n        \n        print(\"Making request {} with headers:{} with transform {}\".format(url, headers, transform_func))\n        return transform_func(requests.get(url, **kw))\n    return f\n```\n\n----------------------------------------\n\nTITLE: Running a Container-based Counting Closure Example in Python\nDESCRIPTION: Defines and runs two_seven_example, which repeatedly calls a closure-based function while printing the call count using the attached get_total method. Demonstrates use of closure state across multiple invocations with a for loop. Inputs: none; Output: printed call count and computation results.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\ndef two_seven_example():\n    f27 = two_seven(2)\n    def fx():\n        return f27(1)\n    for _ in range(5):\n        for name, func in ((\"calling func\", fx), (\"total times called\", f27.get_total)):\n            print(\"{}={}\".format(name, func()))\n\ntwo_seven_example()\n```\n\n----------------------------------------\n\nTITLE: Importing Modules for REST Client\nDESCRIPTION: This code imports necessary modules for the REST client. `requests` is used for making HTTP requests, `functools` is imported (though not explicitly used in the snippets), `collections.namedtuple` is not used directly, `datetime` is for time-related operations, `logging` and `sys` are for system related activities and `dataclasses` which is used for defining data structures in a concise way.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport functools\nfrom collections import namedtuple\nimport datetime\nimport logging\nimport sys\n# This requires python >= 3.7\nfrom dataclasses import dataclass\n```\n\n----------------------------------------\n\nTITLE: Defining a Closure for Greeting in Python\nDESCRIPTION: This code snippet provides a basic example of a closure in Python. The `say` function encapsulates a `message` and returns an inner function `f` which takes a `name` as input and constructs a greeting string.  This demonstrates the ability of an inner function to access variables from its enclosing scope, even after the outer function has finished executing.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef say(message):\n    def f(name):\n        return \" \".join([message, name])\n    return f\n\nsay_hello = say(\"Hello\")\nprint(say_hello(\"Steve\")\n```\n\n----------------------------------------\n\nTITLE: Parsing Command Line Options Using Composed Parsers in Python\nDESCRIPTION: Uses Alpha, Beta, and Gamma argument parsers to parse different sets of CLI arguments, including help and value options. Demonstrates error handling, argparse's sys.exit behavior, and compatibility with notebooks. Standard inputs are lists of argument strings; outputs are Namespace objects. Requires the previously defined parser constructors.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nalpha_parser = to_alpha_parser()\n# Note, argparse is kinda brutal with it's use of sys.exit. \n# this doesn't really play well with the notebook\nalpha_parser.parse_args([\"--help\"])\n```\n\nLANGUAGE: python\nCODE:\n```\nalpha_parser.parse_args(\"1 2 --level=WARN\".split())\n```\n\nLANGUAGE: python\nCODE:\n```\nbeta_parser = to_beta_parser()\nbeta_parser.parse_args(\"--min-radius 11\".split())\n```\n\nLANGUAGE: python\nCODE:\n```\ngamma_parser = to_gamma_parser()\ngamma_parser.parse_args(\"1 2 3 --level=ERROR\".split())\n```\n\n----------------------------------------\n\nTITLE: Defining Demo Data and User Generator\nDESCRIPTION: Sets up demo data including a range `XS` and a `User` dataclass. Defines a `to_users` generator function using `functools.partial` and `random` to create an iterable of `User` objects with random data, used for subsequent examples.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nXS = range(10)\n\n@dataclass(frozen=True)\nclass User(object):\n    user_id:int\n    age:int    \n    first_name:str\n    favorite_color:str  \n\n        \ndef to_users():\n    colors = ['red', \"blue\", \"black\", \"orange\", \"yellow\"]\n    def to_random(xs):\n        return random.choice(xs)\n    to_color = functools.partial(to_random, colors)\n    \n    names = [(\"Ralph\", 13), (\"Joe\", 43),(\"Steve\", 66), (\"Rebecca\", 41), \n             (\"Sam\", 4), (\"Richard\", 32), (\"Paul\", 87), \n             (\"Stephen\", 55), (\"Sean\", 2)]\n\n    for i, (name, age) in enumerate(names):\n        yield User(i + 1, age, name, to_color())\n```\n\n----------------------------------------\n\nTITLE: Defining exception to integer return code mapping in Python\nDESCRIPTION: This code defines an error handler function that maps Python exceptions to integer return codes. It uses a dictionary to map exception class names to corresponding error codes and returns a default error code if the exception is not found in the dictionary. The function takes an exception object and an optional default error code as input.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndef error_handler(ex, default_error_code=1) -> int:\n    \"\"\"Responsible for mapping the Exception to an Int\n    \n    Note, this should also write the stacktrace to log or stderr.\n    \"\"\"\n    d = {'ZeroDivisionError': 7, \n         'IOError':3,\n         'ValueError': 4\n        }\n    return d.get(ex.__class__.__name__, default_error_code)\n```\n\n----------------------------------------\n\nTITLE: Importing Core Modules for Functional Programming in Python\nDESCRIPTION: This snippet imports the datetime module for handling date/time operations and the operator module as op for functional-style operations. No additional installation is required as both are part of Python's standard library. These imports are foundational for date tracking and functional patterns used throughout subsequent examples. Inputs/outputs are not applicable; scope is global to the file.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport datetime\nimport operator as op\n```\n\n----------------------------------------\n\nTITLE: Defining Nullable Function Interface Pattern\nDESCRIPTION: Introduces a pattern using Python's `typing.Optional` and 'null' or 'identity' functions (like `setup_logger_null`) to clearly define interfaces for optional function arguments (hooks/callbacks). This provides a clearer API definition compared to using `None` and facilitates extending the CLI's runner with custom logic.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import Optional\n\ndef setup_logger_null(level:str, output_file:Optional[str]=None) -> None:\n    # implementation omitted for avoid chatter\n    pass\n\ndef runner(args, setup_logger=setup_logger_null) -> int:\n    setup_logger(args.level, args.output_file)\n```\n\n----------------------------------------\n\nTITLE: Utility for Testing CLI Runner\nDESCRIPTION: Defines a list of argument lists (`ARGS`) used for testing and a helper function `run_example` that iterates through these lists. It takes a runner function (like the one produced by `get_parser`) and calls it with each set of arguments, printing the arguments before execution.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nARGS = [[\"hello\", 'my-name'],\n        [\"goodbye\", 'my-new-name'],\n        [\"hello\", '--help'], # ipython won't play nicely with the argparse useage of sys.exit\n        ]\n\ndef run_example(runner_func, args=ARGS):\n    for arg in args:\n        print(\"Running with args {}\".format(arg))\n        runner_func(arg)\n```\n\n----------------------------------------\n\nTITLE: Defining Basic and Configurable Filter Functions in Python\nDESCRIPTION: Implements a custom_filter function to select even integers above a minimum value, then generalizes via to_filter to allow parameterization. Demonstrates building filter pipelines and returning iterable objects. Shows interaction with filter, use of partial application via functools, and list conversion from filter objects. Inputs are integers or ranges; output is filtered collections.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\ndef custom_filter(x):\n    return (x % 2) == 0 and x >= 2\n```\n\nLANGUAGE: python\nCODE:\n```\nfx = filter(custom_filter, range(0, 10))\nisinstance(fx, Iterable)\n\n```\n\nLANGUAGE: python\nCODE:\n```\nlist(fx)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef to_filter(min_value):\n    def f(x):\n        return (x % 2) == 0 and x >= min_value\n    return f\n```\n\nLANGUAGE: python\nCODE:\n```\nf = to_filter(2)\nlist(filter(f, range(-2, 10)))\n```\n\nLANGUAGE: python\nCODE:\n```\ndef custom_filter(min_value, x):\n    return (x % 2) == 0 and x >= min_value\n```\n\nLANGUAGE: python\nCODE:\n```\nf = functools.partial(custom_filter, 2)\n\nlist(filter(f, XS))\n```\n\n----------------------------------------\n\nTITLE: Handling Impedance Mismatch in Function Signatures for Mapping in Python\nDESCRIPTION: Shows mapping over tuples of input to functions requiring positional unpacking or extra arguments, such as a distance function. Uses lambda and closures to adapt signatures. Demonstrates mapping a two-coordinate tuple input to compute Euclidean distances, using the math module.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nimport math\ndef to_distance(x, y, x0=0, y0=0):\n    def f(a, a0):\n        return math.pow(a - a0, 2)\n    return math.sqrt(f(x, x0) + f(y, y0))\n\ndef example():\n    points = [(3, 4), (5, 12)]\n    f = lambda x: to_distance(*x)\n    return map(f, points)\n```\n\nLANGUAGE: python\nCODE:\n```\nto_distance(3, 4)\n```\n\nLANGUAGE: python\nCODE:\n```\nlist(example())\n```\n\n----------------------------------------\n\nTITLE: Generating a Cached Adder Function Instance in Python\nDESCRIPTION: Instantiates a cached binary function f using the compute factory, with default behavior of addition. The resulting f can cache sum computations for pairs of numbers, illustrating practical use of closures for memoization. No additional dependencies. No arguments are required for instantiation; output is a new callable function.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nf = compute()\n```\n\n----------------------------------------\n\nTITLE: Defining Functional Composition Utility\nDESCRIPTION: Implements a `compose` function that takes a variable number of functions and returns a new function representing their composition. The composition applies functions from right to left (e.g., `f(g(h(x)))` for `funcs=[f, g, h]`) using `functools.reduce`, a core functional programming pattern.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef compose(*funcs):\n    \"\"\"Functional composition\n    [f, g, h] will be f(g(h(x)))\n    \"\"\"\n    def compose_two(f, g):\n        def c(x):\n            return f(g(x))\n        return c\n    return functools.reduce(compose_two, funcs)\n```\n\n----------------------------------------\n\nTITLE: Building Filter Pipelines Using functools.partial and Multiple Filters in Python\nDESCRIPTION: Demonstrates chaining filters using both partial application and functional composition. Shows creating a function pipeline with functools.partial and filter. Constructs a two-step filtering process, then lists results. Input is an integer sequence; output is a filtered generator or list.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ndef f1(x):\n    return (x % 2) == 0\n\ndef example():\n    f = functools.partial(custom_filter, 4)\n    # Steps in the pipeline\n    s1 = filter(f, range(1, 10))\n    s2 = filter(f1, s1)\n    return s1\n\nprint(example())\nlist(example())\n```\n\n----------------------------------------\n\nTITLE: Improving Function Composition Example for Lists in Python\nDESCRIPTION: Defines getting_better to remove duplication by creating a composed function and applying it to inputs. Shows better composition and reuse. Also defines to_better which further streamlines the application using a list comprehension with range. Both functions rely on compose and previous utility functions.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ndef getting_better():\n    f = compose(squarer, doubler)\n    a = f(1)\n    b = f(2)\n    c = f(3)\n    return [a, b, c]\n```\n\nLANGUAGE: python\nCODE:\n```\ndef to_better():\n    f = compose(squarer, doubler)\n    return [f(x) for x in range(1, 4)]\n```\n\n----------------------------------------\n\nTITLE: Defining a Validation Function\nDESCRIPTION: This defines a `validate` function that iterates through the fields of a dataclass instance and checks if the attribute's type matches its declared type. If there's a type mismatch, it raises a `TypeError`.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass, fields\n\n# https://stackoverflow.com/questions/51736938/python-3-7-how-to-validate-typing-attributes\n# why is this not in the stdlib?\ndef validate(instance):\n    for field in fields(instance):\n        attr = getattr(instance, field.name)\n        if not isinstance(attr, field.type):\n            msg = \"Field {0.name} (value='{2}') is of type {1}, should be {0.type}\".format(field, type(attr), attr)\n            raise TypeError(msg)\n```\n\n----------------------------------------\n\nTITLE: Computing and Caching Values with Closure-based Function in Python\nDESCRIPTION: Demonstrates invoking the previously created closure-based function f with arguments (1, 2). The call computes the sum and stores it in the closure's cache. Inputs: two integers (1, 2); Output: their sum, printed to standard output with cache status messages.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nf(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Printing Current Date and Time using Python\nDESCRIPTION: This snippet prints the current date and time using datetime.datetime.now(). It demonstrates basic usage of Python's standard datetime library without parameters. Useful for timestamping outputs or marking execution times in procedural or functional scripts. Requires no inputs; outputs a string to standard output.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nprint(\"Today is {}\".format(datetime.datetime.now()))\n```\n\n----------------------------------------\n\nTITLE: Instantiating to_get with error_handler and headers\nDESCRIPTION: This creates a new instance of the `to_get` closure, called `rget`. The code passes in `BASE_URL` and `DEFAULT_HEADER` values, and also configures `error_handler=default_error_handler`, thus linking error handling to the API requests.  This sets the default error handler for the requests.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nrget = to_get(BASE_URL, headers=DEFAULT_HEADER, error_handler=default_error_handler)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Closures with a Multiplier Factory\nDESCRIPTION: Introduces the concept of closures in Python by defining a function `multipler` that returns another function (`func`). The returned function `func` 'closes over' the `x` variable from its enclosing scope, remembering its value even after the outer function has finished executing.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef multipler(x):\n    def func(y):\n        return x * y\n    return func\n\nf6 = multipler(2)\nprint(\"Func {} out={}\".format(f6, f6(3)))\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Using a nonlocal-based Counting Closure in Python 3\nDESCRIPTION: Call compute to create a counting function f that tracks calls using nonlocal, then invoke it with (1, 2). Demonstrates function and state encapsulation. Requires no arguments to instantiate; (1, 2) as call inputs; outputs: functional result and side effect on call count.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nf = compute()\nf(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Hook for running from command line in Python\nDESCRIPTION: This code snippet defines the main entry point of the Python script. When the script is executed directly, it calls the `runner` function with the command-line arguments and exits with the returned exit code. It requires the `sys` module.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nif __name__ == '__main__':\n    sys.exit(runner(sys.argv[1:]))\n```\n\n----------------------------------------\n\nTITLE: Running the Timing Decorator Example in Python\nDESCRIPTION: Calls run_example, which repeatedly invokes the adder function wrapped by the custom_timer decorator. Illustrates the use of decorators and closure-based timing in applying FPT to Python. Inputs: none; Output: result of adder function and timing printout for each call.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_21\n\nLANGUAGE: Python\nCODE:\n```\nrun_example()\n```\n\n----------------------------------------\n\nTITLE: Defining null logger setup function in Python\nDESCRIPTION: This code defines a null implementation for setting up a logger.  It takes a logging level and an optional output file as input but performs no action. It's used as a placeholder or default when actual logging setup is not required.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef null_setup_logger(level:str, output_file:Optional[str]=None) -> None:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Defining Functions with Def and Type Annotations\nDESCRIPTION: Illustrates defining functions using the standard `def` keyword. Includes examples with a docstring (`f1`) and with type annotations (`f2`), showing how to define and assert results from these standard function definitions.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef f1(n):\n    \"\"\"A simple function to square a number\"\"\"\n    return n * n\n\n# Or using type annotations in Python 3\ndef f2(n:int) -> int:\n    return n * n\n\nassert f1(3) == f2(3)\nprint(f1(3))\nprint((f1.__name__, f1.__doc__))\nprint((f1, f2))\n```\n\n----------------------------------------\n\nTITLE: Defining setup logger function in Python\nDESCRIPTION: This code defines a function that sets up a logger. It takes a logging level and an optional output file as parameters. The actual implementation is omitted, but a mock print statement indicates the intended action.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef setup_logger(level:str, output_file:Optional[str]=None):\n    # implementation omitted\n    print(\"mock setting up logger level={} file={}\".format(level, output_file))\n```\n\n----------------------------------------\n\nTITLE: Testing Iteration 2 Extended Hello Command\nDESCRIPTION: Executes the `run_example` utility with custom arguments specifically designed to test the extended 'hello' command from Iteration 2. This includes testing the new `--num-times` option with a value of 2 and requesting the help documentation for the 'hello' subparser.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nrun_example(runner, [['hello', 'My-Name','--num-times', '2'], ['hello', '--help']])\n```\n\n----------------------------------------\n\nTITLE: Adding logging options to parser in Python\nDESCRIPTION: This code defines a function that adds logging-related command-line arguments to an argparse parser. It adds options for logging level and log file output. It expects an argparse parser object as input and returns the modified parser.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef _add_opt_logging(p):\n    f = p.add_argument\n    \n    f('--level', help=\"Logging Level\", default=\"INFO\")\n    f('--log-file', help=\"Write log to specific output file\", default=None)\n    return p\n```\n\n----------------------------------------\n\nTITLE: Defining null run epilogue function in Python\nDESCRIPTION: This code defines a null implementation for running an epilogue after program execution. It takes an exit code and the start time as input but does nothing. It serves as a placeholder or default when an epilogue is not needed.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef null_run_epilogue(exit_code:int, started_at) -> None:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Testing Composed Functions with map in Python\nDESCRIPTION: Demonstrates testing a composed function by combining incrementer, doubler, and squarer, mapping the result over a sequence. Shows creation of composition pipeline and evaluation of outputs. Requires compose and the utility functions from earlier. Returns a list with mapped computations.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfx = compose(incrementer, doubler, squarer)\n\nprint(list(map(fx, (1, 2, 7))))\n```\n\n----------------------------------------\n\nTITLE: Defining a Transformer function for Todos\nDESCRIPTION: This function `to_todo` takes a `response` object as input. It parses the JSON content of the response and then calls `Todo.from_d()` to create a `Todo` object using the parsed JSON data, which is returned as a `Todo` object.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef to_todo(response):\n    return Todo.from_d(response.json())\n```\n\n----------------------------------------\n\nTITLE: Applying the Data Pipeline in Python\nDESCRIPTION: This code demonstrates how to apply the `to_pipeline` function to filter users whose first names start with 'S' and then find the user with the largest age. It calls `filter_user_by_name` to create the filter and then passes the filter and the user stream to `to_pipeline`.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nfilter_s_users = filter_user_by_name('S')    \n\n\nto_pipeline(to_users(), filter_s_users)\n```\n\n----------------------------------------\n\nTITLE: Making a GET Request and Parsing JSON\nDESCRIPTION: This line calls the `rget` function (which is a result of the closure) to fetch data from the '/todos/1' endpoint and then calls the `.json()` method to parse the JSON response. It then assigns the parsed JSON to `first_todo`.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfirst_todo = rget(\"todos/1\").json()\n```\n\n----------------------------------------\n\nTITLE: Implementing Logger Functions for HTTP Responses\nDESCRIPTION: Two logger functions for HTTP requests: a null logger that does nothing and a simple logger that prints request details including URL, status code, and response time.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\ndef null_logger(response):\n    return response\n\ndef simple_logger(response):\n    # the timestamp is a bit odd\n    now = datetime.datetime.now()\n    elapsed = response.elapsed.total_seconds()\n    print(\"{} URL:{} response:{} in {} sec\".format(now.isoformat(), response.url, response.status_code, elapsed))\n    return response\n```\n\n----------------------------------------\n\nTITLE: Creating Argparse Action with Closure\nDESCRIPTION: Demonstrates a practical application of closures in library design. The `_to_print_message_action` function returns a class definition for an `argparse.Action`, allowing the class to capture the `msg` defined in the outer function's scope.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport argparse\n\ndef _to_print_message_action(msg):\n\n    class PrintMessageAction(argparse.Action):\n\n        \"\"\"Print message and exit\"\"\"\n\n        def __call__(self, parser, namespace, values, option_string=None):\n            sys.stdout.write(msg + \"\\n\")\n            sys.exit(0)\n\n    return PrintMessageAction\n```\n\n----------------------------------------\n\nTITLE: Filtering Users by Name Prefix in Python\nDESCRIPTION: This function creates a filter function that checks if a user's first name starts with a given character (`achar`). It returns a function that, when called with a `User` object, returns `True` if the first name starts with `achar`, and `False` otherwise.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\ndef filter_user_by_name(achar):\n    def func(user):\n        return user.first_name.startswith(achar)\n    return func\n```\n\n----------------------------------------\n\nTITLE: Defining Reducer Function for Finding User with Max Age\nDESCRIPTION: Defines a custom binary function `reduce_max_age_user` suitable for `functools.reduce`. It takes an accumulator (`acc`) and a current value (`value`), both expected to be `User` objects, and returns the `User` with the greater age.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndef reduce_max_age_user(acc, value):\n    if value.age < acc.age:\n        return acc\n    return value    \n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Lambda Function\nDESCRIPTION: Demonstrates the use of a concise `lambda` function `f0` for a simple operation (squaring a number). Shows how to call the lambda, assert its result, print its output, and inspect its properties like `__name__`.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nf0 = lambda n: n * n\n\nf0(3) == 9\n\nprint(f0(3))\nprint(f0)\nprint(f0.__name__)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Number of Calls from Closure with Exposed Method in Python 3\nDESCRIPTION: Calls the get_num_times method attached to the function f2 returned by compute. Returns the number of times the function has been called, demonstrating closure state inspection. Input: none; Output: integer call count.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nf.get_num_times()\n```\n\n----------------------------------------\n\nTITLE: Printing Current Timestamp Example\nDESCRIPTION: A simple standalone print statement demonstrating the usage of the `datetime` module to get and format the current timestamp. This snippet is likely a basic example for quick verification or demonstration purposes within the notebook environment.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nprint(\"Today is {}\".format(datetime.datetime.now()))\n```\n\n----------------------------------------\n\nTITLE: Tuple Conversion Functions in Python\nDESCRIPTION: These functions facilitate the conversion between `User` objects and tuples, essential for heap operations.  `user_to_tuple` converts a `User` object to a tuple of `(age, user)`, enabling the heap to sort based on age.  `from_tuple` converts the tuple back to a `User` object.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_43\n\nLANGUAGE: python\nCODE:\n```\ndef user_to_tuple(u):\n    # for the heap\n    return u.age, u\n\ndef from_tuple(x):\n    return x[1]\n```\n\n----------------------------------------\n\nTITLE: Reducing List with Custom Adder Function\nDESCRIPTION: Uses `functools.reduce` with a custom binary function `adder` to sum all elements in the `XS` range. This illustrates the basic fold operation where an accumulator (`a`) is updated with each value (`b`) from the iterable.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef adder(a, b):\n    return a + b\n\nfunctools.reduce(adder, XS)\n```\n\n----------------------------------------\n\nTITLE: Using Python Map to Apply Functions to Sequences\nDESCRIPTION: Demonstrates the use of map to apply a function (square) over a sequence, showing the creation of generator objects and conversion to lists. Requires definition of f and XS sequence (not shown; assumes in context). Highlights standard functional pipeline patterns.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\ndef f(x): \n    return x * x\n\nrx = map(f, XS)\nrx\n```\n\nLANGUAGE: python\nCODE:\n```\nisinstance(rx, Iterable)\n```\n\nLANGUAGE: python\nCODE:\n```\nlist(map(f, range(1, 10)))\n```\n\n----------------------------------------\n\nTITLE: Defining run epilogue function in Python\nDESCRIPTION: This code defines a function that runs an epilogue after program execution. It calculates the runtime and prints a message with the exit code and runtime in seconds. It requires the `datetime` module.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef run_epilogue(exit_code:int, started_at):\n    dt = datetime.datetime.now() - started_at\n    print(\"completed exit-code={} runtime:{:.2f} sec\".format(exit_code, dt.total_seconds()))\n```\n\n----------------------------------------\n\nTITLE: Importing Core Python Modules\nDESCRIPTION: Imports essential standard library modules required for the functional programming techniques and argument parsing demonstrated in the document. This includes modules for date/time, functional tools, iterators, argument parsing, system interaction, and logging.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport datetime\nimport functools\nimport itertools\nimport argparse\nimport sys\nimport logging\n```\n\n----------------------------------------\n\nTITLE: Making a GET Request and Counting Responses\nDESCRIPTION: This code fetches all todos using `rget(\"todos\")`, parses the JSON response using `.json()` and calculates the length of the list returned.  It then prints the count of todos found.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Found {} todos\".format(len(rget(\"todos\").json())))\n```\n\n----------------------------------------\n\nTITLE: Creating a Counting Function Instance from Faulty Closure in Python\nDESCRIPTION: Instantiates a counting function using the compute closure prone to UnboundLocalError due to missing nonlocal statement. No explicit parameters; returns a function object. Highlights issues when modifying closure variables in Python 3.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nf = compute()\n```\n\n----------------------------------------\n\nTITLE: Repeat State Mutation in a Mutating Closure Function in Python\nDESCRIPTION: Calls the mutating closure function f again, this time with input 3, further mutating closure state and printing the result. Demonstrates cumulative state effect. Inputs: integer 3; Output: formatted closure state string.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_19\n\nLANGUAGE: Python\nCODE:\n```\nf(3)\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for Functional Programming\nDESCRIPTION: Imports standard library modules (`datetime`, `types`, `string`, `random`, `collections.abc`) and third-party modules (`functools`, `itertools`, `operator`, `dataclasses`) necessary for the examples demonstrating functional programming techniques and utilities.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport datetime\nimport types\nimport string\nimport random\nfrom collections.abc import Iterable, Callable\n# Requires Python >= 3.7\nfrom dataclasses import dataclass, fields\n\nimport functools\nimport itertools\nimport operator as op\n```\n\n----------------------------------------\n\nTITLE: Applying Pipeline and Retrieving List of Users\nDESCRIPTION: This code demonstrates the use of the `to_pipeline` function. It filters the users by the first name 'S', then retrieves the top 10 users, and converts the output into a list. The output will be a list of User instances.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nlist(to_pipeline(to_users(), filter_s_users, 10))\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Mutating Closure Function in Python\nDESCRIPTION: Creates an instance f of the function returned by bad_example with m=7, setting initial closure state for alpha, beta, and gamma. No output; returns a specialized function ready for further calls.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\nf = bad_example(7)\n```\n\n----------------------------------------\n\nTITLE: Printing Current Date and Time at Script End in Python\nDESCRIPTION: Repeats printing the current date and time as a terminal statement, leveraging datetime.datetime.now(). Useful as a script execution timestamp or to mark end of processing. Inputs: none; Output: prints date and time.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_22\n\nLANGUAGE: Python\nCODE:\n```\nprint(\"Today is {}\".format(datetime.datetime.now()))\n```\n\n----------------------------------------\n\nTITLE: Testing Argparse Version Flag\nDESCRIPTION: Calls the `run_example` helper function to specifically test the `--version` flag functionality provided by `argparse` in the basic CLI setup. It passes a custom list containing only the `--version` argument to the test utility.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nrun_example(runner, [('--version')])\n```\n\n----------------------------------------\n\nTITLE: Calling a Complex Mutating Closure Function in Python\nDESCRIPTION: Calls the previously instantiated mutating closure function f with input 2, causing in-place mutation of closure variables and printing the resulting formatted string. Inputs: integer 2; Output: formatted closure state string.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-4.ipynb#_snippet_18\n\nLANGUAGE: Python\nCODE:\n```\nf(2)\n```\n\n----------------------------------------\n\nTITLE: Filtering List Using Simple Predicate Function\nDESCRIPTION: Demonstrates a basic filtering operation using a list comprehension with a simple predicate function `lte_3` that checks if a number is less than or equal to 3. This is shown as a precursor to generalizing the filtering logic using closures.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef lte_3(n):\n    return n <= 3\n\n[x for x in XS if lte_3(x)]\n```\n\n----------------------------------------\n\nTITLE: Calling runner function example in Python\nDESCRIPTION: This code snippet demonstrates how to call the runner function, likely passing in some arguments or a specific configuration. It's used to execute the core logic of the application.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nrun_example(runner)\n```\n\n----------------------------------------\n\nTITLE: Reducing List of Users to Find Max Age User\nDESCRIPTION: Applies the custom `reduce_max_age_user` function with `functools.reduce` to the iterable of `User` objects generated by `to_users`. The result is the single `User` object from the generated list with the highest age.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfunctools.reduce(reduce_max_age_user, to_users())\n```\n\n----------------------------------------\n\nTITLE: Reducing List Using Operator.add\nDESCRIPTION: Demonstrates using `functools.reduce` with `operator.add` from the `operator` module. This is a common pattern for summing iterables using a built-in function optimized for arithmetic operations.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Or using `operator` from the standard lib https://docs.python.org/3/library/operator.html\nfunctools.reduce(op.add, XS)\n```\n\n----------------------------------------\n\nTITLE: Organizing Helper Classes for Module Exports\nDESCRIPTION: A pattern for organizing utility functions into classes to provide a cleaner public API and make the code more navigable for users.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nclass Loggers(object):\n    DEFAULT = simple_logger\n    NULL = null_logger\n    \nclass ErrorHandlers(object):\n    DEFAULT = default_error_handler\n    NULL = null_tranform\n```\n\n----------------------------------------\n\nTITLE: Defining Default Headers\nDESCRIPTION: This sets a default header dictionary named `DEFAULT_HEADER`.  This dictionary is used to send headers with every subsequent API request.  The key-value pair `\"x-my-header\": \"12345\"` is added.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nDEFAULT_HEADER = {\"x-my-header\": \"12345\"}\n```\n\n----------------------------------------\n\nTITLE: Printing the Retrieved JSON\nDESCRIPTION: This line prints the `first_todo` object, which should be the parsed JSON response from the previous step.  This displays the data obtained from the API call.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfirst_todo\n```\n\n----------------------------------------\n\nTITLE: Printing the Current Date and Time\nDESCRIPTION: This snippet simply prints the current date and time to the console using the `datetime.datetime.now()` function. It's a basic demonstration of using the `datetime` module.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-2.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Today is {}\".format(datetime.datetime.now()))\n```\n\n----------------------------------------\n\nTITLE: Printing current date and time in Python\nDESCRIPTION: This code uses the `datetime` module to get the current date and time and prints it to the console using string formatting. It requires the `datetime` module to be imported.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-3.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Today is {}\".format(datetime.datetime.now()))\n```\n\n----------------------------------------\n\nTITLE: Checking Name of Partially Applied Function\nDESCRIPTION: Prints the `__name__` attribute of the function created by `functools.partial` (`filter_lte_3`), highlighting that it does not automatically inherit the original function's name.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nprint(filter_lte_3.__name__)\n```\n\n----------------------------------------\n\nTITLE: Comparing Improved Composed Functions in Python\nDESCRIPTION: Calls getting_better and to_better, returning their output for direct comparison. Shows results of improved procedures. Ensures both return equivalent lists.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ngetting_better(), to_better()\n```\n\n----------------------------------------\n\nTITLE: Reducing List Using Operator.mul\nDESCRIPTION: Uses `functools.reduce` with `operator.mul` to calculate the product of elements in the range from 1 to 9 (inclusive). This demonstrates reducing with a multiplication operation.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfunctools.reduce(op.mul, range(1, 10))\n```\n\n----------------------------------------\n\nTITLE: Printing Current Date and Time\nDESCRIPTION: This code snippet prints the current date and time to the console using the `datetime` module. It formats the output as a string.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Today is {}\".format(datetime.datetime.now()))\n```\n\n----------------------------------------\n\nTITLE: Printing Current Timestamp\nDESCRIPTION: Prints the current date and time to the console using the `datetime` module, serving as a simple introductory statement.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Today is {}\".format(datetime.datetime.now()))\n```\n\n----------------------------------------\n\nTITLE: Checking Name of Original Function\nDESCRIPTION: Prints the `__name__` attribute of the original `filter_min_value` function to show its default name before being partially applied.\nSOURCE: https://github.com/mpkocher/functional-programming-techniques-in-python/blob/main/Functional-Python-Part-1.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nprint(filter_min_value.__name__)\n```"
  }
]