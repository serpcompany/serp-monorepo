[
  {
    "owner": "colinhacks",
    "repo": "zod",
    "content": "TITLE: Error Handling with Zod\nDESCRIPTION: This code shows how to handle errors using `z.safeParse`. If the validation fails, the `data.error.issues` array contains detailed information about the validation errors. This particular example shows how to catch a type mismatch error.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = z\n  .object({\n    name: z.string(),\n  })\n  .safeParse({ name: 12 });\n\nif (!data.success) {\n  data.error.issues;\n  /* [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"string\",\n        \"received\": \"number\",\n        \"path\": [ \"name\" ],\n        \"message\": \"Expected string, received number\"\n      }\n  ] */\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Form Errors with React in TypeScript\nDESCRIPTION: This snippet showcases how to use the formatted errors generated by Zod to render error messages within a React component. It defines an Errors component that displays a list of error messages, and a MyForm component that utilizes the useForm hook, parses form data with the FormData schema, and renders the Errors component for the 'name' field.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst FormData = z.object({ ... });\n\nfunction Errors(props: {errors?: string[]}){\n  if(!props.errors?.length) return null;\n  return <div>{props.errors.map(err => <p>{err}</p>)}</div>\n}\n\nfunction MyForm(){\n  const {register, data} = useForm({ ... });\n\n  const result = FormData.safeParse(data);\n  const errors = result.success ? {} : result.error.format();\n\n  return <div>\n    <label>Name<label>\n    <input {...register('name')}>\n    <Errors errors={errors?.name?._errors} />\n  </div>\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Data and Handling Zod Errors in TypeScript\nDESCRIPTION: This snippet demonstrates how to parse data using a Zod schema and handle potential errors using a try-catch block.  It parses an object against the 'person' schema, intentionally providing invalid data, and then logs the 'issues' property of the ZodError if parsing fails. This enables inspection of specific validation errors.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntry {\n  person.parse({\n    names: [\"Dave\", 12], // 12 is not a string\n    address: {\n      line1: \"123 Maple Ave\",\n      zipCode: 123, // zip code isn't 5 digits\n      extra: \"other stuff\", // unrecognized key\n    },\n  });\n} catch (err) {\n  if (err instanceof z.ZodError) {\n    console.log(err.issues);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `.catch` with a function for dynamic defaults\nDESCRIPTION: Shows how to use a function with `.catch()` to generate a dynamic default value based on the error context.  In this example, it returns a random number on parsing failure. The context `ctx` contains the ZodError.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_106\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberWithRandomCatch = z.number().catch((ctx) => {\n  ctx.error; // the caught ZodError\n  return Math.random();\n});\n\nnumberWithRandomCatch.parse(\"sup\"); // => 0.4413456736055323\nnumberWithRandomCatch.parse(\"sup\"); // => 0.1871840107401901\nnumberWithRandomCatch.parse(\"sup\"); // => 0.7223408162401552\n```\n\n----------------------------------------\n\nTITLE: JSON Type Validation with Zod in TypeScript\nDESCRIPTION: This snippet demonstrates how to validate any JSON value using Zod. It defines a literal schema that accepts strings, numbers, booleans, or null. Then, it defines a recursive Json type and jsonSchema that allows for nested objects and arrays of Json values. The z.lazy function is crucial for defining the recursive schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_81\n\nLANGUAGE: typescript\nCODE:\n```\nconst literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);\ntype Literal = z.infer<typeof literalSchema>;\ntype Json = Literal | { [key: string]: Json } | Json[];\nconst jsonSchema: z.ZodType<Json> = z.lazy(() =>\n  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])\n);\n\njsonSchema.parse(data);\n```\n\n----------------------------------------\n\nTITLE: Defining Function Schemas with Zod\nDESCRIPTION: These code snippets demonstrate how to define function schemas in Zod using `z.function()`. The examples show how to define the input arguments and return types of a function, and how to extract the parameter and return types from the schema. Also provides examples to implement functions with type validation using `.implement()`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFunction = z.function();\n\ntype myFunction = z.infer<typeof myFunction>;\n// => ()=>unknown\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFunction = z\n  .function()\n  .args(z.string(), z.number()) // 接受任意数量的参数\n  .returns(z.boolean());\ntype myFunction = z.infer<typeof myFunction>;\n// => (arg0: string, arg1: number)=>boolean\n```\n\nLANGUAGE: typescript\nCODE:\n```\nmyFunction.parameters();\n// => ZodTuple<[ZodString, ZodNumber]>\n\nmyFunction.returnType();\n// => ZodBoolean\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst trimmedLength = z\n  .function()\n  .args(z.string()) // accepts an arbitrary number of arguments\n  .returns(z.number())\n  .implement((x) => {\n    // TypeScript knows x is a string!\n    return x.trim().length;\n  });\n\ntrimmedLength(\"sandwich\"); // => 8\ntrimmedLength(\" asdf \"); // => 4\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFunction = z\n  .function()\n  .args(z.string())\n  .implement((arg) => {\n    return [arg.length]; //\n  });\nmyFunction; // (arg: string)=>number[]\n```\n\n----------------------------------------\n\nTITLE: Zod Object Definition\nDESCRIPTION: This code demonstrates how to define an object with required and optional properties using Zod. It utilizes `z.object` for defining the object schema, and `z.number().optional()` for specifying an optional number field.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_80\n\nLANGUAGE: typescript\nCODE:\n```\nconst C = z.object({\n  foo: z.string(),\n  bar: z.number().optional(),\n});\n\ntype C = z.infer<typeof C>;\n// returns { foo: string; bar?: number | undefined }\n```\n\n----------------------------------------\n\nTITLE: Basic Zod Object Schema\nDESCRIPTION: This snippet demonstrates how to define a basic object schema with Zod, including property types and how to infer the TypeScript type from the schema. By default, all properties defined in a Zod object schema are required.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\n// 기본적으로 모든 속성은 필수입니다.\nconst Dog = z.object({\n  name: z.string(),\n  age: z.number(),\n});\n\n// 추론된 타입을 이렇게 추출할 수 있습니다.\ntype Dog = z.infer<typeof Dog>;\n\n// 이는 다음과 동일합니다:\ntype Dog = {\n  name: string;\n  age: number;\n};\n```\n\n----------------------------------------\n\nTITLE: Extending Zod Object Schema\nDESCRIPTION: Illustrates extending an existing Zod object schema with additional fields using the `.extend` method. The new schema includes the properties from the original schema and the new properties.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nconst DogWithBreed = Dog.extend({\n  breed: z.string(),\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Zod Errors with ZodErrorMap in TypeScript\nDESCRIPTION: This snippet shows how to customize error messages using a custom ZodErrorMap. The customErrorMap function checks the error code and expected type and returns custom messages for invalid string types and custom errors. It then sets the global error map using `z.setErrorMap`, affecting all subsequent schema validations.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\";\n\nconst customErrorMap: z.ZodErrorMap = (issue, ctx) => {\n  if (issue.code === z.ZodIssueCode.invalid_type) {\n    if (issue.expected === \"string\") {\n      return { message: \"bad type!\" };\n    }\n  }\n  if (issue.code === z.ZodIssueCode.custom) {\n    return { message: `less-than-${(issue.params || {}).minimum}` };\n  }\n  return { message: ctx.defaultError };\n};\n\nz.setErrorMap(customErrorMap);\n```\n\n----------------------------------------\n\nTITLE: String Validations and Transforms in Zod\nDESCRIPTION: This code snippet demonstrates various string validation and transformation methods available in Zod, such as `max`, `min`, `email`, `url`, `trim`, `toLowerCase`, and more. It shows how to chain these methods to create complex string validation schemas.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// validations\nz.string().max(5);\nz.string().min(5);\nz.string().length(5);\nz.string().email();\nz.string().url();\nz.string().emoji();\nz.string().uuid();\nz.string().nanoid();\nz.string().cuid();\nz.string().cuid2();\nz.string().ulid();\nz.string().regex(regex);\nz.string().includes(string);\nz.string().startsWith(string);\nz.string().endsWith(string);\nz.string().datetime(); // ISO 8601; by default only `Z` timezone allowed\nz.string().ip(); // defaults to allow both IPv4 and IPv6\nz.string().cidr(); // defaults to allow both IPv4 and IPv6\n\n// transforms\nz.string().trim(); // trim whitespace\nz.string().toLowerCase(); // toLowerCase\nz.string().toUpperCase(); // toUpperCase\n\n// added in Zod 3.23\nz.string().date(); // ISO date format (YYYY-MM-DD)\nz.string().time(); // ISO time format (HH:mm:ss[.SSSSSS])\nz.string().duration(); // ISO 8601 duration\nz.string().base64();\n```\n\n----------------------------------------\n\nTITLE: Parsing with Zod in TypeScript\nDESCRIPTION: This snippet shows the different ways to parse data using Zod schemas: `.parse`, `.parseAsync`, `.safeParse`, and `.safeParseAsync`. It demonstrates how `.parse` throws an error on invalid data, while `.safeParse` returns an object indicating success or failure.  Async versions are for schemas with async refinements/transforms.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_87\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string();\n\nstringSchema.parse(\"fish\"); // => returns \"fish\"\nstringSchema.parse(12); // throws error\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string().refine(async (val) => val.length <= 8);\n\nawait stringSchema.parseAsync(\"hello\"); // => returns \"hello\"\nawait stringSchema.parseAsync(\"hello world\"); // => throws error\n```\n\nLANGUAGE: typescript\nCODE:\n```\nstringSchema.safeParse(12);\n// => { success: false; error: ZodError }\n\nstringSchema.safeParse(\"billie\");\n// => { success: true; data: 'billie' }\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = stringSchema.safeParse(\"billie\");\nif (!result.success) {\n  // handle error then return\n  result.error;\n} else {\n  // do something\n  result.data;\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait stringSchema.safeParseAsync(\"billie\");\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait stringSchema.spa(\"billie\");\n```\n\n----------------------------------------\n\nTITLE: Preprocess with Zod in TypeScript\nDESCRIPTION: This snippet demonstrates how to use `z.preprocess` to transform the input before parsing it with Zod. It shows a common use case of coercing a value to a string before validating it as a string. This is useful for handling cases where the input might not be in the expected format initially.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_85\n\nLANGUAGE: typescript\nCODE:\n```\nconst castToString = z.preprocess((val) => String(val), z.string());\n```\n\n----------------------------------------\n\nTITLE: Inferring the type of a schema\nDESCRIPTION: Shows how to extract the TypeScript type of a Zod schema using `z.infer<typeof mySchema>`. Explains the difference between input and output types when transforms are involved.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_117\n\nLANGUAGE: typescript\nCODE:\n```\nconst A = z.string();\ntype A = z.infer<typeof A>; // string\n\nconst u: A = 12; // TypeError\nconst u: A = \"asdf\"; // compiles\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringToNumber = z.string().transform((val) => val.length);\n\n// ⚠️ Important: z.infer returns the OUTPUT type!\ntype input = z.input<typeof stringToNumber>; // string\ntype output = z.output<typeof stringToNumber>; // number\n\n// equivalent to z.output!\ntype inferred = z.infer<typeof stringToNumber>; // number\n```\n\n----------------------------------------\n\nTITLE: Function Schema Definition with Zod in TypeScript\nDESCRIPTION: Demonstrates how to define and implement function schemas using Zod. It shows how to specify the arguments and return type of a function, and how to use the `.implement()` method to automatically validate the input and output. The code snippet illustrates how to create type-safe function interfaces with Zod, ensuring that the function adheres to a defined schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_82\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFunction = z.function();\n\ntype myFunction = z.infer<typeof myFunction>;\n// => ()=>unknown\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFunction = z\n  .function()\n  .args(z.string(), z.number()) // 임의의 수의 인자를 받음\n  .returns(z.boolean());\n\ntype myFunction = z.infer<typeof myFunction>;\n// => (arg0: string, arg1: number)=>boolean\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst trimmedLength = z\n  .function()\n  .args(z.string()) // 임의의 수의 인자를 받음\n  .returns(z.number())\n  .implement((x) => {\n    // TypeScript는 x가 문자열임을 알고 있습니다!\n    return x.trim().length;\n  });\n\ntrimmedLength(\"sandwich\"); // => 8\ntrimmedLength(\" asdf \"); // => 4\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFunction = z\n  .function()\n  .args(z.string())\n  .implement((arg) => {\n    return [arg.length];\n  });\n\nmyFunction; // (arg: string)=>number[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nmyFunction.parameters();\n// => ZodTuple\n\nmyFunction.returnType();\n// => ZodBoolean\n```\n\n----------------------------------------\n\nTITLE: CIDR Validation in Zod\nDESCRIPTION: This code snippet demonstrates how to validate IP address ranges specified with CIDR notation using the `z.string().cidr()` method in Zod. By default, it allows both IPv4 and IPv6 CIDR notations.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst cidr = z.string().cidr();\ncidr.parse(\"192.168.0.0/24\"); // pass\ncidr.parse(\"2001:db8::/32\"); // pass\n```\n\n----------------------------------------\n\nTITLE: CIDR Validation (TypeScript)\nDESCRIPTION: Shows how to validate IP address ranges in CIDR notation using `z.string().cidr()`, which defaults to accepting both IPv4 and IPv6 CIDR.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst cidr = z.string().cidr();\ncidr.parse(\"192.168.0.0/24\"); // 통과\ncidr.parse(\"2001:db8::/32\"); // 통과\n```\n\n----------------------------------------\n\nTITLE: Customizing Number Schema Error Messages in Zod\nDESCRIPTION: This code snippet shows how to customize error messages when creating a number schema in Zod. It demonstrates how to specify `required_error` and `invalid_type_error` options.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst age = z.number({\n  required_error: \"Age is required\",\n  invalid_type_error: \"Age must be a number\",\n});\n```\n\n----------------------------------------\n\nTITLE: SafeParse Method Usage with Zod in TypeScript\nDESCRIPTION: Demonstrates the usage of the `.safeParse` method to validate data against a Zod schema without throwing errors. It shows how `.safeParse` returns an object with either the validated data or a ZodError instance, allowing for graceful error handling. This snippet showcases how to use Zod for validation where error handling is explicit and non-throwing.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_87\n\nLANGUAGE: typescript\nCODE:\n```\nstringSchema.safeParse(12);\n// => { success: false; error: ZodError }\n\nstringSchema.safeParse(\"billie\");\n// => { success: true; data: 'billie' }\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = stringSchema.safeParse(\"billie\");\nif (!result.success) {\n  // 에러 처리 후 반환\n  result.error;\n} else {\n  // 작업 수행\n  result.data;\n}\n```\n\n----------------------------------------\n\nTITLE: Inferring Flattened Errors with Zod\nDESCRIPTION: Infers the type of flattened errors using `z.inferFlattenedErrors`. This utility takes a Zod schema as a generic type argument and returns the type definition for flattened error object, organizing errors into `formErrors` and `fieldErrors`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ntype FlattenedErrors = z.inferFlattenedErrors<typeof FormData>;\n/*\n  {  \n    formErrors: string[],\n    fieldErrors: {\n      email?: string[],\n      password?: string[],\n      confirm?: string[]\n    } \n  }\n*/\n```\n\n----------------------------------------\n\nTITLE: Defining Record Schema in Zod\nDESCRIPTION: Demonstrates how to use `z.record` to define a schema for a record (object with string keys).  The example defines a record with string keys and values that are objects with a 'name' property of type string. It then shows example of valid and invalid assignments based on this schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\nconst User = z.object({ name: z.string() });\n\nconst UserStore = z.record(z.string(), User);\ntype UserStore = z.infer<typeof UserStore>;\n// => Record<string, { name: string }>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst userStore: UserStore = {};\n\nuserStore[\"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\"] = {\n  name: \"Carlotta\",\n}; // passes\n\nuserStore[\"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\"] = {\n  whatever: \"Ice cream sundae\",\n}; // TypeError\n```\n\n----------------------------------------\n\nTITLE: Creating an Object Schema in Zod\nDESCRIPTION: Shows how to define an object schema using Zod with a string property.  Demonstrates parsing an object and inferring the TypeScript type from the Zod schema using `z.infer`. The inferred type ensures type safety when working with validated data.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { z } from \"zod\";\n\nconst User = z.object({\n  username: z.string(),\n});\n\nUser.parse({ username: \"Ludwig\" });\n\n// extract the inferred type\ntype User = z.infer<typeof User>;\n// { username: string }\n```\n\n----------------------------------------\n\nTITLE: Merging Zod Object Schemas\nDESCRIPTION: Demonstrates merging two Zod object schemas using the `.merge` method. If the schemas share keys, the properties from the second schema override those of the first.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nconst BaseTeacher = z.object({ students: z.array(z.string()) });\nconst HasID = z.object({ id: z.string() });\n\nconst Teacher = BaseTeacher.merge(HasID);\ntype Teacher = z.infer<typeof Teacher>; // => { students: string[], id: string }\n```\n\n----------------------------------------\n\nTITLE: Refine Method Usage with Zod in TypeScript\nDESCRIPTION: Demonstrates the usage of the `.refine` method to add custom validation logic to a Zod schema. It shows how to define a refinement that checks the length of a string and provides a custom error message. The code illustrates how to extend Zod's validation capabilities with custom rules and error messages.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_89\n\nLANGUAGE: typescript\nCODE:\n```\nconst myString = z.string().refine((val) => val.length <= 255, {\n  message: \"문자열은 255자를 초과할 수 없습니다.\",\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst longString = z.string().refine(\n  (val) => val.length > 10,\n  (val) => ({ message: `${val}은 10자를 초과하지 않습니다.` })\n);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst passwordForm = z\n  .object({\n    password: z.string(),\n    confirm: z.string(),\n  })\n  .refine((data) => data.password === data.confirm, {\n    message: \"비밀번호가 일치하지 않습니다\",\n    path: [\"confirm\"], // 에러 경로\n  });\n\npasswordForm.parse({ password: \"asdf\", confirm: \"qwer\" });\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst userId = z.string().refine(async (id) => {\n  // 데이터베이스에서 ID가 존재하는지 확인\n  return true;\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nz.string()\n  .transform((val) => val.length) // 문자열을 길이로 변환\n  .refine((val) => val > 25); // 길이가 25보다 큰지 검증\n```\n\n----------------------------------------\n\nTITLE: Make Object Properties Deeply Optional with Zod\nDESCRIPTION: This snippet demonstrates how to make all properties of an object schema, including nested objects, optional using the `.deepPartial` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z.object({\n  username: z.string(),\n  location: z.object({\n    latitude: z.number(),\n    longitude: z.number(),\n  }),\n});\n\nconst deepPartialUser = user.deepPartial();\n\n/*\n{\n  username?: string | undefined,\n  location?: {\n    latitude?: number | undefined;\n    longitude?: number | undefined;\n  } | undefined\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Datetime Validation with Precision in Zod\nDESCRIPTION: This code snippet demonstrates how to constrain the allowable precision for sub-second decimals in datetime validation using Zod's `z.string().datetime()` method. It sets the `precision` option to a specific number and shows how to parse valid and invalid datetime strings based on the specified precision.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst datetime = z.string().datetime({ precision: 3 });\n\ndatetime.parse(\"2020-01-01T00:00:00.123Z\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // fail\ndatetime.parse(\"2020-01-01T00:00:00.123456Z\"); // fail\n```\n\n----------------------------------------\n\nTITLE: Datetime Validation with Timezone Offset (TypeScript)\nDESCRIPTION: Demonstrates using `z.string().datetime({ offset: true })` to validate ISO 8601 datetime strings with timezone offsets.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst datetime = z.string().datetime({ offset: true });\n\ndatetime.parse(\"2020-01-01T00:00:00+02:00\"); // 통과\ndatetime.parse(\"2020-01-01T00:00:00.123+02:00\"); // 통과 (밀리초 선택적)\ndatetime.parse(\"2020-01-01T00:00:00.123+0200\"); // 통과 (밀리초 선택적)\ndatetime.parse(\"2020-01-01T00:00:00.123+02\"); // 통과 (시간 오프셋만)\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // 통과 (Z 지원)\n```\n\n----------------------------------------\n\nTITLE: Validating during Transform\nDESCRIPTION: Shows how to validate and transform within a single `.transform` method by using the `ctx` object to add issues. It transforms a string to a number, adding an issue if parsing fails.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_99\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberInString = z.string().transform((val, ctx) => {\n  const parsed = parseInt(val);\n  if (isNaN(parsed)) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: \"Not a number\",\n    });\n\n    // This is a special symbol you can use to\n    // return early from the transform function.\n    // It has type `never` so it does not affect the\n    // inferred return type.\n    return z.NEVER;\n  }\n  return parsed;\n});\n```\n\n----------------------------------------\n\nTITLE: Zod Coercion for Primitives\nDESCRIPTION: Illustrates how to use Zod's coercion feature to automatically convert input values to specific primitive types. The example covers coercion to `string`, demonstrating how different JavaScript types are converted to strings during parsing. It includes examples with numbers, booleans, `undefined`, and `null` values and shows usage of method chaining.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst schema = z.coerce.string();\nschema.parse(\"tuna\"); // => \"tuna\"\nschema.parse(12); // => \"12\"\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nschema.parse(12); // => \"12\"\nschema.parse(true); // => \"true\"\nschema.parse(undefined); // => \"undefined\"\nschema.parse(null); // => \"null\"\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nz.coerce.string().email().min(5);\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst schema = z.coerce.boolean(); // Boolean(input)\n\nschema.parse(\"tuna\"); // => true\nschema.parse(\"true\"); // => true\nschema.parse(\"false\"); // => true\nschema.parse(1); // => true\nschema.parse([]); // => true\n\nschema.parse(0); // => false\nschema.parse(\"\"); // => false\nschema.parse(undefined); // => false\nschema.parse(null); // => false\n```\n\n----------------------------------------\n\nTITLE: Preprocessing with Zod in TypeScript\nDESCRIPTION: Demonstrates how to use `z.preprocess` to transform input values before parsing.  It shows how to convert a value to a string before validating it against a string schema. This snippet illustrates how to perform type coercion or data cleaning as a preprocessing step before applying validation rules.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_83\n\nLANGUAGE: typescript\nCODE:\n```\nconst castToString = z.preprocess((val) => String(val), z.string());\n```\n\n----------------------------------------\n\nTITLE: Zod Record Schema (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a record schema using Zod's `z.record()` function. This schema validates objects that map string keys to values of a specific type, such as a `User` object. It also showcases how to infer the TypeScript type from the Zod schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\nconst User = z.object({ name: z.string() });\n\nconst UserStore = z.record(z.string(), User);\ntype UserStore = z.infer<typeof UserStore>;\n// => Record\n\nconst userStore: UserStore = {};\n\nuserStore[\"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\"] = {\n  name: \"Carlotta\",\n}; // 통과\n\nuserStore[\"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\"] = {\n  whatever: \"Ice cream sundae\",\n}; // TypeError 발생\n```\n\n----------------------------------------\n\nTITLE: Zod Object Definition\nDESCRIPTION: Defines a Zod object schema with required properties. The inferred type is extracted using `z.infer`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\n// all properties are required by default\nconst Dog = z.object({\n  name: z.string(),\n  age: z.number(),\n});\n\n// extract the inferred type like this\ntype Dog = z.infer<typeof Dog>;\n\n// equivalent to:\ntype Dog = {\n  name: string;\n  age: number;\n};\n```\n\n----------------------------------------\n\nTITLE: Chaining Transforms and Refines in Zod TypeScript\nDESCRIPTION: This code demonstrates chaining `transform` and `refine` methods in Zod to perform a series of data transformations and validations. It converts a string to uppercase, checks its length, adds a greeting, and verifies that it doesn't contain an exclamation mark.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_96\n\nLANGUAGE: typescript\nCODE:\n```\nconst nameToGreeting = z\n  .string()\n  .transform((val) => val.toUpperCase()) // 값을 대문자로 변환\n  .refine((val) => val.length > 15) // 길이가 15를 초과하는지 검증\n  .transform((val) => `Hello ${val}`) // 값 앞에 \"Hello\"를 추가\n  .refine((val) => val.indexOf(\"!\") === -1); // 값에 \"!\"가 포함되지 않았는지 검증\n```\n\n----------------------------------------\n\nTITLE: Enum Schema Definition in Zod\nDESCRIPTION: This code demonstrates how to define enum schemas in Zod using `z.enum`. It shows the recommended way to create an enum with a direct array of values. It also explains how to use `as const` to ensure proper type inference when using an existing array.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nconst FishEnum = z.enum([\"Salmon\", \"Tuna\", \"Trout\"]);\ntype FishEnum = z.infer<typeof FishEnum>;\n// 'Salmon' | 'Tuna' | 'Trout'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst VALUES = [\"Salmon\", \"Tuna\", \"Trout\"] as const;\nconst FishEnum = z.enum(VALUES);\n```\n\n----------------------------------------\n\nTITLE: Validate ISO Datetime Strings (Zod)\nDESCRIPTION: This snippet validates ISO 8601 datetime strings using Zod's `datetime()` method. By default, it requires no timezone offset and allows arbitrary sub-second precision.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst datetime = z.string().datetime();\n\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00.123Z\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00.123456Z\"); // pass (任意精度)\ndatetime.parse(\"2020-01-01T00:00:00+02:00\"); // fail (不允许偏移)\n```\n\n----------------------------------------\n\nTITLE: Async Transformation with Zod\nDESCRIPTION: This code snippet demonstrates how to define an asynchronous transformation in Zod. The transform function converts a UUID string to a user object by calling `getUserById`.  It uses `z.string().uuid().transform` to apply the transformation. The `parseAsync` method must be used to parse the data when the schema contains asynchronous transformers.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_66\n\nLANGUAGE: typescript\nCODE:\n```\nconst IdToUser = z\n  .string()\n  .uuid()\n  .transform(async (id) => {\n    return await getUserById(id);\n  });\n```\n\n----------------------------------------\n\nTITLE: Optional Array Schema in Zod\nDESCRIPTION: Shows how the order of method calls, specifically `.optional()` and `.array()`, affects the resulting type.  `z.string().optional().array()` creates an array of optional strings, while `z.string().array().optional()` makes the entire array optional.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nz.string().optional().array(); // (string | undefined)[]\nz.string().array().optional(); // string[] | undefined\n```\n\n----------------------------------------\n\nTITLE: String Validation Methods (TypeScript)\nDESCRIPTION: This snippet showcases various string validation methods provided by Zod, such as `max`, `min`, `email`, `url`, `uuid`, `regex`, `includes`, `startsWith`, and `endsWith`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// 유효성 검사\nz.string().max(5); // 최대 5자\nz.string().min(5); // 최소 5자\nz.string().length(5); // 정확히 5자\nz.string().email(); // 이메일 형식\nz.string().url(); // URL 형식\nz.string().emoji(); // 이모지 포함\nz.string().uuid(); // UUID 형식\nz.string().nanoid(); // Nano ID 형식\nz.string().cuid(); // CUID 형식\nz.string().cuid2(); // CUID2 형식\nz.string().ulid(); // ULID 형식\nz.string().regex(regex); // 정규식 검사\nz.string().includes(string); // 특정 문자열 포함\nz.string().startsWith(string); // 특정 문자열로 시작\nz.string().endsWith(string); // 특정 문자열로 끝남\nz.string().datetime(); // ISO 8601 형식 (기본적으로 'Z' 시간대만 허용)\nz.string().ip(); // IPv4 및 IPv6 허용 (기본값)\nz.string().cidr(); // IPv4 및 IPv6 CIDR 허용 (기본값)\n\n// 변환\nz.string().trim(); // 공백 제거\nz.string().toLowerCase(); // 소문자로 변환\nz.string().toUpperCase(); // 대문자로 변환\n\n// Zod 3.23에서 추가됨\nz.string().date(); // ISO 날짜 형식 (YYYY-MM-DD)\nz.string().time(); // ISO 시간 형식 (HH:mm:ss[.SSSSSS])\nz.string().duration(); // ISO 8601 기간 형식\nz.string().base64(); // Base64 형식\n```\n\n----------------------------------------\n\nTITLE: Practical Example of Customized Error Map in TypeScript\nDESCRIPTION: This snippet provides a practical example of a customized error map.  It defines a customErrorMap function that overrides error messages for invalid string types and custom errors using a switch statement. It includes a fallback to the default error message using `ctx.defaultError`. Finally, it calls `z.string().parse(12, { errorMap: customErrorMap })` to demonstrate how the map affects error messages during parsing.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as z from \"zod\";\n\nconst customErrorMap: z.ZodErrorMap = (error, ctx) => {\n  /*\n  This is where you override the various error codes\n  */\n  switch (error.code) {\n    case z.ZodIssueCode.invalid_type:\n      if (error.expected === \"string\") {\n        return { message: `This ain't a string!` };\n      }\n      break;\n    case z.ZodIssueCode.custom:\n      // produce a custom message using error.params\n      // error.params won't be set unless you passed\n      // a `params` arguments into a custom validator\n      const params = error.params || {};\n      if (params.myField) {\n        return { message: `Bad input: ${params.myField}` };\n      }\n      break;\n  }\n\n  // fall back to default message!\n  return { message: ctx.defaultError };\n};\n\nz.string().parse(12, { errorMap: customErrorMap });\n```\n\n----------------------------------------\n\nTITLE: Post-processing Zod Issues with Flatten in TypeScript\nDESCRIPTION: This snippet shows how to use the mapping function with `.flatten()` to post-process Zod issues. It provides a lambda function that transforms each ZodIssue into an object containing a `message` and an `errorCode`.  This allows the user to customize the structure and content of the final error object returned by `.flatten()`, making it more convenient to integrate with form validation systems.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nresult.error.flatten((issue: ZodIssue) => ({\n  message: issue.message,\n  errorCode: issue.code,\n}));\n```\n\n----------------------------------------\n\nTITLE: Coerce Primitive Types with Chaining (Zod)\nDESCRIPTION: This snippet demonstrates chaining methods after coercion using `z.coerce`. It coerces the input to a string then applies email and minimum length validations.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nz.coerce.string().email().min(5);\n```\n\n----------------------------------------\n\nTITLE: Defining Object with Optional Properties in Zod\nDESCRIPTION: This code snippet shows how to define an object with optional properties in Zod.  It uses the `z.object` method to define the object schema, and the `z.number().optional()` method to mark the 'bar' property as optional.  This approach is more declarative and concise compared to io-ts, making schema definitions easier to read and write. The `z.infer` utility is used to extract the TypeScript type from the Zod schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_122\n\nLANGUAGE: typescript\nCODE:\n```\nconst C = z.object({\n  foo: z.string(),\n  bar: z.number().optional(),\n});\n\ntype C = z.infer<typeof C>;\n// returns { foo: string; bar?: number | undefined }\n```\n\n----------------------------------------\n\nTITLE: Safely Parsing Data with Zod\nDESCRIPTION: This code demonstrates the `.safeParse` method, which attempts to parse data without throwing an error. Instead, it returns an object indicating either success with the parsed data or failure with a ZodError instance. The resulting discriminated union allows for easy error handling.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nstringSchema.safeParse(12);\n// => { success: false; error: ZodError }\n\nstringSchema.safeParse(\"billie\");\n// => { success: true; data: 'billie' }\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = stringSchema.safeParse(\"billie\");\nif (!result.success) {\n  // handle error then return\n  result.error;\n} else {\n  // do something\n  result.data;\n}\n```\n\n----------------------------------------\n\nTITLE: Zod Recursive Type Definition (TypeScript)\nDESCRIPTION: This snippet demonstrates how to define a recursive schema in Zod, which allows for self-referencing types. It shows how to use `z.lazy` to define the recursive part of the schema, and how to provide a manual type definition for the recursive type due to TypeScript limitations.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nconst baseCategorySchema = z.object({\n  name: z.string(),\n});\n\ntype Category = z.infer<typeof baseCategorySchema> & {\n  subcategories: Category[];\n};\n\nconst categorySchema: z.ZodType = baseCategorySchema.extend({\n  subcategories: z.lazy(() => categorySchema.array()),\n});\n\ncategorySchema.parse({\n  name: \"People\",\n  subcategories: [\n    {\n      name: \"Politicians\",\n      subcategories: [\n        {\n          name: \"Presidents\",\n          subcategories: [],\n        },\n      ],\n    },\n  ],\n}); // 통과\n```\n\n----------------------------------------\n\nTITLE: Email to Domain Transformation\nDESCRIPTION: Shows the correct order of chaining: applying validation (.email()) before transformation. It transforms an email string into its domain.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_98\n\nLANGUAGE: typescript\nCODE:\n```\nconst emailToDomain = z\n  .string()\n  .email()\n  .transform((val) => val.split(\"@\")[1]);\n\nemailToDomain.parse(\"colinhacks@example.com\"); // => example.com\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive Type in Zod\nDESCRIPTION: This code defines a recursive schema for a Category object with nested subcategories. It uses `z.lazy` to handle the recursive definition and `z.object` to define the structure with a string name and an array of subcategories, leveraging the interface to provide type hints to Zod.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Category {\n  name: string;\n  subcategories: Category[];\n}\n\n// cast to z.ZodSchema<Category>\nconst Category: z.ZodSchema<Category> = z.lazy(() =>\n  z.object({\n    name: z.string(),\n    subcategories: z.array(Category),\n  })\n);\n\nCategory.parse({\n  name: \"People\",\n  subcategories: [\n    {\n      name: \"Politicians\",\n      subcategories: [{ name: \"Presidents\", subcategories: [] }],\n    },\n  ],\n}); // 通过\n```\n\n----------------------------------------\n\nTITLE: Using ZodType with ZodEffects in TypeScript\nDESCRIPTION: Defines input and output types for a Zod schema that combines ZodType and ZodEffects. It refines a string ID to ensure it has the format `string/string` using the `refine` method, and then extends a base schema with a lazy-loaded array of itself to handle recursive structures. The code snippet demonstrates how to define complex schema types with input, output, and transform logic.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\nconst isValidId = (id: string): id is `${string}/${string}` =>\n  id.split(\"/\").length === 2;\n\nconst baseSchema = z.object({\n  id: z.string().refine(isValidId),\n});\n\ntype Input = z.input & {\n  children: Input[];\n};\n\ntype Output = z.output & {\n  children: Output[];\n};\n\nconst schema: z.ZodType = baseSchema.extend({\n  children: z.lazy(() => schema.array()),\n});\n```\n\n----------------------------------------\n\nTITLE: Inferring Input and Output Types with Transform\nDESCRIPTION: Illustrates how to extract input and output types from a Zod schema that uses `transform`. It shows that `z.infer` returns the output type, and introduces `z.input` and `z.output` to access the input and output types explicitly.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_118\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringToNumber = z.string().transform((val) => val.length);\n\n// ⚠️ 중요: z.infer는 출력 타입을 반환합니다!\ntype input = z.input; // string\ntype output = z.output; // number\n\n// z.output와 동일합니다!\ntype inferred = z.infer<typeof stringToNumber>; // number\n```\n\n----------------------------------------\n\nTITLE: Async Transform with Zod and TypeScript\nDESCRIPTION: This code demonstrates how to define an asynchronous transform function with Zod. It takes a UUID string, retrieves a user by ID, and transforms the ID into a user object using an async function.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_97\n\nLANGUAGE: typescript\nCODE:\n```\nconst IdToUser = z\n  .string()\n  .uuid()\n  .transform(async (id) => {\n    return await getUserById(id);\n  });\n```\n\n----------------------------------------\n\nTITLE: String Refinement with Message\nDESCRIPTION: Defines a string schema with a refinement to check the length of the string. If the length exceeds 255 characters, a custom error message is returned.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_88\n\nLANGUAGE: typescript\nCODE:\n```\nconst myString = z.string().refine((val) => val.length <= 255, {\n  message: \"String can't be more than 255 characters\",\n});\n```\n\n----------------------------------------\n\nTITLE: Inferring TypeScript Types from Zod Schemas\nDESCRIPTION: Explains how to extract TypeScript types from Zod schemas using `z.infer<typeof mySchema>`.  It demonstrates inferring types from simple schemas and explains how Zod internally tracks both input and output types, which can differ after transformations.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_117\n\nLANGUAGE: typescript\nCODE:\n```\nconst A = z.string();\ntype A = z.infer<typeof A>; // string\n\nconst u: A = 12; // TypeError\nconst u: A = \"asdf\"; // 컴파일 성공\n```\n\n----------------------------------------\n\nTITLE: Creating Partial Zod Object\nDESCRIPTION: Illustrates making all properties of a Zod object schema optional using the `.partial()` method.  All properties become optional.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z.object({\n  email: z.string(),\n  username: z.string(),\n});\n// { email: string; username: string }\n\nconst partialUser = user.partial();\n// { email?: string | undefined; username?: string | undefined }\n```\n\n----------------------------------------\n\nTITLE: Defining a Zod Object Schema for Form Data in TypeScript\nDESCRIPTION: This snippet defines a Zod object schema named 'FormData' for validating form data. It includes validations for a required string field ('name') and a nested object ('contactInfo') with validations for an email string and an optional phone string.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst FormData = z.object({\n  name: z.string(),\n  contactInfo: z.object({\n    email: z.string().email(),\n    phone: z.string().optional(),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Refinement\nDESCRIPTION: Demonstrates an asynchronous refinement using `.refine` to perform validation that requires asynchronous operations, such as database lookups.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_92\n\nLANGUAGE: typescript\nCODE:\n```\nconst userId = z.string().refine(async (id) => {\n  // verify that ID exists in database\n  return true;\n});\n```\n\n----------------------------------------\n\nTITLE: Zod Array Schema TypeScript\nDESCRIPTION: This code demonstrates using the `array()` method to create an array schema for strings.  The resulting schema validates an array of strings.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_106\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringArray = z.string().array(); // string[]\n\n// 위 코드는 아래와 동일합니다\nz.array(z.string());\n```\n\n----------------------------------------\n\nTITLE: Parsing Data with Zod\nDESCRIPTION: This example demonstrates using the `.parse` method to validate data against a Zod schema. It shows how valid data is returned while invalid data throws an error with type information.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string();\nstringSchema.parse(\"fish\"); // => returns \"fish\"\nstringSchema.parse(12); // throws Error('Non-string type: number');\n```\n\n----------------------------------------\n\nTITLE: Accessing Element Schema from Zod Array\nDESCRIPTION: Demonstrates how to use the `.element` property of a `ZodArray` instance to access the schema of the array's elements.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nstringArray.element; // => string schema\n```\n\n----------------------------------------\n\nTITLE: Strict Object Schema with Zod\nDESCRIPTION: This snippet demonstrates how to create a strict object schema that prohibits unknown keys. If unknown keys are present in the input, Zod will throw an error when parsing.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = z\n  .object({\n    name: z.string(),\n  })\n  .strict();\n\nperson.parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => throws ZodError\n```\n\n----------------------------------------\n\nTITLE: Install Zod using package managers\nDESCRIPTION: This snippet shows how to install Zod using npm, deno, yarn, bun, or pnpm.  Choose the appropriate command based on your preferred package manager.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install zod\n```\n\nLANGUAGE: shell\nCODE:\n```\ndeno add npm:zod      # deno\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn add zod          # yarn\n```\n\nLANGUAGE: shell\nCODE:\n```\nbun add zod           # bun\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm add zod          # pnpm\n```\n\n----------------------------------------\n\nTITLE: Time Validation in Zod\nDESCRIPTION: This code snippet demonstrates how to use the `z.string().time()` method to validate strings in the format `HH:MM:SS[.s+]`. The second can include arbitrary decimal precision. It does not allow timezone offsets of any kind. Added in Zod 3.23\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst time = z.string().time();\n\ntime.parse(\"00:00:00\"); // pass\ntime.parse(\"09:52:31\"); // pass\ntime.parse(\"23:59:59.9999999\"); // pass (arbitrary precision)\n\ntime.parse(\"00:00:00.123Z\"); // fail (no `Z` allowed)\ntime.parse(\"00:00:00.123+02:00\"); // fail (no offsets allowed)\n```\n\n----------------------------------------\n\nTITLE: Handling Zod Errors\nDESCRIPTION: Illustrates how to handle Zod errors using `safeParse` and accessing the `issues` array of the `ZodError` object. It shows the structure of the error issues, including error codes, expected and received types, paths, and messages.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_122\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = z\n  .object({\n    name: z.string(),\n  })\n  .safeParse({ name: 12 });\n\nif (!result.success) {\n  result.error.issues;\n  /* [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"string\",\n        \"received\": \"number\",\n        \"path\": [ \"name\" ],\n        \"message\": \"Expected string, received number\"\n      }\n  ] */\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Zod Validation Errors in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the `.format()` method in Zod to convert a validation error into a nested object. It first defines a Zod object schema with a string field named 'name'. Then, it attempts to parse an object with a number value for the 'name' field.  If the parsing fails, the `.format()` method is called on the error object to produce a nested object representing the error structure, which can then be accessed to retrieve specific error messages. The formatted object contains the error messages grouped by the field names where the errors occurred.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_120\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = z\n  .object({\n    name: z.string(),\n  })\n  .safeParse({ name: 12 });\n\nif (!result.success) {\n  const formatted = result.error.format();\n  /* {\n    name: { _errors: [ 'Expected string, received number' ] }\n  } */\n\n  formatted.name?._errors;\n  // => [\"Expected string, received number\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Deep Partial Object Schema with .deepPartial\nDESCRIPTION: This snippet demonstrates how to create a deep partial object schema using the `.deepPartial()` method.  It makes all properties optional recursively, including nested objects and array elements that are objects. It only works on object, arrays and tuples correctly.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z.object({\n  username: z.string(),\n  location: z.object({\n    latitude: z.number(),\n    longitude: z.number(),\n  }),\n  strings: z.array(z.object({ value: z.string() })),\n});\n\nconst deepPartialUser = user.deepPartial();\n\n/*\n{\n  username?: string | undefined,\n  location?: {\n    latitude?: number | undefined;\n    longitude?: number | undefined;\n  } | undefined,\n  strings?: { value?: string}[]\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Zod Native Enum (Numeric)\nDESCRIPTION: Shows how to validate against a numeric enum from TypeScript using `z.nativeEnum()`.  It parses numeric enum values, including the underlying numeric values.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nenum Fruits {\n  Apple,\n  Banana,\n}\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // Fruits\n\nFruitEnum.parse(Fruits.Apple); // passes\nFruitEnum.parse(Fruits.Banana); // passes\nFruitEnum.parse(0); // passes\nFruitEnum.parse(1); // passes\nFruitEnum.parse(3); // fails\n```\n\n----------------------------------------\n\nTITLE: Creating Partial with Specific Properties\nDESCRIPTION: Shows how to make specific properties optional while retaining the required status of others using `.partial({property: true})`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z.object({\n  email: z.string(),\n  username: z.string(),\n});\n/*\n{ email: string;\nusername: string\n}\n*/\n\nconst optionalEmail = user.partial({\n  email: true,\n});\n/*\n{\nemail?: string | undefined;\nusername: string\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Zod Tuple Definition (TypeScript)\nDESCRIPTION: This snippet defines a tuple schema with fixed-length elements, each with a specific type. The example creates an `athleteSchema` with a string, a number, and an object.  The inferred type is also demonstrated.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_68\n\nLANGUAGE: typescript\nCODE:\n```\nconst athleteSchema = z.tuple([\n  z.string(), // 이름\n  z.number(), // 등번호\n  z.object({\n    pointsScored: z.number(),\n  }), // 통계\n]);\n\ntype Athlete = z.infer<typeof athleteSchema>;\n// type Athlete = [string, number, { pointsScored: number }]\n```\n\n----------------------------------------\n\nTITLE: Defining a Zod Object Schema in TypeScript\nDESCRIPTION: This snippet defines a Zod object schema named 'person' with nested objects and specific validations. It includes validations for string arrays (nonempty), required string fields, number fields with minimum values, and strict mode to prevent unrecognized keys.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = z.object({\n  names: z.array(z.string()).nonempty(), // at least 1 name\n  address: z\n    .object({\n      line1: z.string(),\n      zipCode: z.number().min(10000), // American 5-digit code\n    })\n    .strict(), // do not allow unrecognized keys\n});\n```\n\n----------------------------------------\n\nTITLE: Selective Partial (Zod)\nDESCRIPTION: This snippet shows how to make specific fields of a Zod object optional using the `.partial()` method. This allows you to create variations of an object schema where certain properties can be omitted while others remain required, providing flexibility in data validation.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CHANGELOG.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z.object({\n  name: z.string(),\n  age: z.number(),\n});\n\nconst optionalNameUser = user.partial({ name: true });\n// { name?: string; age: number; }\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Zod\nDESCRIPTION: This snippet demonstrates how to use `z.infer` to extract the TypeScript type from a Zod schema. The type `A` is inferred as `string` from the `z.string()` schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nconst A = z.string();\ntype A = z.infer<typeof A>; // string\n\nconst u: A = 12; // TypeError\nconst u: A = \"asdf\"; // compiles\n```\n\n----------------------------------------\n\nTITLE: Number Validation with Zod\nDESCRIPTION: This snippet showcases various number-specific validation methods provided by Zod, such as greater than, less than, integer, positive, negative, multiple of, finite, and safe integer checks. Each method is demonstrated for validating numbers with different constraints.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nz.number().gt(5); // 5보다 커야 함\nz.number().gte(5); // 5보다 크거나 같아야 함 (.min(5)와 동일)\nz.number().lt(5); // 5보다 작아야 함\nz.number().lte(5); // 5보다 작거나 같아야 함 (.max(5)와 동일)\n\nz.number().int(); // 정수여야 함\n\nz.number().positive(); // 0보다 커야 함\nz.number().nonnegative(); // 0보다 크거나 같아야 함\nz.number().negative(); // 0보다 작아야 함\nz.number().nonpositive(); // 0보다 작거나 같아야 함\n\nz.number().multipleOf(5); // 5로 나누어 떨어져야 함 (.step(5)와 동일)\n\nz.number().finite(); // 유한한 값이어야 함 (Infinity 또는 -Infinity 불가)\nz.number().safe(); // Number.MIN_SAFE_INTEGER와 Number.MAX_SAFE_INTEGER 사이의 값이어야 함\n```\n\n----------------------------------------\n\nTITLE: Zod Array Creation (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create an array schema using Zod, specifying that the array should contain elements of a particular type (in this case, strings). It illustrates the equivalent ways to define the array schema and highlights the importance of method order when using `.optional()` with `.array()`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringArray = z.array(z.string());\n\n// 동일한 표현\nconst stringArray = z.string().array();\n```\n\n----------------------------------------\n\nTITLE: Create and Parse an Object Schema (Zod)\nDESCRIPTION: This snippet shows how to create an object schema with Zod. It defines a `User` object with a `username` property of type string.  It also demonstrates how to infer the TypeScript type from the Zod schema using `z.infer`. Dependencies: Zod library.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\";\n\nconst User = z.object({\n  username: z.string(),\n});\n\nUser.parse({ username: \"Ludwig\" });\n\n// 提取出推断的类型\ntype User = z.infer<typeof User>;\n// { username: string }\n```\n\n----------------------------------------\n\nTITLE: Zod Native Enum (String)\nDESCRIPTION: Demonstrates validating against a string enum from TypeScript using `z.nativeEnum()`. It parses both enum values and their corresponding string values.  It can handle mixed numerical and string enums.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nenum Fruits {\n  Apple = \"apple\",\n  Banana = \"banana\",\n  Cantaloupe, // you can mix numerical and string enums\n}\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // Fruits\n\nFruitEnum.parse(Fruits.Apple); // passes\nFruitEnum.parse(Fruits.Cantaloupe); // passes\nFruitEnum.parse(\"apple\"); // passes\nFruitEnum.parse(\"banana\"); // passes\nFruitEnum.parse(0); // passes\nFruitEnum.parse(\"Cantaloupe\"); // fails\n```\n\n----------------------------------------\n\nTITLE: Creating a String Schema in Zod\nDESCRIPTION: Demonstrates how to create a simple string schema in Zod, parse a string, and handle validation errors using `parse` and `safeParse`.  `parse` throws an error when validation fails, while `safeParse` returns an object indicating success or failure.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { z } from \"zod\";\n\n// creating a schema for strings\nconst mySchema = z.string();\n\n// parsing\nmySchema.parse(\"tuna\"); // => \"tuna\"\nmySchema.parse(12); // => throws ZodError\n\n// \"safe\" parsing (doesn't throw error if validation fails)\nmySchema.safeParse(\"tuna\"); // => { success: true; data: \"tuna\" }\nmySchema.safeParse(12); // => { success: false; error: ZodError }\n```\n\n----------------------------------------\n\nTITLE: Array Schema Definition in Zod\nDESCRIPTION: This snippet illustrates defining array schemas in Zod, showing both the `z.array(z.string())` and `z.string().array()` approaches for creating a string array schema. It highlights the importance of method order when chaining methods like `.optional()` with `.array()` due to the creation of new `ZodArray` instances.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringArray = z.array(z.string());\n\n// 相当于\nconst stringArray = z.string().array();\n```\n\n----------------------------------------\n\nTITLE: Zod Nullable Schema\nDESCRIPTION: Demonstrates creating a nullable schema using `z.nullable()`. The schema accepts either a string or `null` as valid input.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nconst nullableString = z.nullable(z.string());\nnullableString.parse(\"asdf\"); // => \"asdf\"\nnullableString.parse(null); // => null\n```\n\n----------------------------------------\n\nTITLE: Non-Empty Array Validation in Zod\nDESCRIPTION: This code demonstrates how to use the `.nonempty()` method in Zod to ensure that an array contains at least one element. The `.nonempty()` method modifies the inferred type to `[string, ...string[]]` and throws an error if the array is empty.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nconst nonEmptyStrings = z.string().array().nonempty();\n// 现在推断的类型是\n// [string, ...string[]]\n\nnonEmptyStrings.parse([]); // throws: \"Array cannot be empty\"\nnonEmptyStrings.parse([\"Ariana Grande\"]); // passes\n```\n\n----------------------------------------\n\nTITLE: Defining Map Schema in Zod\nDESCRIPTION: Demonstrates how to use `z.map` to define a schema for a Map object with string keys and number values. It also shows how to infer the TypeScript type from the schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringNumberMap = z.map(z.string(), z.number());\n\ntype StringNumberMap = z.infer<typeof stringNumberMap>;\n// type StringNumberMap = Map<string, number>\n```\n\n----------------------------------------\n\nTITLE: Zod Enum with Const Assertion\nDESCRIPTION: This snippet shows how to define a Zod enum using a `const` assertion to ensure the values are treated as a string tuple. This allows Zod to accurately infer the type of the enum values.  The VALUES array holds the allowed enum values.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nconst VALUES = [\"Salmon\", \"Tuna\", \"Trout\"] as const;\nconst FishEnum = z.enum(VALUES);\n```\n\n----------------------------------------\n\nTITLE: Constraining Array Length in Zod\nDESCRIPTION: Demonstrates how to use `.min()`, `.max()`, and `.length()` methods to specify the minimum, maximum, and exact length of an array, respectively. These methods validate array size without altering inferred type.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_66\n\nLANGUAGE: typescript\nCODE:\n```\nz.string().array().min(5); // must contain 5 or more items\nz.string().array().max(5); // must contain 5 or fewer items\nz.string().array().length(5); // must contain 5 items exactly\n```\n\n----------------------------------------\n\nTITLE: Catchall Schema in Zod\nDESCRIPTION: This code demonstrates how to use the `.catchall` method in Zod to define an object schema that allows unknown keys, validating them against a specified schema. This is useful for scenarios where you need to accept extra keys in an object, ensuring they conform to a specific type. It avoids the use of `.passthrough()`, `.strip()`, or `.strict()`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = z\n  .object({\n    name: z.string(),\n  })\n  .catchall(z.number());\n\nperson.parse({\n  name: \"bob dylan\",\n  validExtraKey: 61, // 运行良好\n});\n\nperson.parse({\n  name: \"bob dylan\",\n  validExtraKey: false, // 未能成功\n});\n// => throws ZodError\n```\n\n----------------------------------------\n\nTITLE: Refining Zod Arrays with superRefine in TypeScript\nDESCRIPTION: This code demonstrates using `superRefine` to add custom validation logic to a Zod array schema. It checks if the array's length exceeds 3 and if there are duplicate elements. If either condition is true, it adds an issue to the validation context.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_90\n\nLANGUAGE: typescript\nCODE:\n```\nconst Strings = z.array(z.string()).superRefine((val, ctx) => {\n  if (val.length > 3) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.too_big,\n      maximum: 3,\n      type: \"array\",\n      inclusive: true,\n      message: \"Too many items 😡\",\n    });\n  }\n\n  if (val.length !== new Set(val).size) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: `No duplicates allowed.`,\n    });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Zod Enum\nDESCRIPTION: This snippet shows how to define a Zod enum with a set of allowed string values, representing different types of fish. It also demonstrates how to extract the inferred type from the enum schema. The inferred type is a union of the allowed string values.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nconst FishEnum = z.enum([\"Salmon\", \"Tuna\", \"Trout\"]);\ntype FishEnum = z.infer<typeof FishEnum>;\n// 'Salmon' | 'Tuna' | 'Trout'\n```\n\n----------------------------------------\n\nTITLE: Validating JSON Type with Zod\nDESCRIPTION: This snippet demonstrates how to validate any JSON value using Zod. It defines a `literalSchema` as a union of basic JSON types (string, number, boolean, null) and recursively constructs a `jsonSchema` allowing for nested objects and arrays, leveraging `z.lazy` for the recursive schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nconst literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);\ntype Literal = z.infer<typeof literalSchema>;\ntype Json = Literal | { [key: string]: Json } | Json[];\nconst jsonSchema: z.ZodSchema<Json> = z.lazy(() =>\n  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])\n);\n\njsonSchema.parse(data);\n```\n\n----------------------------------------\n\nTITLE: Creating a promise schema with `.promise`\nDESCRIPTION: Demonstrates how to create a promise schema using the `.promise()` method. The resulting schema represents a Promise that resolves to a string.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_111\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringPromise = z.string().promise(); // Promise<string>\n\n// equivalent to\nz.promise(z.string());\n```\n\n----------------------------------------\n\nTITLE: Datetime Validation in Zod\nDESCRIPTION: This code snippet demonstrates how to use the `z.string().datetime()` method to validate ISO 8601 datetime strings in Zod. It shows how to parse valid and invalid datetime strings based on the default settings (no timezone offsets).\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst datetime = z.string().datetime();\n\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00.123Z\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00.123456Z\"); // pass (arbitrary precision)\ndatetime.parse(\"2020-01-01T00:00:00+02:00\"); // fail (no offsets allowed)\n```\n\n----------------------------------------\n\nTITLE: Zod Intersection Type (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create an intersection type by combining two object schemas. It shows how to use both `z.intersection` and the `.and` method to achieve the same result. It also mentions that `A.merge(B)` is generally preferred over `A.and(B)` for object merging.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nconst Person = z.object({\n  name: z.string(),\n});\n\nconst Employee = z.object({\n  role: z.string(),\n});\n\nconst EmployedPerson = z.intersection(Person, Employee);\n\n// 다음과 동일합니다:\nconst EmployedPerson = Person.and(Employee);\n\nconst a = z.union([z.number(), z.string()]);\nconst b = z.union([z.number(), z.boolean()]);\nconst c = z.intersection(a, b);\n\ntype c = z.infer<typeof c>; // => number\n```\n\n----------------------------------------\n\nTITLE: Parsing Data Asynchronously with Zod\nDESCRIPTION: This example demonstrates how to use the `.parseAsync` method for asynchronous validation with Zod. It shows how to define a string schema with an asynchronous refinement and then use `.parseAsync` to validate the data.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string().refine(async (val) => val.length > 20);\nconst value = await stringSchema.parseAsync(\"hello\"); // => hello\n```\n\n----------------------------------------\n\nTITLE: Zod Intersection Type Schema TypeScript\nDESCRIPTION: This code demonstrates using the `and` method to create an intersection type schema in Zod. The resulting schema represents the intersection of two object types: one with a `name` property (string) and another with an `age` property (number).\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_109\n\nLANGUAGE: typescript\nCODE:\n```\nconst nameAndAge = z\n  .object({ name: z.string() })\n  .and(z.object({ age: z.number() })); // { name: string } & { age: number }\n\n// 위 코드는 아래와 동일합니다.\nz.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));\n```\n\n----------------------------------------\n\nTITLE: Creating Deep Partial Zod Object\nDESCRIPTION: Demonstrates making all nested properties of a Zod object schema optional using the `.deepPartial()` method.  This creates a partial object recursively.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z.object({\n  username: z.string(),\n  location: z.object({\n    latitude: z.number(),\n    longitude: z.number(),\n  }),\n  strings: z.array(z.object({ value: z.string() })),\n});\n\nconst deepPartialUser = user.deepPartial();\n\n/*\n{\n  username?: string | undefined,\n  location?: {\n    latitude?: number | undefined;\n    longitude?: number | undefined;\n  } | undefined,\n  strings?: { value?: string}[]\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Customize String Validation Error Messages (Zod)\nDESCRIPTION: This snippet demonstrates how to customize error messages for individual string validation methods in Zod. You can pass a `message` option to methods like `min`, `max`, `length`, `email`, etc.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nz.string().min(5, { message: \"Must be 5 or more characters long\" });\nz.string().max(5, { message: \"Must be 5 or fewer characters long\" });\nz.string().length(5, { message: \"Must be exactly 5 characters long\" });\nz.string().email({ message: \"Invalid email address\" });\nz.string().url({ message: \"Invalid url\" });\nz.string().emoji({ message: \"Contains non-emoji characters\" });\nz.string().uuid({ message: \"Invalid UUID\" });\nz.string().includes(\"tuna\", { message: \"Must include tuna\" });\nz.string().startsWith(\"https://\", { message: \"Must provide secure URL\" });\nz.string().endsWith(\".com\", { message: \"Only .com domains allowed\" });\nz.string().datetime({ message: \"Invalid datetime string! Must be UTC.\" });\nz.string().ip({ message: \"Invalid IP address\" });\n```\n\n----------------------------------------\n\nTITLE: Branded Types with Zod TypeScript\nDESCRIPTION: This code demonstrates how to create branded types using Zod's `.brand()` method to simulate nominal typing in TypeScript. It prevents structurally identical types from being used interchangeably.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_110\n\nLANGUAGE: typescript\nCODE:\n```\nconst Cat = z.object({ name: z.string() }).brand();\ntype Cat = z.infer<typeof Cat>;\n\nconst petCat = (cat: Cat) => {};\n\n// 이 코드는 동작\nconst simba = Cat.parse({ name: \"simba\" });\npetCat(simba);\n\n// 이 코드는 동작하지 않음\npetCat({ name: \"fido\" });\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst Cat = z.object({ name: z.string() }).brand();\ntype Cat = z.infer<typeof Cat>;\n// {name: string} & {[symbol]: \"Cat\"}\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Type Schema in Zod\nDESCRIPTION: Demonstrates how to define a recursive schema in Zod using `z.lazy` to handle self-references. Due to TypeScript limitations, the type definition needs to be manually defined and provided as a type hint.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\nconst baseCategorySchema = z.object({\n  name: z.string(),\n});\n\ntype Category = z.infer<typeof baseCategorySchema> & {\n  subcategories: Category[];\n};\n\nconst categorySchema: z.ZodType<Category> = baseCategorySchema.extend({\n  subcategories: z.lazy(() => categorySchema.array()),\n});\n\ncategorySchema.parse({\n  name: \"People\",\n  subcategories: [\n    {\n      name: \"Politicians\",\n      subcategories: [\n        {\n          name: \"Presidents\",\n          subcategories: [],\n        },\n      ],\n    },\n  ],\n}); // passes\n```\n\n----------------------------------------\n\nTITLE: Defining String Array Schema in Zod\nDESCRIPTION: Defines a Zod schema for an array of strings. It demonstrates two equivalent ways to achieve the same result: using `z.array(z.string())` and `z.string().array()`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringArray = z.array(z.string());\n\n// equivalent\nconst stringArray = z.string().array();\n```\n\n----------------------------------------\n\nTITLE: Omitting Properties from Object Schema with .omit in Zod\nDESCRIPTION: This snippet shows how to omit certain properties from a Zod object schema using the `.omit()` method.  The new schema will contain all the properties from the original schema except the ones specified in the argument. Here, the `id` property is omitted from the `Recipe` schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nconst NoIDRecipe = Recipe.omit({ id: true });\n\ntype NoIDRecipe = z.infer<typeof NoIDRecipe>;\n// => { name: string, ingredients: string[] }\n```\n\n----------------------------------------\n\nTITLE: Coercing to Date with Zod\nDESCRIPTION: This snippet demonstrates how to coerce inputs to a `Date` object using Zod's `z.coerce.date()` schema. It validates different date formats and logs the success status of parsing each format using `safeParse`. This feature was added in Zod version 3.20.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nconst dateSchema = z.coerce.date();\ntype DateSchema = z.infer<typeof dateSchema>;\n// 타입 DateSchema = Date\n\n/* 유효한 날짜 */\nconsole.log(dateSchema.safeParse(\"2023-01-10T00:00:00.000Z\").success); // true\nconsole.log(dateSchema.safeParse(\"2023-01-10\").success); // true\nconsole.log(dateSchema.safeParse(\"1/10/23\").success); // true\nconsole.log(dateSchema.safeParse(new Date(\"1/10/23\")).success); // true\n\n/* 유효하지 않은 날짜 */\nconsole.log(dateSchema.safeParse(\"2023-13-10\").success); // false\nconsole.log(dateSchema.safeParse(\"0000-00-00\").success); // false\n```\n\n----------------------------------------\n\nTITLE: Inferring Flattened Errors with Custom Mapper\nDESCRIPTION: Demonstrates how to use `z.inferFlattenedErrors` with a second generic argument that specifies the type returned by a custom `ZodIssue` mapper function. This allows customizing the structure of the error messages.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ntype FormDataErrors = z.inferFlattenedErrors<\n  typeof FormData,\n  { message: string; errorCode: string }\n>;\n\n/*\n  { \n    formErrors: { message: string, errorCode: string }[],\n    fieldErrors: {\n      email?: { message: string, errorCode: string }[],\n      password?: { message: string, errorCode: string }[],\n      confirm?: { message: string, errorCode: string }[]\n    }\n  }\n*/\n```\n\n----------------------------------------\n\nTITLE: Omitting Properties from Zod Object\nDESCRIPTION: Demonstrates how to create a new Zod object schema excluding the specified properties from an existing schema using the `.omit` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nconst Recipe = z.object({\n  id: z.string(),\n  name: z.string(),\n  ingredients: z.array(z.string()),\n});\n\nconst NoIDRecipe = Recipe.omit({ id: true });\n\ntype NoIDRecipe = z.infer<typeof NoIDRecipe>;\n// => { name: string, ingredients: string[] }\n```\n\n----------------------------------------\n\nTITLE: Extending Object Schema with .extend in Zod\nDESCRIPTION: This snippet shows how to extend an existing Zod object schema using the `.extend()` method. This allows you to add new fields to the schema while inheriting the existing properties. The `DogWithBreed` now contains all the properties of `Dog` plus the additional `breed` property.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nconst DogWithBreed = Dog.extend({\n  breed: z.string(),\n});\n```\n\n----------------------------------------\n\nTITLE: Array Schema with Optional and Order\nDESCRIPTION: This snippet explains the impact of the order in which methods are called when using Zod to define array schemas with optional values. It shows that `z.string().optional().array()` creates an array of optional strings, while `z.string().array().optional()` creates an optional array of strings. The order affects the inferred type.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nz.string().optional().array(); // (string | undefined)[]\nz.string().array().optional(); // string[] | undefined\n```\n\n----------------------------------------\n\nTITLE: Custom Error Messages for Validation Methods (TypeScript)\nDESCRIPTION: This snippet shows how to provide custom error messages as an optional argument when using Zod's string validation methods, such as `min`, `max`, `email`, and `url`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nz.string().min(5, { message: \"5자 이상이어야 합니다\" });\nz.string().max(5, { message: \"5자 이하여야 합니다\" });\nz.string().length(5, { message: \"정확히 5자여야 합니다\" });\nz.string().email({ message: \"유효하지 않은 이메일 주소입니다\" });\nz.string().url({ message: \"유효하지 않은 URL입니다\" });\nz.string().emoji({ message: \"이모지가 아닌 문자가 포함되어 있습니다\" });\nz.string().uuid({ message: \"유효하지 않은 UUID입니다\" });\nz.string().includes(\"tuna\", { message: \"'tuna'가 포함되어야 합니다\" });\nz.string().startsWith(\"https://\", { message: \"보안 URL이어야 합니다\" });\nz.string().endsWith(\".com\", { message: \".com 도메인만 허용됩니다\" });\nz.string().datetime({\n  message: \"유효하지 않은 날짜/시간 문자열입니다! UTC여야 합니다.\",\n});\nz.string().date({ message: \"유효하지 않은 날짜 문자열입니다!\" });\nz.string().time({ message: \"유효하지 않은 시간 문자열입니다!\" });\nz.string().ip({ message: \"유효하지 않은 IP 주소입니다\" });\nz.string().cidr({ message: \"유효하지 않은 CIDR입니다\" });\n```\n\n----------------------------------------\n\nTITLE: Piping Zod Schemas TypeScript\nDESCRIPTION: This code demonstrates using the `pipe` method to create a validation pipeline. It transforms a string into its length and then validates that the length is greater than or equal to 5.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_112\n\nLANGUAGE: typescript\nCODE:\n```\nz.string()\n  .transform((val) => val.length) // 문자열을 길이로 변환\n  .pipe(z.number().min(5)); // 길이가 5 이상인지 검증\n```\n\n----------------------------------------\n\nTITLE: Parsing Form Data and Handling Errors in TypeScript\nDESCRIPTION: This snippet demonstrates parsing form data using the 'FormData' schema and handling errors with `safeParse`. It calls `FormData.safeParse` with invalid data (null for 'name' and an invalid email). It then checks if the result is a failure and logs the issues array of the ZodError.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = FormData.safeParse({\n  name: null,\n  contactInfo: {\n    email: \"not an email\",\n    phone: \"867-5309\",\n  },\n});\n\nif (!result.success) {\n  console.log(result.error.issues);\n}\n```\n\n----------------------------------------\n\nTITLE: Refining Schemas with Zod\nDESCRIPTION: This code demonstrates how to use `.refine` to add custom validation logic to a Zod schema. It shows how to define a validation function and optional parameters to customize the error message, path, and params object. It also demonstrates how to create asynchronous refinements.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nconst myString = z.string().refine((val) => val.length <= 255, {\n  message: \"String can't be more than 255 characters\",\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nz.string().refine(\n  (val) => val.length > 10,\n  (val) => ({ message: `${val} is not more than 10 characters` })\n);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst passwordForm = z\n  .object({\n    password: z.string(),\n    confirm: z.string(),\n  })\n  .refine((data) => data.password === data.confirm, {\n    message: \"Passwords don't match\",\n    path: [\"confirm\"], // path of error\n  })\n  .parse({ password: \"asdf\", confirm: \"qwer\" });\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst userId = z.string().refine(async (id) => {\n  // verify that ID exists in database\n  return true;\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Subset of Zod Enum with extract/exclude\nDESCRIPTION: This code shows how to create a subset of a Zod enum using `.extract()` and `.exclude()`. `extract()` creates a new enum containing only specified values from the original enum.  `exclude()` creates a new enum excluding certain specified values from original enum.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nconst FishEnum = z.enum([\"Salmon\", \"Tuna\", \"Trout\"]);\nconst SalmonAndTrout = FishEnum.extract([\"Salmon\", \"Trout\"]);\nconst TunaOnly = FishEnum.exclude([\"Salmon\", \"Trout\"]);\n```\n\n----------------------------------------\n\nTITLE: Picking Properties from Zod Object\nDESCRIPTION: Shows how to create a new Zod object schema containing only the specified properties from an existing schema using the `.pick` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nconst Recipe = z.object({\n  id: z.string(),\n  name: z.string(),\n  ingredients: z.array(z.string()),\n});\n\nconst JustTheName = Recipe.pick({ name: true });\ntype JustTheName = z.infer<typeof JustTheName>;\n// => { name: string }\n```\n\n----------------------------------------\n\nTITLE: Coercing Primitive Types with Zod (TypeScript)\nDESCRIPTION: This snippet demonstrates how to coerce values to primitive types using Zod's `z.coerce`. It uses built-in JavaScript constructors like `String`, `Number`, and `new Date` to transform input values.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.coerce.string();\nschema.parse(\"tuna\"); // => \"tuna\"\nschema.parse(12); // => \"12\"\n```\n\n----------------------------------------\n\nTITLE: Zod Passthrough Method (TypeScript)\nDESCRIPTION: This snippet illustrates the use of the `.passthrough()` method in Zod. By default, Zod removes unrecognized keys during parsing. This method allows you to retain these unknown keys in the parsed output, maintaining the original structure of the input.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = z.object({\n  name: z.string(),\n});\n\nperson.parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => { name: \"bob dylan\" }\n// extraKey가 제거됨\n\nperson.passthrough().parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => { name: \"bob dylan\", extraKey: 61 }\n```\n\n----------------------------------------\n\nTITLE: Safely Parsing Data Asynchronously with Zod\nDESCRIPTION: This example showcases the asynchronous version of `safeParse`, called `safeParseAsync` or `.spa`. It safely parses data asynchronously and returns either a success or error object, but in a promise.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nawait stringSchema.safeParseAsync(\"billie\");\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait stringSchema.spa(\"billie\");\n```\n\n----------------------------------------\n\nTITLE: Optional String Validation with Union in Zod\nDESCRIPTION: Demonstrates how to validate an optional form input using a union of a string with URL validation and an empty string literal.  This allows the input to be either a valid URL or an empty string.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nconst optionalUrl = z.union([z.string().url().nullish(), z.literal(\"\")]);\n\nconsole.log(optionalUrl.safeParse(undefined).success); // true\nconsole.log(optionalUrl.safeParse(null).success); // true\nconsole.log(optionalUrl.safeParse(\"\").success); // true\nconsole.log(optionalUrl.safeParse(\"https://zod.dev\").success); // true\nconsole.log(optionalUrl.safeParse(\"not a valid url\").success); // false\n```\n\n----------------------------------------\n\nTITLE: Refine Params Type Definition\nDESCRIPTION: Defines the type `RefineParams` for customizing error-handling behavior in `.refine`. It allows overriding the error message, appending to the error path, and providing custom parameters for message customization in the error map.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_89\n\nLANGUAGE: typescript\nCODE:\n```\ntype RefineParams = {\n  // override error message\n  message?: string;\n\n  // appended to error path\n  path?: (string | number)[];\n\n  // params object you can use to customize message\n  // in error map\n  params?: object;\n};\n```\n\n----------------------------------------\n\nTITLE: Define Primitive Types with Zod\nDESCRIPTION: This snippet demonstrates how to define schemas for various primitive types using Zod.  It covers string, number, bigint, boolean, date, symbol, undefined, null, void, any, unknown, and never types.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\";\n\n// 原始值类型\nz.string();\nz.number();\nz.bigint();\nz.boolean();\nz.date();\nz.symbol();\n\n// 空类型\nz.undefined();\nz.null();\nz.void(); // 接受 undefined\n\n// 任意类型\n// 允许任意类型的值\nz.any();\nz.unknown();\n\n// never 类型\n// 不允许值类型存在\nz.never();\n```\n\n----------------------------------------\n\nTITLE: ParseAsync Method Usage with Zod in TypeScript\nDESCRIPTION: Illustrates the usage of the `.parseAsync` method for asynchronous validation using Zod.  It defines a schema with an asynchronous refinement and then uses `.parseAsync` to validate data against it. The snippet highlights the importance of using `.parseAsync` when dealing with asynchronous validation logic in Zod schemas.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_86\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string().refine(async (val) => val.length <= 8);\n\nawait stringSchema.parseAsync(\"hello\"); // => \"hello\" 반환\nawait stringSchema.parseAsync(\"hello world\"); // => 에러 발생\n```\n\n----------------------------------------\n\nTITLE: Zod Discriminated Union (TypeScript)\nDESCRIPTION: This snippet shows how to define and use a discriminated union using `z.discriminatedUnion`.  This approach allows Zod to determine which schema to use for parsing based on a discriminator key, leading to faster evaluation and more informative error reporting. It also demonstrates how to merge two discriminated unions using `.options`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\nconst myUnion = z.discriminatedUnion(\"status\", [\n  z.object({ status: z.literal(\"success\"), data: z.string() }),\n  z.object({ status: z.literal(\"failed\"), error: z.instanceof(Error) }),\n]);\n\nmyUnion.parse({ status: \"success\", data: \"yippie ki yay\" });\n\nmyUnion.options; // [ZodObject, ZodObject]\n\nconst A = z.discriminatedUnion(\"status\", [\n  /* options */\n]);\nconst B = z.discriminatedUnion(\"status\", [\n  /* options */\n]);\n\nconst AB = z.discriminatedUnion(\"status\", [...A.options, ...B.options]);\n```\n\n----------------------------------------\n\nTITLE: Intersection Schema with Zod\nDESCRIPTION: This example shows how to create an intersection schema using `.and()` in Zod.  The resulting schema requires both a name (string) and an age (number).\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nz.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }\n\n// equivalent to\nz.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));\n```\n\n----------------------------------------\n\nTITLE: Zod Default Value for Strings TypeScript\nDESCRIPTION: This code demonstrates using the `default` method to provide a default value for a Zod string schema. If the input is `undefined`, the schema will return the specified default value (in this case, \"tuna\").\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_98\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringWithDefault = z.string().default(\"tuna\");\n\nstringWithDefault.parse(undefined); // => \"tuna\"\n```\n\n----------------------------------------\n\nTITLE: Defining an object with optional properties in Zod\nDESCRIPTION: This code snippet shows how to define an object with both required and optional properties using Zod. It uses `z.object` to define the object schema, `z.string` and `z.number` for the property types, and `optional()` to indicate that a property is optional. The `z.infer` utility extracts the TypeScript type from the Zod schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_125\n\nLANGUAGE: typescript\nCODE:\n```\nconst C = z.object({\n  foo: z.string(),\n  bar: z.number().optional(),\n});\n\ntype C = z.infer<typeof C>;\n// 반환 타입: { foo: string; bar?: number | undefined }\n```\n\n----------------------------------------\n\nTITLE: Transforming Zod String to Domain TypeScript\nDESCRIPTION: This code shows transforming a Zod string schema to extract the domain from an email address using the `transform` method. It first validates that the string is a valid email and then splits it at the `@` symbol to return the domain part.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_94\n\nLANGUAGE: typescript\nCODE:\n```\nconst emailToDomain = z\n  .string()\n  .email()\n  .transform((val) => val.split(\"@\")[1]);\n\nemailToDomain.parse(\"colinhacks@example.com\"); // => example.com\n```\n\n----------------------------------------\n\nTITLE: Zod Optional Schema\nDESCRIPTION: Shows how to make a schema optional using `z.optional()`. The `parse` method returns `undefined` when parsing `undefined`, and the inferred type includes `undefined`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.optional(z.string());\n\nschema.parse(undefined); // => returns undefined\ntype A = z.infer<typeof schema>; // string | undefined\n```\n\n----------------------------------------\n\nTITLE: Optional Schema with Zod\nDESCRIPTION: This code demonstrates the use of `.optional()` to create an optional version of a schema. The resulting schema allows either a string or undefined as valid input.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\nconst optionalString = z.string().optional(); // string | undefined\n\n// equivalent to\nz.optional(z.string());\n```\n\n----------------------------------------\n\nTITLE: Creating an Object Schema (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create an object schema with a string field using Zod.  It shows how to parse objects against the schema and infer the TypeScript type from the schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\";\n\nconst User = z.object({\n  username: z.string(),\n});\n\nUser.parse({ username: \"Ludwig\" });\n\n// 추론된 타입 추출\ntype User = z.infer<typeof User>;\n// { username: string }\n```\n\n----------------------------------------\n\nTITLE: Customizing Number Schema Error Messages in Zod\nDESCRIPTION: This code snippet demonstrates how to customize error messages when creating a number schema using Zod.  It defines custom messages for required and invalid type errors. The age constant stores the zod schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst age = z.number({\n  required_error: \"나이는 필수입니다\",\n  invalid_type_error: \"나이는 숫자여야 합니다\",\n});\n```\n\n----------------------------------------\n\nTITLE: Discriminated Union Schema in Zod\nDESCRIPTION: This example shows how to create a discriminated union schema in Zod using `z.discriminatedUnion`. A discriminated union is a union type where a specific key (the discriminant) determines which object schema should be used to parse the input. This improves parsing efficiency and error reporting.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nconst myUnion = z.discriminatedUnion(\"status\", [\n  z.object({ status: z.literal(\"success\"), data: z.string() }),\n  z.object({ status: z.literal(\"failed\"), error: z.instanceof(Error) }),\n]);\n\nmyUnion.parse({ status: \"success\", data: \"yippie ki yay\" });\n```\n\n----------------------------------------\n\nTITLE: Async Transformation with UUID and User Retrieval\nDESCRIPTION: An example of an asynchronous transform that validates a UUID and retrieves a user by ID.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_101\n\nLANGUAGE: typescript\nCODE:\n```\nconst IdToUser = z\n  .string()\n  .uuid()\n  .transform(async (id) => {\n    return await getUserById(id);\n  });\n```\n\n----------------------------------------\n\nTITLE: Zod Passthrough Object\nDESCRIPTION: Demonstrates how to pass through unknown keys during parsing using the `.passthrough()` method.  Unrecognized keys are included in the parsed result.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = z.object({\n  name: z.string(),\n});\n\nperson.parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => { name: \"bob dylan\" }\n// extraKey has been stripped\n\nperson.passthrough().parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => { name: \"bob dylan\", extraKey: 61 }\n```\n\n----------------------------------------\n\nTITLE: Optional Schema Shorthand with .optional()\nDESCRIPTION: This snippet demonstrates the shorthand syntax for making a Zod schema optional by calling `.optional()` directly on an existing schema. It is convenient for creating optional properties within an object schema. The inferred type includes the possibility of `undefined`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z.object({\n  username: z.string().optional(),\n});\ntype C = z.infer<typeof user>; // { username?: string | undefined };\n```\n\n----------------------------------------\n\nTITLE: Zod Optional Method\nDESCRIPTION: Demonstrates the use of the `.optional()` method on an existing schema to make properties of an object optional. The inferred type represents an object with optional properties.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z.object({\n  username: z.string().optional(),\n});\ntype C = z.infer<typeof user>; // { username?: string | undefined };\n```\n\n----------------------------------------\n\nTITLE: Zod Tuple Rest Parameters (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the `.rest` method to add a variable number of arguments to a tuple schema. These additional arguments must all be of the same specified type.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\nconst variadicTuple = z.tuple([z.string()]).rest(z.number());\nconst result = variadicTuple.parse([\"hello\", 1, 2, 3]);\n// => [string, ...number[]];\n```\n\n----------------------------------------\n\nTITLE: Nullish Zod String Schema TypeScript\nDESCRIPTION: This code demonstrates using the `nullish` method to create a \"nullish\" version of a Zod string schema. The resulting schema accepts either a string, `null`, or `undefined`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_105\n\nLANGUAGE: typescript\nCODE:\n```\nconst nullishString = z.string().nullish(); // string | null | undefined\n\n// 위 코드는 아래와 동일합니다.\nz.string().nullable().optional();\n```\n\n----------------------------------------\n\nTITLE: Making All Properties Optional with .partial in Zod\nDESCRIPTION: This snippet illustrates how to make all properties in a Zod object schema optional using the `.partial()` method. This is equivalent to TypeScript's built-in `Partial` utility type.  The `partialUser` schema now has all properties as optional.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z.object({\n  email: z.string(),\n  username: z.string(),\n});\n// { email: string; username: string }\n\nconst partialUser = user.partial();\n// { email?: string | undefined; username?: string | undefined }\n```\n\n----------------------------------------\n\nTITLE: Datetime Validation with Timezone Offset in Zod\nDESCRIPTION: This code snippet shows how to allow timezone offsets in datetime validation using Zod's `z.string().datetime()` method. It sets the `offset` option to `true` and demonstrates parsing datetime strings with various timezone offsets.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst datetime = z.string().datetime({ offset: true });\n\ndatetime.parse(\"2020-01-01T00:00:00+02:00\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00.123+02:00\"); // pass (millis optional)\ndatetime.parse(\"2020-01-01T00:00:00.123+0200\"); // pass (millis optional)\ndatetime.parse(\"2020-01-01T00:00:00.123+02\"); // pass (only offset hours)\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // pass (Z still supported)\n```\n\n----------------------------------------\n\nTITLE: Array Length Validation in Zod\nDESCRIPTION: This snippet shows how to use `.min()`, `.max()`, and `.length()` methods in Zod to validate the number of elements in an array. These methods allow you to specify minimum, maximum, or exact lengths for an array schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nz.string().array().min(5); // 必须包含5个或更多元素\nz.string().array().max(5); // 必须包含5个或更少元素\nz.string().array().length(5); // 必须正好包含5个元素\n```\n\n----------------------------------------\n\nTITLE: JSON Type Validation with Zod in TypeScript\nDESCRIPTION: Validates JSON values using a Zod schema. It defines a literal schema that accepts strings, numbers, booleans, and null values, and then creates a recursive schema that allows for nested objects and arrays. The snippet demonstrates how to parse and validate JSON data against a defined schema, using `z.lazy` to handle recursive JSON structures.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\nconst literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);\ntype Literal = z.infer<typeof literalSchema>;\ntype Json = Literal | { [key: string]: Json } | Json[];\nconst jsonSchema: z.ZodType = z.lazy(() =>\n  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])\n);\n\njsonSchema.parse(data);\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Functions with Zod Schemas\nDESCRIPTION: Demonstrates how to create reusable functions that accept Zod schemas as parameters, using TypeScript generics. It emphasizes the importance of using `z.ZodTypeAny` to properly infer the schema and avoid losing type information.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_119\n\nLANGUAGE: typescript\nCODE:\n```\nfunction inferSchema(schema: z.ZodType) {\n  return schema;\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninferSchema(z.string());\n// => ZodType\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfunction inferSchema<T extends z.ZodTypeAny>(schema: T) {\n  return schema;\n}\n\ninferSchema(z.string());\n// => ZodString\n```\n\n----------------------------------------\n\nTITLE: Custom Error Messages for String Validations in Zod\nDESCRIPTION: This code snippet demonstrates how to provide custom error messages for specific string validation methods in Zod. It shows how to pass a `message` option to methods like `min`, `max`, `email`, `url`, and others to customize the error message when validation fails.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nz.string().min(5, { message: \"Must be 5 or more characters long\" });\nz.string().max(5, { message: \"Must be 5 or fewer characters long\" });\nz.string().length(5, { message: \"Must be exactly 5 characters long\" });\nz.string().email({ message: \"Invalid email address\" });\nz.string().url({ message: \"Invalid url\" });\nz.string().emoji({ message: \"Contains non-emoji characters\" });\nz.string().uuid({ message: \"Invalid UUID\" });\nz.string().includes(\"tuna\", { message: \"Must include tuna\" });\nz.string().startsWith(\"https://\", { message: \"Must provide secure URL\" });\nz.string().endsWith(\".com\", { message: \"Only .com domains allowed\" });\nz.string().datetime({ message: \"Invalid datetime string! Must be UTC.\" });\nz.string().date({ message: \"Invalid date string!\" });\nz.string().time({ message: \"Invalid time string!\" });\nz.string().ip({ message: \"Invalid IP address\" });\nz.string().cidr({ message: \"Invalid CIDR\" });\n```\n\n----------------------------------------\n\nTITLE: Catching Zod Parsing Errors with TypeScript\nDESCRIPTION: This code demonstrates using the `catch` method to provide a fallback value when a Zod schema fails to parse. If parsing fails, the schema will return the specified fallback value (in this case, 42).\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_101\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberWithCatch = z.number().catch(42);\n\nnumberWithCatch.parse(5); // => 5\nnumberWithCatch.parse(\"tuna\"); // => 42\n```\n\n----------------------------------------\n\nTITLE: Define Literal Types with Zod\nDESCRIPTION: This snippet demonstrates how to define literal types in Zod. It shows how to create schemas for specific string, number, bigint, boolean, and symbol literals.  It also shows how to access the value of a literal schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst tuna = z.literal(\"tuna\");\nconst twelve = z.literal(12);\nconst twobig = z.literal(2n); // bigint literal\nconst tru = z.literal(true);\n\nconst terrificSymbol = Symbol(\"terrific\");\nconst terrific = z.literal(terrificSymbol);\n\n// 检索字面量的值\ntuna.value; // \"tuna\"\n```\n\n----------------------------------------\n\nTITLE: Creating a union schema with `.or`\nDESCRIPTION: Explains how to create a union schema using the `.or()` method. The schema accepts either a string or a number.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_112\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringOrNumber = z.string().or(z.number()); // string | number\n\n// equivalent to\nz.union([z.string(), z.number()]);\n```\n\n----------------------------------------\n\nTITLE: Coercing to Boolean (TypeScript)\nDESCRIPTION: Illustrates the behavior of boolean coercion with `z.coerce.boolean()`, noting that all truthy values become `true` and all falsy values become `false`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.coerce.boolean(); // Boolean(input)\n\nschema.parse(\"tuna\"); // => true\nschema.parse(\"true\"); // => true\nschema.parse(\"false\"); // => true\nschema.parse(1); // => true\nschema.parse([]); // => true\n\nschema.parse(0); // => false\nschema.parse(\"\"); // => false\nschema.parse(undefined); // => false\nschema.parse(null); // => false\n```\n\n----------------------------------------\n\nTITLE: Optional Schema Definition in Zod\nDESCRIPTION: This code shows how to define optional schemas in Zod using `z.optional` and the `.optional()` method. An optional schema allows a value to be either the specified type or `undefined`. The code demonstrates parsing `undefined` with an optional schema and inferring the type.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.optional(z.string());\n\nschema.parse(undefined); // => returns undefined\ntype A = z.infer<typeof schema>; // string | undefined\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z.object({\n  username: z.string().optional(),\n});\ntype C = z.infer<typeof user>; // { username?: string | undefined };\n```\n\n----------------------------------------\n\nTITLE: Zod Strict Object\nDESCRIPTION: Illustrates how to disallow unknown keys during parsing using the `.strict()` method. If there are any unknown keys, Zod throws an error.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = z\n  .object({\n    name: z.string(),\n  })\n  .strict();\n\nperson.parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => throws ZodError\n```\n\n----------------------------------------\n\nTITLE: Zod Catchall Method (TypeScript)\nDESCRIPTION: This snippet shows how to use the `.catchall()` method in Zod to define a schema for any unknown keys in an object.  All unrecognized keys are validated against this specified schema. This eliminates the need for `.passthrough()`, `.strip()`, or `.strict()`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = z\n  .object({\n    name: z.string(),\n  })\n  .catchall(z.number());\n\nperson.parse({\n  name: \"bob dylan\",\n  validExtraKey: 61, // 정상 동작\n});\n\nperson.parse({\n  name: \"bob dylan\",\n  validExtraKey: false, // 실패\n});\n// => ZodError 발생\n```\n\n----------------------------------------\n\nTITLE: Validate Strings with Zod\nDESCRIPTION: This snippet shows various string validation methods available in Zod.  It covers constraints like max length, min length, exact length, email format, URL format, emoji, UUID, CUID, ULID, duration, regex, includes, startsWith, endsWith, datetime, and IP address validations.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// 验证\nz.string().max(5);\nz.string().min(5);\nz.string().length(5);\nz.string().email();\nz.string().url();\nz.string().emoji();\nz.string().uuid();\nz.string().cuid();\nz.string().cuid2();\nz.string().ulid();\nz.string().duration();\nz.string().regex(regex);\nz.string().includes(string);\nz.string().startsWith(string);\nz.string().endsWith(string);\nz.string().datetime(); // ISO 8601；默认值为无 UTC 偏移，选项见下文\nz.string().ip(); // 默认为 IPv4 和 IPv6，选项见下文\n\n// 转变\nz.string().trim(); // 减除空白\nz.string().toLowerCase(); // 小写化\nz.string().toUpperCase(); // 大写化\n```\n\n----------------------------------------\n\nTITLE: Zod Union Type Schema TypeScript\nDESCRIPTION: This code demonstrates using the `or` method to create a union type schema in Zod. The resulting schema accepts either a string or a number.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_108\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringOrNumber = z.string().or(z.number()); // string | number\n\n// 위 코드는 아래와 동일합니다.\nz.union([z.string(), z.number()]);\n```\n\n----------------------------------------\n\nTITLE: Creating a validation pipeline with `.pipe`\nDESCRIPTION: Demonstrates how to create a validation pipeline using the `.pipe()` method to chain schemas together, often used after a `.transform()` to validate the transformed result.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_116\n\nLANGUAGE: typescript\nCODE:\n```\nz.string()\n  .transform((val) => val.length)\n  .pipe(z.number().min(5));\n```\n\n----------------------------------------\n\nTITLE: Parse Method Usage with Zod in TypeScript\nDESCRIPTION: Demonstrates the usage of the `.parse` method to validate data against a Zod schema.  It attempts to parse a string and a number against a string schema, showing how `.parse` returns the validated value or throws an error if the validation fails. The snippet emphasizes the basic usage of Zod for data validation and type checking.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_85\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string();\n\nstringSchema.parse(\"fish\"); // => \"fish\" 반환\nstringSchema.parse(12); // 오류 발생\n```\n\n----------------------------------------\n\nTITLE: Extend Object Schema with Zod\nDESCRIPTION: This snippet demonstrates how to extend an existing object schema with additional fields using the `.extend` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst DogWithBreed = Dog.extend({\n  breed: z.string(),\n});\n```\n\n----------------------------------------\n\nTITLE: Datetime Validation with Precision Limit (TypeScript)\nDESCRIPTION: Demonstrates setting a precision limit for the fractional seconds with `z.string().datetime({ precision: 3 })`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst datetime = z.string().datetime({ precision: 3 });\n\ndatetime.parse(\"2020-01-01T00:00:00.123Z\"); // 통과\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // 실패\ndatetime.parse(\"2020-01-01T00:00:00.123456Z\"); // 실패\n```\n\n----------------------------------------\n\nTITLE: Zod Native Enum with Const Enum\nDESCRIPTION: This code snippet demonstrates how to use Zod's `z.nativeEnum()` with a `const` object mimicking an enum. It requires TypeScript 3.4 or later due to the `as const` assertion. The resulting Zod schema validates the literal values defined in the constant object.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nconst Fruits = {\n  Apple: \"apple\",\n  Banana: \"banana\",\n  Cantaloupe: 3,\n} as const;\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // \"apple\" | \"banana\" | 3\n\nFruitEnum.parse(\"apple\"); // 통과\nFruitEnum.parse(\"banana\"); // 통과\nFruitEnum.parse(3); // 통과\nFruitEnum.parse(\"Cantaloupe\"); // 실패\n```\n\n----------------------------------------\n\nTITLE: Creating Required with Specific Properties\nDESCRIPTION: Shows how to make specific properties required while retaining the optional status of others using `.required({property: true})`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z\n  .object({\n    email: z.string(),\n    username: z.string(),\n  })\n  .partial();\n  /*\n  {\n  email?: string | undefined;\n  username?: string | undefined\n  }\n  */\n\nconst requiredEmail = user.required({\n  email: true,\n});\n/*\n{\n  email: string;\n  username?: string | undefined;\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Zod Catchall Object\nDESCRIPTION: Shows how to validate unknown keys against a specific schema using the `.catchall()` method. All unknown keys must conform to the provided schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = z\n  .object({\n    name: z.string(),\n  })\n  .catchall(z.number());\n\nperson.parse({\n  name: \"bob dylan\",\n  validExtraKey: 61, // works fine\n});\n\nperson.parse({\n  name: \"bob dylan\",\n  validExtraKey: false, // fails\n});\n// => throws ZodError\n```\n\n----------------------------------------\n\nTITLE: Handling Promises with Zod\nDESCRIPTION: This code shows how to work with promises in Zod using `z.promise`. It demonstrates how Zod checks if the input is a Promise and attaches a validation step to the existing Promise. The example showcases successful and unsuccessful promise validations and error handling.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberPromise = z.promise(z.number());\n```\n\nLANGUAGE: typescript\nCODE:\n```\nnumberPromise.parse(\"tuna\");\n// ZodError: Non-Promise type: string\n\nnumberPromise.parse(Promise.resolve(\"tuna\"));\n// => Promise<number>\n\nconst test = async () => {\n  await numberPromise.parse(Promise.resolve(\"tuna\"));\n  // ZodError: Non-number type: string\n\n  await numberPromise.parse(Promise.resolve(3.14));\n  // => 3.14\n};\n```\n\n----------------------------------------\n\nTITLE: Name to Greeting Transformations and Refinements\nDESCRIPTION: Combines transforms and refinements in a sequence. The string is first converted to uppercase, then checked for a minimum length, and finally a greeting is added, with a final refinement to check for exclamation marks.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_100\n\nLANGUAGE: typescript\nCODE:\n```\nconst nameToGreeting = z\n  .string()\n  .transform((val) => val.toUpperCase())\n  .refine((val) => val.length > 15)\n  .transform((val) => `Hello ${val}`)\n  .refine((val) => val.indexOf(\"!\") === -1);\n```\n\n----------------------------------------\n\nTITLE: Defining an object with optional properties in io-ts\nDESCRIPTION: This code snippet demonstrates how to define an object type with both required and optional properties using io-ts. It uses `t.type` for required properties, `t.partial` for optional properties, and `t.intersection` to combine them. The `t.TypeOf` utility extracts the TypeScript type from the io-ts schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_124\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as t from \"io-ts\";\n\nconst A = t.type({\n  foo: t.string,\n});\n\nconst B = t.partial({\n  bar: t.number,\n});\n\nconst C = t.intersection([A, B]);\n\ntype C = t.TypeOf;\n// 반환 타입: { foo: string; bar?: number | undefined }\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Empty Array Schema in Zod\nDESCRIPTION: Demonstrates how to use the `.nonempty()` method to ensure an array contains at least one element.  It shows the error thrown when parsing an empty array and a successful parse with an array containing elements. It also covers specifying a custom error message.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_65\n\nLANGUAGE: typescript\nCODE:\n```\nconst nonEmptyStrings = z.string().array().nonempty();\n// the inferred type is now\n// [string, ...string[]]\n\nnonEmptyStrings.parse([]); // throws: \"Array cannot be empty\"\nnonEmptyStrings.parse([\"Ariana Grande\"]); // passes\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// optional custom error message\nconst nonEmptyStrings = z.string().array().nonempty({\n  message: \"Can't be empty!\",\n});\n```\n\n----------------------------------------\n\nTITLE: Validate Dates with Zod\nDESCRIPTION: This snippet showcases date validation using Zod, including parsing a date, customizing error messages for required and invalid type errors, and setting minimum and maximum date constraints.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nz.date().safeParse(new Date()); // success: true\n\nz.date({\n  required_error: \"Please select a date and time\",\n  invalid_type_error: \"That's not a date!\",\n});\n\nz.date().min(new Date(\"1900-01-01\"), { message: \"Too old\" });\nz.date().max(new Date(), { message: \"Too young!\" });\n```\n\n----------------------------------------\n\nTITLE: CIDR Validation with Version in Zod\nDESCRIPTION: This code snippet demonstrates how to specify the IP version (IPv4 or IPv6) for CIDR validation using Zod's `z.string().cidr()` method. It shows how to create separate schemas for IPv4 and IPv6 CIDR notations.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst ipv4Cidr = z.string().cidr({ version: \"v4\" });\nipv4Cidr.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003\"); // fail\n\nconst ipv6Cidr = z.string().cidr({ version: \"v6\" });\nipv6Cidr.parse(\"192.168.1.1\"); // fail\n```\n\n----------------------------------------\n\nTITLE: Nullable Zod String Schema TypeScript\nDESCRIPTION: This code demonstrates using the `nullable` method to create a nullable version of a Zod string schema. The resulting schema accepts either a string or `null`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_104\n\nLANGUAGE: typescript\nCODE:\n```\nconst nullableString = z.string().nullable(); // string | null\n\n// 위 코드는 아래와 동일합니다.\nz.nullable(z.string());\n```\n\n----------------------------------------\n\nTITLE: Creating Required Zod Object\nDESCRIPTION: Illustrates making all properties of a Zod object schema required using the `.required()` method, reversing the effect of `.partial()`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z\n  .object({\n    email: z.string(),\n    username: z.string(),\n  })\n  .partial();\n// { email?: string | undefined; username?: string | undefined }\n\nconst requiredUser = user.required();\n// { email: string; username: string }\n```\n\n----------------------------------------\n\nTITLE: Make Object Properties Optional with Zod\nDESCRIPTION: This snippet demonstrates how to make all properties of an object schema optional using the `.partial` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z.object({\n  username: z.string(),\n});\n// { username: string }\n\nconst partialUser = user.partial();\n// { username?: string | undefined }\n```\n\n----------------------------------------\n\nTITLE: Defining Union Schema in Zod\nDESCRIPTION: Demonstrates how to use `z.union` to define a schema that accepts either a string or a number.  It also shows the equivalent `.or` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringOrNumber = z.union([z.string(), z.number()]);\n\nstringOrNumber.parse(\"foo\"); // passes\nstringOrNumber.parse(14); // passes\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringOrNumber = z.string().or(z.number());\n```\n\n----------------------------------------\n\nTITLE: Native Enum Schema Definition in Zod\nDESCRIPTION: This code demonstrates how to define a native enum schema in Zod using `z.nativeEnum`. This allows you to validate against existing TypeScript enums (both string and numeric).\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nenum Fruits {\n  Apple,\n  Banana,\n}\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // Fruits\n\nFruitEnum.parse(Fruits.Apple); // 通过\nFruitEnum.parse(Fruits.Banana); // 通过\nFruitEnum.parse(0); // 通过\nFruitEnum.parse(1); // 通过\nFruitEnum.parse(3); // 未通过\n```\n\nLANGUAGE: typescript\nCODE:\n```\nenum Fruits {\n  Apple = \"apple\",\n  Banana = \"banana\",\n  Cantaloupe, // 你可以混合使用数字和字符串的枚举\n}\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // Fruits\n\nFruitEnum.parse(Fruits.Apple); // 通过\nFruitEnum.parse(Fruits.Cantaloupe); // 通过\nFruitEnum.parse(\"apple\"); // 通过\nFruitEnum.parse(\"banana\"); // 通过\nFruitEnum.parse(0); // 通过\nFruitEnum.parse(\"Cantaloupe\"); // 未通过\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst Fruits = {\n  Apple: \"apple\",\n  Banana: \"banana\",\n  Cantaloupe: 3,\n} as const;\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // \"apple\" | \"banana\" | 3\n\nFruitEnum.parse(\"apple\"); // passes\nFruitEnum.parse(\"banana\"); // passes\nFruitEnum.parse(3); // passes\nFruitEnum.parse(\"Cantaloupe\"); // fails\n```\n\n----------------------------------------\n\nTITLE: Transforming and Validating Zod String to Number TypeScript\nDESCRIPTION: This code shows how to combine transformation and validation in a single step using Zod's `transform` method. It attempts to parse a string as an integer, and if the parsing fails (isNaN), it adds an issue to the context and returns `z.NEVER` to indicate failure.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_95\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberInString = z.string().transform((val, ctx) => {\n  const parsed = parseInt(val);\n  if (isNaN(parsed)) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: \"숫자가 아닙니다.\",\n    });\n\n    // 이는 변환 함수에서 조기에 반환하기 위해 사용할 수 있는\n    // 특별한 심볼입니다. `never` 타입을 가지므로 반환 타입에\n    // 영향을 미치지 않습니다.\n    return z.NEVER;\n  }\n  return parsed;\n});\n```\n\n----------------------------------------\n\nTITLE: Merging Object Schemas with .merge in Zod\nDESCRIPTION: This snippet demonstrates how to merge two Zod object schemas using the `.merge()` method. If schemas share the same keys, properties from the second schema overwrite the first. The resulting `Teacher` schema contains all fields from both `BaseTeacher` and `HasID`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nconst BaseTeacher = z.object({ students: z.array(z.string()) });\nconst HasID = z.object({ id: z.string() });\n\nconst Teacher = BaseTeacher.merge(HasID);\ntype Teacher = z.infer<typeof Teacher>; // => { students: string[], id: string }\n```\n\n----------------------------------------\n\nTITLE: IP Address Validation with Version (TypeScript)\nDESCRIPTION: Demonstrates validating IP addresses for specific versions (IPv4 or IPv6) using the version option in `z.string().ip()`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst ipv4 = z.string().ip({ version: \"v4\" });\nipv4.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003\"); // 실패\n\nconst ipv6 = z.string().ip({ version: \"v6\" });\nipv6.parse(\"192.168.1.1\"); // 실패\n```\n\n----------------------------------------\n\nTITLE: Parsing Data with Generic Zod Schemas\nDESCRIPTION: Explains how to correctly parse data using a generic function that accepts a Zod schema. It addresses the issue of the parsed data being typed as `any` due to TypeScript's type inference, and provides a solution using type casting with `z.infer`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_120\n\nLANGUAGE: typescript\nCODE:\n```\nfunction parseData(data: unknown, schema: T) {\n  return schema.parse(data);\n}\n\nparseData(\"sup\", z.string());\n// => any\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfunction parseData(data: unknown, schema: T) {\n  return schema.parse(data) as z.infer<T>;\n  //                        ^^^^^^^^^^^^^^ <- 이 부분 추가\n}\n\nparseData(\"sup\", z.string());\n// => string\n```\n\n----------------------------------------\n\nTITLE: CIDR Validation with Version (TypeScript)\nDESCRIPTION: Demonstrates validating CIDR notations for a specific IP version using the `version` option in `z.string().cidr()`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst ipv4Cidr = z.string().cidr({ version: \"v4\" });\nipv4Cidr.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003\"); // 실패\n\nconst ipv6Cidr = z.string().cidr({ version: \"v6\" });\nipv6Cidr.parse(\"192.168.1.1\"); // 실패\n```\n\n----------------------------------------\n\nTITLE: Instanceof Validation with Zod in TypeScript\nDESCRIPTION: Shows how to use `z.instanceof` to check if an input is an instance of a specific class. It defines a `Test` class and then creates a Zod schema that validates whether a given value is an instance of that class. The code demonstrates how to use Zod to enforce type constraints based on class inheritance and object instantiation.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_81\n\nLANGUAGE: typescript\nCODE:\n```\nclass Test {\n  name: string;\n}\n\nconst TestSchema = z.instanceof(Test);\n\nconst blob: any = \"whatever\";\nTestSchema.parse(new Test()); // 통과\nTestSchema.parse(blob); // 오류 발생\n```\n\n----------------------------------------\n\nTITLE: Accessing Enum Values in Zod\nDESCRIPTION: This code shows how to access the enum values in Zod using the `.enum` and `.options` properties. This allows you to access the enumeration elements programmatically.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nFishEnum.enum.Salmon; // => 自动补全\n\nFishEnum.enum;\n/*\n=> {\n  Salmon: \"Salmon\",\n  Tuna: \"Tuna\",\n  Trout: \"Trout\",\n}\n*/\n```\n\nLANGUAGE: typescript\nCODE:\n```\nFishEnum.options; // [\"Salmon\", \"Tuna\", \"Trout\"]);\n```\n\n----------------------------------------\n\nTITLE: Union Schema Definition in Zod\nDESCRIPTION: This code demonstrates how to create a union schema in Zod using both `z.union` and the `.or` method. A union schema allows a value to be one of several specified types. Zod tests the input against each option in order and returns the first successful validation.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringOrNumber = z.union([z.string(), z.number()]);\n\nstringOrNumber.parse(\"foo\"); // 通过\nstringOrNumber.parse(14); // 通过\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringOrNumber = z.string().or(z.number());\n```\n\n----------------------------------------\n\nTITLE: Enable Strict Mode in tsconfig.json (Zod)\nDESCRIPTION: This snippet demonstrates how to enable strict mode in your `tsconfig.json` file.  Zod requires strict mode to be enabled for proper type checking and validation.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  // ...\n  \"compilerOptions\": {\n    // ...\n    \"strict\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Zod Native Enum with String Enum\nDESCRIPTION: This code showcases using Zod's `z.nativeEnum()` to validate a string enum.  It also illustrates the usage of mixed string and numeric enum values.  It shows how parsing will accept string or numeric values for enum members, based on definition.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nenum Fruits {\n  Apple = \"apple\",\n  Banana = \"banana\",\n  Cantaloupe, // 숫자와 문자열 열거형을 혼합할 수 있음\n}\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // Fruits\n\nFruitEnum.parse(Fruits.Apple); // 통과\nFruitEnum.parse(Fruits.Cantaloupe); // 통과\nFruitEnum.parse(\"apple\"); // 통과\nFruitEnum.parse(\"banana\"); // 통과\nFruitEnum.parse(0); // 통과\nFruitEnum.parse(\"Cantaloupe\"); // 실패\n```\n\n----------------------------------------\n\nTITLE: Using `.catch` to provide a default value\nDESCRIPTION: Demonstrates how to use the `.catch()` method to provide a default value when parsing fails.  If the input is not a number, it will return 42.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_105\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberWithCatch = z.number().catch(42);\n\nnumberWithCatch.parse(5); // => 5\nnumberWithCatch.parse(\"tuna\"); // => 42\n```\n\n----------------------------------------\n\nTITLE: Date Validation in Zod\nDESCRIPTION: This code snippet demonstrates how to use the `z.string().date()` method to validate strings in the format `YYYY-MM-DD`. Added in Zod 3.23\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst date = z.string().date();\n\ndate.parse(\"2020-01-01\"); // pass\ndate.parse(\"2020-1-1\"); // fail\ndate.parse(\"2020-01-32\"); // fail\n```\n\n----------------------------------------\n\nTITLE: Combining Discriminated Unions in Zod\nDESCRIPTION: This code snippet illustrates how to combine two or more discriminated union schemas in Zod by expanding their `.options` properties. This allows you to create a new discriminated union that includes all the options from the original unions.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nconst A = z.discriminatedUnion(\"status\", [\n  /* options */\n]);\nconst B = z.discriminatedUnion(\"status\", [\n  /* options */\n]);\n\nconst AB = z.discriminatedUnion(\"status\", [...A.options, ...B.options]);\n```\n\n----------------------------------------\n\nTITLE: Validate Numbers with Zod\nDESCRIPTION: This snippet showcases various number validation methods provided by Zod, including `gt`, `gte`, `lt`, `lte`, `int`, `positive`, `nonnegative`, `negative`, `nonpositive`, `multipleOf`, `finite`, and `safe`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nz.number().gt(5);\nz.number().gte(5); // alias .min(5)\nz.number().lt(5);\nz.number().lte(5); // alias .max(5)\n\nz.number().int(); // value must be an integer\n\nz.number().positive(); //     > 0\nz.number().nonnegative(); //  >= 0\nz.number().negative(); //     < 0\nz.number().nonpositive(); //  <= 0\n\nz.number().multipleOf(5); // Evenly divisible by 5. Alias .step(5)\n\nz.number().finite(); // value must be finite, not Infinity or -Infinity\nz.number().safe(); // value must be between Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER\n```\n\n----------------------------------------\n\nTITLE: Zod Catch Method with Random Value TypeScript\nDESCRIPTION: This code demonstrates using the `catch` method with a function that returns a random number as the fallback value when parsing fails.  The function receives the error context.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_102\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberWithRandomCatch = z.number().catch((ctx) => {\n  ctx.error; // 발생한 ZodError\n  return Math.random();\n});\n\nnumberWithRandomCatch.parse(\"sup\"); // => 0.4413456736055323\nnumberWithRandomCatch.parse(\"sup\"); // => 0.1871840107401901\nnumberWithRandomCatch.parse(\"sup\"); // => 0.7223408162401552\n```\n\n----------------------------------------\n\nTITLE: Defining Discriminated Union Schema in Zod\nDESCRIPTION: Demonstrates how to use `z.discriminatedUnion` to define a union of object schemas that share a common discriminator key.  This allows Zod to efficiently determine which schema to use for parsing based on the value of the discriminator key.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_71\n\nLANGUAGE: typescript\nCODE:\n```\nconst myUnion = z.discriminatedUnion(\"status\", [\n  z.object({ status: z.literal(\"success\"), data: z.string() }),\n  z.object({ status: z.literal(\"failed\"), error: z.instanceof(Error) }),\n]);\n\nmyUnion.parse({ status: \"success\", data: \"yippie ki yay\" });\n```\n\n----------------------------------------\n\nTITLE: TypeScript Configuration\nDESCRIPTION: Enables strict mode in the tsconfig.json file. This is a recommended best practice when working with TypeScript projects as it enforces stricter type checking and helps catch potential errors early in the development process.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// tsconfig.json\n{\n  // ...\n  \"compilerOptions\": {\n    // ...\n    \"strict\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Zod Union Type Definition (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a union type using `z.union()`. It shows that the input value will be tested against each of the types in the order they are provided, and the first one to validate is accepted. The `.or` method is shown as an alternative.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringOrNumber = z.union([z.string(), z.number()]);\n\nstringOrNumber.parse(\"foo\"); // 통과\nstringOrNumber.parse(14); // 통과\n\nconst stringOrNumber = z.string().or(z.number());\n```\n\n----------------------------------------\n\nTITLE: Transforms and Refinements Interleaved\nDESCRIPTION: Illustrates how transforms and refinements can be combined and interleaved, executing in the order they are declared.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_93\n\nLANGUAGE: typescript\nCODE:\n```\nz.string()\n  .transform((val) => val.length)\n  .refine((val) => val > 25);\n```\n\n----------------------------------------\n\nTITLE: Zod Literal Types\nDESCRIPTION: Shows how to define Zod schemas that represent literal types, such as specific strings, numbers, bigints, booleans, and symbols. Also demonstrates accessing the literal value using the `value` property of the schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst tuna = z.literal(\"tuna\");\nconst twelve = z.literal(12);\nconst twobig = z.literal(2n); // bigint literal\nconst tru = z.literal(true);\n\nconst terrificSymbol = Symbol(\"terrific\");\nconst terrific = z.literal(terrificSymbol);\n\n// retrieve literal value\ntuna.value; // \"tuna\"\n```\n\n----------------------------------------\n\nTITLE: Pass Through Unknown Keys with Zod\nDESCRIPTION: This snippet demonstrates how to allow unknown keys in an object schema and pass them through during parsing using the `.passthrough()` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nperson.passthrough().parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => { name: \"bob dylan\", extraKey: 61 }\n```\n\n----------------------------------------\n\nTITLE: Promise Validation with Zod in TypeScript\nDESCRIPTION: This code snippet shows how to validate promises using Zod. It defines a schema for a promise that resolves to a number and demonstrates how `parse` checks for a Promise instance and then attaches validation to the promise. Error handling needs to be done with `.catch` on the promise returned by `parse`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_82\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberPromise = z.promise(z.number());\n```\n\nLANGUAGE: typescript\nCODE:\n```\nnumberPromise.parse(\"tuna\");\n// ZodError: Non-Promise type: string\n\nnumberPromise.parse(Promise.resolve(\"tuna\"));\n// => Promise<number>\n\nconst test = async () => {\n  await numberPromise.parse(Promise.resolve(\"tuna\"));\n  // ZodError: Non-number type: string\n\n  await numberPromise.parse(Promise.resolve(3.14));\n  // => 3.14\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Literal Schemas (TypeScript)\nDESCRIPTION: This snippet shows how to create literal schemas using Zod's `z.literal`. Literal schemas only allow specific literal values.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst tuna = z.literal(\"tuna\");\nconst twelve = z.literal(12);\nconst twobig = z.literal(2n); // bigint 리터럴\nconst tru = z.literal(true);\n\nconst terrificSymbol = Symbol(\"terrific\");\nconst terrific = z.literal(terrificSymbol);\n\n// 리터럴 값 가져오기\ntuna.value; // \"tuna\"\n```\n\n----------------------------------------\n\nTITLE: Getting Enum Options as Tuple with Zod\nDESCRIPTION: This snippet shows how to get a tuple of all the options in a Zod enum using the `.options` property.  This allows easy access to all possible values of the enum as an array.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nFishEnum.options; // [\"Salmon\", \"Tuna\", \"Trout\"];\n```\n\n----------------------------------------\n\nTITLE: Type Refinement with Super Refine\nDESCRIPTION: Shows using `.superRefine()` with a type predicate to narrow down the type of the input.  It adds a custom issue if the object is null and returns z.NEVER.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_96\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z\n  .object({\n    first: z.string(),\n    second: z.number(),\n  })\n  .nullable()\n  .superRefine((arg, ctx): arg is { first: string; second: number } => {\n    if (!arg) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom, // customize your issue\n        message: \"object should exist\",\n      });\n    }\n\n    return z.NEVER; // The return value is not used, but we need to return something to satisfy the typing\n  })\n  // here, TS knows that arg is not null\n  .refine((arg) => arg.first === \"bob\", \"`first` is not `bob`!\");\n```\n\n----------------------------------------\n\nTITLE: Super Refinement with Multiple Issues\nDESCRIPTION: Example using `.superRefine` to add multiple validation issues, specifically checking array length and for duplicate items.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_94\n\nLANGUAGE: typescript\nCODE:\n```\nconst Strings = z.array(z.string()).superRefine((val, ctx) => {\n  if (val.length > 3) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.too_big,\n      maximum: 3,\n      type: \"array\",\n      inclusive: true,\n      message: \"Too many items 😡\",\n    });\n  }\n\n  if (val.length !== new Set(val).size) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: `No duplicates allowed.`,\n    });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Coercing to String (TypeScript)\nDESCRIPTION: Shows how various primitive JavaScript types are coerced to strings using `z.coerce.string()`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nschema.parse(12); // => \"12\"\nschema.parse(true); // => \"true\"\nschema.parse(undefined); // => \"undefined\"\nschema.parse(null); // => \"null\"\n```\n\n----------------------------------------\n\nTITLE: Defining Set Schema in Zod\nDESCRIPTION: Demonstrates how to use `z.set` to define a schema for a Set object containing numbers. It also shows how to infer the TypeScript type from the schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberSet = z.set(z.number());\ntype NumberSet = z.infer<typeof numberSet>;\n// type NumberSet = Set<number>\n```\n\n----------------------------------------\n\nTITLE: Nullable Schema with Zod\nDESCRIPTION: This example shows how to use `.nullable()` to create a nullable version of a Zod schema. The resulting schema will accept either a string or null.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nconst nullableString = z.string().nullable(); // string | null\n\n// equivalent to\nz.nullable(z.string());\n```\n\n----------------------------------------\n\nTITLE: Customizing Boolean Schema Error Messages with Zod\nDESCRIPTION: This code demonstrates how to customize error messages when creating a boolean schema using Zod.  It defines custom messages for `required_error` and `invalid_type_error`.  The `isActive` constant represents the boolean schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nconst isActive = z.boolean({\n  required_error: \"isActive는 필수 항목입니다\",\n  invalid_type_error: \"isActive는 불리언 타입이어야 합니다\",\n});\n```\n\n----------------------------------------\n\nTITLE: Customize String Schema Error Messages (Zod)\nDESCRIPTION: This snippet shows how to customize error messages for a string schema in Zod.  You can provide custom messages for `required_error` and `invalid_type_error` when creating the schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst name = z.string({\n  required_error: \"Name is required\",\n  invalid_type_error: \"Name must be a string\",\n});\n```\n\n----------------------------------------\n\nTITLE: Date Validation with Zod\nDESCRIPTION: This snippet demonstrates how to validate `Date` instances and strings using Zod's `z.date()` schema. It uses `safeParse` to check if a given value is a valid date. Note that `safeParse` returns a result object with a `success` property.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nz.date().safeParse(new Date()); // 성공: true\nz.date().safeParse(\"2022-01-12T00:00:00.000Z\"); // 성공: false\n```\n\n----------------------------------------\n\nTITLE: ZodError Class Definition\nDESCRIPTION: This code snippet shows the structure of the ZodError class, which extends the standard Error class. It contains an array of ZodIssue objects, each representing a validation error.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nclass ZodError extends Error {\n  issues: ZodIssue[];\n}\n```\n\n----------------------------------------\n\nTITLE: Limiting Acceptable Inputs with ZodType Generics\nDESCRIPTION: Demonstrates how to limit the acceptable schema inputs to a function by constraining the generic parameter of `ZodType`. It shows how to restrict the function to only accept schemas that are of type `ZodType`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_121\n\nLANGUAGE: typescript\nCODE:\n```\nfunction makeSchemaOptional<T extends ZodType>(schema: T) {\n  return schema.optional();\n}\n\nmakeSchemaOptional(z.string());\n// 정상적으로 동작\n\nmakeSchemaOptional(z.number());\n// 오류: 'ZodNumber'는 'ZodType' 타입의 매개변수에 할당할 수 없음\n```\n\n----------------------------------------\n\nTITLE: Custom Schema Definition with Zod in TypeScript\nDESCRIPTION: Illustrates how to create custom schemas using `z.custom` to validate specific types, such as template literal types. It defines a schema that checks if a string matches the pattern of a pixel value (e.g., \"42px\"). This snippet demonstrates how to extend Zod's validation capabilities with custom validation logic.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_84\n\nLANGUAGE: typescript\nCODE:\n```\nconst px = z.custom((val) => {\n  return typeof val === \"string\" ? /^\\d+px$/.test(val) : false;\n});\n\ntype px = z.infer<typeof px>; // `${number}px`\n\npx.parse(\"42px\"); // \"42px\"\npx.parse(\"42vw\"); // 에러 발생\n```\n\nLANGUAGE: typescript\nCODE:\n```\nz.custom(); // 검증을 수행하지 않음\n```\n\nLANGUAGE: typescript\nCODE:\n```\nz.custom((val) => ..., \"커스텀 에러 메시지\");\n```\n\n----------------------------------------\n\nTITLE: Input/Output Type Inference with Zod\nDESCRIPTION: This example demonstrates how to use `z.input` and `z.output` to extract the input and output types of a Zod schema, respectively.  It is especially relevant when using transforms. The `z.infer` method returns the output type.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringToNumber = z.string().transform((val) => val.length);\n\n// ⚠️ Important: z.infer返回OUTPUT类型!\ntype input = z.input<stringToNumber>; // string\ntype output = z.output<stringToNumber>; // number\n\n// equivalent to z.output!\ntype inferred = z.infer<stringToNumber>; // number\n```\n\n----------------------------------------\n\nTITLE: Zod Array Element Schema Access (TypeScript)\nDESCRIPTION: This snippet demonstrates how to access the schema of an array's elements using the `.element` property. This allows you to work with the schema defining the type of the array's contents.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_65\n\nLANGUAGE: typescript\nCODE:\n```\nstringArray.element; // => string 스키마\n```\n\n----------------------------------------\n\nTITLE: Optional Zod String Schema TypeScript\nDESCRIPTION: This code demonstrates using the `optional` method to create an optional version of a Zod string schema. The resulting schema accepts either a string or `undefined`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_103\n\nLANGUAGE: typescript\nCODE:\n```\nconst optionalString = z.string().optional(); // string | undefined\n\n// 아래와 동일합니다\nz.optional(z.string());\n```\n\n----------------------------------------\n\nTITLE: Adding Description to Schema\nDESCRIPTION: Adds a description to a schema using the `.describe()` method, enabling documentation of the schema's purpose.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_104\n\nLANGUAGE: typescript\nCODE:\n```\nconst documentedString = z\n  .string()\n  .describe(\"A useful bit of text, if you know what to do with it.\");\ndocumentedString.description; // A useful bit of text…\n```\n\n----------------------------------------\n\nTITLE: Super Refine Abort Early\nDESCRIPTION: Demonstrates using the `fatal` flag in `ctx.addIssue` to abort early during super refinement if a specific condition is met.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_95\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.number().superRefine((val, ctx) => {\n  if (val < 10) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: \"should be >= 10\",\n      fatal: true,\n    });\n\n    return z.NEVER;\n  }\n\n  if (val !== 12) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: \"should be twelve\",\n    });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: IP Address Validation (TypeScript)\nDESCRIPTION: Demonstrates validating IP addresses using `z.string().ip()`, which accepts both IPv4 and IPv6 addresses by default.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst ip = z.string().ip();\n\nip.parse(\"192.168.1.1\"); // 통과\nip.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003\"); // 통과\nip.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:192.168.1.1\"); // 통과\n\nip.parse(\"256.1.1.1\"); // 실패\nip.parse(\"84d5:51a0:9114:gggg:4cfa:f2d7:1f12:7003\"); // 실패\n```\n\n----------------------------------------\n\nTITLE: Describing a Zod String Schema TypeScript\nDESCRIPTION: This code demonstrates using the `describe` method to add a description to a Zod string schema. This description can be used for documentation or other purposes.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_100\n\nLANGUAGE: typescript\nCODE:\n```\nconst documentedString = z\n  .string()\n  .describe(\"유용한 텍스트 조각입니다. 어떻게 사용할지 알고 있다면 말이죠.\");\ndocumentedString.description; // 유용한 텍스트 조각…\n```\n\n----------------------------------------\n\nTITLE: Tuple Schema Definition in Zod\nDESCRIPTION: This code demonstrates how to define tuple schemas in Zod using `z.tuple`. Tuples are similar to arrays but have a fixed number of elements, and each element can have a different type.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nconst athleteSchema = z.tuple([\n  z.string(), // name\n  z.number(), // jersey number\n  z.object({\n    pointsScored: z.number(),\n  }), // statistics\n]);\n\ntype Athlete = z.infer<typeof athleteSchema>;\n// type Athlete = [string, number, { pointsScored: number }]\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Zod Nullable Schema\nDESCRIPTION: Shows how to extract the wrapped schema from a `ZodNullable` instance using the `.unwrap()` method. This is equivalent to retrieving the original schema before making it nullable.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string();\nconst nullableString = stringSchema.nullable();\nnullableString.unwrap() === stringSchema; // true\n```\n\n----------------------------------------\n\nTITLE: SafeParseAsync Method Usage with Zod in TypeScript\nDESCRIPTION: Illustrates the usage of the `.safeParseAsync` (or `.spa`) method for asynchronous validation with safe parsing in Zod. It provides a convenient way to handle asynchronous validation without throwing errors, similar to `.safeParse`. The snippet demonstrates the asynchronous counterpart of `.safeParse`, allowing for explicit error handling in asynchronous contexts.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_88\n\nLANGUAGE: typescript\nCODE:\n```\nawait stringSchema.safeParseAsync(\"billie\");\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait stringSchema.spa(\"billie\");\n```\n\n----------------------------------------\n\nTITLE: Dynamic Default Value with Zod\nDESCRIPTION: This snippet demonstrates how to use a function within `.default` to generate a dynamic default value. The function, in this case `Math.random`, is called each time a default value is needed. This ensures different random numbers are returned on each call.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_68\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberWithRandomDefault = z.number().default(Math.random);\n\nnumberWithRandomDefault.parse(undefined); // => 0.4413456736055323\nnumberWithRandomDefault.parse(undefined); // => 0.1871840107401901\nnumberWithRandomDefault.parse(undefined); // => 0.7223408162401552\n```\n\n----------------------------------------\n\nTITLE: Date Validation with Minimum and Maximum Constraints in Zod\nDESCRIPTION: This snippet shows how to validate dates with minimum and maximum constraints using Zod. It defines minimum and maximum dates and provides custom error messages when the date is outside these bounds. The validation uses the `min` and `max` methods on the date schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nz.date().min(new Date(\"1900-01-01\"), { message: \"너무 오래된 날짜입니다\" });\nz.date().max(new Date(), { message: \"너무 미래의 날짜입니다!\" });\n```\n\n----------------------------------------\n\nTITLE: Creating a nullable schema with `.nullable`\nDESCRIPTION: Demonstrates how to create a nullable schema using the `.nullable()` method. The schema will accept either a string or null.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_108\n\nLANGUAGE: typescript\nCODE:\n```\nconst nullableString = z.string().nullable(); // string | null\n\n// equivalent to\nz.nullable(z.string());\n```\n\n----------------------------------------\n\nTITLE: Zod Strict Method (TypeScript)\nDESCRIPTION: This snippet demonstrates the `.strict()` method in Zod. This method enforces that no unrecognized keys are present in the input. If any unknown keys are found during parsing, Zod will throw an error, ensuring the input strictly conforms to the schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = z\n  .object({\n    name: z.string(),\n  })\n  .strict();\n\nperson.parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => ZodError 발생\n```\n\n----------------------------------------\n\nTITLE: Create and Parse a String Schema (Zod)\nDESCRIPTION: This snippet demonstrates creating a simple string schema using Zod. It shows how to parse a valid string and how to handle errors when parsing an invalid type. It also demonstrates the use of `safeParse` which returns a success/failure object instead of throwing.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\";\n\n// 创建一个字符串的模式\nconst mySchema = z.string();\n\n// 解析\nmySchema.parse(\"tuna\"); // => \"tuna\"\nmySchema.parse(12); // => throws ZodError\n\n// \"安全\"解析(如果验证失败不抛出错误)\nmySchema.safeParse(\"tuna\"); // => { success: true; data: \"tuna\" }\nmySchema.safeParse(12); // => { success: false; error: ZodError }\n```\n\n----------------------------------------\n\nTITLE: Zod Optional Schema\nDESCRIPTION: This snippet shows how to make a Zod schema optional using `z.optional()`. It demonstrates parsing an optional schema with `undefined` and infers the resulting type. Using `z.optional()` wraps the schema within a `ZodOptional` instance.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.optional(z.string());\n\nschema.parse(undefined); // => undefined 반환\ntype A = z.infer<typeof schema>; // string | undefined\n```\n\n----------------------------------------\n\nTITLE: Customizing NaN Schema Error Messages in Zod\nDESCRIPTION: This code snippet shows how to customize error messages when creating a NaN schema in Zod. It demonstrates how to specify `required_error` and `invalid_type_error` options.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst isNaN = z.nan({\n  required_error: \"isNaN is required\",\n  invalid_type_error: \"isNaN must be 'not a number'\",\n});\n```\n\n----------------------------------------\n\nTITLE: Formatting Zod Errors\nDESCRIPTION: Demonstrates how to format Zod errors into a nested object structure using the `.format()` method. It shows how to access the error messages for specific fields in the object.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_123\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = z\n  .object({\n    name: z.string(),\n  })\n  .safeParse({ name: 12 });\n\nif (!result.success) {\n  const formatted = result.error.format();\n  /* {\n    name: { _errors: [ '문자열이어야 하는데, 숫자가 입력되었습니다' ] }\n  } */\n\n  formatted.name?._errors;\n  // => [\"문자열이어야 하는데, 숫자가 입력되었습니다\"]\n}\n```\n\n----------------------------------------\n\nTITLE: BigInt Validation with Zod\nDESCRIPTION: This snippet demonstrates several validation methods for BigInt types in Zod, including greater than, greater than or equal to, less than, less than or equal to, positive, non-negative, negative, non-positive, and multiple of. Each validation method checks if a BigInt satisfies a specific condition.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nz.bigint().gt(5n); // 5n보다 큰지 확인\nz.bigint().gte(5n); // 5n보다 크거나 같은지 확인 (`.min(5n)`과 동일)\nz.bigint().lt(5n); // 5n보다 작은지 확인\nz.bigint().lte(5n); // 5n보다 작거나 같은지 확인 (`.max(5n)`과 동일)\n\nz.bigint().positive(); // 0n보다 큰지 확인\nz.bigint().nonnegative(); // 0n보다 크거나 같은지 확인\nz.bigint().negative(); // 0n보다 작은지 확인\nz.bigint().nonpositive(); // 0n보다 작거나 같은지 확인\n\nz.bigint().multipleOf(5n); // 5n으로 나누어 떨어지는지 확인\n```\n\n----------------------------------------\n\nTITLE: Customizing String Schema Error Messages in Zod\nDESCRIPTION: This code snippet shows how to customize error messages when creating a string schema in Zod. It demonstrates how to specify `required_error` and `invalid_type_error` options to provide more informative error messages to the user.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst name = z.string({\n  required_error: \"Name is required\",\n  invalid_type_error: \"Name must be a string\",\n});\n```\n\n----------------------------------------\n\nTITLE: Making Specific Properties Optional with .partial in Zod\nDESCRIPTION: This snippet demonstrates how to make specific properties optional in a Zod object schema using the `.partial()` method with a configuration object. Only the specified properties will become optional while others will remain required. Here, only `email` is becoming optional.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nconst optionalEmail = user.partial({\n  email: true,\n});\n/*\n{\n  email?: string | undefined;\n  username: string\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Customizing Date Schema Error Messages with Zod\nDESCRIPTION: This code shows how to customize error messages for a date schema in Zod, defining messages for when a date is required and when the format is invalid. The `myDateSchema` constant represents the Zod date schema with custom error messages.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nconst myDateSchema = z.date({\n  required_error: \"날짜와 시간을 선택해 주세요\",\n  invalid_type_error: \"날짜 형식이 아닙니다!\",\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a ZodError Instance\nDESCRIPTION: This example demonstrates how to create a new instance of the ZodError class. It imports the Zod library and initializes a ZodError with an empty array of issues.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as z from \"zod\";\n\nconst myError = new z.ZodError([]);\n```\n\n----------------------------------------\n\nTITLE: Interleaving Transformations and Refinements in Zod (TypeScript)\nDESCRIPTION: This example showcases how to interleave transformations and refinements in Zod using the `.transform()` and `.refine()` methods. It demonstrates that transformations and refinements can be chained and executed in any order, which provides flexibility in data processing and validation. The example transforms a string to its length, refines it based on a minimum length, and then transforms the length by multiplying it by 2.\nSOURCE: https://github.com/colinhacks/zod/blob/main/MIGRATION.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst test = z\n  .string()\n  .transform((val) => val.length)\n  .refine((val) => val > 5, { message: \"Input is too short\" })\n  .transform((val) => val * 2);\n\ntest.parse(\"12characters\"); // => 24\n```\n\n----------------------------------------\n\nTITLE: Define Object Schema with Zod\nDESCRIPTION: This snippet defines an object schema `Dog` with `name` (string) and `age` (number) properties. All properties are required by default. The snippet also shows how to extract the TypeScript type definition from the Zod schema using `z.infer`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n// 所有属性都是默认需要的\nconst Dog = z.object({\n  name: z.string(),\n  age: z.number(),\n});\n\n// 像这样提取推断出的类型\ntype Dog = z.infer<typeof Dog>;\n\n// 相当于:\ntype Dog = {\n  name: string;\n  age: number;\n};\n```\n\n----------------------------------------\n\nTITLE: Super Refining Schemas with Zod\nDESCRIPTION: This example shows how to use `.superRefine` for more complex validation scenarios. It allows adding multiple issues to the validation context with different error codes, enabling fine-grained control over error reporting.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nconst Strings = z.array(z.string()).superRefine((val, ctx) => {\n  if (val.length > 3) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.too_big,\n      maximum: 3,\n      type: \"array\",\n      inclusive: true,\n      message: \"Too many items 😡\",\n    });\n  }\n\n  if (val.length !== new Set(val).size) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: `No duplicated allowed.`,\n    });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a nullish schema with `.nullish`\nDESCRIPTION: Explains how to create a \"nullish\" schema using the `.nullish()` method. Nullish schemas accept both undefined and null.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_109\n\nLANGUAGE: typescript\nCODE:\n```\nconst nullishString = z.string().nullish(); // string | null | undefined\n\n// equivalent to\nz.string().nullable().optional();\n```\n\n----------------------------------------\n\nTITLE: Installing Zod via npm\nDESCRIPTION: Commands for installing Zod using various package managers. Includes options for installing the stable version as well as the canary version. Different package managers are covered, including npm, deno, yarn, bun and pnpm.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install zod       # npm\ndeno add npm:zod      # deno\nyarn add zod          # yarn\nbun add zod           # bun\npnpm add zod          # pnpm\n```\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install zod@canary       # npm\ndeno add npm:zod@canary      # deno\nyarn add zod@canary          # yarn\nbun add zod@canary           # bun\npnpm add zod@canary          # pnpm\n```\n\n----------------------------------------\n\nTITLE: Set Schema Definition in Zod\nDESCRIPTION: This code demonstrates how to create a Set schema in Zod using `z.set`. This schema is used to validate JavaScript Set objects. The example creates a Set of numbers.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberSet = z.set(z.number());\ntype numberSet = z.infer<typeof numberSet>;\n// Set<number>\n```\n\n----------------------------------------\n\nTITLE: Invalid Zod Enum Definition\nDESCRIPTION: Illustrates an invalid attempt to define a Zod enum directly from a non-constant array, which prevents Zod from inferring the exact values of each element, leading to potential type safety issues.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nconst fish = [\"Salmon\", \"Tuna\", \"Trout\"];\nconst FishEnum = z.enum(fish);\n```\n\n----------------------------------------\n\nTITLE: ZodType with ZodEffects in TypeScript\nDESCRIPTION: This snippet shows how to define input and output types of a Zod schema when using ZodEffects. It defines a base schema with an ID validation and then extends it to include a recursive children array, demonstrating the usage of z.ZodType, z.ZodEffects, and z.lazy for handling recursive structures. The isValidId function is used for validating the ID format.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_80\n\nLANGUAGE: typescript\nCODE:\n```\nconst isValidId = (id: string): id is `${string}/${string}` =>\n  id.split(\"/\").length === 2;\n\nconst baseSchema = z.object({\n  id: z.string().refine(isValidId),\n});\n\ntype Input = z.input<typeof baseSchema> & {\n  children: Input[];\n};\n\ntype Output = z.output<typeof baseSchema> & {\n  children: Output[];\n};\n\nconst schema: z.ZodType<Output, z.ZodTypeDef, Input> = baseSchema.extend({\n  children: z.lazy(() => schema.array()),\n});\n```\n\n----------------------------------------\n\nTITLE: Zod Nonempty Array Validation (TypeScript)\nDESCRIPTION: This snippet shows how to ensure an array contains at least one element using `.nonempty()`.  It includes examples of both the basic usage and how to provide a custom error message if the array is empty. The inferred type is also shown.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_66\n\nLANGUAGE: typescript\nCODE:\n```\nconst nonEmptyStrings = z.string().array().nonempty();\n// 추론된 타입은 이제 다음과 같습니다.\n// [string, ...string[]]\n\nnonEmptyStrings.parse([]); // 오류 발생: \"배열이 비어 있을 수 없습니다\"\nnonEmptyStrings.parse([\"Ariana Grande\"]); // 통과\n\n// 커스텀 오류 메시지 지정\nconst nonEmptyStrings = z.string().array().nonempty({\n  message: \"비어 있을 수 없습니다!\",\n});\n```\n\n----------------------------------------\n\nTITLE: SuperRefine with Early Termination in Zod TypeScript\nDESCRIPTION: This code demonstrates using `superRefine` to add custom validation logic to a Zod number schema with early termination. If the number is less than 10, it adds an issue to the context and returns `z.NEVER`, preventing further validation.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_91\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.number().superRefine((val, ctx) => {\n  if (val < 10) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: \"10 이상이어야 합니다\",\n      fatal: true,\n    });\n\n    return z.NEVER;\n  }\n\n  if (val !== 12) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: \"12여야 합니다\",\n    });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Constraining Set Size in Zod\nDESCRIPTION: Demonstrates how to use `.nonempty()`, `.min()`, `.max()`, and `.size()` methods to constrain the size of a Zod Set schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nz.set(z.string()).nonempty(); // must contain at least one item\nz.set(z.string()).min(5); // must contain 5 or more items\nz.set(z.string()).max(5); // must contain 5 or fewer items\nz.set(z.string()).size(5); // must contain 5 items exactly\n```\n\n----------------------------------------\n\nTITLE: Union with Or (Zod)\nDESCRIPTION: This snippet illustrates how the `.or` method now returns a nested union instead of flattening the union. This change was implemented to address recursion limitations in TypeScript.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CHANGELOG.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nz.union([z.string(), z.number()]).or(z.boolean());\n// previously\n// => ZodUnion<[ZodString, ZodNumber, ZodBoolean]>\n\n// now\n// => ZodUnion<[ZodUnion<[ZodString, ZodNumber]>, ZodBoolean]>\n```\n\n----------------------------------------\n\nTITLE: Zod Map Schema Definition (TypeScript)\nDESCRIPTION: This snippet demonstrates the use of Zod to define a schema for a JavaScript `Map` where the keys are strings and the values are numbers. It also shows how to infer the TypeScript type of the `Map` from the schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringNumberMap = z.map(z.string(), z.number());\n\ntype StringNumberMap = z.infer<typeof stringNumberMap>;\n// type StringNumberMap = Map<string, number>\n```\n\n----------------------------------------\n\nTITLE: Zod Set Schema Definition (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a Zod schema for a JavaScript `Set` containing numbers. The inferred TypeScript type for the Set is also shown. Additionally, it shows how to apply constraints such as `nonempty`, `min`, `max`, and `size` to a set schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberSet = z.set(z.number());\ntype NumberSet = z.infer<typeof numberSet>;\n// type NumberSet = Set<number>\n\nz.set(z.string()).nonempty(); // 최소 하나 이상의 항목을 포함해야 함\nz.set(z.string()).min(5); // 5개 이상의 항목을 포함해야 함\nz.set(z.string()).max(5); // 5개 이하의 항목을 포함해야 함\nz.set(z.string()).size(5); // 정확히 5개의 항목을 포함해야 함\n```\n\n----------------------------------------\n\nTITLE: Transformer Implementation in Zod (TypeScript)\nDESCRIPTION: This code snippet shows the current way to implement transformations in Zod using the `.transform()` method directly on Zod schemas. It demonstrates how to apply transformations to Zod schemas, replacing the deprecated `z.transformer` syntax. The example transforms a string to its length.\nSOURCE: https://github.com/colinhacks/zod/blob/main/MIGRATION.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nz.string().transform((val) => val.length);\n```\n\n----------------------------------------\n\nTITLE: Record Schema Definition in Zod\nDESCRIPTION: This code demonstrates how to create a record schema in Zod using `z.record`. A record schema is used to validate objects with string keys and values of a specific type, such as `{ [k: string]: number }`. This is especially useful for scenarios involving data storage or caching by ID.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nconst NumberCache = z.record(z.number());\n\ntype NumberCache = z.infer<typeof NumberCache>;\n// => { [k: string]: number }\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst userSchema = z.object({ name: z.string() });\nconst userStoreSchema = z.record(userSchema);\n\ntype UserStore = z.infer<typeof userStoreSchema>;\n// => type UserStore = { [ x: string ]: { name: string } }\n\nconst userStore: UserStore = {};\n\nuserStore[\"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\"] = {\n  name: \"Carlotta\",\n}; // passes\n\nuserStore[\"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\"] = {\n  whatever: \"Ice cream sundae\",\n}; // TypeError\n```\n\n----------------------------------------\n\nTITLE: Zod Native Enum with Numeric Enum\nDESCRIPTION: This snippet demonstrates how to use Zod's `z.nativeEnum()` with a numeric enum. It shows how to parse enum values, including the numeric representations, using the generated Zod schema. This validates that the input is a valid value from the original enum.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nenum Fruits {\n  Apple,\n  Banana,\n}\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // Fruits\n\nFruitEnum.parse(Fruits.Apple); // 통과\nFruitEnum.parse(Fruits.Banana); // 통과\nFruitEnum.parse(0); // 통과\nFruitEnum.parse(1); // 통과\nFruitEnum.parse(3); // 실패\n```\n\n----------------------------------------\n\nTITLE: Date Validation in Zod\nDESCRIPTION: This code snippet demonstrates basic date validation using Zod. It shows how to validate `Date` instances and demonstrates that strings are not considered valid dates unless coercion is used.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nz.date().safeParse(new Date()); // success: true\nz.date().safeParse(\"2022-01-12T00:00:00.000Z\"); // success: false\n```\n\n----------------------------------------\n\nTITLE: Coercing Dates with Input Restriction\nDESCRIPTION: Shows how to restrict input types before coercion.  It utilizes `z.union` to allow only numbers, strings, and dates, leading to more controlled and predictable coercion behavior, especially when dealing with potentially invalid inputs like `null`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_114\n\nLANGUAGE: typescript\nCODE:\n```\nconst datelike = z.union([z.number(), z.string(), z.date()]);\nconst datelikeToDate = datelike.pipe(z.coerce.date());\n\n// 여전히 직관적으로 동작\nconsole.log(datelikeToDate.safeParse(\"2023-01-01\").success); // true\n\n// 더 원하는 결과를 얻을 수 있음\nconsole.log(datelikeToDate.safeParse(null).success); // false\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Nullable Schema in Zod\nDESCRIPTION: This snippet shows how to use the `.unwrap()` method to retrieve the underlying schema of a nullable schema.  This is useful for accessing the core schema without the nullable wrapper.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string();\nconst nullableString = stringSchema.nullable();\nnullableString.unwrap() === stringSchema; // true\n```\n\n----------------------------------------\n\nTITLE: Date Coercion in Zod (z.coerce.date())\nDESCRIPTION: This code snippet demonstrates how to coerce input values to Date objects using `z.coerce.date()` in Zod (since version 3.20). It shows that strings and other date-compatible inputs can be parsed successfully.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nconst dateSchema = z.coerce.date();\ntype DateSchema = z.infer<typeof dateSchema>;\n// type DateSchema = Date\n\n/* valid dates */\nconsole.log(dateSchema.safeParse(\"2023-01-10T00:00:00.000Z\").success); // true\nconsole.log(dateSchema.safeParse(\"2023-01-10\").success); // true\nconsole.log(dateSchema.safeParse(\"1/10/23\").success); // true\nconsole.log(dateSchema.safeParse(new Date(\"1/10/23\")).success); // true\n\n/* invalid dates */\nconsole.log(dateSchema.safeParse(\"2023-13-10\").success); // false\nconsole.log(dateSchema.safeParse(\"0000-00-00\").success); // false\n```\n\n----------------------------------------\n\nTITLE: Instanceof Validation with Zod in TypeScript\nDESCRIPTION: This snippet demonstrates how to use `z.instanceof` to validate if an input is an instance of a class.  It defines a simple class `Test` and then creates a Zod schema to check for instances of that class. The `parse` method will throw an error if the input is not an instance of `Test`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_83\n\nLANGUAGE: typescript\nCODE:\n```\nclass Test {\n  name: string;\n}\n\nconst TestSchema = z.instanceof(Test);\n\nconst blob: any = \"whatever\";\nTestSchema.parse(new Test()); // passes\nTestSchema.parse(blob); // throws\n```\n\n----------------------------------------\n\nTITLE: Type Refinement with superRefine in Zod TypeScript\nDESCRIPTION: This code demonstrates using `superRefine` with a type predicate to narrow the type of the validated value. It checks if the input is not null and refines the type if it is an object with `first` (string) and `second` (number) properties.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_92\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z\n  .object({\n    first: z.string(),\n    second: z.number(),\n  })\n  .nullable()\n  .superRefine((arg, ctx): arg is { first: string; second: number } => {\n    if (!arg) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom, // 이슈 커스터마이징\n        message: \"객체가 존재해야 합니다.\",\n      });\n    }\n\n    return z.NEVER; // 반환값은 사용되지 않지만, 타입을 만족시키기 위해 반환해야 함\n  })\n  // 여기서 TS는 arg가 null이 아니라는 것을 알고 있음\n  .refine((arg) => arg.first === \"bob\", \"`first`가 `bob`이 아닙니다!\");\n```\n\n----------------------------------------\n\nTITLE: Error Formatting with Zod\nDESCRIPTION: This example shows how to format errors using the `.format()` method. The method converts the error structure into a nested object where each field contains an array of errors.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\ndata.error.format();\n/* {\n  name: { _errors: [ 'Expected string, received number' ] }\n} */\n```\n\n----------------------------------------\n\nTITLE: Merge Object Schemas with Zod\nDESCRIPTION: This snippet shows how to merge two object schemas using the `.merge` method, where properties from the second schema override those from the first if there are conflicts.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst BaseTeacher = z.object({ students: z.array(z.string()) });\nconst HasID = z.object({ id: z.string() });\n\nconst Teacher = BaseTeacher.merge(HasID);\ntype Teacher = z.infer<typeof Teacher>; // => { students: string[], id: string }\n```\n\n----------------------------------------\n\nTITLE: Custom Schema Creation with Zod in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a custom Zod schema using `z.custom`. This is useful for creating schemas for types not directly supported by Zod, such as template string literals. The example shows how to validate a string that matches a specific pattern (e.g., a CSS pixel value).\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_86\n\nLANGUAGE: typescript\nCODE:\n```\nconst px = z.custom<`${number}px`>((val) => {\n  return typeof val === \"string\" ? /^\\d+px$/.test(val) : false;\n});\n\ntype px = z.infer<typeof px>; // `${number}px`\n\npx.parse(\"42px\"); // \"42px\"\npx.parse(\"42vw\"); // throws;\n```\n\nLANGUAGE: typescript\nCODE:\n```\nz.custom<{ arg: string }>(); // performs no validation\n```\n\nLANGUAGE: typescript\nCODE:\n```\nz.custom<...>((val) => ..., \"custom error message\");\n```\n\n----------------------------------------\n\nTITLE: Coerce All Primitive Types (Zod)\nDESCRIPTION: This snippet displays how to coerce all primitive types: string, number, boolean, bigint, and date, using the z.coerce method in Zod.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nz.coerce.string(); // String(input)\nz.coerce.number(); // Number(input)\nz.coerce.boolean(); // Boolean(input)\nz.coerce.bigint(); // BigInt(input)\nz.coerce.date(); // new Date(input)\n```\n\n----------------------------------------\n\nTITLE: Omit Object Keys with Zod\nDESCRIPTION: This snippet demonstrates how to omit specific keys from an object schema to create a new schema using the `.omit` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst NoIDRecipe = Recipe.omit({ id: true });\n\ntype NoIDRecipe = z.infer<typeof NoIDRecipe>;\n// => { name: string, ingredients: string[] }\n```\n\n----------------------------------------\n\nTITLE: Custom Error Messages for Number Validations in Zod\nDESCRIPTION: This code snippet demonstrates how to provide custom error messages for specific number validation methods in Zod. It shows how to pass a `message` option to methods like `lte` to customize the error message when validation fails.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nz.number().lte(5, { message: \"this👏is👏too👏big\" });\n```\n\n----------------------------------------\n\nTITLE: Formatting Zod Errors for Form Display in TypeScript\nDESCRIPTION: This snippet demonstrates using the `.format()` method on a ZodError to create a nested object structure representing the error. This structure is then displayed as a nested object to the console.  The structure is designed for displaying errors in forms.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nif (!result.success) {\n  console.log(result.error.format());\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Zod Enum from Object Keys\nDESCRIPTION: Shows how to create a `ZodEnum` schema from the keys of an object schema using the `.keyof()` method. The resulting enum contains the keys of the object.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nconst keySchema = Dog.keyof();\nkeySchema; // ZodEnum<[\"name\", \"age\"]>\n```\n\n----------------------------------------\n\nTITLE: Array Schema with Zod\nDESCRIPTION: This code shows how to create an array schema using `.array()` in Zod.  The resulting schema expects an array of strings.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\nconst nullableString = z.string().array(); // string[]\n\n// equivalent to\nz.array(z.string());\n```\n\n----------------------------------------\n\nTITLE: Zod Optional URL Validation (TypeScript)\nDESCRIPTION: This example shows how to validate an optional form input that must contain either a valid URL or an empty string.  It uses a union of a string URL schema and a literal empty string.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_71\n\nLANGUAGE: typescript\nCODE:\n```\nconst optionalUrl = z.union([z.string().url().nullish(), z.literal(\"\")]);\n\nconsole.log(optionalUrl.safeParse(undefined).success); // true\nconsole.log(optionalUrl.safeParse(null).success); // true\nconsole.log(optionalUrl.safeParse(\"\").success); // true\nconsole.log(optionalUrl.safeParse(\"https://zod.dev\").success); // true\nconsole.log(optionalUrl.safeParse(\"not a valid url\").success); // false\n```\n\n----------------------------------------\n\nTITLE: Picking Properties from Object Schema with .pick in Zod\nDESCRIPTION: This snippet demonstrates how to pick specific properties from a Zod object schema using the `.pick()` method. The new schema will only contain the properties specified in the argument. Here, only the `name` property is picked from the `Recipe` schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nconst Recipe = z.object({\n  id: z.string(),\n  name: z.string(),\n  ingredients: z.array(z.string()),\n});\n\nconst JustTheName = Recipe.pick({ name: true });\ntype JustTheName = z.infer<typeof JustTheName>;\n// => { name: string }\n```\n\n----------------------------------------\n\nTITLE: Zod Array Length Validation (TypeScript)\nDESCRIPTION: This snippet demonstrates how to specify minimum, maximum, or exact length constraints for an array using `.min()`, `.max()`, and `.length()`. Unlike `.nonempty()`, these methods do not affect type inference.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_67\n\nLANGUAGE: typescript\nCODE:\n```\nz.string().array().min(5); // 배열은 5개 이상의 항목을 포함해야 함\nz.string().array().max(5); // 배열은 5개 이하의 항목을 포함해야 함\nz.string().array().length(5); // 배열은 정확히 5개의 항목을 포함해야 함\n```\n\n----------------------------------------\n\nTITLE: BigInt Validations in Zod\nDESCRIPTION: This code snippet demonstrates various bigint validation methods available in Zod, such as `gt`, `gte`, `lt`, `lte`, `positive`, `negative`, and `multipleOf`. It shows how to use these methods to create bigint validation schemas.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nz.bigint().gt(5n);\nz.bigint().gte(5n); // alias `.min(5n)`\nz.bigint().lt(5n);\nz.bigint().lte(5n); // alias `.max(5n)`\n\nz.bigint().positive(); // > 0n\nz.bigint().nonnegative(); // >= 0n\nz.bigint().negative(); // < 0n\nz.bigint().nonpositive(); // <= 0n\n\nz.bigint().multipleOf(5n); // Evenly divisible by 5n.\n```\n\n----------------------------------------\n\nTITLE: Number Validations in Zod\nDESCRIPTION: This code snippet demonstrates various number validation methods available in Zod, such as `gt`, `gte`, `lt`, `lte`, `int`, `positive`, `negative`, `multipleOf`, `finite`, and `safe`. It shows how to use these methods to create number validation schemas.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nz.number().gt(5);\nz.number().gte(5); // alias .min(5)\nz.number().lt(5);\nz.number().lte(5); // alias .max(5)\n\nz.number().int(); // value must be an integer\n\nz.number().positive(); //     > 0\nz.number().nonnegative(); //  >= 0\nz.number().negative(); //     < 0\nz.number().nonpositive(); //  <= 0\n\nz.number().multipleOf(5); // Evenly divisible by 5. Alias .step(5)\n\nz.number().finite(); // value must be finite, not Infinity or -Infinity\nz.number().safe(); // value must be between Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER\n```\n\n----------------------------------------\n\nTITLE: IP Address Validation with Version in Zod\nDESCRIPTION: This code snippet demonstrates how to specify the IP version (IPv4 or IPv6) for validation using Zod's `z.string().ip()` method. It shows how to create separate schemas for IPv4 and IPv6 addresses.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst ipv4 = z.string().ip({ version: \"v4\" });\nipv4.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003\"); // fail\n\nconst ipv6 = z.string().ip({ version: \"v6\" });\nipv6.parse(\"192.168.1.1\"); // fail\n```\n\n----------------------------------------\n\nTITLE: Transforming Data with Zod\nDESCRIPTION: This example demonstrates using the `.transform` method to transform data after parsing. It shows how to define a transformation function that converts a string to a number representing its length. The example also highlights the importance of chaining order and the relationship between transforms and refinements.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_65\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringToNumber = z.string().transform((val) => myString.length);\nstringToNumber.parse(\"string\"); // => 6\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst emailToDomain = z\n  .string()\n  .email()\n  .transform((val) => val.split(\"@\")[1]);\n\nemailToDomain.parse(\"colinhacks@example.com\"); // => example.com\n```\n\nLANGUAGE: typescript\nCODE:\n```\nz.string()\n  .transform((val) => val.length)\n  .refine((val) => val > 25);\n```\n\n----------------------------------------\n\nTITLE: Defining Variadic Tuple Schema in Zod\nDESCRIPTION: Shows how to use the `.rest()` method to create a tuple with a variable number of elements of a specific type after the initial elements.  The example creates a tuple that starts with a string and then has any number of numbers.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_68\n\nLANGUAGE: typescript\nCODE:\n```\nconst variadicTuple = z.tuple([z.string()]).rest(z.number());\nconst result = variadicTuple.parse([\"hello\", 1, 2, 3]);\n// => [string, ...number[]];\n```\n\n----------------------------------------\n\nTITLE: Running Yarn\nDESCRIPTION: This snippet shows how to install the dependencies for the project by running `yarn`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Creating Enum from Object Keys with .keyof\nDESCRIPTION: This snippet shows how to create a `ZodEnum` schema from the keys of a Zod object schema using the `.keyof()` method. This allows you to validate strings against the keys of the object. The resulting `keySchema` will only accept the string 'name' or 'age'.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nconst keySchema = Dog.keyof();\nkeySchema; // ZodEnum\n```\n\n----------------------------------------\n\nTITLE: Defining Primitive Types with Zod (TypeScript)\nDESCRIPTION: This snippet shows how to define schemas for various primitive types using Zod, including string, number, boolean, date, symbol, undefined, null, void, any, unknown, and never.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\";\n\n// 기본 값\nz.string();\nz.number();\nz.bigint();\nz.boolean();\nz.date();\nz.symbol();\n\n// 빈 타입\nz.undefined();\nz.null();\nz.void(); // undefined를 허용\n\n// 모든 타입 허용\n// 어떤 값이든 허용\nz.any();\nz.unknown();\n\n// never 타입\n// 어떤 값도 허용하지 않음\nz.never();\n```\n\n----------------------------------------\n\nTITLE: Zod Object Required Transformation (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the `.required()` method in Zod to make all or specific properties of an object schema required. It starts with a partial object and transforms it into a required one, showing both the complete object and a specific property becoming required.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = z\n  .object({\n    email: z.string(),\n    username: z.string(),\n  })\n  .partial();\n// { email?: string | undefined; username?: string | undefined }\n\nconst requiredUser = user.required();\n// { email: string; username: string }\n\nconst requiredEmail = user.required({\n  email: true,\n});\n/*\n{\n  email: string;\n  username?: string | undefined;\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Coercing BigInts with Input Restriction\nDESCRIPTION: Demonstrates how to safely coerce to `bigint` by restricting input types using `z.number().or(z.string())` and `pipe()`. It shows how this prevents uncaught errors and provides more predictable behavior when dealing with potentially invalid inputs like `null`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_116\n\nLANGUAGE: typescript\nCODE:\n```\nconst toNumber = z.number().or(z.string()).pipe(z.coerce.number());\nconst toBigInt = z.bigint().or(toNumber).pipe(z.coerce.bigint());\n\n// 여전히 직관적으로 동작\nconsole.log(toBigInt.safeParse(\"42\").success); // true\n\n// Zod가 오류를 처리하며, 더 원하는 결과를 얻을 수 있음\nconsole.log(toBigInt.safeParse(null).success); // false\n```\n\n----------------------------------------\n\nTITLE: Custom Error Map in Schemas (Zod)\nDESCRIPTION: This snippet showcases how to pass a custom error map explicitly to a Zod schema.  This allows for centralized management and reuse of error messages across multiple schemas.  The `errorMap` option takes a custom error map function as its value.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CHANGELOG.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst name = z.string({ errorMap: myErrorMap });\n```\n\n----------------------------------------\n\nTITLE: Custom Refine Params Function\nDESCRIPTION: Demonstrates using a function to return `RefineParams`, enabling dynamic error message generation based on the input value.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_90\n\nLANGUAGE: typescript\nCODE:\n```\nconst longString = z.string().refine(\n  (val) => val.length > 10,\n  (val) => ({ message: `${val} is not more than 10 characters` })\n);\n```\n\n----------------------------------------\n\nTITLE: Coerce Primitive Types with Zod\nDESCRIPTION: This snippet demonstrates how to coerce primitive types using `z.coerce`. It shows how to convert a string, number, or boolean to the corresponding type during parsing using JavaScript's built-in coercion functions.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.coerce.string();\nschema.parse(\"tuna\"); // => \"tuna\"\nschema.parse(12); // => \"12\"\nschema.parse(true); // => \"true\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Options and Merging Discriminated Unions in Zod\nDESCRIPTION: Shows how to access the array of schemas in a discriminated union using the `.options` property, and how to merge two or more discriminated unions using destructuring with `.options`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\nmyUnion.options; // [ZodObject<...>, ZodObject<...>]\n\nconst A = z.discriminatedUnion(\"status\", [\n  /* options */\n]);\nconst B = z.discriminatedUnion(\"status\", [\n  /* options */\n]);\n\nconst AB = z.discriminatedUnion(\"status\", [...A.options, ...B.options]);\n```\n\n----------------------------------------\n\nTITLE: Writing generic functions with Zod schemas\nDESCRIPTION: Explains how to write generic functions that accept Zod schemas as parameters, highlighting the use of `z.ZodTypeAny` to avoid losing type information. Includes instructions on how to properly infer schema types when using generic schema inputs.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_118\n\nLANGUAGE: typescript\nCODE:\n```\nfunction inferSchema<T>(schema: z.ZodType<T>) {\n  return schema;\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninferSchema(z.string());\n// => ZodType<string>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfunction inferSchema<T extends z.ZodTypeAny>(schema: T) {\n  return schema;\n}\n\ninferSchema(z.string());\n// => ZodString\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfunction parseData<T extends z.ZodTypeAny>(data: unknown, schema: T) {\n  return schema.parse(data);\n}\n\nparseData(\"sup\", z.string());\n// => any\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfunction parseData<T extends z.ZodTypeAny>(data: unknown, schema: T) {\n  return schema.parse(data) as z.infer<T>;\n  //                        ^^^^^^^^^^^^^^ <- add this\n}\n\nparseData(\"sup\", z.string());\n// => string\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfunction makeSchemaOptional<T extends z.ZodType<string>>(schema: T) {\n  return schema.optional();\n}\n\nmakeSchemaOptional(z.string());\n// works fine\n\nmakeSchemaOptional(z.number());\n// Error: 'ZodNumber' is not assignable to parameter of type 'ZodType<string, ZodTypeDef, string>'\n```\n\n----------------------------------------\n\nTITLE: Checking Instanceof with Zod\nDESCRIPTION: This example demonstrates how to use `z.instanceof` to check if an input is an instance of a specific class. It defines a `Test` class and uses `z.instanceof(Test)` to create a schema that validates whether the input is an instance of that class.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nclass Test {\n  name: string;\n}\n\nconst TestSchema = z.instanceof(Test);\n\nconst blob: any = \"whatever\";\nTestSchema.parse(new Test()); // passes\nTestSchema.parse(blob); // throws\n```\n\n----------------------------------------\n\nTITLE: io-ts Object Definition\nDESCRIPTION: This code demonstrates how to define an object with required and optional properties using `io-ts`.  It requires using `t.type` for required fields, `t.partial` for optional fields, and `t.intersection` to combine them.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as t from \"io-ts\";\n\nconst A = t.type({\n  foo: t.string,\n});\n\nconst B = t.partial({\n  bar: t.number,\n});\n\nconst C = t.intersection([A, B]);\n\ntype C = t.TypeOf<typeof C>;\n// returns { foo: string; bar?: number | undefined }\n```\n\n----------------------------------------\n\nTITLE: Creating Subsets of Zod Enum\nDESCRIPTION: Demonstrates how to create subsets of a Zod enum using the `.extract` and `.exclude` methods. `.extract` creates a new enum with only the specified values, while `.exclude` creates a new enum without the specified values.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nconst FishEnum = z.enum([\"Salmon\", \"Tuna\", \"Trout\"]);\nconst SalmonAndTrout = FishEnum.extract([\"Salmon\", \"Trout\"]);\nconst TunaOnly = FishEnum.exclude([\"Salmon\", \"Trout\"]);\n```\n\n----------------------------------------\n\nTITLE: Zod Nullable Schema\nDESCRIPTION: This snippet demonstrates how to create a nullable schema using `z.nullable()`. It shows how to parse both a string and `null` against the nullable schema. The nullable schema accepts either the underlying type or `null` as a valid value.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nconst nullableString = z.nullable(z.string());\nnullableString.parse(\"asdf\"); // => \"asdf\"\nnullableString.parse(null); // => null\n```\n\n----------------------------------------\n\nTITLE: Default Value with Zod\nDESCRIPTION: This example showcases how to use the `.default` method to provide a default value for a string schema. If the input to `parse` is `undefined`, the schema will return the default string \"tuna\".\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_67\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringWithDefault = z.string().default(\"tuna\");\n\nstringWithDefault.parse(undefined); // => \"tuna\"\n```\n\n----------------------------------------\n\nTITLE: Handling Zod errors\nDESCRIPTION: Describes how to handle Zod errors, including accessing the `issues` array of a `ZodError` to get detailed information about validation problems.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_119\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = z\n  .object({\n    name: z.string(),\n  })\n  .safeParse({ name: 12 });\n\nif (!result.success) {\n  result.error.issues;\n  /* [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"string\",\n        \"received\": \"number\",\n        \"path\": [ \"name\" ],\n        \"message\": \"Expected string, received number\"\n      }\n  ] */\n}\n```\n\n----------------------------------------\n\nTITLE: Time Validation with Precision (TypeScript)\nDESCRIPTION: Illustrates how to set the precision for fractional seconds in `z.string().time()`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst time = z.string().time({ precision: 3 });\n\ntime.parse(\"00:00:00.123\"); // 통과\ntime.parse(\"00:00:00.123456\"); // 실패\ntime.parse(\"00:00:00\"); // 실패\n```\n\n----------------------------------------\n\nTITLE: Map Schema Definition in Zod\nDESCRIPTION: This code shows how to define a Map schema in Zod using `z.map`. This schema is used to validate JavaScript Map objects. The example demonstrates creating a map with string keys and number values.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringNumberMap = z.map(z.string(), z.number());\n\ntype StringNumberMap = z.infer<typeof stringNumberMap>;\n// type StringNumber = Map<string, number>\n```\n\n----------------------------------------\n\nTITLE: Customize Error Path\nDESCRIPTION: Shows how to customize the error path using the `path` parameter in `.refine`. This allows specifying the exact location of the error within the data structure.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_91\n\nLANGUAGE: typescript\nCODE:\n```\nconst passwordForm = z\n  .object({\n    password: z.string(),\n    confirm: z.string(),\n  })\n  .refine((data) => data.password === data.confirm, {\n    message: \"Passwords don't match\",\n    path: [\"confirm\"], // path of error\n  });\n\npasswordForm.parse({ password: \"asdf\", confirm: \"qwer\" });\n```\n\n----------------------------------------\n\nTITLE: Intersection Schema Definition in Zod\nDESCRIPTION: This code shows how to create intersection types in Zod using both `z.intersection` and the `.and` method.  It is recommended to use `.merge` instead of `.and` and `z.intersection` where possible.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nconst Person = z.object({\n  name: z.string(),\n});\n\nconst Employee = z.object({\n  role: z.string(),\n});\n\nconst EmployedPerson = z.intersection(Person, Employee);\n\n// equivalent to:\nconst EmployedPerson = Person.and(Employee);\n```\n\n----------------------------------------\n\nTITLE: Zod Nullable Method\nDESCRIPTION: Illustrates the use of the `.nullable()` method on an existing schema to create a nullable type. The inferred type represents a union of the original type and `null`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nconst E = z.string().nullable(); // equivalent to nullableString\ntype E = z.infer<typeof E>; // string | null\n```\n\n----------------------------------------\n\nTITLE: Creating an intersection schema with `.and`\nDESCRIPTION: Shows how to create an intersection schema using the `.and()` method.  The schema combines the properties of two object schemas.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_113\n\nLANGUAGE: typescript\nCODE:\n```\nconst nameAndAge = z\n  .object({ name: z.string() })\n  .and(z.object({ age: z.number() })); // { name: string } & { age: number }\n\n// equivalent to\nz.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));\n```\n\n----------------------------------------\n\nTITLE: Inferring Formatted Errors with Zod\nDESCRIPTION: Infers the type of formatted errors using `z.inferFormattedError`. It takes a Zod schema as a generic type argument and returns the type definition of the formatted error object, which provides nested errors for each field in the schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ntype FormattedErrors = z.inferFormattedError<typeof FormData>;\n/*\n  {  \n    name?: {_errors?: string[]},\n    contactInfo?: {\n      _errors?: string[],\n      email?: {\n        _errors?: string[],\n      },\n      phone?: {\n        _errors?: string[],\n      },\n    },\n  } \n*/\n```\n\n----------------------------------------\n\nTITLE: Creating a readonly schema with `.readonly`\nDESCRIPTION: Explains how to create a readonly schema using the `.readonly()` method. This freezes the output of the parsed object and makes the type readonly.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_115\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.object({ name: z.string() }).readonly();\ntype schema = z.infer<typeof schema>;\n// Readonly<{name: string}>\n\nconst result = schema.parse({ name: \"fido\" });\nresult.name = \"simba\"; // error\n```\n\nLANGUAGE: typescript\nCODE:\n```\nz.array(z.string()).readonly();\n// readonly string[]\n\nz.tuple([z.string(), z.number()]).readonly();\n// readonly [string, number]\n\nz.map(z.string(), z.date()).readonly();\n// ReadonlyMap<string, Date>\n\nz.set(z.string()).readonly();\n// ReadonlySet<string>\n```\n\n----------------------------------------\n\nTITLE: Zod Enum Definition\nDESCRIPTION: Defines a Zod enum with a fixed set of string values. The type is inferred using `z.infer`. This is a Zod-native approach to declare a schema with allowable string values.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nconst FishEnum = z.enum([\"Salmon\", \"Tuna\", \"Trout\"]);\ntype FishEnum = z.infer<typeof FishEnum>;\n// 'Salmon' | 'Tuna' | 'Trout'\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Zod Optional Schema\nDESCRIPTION: Shows how to extract the wrapped schema from a `ZodOptional` instance using the `.unwrap()` method. This allows access to the original schema before it was made optional.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string();\nconst optionalString = stringSchema.optional();\noptionalString.unwrap() === stringSchema; // true\n```\n\n----------------------------------------\n\nTITLE: Customizing Date Schema Error Messages in Zod\nDESCRIPTION: This code snippet shows how to customize error messages when creating a date schema in Zod. It demonstrates how to specify `required_error` and `invalid_type_error` options.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nconst myDateSchema = z.date({\n  required_error: \"Please select a date and time\",\n  invalid_type_error: \"That's not a date!\",\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Boolean Schema Error Messages in Zod\nDESCRIPTION: This code snippet shows how to customize error messages when creating a boolean schema in Zod. It demonstrates how to specify `required_error` and `invalid_type_error` options.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst isActive = z.boolean({\n  required_error: \"isActive is required\",\n  invalid_type_error: \"isActive must be a boolean\",\n});\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Nullable Schema with Zod\nDESCRIPTION: This snippet illustrates how to extract the underlying schema from a `ZodNullable` instance using the `.unwrap()` method. The `.unwrap()` method removes the nullable wrapper, returning the original schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string();\nconst nullableString = stringSchema.nullable();\nnullableString.unwrap() === stringSchema; // true\n```\n\n----------------------------------------\n\nTITLE: Nullable Schema Shorthand with .nullable()\nDESCRIPTION: This snippet demonstrates the shorthand syntax for creating a nullable Zod schema by calling the `.nullable()` method directly on an existing schema. This is a convenient way to make a schema accept either its underlying type or `null`. The inferred type reflects the union of the type and `null`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nconst E = z.string().nullable(); // nullableString과 동일\ntype E = z.infer<typeof E>; // string | null\n```\n\n----------------------------------------\n\nTITLE: Coerce Boolean Types with Zod\nDESCRIPTION: This snippet demonstrates how boolean coercion works in Zod. It shows how various values are coerced to true or false using JavaScript's `Boolean()` function.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nz.coerce.boolean().parse(\"tuna\"); // => true\nz.coerce.boolean().parse(\"true\"); // => true\nz.coerce.boolean().parse(\"false\"); // => true\nz.coerce.boolean().parse(1); // => true\nz.coerce.boolean().parse([]); // => true\n\nz.coerce.boolean().parse(0); // => false\nz.coerce.boolean().parse(undefined); // => false\nz.coerce.boolean().parse(null); // => false\n```\n\n----------------------------------------\n\nTITLE: Datetime Validation with ISO 8601 (TypeScript)\nDESCRIPTION: Demonstrates using `z.string().datetime()` to validate ISO 8601 datetime strings, including options for timezone offset and precision.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst datetime = z.string().datetime();\n\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // 통과\ndatetime.parse(\"2020-01-01T00:00:00.123Z\"); // 통과\ndatetime.parse(\"2020-01-01T00:00:00.123456Z\"); // 통과 (임의 정밀도)\ndatetime.parse(\"2020-01-01T00:00:00+02:00\"); // 실패 (오프셋 허용 안 됨)\n```\n\n----------------------------------------\n\nTITLE: Date Validations in Zod\nDESCRIPTION: This code snippet demonstrates date-specific validations in Zod, allowing you to specify minimum and maximum allowed dates with custom error messages.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nz.date().min(new Date(\"1900-01-01\"), { message: \"Too old\" });\nz.date().max(new Date(), { message: \"Too young!\" });\n```\n\n----------------------------------------\n\nTITLE: Intersection of Unions in Zod\nDESCRIPTION: Illustrates the result of intersecting two union types, showing how it results in the intersection of their possible types.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\nconst a = z.union([z.number(), z.string()]);\nconst b = z.union([z.number(), z.boolean()]);\nconst c = z.intersection(a, b);\n\ntype c = z.infer<typeof c>; // => number\n```\n\n----------------------------------------\n\nTITLE: Updating Local Fork\nDESCRIPTION: This snippet provides the git commands to update a local fork of the Zod repository after the default branch was switched from `master` to `main`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit branch -m master main   # rename local branch\ngit fetch origin   # fetch from remote\ngit branch -u origin/main main   # set upstream\ngit remote set-head origin -a   # update remote\n```\n\n----------------------------------------\n\nTITLE: String with Default Value\nDESCRIPTION: Creates a string schema with a default value of \"tuna\". If the input is `undefined`, the default value will be used.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_102\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringWithDefault = z.string().default(\"tuna\");\n\nstringWithDefault.parse(undefined); // => \"tuna\"\n```\n\n----------------------------------------\n\nTITLE: Custom Error Message for Zod Number Validation\nDESCRIPTION: This code shows how to provide a custom error message as the second argument to Zod's validation methods.  It uses lte (less than or equal to) to validate if a number is less than or equal to 5, displaying a custom error message if the validation fails.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nz.number().lte(5, { message: \"이👏값은👏너무👏큽니다\" });\n```\n\n----------------------------------------\n\nTITLE: Union Schema with Zod\nDESCRIPTION: This demonstrates how to create a union schema using `.or()` in Zod. The resulting schema allows either a string or a number as valid input.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\nz.string().or(z.number()); // string | number\n\n// equivalent to\nz.union([z.string(), z.number()]);\n```\n\n----------------------------------------\n\nTITLE: Defining Tuple Schema in Zod\nDESCRIPTION: Defines a Zod schema for a tuple with a fixed number of elements, each with a specific type.  The example includes a string, a number, and an object with a number property.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_67\n\nLANGUAGE: typescript\nCODE:\n```\nconst athleteSchema = z.tuple([\n  z.string(), // name\n  z.number(), // jersey number\n  z.object({\n    pointsScored: z.number(),\n  }), // statistics\n]);\n\ntype Athlete = z.infer<typeof athleteSchema>;\n// type Athlete = [string, number, { pointsScored: number }]\n```\n\n----------------------------------------\n\nTITLE: Accessing Options in Discriminated Union\nDESCRIPTION: This shows how to retrieve the list of Zod objects/schemas that make up a discriminated union.  This is useful for programmatically manipulating or combining unions.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nmyUnion.options; // [ZodObject<...>, ZodObject<...>]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Zod Enum Options\nDESCRIPTION: Shows how to retrieve the list of options as a tuple using the `.options` property of the Zod enum schema. The `.options` property returns an array of the enum values.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nFishEnum.options; // [\"Salmon\", \"Tuna\", \"Trout\"];\n```\n\n----------------------------------------\n\nTITLE: Creating an optional schema with `.optional`\nDESCRIPTION: Illustrates how to create an optional schema using the `.optional()` method.  The schema will accept either a string or undefined.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_107\n\nLANGUAGE: typescript\nCODE:\n```\nconst optionalString = z.string().optional(); // string | undefined\n\n// equivalent to\nz.optional(z.string());\n```\n\n----------------------------------------\n\nTITLE: Creating an array schema with `.array`\nDESCRIPTION: Shows how to create an array schema using the `.array()` method.  The resulting schema is an array of strings.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_110\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringArray = z.string().array(); // string[]\n\n// equivalent to\nz.array(z.string());\n```\n\n----------------------------------------\n\nTITLE: Nullish Schema with Zod\nDESCRIPTION: This snippet demonstrates the use of `.nullish()` to create a 'nullish' version of a Zod schema. A nullish schema accepts either a string, null, or undefined.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_71\n\nLANGUAGE: typescript\nCODE:\n```\nconst nullishString = z.string().nullish(); // string | null | undefined\n\n// equivalent to\nz.string().nullable().optional();\n```\n\n----------------------------------------\n\nTITLE: IP Address Validation in Zod\nDESCRIPTION: This code snippet demonstrates how to validate IP addresses using the `z.string().ip()` method in Zod. By default, it allows both IPv4 and IPv6 addresses.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst ip = z.string().ip();\n\nip.parse(\"192.168.1.1\"); // pass\nip.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003\"); // pass\nip.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:192.168.1.1\"); // pass\n\nip.parse(\"256.1.1.1\"); // fail\nip.parse(\"84d5:51a0:9114:gggg:4cfa:f2d7:1f12:7003\"); // fail\n```\n\n----------------------------------------\n\nTITLE: Function Schema Definition with Zod in TypeScript\nDESCRIPTION: This example illustrates how to define and implement function schemas with Zod for input and output validation. It shows how to define the argument types and return type using `z.function().args(...).returns(...)` and then use `.implement()` to provide the function implementation, which will automatically validate the inputs and outputs based on the defined schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_84\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFunction = z.function();\n\ntype myFunction = z.infer<typeof myFunction>;\n// => ()=>unknown\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFunction = z\n  .function()\n  .args(z.string(), z.number()) // accepts an arbitrary number of arguments\n  .returns(z.boolean());\n\ntype myFunction = z.infer<typeof myFunction>;\n// => (arg0: string, arg1: number)=>boolean\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst trimmedLength = z\n  .function()\n  .args(z.string()) // accepts an arbitrary number of arguments\n  .returns(z.number())\n  .implement((x) => {\n    // TypeScript knows x is a string!\n    return x.trim().length;\n  });\n\ntrimmedLength(\"sandwich\"); // => 8\ntrimmedLength(\" asdf \"); // => 4\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFunction = z\n  .function()\n  .args(z.string())\n  .implement((arg) => {\n    return [arg.length];\n  });\n\nmyFunction; // (arg: string)=>number[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nmyFunction.parameters();\n// => ZodTuple<[ZodString, ZodNumber]>\n\nmyFunction.returnType();\n// => ZodBoolean\n```\n\n----------------------------------------\n\nTITLE: Datetime Validation with Local Time (TypeScript)\nDESCRIPTION: Shows usage of `z.string().datetime({ local: true })` to permit datetimes without timezone information.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.string().datetime({ local: true });\nschema.parse(\"2020-01-01T00:00:00\"); // 통과\n```\n\n----------------------------------------\n\nTITLE: Validate ISO Datetime Strings with Precision (Zod)\nDESCRIPTION: This snippet validates ISO 8601 datetime strings and restricts the sub-second precision. The `precision` option is used to specify the allowed precision.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst datetime = z.string().datetime({ precision: 3 });\n\ndatetime.parse(\"2020-01-01T00:00:00.123Z\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // fail\ndatetime.parse(\"2020-01-01T00:00:00.123456Z\"); // fail\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Optional Schema with Zod\nDESCRIPTION: This snippet illustrates how to extract the underlying schema from a `ZodOptional` instance using the `.unwrap()` method. The `.unwrap()` method removes the optional wrapper, returning the original schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string();\nconst optionalString = stringSchema.optional();\noptionalString.unwrap() === stringSchema; // true\n```\n\n----------------------------------------\n\nTITLE: Pick Object Keys with Zod\nDESCRIPTION: This snippet demonstrates how to pick specific keys from an object schema to create a new schema using the `.pick` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst Recipe = z.object({\n  id: z.string(),\n  name: z.string(),\n  ingredients: z.array(z.string()),\n});\n\nconst JustTheName = Recipe.pick({ name: true });\ntype JustTheName = z.infer<typeof JustTheName>;\n// => { name: string }\n```\n\n----------------------------------------\n\nTITLE: Specify Key Schema in ZodRecord (Zod)\nDESCRIPTION: This code shows how to define the key and value schemas for a Zod record.  Prior to this change, only the value schema could be specified.  Now, the first argument validates the record keys, and the second argument validates the record values. The example includes use of an enum as key.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CHANGELOG.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nz.record(z.boolean()); // Record<string, boolean>;\n\nconst schema = z.record(z.number(), z.boolean());\ntype schema = z.infer<typeof schema>; // Record<number, boolean>\n\nconst schema = z.record(z.enum([\"Tuna\", \"Trout\"]), z.boolean());\ntype schema = z.infer<typeof schema>; // Record<\"Tuna\" | \"Trout\", boolean>\n```\n\n----------------------------------------\n\nTITLE: String to Number Transformation\nDESCRIPTION: Transforms a string to its length (number) using the `.transform` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_97\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringToNumber = z.string().transform((val) => val.length);\n\nstringToNumber.parse(\"string\"); // => 6\n```\n\n----------------------------------------\n\nTITLE: Chaining String Methods After Coercion (TypeScript)\nDESCRIPTION: Demonstrates how to chain string validation methods after coercing a value to a string using `z.coerce.string()`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nz.coerce.string().email().min(5);\n```\n\n----------------------------------------\n\nTITLE: Accessing Enum Values with Zod\nDESCRIPTION: This snippet demonstrates how to access individual enum values and the enum object itself using the `.enum` property of a Zod enum schema. It allows for autocompletion and provides a convenient way to access the key-value pairs of the enum.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nFishEnum.enum.Salmon; // => 자동 완성\n\nFishEnum.enum;\n/*\n=> {\n  Salmon: \"Salmon\",\n  Tuna: \"Tuna\",\n  Trout: \"Trout\",\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Zod Default Value with Random Number TypeScript\nDESCRIPTION: This code demonstrates using the `default` method with a function to generate a random number as the default value for a Zod number schema. Each time `parse(undefined)` is called, a new random number is generated.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_99\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberWithRandomDefault = z.number().default(Math.random);\n\nnumberWithRandomDefault.parse(undefined); // => 0.4413456736055323\nnumberWithRandomDefault.parse(undefined); // => 0.1871840107401901\nnumberWithRandomDefault.parse(undefined); // => 0.7223408162401552\n```\n\n----------------------------------------\n\nTITLE: Nullable Schema Definition in Zod\nDESCRIPTION: This code demonstrates how to create nullable schemas in Zod using `z.nullable` and the `.nullable()` method. A nullable schema allows a value to be either the specified type or `null`. The code demonstrates parsing both a string and `null` with a nullable schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nconst nullableString = z.nullable(z.string());\nnullableString.parse(\"asdf\"); // => \"asdf\"\nnullableString.parse(null); // => null\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst E = z.string().nullable(); // equivalent to D\ntype E = z.infer<typeof E>; // string | null\n```\n\n----------------------------------------\n\nTITLE: Accessing Zod Object Shape\nDESCRIPTION: Demonstrates accessing the schemas for individual keys within a Zod object schema using the `.shape` property. This allows direct access to the schema definition of each property.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nDog.shape.name; // => string schema\nDog.shape.age; // => number schema\n```\n\n----------------------------------------\n\nTITLE: Custom Error Messages in Schemas (Zod)\nDESCRIPTION: This code snippet demonstrates how to define custom error messages for Zod schemas using the `invalid_type_error` and `required_error` options. These messages are displayed when the input data does not match the expected type or is missing, respectively. It creates a custom error map that's bound to the schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CHANGELOG.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst name = z.string({\n  invalid_type_error: \"Name must be string\",\n  required_error: \"Name is required\",\n});\n```\n\n----------------------------------------\n\nTITLE: Validate IP Addresses with Version (Zod)\nDESCRIPTION: This snippet validates IP addresses with a specific version (IPv4 or IPv6) using Zod's `ip()` method with the `version` option.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst ipv4 = z.string().ip({ version: \"v4\" });\nipv4.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003\"); // fail\n\nconst ipv6 = z.string().ip({ version: \"v6\" });\nipv6.parse(\"192.168.1.1\"); // fail\n```\n\n----------------------------------------\n\nTITLE: Access Schema Shape with Zod\nDESCRIPTION: This snippet shows how to access the schema of specific keys within an object schema using the `.shape` property.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nDog.shape.name; // => string schema\nDog.shape.age; // => number schema\n```\n\n----------------------------------------\n\nTITLE: Cloning Zod Repository\nDESCRIPTION: This snippet shows how to clone a forked Zod repository using git via SSH.  The placeholder `{your_username}` needs to be replaced with the actual GitHub username.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngit clone git@github.com:{your_username}/zod.git\n```\n\n----------------------------------------\n\nTITLE: Customizing NaN Schema Error Messages with Zod\nDESCRIPTION: This code shows how to customize error messages for a NaN schema in Zod. It defines custom messages for required and invalid type errors. The `isNaN` constant represents a schema that validates if a value is NaN.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst isNaN = z.nan({\n  required_error: \"isNaN은 필수입니다\",\n  invalid_type_error: \"isNaN은 '숫자가 아님'이어야 합니다\",\n});\n```\n\n----------------------------------------\n\nTITLE: Strip Unknown Keys with Zod\nDESCRIPTION: This snippet shows how to reset an object schema to the default behavior of stripping unknown keys using the `.strip` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Zod Primitive Types\nDESCRIPTION: Lists various primitive types supported by Zod. Each line declares a schema for a different primitive type using the `z` object from the Zod library, covering `string`, `number`, `bigint`, `boolean`, `date`, `symbol`, `undefined`, `null`, `void`, `any`, `unknown`, and `never`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { z } from \"zod\";\n\n// primitive values\nz.string();\nz.number();\nz.bigint();\nz.boolean();\nz.date();\nz.symbol();\n\n// empty types\nz.undefined();\nz.null();\nz.void(); // accepts undefined\n\n// catch-all types\n// allows any value\nz.any();\nz.unknown();\n\n// never type\n// allows no values\nz.never();\n```\n\n----------------------------------------\n\nTITLE: Creating a branded type with `.brand`\nDESCRIPTION: Demonstrates how to create a branded type using the `.brand()` method to simulate nominal typing in TypeScript.  Branded types can be used to ensure that only validated data is passed to certain functions.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_114\n\nLANGUAGE: typescript\nCODE:\n```\nconst Cat = z.object({ name: z.string() }).brand<\"Cat\">();\ntype Cat = z.infer<typeof Cat>;\n\nconst petCat = (cat: Cat) => {};\n\n// this works\nconst simba = Cat.parse({ name: \"simba\" });\npetCat(simba);\n\n// this doesn't\npetCat({ name: \"fido\" });\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst Cat = z.object({ name: z.string() }).brand<\"Cat\">();\ntype Cat = z.infer<typeof Cat>;\n// {name: string} & {[symbol]: \"Cat\"}\n```\n\n----------------------------------------\n\nTITLE: Customize Number Schema Error Messages (Zod)\nDESCRIPTION: This snippet demonstrates how to customize error messages for number schemas in Zod.  You can set custom messages for `required_error` and `invalid_type_error`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst age = z.number({\n  required_error: \"Age is required\",\n  invalid_type_error: \"Age must be a number\",\n});\n```\n\n----------------------------------------\n\nTITLE: Coercing BigInts without Input Restriction\nDESCRIPTION: Illustrates the issues that can arise when coercing to `bigint` without input restrictions. It shows that unexpected inputs, like `null`, can cause uncaught errors.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_115\n\nLANGUAGE: typescript\nCODE:\n```\nconst toBigInt = z.coerce.bigint();\n\n// 직관적으로 동작\nconsole.log(toBigInt.safeParse(\"42\")); // true\n\n// 원하지 않는 결과가 나올 수 있음\nconsole.log(toBigInt.safeParse(null)); // 잡히지 않는 오류 발생\n```\n\n----------------------------------------\n\nTITLE: Accessing Schemas with .shape in Zod Objects\nDESCRIPTION: This snippet shows how to access individual schema definitions for specific keys within a Zod object schema using the `.shape` property.  It allows you to retrieve the schema associated with a certain property, such as the string schema for `name` or the number schema for `age`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nDog.shape.name; // => 문자열 스키마\nDog.shape.age; // => 숫자 스키마\n```\n\n----------------------------------------\n\nTITLE: Datetime Validation with Local Flag in Zod\nDESCRIPTION: This code snippet shows how to allow unqualified (timezone-less) datetimes with the `local` flag when validating with Zod's `z.string().datetime()` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.string().datetime({ local: true });\nschema.parse(\"2020-01-01T00:00:00\"); // pass\n```\n\n----------------------------------------\n\nTITLE: Number with Random Default Value\nDESCRIPTION: Sets a default value for a number schema using a function (Math.random).  The function is re-executed whenever a default value is needed.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_103\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberWithRandomDefault = z.number().default(Math.random);\n\nnumberWithRandomDefault.parse(undefined); // => 0.4413456736055323\nnumberWithRandomDefault.parse(undefined); // => 0.1871840107401901\nnumberWithRandomDefault.parse(undefined); // => 0.7223408162401552\n```\n\n----------------------------------------\n\nTITLE: Promise Validation with Zod in TypeScript\nDESCRIPTION: Demonstrates how to validate Promise instances using Zod's `z.promise` schema.  It checks if the input is a Promise instance and then validates the resolved value of the Promise. The snippet also shows how to handle validation failures within the Promise context, using `async` and `await` for asynchronous validation.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_80\n\nLANGUAGE: typescript\nCODE:\n```\nconst numberPromise = z.promise(z.number());\n```\n\nLANGUAGE: typescript\nCODE:\n```\nnumberPromise.parse(\"tuna\");\n// ZodError: Non-Promise type: string\n\nnumberPromise.parse(Promise.resolve(\"tuna\"));\n// => Promise\n\nconst test = async () => {\n  await numberPromise.parse(Promise.resolve(\"tuna\"));\n  // ZodError: Non-number type: string\n\n  await numberPromise.parse(Promise.resolve(3.14));\n  // => 3.14\n};\n```\n\n----------------------------------------\n\nTITLE: Rest Parameters for Tuples (Zod)\nDESCRIPTION: This code demonstrates the use of rest parameters in Zod tuples. The `.rest()` method allows you to define a tuple with a fixed number of initial elements followed by a variable number of elements of a specific type. This is useful for creating tuples with dynamic lengths and types.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CHANGELOG.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());\ntype t1 = z.output<typeof myTuple>; // [string, number, ...boolean[]]\n```\n\n----------------------------------------\n\nTITLE: Time Validation with Precision in Zod\nDESCRIPTION: This code snippet demonstrates how to set the `precision` option to constrain the allowable decimal precision when validating using Zod's `z.string().time()` method.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst time = z.string().time({ precision: 3 });\n\ntime.parse(\"00:00:00.123\"); // pass\ntime.parse(\"00:00:00.123456\"); // fail\ntime.parse(\"00:00:00\"); // fail\n```\n\n----------------------------------------\n\nTITLE: Zod Native Enum (Const)\nDESCRIPTION: Illustrates validating against an `as const` object using `z.nativeEnum()`.  It effectively validates against the literal values defined in the const object.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nconst Fruits = {\n  Apple: \"apple\",\n  Banana: \"banana\",\n  Cantaloupe: 3,\n} as const;\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // \"apple\" | \"banana\" | 3\n\nFruitEnum.parse(\"apple\"); // passes\nFruitEnum.parse(\"banana\"); // passes\nFruitEnum.parse(3); // passes\nFruitEnum.parse(\"Cantaloupe\"); // fails\n```\n\n----------------------------------------\n\nTITLE: Zod Promise Schema TypeScript\nDESCRIPTION: This code demonstrates how to define a Zod schema for a Promise that resolves to a string. It uses the `promise()` method to wrap the string schema in a Promise.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_107\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringPromise = z.string().promise(); // Promise<string>\n\n// 위 코드는 아래와 동일합니다\nz.promise(z.string());\n```\n\n----------------------------------------\n\nTITLE: Accessing Native Enum Object\nDESCRIPTION: Demonstrates accessing the underlying object of a Zod native enum using the `.enum` property.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nFruitEnum.enum.Apple; // \"apple\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple String Schema (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a simple string schema using Zod and parse values against it. It also shows how to use `safeParse` for handling validation failures without throwing errors.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\";\n\n// 문자열을 위한 스키마 생성\nconst mySchema = z.string();\n\n// 파싱\nmySchema.parse(\"tuna\"); // => \"tuna\"\nmySchema.parse(12); // => ZodError 발생\n\n// \"안전한\" 파싱 (검증 실패 시 에러를 던지지 않음)\nmySchema.safeParse(\"tuna\"); // => { success: true; data: \"tuna\" }\nmySchema.safeParse(12); // => { success: false; error: ZodError }\n```\n\n----------------------------------------\n\nTITLE: Accessing Base Object From Native Enum\nDESCRIPTION: This code snippet shows how to access the underlying object used to create the native enum schema using the `.enum` property.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nFruitEnum.enum.Apple; // \"apple\"\n```\n\n----------------------------------------\n\nTITLE: Time Validation (HH:MM:SS[.s+]) (TypeScript)\nDESCRIPTION: Shows how to use `z.string().time()` to validate time strings with optional fractional seconds, but without timezone offsets.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst time = z.string().time();\n\ntime.parse(\"00:00:00\"); // 통과\ntime.parse(\"09:52:31\"); // 통과\ntime.parse(\"23:59:59.9999999\"); // 통과 (임의의 정밀도 허용)\n\ntime.parse(\"00:00:00.123Z\"); // 실패 (`Z` 허용 안 됨)\ntime.parse(\"00:00:00.123+02:00\"); // 실패 (오프셋 허용 안 됨)\n```\n\n----------------------------------------\n\nTITLE: Accessing Zod Enum Values\nDESCRIPTION: Demonstrates how to access the enum values for autocompletion using the `.enum` property of the Zod schema. The `.enum` property returns an object where keys are enum values and values are the enum values themselves.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nFishEnum.enum.Salmon; // => autocompletes\n\nFishEnum.enum;\n/*\n=> {\n  Salmon: \"Salmon\",\n  Tuna: \"Tuna\",\n  Trout: \"Trout\",\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Coercing Dates with Pipe\nDESCRIPTION: Demonstrates how to use `.pipe()` with `z.coerce.date()` to handle coercion issues. It shows how limiting input types improves the predictability of date coercion, preventing unexpected results from `null` inputs.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_113\n\nLANGUAGE: typescript\nCODE:\n```\nconst toDate = z.coerce.date();\n\n// 직관적으로 동작\nconsole.log(toDate.safeParse(\"2023-01-01\").success); // true\n\n// 원하지 않는 결과가 나올 수 있음\nconsole.log(toDate.safeParse(null).success); // true\n```\n\n----------------------------------------\n\nTITLE: Building Zod\nDESCRIPTION: This snippet shows how to build the Zod library, compiling the `src` directory to the `lib` directory.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nyarn build\n```\n\n----------------------------------------\n\nTITLE: Defining Intersection Schema in Zod\nDESCRIPTION: Demonstrates how to use `z.intersection` and `.and` to create an intersection type, which combines the properties of two object types. Shows that A.merge(B) returns a more useful ZodObject.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nconst Person = z.object({\n  name: z.string(),\n});\n\nconst Employee = z.object({\n  role: z.string(),\n});\n\nconst EmployedPerson = z.intersection(Person, Employee);\n\n// equivalent to:\nconst EmployedPerson = Person.and(Employee);\n```\n\n----------------------------------------\n\nTITLE: Readonly Zod Schema TypeScript\nDESCRIPTION: This code demonstrates using the `readonly()` method to create a `ZodReadonly` schema instance. This freezes the resulting object with `Object.freeze()` and marks the inferred type as `readonly`.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_111\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.object({ name: z.string() }).readonly();\ntype schema = z.infer<typeof schema>;\n// Readonly\n\nconst result = schema.parse({ name: \"fido\" });\nresult.name = \"simba\"; // 오류 발생\n```\n\nLANGUAGE: typescript\nCODE:\n```\nz.array(z.string()).readonly();\n// readonly string[]\n\nz.tuple([z.string(), z.number()]).readonly();\n// readonly [string, number]\n\nz.map(z.string(), z.date()).readonly();\n// ReadonlyMap\n\nz.set(z.string()).readonly();\n// ReadonlySet\n```\n\n----------------------------------------\n\nTITLE: Zod Enum with Const Assertion\nDESCRIPTION: Defines a Zod enum using a `const` assertion to ensure the enum values are treated as a tuple of strings. This allows Zod to infer the exact values of each element.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nconst VALUES = [\"Salmon\", \"Tuna\", \"Trout\"] as const;\nconst FishEnum = z.enum(VALUES);\n```\n\n----------------------------------------\n\nTITLE: Customize Number Validation Error Messages (Zod)\nDESCRIPTION: This snippet demonstrates how to add a custom error message to a number validation, specifically when using the `max` function.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nz.number().max(5, { message: \"this👏is👏too👏big\" });\n```\n\n----------------------------------------\n\nTITLE: Validate ISO Datetime Strings with Offset (Zod)\nDESCRIPTION: This snippet validates ISO 8601 datetime strings allowing for timezone offsets. The `offset` option is set to `true` to enable this.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst datetime = z.string().datetime({ offset: true });\n\ndatetime.parse(\"2020-01-01T00:00:00+02:00\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00.123+02:00\"); // pass (毫秒数可选)\ndatetime.parse(\"2020-01-01T00:00:00.123+0200\"); // pass (毫秒数可选)\ndatetime.parse(\"2020-01-01T00:00:00.123+02\"); // pass (只偏移小时)\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // pass (仍支持 Z)\n```\n\n----------------------------------------\n\nTITLE: Flattening Zod Errors in TypeScript\nDESCRIPTION: This snippet demonstrates using the `.flatten()` method on a ZodError to generate a simpler error structure suitable for scenarios with shallow object schemas.  The `fieldErrors` key points to an object that groups all issues by key, and the `formErrors` element is a list of issues that occurred on the \"root\" of the object schema.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nif (!result.success) {\n  console.log(result.error.flatten());\n}\n```\n\n----------------------------------------\n\nTITLE: Validate IP Addresses (Zod)\nDESCRIPTION: This snippet validates IP addresses using Zod's `ip()` method. By default, it validates both IPv4 and IPv6 addresses.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst ip = z.string().ip();\n\nip.parse(\"192.168.1.1\"); // pass\nip.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003\"); // pass\nip.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:192.168.1.1\"); // pass\n\nip.parse(\"256.1.1.1\"); // fail\nip.parse(\"84d5:51a0:9114:gggg:4cfa:f2d7:1f12:7003\"); // fail\n```\n\n----------------------------------------\n\nTITLE: Customizing String Schema Error Messages (TypeScript)\nDESCRIPTION: This snippet demonstrates how to customize default error messages for string schemas in Zod using the `required_error` and `invalid_type_error` options.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst name = z.string({\n  required_error: \"이름은 필수입니다\",\n  invalid_type_error: \"이름은 문자열이어야 합니다\",\n});\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Optional Schema in Zod\nDESCRIPTION: This snippet shows how to use the `.unwrap()` method to retrieve the underlying schema of an optional schema. This is useful if you need to access the original schema without the optional modifier.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_ZH.md#_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringSchema = z.string();\nconst optionalString = stringSchema.optional();\noptionalString.unwrap() === stringSchema; // true\n```\n\n----------------------------------------\n\nTITLE: Transforming Zod String to Number TypeScript\nDESCRIPTION: This code demonstrates using the `transform` method to convert a Zod string schema into a number schema representing the length of the string. It parses a string and returns its length as a number.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_93\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringToNumber = z.string().transform((val) => val.length);\n\nstringToNumber.parse(\"string\"); // => 6\n```\n\n----------------------------------------\n\nTITLE: Defining Object with Optional Properties in io-ts\nDESCRIPTION: This code snippet illustrates how to define an object with optional properties using the `io-ts` library. It defines two separate object validators, one for required properties (`A`) and one for optional properties (`B`). The optional properties are passed through `t.partial` to mark them as optional. Finally, the two validators are combined using `t.intersection` to create the final object type `C`. This approach requires familiarity with functional programming concepts and the `fp-ts` library, which `io-ts` relies on.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README.md#_snippet_121\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as t from \"io-ts\";\n\nconst A = t.type({\n  foo: t.string,\n});\n\nconst B = t.partial({\n  bar: t.number,\n});\n\nconst C = t.intersection([A, B]);\n\ntype C = t.TypeOf<typeof C>;\n// returns { foo: string; bar?: number | undefined }\n```\n\n----------------------------------------\n\nTITLE: Running Jest Tests\nDESCRIPTION: This snippet shows how to run all Jest tests and generate coverage badges. It assumes Jest and its dependencies are installed.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nyarn test\n```\n\n----------------------------------------\n\nTITLE: Deprecated Transformer Syntax in Zod (TypeScript)\nDESCRIPTION: This code snippet demonstrates the transformer syntax that is no longer available in Zod.  It shows how transformers were previously created using input and output schemas with a transformation function.  This example highlights the now-deprecated `z.transformer(A, B, func)` and `A.transform(B, func)` methods.\nSOURCE: https://github.com/colinhacks/zod/blob/main/MIGRATION.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n# not available\nz.transformer(A, B, func);\nA.transform(B, func)\n```\n\n----------------------------------------\n\nTITLE: Flattening Zod Errors with Root Error in TypeScript\nDESCRIPTION: This snippet demonstrates the output of `.flatten()` when the entire object being validated is invalid. In this example, `FormData.safeParse(null)` is called, resulting in an \"Invalid input\" error at the root level. The `.flatten()` method then populates the `formErrors` array with this error message and keeps the `fieldErrors` object empty.\nSOURCE: https://github.com/colinhacks/zod/blob/main/ERROR_HANDLING.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = FormData.safeParse(null);\nif (!result.success) {\n  result.error.flatten();\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Mode in tsconfig.json (TypeScript)\nDESCRIPTION: This snippet shows how to enable the `strict` mode in your `tsconfig.json` file. Enabling strict mode is recommended for all TypeScript projects as a best practice.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// tsconfig.json\n{\n  // ...\n  \"compilerOptions\": {\n    // ...\n    \"strict\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Single Jest Test File\nDESCRIPTION: This snippet shows how to run a single Jest test file.  The example given is `enum.test.ts` but any valid test file can be provided.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nyarn test enum\n```\n\n----------------------------------------\n\nTITLE: Installing Zod via npm, deno, yarn, bun, pnpm (Shell)\nDESCRIPTION: These commands install the Zod library using different package managers: npm, deno, yarn, bun, and pnpm.  They add Zod as a project dependency.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install zod       # npm\ndeno add npm:zod      # deno\nyarn add zod          # yarn\nbun add zod           # bun\npnpm add zod          # pnpm\n```\n\n----------------------------------------\n\nTITLE: Executing Playground\nDESCRIPTION: This snippet executes the `playground.ts` file and watches for changes, useful for experimentation.  Requires `ts-node` or equivalent to be installed.\nSOURCE: https://github.com/colinhacks/zod/blob/main/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nyarn play\n```\n\n----------------------------------------\n\nTITLE: Installing Zod Canary Version (Shell)\nDESCRIPTION: These commands install the canary version of the Zod library using different package managers: npm, deno, yarn, bun, and pnpm.  Canary versions are pre-release versions.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpm install zod@canary       # npm\ndeno add npm:zod@canary      # deno\nyarn add zod@canary          # yarn\nbun add zod@canary           # bun\npnpm add zod@canary          # pnpm\n```\n\n----------------------------------------\n\nTITLE: Date Validation (YYYY-MM-DD) (TypeScript)\nDESCRIPTION: Example of using `z.string().date()` to validate strings matching the `YYYY-MM-DD` format.\nSOURCE: https://github.com/colinhacks/zod/blob/main/README_KO.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst date = z.string().date();\n\ndate.parse(\"2020-01-01\"); // 통과\ndate.parse(\"2020-1-1\"); // 실패\ndate.parse(\"2020-01-32\"); // 실패\n```"
  }
]