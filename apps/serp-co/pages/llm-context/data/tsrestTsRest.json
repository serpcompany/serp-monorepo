[
  {
    "owner": "ts-rest",
    "repo": "ts-rest",
    "content": "TITLE: Creating a ts-rest Contract with Zod Schema Validation\nDESCRIPTION: Defines a ts-rest contract using Zod for schema validation. The contract includes endpoints for creating and retrieving posts, with fully typed request and response bodies.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/quickstart.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// contract.ts\n\nimport { initContract } from '@ts-rest/core';\nimport { z } from 'zod';\n\nconst c = initContract();\n\nconst PostSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  body: z.string(),\n});\n\nexport const contract = c.router({\n  createPost: {\n    method: 'POST',\n    path: '/posts',\n    responses: {\n      201: PostSchema,\n    },\n    body: z.object({\n      title: z.string(),\n      body: z.string(),\n    }),\n    summary: 'Create a post',\n  },\n  getPost: {\n    method: 'GET',\n    path: `/posts/:id`,\n    responses: {\n      200: PostSchema.nullable(),\n    },\n    summary: 'Get a post by id',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining API Contract with ts-rest\nDESCRIPTION: Example showing how to define a ts-rest API contract with Zod validation and TypeScript types. The contract defines a GET endpoint for fetching posts with pagination support through query parameters and custom headers.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst contract = c.router({\n  getPosts: {\n    method: 'GET',\n    path: '/posts',\n    query: z.object({\n      skip: z.number(),\n      take: z.number(),\n    }), // <-- Zod schema\n    responses: {\n      200: c.type<Post[]>(), // <-- OR normal TS types\n    },\n    headers: z.object({\n      'x-pagination-page': z.coerce.number().optional(),\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Path Parameters in ts-rest Contract\nDESCRIPTION: Shows how to define and validate path parameters in a ts-rest contract, including parameter validation using Zod schema.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router({\n  getPost: {\n    ...,\n    path: '/api/posts/:id',\n  }\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router({\n  getPost: {\n    ...,\n    path: '/api/author/:authorId/posts/:id',\n    pathParams: z.object({\n      authorId: z.string().nanoid(),\n      id: z.coerce.number(),\n    }),\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Using ts-rest with Fetch API Client\nDESCRIPTION: Implements a client using ts-rest with the Fetch API to make type-safe requests to the server. The client is initialized with a base URL and includes typed response handling.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/quickstart.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// client.ts\nimport { initClient } from \"@ts-rest/core\";\n\n// `contract` is the AppRouter returned by `c.router`\nconst client = initClient(contract, {\n  baseUrl: 'http://localhost:3000',\n  baseHeaders: {},\n});\n\nconst { body, status } = await client.createPost({\n  body: {\n    title: 'Post Title',\n    body: 'Post Body',\n  },\n});\n\nif (status === 201) {\n  // body is Post\n  console.log(body);\n} else {\n  // body is unknown\n  console.log(body);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ts-rest with NestJS Controller\nDESCRIPTION: Integrates ts-rest with a NestJS controller to create a fully type-safe REST API. Uses decorators to bind contract routes to controller methods with type checking.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/quickstart.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// post.controller.ts\n\nconst c = nestControllerContract(contract);\ntype RequestShapes = NestRequestShapes<typeof c>;\n\n@Controller()\nexport class PostController implements NestControllerInterface<typeof c> {\n  constructor(private readonly postService: PostService) {}\n\n  @TsRest(c.getPost)\n  async getPost(@TsRestRequest() { params: { id } }: RequestShapes['getPost']) {\n    const post = await this.postService.getPost(id);\n\n    return { status: 200 as const, body: post };\n  }\n\n  @TsRest(c.createPost)\n  async createPost(@TsRestRequest() { body }: RequestShapes['createPost']) {\n    const post = await this.postService.createPost({\n      title: body.title,\n      body: body.body,\n    });\n\n    return { status: 201 as const, body: post };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an API Contract with ts-rest\nDESCRIPTION: Demonstrates how to define a REST API contract using ts-rest's router functionality with Zod for query validation and TypeScript types for response typing. The example shows a GET endpoint for retrieving posts with pagination support.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/intro.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst contract = c.router({\n  getPosts: {\n    method: 'GET',\n    path: '/posts',\n    query: z.object({\n      skip: z.number(),\n      take: z.number(),\n    }), // <-- Zod schema\n    responses: {\n      200: c.type<Post[]>(), // <-- OR normal TS types\n    },\n    headers: z.object({\n      'x-pagination-page': z.coerce.number().optional(),\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing ts-rest with Fastify Server\nDESCRIPTION: Sets up a Fastify server with ts-rest integration for type-safe API routes. Includes route handlers for getting and creating posts with proper typing of request and response objects.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/quickstart.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\n\nimport { initServer } from '@ts-rest/fastify';\nconst app = fastify();\n\nconst s = initServer();\n\nconst router = s.router(contract, {\n  getPost: async ({ params: { id } }) => {\n    const post = await prisma.post.findUnique({ where: { id } });\n\n    return {\n      status: 200,\n      body: post,\n    };\n  },\n  createPost: async ({ body }) => {\n    const post = await prisma.post.create({\n      data: body,\n    });\n\n    return {\n      status: 201,\n      body: post,\n    };\n  },\n});\n\napp.register(s.plugin(router));\n\nconst start = async () => {\n  try {\n    await app.listen({ port: 3000 });\n  } catch (err) {\n    app.log.error(err);\n    process.exit(1);\n  }\n};\n\nstart();\n```\n\n----------------------------------------\n\nTITLE: Implementing ts-rest with Next.js API Routes\nDESCRIPTION: Integrates ts-rest with Next.js API routes to create type-safe endpoints. Uses createNextRoute to define route handlers and createNextRouter to generate the API handler.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/quickstart.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// pages/api/[...ts-rest].tsx\n\n// `contract` is the AppRouter returned by `c.router`\nconst postsRouter = createNextRoute(contract.posts, {\n  createPost: async (args) => {\n    const newPost = await posts.createPost(args.body);\n\n    return {\n      status: 201,\n      body: newPost,\n    };\n  },\n});\n\nconst router = createNextRoute(contract, {\n  posts: postsRouter,\n});\n\n// Actually initiate the collective endpoints\nexport default createNextRouter(contract, router);\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic REST Contract with TypeScript\nDESCRIPTION: Demonstrates how to initialize and define a basic REST API contract with POST and GET endpoints using ts-rest. Shows implementation of request body validation with Zod, response typing, and metadata configuration.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initContract } from '@ts-rest/core';\n\nconst c = initContract();\nexport const contract = c.router({\n  createPost: {\n    method: 'POST',\n    path: '/posts',\n    //     ^ Note! This is the full path on the server, not just the sub-path of a route\n    responses: {\n      201: c.type<Post>(),\n    },\n    body: z.object({\n      title: z.string(),\n      content: z.string(),\n      published: z.boolean().optional(),\n      description: z.string().optional(),\n    }),\n    summary: 'Create a post',\n    metadata: { role: 'user' } as const,\n  },\n  getPosts: {\n    method: 'GET',\n    path: '/posts',\n    responses: {\n      200: c.type<{ posts: Post[]; total: number }>(),\n    },\n    headers: z.object({\n      pagination: z.string().optional(),\n    }),\n    query: z.object({\n      take: z.string().transform(Number).optional(),\n      skip: z.string().transform(Number).optional(),\n      search: z.string().optional(),\n    }),\n    summary: 'Get all posts',\n    metadata: { role: 'guest' } as const,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Consuming a ts-rest API on the Client\nDESCRIPTION: Demonstrates how to consume a ts-rest API contract from a client using the RPC-like interface. The example shows a fully type-safe API call with typed headers and query parameters.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/intro.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = await client.getPosts({\n  headers: { 'x-pagination-page': 1 },\n  query: { skip: 0, take: 10 },\n  // ^-- Fully typed!\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a ts-rest Contract on the Server\nDESCRIPTION: Shows how to fulfill the ts-rest contract on a server by implementing a route handler with type safety. The example implements a getPost endpoint using Prisma to retrieve a post by ID.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/intro.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst router = s.router(contract, {\n  getPost: async ({ params: { id } }) => {\n    return {\n      status: 200,\n      body: prisma.post.findUnique({ where: { id } }),\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing useInfiniteQuery with ts-rest in React\nDESCRIPTION: This snippet demonstrates how to use the useInfiniteQuery hook from ts-rest to fetch paginated posts. It includes logic for loading more posts, handling loading and error states, and rendering the fetched data.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/use-infinite-query.md#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { tsr } from './tsr';\n\nconst PAGE_SIZE = 5;\n\nexport const Posts = () => {\n  const { data, isLoading, isError, fetchNextPage, hasNextPage } = tsr.getPosts.useInfiniteQuery({\n    queryKey: ['posts'],\n    queryData: ({ pageParam }) => ({\n      query: {\n        skip: pageParam.skip,\n        take: pageParam.take,\n      },\n    }),\n    initialPageParam: { skip: 0, take: PAGE_SIZE },\n    getNextPageParam: (lastPage, allPages) => {\n      return lastPage.body.posts.length >= PAGE_SIZE\n        ? { take: PAGE_SIZE, skip: allPages.length * PAGE_SIZE }\n        : undefined;\n    },\n  });\n  \n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n  \n  if (isError) {\n    return <div>Error</div>;\n  }\n\n  const posts = data.pages.flatMap((page) =>\n    page.status === 200 ? page.body.posts : [],\n  );\n  \n  return (\n    <div>\n      <ul>\n        {posts.map((post) => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n      <button onClick={fetchNextPage}>Load more</button>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Consuming API with ts-rest Client\nDESCRIPTION: Example showing how to consume the API using ts-rest's type-safe client. Demonstrates making a request with typed query parameters and headers.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/README.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = await client.getPosts({\n  headers: { 'x-pagination-page': 1 },\n  query: { skip: 0, take: 10 },\n  // ^-- Fully typed!\n});\n```\n\n----------------------------------------\n\nTITLE: Complete Example with Queries and Mutations\nDESCRIPTION: Comprehensive example showing queries, mutations, optimistic updates, and error handling with ts-rest and React Query.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v5-setup.mdx#2025-04-17_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { tsr } from './tsr';\n\nconst Posts = () => {\n  const tsrQueryClient = tsr.useQueryClient();\n\n  const { data, isPending } = tsr.posts.get.useQuery({ queryKey: ['posts'] });\n  const { mutate } = tsr.posts.create.useMutation({\n    onMutate: (newPost) => {\n      // get current posts, so we can reset back to it if the mutation fails\n      const lastGoodKnown = tsrQueryClient.posts.get.getQueryData(['posts']);\n\n      // optimistically update the cache with the new post\n      tsrQueryClient.posts.get.setQueryData(['posts'], (old) => ({\n        ...old,\n        body: [\n          ...old.body,\n          {\n            ...newPost.body,\n            id: `placeholder-${Date.now()}`\n          }\n        ]\n      }));\n\n      // return the old posts to be stored in mutation context\n      return { lastGoodKnown };\n    },\n    onError: (error, newPost, context) => {\n      tsrQueryClient.posts.get.setQueryData(['posts'], context.lastGoodKnown);\n    },\n    onSettled: () => {\n      // trigger a refetch regardless if the mutation was successful or not\n      tsrQueryClient.invalidateQueries({ queryKey: ['posts'] });\n      //                 ^ QueryClient functions that do not consume or provide typed data are not wrapped by ts-rest\n      // and are provided at the root level only\n    },\n  });\n\n  if (isPending) {\n    return <div>Loading...</div>;\n  }\n\n  if (data?.status !== 200) {\n    return <div>Error</div>;\n  }\n\n  return (\n    <div>\n      <ul>\n        {data.body.map((post) => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n      <button onClick={() => mutate({ body: { title: 'Hello World' } })}>Create Post</button>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Contract for File Upload in ts-rest\nDESCRIPTION: Shows how to define a ts-rest contract that supports multipart/form-data for file uploads. The contract specifies a POST endpoint for updating a post's thumbnail with appropriate response types.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/form-data.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// contract.ts\n\nimport { initContract } from '@ts-rest/core';\n\nconst c = initContract();\n\nexport const postsContract = c.router({\n  updatePostThumbnail: {\n    method: 'POST',\n    path: '/posts/:id/thumbnail',\n    contentType: 'multipart/form-data', // <- Only difference\n    body: c.type<{ thumbnail: File }>(), // <- Use File type in here\n    responses: {\n      200: z.object({\n        uploadedFile: z.object({\n          name: z.string(),\n          size: z.number(),\n          type: z.string(),\n        }),\n      }),\n      400: z.object({\n        message: z.string(),\n      }),\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a ts-rest Client Implementation\nDESCRIPTION: Example of creating a client implementation using ts-rest. It shows how to instantiate a client with base URL and authorization header, and then make type-safe API calls with correct path parameters, query parameters, and body payloads.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/core/README.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initClient } from '@ts-rest/core';\n\nconst client = initClient(contract, {\n  baseUrl: 'https://jsonplaceholder.typicode.com',\n  baseHeaders: {\n    Authorization: 'Bearer token',\n  },\n});\n\nconst fetchPost = async () => {\n  const result = await client.getPost({\n    params: { id: '1' },\n  });\n\n  if (result.status === 200) {\n    return result.body;\n  }\n};\n\nconst fetchPosts = async () => {\n  const result = await client.getPosts({\n    query: { take: '10', skip: '0' },\n  });\n\n  if (result.status === 200) {\n    return result.body;\n  }\n};\n\nconst createPost = async () => {\n  const result = await client.createPost({\n    body: {\n      title: 'foo',\n      body: 'bar',\n      userId: '1',\n    },\n  });\n\n  if (result.status === 201) {\n    return result.body;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Using ts-rest with React Query Integration\nDESCRIPTION: Implements a client using ts-rest with React Query for type-safe API calls with caching and state management. Includes a React component example that uses the client to fetch and display data.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/quickstart.mdx#2025-04-17_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// client.ts\nimport { initQueryClient } from \"@ts-rest/react-query\";\n\n// `contract` is the AppRouter returned by `c.router`\nexport const client = initQueryClient(contract, {\n  baseUrl: 'http://localhost:3333',\n  baseHeaders: {},\n});\n\nexport const Index = () => {\n  const { data, isLoading, error } = client.getPost.useQuery([\"posts/1\"], {\n    params: { id: '1' },\n  });\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (data.status !== 200 || error) {\n    return <div>Error</div>;\n  }\n\n  return <div>{data.body.title}</div>;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Router with ts-rest for AWS Serverless\nDESCRIPTION: Example of defining a basic router implementation using ts-rest for AWS serverless functions, showing how to implement route handlers for getting and creating posts.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/routers.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tsr } from '@ts-rest/serverless/aws';\nimport { contract } from './contract';\n\nexport const postsRouter = tsr.router(contract.posts, {\n  getPosts: async () => {\n    return {\n      status: 200,\n      body: {\n        posts: [...],\n      },\n    };\n  },\n  createPost: async ({ body }) => {\n    return { \n      status: 201,\n      body: {\n        post: { ... },\n      },\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up Express with ts-rest\nDESCRIPTION: Demonstrates how to initialize an Express server with ts-rest, creating endpoints based on a contract definition. The example shows routing setup with a sample getPost implementation.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/express/express.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createExpressEndpoints, initServer } from '@ts-rest/express';\nimport * as express from 'express';\nimport * as bodyParser from 'body-parser';\nimport { contract } from './contract';\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.json());\n\nconst s = initServer();\nconst router = s.router(contract, {\n  getPost: async ({ params: { id } }) => {\n    const post = prisma.post.findUnique({ where: { id } });\n\n    return {\n      status: 200,\n      body: post ?? null,\n    };\n  },\n});\n\ncreateExpressEndpoints(contract, router, app);\n```\n\n----------------------------------------\n\nTITLE: Using Type-Safe QueryClient with React Components\nDESCRIPTION: Demonstrates a React component using ts-rest's type-safe QueryClient for fetching posts and creating new posts. Shows integration with React Query hooks and proper TypeScript typing for query data and mutations.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/query-client.md#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { tsr } from './tsr';\n\nconst Posts = () => {\n  const POSTS_QUERY_KEY = ['posts'];\n\n  const tsrQueryClient = tsr.useQueryClient();\n  const { data, isLoading } = tsr.posts.get.useQuery({ queryKey: POSTS_QUERY_KEY });\n  const { mutate } = tsr.posts.create.useMutation();\n\n  const createPost = async () => {\n    return mutate(\n      { body: { title: 'Hello World' } },\n      {\n        onSuccess: async (data) => {\n          //  this is typed ^\n          tsrQueryClient.posts.get.setQueryData(POSTS_QUERY_KEY, (oldPosts) => {\n            //                                     this is also typed ^\n            return {\n              ...oldPosts,\n              body: [...oldPosts.body, data.body],\n            };\n          });\n        },\n      },\n    );\n  };\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (data?.status !== 200) {\n    return <div>Error</div>;\n  }\n\n  return (\n    <div>\n      <button onClick={createPost}>Create Post</button>\n      {data.body.map((post) => (\n        <p key={post.id}>post.title</p>\n      ))}\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Prefetching Data with ts-rest in Next.js Pages Router\nDESCRIPTION: Example of using ts-rest with React Query in Next.js Pages Router to prefetch data during server-side rendering. It initializes a QueryClient, prefetches posts data, and returns the dehydrated state as props.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/ssr.md#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// pages/posts.tsx\nimport { dehydrate, QueryClient } from '@tanstack/react-query';\nimport { tsr } from './tsr';\n\nexport async function getServerSideProps() {\n  const tsrQueryClient = tsr.initQueryClient(new QueryClient());\n\n  await tsrQueryClient.getPosts.prefetchQuery({ queryKey: ['POSTS'] });\n\n  return {\n    props: {\n      dehydratedState: dehydrate(queryClient),\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Swagger UI with Express\nDESCRIPTION: This snippet shows how to serve a Swagger UI using swagger-ui-express in an Express application. It requires generating an OpenAPI document from a ts-rest contract and setting up the Swagger UI middleware.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/open-api.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { myContract } from './my-api';\nimport { generateOpenApi } from '@ts-rest/open-api';\nimport * as swaggerUi from 'swagger-ui-express';\n\nconst openApiDocument = generateOpenApi(myContract, {\n  info: {\n    title: 'Posts API',\n    version: '1.0.0',\n  },\n});\n\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(openApiDocument));\n```\n\n----------------------------------------\n\nTITLE: Implementing ts-rest with Express Server\nDESCRIPTION: Sets up an Express server with ts-rest integration for type-safe API routes. Includes body parsing, CORS setup, and handlers for getting and creating posts.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/quickstart.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\n\nimport { initServer } from '@ts-rest/express';\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.json());\n\nconst s = initServer();\n\nconst router = s.router(contract, {\n  getPost: async ({ params: { id } }) => {\n    const post = await prisma.post.findUnique({ where: { id } });\n\n    return {\n      status: 200,\n      body: post,\n    };\n  },\n  createPost: async ({ body }) => {\n    const post = await prisma.post.create({\n      data: body,\n    });\n\n    return {\n      status: 201,\n      body: post,\n    };\n  },\n});\n\ncreateExpressEndpoints(contract, router, app);\n\nconst port = process.env.port || 3333;\nconst server = app.listen(port, () => {\n  console.log(`Listening at http://localhost:${port}`);\n});\n```\n\n----------------------------------------\n\nTITLE: Prefetching Data with ts-rest in React Server Components\nDESCRIPTION: Example of using ts-rest with React Query in React Server Components to prefetch data during server-side rendering. It initializes a QueryClient, prefetches posts data, and renders a HydrationBoundary with the dehydrated state.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/ssr.md#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// app/posts/page.tsx\nimport { dehydrate, HydrationBoundary, QueryClient} from '@tanstack/react-query';\nimport { tsr } from './tsr';\n\nexport default async function PostsPage() {\n  const tsrQueryClient = tsr.initQueryClient(new QueryClient()); // <-- or pass a QueryClient from anywhere depending on your needs\n\n  await tsrQueryClient.getPosts.prefetchQuery({ queryKey: ['POSTS'] });\n\n  return (\n    <HydrationBoundary state={dehydrate(tsrQueryClient)}>\n      <Posts />\n    </HydrationBoundary>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a ts-rest Contract with Routes and Endpoints\nDESCRIPTION: Example showing how to create a ts-rest contract with different HTTP methods and typed request/response structures. The contract uses Zod schemas for input/output validation and demonstrates path parameters, query parameters, and body payloads.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/core/README.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initContract } from '@ts-rest/core';\nimport { z } from 'zod';\n\nconst c = initContract();\n\nconst postSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  body: z.string(),\n  userId: z.string(),\n});\n\nconst contract = c.router({\n  getPost: {\n    method: 'GET',\n    path: '/posts/:id',\n    pathParams: z.object({\n      id: z.string(),\n    }),\n    responses: {\n      200: postSchema,\n    },\n  },\n  getPosts: {\n    method: 'GET',\n    path: '/posts',\n    query: z.object({\n      take: z.string().transform(Number).optional(),\n      skip: z.string().transform(Number).optional(),\n    }),\n    responses: {\n      200: z.array(postSchema),\n    },\n  },\n  createPost: {\n    method: 'POST',\n    path: '/posts',\n    body: z.object({\n      title: z.string(),\n      body: z.string(),\n      userId: z.string(),\n    }),\n    responses: {\n      201: postSchema,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing ts-rest Contract in TypeScript\nDESCRIPTION: Demonstrates how to create a ts-rest contract for API endpoints, including method definitions, path specifications, response types, and query parameters using zod for validation.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/guides/without-backend.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\n\nexport const contract = c.router({\n  getPosts: {\n    method: 'GET',\n    path: '/posts',\n    responses: {\n      200: c.type<{ posts: Post[]; total: number }>(),\n    },\n    query: z.object({\n      take: z.string().transform(Number).optional(),\n      skip: z.string().transform(Number).optional(),\n      search: z.string().optional(),\n    }),\n    summary: 'Get all posts',\n  },\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring ts-rest Options in NestJS\nDESCRIPTION: Demonstrates how to configure ts-rest options at both controller and method levels using decorators, with method-level options overriding controller-level options.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/nest/nest.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TsRestHandler, tsRestHandler } from '@ts-rest/nest';\n\n@Controller()\n@TsRest({ jsonQuery: true })\nexport class MyController {\n  @TsRestHandler(c.getPost, { jsonQuery: false })\n  async getPost() {\n    return tsRestHandler(c.getPost, async () => {\n      // ...\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Parameters in ts-rest\nDESCRIPTION: Examples of implementing both basic and JSON query parameters in ts-rest contracts with type coercion and validation using Zod.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router({\n  getPosts: {\n    ...,\n    query: z.object({\n      take: z.coerce.number().default(10),\n      skip: z.coerce.number().default(0),\n      search: z.string().optional(),\n    }),\n  }\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router({\n  getPosts: {\n    ...,\n    // with `jsonQuery` enabled\n    query: z.object({\n      take: z.number().default(10),\n      skip: z.number().default(0),\n      filter: z\n        .object({\n          by: z.enum(['title', 'author', 'content']),\n          search: z.string(),\n        })\n        .optional(),\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Single Handler Approach in NestJS Controller\nDESCRIPTION: Demonstrates the single handler approach for ts-rest integration with NestJS, showing how to implement individual route handlers with full type safety. This approach allows for easy migration from legacy controllers and flexible route implementation.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/nest/nest.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TsRestHandler, tsRestHandler } from '@ts-rest/nest';\nimport { c } from './contract';\n\n@Controller()\nexport class MyController {\n  constructor(private readonly service: Service) {}\n\n  @TsRestHandler(c.getPost)\n  async getPost() {\n    return tsRestHandler(c.getPost, async ({ params }) => {\n      const post = await this.service.getPost(params.id);\n\n      if (!post) {\n        return { status: 404, body: null };\n      }\n\n      return { status: 200, body: post };\n    });\n  }\n\n  @TsRestHandler(c.getPosts)\n  async getPosts() {\n    return tsRestHandler(c.getPosts, async () => {\n      const posts = await this.service.getPosts();\n\n      return { status: 200, body: posts };\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Axios as a Custom API in ts-rest Client\nDESCRIPTION: Demonstrates how to replace the default fetch implementation with Axios. This example creates a custom API function that uses Axios for HTTP requests and properly handles responses and errors.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/custom.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport axios, { Method, AxiosError, AxiosResponse, isAxiosError } from 'axios';\nimport { initClient } from '@ts-rest/core';\nimport { contract } from './contract';\n\nconst client = initClient(contract, {\n  baseUrl: 'http://localhost:3333/api',\n  baseHeaders: {\n    'Content-Type': 'application/json',\n  },\n  api: async ({ path, method, headers, body }) => {\n    const baseUrl = 'http://localhost:3333/api'; //baseUrl is not available as a param, yet\n    try {\n      const result = await axios.request({\n        method: method as Method,\n        url: `${this.baseUrl}/${path}`,\n        headers,\n        data: body,\n      });\n      return { status: result.status, body: result.data, headers: result.headers };\n    } catch (e: Error | AxiosError | any) {\n      if (isAxiosError(e)) {\n        const error = e as AxiosError;\n        const response = error.response as AxiosResponse;\n        return { status: response.status, body: response.data, headers: response.headers };\n      }\n      throw e;\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Response Status Codes in ts-rest Router Contract\nDESCRIPTION: Example of defining a router contract with multiple response status codes (200 and 400) for an updateUser endpoint. This demonstrates how to specify different response types for success and error cases.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/errors.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const routerBasic = c.router({\n  updateUser: {\n    method: 'PATCH',\n    path: `/basic/users/:id`,\n    response: {\n      200: c.type<User>(),\n      400: c.type<{ message: string }>(),\n    },\n    body: c.type<{ name: string | null; email: string | null }>(),\n    summary: 'Update a user',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Response Types in ts-rest\nDESCRIPTION: Shows how to define different types of responses including JSON and plain text, with status codes and content types.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\n\nexport const contract = c.router({\n  createPost: {\n    ...,\n    responses: {\n      201: z.object({\n        id: z.string(),\n        title: z.string(),\n        content: z.string(),\n        published: z.boolean(),\n        description: z.string(),\n      }),\n      404: c.type<{ message: string }>(),\n      500: c.otherResponse({\n        contentType: 'text/plain',\n        body: z.literal('Server Error'),\n      })\n    },\n    ...,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Authentication with Firebase in ts-rest Client\nDESCRIPTION: Shows how to create a ts-rest client that dynamically fetches authentication tokens at runtime. This example uses Firebase authentication to get a token when making requests.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/custom.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport axios, { Method, AxiosError, AxiosResponse, isAxiosError } from 'axios';\nimport { initClient } from '@ts-rest/core';\nimport { contract } from './contract';\n\nexport class SampleAPI {\n  authInstance: Auth;\n  constructor(params: { authInstance: Auth }) {\n    this.authInstance = params.authInstance;\n  }\n  client = () => {\n    return initClient(contract, {\n      baseUrl: '',\n      baseHeaders: {\n        'Content-Type': 'application/json',\n      },\n      api: async ({ path, method, headers, body }) => {\n        const idToken = await this.authInstance.currentUser.getIdToken();\n        try {\n          const result = await axios.request({\n            method: method as Method,\n            url: `${this.baseUrl}/${path}`,\n            headers: {\n              ...headers,\n              Authorization: `Bearer ${idToken}`,\n            },\n            data: body,\n          });\n          return { status: result.status, body: result.data, headers: result.headers };\n        } catch (e: Error | AxiosError | any) {\n          if (isAxiosError(e)) {\n            const error = e as AxiosError;\n            const response = error.response as AxiosResponse;\n            return { status: response.status, body: response.data, headers: response.headers };\n          }\n          throw e;\n        }\n      },\n    });\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Azure Function Handler with ts-rest in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an Azure Function handler using ts-rest. It imports necessary modules, creates a handler, and registers it with the Azure Functions app.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/azure-functions.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { app } from '@azure/functions';\nimport { createAzureFunctionHandler } from '@ts-rest/serverless/azure';\nimport { contract } from './contract';\nimport { router } from './router';\n\nconst handler = createAzureFunctionHandler(contract, router, {\n  // options\n});\n\n// This will register a single function handler for the handler\napp.http('api', {\n  // Be sure to include any method that the router requires\n  methods: ['POST', 'PATCH', 'DELETE', 'GET'],\n  authLevel: 'anonymous',\n  route: '{*route}',\n  handler,\n});\n```\n\n----------------------------------------\n\nTITLE: Using ts-rest with Advanced Configuration Options\nDESCRIPTION: Example showing advanced configuration options for ts-rest, including custom response validation, error handling, and request timeouts. Demonstrates how to fine-tune the client behavior for specific requirements.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/core/README.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initClient } from '@ts-rest/core';\n\nconst client = initClient(contract, {\n  baseUrl: 'https://api.example.com',\n  baseHeaders: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json',\n  },\n  // Configure custom validation behavior\n  validateResponse: true,\n  throwOnUnknownStatus: true,\n  // Configure timeout settings\n  timeoutMs: 10000,\n  // Add custom request modifiers\n  requestTransformer: (request) => {\n    // Add timestamp to every request\n    return {\n      ...request,\n      headers: {\n        ...request.headers,\n        'X-Request-Time': new Date().toISOString(),\n      },\n    };\n  },\n  // Add response transformation\n  responseTransformer: (response, apiContext) => {\n    // Log all responses\n    console.log(`${apiContext.method} ${apiContext.path} - Status: ${response.status}`);\n    return response;\n  },\n  // Custom error handler\n  onError: (error, apiContext) => {\n    console.error(`API Error: ${apiContext.method} ${apiContext.path}`, error);\n    // You could also report to monitoring services here\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Response Handlers in ts-rest Serverless with TypeScript\nDESCRIPTION: Demonstrates how to set up global response handlers in a ts-rest serverless setup. The example includes a request middleware to set a timestamp and a response handler to log the request duration.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/options.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler, tsr } from '@ts-rest/serverless/fetch';\nimport { contract } from './contract';\nimport { router } from './router';\n\nexport default async (request: Request) => {\n  return fetchRequestHandler({\n    request,\n    contract,\n    router,\n    options: {\n      requestMiddleware: [\n        tsr.middleware<{ time: Date }>((request) => {\n          request.time = new Date();\n        }),\n      ],\n      responseHandlers: [\n        (response, request) => {\n          console.log('Request took', new Date().getTime() - request.time.getTime(), 'ms');\n        },\n      ],\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Multiple Posts with useQueries in ts-rest\nDESCRIPTION: This example demonstrates how to fetch multiple posts by their IDs using the useQueries hook from ts-rest. It maps over an array of IDs to create multiple queries, then combines the results to track loading state and aggregate the data. The component displays a loading indicator while fetching and renders the post titles when data is available.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/use-queries.md#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { tsr } from './tsr';\n\nconst Posts = ({ ids }: { ids: string[] }) => {\n  const { data, pending } = tsr.posts.get.useQueries({\n    queries: ids.map((id) => ({\n      queryKey: ['posts', id],\n      queryData: {\n        params: { id }\n      },\n    })),\n    combine: (results) => {\n      return {\n        data: results.map((result) => result.data),\n        pending: results.some((result) => result.isPending),\n      }\n    },\n  });\n  \n  if (pending) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div>\n      {queries.map((query) => (\n        <p key={query.data?.body.id}>{query.data?.body.title}</p>\n      ))}\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Serving Swagger UI with NestJS\nDESCRIPTION: This snippet demonstrates how to serve a Swagger UI in a NestJS application using @nestjs/swagger. It shows how to generate an OpenAPI document from a ts-rest contract and set up the Swagger UI at a specific endpoint.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/open-api.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { myContract } from './my-api';\nimport { generateOpenApi } from '@ts-rest/open-api';\nimport { NestFactory } from '@nestjs/core';\nimport { SwaggerModule } from '@nestjs/swagger';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  const document = generateOpenApi(myContract, {\n    info: {\n      title: 'Posts API',\n      version: '1.0.0',\n    },\n  });\n\n  SwaggerModule.setup('api-docs', app, document);\n  //                   ^ Path for swagger\n\n  await app.listen(3000);\n}\nbootstrap();\n```\n\n----------------------------------------\n\nTITLE: Initializing and Implementing a ts-rest Router with Fastify\nDESCRIPTION: Sets up a Fastify server with ts-rest integration, implementing route handlers for getting and creating posts. The example demonstrates how to initialize the server, create a router with handlers for contract endpoints, and start the server.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/fastify.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport Fastify from 'fastify';\nimport { initServer } from '@ts-rest/fastify';\n\nconst app = Fastify();\n\nconst s = initServer();\n\nconst router = s.router(contract, {\n  getPost: async ({ params: { id } }) => {\n    const post = await prisma.post.findUnique({ where: { id } });\n\n    return {\n      status: 200,\n      body: post,\n    };\n  },\n  createPost: async ({ body }) => {\n    const post = await prisma.post.create({\n      data: body,\n    });\n\n    return {\n      status: 201,\n      body: post,\n    };\n  },\n});\n\napp.register(s.plugin(router));\n\nconst start = async () => {\n  try {\n    await app.listen({ port: 3000 });\n  } catch (err) {\n    app.log.error(err);\n    process.exit(1);\n  }\n};\n\nstart();\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom API Implementation to ts-rest Client\nDESCRIPTION: Demonstrates how to create a custom API implementation by wrapping the default tsRestFetchApi. This allows adding custom logic like logging while reusing the built-in fetch functionality.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/custom.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initClient, tsRestFetchApi } from '@ts-rest/core';\nimport { contract } from './contract';\n\nconst client = initClient(contract, {\n  baseUrl: 'http://localhost:5003',\n  baseHeaders: {},\n  api: async (args) => {\n    // Add anything you want here!\n\n    return tsRestFetchApi(args);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Inferring Response Types in TypeScript using ts-rest\nDESCRIPTION: Demonstrates how to use ServerInferResponses to infer response types from a contract or specific endpoint. This is useful for typing HTTP calls and service functions.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/infer-types.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ServerInferResponses } from '@ts-rest/core';\nimport { contract } from './contract';\n\ntype ResponseShapes = ServerInferResponses<typeof contract>;\n\nasync function someHttpCall(req: Request): Promise<ResponseShapes['getPosts']> {\n  return ...;\n}\n\nfunction someServiceCall(): ServerInferResponses<typeof contract.getPosts> {\n  return ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Using ts-rest Router with Type Extension for Middleware\nDESCRIPTION: Example of defining a router with explicit type extensions for preserving type inference when using middleware that modifies the request object. Shows how to make custom properties like userId visible in request handlers.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/routers.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tsr } from '@ts-rest/serverless/aws';\nimport { contract } from './contract';\n\nexport const postsRouter = tsr.routerWithMiddleware(contract)<\n  { userId: string } // <-- Add the extended part here. This will be visible in request.userId\n>({ ... });\n```\n\n----------------------------------------\n\nTITLE: Creating Next.js API Route with ts-rest Router\nDESCRIPTION: Demonstrates how to create a Next.js API route using ts-rest contract and router. Shows implementation of posts endpoints and router initialization.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/next.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// pages/api/[...ts-rest].tsx\nimport { createNextRoute, createNextRouter } from '@ts-rest/next';\n\n// `contract` is the AppRouter returned by `c.router`\nconst postsRouter = createNextRoute(contract.posts, {\n  createPost: async (args) => {\n    const newPost = await posts.createPost(args.body);\n\n    return {\n      status: 201,\n      body: newPost,\n    };\n  },\n});\n\nconst router = createNextRoute(contract, {\n  posts: postsRouter,\n});\n\n// Actually initiate the collective endpoints\nexport default createNextRouter(contract, router);\n```\n\n----------------------------------------\n\nTITLE: Generating an OpenAPI Document with ts-rest\nDESCRIPTION: This snippet demonstrates how to generate an OpenAPI document from a ts-rest contract using the generateOpenApi function. It requires the contract to be imported and minimal configuration for the OpenAPI info object.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/open-api.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { myContract } from './my-api';\nimport { generateOpenApi } from '@ts-rest/open-api';\n\nconst openApiDocument = generateOpenApi(myContract, {\n  info: {\n    title: 'Posts API',\n    version: '1.0.0',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Server Router with ts-rest\nDESCRIPTION: Example demonstrating how to implement the API contract on the server side using ts-rest's router. Shows type-safe request handling with Prisma integration.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/README.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst router = s.router(contract, {\n  getPosts: async ({ params: { id } }) => {\n    return {\n      status: 200,\n      body: prisma.post.findUnique({ where: { id } }),\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Response Status in ts-rest Client\nDESCRIPTION: Shows how to check the response status and handle success or failure cases when using the ts-rest client.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/fetch.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = await client.posts.create({\n  body: {\n    title: 'My Post',\n    content: 'This is my post',\n  },\n});\n\nif (data.status === 200) {\n  console.log('Success');\n} else {\n  console.log('Something went wrong');\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming ts-rest Contract with React Query in TSX\nDESCRIPTION: Illustrates how to use the ts-rest contract with react-query to create a typed client for API calls, including setting up the client and using it in a React component.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/guides/without-backend.mdx#2025-04-17_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { contract } from './contract';\n\nexport const client = initQueryClient(contract, {\n  baseUrl: 'http://localhost:3333',\n  baseHeaders: {},\n});\n\nconst YourComponent = () => {\n  const queryResult = client.getPosts.useQuery(\n    ['posts'], // <- queryKey\n    { query: { take: 10 } }, // <- Query params, Params, Body etc (all typed)\n    { staleTime: 1000 } // <- react-query options (optional)\n  );\n\n  // ... use the query result\n};\n```\n\n----------------------------------------\n\nTITLE: Serving Swagger UI with Fastify\nDESCRIPTION: This snippet shows how to serve a Swagger UI in a Fastify application using @fastify/swagger and @fastify/swagger-ui. It generates an OpenAPI document from a ts-rest contract and registers the Swagger plugins with Fastify.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/open-api.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { myContract } from './my-api';\nimport { generateOpenApi } from '@ts-rest/open-api';\nimport fastifySwagger from '@fastify/swagger';\nimport fastifySwaggerUI from '@fastify/swagger-ui';\n\nconst openApiDocument = generateOpenApi(myContract, {\n  info: {\n    title: 'Posts API',\n    version: '1.0.0',\n  },\n});\n\napp.register(fastifySwagger, {\n  transformObject: () => openApiDocument\n})\n.register(fastifySwaggerUI, {\n  routePrefix: '/api-docs',\n});\n```\n\n----------------------------------------\n\nTITLE: Client-Side File Upload Implementation with React\nDESCRIPTION: Demonstrates how to implement a client-side file upload component in React using ts-rest. It includes a file input and handles the upload through the ts-rest client with type-safe objects.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/form-data.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// client.ts\n\nconst App = () => {\n  const [thumbnail, setThumbnail] = React.useState<File | null>(null);\n\n  return (\n    <div>\n      <input\n        multiple={false}\n        type=\"file\"\n        onChange={(e) => setThumbnail(e.target.files?.[0] || null)}\n      />\n      <button\n        onClick={() => {\n          if (file) {\n            apiClient.uploadFile({\n              body: {\n                thumbnail: file, // <- typed body with \"File\" type\n              },\n            });\n          }\n        }}\n      >\n        Upload\n      </button>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Per-Route Middleware in ts-rest Serverless with TypeScript\nDESCRIPTION: Shows how to set up middleware for individual routes in a ts-rest serverless handler. The example demonstrates adding authentication middleware to a specific route.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/options.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler } from '@ts-rest/serverless/fetch';\nimport { contract } from './contract';\n\nexport default async (request: Request) => {\n  return fetchRequestHandler({\n    request,\n    contract,\n    router: {\n      getPost: {\n        middleware: [authenticationMiddleware],\n        handler: async ({ params: { id } }, { request }) => {\n          const post = prisma.post.findUniqueOrThrow({ where: { id, ownerId: request.userId } });\n\n          return {\n            status: 200,\n            body: post,\n          };\n        },\n      }\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Response Validation in ts-rest\nDESCRIPTION: Demonstrates how to enable response validation in ts-rest, ensuring that the server response matches the defined schema and applying any transformations.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/fetch.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router({\n  method: 'GET',\n  path: '/post/:id',\n  responses: {\n    200: z.object({\n      id: z.string(),\n      createdAt: z.coerce.date(),\n    }),\n  },\n});\n\nconst client = initClient(contract, { validateResponse: true });\nconst response = await client.getPost({ id: '1' });\n// response will be validated against the response schema\nif (response.status === 200) {\n  // response.data will be of type { id: string, createdAt: Date }\n  // because `createdAt` has transformation of `z.coerce.date()`, it will parse any string date into a Date object\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ts-rest Next.js Handler\nDESCRIPTION: Shows how to create a Next.js handler for both App Router and Pages Router environments using ts-rest. The handler must be placed in a catch-all route file following specific naming patterns.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/next-serverless.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createNextHandler } from '@ts-rest/serverless/next';\nimport { contract } from './contract';\nimport { router } from './router';\n\nexport const handler = createNextHandler(\n  contract,\n  router,\n  {\n    handlerType: 'app-router',\n    // handlerType: 'pages-router-edge',\n    \n    // rest of options\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Route-Specific Middleware in ts-rest with Express\nDESCRIPTION: Demonstrates how to add middleware for a specific route in ts-rest. The middleware has access to typed contract information and runs before the route handler. Shows implementation of a simple logging middleware for a getPost route.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/express/middleware.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initServer } from '@ts-rest/express';\nimport { contract } from './contract';\n\nconst s = initServer();\n\nconst router = s.router(contract, {\n  getPost: {\n    middleware: [\n      (req, res, next) => {\n        // req.tsRestRoute is typed as the contract route\n        console.log('Called: ', req.tsRestRoute.method, req.tsRestRoute.path);\n        // prints: Called: GET /posts/:id\n        next();\n      }\n    ],\n    handler: async ({ params: { id } }) => {\n      const post = prisma.post.findUnique({ where: { id } });\n\n      return {\n        status: 200,\n        body: post ?? null,\n      };\n    }\n  },\n});\n\ncreateExpressEndpoints(contract, router, app);\n```\n\n----------------------------------------\n\nTITLE: Implementing Fully Type-Safe Error Handling in React Component with ts-rest and React Query\nDESCRIPTION: This code snippet shows how to implement fully type-safe error handling in a React component using ts-rest and React Query. It demonstrates the use of various type guard functions like isFetchError, isUndefinedErrorResponse, and exhaustiveGuard for comprehensive error handling.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/error-handling.md#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { isFetchError, isUndefinedErrorResponse, exhaustiveGuard } from '@ts-rest/react-query/v5';\nimport { tsr } from './tsr';\n\nconst Post = ({ id }: { id: string }) => {\n  const { data, error, isPending, contractEndpoint } = tsr.getPost.useQuery({\n    queryKey: ['posts', id],\n    queryData: {\n      params: { id },\n    },\n  });\n\n  if (isPending) {\n    return <div>Loading...</div>;\n  }\n\n  if (error) {\n    if (isFetchError(error)) {\n      return <div>We could not retrieve this post. Please check your internet connection.</div>;\n    }\n    \n    if (isUndefinedErrorResponse(error, contractEndpoint)) {\n      return <div>Unexpected error occurred</div>;\n    }\n\n    if (error.status === 404) {\n      return <div>Post not found</div>;\n    }\n\n    // this should be unreachable code if you handle all possible error cases\n    // if not, you will get a compile-time error on the line below\n    return exhaustiveGuard(error);\n  }\n\n  return (\n    <div>\n      <h1>{data.body.title}</h1>\n      <p>{data.body.content}</p>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Query Usage with ts-rest and React Query\nDESCRIPTION: Demonstrates basic usage of ts-rest with React Query, showing typed response data, error handling, and query parameters.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v5-setup.mdx#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst {\n  data,                   // <- fully typed response data\n  error,                  // <- fully typed error data\n} = tsr.getPost.useQuery({\n  queryKey: ['posts'],\n  queryData: {            // <- fully typed request data\n    params: { id: '1' },\n  },\n  staleTime: 1000,        // <- react-query options (optional)\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Request Validation in a Nest.js Controller with ts-rest\nDESCRIPTION: Example of how to disable request validation for body, query, and headers in a Nest.js controller using ts-rest. The code demonstrates how to configure validation settings and manually handle validation if needed.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/nest/configuration.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TsRestHandler, tsRestHandler } from '@ts-rest/nest';\n\n@Controller()\nexport class MyController {\n  constructor() {}\n\n  @TsRestHandler(c.getPost, {\n    validateRequestBody: false,\n    validateRequestQuery: false,\n    validateRequestHeaders: false\n  })\n  async getPost() {\n    return tsRestHandler(c.getPost, async ({ query, body }) => {\n      const isQueryValid = querySchema.safeParse(query);\n      console.log(isQueryValid) // => { success: false; error: ZodError }\n\n      const isBodyValid = bodySchema.safeParse(body);\n      console.log(isBodyValid) // => { success: true; data: {...} }\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating OpenAPI Documentation from TypeScript Contracts with ts-rest\nDESCRIPTION: This snippet demonstrates how to generate an OpenAPI specification from a ts-rest contract. It imports a contract and uses the generateOpenApi function to create an OpenAPI document with specified metadata. This generated document can then be used with tools like Swagger Codegen to create client libraries for non-TypeScript environments.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/guides/non-ts-clients.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { myContract } from './my-api';\nimport { generateOpenApi } from '@ts-rest/open-api';\n\nconst openApiDocument = generateOpenApi(myContract, {\n  info: {\n    title: 'Posts API',\n    version: '1.0.0',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Vue Component with Query Implementation\nDESCRIPTION: Complete Vue component example showing usage of useQuery and useMutation hooks.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/vue-query.mdx#2025-04-17_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <div class=\"App\">\n    <h1>Posts from posts-service</h1>\n\n    <div v-if=\"isLoading\">Loading...</div>\n    <div v-if=\"error\">Error: {{ error }}</div>\n\n    <div v-if=\"data\">\n      <div v-for=\"post in data.body\" :key=\"post.id\">\n        <h2>{{ post.title }}</h2>\n        <p>{{ post.content }}</p>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\n  // Effectively a useQuery hook\n  const { data, error, isLoading } = client.getPosts.useQuery(['posts']);\n\n  // Effectively a useMutation hook\n  const { mutate, isLoading } = client.posts.create.useMutation();\n</script>\n```\n\n----------------------------------------\n\nTITLE: Defining Nested ts-rest Contracts and Routers\nDESCRIPTION: Example demonstrating how to structure complex APIs with nested contracts in ts-rest. Shows the organization of API endpoints into logical groups and how to maintain type safety across nested structure.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/core/README.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initContract } from '@ts-rest/core';\nimport { z } from 'zod';\n\nconst c = initContract();\n\nconst postSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  body: z.string(),\n  userId: z.string(),\n});\n\nconst commentSchema = z.object({\n  id: z.string(),\n  postId: z.string(),\n  name: z.string(),\n  email: z.string(),\n  body: z.string(),\n});\n\nconst postsContract = c.router({\n  getPost: {\n    method: 'GET',\n    path: '/posts/:id',\n    pathParams: z.object({\n      id: z.string(),\n    }),\n    responses: {\n      200: postSchema,\n    },\n  },\n  getPosts: {\n    method: 'GET',\n    path: '/posts',\n    responses: {\n      200: z.array(postSchema),\n    },\n  },\n});\n\nconst commentsContract = c.router({\n  getComment: {\n    method: 'GET',\n    path: '/comments/:id',\n    pathParams: z.object({\n      id: z.string(),\n    }),\n    responses: {\n      200: commentSchema,\n    },\n  },\n  getComments: {\n    method: 'GET',\n    path: '/comments',\n    query: z.object({\n      postId: z.string().optional(),\n    }),\n    responses: {\n      200: z.array(commentSchema),\n    },\n  },\n});\n\nconst apiContract = c.router({\n  posts: postsContract,\n  comments: commentsContract,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Basic AWS Lambda Handler with ts-rest\nDESCRIPTION: Basic setup for creating an AWS Lambda handler using ts-rest that can process API Gateway v1 or v2 events. This handler connects a contract definition with a router implementation.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/aws.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createLambdaHandler } from '@ts-rest/serverless/aws';\nimport { contract } from './contract';\nimport { router } from './router';\n\nexport const handler = createLambdaHandler(\n  contract,\n  router,\n  {\n    // options\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Throwing Type-Safe Errors with ts-rest\nDESCRIPTION: Shows how to throw type-safe errors using TsRestException, maintaining contract typing while providing a cleaner error handling approach.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/nest/nest.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nthrow new TsRestException(contract.test, {\n  status: 400,\n  body: { code: 'UserAlreadySignedUp', message: 'User has already signed up' },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Cloudflare Workers Handler\nDESCRIPTION: Shows how to implement a Cloudflare Workers handler with KV namespace support and worker-specific context types. Includes type definitions and request handling setup.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/fetch-runtimes.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Request as WorkerRequest, ExecutionContext, KVNamespace } from '@cloudflare/workers-types/experimental';\nimport { fetchRequestHandler, tsr } from '@ts-rest/serverless/fetch';\nimport { contract } from './contract';\n\ninterface Env {\n  MY_KV_NAMESPACE: KVNamespace;\n}\n\nconst router = tsr\n  .platformContext<{\n    workerRequest: WorkerRequest;\n    workerEnv: Env;\n    workerContext: ExecutionContext\n  }>()\n  .router(contract, {\n    getPost: async ({ params: { id } }, { workerRequest, workerEnv, workerContext }) => {\n      return {\n        status: 200,\n        body: {\n          id: id,\n          title: await workerEnv.MY_KV_NAMESPACE.get(`post_${id}`),\n          country: workerRequest.cf?.country,\n        },\n      };\n    },\n  });\n\nexport default {\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n    return fetchRequestHandler({\n      request,\n      contract,\n      router,\n      platformContext: {\n        workerRequest: request as unknown as WorkerRequest,\n        workerEnv: env,\n        workerContext: ctx,\n      },\n    });\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Default ts-rest Client with Fetch\nDESCRIPTION: Creates a basic ts-rest client using the default fetch implementation. The client is configured with a base URL and optional base headers.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/custom.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initClient } from '@ts-rest/core';\nimport { contract } from './contract';\n\nconst client = initClient(contract, {\n  baseUrl: 'http://localhost:5003',\n  baseHeaders: {},\n  // Uses `tsRestFetchApi` by default\n});\n```\n\n----------------------------------------\n\nTITLE: Infinite Query Implementation\nDESCRIPTION: Implementation of infinite query pagination with cursor-based example\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v4.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst { isLoading, data, hasNextPage, fetchNextPage } = useInfiniteQuery(\n  queryKey,\n  ({ pageParam = 1 }) => pageParam,\n  {\n    getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,\n    getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Strict Status Codes in ts-rest\nDESCRIPTION: Shows how to enable strict status code checking globally and per-route in ts-rest contracts.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router(\n  {\n    // ...endpoints\n  },\n  {\n    strictStatusCodes: true,\n  }\n);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router({\n  getPosts: {\n    ...,\n    strictStatusCodes: true,\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Netlify Functions Handler\nDESCRIPTION: Demonstrates implementation of a Netlify Functions handler with access to Netlify-specific context information. Shows how to handle requests and access IP information.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/fetch-runtimes.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Context } from '@netlify/functions';\nimport { fetchRequestHandler, tsr } from '@ts-rest/serverless/fetch';\nimport { contract } from './contract';\n\nconst router = tsr\n  .platformContext<{ netlifyContext: Context }>()\n  .router(contract, {\n    getPost: async ({ params: { id } }, { netlifyContext }) => {\n      return {\n        status: 200,\n        body: {\n          id: id,\n          title: 'Hello, World!',\n          ip: netlifyContext.ip,\n        },\n      };\n    },\n  });\n\nexport default async (request: Request, netlifyContext: Context) => {\n  return fetchRequestHandler({\n    request,\n    contract,\n    router,\n    platformContext: {\n      netlifyContext,\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a ts-rest Client with Predefined Authentication Token\nDESCRIPTION: Demonstrates how to create a class that provides a ts-rest client with authentication tokens. The token is passed in during instantiation and used for all requests.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/custom.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport axios, { Method, AxiosError, AxiosResponse, isAxiosError } from 'axios';\nimport { initClient } from '@ts-rest/core';\nimport { contract } from './contract';\n\nexport class SampleAPI {\n  token: string;\n  constructor(params: { token: string }) {\n    this.token = params.token;\n    this.baseUrl = 'http://localhost:3333/api';\n  }\n  client = () => {\n    return initClient(contract, {\n      baseUrl: this.baseUrl,\n      baseHeaders: {\n        Authorization: `Bearer ${idToken}`,\n        'Content-Type': 'application/json',\n      },\n      api: async ({ path, method, headers, body }) => {\n        try {\n          const result = await axios.request({\n            method: method as Method,\n            url: `${this.baseUrl}/${path}`,\n            headers,\n            data: body,\n          });\n          return { status: result.status, body: result.data, headers: result.headers };\n        } catch (e: Error | AxiosError | any) {\n          if (isAxiosError(e)) {\n            const error = e as AxiosError;\n            const response = error.response as AxiosResponse;\n            return { status: response.status, body: response.data, headers: response.headers };\n          }\n          throw e;\n        }\n      },\n    });\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Credentials for Cross-Origin Requests in ts-rest\nDESCRIPTION: Demonstrates how to configure the ts-rest client to send cookies in cross-origin requests by setting the credentials option.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/fetch.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = initClient(contract, {\n  baseUrl: 'http://localhost:3333/api',\n  baseHeaders: {},\n  credentials: 'include',\n});\n```\n\n----------------------------------------\n\nTITLE: Cursor-Based Infinite Query\nDESCRIPTION: Implementation of infinite query using cursor-based pagination.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/vue-query.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst { isLoading, data, hasNextPage, fetchNextPage } = useInfiniteQuery(\n  queryKey,\n  ({ pageParam = 1 }) => pageParam,\n  {\n    getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,\n    getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Inferring Response Body in React with ts-rest\nDESCRIPTION: Shows how to use ClientInferResponseBody to infer the response body type for a specific endpoint and status code. This is useful for typing props in React components.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/infer-types.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport React from 'react';\nimport { ClientInferResponseBody } from '@ts-rest/core';\nimport { contract } from './contract';\n\ntype Post = ClientInferResponseBody<typeof contract.getPost, 200>;\n\nfunction PostComponent(props: { post: Post }) {\n  return <>...</>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multi Handler Approach in NestJS Controller\nDESCRIPTION: Shows the multi handler approach which provides enhanced type safety by requiring implementation of all routes in a contract. This approach is ideal for functional programming styles and ensures correct response types.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/nest/nest.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TsRestHandler, tsRestHandler } from '@ts-rest/nest';\nimport { c } from './contract';\n\n@Controller()\nexport class MyController {\n  constructor(private readonly service: Service) {}\n\n  @TsRestHandler(c)\n  async handler() {\n    return tsRestHandler(c, {\n      getPost: async ({ params }) => {\n        const post = await this.service.getPost(params.id);\n\n        if (!post) {\n          return { status: 404, body: null };\n        }\n\n        return { status: 200, body: post };\n      },\n      getPosts: async () => {\n        const posts = await this.service.getPosts();\n\n        return { status: 200, body: posts };\n      },\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Object in Next.js Handler\nDESCRIPTION: Demonstrates how to use the Next.js-specific context object within a ts-rest handler, including access to the NextRequest object and response headers manipulation.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/next-serverless.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createNextHandler } from '@ts-rest/serverless/next';\nimport { contract } from './contract';\n\nexport const handler = createNextHandler(\n  contract,\n  {\n    getPost: async ({ params: { id } }, { nextRequest, responseHeaders }) => {\n      responseHeaders.set('x-geo-country', nextRequest.geo.country);\n      \n      return {\n        status: 200,\n        body: {\n          id,\n          title: 'Hello, World!',\n        },\n      };\n    },\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Regular Query and Mutation Examples\nDESCRIPTION: Examples of using regular queries and mutations without hooks.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/vue-query.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Normal fetch\nconst { body, status } = await client.posts.get.query();\n\n// useQuery hook\nconst { data, isLoading } = client.posts.get.useQuery();\n```\n\n----------------------------------------\n\nTITLE: Using Custom Arguments in ts-rest Client Requests\nDESCRIPTION: Demonstrates how to use custom arguments when making requests with the extended ts-rest client. The custom arguments are passed alongside standard request parameters.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/custom.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nclient.getPosts({\n  query: { skip: 0, take: 10 },\n  myCustomArg: 'hello',\n  // ^-- autocomplete will work here, allowing you to extend ts-rest however you want\n});\n```\n\n----------------------------------------\n\nTITLE: Inferring Request Types in TypeScript using ts-rest\nDESCRIPTION: Illustrates how to use ServerInferRequest and ServerInferResponses to infer request and response types for a specific endpoint. This is useful for typing lambda handlers or API functions.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/infer-types.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ServerInferRequest, ServerInferResponses } from '@ts-rest/core';\nimport { contract } from './contract';\n\ntype GetPostRequest = ServerInferRequest<typeof contract.getPost>;\ntype GetPostResponse = ServerInferResponses<typeof contract.getPost>;\n\nasync function getPostLambdaHandler({ params, query }: GetPostRequest): Promise<GetPostResponse> {\n  return ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Extending ts-rest Client with Custom Arguments\nDESCRIPTION: Shows how to extend the ts-rest client's API fetcher with custom arguments. This provides type-safe custom parameters that can be used when making requests, with full IDE autocomplete support.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/custom.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = initClient(contract, {\n  baseUrl: 'http://localhost:5003',\n  baseHeaders: {},\n  api: async (args: ApiFetcherArgs & { myCustomArg?: string }) => {\n    if (args.myCustomArg) {\n      // do something with myCustomArg \n    }\n\n    return tsRestFetchApi(args);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Single Route Handler in Next.js\nDESCRIPTION: Shows how to create a handler for a single contract route using createSingleRouteHandler function.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/next.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// pages/api/posts/index.tsx\nimport { createSingleRouteHandler } from '@ts-rest/next';\n\nexport default createSingleRouteHandler(api.posts.createPost, async (args) => {\n  const newPost = await posts.createPost(args.body);\n\n  return {\n    status: 201,\n    body: newPost,\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: JSON Query Configuration\nDESCRIPTION: Example of configuring the client to use JSON-encoded query parameters instead of URL encoding.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/vue-query.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport const client = initQueryClient(router, {\n  ...,\n  jsonQuery: true\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Platform Context Router in TypeScript\nDESCRIPTION: Demonstrates how to set up a basic router with custom platform context using ts-rest. The example shows handling a getPost endpoint with access to platform-specific context.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/fetch-runtimes.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler, tsr } from '@ts-rest/serverless/fetch';\nimport { contract } from './contract';\n\nexport const router = tsr\n  .platformContext<{ customContext: PlatformContext }>()\n  .router(contract, {\n    getPost: async ({ params: { id } }, { customContext }) => {\n      console.log(platformContext);\n      return {\n        status: 200,\n        body: {\n          id: id,\n          title: 'Hello, World!',\n        },\n      };\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Basic Query and Mutation Usage\nDESCRIPTION: Example of using useQuery and useMutation hooks with error handling\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v4.mdx#2025-04-17_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst App = () => {\n  // Effectively a useQuery hook\n  const { data, isLoading, error } = client.posts.get.useQuery(['posts']);\n\n  // Effectively a useMutation hook\n  const { mutate, isLoading } = client.posts.create.useMutation();\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (data?.status !== 200) {\n    return <div>Error</div>;\n  }\n\n  return (\n    <div>\n      {data.body.map((post) => (\n        <p key={post.id}>post.title</p>\n      ))}\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Adding JSDoc Documentation to ts-rest Contracts\nDESCRIPTION: Example of adding JSDoc documentation to contract types for better IntelliSense support.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\n\nexport const contract = c.router({\n  getPosts: {\n    method: 'GET',\n    path: '/posts',\n    responses: {\n      200: c.type<{ posts: Post[]; total: number }>(),\n    },\n    query: z.object({\n      /**\n       * @type {string} - UTC timestamp in milliseconds\n       */\n      beginDate: z.string(),\n      /**\n       * @type {string} - UTC timestamp in milliseconds\n       */\n      endDate: z.string(),\n    }),\n    summary: 'Get posts within time-range',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing ts-rest Query Client\nDESCRIPTION: Configuration of ts-rest query client with base URL and headers\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v4.mdx#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initQueryClient } from '@ts-rest/react-query';\n\nexport const client = initQueryClient(router, {\n  baseUrl: 'http://localhost:3333',\n  baseHeaders: {},\n  api?: () => ... // <- Optional Custom API Fetcher (see below)\n});\n```\n\n----------------------------------------\n\nTITLE: Nest.js Server Implementation for File Upload with FileInterceptor\nDESCRIPTION: Demonstrates how to implement file upload handling in a Nest.js controller using ts-rest and FileInterceptor. This approach follows Nest.js best practices for file uploading.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/form-data.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// nest\n@Controller()\nexport class AppController implements NestControllerInterface<typeof c> {\n  @TsRest(s.route.updateUserAvatar)\n  @UseInterceptors(FileInterceptor('avatar'))\n  async updateUserAvatar(\n    @TsRestRequest() { params: { id } }: RequestShapes['updateUserAvatar'],\n    @UploadedFile() avatar: Express.Multer.File\n  ) {\n    return {\n      status: 200 as const,\n      body: {\n        message: `Updated user ${id}'s avatar with ${avatar.originalname}`,\n      },\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ts-rest Client with Custom Headers\nDESCRIPTION: Demonstrates how to initialize a ts-rest client with a base URL and custom headers, including a dynamic access token.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/fetch.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initClient } from '@ts-rest/core';\nimport { getAccessToken } from '@some-auth-lib/sdk';\nimport { contract } from './contract';\n\nexport const client = initClient(contract, {\n  baseUrl: 'http://localhost:3334',\n  baseHeaders: {\n    'x-app-source': 'ts-rest',\n    'x-access-token': () => getAccessToken(),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Headers in ts-rest Contract\nDESCRIPTION: Demonstrates header configuration in ts-rest contracts, including per-route headers and base headers for all routes.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router({\n  getPosts: {\n    ...,\n    headers: z.object({\n      authorization: z.string(),\n      pagination: z.coerce.number().optional(),\n    }),\n  }\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router(\n  {\n    // ...endpoints\n  },\n  {\n    baseHeaders: z.object({\n      authorization: z.string(),\n    }),\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Adding Metadata to ts-rest Contracts\nDESCRIPTION: Shows how to add metadata to contract routes for additional configuration and documentation.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router({\n    getPosts: {\n        ...,\n        metadata: { role: 'guest' } as const,\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Regular Query and Mutation Example\nDESCRIPTION: Demonstration of regular fetch and mutation operations without hooks\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v4.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Normal fetch\nconst { body, status } = await client.posts.get.query();\n\n// useQuery hook\nconst { data, isLoading } = client.posts.get.useQuery();\n```\n\n----------------------------------------\n\nTITLE: Accessing Lambda Context in ts-rest Handlers\nDESCRIPTION: Example showing how to access Lambda-specific context properties within endpoint handlers and middleware. Demonstrates accessing the raw event object and Lambda context in both route handlers and middleware functions.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/aws.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createLambdaHandler } from '@ts-rest/serverless/aws';\nimport { contract } from './contract';\n\nexport const handler = createLambdaHandler(\n  contract,\n  {\n    getPost: async ({ params: { id } }, { rawEvent, lambdaContext }) => {\n      return {\n        status: 200,\n        body: {\n          id,\n          title: 'Hello, World!',\n        },\n      };\n    },\n  },\n  {\n    requestMiddleware: [\n      (request, { rawEvent, lambdaContext }) => {\n        console.log('Raw Event:', context.rawEvent);\n        console.log('Lambda Context:', context.lambdaContext);\n      }\n    ],\n    responseHandlers: [\n      (response, request, { rawEvent, lambdaContext }) => {}\n    ]\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Handling Status Codes in ts-rest Client\nDESCRIPTION: Example of using the ts-rest client to handle different response status codes. Shows how to check the status code and access the properly typed response body based on the status.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/errors.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst { status, body } = await client.user({ params: { id: '1' } });\n\nif (status === 200) {\n  console.log(body.email);\n} else if (status === 400) {\n  console.log('Not found');\n} else {\n  console.log('Something went wrong');\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic ts-rest Contract with TypeScript Types\nDESCRIPTION: Defines a ts-rest contract using basic TypeScript type annotations. The contract includes endpoints for creating and retrieving posts with typed request and response bodies.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/quickstart.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// contract.ts\n\nimport { initContract } from '@ts-rest/core';\n\nconst c = initContract();\n\nexport const contract = c.router({\n  createPost: {\n    method: 'POST',\n    path: '/posts',\n    responses: {\n      201: c.type<Post>(),\n    },\n    body: c.type<{title: string}>(),\n    summary: 'Create a post',\n  },\n  getPost: {\n    method: 'GET',\n    path: `/posts/:id`,\n    responses: {\n      200: c.type<Post | null>(),\n    },\n    summary: 'Get a post by id',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClientProvider with React Query\nDESCRIPTION: Basic setup of QueryClientProvider wrapper component for React Query integration\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v4.mdx#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\nconst queryClient = new QueryClient();\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>;\n}\n```\n\n----------------------------------------\n\nTITLE: Utilizing Azure Function Context Object with ts-rest in TypeScript\nDESCRIPTION: This example shows how to use the Azure Function context object with ts-rest. It demonstrates accessing Azure-specific properties like rawHttpRequest and azureContext in both the main handler and middleware functions.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/azure-functions.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAzureFunctionHandler } from '@ts-rest/serverless/azure';\nimport { contract } from './contract';\n\nexport const handler = createAzureFunctionHandler(\n  contract,\n  {\n    getPost: async ({ params: { id } }, { azureContext, rawHttpRequest }) => {\n      azureContext.log('Received request!');\n\n      return {\n        status: 200,\n        body: {\n          id,\n          title: 'Hello, World!',\n        },\n      };\n    },\n  },\n  {\n    requestMiddleware: [\n      (request, { rawHttpRequest, azureContext }) => {\n        console.log('Raw HttpRequest:', rawHttpRequest);\n        console.log('Azure Invocation Context:', azureContext);\n      },\n    ],\n    responseHandlers: [(response, request, { rawHttpRequest, azureContext }) => {}],\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Handler in TypeScript for ts-rest Serverless\nDESCRIPTION: Demonstrates how to create a custom error handler function for ts-rest serverless handlers. The function takes an error and request object, logs the error, and returns a custom error response.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/options.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TsRestRequest, TsRestResponse } from '@ts-rest/serverless';\n\nconst errorHandler = (error: unknown, request: TsRestRequest) => {\n  console.error('Server Error', error);\n  \n  return TsRestResponse.fromJson(\n    { message: 'Custom Server Error Message' },\n    { status: 500 }\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a ts-rest Client with Custom Fetch Implementation\nDESCRIPTION: Example showing how to create a ts-rest client with a custom fetch implementation. This demonstrates advanced configuration possibilities like custom header manipulation, request transformation, and response handling.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/core/README.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initClient } from '@ts-rest/core';\n\nconst client = initClient(contract, {\n  baseUrl: 'https://jsonplaceholder.typicode.com',\n  baseHeaders: {\n    'Content-Type': 'application/json',\n  },\n  api: async ({ path, method, headers, body }) => {\n    const url = `https://jsonplaceholder.typicode.com${path}`;\n\n    const res = await fetch(url, {\n      method,\n      headers: {\n        ...headers,\n        'x-custom-header': 'custom value',\n      },\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    if (!res.ok && res.status !== 404) {\n      throw new Error(`Error calling ${method} ${path}: ${res.statusText}`);\n    }\n\n    const contentType = res.headers.get('content-type');\n    const isJson = contentType?.includes('application/json');\n\n    return {\n      status: res.status,\n      body: isJson ? await res.json() : await res.text(),\n      headers: Object.fromEntries(res.headers.entries()),\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up ts-rest Provider with React Query\nDESCRIPTION: Demonstrates how to set up the ts-rest Provider component with React Query's QueryClientProvider.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v5-setup.mdx#2025-04-17_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport React from 'react';\nimport { tsr } from './tsr';\n\nconst queryClient = new QueryClient()\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <tsr.ReactQueryProvider>{children}</tsr.ReactQueryProvider>\n    </QueryClientProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Global Middleware in ts-rest with Express\nDESCRIPTION: Shows how to implement global middleware that runs for all routes in a contract. Includes example of using Passport JWT authentication as global middleware, which executes before any route-specific middleware.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/express/middleware.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initServer } from '@ts-rest/express';\nimport { contract } from './contract';\n\nconst s = initServer();\n\nconst router = s.router(contract, {\n  getPost: {\n    middleware: [\n      (req, res, next) => {\n        // req.tsRestRoute is typed as the contract route\n        console.log('Called: ', req.tsRestRoute.method, req.tsRestRoute.path);\n        //                                   'GET' ^        '/posts/:id'  ^ \n        next();\n      }\n    ],\n    handler: async ({ params: { id } }) => {\n      const post = prisma.post.findUnique({ where: { id } });\n\n      return {\n        status: 200,\n        body: post ?? null,\n      };\n    }\n  },\n});\n\ncreateExpressEndpoints(contract, router, app, {\n  globalMiddleware: [passport.authenticate('jwt', { session: false })]\n});\n```\n\n----------------------------------------\n\nTITLE: Defining API Contract with ts-rest in TypeScript\nDESCRIPTION: This snippet demonstrates how to define an API contract using ts-rest. It includes endpoints for getting a list of dogs and adding a new dog, with specified request methods, paths, and response schemas.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/guides/fake-apis.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initContract } from '@ts-rest/core'\n\nconst c = initContract()\nexport const contract = c.router({\n  getDogs: {\n    method: 'GET',\n    path: '/dogs',\n    responses: {\n      200: z.array(z.string()),\n    },\n  },\n  addDog: {\n    method: 'POST',\n    path: '/dogs',\n    body: z.object({\n      name: z.string(),\n    }),\n    responses: {\n      200: z.object({\n        message: z.string(),\n      }),\n      400: z.object({\n        error: z.string(),\n      }),\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling JSON Query Parameters in OpenAPI\nDESCRIPTION: This snippet shows how to enable JSON query parameters in the OpenAPI document by setting the jsonQuery option to true. This is useful when the server and client are configured to use JSON query parameters.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/open-api.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst openApiSchema = generateOpenApi(\n  postsApi,\n  {\n    info: {\n      title: 'Posts API',\n      version: '1.0.0',\n    },\n  },\n  {\n    jsonQuery: true,\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Direct Fetching with ts-rest\nDESCRIPTION: Shows how to make direct fetch requests without React Query using ts-rest's query and mutate functions.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v5-setup.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Normal fetch\nconst { body, status } = await tsr.posts.get.query();\n\n// useQuery hook\nconst { data, isLoading } = tsr.posts.get.useQuery();\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Request Middleware in ts-rest Serverless with TypeScript\nDESCRIPTION: Shows how to set up global request middleware for authentication in a ts-rest serverless handler. The middleware authenticates the user, adds a userId to the request object, and optionally short-circuits the request with an unauthorized response.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/options.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TsRestResponse } from '@ts-rest/serverless';\nimport { fetchRequestHandler, tsr } from '@ts-rest/serverless/fetch';\nimport { contract } from './contract';\n\nexport default async (request: Request) => {\n  return fetchRequestHandler({\n    request,\n    contract,\n    router: {\n      getPost: async ({ params: { id } }, { request }) => {\n        const post = prisma.post.findUniqueOrThrow({\n          where: { id, ownerId: request.userId },\n        });\n\n        return {\n          status: 200,\n          body: post,\n        };\n      },\n    },\n    options: {\n      requestMiddleware: [\n        tsr.middleware<{ userId: string }>((request) => {\n          if (request.headers.get('Authorization')) {\n            const userId = authenticate(request.headers.get('Authorization'));\n            if (!userId) {\n              return TsRestResponse.fromJson(\n                { message: 'Unauthorized' },\n                { status: 401 },\n              );\n            }\n            request.userId = userId;\n          }\n        }),\n      ],\n    },\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a NestJS Controller with ts-rest\nDESCRIPTION: This example demonstrates how to implement a NestJS controller that conforms to a ts-rest contract. It shows how to use the nestControllerContract, NestControllerInterface, TsRest decorator, and TsRestRequest decorator to create a type-safe controller.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/nest/legacy.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  nestControllerContract,\n  NestControllerInterface,\n  NestRequestShapes,\n  TsRest,\n  TsRestRequest,\n} from '@ts-rest/nest';\n\nconst c = nestControllerContract(contract);\ntype RequestShapes = NestRequestShapes<typeof c>;\n\n@Controller()\nexport class PostController implements NestControllerInterface<typeof c> {\n  constructor(private readonly postService: PostService) {}\n\n  @TsRest(c.getPost)\n  async getPost(@TsRestRequest() { params: { id } }: RequestShapes['getPost']) {\n    const post = await this.postService.getPost(id);\n\n    if (!post) {\n      return { status: 404 as const, body: null };\n    }\n\n    return { status: 200 as const, body: post };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving QueryClient Provider Issues with ts-rest/react-query\nDESCRIPTION: Demonstrates how to resolve the 'No QueryClient set' error by importing React Query components from ts-rest's package instead of directly from @tanstack/react-query. This approach ensures consistent module versions when multiple versions may exist in the project.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/troubleshooting.md#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from '@ts-rest/react-query/tanstack';\n\nconst queryClient = new QueryClient()\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\n```\n\n----------------------------------------\n\nTITLE: AST Transformer Factory for ts-rest Controller Migration\nDESCRIPTION: Creates a TypeScript transformer that converts decorated controller methods to use tsRestHandler. Supports both single-handler and multiple-handler output styles, modifying imports, class declarations, and method implementations.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/src/components/nestTransform.txt#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst getTransformer = (output: 'single-handler' | 'multiple-handler') => {\n  const transform = (context: ts.TransformationContext) => {\n    const { factory } = context;\n\n    let contractIdentifier: ts.Identifier | undefined;\n\n    return (rootNode: ts.Node) => {\n      function visit(node: ts.Node): ts.Node {\n        // Look for the variable assignment to 'nestControllerContract' and store the contract Identifier\n        if (ts.isVariableStatement(node)) {\n          const declaration = node.declarationList.declarations[0];\n\n          if (\n            declaration &&\n            declaration.initializer &&\n            ts.isCallExpression(declaration.initializer)\n          ) {\n            if (\n              isNestControllerContract(\n                declaration.initializer.expression.getText()\n              )\n            ) {\n              console.log(\n                'transform - found the nestControllerContract function, saving contract name and deleting line'\n              );\n\n              contractIdentifier = declaration.initializer\n                .arguments[0] as ts.Identifier;\n              return factory.createEmptyStatement();\n            }\n          }\n        }\n\n        if (ts.isClassDeclaration(node)) {\n          console.log('transform - found class, trying to transform');\n\n          const newMembers = transformMethods(node.members);\n\n          if (newMembers) {\n            const newHeritageClauses = node.heritageClauses?.filter(\n              (heritageClause) =>\n                !heritageClause.types.some((type) =>\n                  isClassDecoratorImplementation(type.expression.getText())\n                )\n            );\n\n            return factory.updateClassDeclaration(\n              node,\n              node.modifiers,\n              node.name,\n              node.typeParameters,\n              newHeritageClauses,\n              newMembers\n            );\n          }\n        }\n\n        if (\n          ts.isImportDeclaration(node) &&\n          node.moduleSpecifier.getText() === \"'@ts-rest/nest'\"\n        ) {\n          if (\n            node.importClause?.namedBindings &&\n            ts.isNamedImports(node.importClause.namedBindings)\n          ) {\n            const tsRestHandlerFunctionImportSpecifier =\n              factory.createImportSpecifier(\n                false,\n                undefined,\n                factory.createIdentifier('tsRestHandler')\n              );\n\n            const tsRestHandlerDecoratorImportSpecifier =\n              factory.createImportSpecifier(\n                false,\n                undefined,\n                factory.createIdentifier('TsRestHandler')\n              );\n\n            const newNamedImports = factory.updateNamedImports(\n              node.importClause.namedBindings,\n              [\n                // ...node.importClause.namedBindings.elements,\n                tsRestHandlerFunctionImportSpecifier,\n                tsRestHandlerDecoratorImportSpecifier,\n              ]\n            );\n\n            const newImportClause = factory.createImportClause(\n              false,\n              undefined,\n              newNamedImports\n            );\n\n            return factory.createImportDeclaration(\n              node.decorators,\n              node.modifiers,\n              newImportClause,\n              node.moduleSpecifier\n            );\n          }\n        }\n        return ts.visitEachChild(node, visit, context);\n      }\n\n      function transformMethods(members: ts.NodeArray<ts.ClassElement>) {\n        const constructor = members.find(ts.isConstructorDeclaration) as\n          | ts.ConstructorDeclaration\n          | undefined;\n\n        // Split methods into ones that have the TsRest decorator and ones that do not\n        const tsRestMethods: ts.MethodDeclaration[] = [];\n        const nonTsRestMethods: ts.MethodDeclaration[] = [];\n\n        members.forEach((member) => {\n          if (ts.isMethodDeclaration(member)) {\n            const hasTsRestDecorator =\n              (ts.canHaveDecorators(member) &&\n                ts\n                  .getDecorators(member)\n                  ?.some((decorator) =>\n                    isTsRestMethodDecorator(decorator.expression.getText())\n                  )) ??\n              false;\n\n            if (hasTsRestDecorator) {\n              tsRestMethods.push(member);\n            } else {\n              nonTsRestMethods.push(member);\n            }\n          }\n        });\n\n        // Preserve property declarations\n        const propertyDeclarations = members.filter(\n          ts.isPropertyDeclaration\n        ) as ts.PropertyDeclaration[];\n\n        if (!constructor || !tsRestMethods.length || !contractIdentifier) {\n          return;\n        }\n\n        console.log('transform - trying to generate the handler function');\n\n        const singleHandlers = tsRestMethods.map((controllerMethod) => {\n          const contractAccess = factory.createPropertyAccessExpression(\n            contractIdentifier!,\n            factory.createIdentifier(controllerMethod.name.getText())\n          );\n\n          const decorator = factory.createDecorator(\n            factory.createCallExpression(\n              factory.createIdentifier('TsRestHandler'),\n              undefined,\n              [contractAccess]\n            )\n          );\n\n          const paramsWithoutTsRestDecorators =\n            controllerMethod.parameters.filter(\n              (param) =>\n                !ts\n                  .getDecorators(param)\n                  ?.some((decorator) =>\n                    isTsRestParameterDecoratorName(\n                      decorator.expression.getText()\n                    )\n                  )\n            );\n\n          const originalTsRestParamDecorator = controllerMethod.parameters.find(\n            (param) =>\n              ts\n                .getDecorators(param)\n                ?.some((decorator) =>\n                  isTsRestParameterDecoratorName(decorator.expression.getText())\n                )\n          );\n\n          // Create a new parameter based on the old one, but without the decorator and type.\n          const newParam = originalTsRestParamDecorator\n            ? factory.createParameterDeclaration(\n                undefined, // No decorators.\n                undefined, // No modifiers.\n                undefined, // No dotDotDotToken.\n                originalTsRestParamDecorator.name, // Keep the old parameter's name.\n                undefined, // No questionToken.\n                undefined // No type.\n              )\n            : undefined;\n\n          const handler = factory.createMethodDeclaration(\n            [decorator, ...(controllerMethod.decorators ?? [])],\n            undefined,\n            undefined,\n            controllerMethod.name,\n            undefined,\n            undefined,\n            paramsWithoutTsRestDecorators,\n            undefined,\n            factory.createBlock([\n              factory.createReturnStatement(\n                factory.createCallExpression(\n                  factory.createIdentifier('tsRestHandler'),\n                  undefined,\n                  [\n                    contractAccess,\n                    factory.createArrowFunction(\n                      [factory.createModifier(ts.SyntaxKind.AsyncKeyword)],\n                      undefined,\n                      [...(newParam ? [newParam] : [])],\n                      undefined,\n                      factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n                      controllerMethod.body || factory.createBlock([])\n                    ),\n                  ]\n                )\n              ),\n            ])\n          );\n\n          return handler;\n        });\n\n        const decorator = factory.createDecorator(\n          factory.createCallExpression(\n            factory.createIdentifier('TsRestHandler'),\n            undefined,\n            [contractIdentifier]\n          )\n        );\n\n        const combinedHandlerFunction = factory.createMethodDeclaration(\n          [decorator],\n          undefined,\n          undefined,\n          'handler',\n          undefined,\n          undefined,\n          [],\n          undefined,\n          factory.createBlock([\n            factory.createReturnStatement(\n              factory.createCallExpression(\n                factory.createIdentifier('tsRestHandler'),\n                undefined,\n                [\n                  contractIdentifier,\n                  factory.createObjectLiteralExpression(\n                    tsRestMethods.map((controllerMethod) => {\n                      const headersMap: { [key: string]: string } = {};\n\n                      // Find parameters with the @Headers decorator\n                      controllerMethod.parameters.forEach((param) => {\n                        if (\n                          ts.canHaveDecorators(param) &&\n                          ts\n                            .getDecorators(param)\n                            ?.some((decorator) =>\n                              decorator.expression.getText().includes('Headers')\n                            )\n                        ) {\n                          const paramName = param.name.getText();\n\n                          // Extract the header name from the decorator\n                          const decorator = ts\n                            .getDecorators(param)\n                            ?.find((decorator) =>\n```\n\n----------------------------------------\n\nTITLE: Setting Base Headers in ts-rest Contracts\nDESCRIPTION: Example of setting baseHeaders in a ts-rest contract which will be merged with endpoint-specific headers. This allows for defining common headers like authorization that should be included in all API requests.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router(\n  {\n    // ...endpoints\n  },\n  {\n    baseHeaders: z.object({\n      authorization: z.string(),\n    }),\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Express Server Implementation for File Upload with Multer\nDESCRIPTION: Shows how to implement the server-side handling of file uploads in Express using multer middleware with ts-rest. The example creates an endpoint that processes a thumbnail file upload.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/form-data.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createExpressEndpoints, initServer } from '@ts-rest/express';\nimport * as express from 'express';\nimport * as multer from 'multer';\nimport { postsContract } from './postsContract';\n\nconst upload = multer();\nconst s = initServer();\n\nconst postsRouter = s.router(postsContract, {\n  updatePostThumbnail: {\n    middleware: [upload.single('thumbnail')],\n    handler: async ({ file }) => {\n      const thumbnail = file as Express.Multer.File;\n\n      return {\n        status: 200,\n        body: {\n          message: `File ${thumbnail.originalname} successfully!`,\n        },\n      };\n    },\n  },\n});\n\nconst app = express();\n\ncreateExpressEndpoints(postsContract, postsRouter, app);\n```\n\n----------------------------------------\n\nTITLE: Extending Zod Schemas with OpenAPI Metadata\nDESCRIPTION: This snippet shows how to extend Zod schemas with additional OpenAPI metadata using @anatine/zod-openapi. It demonstrates adding descriptions, examples, and titles to schema properties to improve the generated documentation.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/open-api.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initContract } from '@ts-rest/core';\nimport { z } from 'zod';\nimport { extendZodWithOpenApi } from '@anatine/zod-openapi';\n\nextendZodWithOpenApi(z);\n\nconst c = initContract();\n\nexport const contract = c.router({\n  getUser: {\n    method: 'GET',\n    path: '/users/:id',\n    pathParams: z.object({\n      id: z.string().openapi({\n        description: \"The user's ID\",\n      }),\n    }),\n    responses: {\n      200: z\n        .object({\n          id: z.string().uuid().openapi({\n            title: 'Unique ID',\n            description: 'A UUID generated by the server',\n          }),\n          name: z.string(),\n          phoneNumber: z.string().min(10).openapi({\n            description: 'US phone numbers only',\n            example: '555-555-5555',\n          }),\n        })\n        .openapi({\n          title: 'User',\n          description: 'A user schema',\n          mediaExamples: {\n            myExample: {\n              value: {\n                id: '123e4567-e89b-12d3-a456-426614174000',\n                name: 'John Doe',\n                phoneNumber: '555-555-5555',\n              },\n              summary: 'Example of a user',\n            },\n          },\n        }),\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Transforming Nest.js Controller with Header Handling\nDESCRIPTION: This snippet transforms a Nest.js controller method, handling @Headers decorators and creating a new parameter structure. It processes the AST to modify the controller's structure based on decorators and parameters.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/src/components/nestTransform.txt#2025-04-17_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst headersObjectLiteral = factory.createObjectBindingPattern(\n  Object.keys(headersMap).map((key) =>\n    factory.createBindingElement(\n      undefined,\n      factory.createStringLiteral(key.toLowerCase()),\n      factory.createIdentifier(headersMap[key]),\n      undefined\n    )\n  )\n);\n\nlet nameUpdatedWithHeaders;\n\nif (\n  tsRestRequestParam &&\n  ts.isObjectBindingPattern(tsRestRequestParam.name) &&\n  Object.keys(headersMap).length > 0\n) {\n  nameUpdatedWithHeaders = factory.createObjectBindingPattern([\n    ...tsRestRequestParam.name.elements,\n    factory.createBindingElement(\n      undefined,\n      'headers',\n      headersObjectLiteral\n    ),\n  ]);\n} else {\n  nameUpdatedWithHeaders = tsRestRequestParam?.name;\n}\n\nconst newParam = tsRestRequestParam\n  ? factory.createParameterDeclaration(\n      undefined,\n      undefined,\n      undefined,\n      nameUpdatedWithHeaders,\n      undefined,\n      undefined\n    )\n  : undefined;\n```\n\n----------------------------------------\n\nTITLE: Adding Path Prefix to ts-rest Contracts\nDESCRIPTION: Demonstrates how to add a pathPrefix to a ts-rest contract to prepend a common path segment to all routes. This example shows adding '/api/v1' to all endpoints, resulting in paths like '/api/v1/mypath'.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router(\n  {\n    getPost: {\n      path: '/mypath',\n      //... Your Contract\n    },\n  },\n  {\n    pathPrefix: '/api/v1',\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing ts-rest Server Routes with Express\nDESCRIPTION: Example of implementing a server using ts-rest and Express. It demonstrates how to create route handlers that conform to the contract, with proper typing for request parameters and responses, plus error handling capabilities.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/core/README.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initServer } from '@ts-rest/express';\nimport express from 'express';\n\nconst s = initServer();\n\nconst router = s.router(contract, {\n  getPost: async ({ params }) => {\n    const post = await fetchPostFromDatabase(params.id);\n\n    if (!post) {\n      return {\n        status: 404,\n        body: { message: 'Post not found' },\n      };\n    }\n\n    return {\n      status: 200,\n      body: post,\n    };\n  },\n  getPosts: async ({ query }) => {\n    const posts = await fetchPostsFromDatabase({\n      take: query.take,\n      skip: query.skip,\n    });\n\n    return {\n      status: 200,\n      body: posts,\n    };\n  },\n  createPost: async ({ body }) => {\n    const post = await createPostInDatabase({\n      title: body.title,\n      body: body.body,\n      userId: body.userId,\n    });\n\n    return {\n      status: 201,\n      body: post,\n    };\n  },\n});\n\nconst app = express();\napp.use(express.json());\napp.use(s.route(contract, router));\n```\n\n----------------------------------------\n\nTITLE: Throwing Contract-Wide Response Errors in ts-rest\nDESCRIPTION: This snippet shows how to throw a TsRestResponseError using the entire contract, which allows you to pass responses that are common to all endpoints. This approach enables reusing error responses across multiple endpoints.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/server-errors.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nthrow new TsRestResponseError(contract, {\n  status: 404,\n  body: { message: 'Not Found' },\n});\n```\n\n----------------------------------------\n\nTITLE: Transforming Legacy Nest.js Controller\nDESCRIPTION: This function orchestrates the transformation of a legacy Nest.js controller. It applies multiple transformations including the main controller transformation, removal of 'as const' assertions, and removal of specific type aliases.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/src/components/nestTransform.txt#2025-04-17_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const transformLegacyNestController = (\n  oldCode: string,\n  output: 'single-handler' | 'multiple-handler'\n) => {\n  const sourceFile = ts.createSourceFile(\n    'old.ts',\n    oldCode,\n    ts.ScriptTarget.ES2015,\n    true\n  );\n\n  console.log('transformer - starting transformation');\n\n  const result = ts.transform(sourceFile, [\n    getTransformer(output),\n    removeAsConst,\n    removeNestRequestShapesTypes,\n  ]);\n\n  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n  let newCode = '';\n  result.transformed.forEach((file) => {\n    newCode += printer.printNode(ts.EmitHint.Unspecified, file, sourceFile);\n  });\n\n  return newCode;\n};\n```\n\n----------------------------------------\n\nTITLE: Custom Request Validation Error Handling with ts-rest\nDESCRIPTION: Demonstrates how to implement a custom error handler for request validation errors, providing control over the error response format and status codes.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/express/express.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ncreateExpressEndpoints(contract, router, app, {\n  requestValidationErrorHandler: (err, req, res, next) => {\n    //             err is typed as ^ RequestValidationError\n    return res.status(400).json({\n      message: 'Validation failed'\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring ts-rest/fastify Options\nDESCRIPTION: Defines the available configuration options for ts-rest's Fastify integration. Options include route initialization logging, JSON query handling, response validation, and custom request validation error handling.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/fastify.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype Options = {\n  logInitialization?: boolean; // print route initialization logs to console\n  jsonQuery?: boolean;\n  responseValidation?: boolean;\n  requestValidationErrorHandler?:\n    | 'combined'\n    | ((err: TsRestRequestValidationError,\n        request: fastify.FastifyRequest,\n        reply: fastify.FastifyReply\n      ) => void);\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Route-Specific Middleware with Global Context in ts-rest Serverless\nDESCRIPTION: Demonstrates how to use the tsr.routeWithMiddleware() helper function to define route-specific middleware while maintaining global request context types. This approach allows for different request contexts in global and route-specific middleware.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/options.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler, tsr } from '@ts-rest/serverless/fetch';\nimport { contract } from './contract';\n\ntype GlobalRequestContext = {\n  time: Date;\n};\n\nexport default async (request: Request) => {\n  return fetchRequestHandler({\n    request,\n    contract,\n    router: {\n      getPost: tsr.routeWithMiddleware(contract.getPost)<\n        GlobalRequestContext, // <--- this is the global context\n        { userId: string } // <--- this is the route-level context\n      >({\n        middleware: [\n          (request) => {\n            // do authentication\n            request.userId = '123';\n          },\n        ],\n        handler: async ({ params: { id } }, { request }) => {\n          const post = prisma.post.findUniqueOrThrow({\n            where: { id, ownerId: request.userId },\n          });\n\n          return {\n            status: 200,\n            body: post,\n          };\n        },\n      }),\n    },\n    options: {\n      requestMiddleware: [\n        tsr.middleware<GlobalRequestContext>((request) => {\n          request.time = new Date();\n        }),\n      ],\n    },\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple ts-rest Contracts\nDESCRIPTION: Example of how to combine multiple contracts into a single contract for better organization of large APIs.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\n\nexport const postContract = c.router({\n  getPosts: {\n    method: 'GET',\n    path: '/posts',\n    responses: {\n      200: c.type<{ posts: Post[]; total: number }>(),\n    },\n    query: z.object({\n      take: z.string().transform(Number).optional(),\n      skip: z.string().transform(Number).optional(),\n      search: z.string().optional(),\n    }),\n    summary: 'Get all posts',\n  },\n});\n\nexport const contract = c.router({\n  posts: postContract,\n});\n```\n\n----------------------------------------\n\nTITLE: Identifying NestJS Controller Contract Initializations\nDESCRIPTION: Function to detect strings that represent the initialization of a nest controller contract using either initNestServer or nestControllerContract functions.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/src/components/nestTransform.txt#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst isNestControllerContract = (str: string): boolean => {\n  return (\n    str.includes('initNestServer') || str.includes('nestControllerContract')\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Request Validation Error Handling\nDESCRIPTION: Demonstrates how to implement a custom error handler for request validation errors in ts-rest/fastify. The handler receives the validation error, request, and response objects and can return a customized error response.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/fastify.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ns.registerRouter(contract, router, app, {\n  requestValidationErrorHandler: (err, req, res, next) => {\n    //             err is typed as ^ RequestValidationError\n    return res.status(400).json({\n      message: 'Validation failed',\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClient with ts-rest React Query Integration\nDESCRIPTION: Example showing how to properly initialize and set up QueryClient with ts-rest when encountering version mismatch issues. This approach imports QueryClient directly from ts-rest to ensure version compatibility.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v4.mdx#2025-04-17_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from '@ts-rest/react-query/tanstack';\n\nconst queryClient = new QueryClient()\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Response Validation in ts-rest/fastify\nDESCRIPTION: Shows how to enable response validation in the ts-rest Fastify integration. When enabled, responses will be validated against Zod schemas defined in the contract for the returned status code.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/fastify.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ns.registerRouter(contract, router, app, {\n  validateResponses: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Detecting Class Decorator Implementations in TypeScript\nDESCRIPTION: Helper function that checks if a string contains NestControllerInterface or ControllerShape indicators, which are used to identify classes implementing ts-rest controller interfaces.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/src/components/nestTransform.txt#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst isClassDecoratorImplementation = (str: string): boolean => {\n  return (\n    str.includes('NestControllerInterface') || str.includes('ControllerShape')\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Error Handler in ts-rest\nDESCRIPTION: Demonstrates how to implement a global error handler for handling validation and other errors.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/next.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport default createNextRouter(contract, router, {\n  responseValidation: true,\n  errorHandler: (error: unknown, req: NextApiRequest, res: NextApiResponse) => {\n    if (error instanceof ResponseValidationError) {\n      console.log(error.cause);\n      return res.status(500).json({ message: 'Internal Server Error' });\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ts-rest Client API Usage\nDESCRIPTION: Example showing how ts-rest provides RPC-style method calls while maintaining REST-like endpoint structure. Shows type-safe interface usage.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/comparisons/rpc-comparison.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nclient.posts.getPost({ id: \"1\" })\nclient.posts.getPostComments()\n```\n\n----------------------------------------\n\nTITLE: Type Definition for Client Response with Multiple Status Codes\nDESCRIPTION: Example showing the TypeScript type definition generated for a response with multiple status codes. Illustrates how ts-rest creates a union type that includes all possible status codes with their corresponding body types.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/errors.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst updatedUser: {\n    status: 200;\n    body: User\n} | {\n    status: 400;\n    body: {\n        message: string;\n    }\n} | {\n    status: 100 | 101 | 102 | 201 | 202 | 203 | ... 47 more ... | 511;\n    body: unknown;\n}\n```\n\n----------------------------------------\n\nTITLE: Removing 'as const' Type Assertions in TypeScript\nDESCRIPTION: This function removes 'as const' type assertions from the AST. It visits each node and removes the assertion if it matches the pattern of an 'as const' expression.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/src/components/nestTransform.txt#2025-04-17_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction removeAsConst(context: ts.TransformationContext) {\n  const visitor: ts.Visitor = (node: ts.Node): ts.VisitResult<ts.Node> => {\n    if (\n      ts.isAsExpression(node) &&\n      ts.isTypeReferenceNode(node.type) &&\n      node.type.typeName.getText() === 'const'\n    ) {\n      return node.expression;\n    }\n    return ts.visitEachChild(node, visitor, context);\n  };\n  return (rootNode: ts.Node) => ts.visitNode(rootNode, visitor);\n}\n```\n\n----------------------------------------\n\nTITLE: Throwing Endpoint-Specific Response Errors in ts-rest\nDESCRIPTION: This snippet demonstrates how to throw a TsRestResponseError for a specific endpoint defined in your contract. The error includes a status code and error message body, which will be caught by ts-rest and served as a response.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/server-errors.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TsRestResponseError } from '@ts-rest/core';\nimport { contract } from './contract';\n\n// anywhere in your code\nthrow new TsRestResponseError(contract.getPost, {\n  status: 404,\n  body: { message: 'Not Found' },\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Request Validation Error Handling\nDESCRIPTION: Shows implementation of custom request validation error handling with detailed error responses.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/next.mdx#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport default createNextRouter(contract, router, {\n  throwRequestValidation: true,\n  errorHandler: (error: unknown, req: NextApiRequest, res: NextApiResponse) => {\n    if (error instanceof RequestValidationError) {\n      if (error.body !== null) {\n        return res\n          .status(400)\n          .json({ message: 'Malformed Body', errors: error.body.flatten() });\n      }\n\n      return res.status(400).json({ message: 'Bad Request' });\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling strict mode in tsconfig.json\nDESCRIPTION: Configuration snippet showing how to enable strict mode in tsconfig.json to improve TypeScript intellisense performance in ts-rest projects. This is a requirement for optimal performance due to the Zod dependency.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/troubleshoot.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n  \"compilerOptions\": {\n    ...\n    \"strict\": true\n  }\n```\n\n----------------------------------------\n\nTITLE: Changelog Entry for Version 3.30.5\nDESCRIPTION: Markdown documentation of changes including fixes for fastify deprecated routerPath property, OpenAPI schema content-type handling, and content-type text/html blob body returns.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/fastify/CHANGELOG.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n### Patch Changes\n- 9bd7402: - `@ts-rest/fastify` fix: fastify deprecated routerPath property (fixes [#392](https://github.com/ts-rest/ts-rest/issues/392))\n  - `@ts-rest/open-api` fix: Pass through contentType to OpenApi schema ([#414](https://github.com/ts-rest/ts-rest/pull/414))\n  - `@ts-rest/core` fix: Content-type text/html returns blob body (fixes [#418](https://github.com/ts-rest/ts-rest/issues/418))\n- 8cc95c5: add changeset for latest changes\n```\n\n----------------------------------------\n\nTITLE: Setting Global Configuration for ts-rest in a Nest.js Module\nDESCRIPTION: Example of how to set global configuration options for ts-rest in a Nest.js module. This demonstrates how to configure options like jsonQuery and validateResponses that will be applied to all controllers in the module or across the entire application.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/nest/configuration.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Module } from '@nestjs/common';\nimport { TsRestModule } from '@ts-rest/nest';\n\n@Module({\n  imports: [\n    TsRestModule.register({\n      isGlobal: true,\n      jsonQuery: true,\n      validateResponses: true,\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Initializing ts-rest React Query Client\nDESCRIPTION: Shows how to initialize the ts-rest React Query client with configuration options including base URL and custom headers.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v5-setup.mdx#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initTsrReactQuery } from '@ts-rest/react-query/v5';\nimport { getAccessToken } from '@some-auth-lib/sdk';\nimport { contract } from './contract';\n\nexport const tsr = initTsrReactQuery(contract, {\n  baseUrl: 'http://localhost:3333',\n  baseHeaders: {\n    'x-app-source': 'ts-rest',\n    'x-access-token': () => getAccessToken(),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using NestJS Decorators with ts-rest\nDESCRIPTION: Demonstrates how to use standard NestJS decorators alongside ts-rest handlers, showing compatibility with existing NestJS features like request object access.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/nest/nest.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TsRestHandler, tsRestHandler } from '@ts-rest/nest';\n\n@Controller()\nexport class MyController {\n  constructor(private readonly service: Service) {}\n\n  @TsRestHandler(c.test)\n  async myMethod(@Req() req: Request) {\n    return tsRestHandler(c.test, async ({ params }) => {\n      // ...\n\n      console.log(req.headers);\n      // ^ You can still use Nest decorators\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Explicit Response Type Safety in NestJS\nDESCRIPTION: This example shows how to ensure type safety of responses without implementing NestControllerInterface. It's useful when implementing routes across multiple controllers or using different method names than those in the contract.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/nest/legacy.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  nestControllerContract,\n  NestRequestShapes,\n  NestResponseShapes,\n  TsRestRequest,\n} from '@ts-rest/nest';\n\nconst c = nestControllerContract(contract);\ntype RequestShapes = NestRequestShapes<typeof c>;\ntype ResponseShapes = NestResponseShapes<typeof c>;\n\n@Controller()\nexport class PostController {\n  constructor(private readonly postService: PostService) {}\n\n  @TsRest(c.getPost)\n  async getPost(\n    @TsRestRequest() { params: { id } }: RequestShapes['getPost']\n  ): Promise<ResponseShapes['getPost']> {\n    const post = await this.postService.getPost(id);\n\n    if (!post) {\n      return { status: 404 as const, body: null };\n    }\n\n    return { status: 200 as const, body: post };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing NestJS Controller Transformation with Vitest\nDESCRIPTION: A test suite that verifies the transformation of legacy NestJS controllers to a new format. It reads input files, applies the transformation, and compares the results with expected outputs after formatting with Prettier.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/src/components/nestTransformer.spec.txt#2025-04-17_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n//@ts-nocheck\n// deprecated file for now\nimport { assert, describe, expect, it } from 'vitest';\nimport { transformLegacyNestController } from './nestTransform';\nimport * as ts from 'typescript';\nimport * as fs from 'fs';\nimport path from 'path';\nimport * as prettier from 'prettier';\n\ndescribe('nestTransform', () => {\n  it('should transform multiple-routes test file', () => {\n    const file = fs\n      .readFileSync(\n        path.join(__dirname, './transformerFixtures/multiple-routes/input.ts')\n      )\n      .toString();\n\n    const transformed = transformLegacyNestController(file, 'multiple-handler');\n\n    const expected = fs\n      .readFileSync(\n        path.join(\n          __dirname,\n          './transformerFixtures/multiple-routes/expected.ts'\n        )\n      )\n      .toString();\n\n    const formatted = prettier.format(transformed, {\n      parser: 'typescript',\n      singleQuote: true,\n    });\n\n    fs.writeFileSync(\n      path.join(\n        __dirname,\n        './transformerFixtures/multiple-routes/__debug__.ts'\n      ),\n      formatted\n    );\n\n    expect(formatted).toStrictEqual(expected);\n  });\n\n  it('should transform single-routes test file', () => {\n    const file = fs\n      .readFileSync(\n        path.join(__dirname, './transformerFixtures/single-routes/input.ts')\n      )\n      .toString();\n\n    const transformed = transformLegacyNestController(file, 'single-handler');\n\n    const expected = fs\n      .readFileSync(\n        path.join(__dirname, './transformerFixtures/single-routes/expected.ts')\n      )\n      .toString();\n\n    const formatted = prettier.format(transformed, {\n      parser: 'typescript',\n      singleQuote: true,\n    });\n\n    fs.writeFileSync(\n      path.join(__dirname, './transformerFixtures/single-routes/__debug__.ts'),\n      formatted\n    );\n\n    expect(formatted).toStrictEqual(expected);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring ts-rest Options in NestJS\nDESCRIPTION: This snippet shows how to configure ts-rest options at both the controller and method levels. Controller-level options apply to all routes in the controller, while method-level options override these for specific routes.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/nest/legacy.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n@Controller()\n@TsRest({ jsonQuery: true })\nexport class PostController implements NestControllerInterface<typeof c> {\n  constructor(private readonly postService: PostService) {}\n\n  @TsRest(s.route.getPost, { jsonQuery: false })\n  async getPost(@TsRestRequest() { params: { id } }: RequestShapes['getPost']) {\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing ts-rest API with Additional Arguments\nDESCRIPTION: Demonstrates how to customize the ts-rest API by adding custom arguments to the request, which are passed through to the api function.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/fetch.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = initClient(contract, {\n  // ...\n  api: async (args: ApiFetcherArgs & { custom?: string }) => {\n    return tsRestFetchApi(args);\n  },\n});\n\nconst { data } = await client.getPosts({\n  custom: 'argument',\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring ts-rest Query Client\nDESCRIPTION: Initialize a ts-rest query client with base configuration options including URL and headers.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/vue-query.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initQueryClient } from '@ts-rest/vue-query';\n\nexport const client = initQueryClient(router, {\n  baseUrl: 'http://localhost:3333',\n  baseHeaders: {},\n  api?: () => ... // <- Optional Custom API Fetcher (see below)\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Peer Dependencies for @ts-rest/nest\nDESCRIPTION: Specifies the supported versions of NestJS dependencies for the @ts-rest/nest package.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/nest/CHANGELOG.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"@nestjs/common\": \"^9.0.0 || ^10.0.0\",\n\"@nestjs/core\": \"^9.0.0 || ^10.0.0\"\n```\n\n----------------------------------------\n\nTITLE: Enabling JSON-Encoded Query Parameters in ts-rest\nDESCRIPTION: Shows how to enable JSON encoding for query parameters in ts-rest, allowing for typed query parameters instead of string-only values.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/fetch.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = initClient(contract, {\n  baseUrl: 'http://localhost:3334',\n  baseHeaders: {},\n  jsonQuery: true,\n});\n\nconst { data } = await client.posts.get({\n  query: {\n    take: 10,\n    skip: 0,\n    search: 'hello',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Making GET and POST Requests with ts-rest Client\nDESCRIPTION: Shows how to make GET (query) and POST (mutate) requests using the initialized ts-rest client, including passing request body for POST requests.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/fetch.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data } = await client.posts.get();\n\nconst { data, status } = await client.posts.create({\n  body: {\n    title: 'My Post',\n    content: 'This is my post',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up React Query Provider in TSX\nDESCRIPTION: Shows how to set up the QueryClientProvider from @tanstack/react-query to wrap the application and provide the QueryClient instance.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/guides/without-backend.mdx#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\n// Create a client\nconst queryClient = new QueryClient();\n\nconst App = () => {\n  return (\n    // Provide the client to your App\n    <QueryClientProvider client={queryClient}>\n      <Todos />\n    </QueryClientProvider>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Running NestJS Test Suites\nDESCRIPTION: Commands for running different types of tests in a NestJS application using PNPM, including unit tests, end-to-end tests, and test coverage reporting.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/test-projects/nest-9/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# unit tests\n$ pnpm run test\n\n# e2e tests\n$ pnpm run test:e2e\n\n# test coverage\n$ pnpm run test:cov\n```\n\n----------------------------------------\n\nTITLE: Enabling Response Validation with ts-rest Express\nDESCRIPTION: Shows how to enable response validation which will parse and validate responses against the Zod schemas defined in the contract. Failed validations throw a ResponseValidationError.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/express/express.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncreateExpressEndpoints(contract, router, app, {\n  responseValidation: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Fake API with ts-rest and Express in TypeScript\nDESCRIPTION: This snippet shows how to implement a fake API using ts-rest and Express. It uses an in-memory data store to simulate database operations, and implements the contract defined earlier for getting and adding dogs.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/guides/fake-apis.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = express()\napp.use(bodyParser.urlencoded({ extended: false }))\napp.use(bodyParser.json())\n\n// Use a simple in-memory data store instead of a database\nclass InMemoryDogStore {\n  // Initialize with sample data\n  private readonly _dogs = ['fido', 'rex']\n\n  getDogs() {\n    return this._dogs\n  }\n\n  addDog(name: string) {\n    this._dogs.push(name)\n  }\n}\nconst dogStore = new InMemoryDogStore()\n\nconst s = initServer()\nconst router = s.router(contract, {\n  getDogs: async () => {\n    return {\n      status: 200,\n      // Get dogs from the in-memory store\n      body: dogStore.getDogs(),\n    }\n  },\n  addDog: async ({ body: { name } }) => {\n    if (!name) {\n      return {\n        status: 400,\n        body: { error: 'Name is required' },\n      }\n    }\n\n    // Update the in-memory store\n    dogStore.addDog(name)\n\n    return {\n      status: 200,\n      body: { message: 'Dog added' },\n    }\n  },\n})\n\ncreateExpressEndpoints(contract, router, app)\n\napp.listen(6900, () => {\n  console.log('Fake API is running on port 6900')\n})\n```\n\n----------------------------------------\n\nTITLE: Serving ts-rest Documentation\nDESCRIPTION: Command to serve the Docusaurus documentation locally. This also generates TypeDocs in the docs/api directory.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/CONTRIBUTING.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm nx run docs:serve\n```\n\n----------------------------------------\n\nTITLE: Running NestJS tests\nDESCRIPTION: Commands to run unit tests, end-to-end tests, and generate test coverage reports for a NestJS application using pnpm scripts.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/test-projects/nest-10/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# unit tests\n$ pnpm run test\n\n# e2e tests\n$ pnpm run test:e2e\n\n# test coverage\n$ pnpm run test:cov\n```\n\n----------------------------------------\n\nTITLE: Implementing Response Validation in ts-rest\nDESCRIPTION: Shows how to enable response validation for the router using validateResponses option.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/next.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport default createNextRouter(contract, router, { validateResponses: true });\n```\n\n----------------------------------------\n\nTITLE: Implementing Vercel Functions Handler\nDESCRIPTION: Shows how to implement a Vercel Functions handler with edge runtime support. Includes setup for multiple HTTP methods and Vercel-specific context handling.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/fetch-runtimes.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { RequestContext } from '@vercel/edge';\nimport { fetchRequestHandler, tsr } from '@ts-rest/serverless/fetch';\nimport { contract } from './contract';\n\nconst router = tsr\n  .platformContext<{ vercelContext: RequestContext }>()\n  .router(contract, {\n    getPost: async ({ params: { id } }, { vercelContext }) => {\n      return {\n        status: 200,\n        body: {\n          id: id,\n          title: 'Hello, World!',\n        },\n      };\n    },\n  });\n\nconst handler = async (request: Request, vercelContext: RequestContext) => {\n  return fetchRequestHandler({\n    request,\n    contract,\n    router,\n    platformContext: {\n      vercelContext,\n    },\n  });\n};\n\nexport {\n  handler as GET,\n  handler as POST,\n  handler as PUT,\n  handler as PATCH,\n  handler as DELETE,\n};\n```\n\n----------------------------------------\n\nTITLE: Running the ts-rest Development Environment\nDESCRIPTION: Command to start all example apps and documentation in parallel using NX.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/CONTRIBUTING.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# in project root directory\npnpm nx run-many --target=serve --all --parallel=10\n```\n\n----------------------------------------\n\nTITLE: Running Tests in NestJS\nDESCRIPTION: Commands for running unit tests, end-to-end tests, and generating test coverage reports\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/test-projects/nest-11/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# unit tests\n$ pnpm run test\n\n# e2e tests\n$ pnpm run test:e2e\n\n# test coverage\n$ pnpm run test:cov\n```\n\n----------------------------------------\n\nTITLE: Extending OpenAPI Operations with Custom Fields\nDESCRIPTION: This snippet demonstrates how to customize OpenAPI operations using the operationMapper option. It shows how to add tags and security requirements to operations by leveraging the metadata field in contract endpoints.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/open-api.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst hasCustomTags = (\n  metadata: unknown,\n): metadata is { openApiTags: string[] } => {\n  return (\n    !!metadata &&\n    typeof metadata === 'object' &&\n    'openApiTags' in metadata\n  );\n};\n\nconst hasSecurity = (\n  metadata: unknown,\n): metadata is { openApiSecurity: SecurityRequirementObject[] } => {\n  return (\n    !!metadata &&\n    typeof metadata === 'object' &&\n    'openApiSecurity' in metadata\n  );\n};\n\nconst apiDoc = generateOpenApi(\n  router,\n  {\n    info: { title: 'Blog API', version: '0.1' },\n    components: {\n      securitySchemes: {\n        BasicAuth: {\n          type: 'http',\n          scheme: 'basic',\n        },\n      },\n    },\n  },\n  {\n    operationMapper: (operation, appRoute) => ({\n      ...operation,\n      ...(hasCustomTags(appRoute.metadata)\n        ? {\n            tags: appRoute.metadata.openApiTags,\n          }\n        : {}),\n      ...(hasSecurity(appRoute.metadata)\n        ? {\n            security: appRoute.metadata.openApiSecurity,\n          }\n        : {}),\n    }),\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Accessing Raw Request Body and Content Type in ts-rest Client\nDESCRIPTION: Shows how to access the raw request body and content type in a custom API implementation. This is useful when you need to work with the original request data before it's processed.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/custom.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = initClient(contract, {\n  baseUrl: 'http://localhost:5003',\n  baseHeaders: {},\n  api: async ({ path, method, headers, body, rawBody, contentType }) => {\n    // do something with rawBody \n    return tsRestFetchApi(args);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Building the ts-rest-serverless Library with Nx\nDESCRIPTION: Command for building the ts-rest-serverless library using the Nx build system.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/serverless/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnx build ts-rest-serverless\n```\n\n----------------------------------------\n\nTITLE: Running NestJS Application in Different Modes\nDESCRIPTION: Commands for running the application in development, watch, and production modes using PNPM\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/test-projects/nest-11/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# development\n$ pnpm run start\n\n# watch mode\n$ pnpm run start:dev\n\n# production mode\n$ pnpm run start:prod\n```\n\n----------------------------------------\n\nTITLE: Configuring operationId in OpenAPI Generation\nDESCRIPTION: This snippet demonstrates how to enable operationId generation in the OpenAPI document. It shows how to set the setOperationId option to either true or 'concatenated-path' to generate unique operation identifiers for endpoints.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/open-api.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst openApiSchema = generateOpenApi(\n  postsApi,\n  {\n    info: {\n      title: 'Posts API',\n      version: '1.0.0',\n    },\n  },\n  {\n    setOperationId: true,\n    // setOperationId: 'concatenated-path',\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Query Implementation\nDESCRIPTION: Example of using useQuery hook with static parameters.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/vue-query.mdx#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst queryResult = client.posts.get.useQuery(\n  ['posts'], // <- queryKey\n  () => ({\n    params: {\n      id: '1';\n    }\n  }), // <- Query params, Params, Body etc (all typed)\n  { staleTime: 1000 } // <- vue-query options (optional)\n);\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests for ts-rest-serverless with Jest\nDESCRIPTION: Command for executing unit tests for the ts-rest-serverless library using Jest via Nx.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/serverless/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnx test ts-rest-serverless\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with PNPM\nDESCRIPTION: Command to install all project dependencies using PNPM package manager\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/test-projects/nest-11/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm install\n```\n\n----------------------------------------\n\nTITLE: Using QueryClient Methods for Infinite Queries with ts-rest\nDESCRIPTION: This snippet shows how to use fetchInfiniteQuery and prefetchInfiniteQuery methods on the ts-rest extended QueryClient. It demonstrates prefetching infinite query data on the server-side and hydrating it on the client-side.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/use-infinite-query.md#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { dehydrate, HydrationBoundary, QueryClient } from '@tanstack/react-query';\nimport { tsr } from './tsr';\n\nexport default async function Page() {\n  const tsrQueryClient = tsr.initQueryClient(new QueryClient());\n  \n  const initialPageParam = { skip: 0, take: 10 };\n  await tsrQueryClient.getPosts.prefetchInfiniteQuery({\n    queryKey: ['posts'],\n    queryData: {\n      query: initialPageParam,\n    },\n    initialPageParam,\n  });\n\n  return (\n    <main>\n      <HydrationBoundary state={dehydrate(tsrQueryClient)}>\n        <Posts />\n      </HydrationBoundary>\n    </main>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Query Parameters\nDESCRIPTION: Implementation of useQuery with dynamic parameters using Vue reactive refs.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/vue-query.mdx#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst postId = computed(() => selectedPost.value.id);\n\nconst queryResult = client.posts.get.useQuery(\n  ['posts', postId], // <- queryKey with reactive ref\n  (context) => ({\n    params: {\n      id: postId.value; //  or use queryKey passed to context: context.queryKey[1]\n    }\n  }),\n  { enabled: computed(() => !!postId.value) } // <- make sure to use computed values for reactive options\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Solid.js Project\nDESCRIPTION: Command to install project dependencies using npm, pnpm, or yarn package managers. The project uses pnpm for dependency management as indicated by the pnpm-lock.yaml file.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/example-microservice/web-app-solid/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm install # or pnpm install or yarn install\n```\n\n----------------------------------------\n\nTITLE: Running Tests for ts-rest\nDESCRIPTION: Command to run tests for affected applications using NX.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/CONTRIBUTING.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm nx affected:test\n```\n\n----------------------------------------\n\nTITLE: Initializing VueQuery Plugin\nDESCRIPTION: Basic setup for adding VueQueryPlugin to a Vue application.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/vue-query.mdx#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { VueQueryPlugin } from '@tanstack/vue-query';\n\ncreateApp(App).use(VueQueryPlugin).mount('#app');\n```\n\n----------------------------------------\n\nTITLE: Offset-Based Infinite Query\nDESCRIPTION: Implementation of infinite query using offset-based pagination with skip and take parameters.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/vue-query.mdx#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst PAGE_SIZE = 5;\n\nexport function Index() {\n  const { isLoading, data, hasNextPage, fetchNextPage } =\n    client.getPosts.useInfiniteQuery(\n      ['posts'],\n      ({ pageParam = { skip: 0, take: PAGE_SIZE } }) => ({\n        query: { skip: pageParam.skip, take: pageParam.take },\n      }),\n      {\n        getNextPageParam: (lastPage, allPages) =>\n          lastPage.status === 200\n            ? lastPage.body.count > allPages.length * PAGE_SIZE\n              ? { take: PAGE_SIZE, skip: allPages.length * PAGE_SIZE }\n              : undefined\n            : undefined,\n      }\n    );\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!data) {\n    return <div>No posts found</div>;\n  }\n\n  const posts = data.pages.flatMap((page) =>\n    page.status === 200 ? page.body.posts : []\n  );\n\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting ts-rest Parameter Decorator Names\nDESCRIPTION: Helper function that identifies parameter decorators specific to ts-rest, looking for ApiDecorator or TsRestRequest in the decorator name.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/src/components/nestTransform.txt#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst isTsRestParameterDecoratorName = (str: string): boolean => {\n  return str.includes('ApiDecorator') || str.includes('TsRestRequest');\n};\n```\n\n----------------------------------------\n\nTITLE: Running Linting for ts-rest\nDESCRIPTION: Command to run linting checks on affected applications using NX.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/CONTRIBUTING.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm nx affected:lint\n```\n\n----------------------------------------\n\nTITLE: Query Client Helpers Implementation\nDESCRIPTION: Example of using QueryClient helpers with mutation and query data updates\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/v4.mdx#2025-04-17_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initQueryClient, useTsRestQueryClient } from '@ts-rest/react-query';\n\nexport const client = initQueryClient(router);\n\nconst App = () => {\n  const apiQueryClient = useTsRestQueryClient(client);\n\n  const { data, isLoading, error } = apiQueryClient.posts.get.useQuery(['posts']);\n  const { mutate, isLoading } = client.posts.create.useMutation();\n\n  const createPost = async () => {\n    return mutate(\n      { body: { title: 'Hello World' } },\n      {\n        onSuccess: async (data) => {\n          apiQueryClient.posts.get.setQueryData(['posts'], (oldPosts) => {\n            return {\n              ...oldPosts,\n              body: [...oldPosts.body, data.body],\n            };\n          });\n        },\n      },\n    );\n  };\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (data?.status !== 200) {\n    return <div>Error</div>;\n  }\n\n  return (\n    <div>\n      <button onClick={createPost}>Create Post</button>\n      {data.body.map((post) => (\n        <p key={post.id}>post.title</p>\n      ))}\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring JSON Query Parameters in ts-rest\nDESCRIPTION: Example of enabling JSON query parameter handling in the Next.js router configuration.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/next.mdx#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport default createNextRouter(contract, router, { jsonQuery: true });\n```\n\n----------------------------------------\n\nTITLE: Building the ts-rest-vue-query Library with Nx\nDESCRIPTION: Command for building the ts-rest-vue-query library using the Nx build system. This command compiles the library code and generates the distributable package.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/vue-query/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnx build ts-rest-vue-query\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests for ts-rest-nest with Jest\nDESCRIPTION: Command for executing unit tests for the ts-rest-nest library using Jest through the Nx test runner.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/nest/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnx test ts-rest-nest\n```\n\n----------------------------------------\n\nTITLE: Configuring ts-rest Express Options\nDESCRIPTION: Shows the available options for the createExpressEndpoints function, including logging, query parsing, response validation, middleware, and error handling configuration.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/express/express.mdx#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype Options = {\n  logInitialization?: boolean; // print route initialization logs to console\n  jsonQuery?: boolean;\n  responseValidation?: boolean;\n  globalMiddleware?: ((req, res, next) => void)[];\n  requestValidationErrorHandler?:\n    | 'default'\n    | 'combined'\n    | ((err: RequestValidationError, req, res, next) => void);\n};\n```\n\n----------------------------------------\n\nTITLE: RequestValidationError Class Definition\nDESCRIPTION: Definition of the RequestValidationError class used for handling validation errors in requests.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/next.mdx#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport class RequestValidationError extends Error {\n  constructor(\n    public pathParams: z.ZodError | null,\n    public headers: z.ZodError | null,\n    public query: z.ZodError | null,\n    public body: z.ZodError | null,\n  ) {\n    super('[ts-rest] request validation failed');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Supported Versions in Markdown Table\nDESCRIPTION: This snippet shows a markdown table that clearly indicates which versions of ts-rest are supported for security updates. Versions 3.x.x and above are supported, while versions below 2.0 are not.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/SECURITY.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Version  | Supported          |\n| -------- | ------------------ |\n| >= 3.x.x | :white_check_mark: |\n| < 2.0    | :x:                |\n```\n\n----------------------------------------\n\nTITLE: Running unit tests for example-contracts with Nx and Jest\nDESCRIPTION: Command to execute unit tests for the example-contracts library using Nx and Jest testing framework.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/example-contracts/README.md#2025-04-17_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnx test example-contracts\n```\n\n----------------------------------------\n\nTITLE: Example OpenAPI Document with operationId\nDESCRIPTION: This snippet shows an example of what an OpenAPI document looks like with operationId enabled. It demonstrates the structure of the paths object and how the operationId is included in the operation object.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/open-api.mdx#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  \"openapi\": \"3.0.2\",\n  \"paths\": {\n    \"/posts\": {\n      \"get\": {\n        \"description\": \"Get all posts\",\n        \"tags\": [],\n        \"parameters\": [\n          {\n            \"name\": \"userId\",\n            \"in\": \"query\",\n            \"schema\": {\n              \"type\": \"number\"\n            }\n          }\n        ],\n        \"operationId\": \"getPosts\", // <--- This is the operationId\n        // or\n        \"operationId\": \"posts.getPosts\", // <--- If using concatenated-path\n        \"responses\": {\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Common Responses in ts-rest\nDESCRIPTION: Demonstrates how to configure common response types that are shared across multiple endpoints.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = initContract();\nexport const contract = c.router(\n  {\n    // ...endpoints\n  },\n  {\n    commonResponses: {\n      404: c.type<{ message: 'Not Found'; reason: string }>(),\n      500: c.otherResponse({\n        contentType: 'text/plain',\n        body: z.literal('Server Error'),\n      }),\n    },\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Running NestJS application in different modes\nDESCRIPTION: Commands to start a NestJS application in development, watch, or production mode using pnpm scripts.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/test-projects/nest-10/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# development\n$ pnpm run start\n\n# watch mode\n$ pnpm run start:dev\n\n# production mode\n$ pnpm run start:prod\n```\n\n----------------------------------------\n\nTITLE: Building the example-contracts library with Nx\nDESCRIPTION: Command to build the example-contracts library using Nx build system.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/example-contracts/README.md#2025-04-17_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnx build example-contracts\n```\n\n----------------------------------------\n\nTITLE: Using Nested Path Prefixes in ts-rest Contracts\nDESCRIPTION: Shows how to use pathPrefix in nested contracts to create hierarchical API paths. In this example, combining '/v1' from the parent and '/posts' from the nested contract results in paths like '/v1/posts/mypath'.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/core/core.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst nestedContract = c.router(\n  {\n    getPost: {\n      path: '/mypath',\n      //... Your Contract\n    },\n  },\n  {\n    pathPrefix: '/posts',\n  }\n);\n\nconst parentContract = c.router(\n  {\n    posts: nestedContract,\n  },\n  {\n    pathPrefix: '/v1',\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Removing NestRequestShapes and NestResponseShapes Type Aliases\nDESCRIPTION: This function removes type alias declarations for NestRequestShapes and NestResponseShapes from the AST. It visits each node and removes the declaration if it matches either of these types.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/src/components/nestTransform.txt#2025-04-17_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction removeNestRequestShapesTypes(context: ts.TransformationContext) {\n  const visitor: ts.Visitor = (node: ts.Node): ts.VisitResult<ts.Node> => {\n    if (ts.isTypeAliasDeclaration(node)) {\n      if (ts.isTypeReferenceNode(node.type)) {\n        const typeName = node.type.typeName.getText();\n        if (\n          typeName === 'NestRequestShapes' ||\n          typeName === 'NestResponseShapes'\n        ) {\n          return undefined;\n        }\n      }\n    }\n    return ts.visitEachChild(node, visitor, context);\n  };\n  return (rootNode: ts.Node) => ts.visitNode(rootNode, visitor);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Jest Tests for Posts API Library\nDESCRIPTION: Command to execute Jest unit tests for the example-microservice-util-posts-api library using Nx test runner.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/example-microservice/util-posts-api/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnx test example-microservice-util-posts-api\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure Functions Route Prefix in JSON\nDESCRIPTION: This JSON configuration removes the default 'api' route prefix in Azure Functions. It should be added to the host.json file to ensure proper routing with ts-rest contracts.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/serverless/azure-functions.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  ...,\n  \"extensions\": {\n    \"http\": {\n      \"routePrefix\": \"\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Posts API Library with Nx\nDESCRIPTION: Command to build the example-microservice-util-posts-api library using Nx build tools.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/example-microservice/util-posts-api/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnx build example-microservice-util-posts-api\n```\n\n----------------------------------------\n\nTITLE: Configuring Strict Mode in tsconfig.json for Zod Integration\nDESCRIPTION: Configuration snippet for TypeScript's tsconfig.json to enable strict mode, which is required for Zod integration with ts-rest. Without strict mode, performance issues may occur.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/quickstart.mdx#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n  \"compilerOptions\": {\n    ...\n    \"strict\": true\n  }\n```\n\n----------------------------------------\n\nTITLE: Running Vue.js Microservice Web Application with nx\nDESCRIPTION: This command uses nx to serve the Vue.js microservice web application locally. It assumes the project is set up with nx and the application is named 'example-microservice-web-app-vue'.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/example-microservice/web-app-vue/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnx serve example-microservice-web-app-vue\n```\n\n----------------------------------------\n\nTITLE: Identifying ts-rest Method Decorators\nDESCRIPTION: Function that checks if a string represents a ts-rest method decorator by looking for 'Api' or 'TsRest' in the name, used to identify methods that should be transformed.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/src/components/nestTransform.txt#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst isTsRestMethodDecorator = (str: string): boolean => {\n  return str.includes('Api') || str.includes('TsRest');\n};\n```\n\n----------------------------------------\n\nTITLE: Running TS-REST Example Microservice Web App Locally\nDESCRIPTION: Command to start the example microservice web application locally using the nx development server. This allows developers to run and test the application in a development environment.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/example-microservice/web-app/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnx serve example-microservice-web-app\n```\n\n----------------------------------------\n\nTITLE: Building ts-rest-next Library with Nx\nDESCRIPTION: Command to build the ts-rest-next library using Nx build system.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/next/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnx build ts-rest-next\n```\n\n----------------------------------------\n\nTITLE: Building Project with Nx\nDESCRIPTION: Command to build the non-strict-mode-test library using Nx build system\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/non-strict-mode-test/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnx build non-strict-mode-test\n```\n\n----------------------------------------\n\nTITLE: Embedding Star History Chart with Dark/Light Mode Support\nDESCRIPTION: HTML code for embedding a responsive star history chart that adapts to user's color scheme preference using the picture element with multiple sources.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/README.md#2025-04-17_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<div align=\"center\">\n<a href=\"https://star-history.com/#ts-rest/ts-rest&Timeline\">\n  <picture>\n    <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://api.star-history.com/svg?repos=ts-rest/ts-rest&type=Timeline&theme=dark\" />\n    <source media=\"(prefers-color-scheme: light)\" srcset=\"https://api.star-history.com/svg?repos=ts-rest/ts-rest&type=Timeline\" />\n    <img alt=\"Star History Chart\" src=\"https://api.star-history.com/svg?repos=ts-rest/ts-rest&type=Timeline\" />\n  </picture>\n</a>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Discord Community Section with Widget\nDESCRIPTION: HTML markup for the Discord community section, including invitation text and a banner widget displaying server information.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/README.md#2025-04-17_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<div align=\"center\" >\n  <div>Join us on Discord for help, feedback, and discussions!</div><br></br>\n  <a href=\"https://discord.gg/2Megk85k5a\">\n    <img src=\"https://discordapp.com/api/guilds/1055855205960392724/widget.png?style=banner2\" alt=\"Discord Shield\"/>\n  </a>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in React Component using ts-rest and React Query\nDESCRIPTION: This code snippet demonstrates how to handle different types of errors when fetching a post using ts-rest and React Query. It shows how to use the isFetchError function and handle specific HTTP status codes.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/react-query/error-handling.md#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { isFetchError } from '@ts-rest/react-query/v5';\nimport { tsr } from './tsr';\n\nconst Post = ({ id }: { id: string }) => {\n  const { data, error, isPending } = tsr.getPost.useQuery({\n    queryKey: ['posts', id],\n    queryData: {\n      params: { id },\n    },\n  });\n\n  if (isPending) {\n    return <div>Loading...</div>;\n  }\n\n  if (error) {\n    if (isFetchError(error)) {\n      return <div>We could not retrieve this post. Please check your internet connection.</div>;\n    }\n    \n    if (error.status === 404) {\n      return <div>Post not found</div>;\n    }\n\n    return <div>Unexpected error occurred</div>;\n  }\n\n  return (\n    <div>\n      <h1>{data.body.title}</h1>\n      <p>{data.body.content}</p>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Changelog Entry for Version 3.30.4\nDESCRIPTION: Markdown documentation noting security fix for zod CVE vulnerability by updating minimum zod peer dependency version.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/fastify/CHANGELOG.md#2025-04-17_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n### Patch Changes\n- 10dff96: - fix: address `zod` [CVE](https://nvd.nist.gov/vuln/detail/CVE-2023-4316) with bump `@ts-rest` peer dependency `zod` to minimum `^3.22.3`\n  - ref PR: https://github.com/colinhacks/zod/pull/2824\n```\n\n----------------------------------------\n\nTITLE: Building the ts-rest-nest Library with Nx\nDESCRIPTION: Command for building the ts-rest-nest library using the Nx build system.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/nest/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnx build ts-rest-nest\n```\n\n----------------------------------------\n\nTITLE: Displaying Image in Markdown\nDESCRIPTION: This snippet demonstrates how to embed an image in a Markdown file using the standard Markdown image syntax. The image is referenced as 'Example banner' and the source path is relative to the current file location.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/examples.mdx#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n![Example banner](../static/img/blog-example.png)\n```\n\n----------------------------------------\n\nTITLE: Running Jest Unit Tests for ts-rest-vue-query\nDESCRIPTION: Command for executing unit tests for the ts-rest-vue-query library using Jest as the test runner. This runs all test files associated with the library.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/vue-query/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnx test ts-rest-vue-query\n```\n\n----------------------------------------\n\nTITLE: Deploying with Mau on AWS\nDESCRIPTION: Commands for installing Mau CLI globally and deploying the NestJS application to AWS\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/test-projects/nest-11/README.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm install -g mau\n$ mau deploy\n```\n\n----------------------------------------\n\nTITLE: Demonstrating tRPC Endpoint Structure\nDESCRIPTION: Example showing how tRPC structures its API endpoints in an RPC-style format.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/apps/docs/docs/comparisons/rpc-comparison.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n\"/trpc/getPosts\"\n\"/trpc/getPostComments\"\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests for ts-rest-next\nDESCRIPTION: Command to execute unit tests for the ts-rest-next library using Jest test runner through Nx.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/ts-rest/next/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnx test ts-rest-next\n```\n\n----------------------------------------\n\nTITLE: Cloning and Setting Up the ts-rest Repository\nDESCRIPTION: Commands to clone the repository and install dependencies using pnpm.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/CONTRIBUTING.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:ts-rest/ts-rest.git\ncd ts-rest\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Building the Users API Library with Nx\nDESCRIPTION: Command to build the example-microservice-util-users-api library using Nx build tools.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/example-microservice/util-users-api/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnx build example-microservice-util-users-api\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests for Users API with Jest\nDESCRIPTION: Command to execute unit tests for the example-microservice-util-users-api library using Jest via Nx.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/example-microservice/util-users-api/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnx test example-microservice-util-users-api\n```\n\n----------------------------------------\n\nTITLE: Installing NestJS Project Dependencies with PNPM\nDESCRIPTION: Command to install all dependencies for a NestJS project using PNPM package manager. This should be run in the project root directory before running any other commands.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/test-projects/nest-9/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm install\n```\n\n----------------------------------------\n\nTITLE: Running NestJS Application in Different Modes\nDESCRIPTION: Commands for running a NestJS application in development, watch, and production modes using PNPM. These commands execute predefined scripts in the package.json file.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/test-projects/nest-9/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# development\n$ pnpm run start\n\n# watch mode\n$ pnpm run start:dev\n\n# production mode\n$ pnpm run start:prod\n```\n\n----------------------------------------\n\nTITLE: Installing NestJS dependencies with pnpm\nDESCRIPTION: Command to install all required dependencies for a NestJS project using pnpm package manager.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/test-projects/nest-10/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm install\n```\n\n----------------------------------------\n\nTITLE: Vercel Sponsorship Badge\nDESCRIPTION: HTML code for displaying the Vercel sponsorship badge with proper attribution and styling.\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/README.md#2025-04-17_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<div  align=\"center\">\n  <a\n    href=\"https://vercel.com/?utm_source=ts-rest&utm_campaign=oss\"\n    target=\"_blank\"\n    rel=\"noreferrer\"\n  >\n    <img\n      src=\"https://ts-rest.com/img/powered-by-vercel.svg\"\n      alt=\"Powered by Vercel\"\n      height=\"40\"\n    />\n  </a>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with Jest\nDESCRIPTION: Command to execute unit tests for the library using Jest testing framework through Nx\nSOURCE: https://github.com/ts-rest/ts-rest/blob/main/libs/non-strict-mode-test/README.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnx test non-strict-mode-test\n```"
  }
]