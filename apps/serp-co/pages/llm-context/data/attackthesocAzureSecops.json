[
  {
    "owner": "attackthesoc",
    "repo": "azure-secops",
    "content": "TITLE: Detecting Shadow Credentials KCL Modification IP Anomaly (KQL)\nDESCRIPTION: This KQL query identifies suspicious modifications to the msDS-KeyCredentialLink (KCL) attribute of computer objects (EventID 5136) by parsing XML EventData. It then correlates these modifications with corresponding logon events (EventID 4624) using the SubjectLogonId. Finally, it joins this with DeviceNetworkInfo data to check if the source IP address of the logon event is an IP not historically associated with the target device, flagging potential shadow credential abuse from an unexpected location. It requires SecurityEvent and DeviceNetworkInfo tables in the Log Analytics workspace.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/UEBA/ShadowCredentialsAddedtoADComputerObject.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\nlet domainName = \".domain.com\";\nlet kcl_added = materialize ( SecurityEvent\n| where EventID == 5136 and OperationType == @\"%%14674\" // all DS object modified events where a value add operation took place\n// now to parse out the EventData XML values to only pull writes to the KCL \n| project EventData\n| extend EventDataXml = parse_xml(EventData)\n| extend DataElements = EventDataXml[\"EventData\"][\"Data\"]\n| mv-expand DataElement = DataElements\n| extend Name = tostring(DataElement[\"@Name\"]), Value = tostring(DataElement[\"#text\"])\n| summarize bag = make_bag(bag_pack(Name, Value)) by EventData\n| evaluate bag_unpack(bag)\n| extend AttributeLDAPDisplayName = column_ifexists('AttributeLDAPDisplayName','x'), OperationType = column_ifexists('OperationType','x'), SubjectLogonId = column_ifexists('SubjectLogonId','x')\n| project AttributeLDAPDisplayName, OperationType, SubjectLogonId\n| where AttributeLDAPDisplayName == \"msDS-KeyCredentialLink\"\n| project SubjectLogonId);\nlet correlateLogon = materialize ( SecurityEvent\n| where EventID == 4624\n| where TargetLogonId in (kcl_added) // looking for the correlated logon events via the SubjectLogoId\n| project IpAddress, WorkstationName = tolower(strcat(WorkstationName, domainName)));\nDeviceNetworkInfo\n| join kind=inner correlateLogon on $left.DeviceName == $right.WorkstationName\n// check for any logons where the IP does not match any known IPs associated with the host\n| where IPAddresses !has IpAddress\n| summarize count() by TargetComputer = WorkstationName, AttackerIP = IpAddress\n| project-away count_\n```\n\n----------------------------------------\n\nTITLE: Template for Custom Conditional Access Gap Detection Queries in KQL\nDESCRIPTION: This KQL template provides a base structure for building custom Conditional Access policy gap detection queries. It includes methods for filtering by group membership, admin roles, client application, authentication requirement, resource ID, app display name, parsing network location details, and parsing device details. It is intended as a starting point for adapting to specific policy requirements.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/ConditionalAccessPolicies/CAP-Gap-Detections.md#_snippet_3\n\nLANGUAGE: KQL\nCODE:\n```\nlet firstyPartyIds = dynamic([\"c2ada927-a9e2-4564-aae2-70775a2fa0af\",\"04436913-cf0d-4d2a-9cc6-2ffe7f1d3d1c\"]);\nlet privilegedRoles = dynamic([\"Global Administrator\", \"Application Administrator\", \"Authentication Administrator\", \"Billing Administrator\", \"Cloud Application Administrator\", \"Conditional Access Administrator\", \"Exchange Administrator\", \"Helpdesk Administrator\", \"Password Administrator\", \"Privileged Authentication Administrator\", \"Privileged Role Administrator\", \"Security Administrator\", \"SharePoint Administrator\", \"User Administrator\"]);\nlet excludedResourceIds = dynamic([\"\"]);\nlet CAPTargetGroups = materialize ( ExposureGraphEdges\n| where EdgeLabel == \"member of\" and TargetNodeLabel == \"group\"\n| where TargetNodeName == \"<GROUP_NAME>\"\n| distinct SourceNodeName);\nlet CAPTargetAdmins = IdentityInfo\n| where AssignedRoles has_any(privilegedRoles)\n| distinct AccountDisplayName;\nSigninLogs\n| where Identity in (CAPTargetGroups)\n| where ResultType == 0\n//# Specify expected included/excluded Client App or comment-out for all\n| where ClientAppUsed == @\"Mobile Apps and Desktop clients\" or ClientAppUsed == @\"Browser\"\n| where AuthenticationRequirement == @\"singleFactorAuthentication\" or AuthenticationRequirement == @\"multiFactorAuthentication\"\n// when looking for single factor, exclude the expected\n| where ResourceId in (firstyPartyIds, excludedResourceIds)\n| where AppDisplayName != @\"Windows Sign In\"\n| where ResourceTenantId == AADTenantId\n| where ConditionalAccessStatus == \"notApplied\"\n//# Specify expected included/exlcuded ResourceDisplayName (ex. is of CAP excluded apps)\n| where ResourceDisplayName != @\"\" and AppDisplayName != @\"\"\n//# Parse out NetworkLocationDetails\n| mv-expand NetworkLocationDetails\n| extend NetworkLocationDetails = parse_json(NetworkLocationDetails)\n| extend NamedLocation = NetworkLocationDetails.networkNames\n| extend NetworkType = tostring(NetworkLocationDetails.networkType)\n| project-away NetworkLocationDetails\n//# Specify expected Device Details\n| extend DeviceDetail = parse_json(DeviceDetail)\n| extend\n              DeviceId = DeviceDetail.deviceId,\n              DisplayName = DeviceDetail.displayName,\n              OS = DeviceDetail.operatingSystem,\n              Browser = DeviceDetail.browser,\n              IsCompliant = DeviceDetail.isCompliant,\n              IsManaged = DeviceDetail.isManaged,\n              TrustType = DeviceDetail.trustType\n| project-away DeviceDetail\n```\n\n----------------------------------------\n\nTITLE: Detecting Single-Factor Authentication for Administrators in KQL\nDESCRIPTION: This query identifies successful sign-ins using single-factor authentication by users who are members of a specified group or hold privileged Microsoft Entra ID roles. It helps detect potential policy gaps where administrators might bypass MFA requirements. The query filters out specific first-party and excluded resource IDs.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/ConditionalAccessPolicies/CAP-Gap-Detections.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\nlet firstPartyIds = dynamic([\"c2ada927-a9e2-4564-aae2-70775a2fa0af\",\"04436913-cf0d-4d2a-9cc6-2ffe7f1d3d1c\"]);\nlet excludedResourceIds = dynamic([]);\n// initialize list of CAP targeted group members\nlet CAPTargetGroup = materialize(ExposureGraphEdges\n| where EdgeLabel == \"member of\" and TargetNodeLabel == \"group\"\n| where TargetNodeName == \"<GROUP_NAME>\"\n| distinct SourceNodeName);\nlet privilegedRoles = dynamic([\"Global Administrator\", \"Application Administrator\", \"Authentication Administrator\", \"Billing Administrator\", \"Cloud Application Administrator\", \"Conditional Access Administrator\", \"Exchange Administrator\", \"Helpdesk Administrator\", \"Password Administrator\", \"Privileged Authentication Administrator\", \"Privileged Role Administrator\", \"Security Administrator\", \"SharePoint Administrator\", \"User Administrator\"]);\nlet CAPTargetAdmins = IdentityInfo\n| where AssignedRoles has_any(privilegedRoles)// or isnotempty(PrivilegedEntraPimRoles)\n| distinct AccountDisplayName;\nSigninLogs\n| where Identity in (CAPTargetGroup, CAPTargetAdmins)\n| where ResultType == 0\n| where AuthenticationRequirement == @\"singleFactorAuthentication\"\n// when looking for single-factor authentication exclude the expected\n| where ResourceId !in (firstPartyIds, excludedResourceIds)\n| where AppDisplayName != @\"Windows Sign In\"\n| project-away OperationName, OperationVersion, Category, DurationMs, Resource, ResourceGroup, ProcessingTimeInMilliseconds\n```\n\n----------------------------------------\n\nTITLE: Identifying Single-Factor Sign-Ins to Resources with No CAP Applied in KQL\nDESCRIPTION: This query finds successful single-factor sign-ins to specified internal or excluded resources within the tenant where no Conditional Access policy was applied. This helps highlight applications or services potentially overlooked by CAP coverage. It filters by result type, tenant ID, authentication requirement, and Conditional Access status.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/ConditionalAccessPolicies/CAP-Gap-Detections.md#_snippet_2\n\nLANGUAGE: KQL\nCODE:\n```\nlet firstPartyIds = dynamic([\"c2ada927-a9e2-4564-aae2-70775a2fa0af\",\"04436913-cf0d-4d2a-9cc6-2ffe7f1d3d1c\"]);\nlet excludedResourceIds = dynamic([]);\nSigninLogs\n| where ResultType == 0\n| where ResourceTenantId == AADTenantId\n| where AuthenticationRequirement == @\"singleFactorAuthentication\"\n| where ConditionalAccessStatus == \"notApplied\"\n// when looking for single factor authentication exclude the expected\n| where ResourceId in (firstPartyIds, excludedResourceIds)\n| where AppDisplayName != @\"Windows Sign In\"\n| where ResourceTenantId == AADTenantId\n```\n\n----------------------------------------\n\nTITLE: Correlating Live Response Commands using KQL\nDESCRIPTION: This KQL query analyzes DeviceProcessEvents in Defender XDR to identify processes initiated by the Live Response tool (SenseIR.exe OnlineSenseIR). It joins these initiating processes with subsequent process events, filters out common noise and specific detection/lure configurations, and uses the row_window_session function to group related commands within 10-minute windows with a 3-minute inactivity timeout, providing a review of actions taken during each session. Dependencies include access to Defender XDR data, specifically DeviceProcessEvents.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Endpoint/Live Response Session Review.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\nlet PIDs = DeviceProcessEvents\n| where InitiatingProcessCommandLine startswith @\"\"\"SenseIR.exe\"\" \"\"OnlineSenseIR\"\"\"\n| project DeviceId, ProcessId;\nPIDs\n| join DeviceProcessEvents on $right.InitiatingProcessId == $left.ProcessId , $right.DeviceId == $left.DeviceId\n| where FileName !in (\"csc.exe\", \"conhost.exe\") // noisy processes\n| where InitiatingProcessFileName == \"powershell.exe\"\n| where ProcessCommandLine !contains \"ew0KICAgICJTY2FubmVyQXJncyI\" // Disovery scan configs\n| where InitiatingProcessCommandLine !contains \"eyJEZXRlY3Rpb25LZXlzIjp\" // MDE deception lure configs\n| sort by DeviceId, TimeGenerated asc\n| extend EventSessionId = row_window_session(TimeGenerated, 10m, 3m, DeviceId != prev(DeviceId))\n| project DeviceName, TimeGenerated, FileName, ProcessCommandLine, EventSessionId\n```\n\n----------------------------------------\n\nTITLE: Detecting Specific App Access by Group from Untrusted Locations or Unmanaged Devices in KQL\nDESCRIPTION: This KQL query identifies successful sign-ins to a specific application by members of a target group that originate from locations not marked as trusted, or from devices that do not meet specified compliance and management criteria (e.g., not marked as compliant/managed or having unexpected trust types). It requires specifying the target group name and application display name.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/ConditionalAccessPolicies/CAP-Gap-Detections.md#_snippet_1\n\nLANGUAGE: KQL\nCODE:\n```\nlet excludedUsers = dynamic([\"\"]);\nlet CAPTargetGroup = materialize(ExposureGraphEdges\n| where EdgeLabel == \"member of\" and TargetNodeLabel == \"group\"\n| where TargetNodeName == \"<GROUP_NAME>\"\n| distinct SourceNodeName);\nSigninLogs\n| where ApplicationDisplayName == @\"<AppDisplayName>\"//ResourceId == @\"<resourceId>\"\n| where ResultType == 0\n| where Identity in (CAPTargetGroup) and Identity !in (excludedUsers)\n| where NetworkLocationDetails !has \"trustedNamedLocation\"\n| extend DeviceDetail = parse_json(DeviceDetail)\n//# Specify expected Device Details\n| extend\n              IsCompliant = DeviceDetail.isCompliant,\n              IsManaged = DeviceDetail.isManaged,\n              TrustType = DeviceDetail.trustType\n//# modify according to what is expected in your environment\n| where IsCompliant == true\n| where IsManaged == true              \n| where TrustType in (\"Workplace\", \"AzureAD\", \"ServerAD\")\n| project-away OperationName, OperationVersion, Category, DurationMs, Resource, ResourceGroup, ProcessingTimeInMilliseconds, DeviceDetail, NetworkLocationDetails\n```\n\n----------------------------------------\n\nTITLE: Identify Low Prevalence Service Installations (KQL)\nDESCRIPTION: This KQL query identifies service installations (`ActionType == \"ServiceInstalled\"`) that have a low count (<= 3) across devices based on their extracted service name. It first finds the `ReportId` values associated with these rare services and then retrieves the full `DeviceEvents` for those `ReportId`s, excluding services installed with a manual start type (`ServiceStartType != 3`). It requires Windows event ID 4697 and the Audit Security System Extension setting enabled to gather the necessary data.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Endpoint/Low Prev Svc Installs by SvcName.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\nlet susServices = DeviceEvents\n| where ActionType == \"ServiceInstalled\"\n| extend AdditionalFieldsParsed = parse_json(AdditionalFields)\n| evaluate bag_unpack(AdditionalFieldsParsed)\n//| where ServiceStartType != 3 // uncomment to exclude services installed with a start type of Manual\n| extend ServiceName = extract(\"^[a-zA-Z]+\", 0, ServiceName)\n| summarize any(ReportId), count() by ServiceName\n| where count_ <= 3\n| project any_ReportId;\nDeviceEvents\n| where ActionType == \"ServiceInstalled\" and ReportId in (susServices)\n| extend AdditionalFieldsParsed = parse_json(AdditionalFields)\n| evaluate bag_unpack(AdditionalFieldsParsed)\n| where ServiceStartType != 3\n| extend ServiceName = extract(\"^[a-zA-Z]+\", 0, ServiceName)\n```\n\n----------------------------------------\n\nTITLE: Querying Defender Live Response API Sessions - KQL\nDESCRIPTION: This KQL query identifies endpoints where a Live Response session was initiated via API (`RunLiveResponseApi`) and correlates the session with subsequent device process events using time proximity and process lineage. It filters out known noisy processes and specific MDE configuration command lines to highlight user-executed commands during the session. Dependencies include access to CloudAppEvents and DeviceProcessEvents tables in Microsoft Defender XDR. The output includes Device Name, event timestamp, executed file name, full command line, a session identifier, and the initial API commands string.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Endpoint/Live Response via API Session Review.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\nlet lrSessionStarted = CloudAppEvents\n| where ActionType == \"RunLiveResponseApi\"\n| extend DeviceId = tostring(parse_json(RawEventData)[\"DeviceId\"])\n| extend CommandsString = tostring(parse_json(RawEventData)[\"CommandsString\"])\n| project TimeGenerated, DeviceId, CommandsString;\nlet PIDs = lrSessionStarted \n| join kind=inner DeviceProcessEvents on $right.DeviceId == $left.DeviceId\n| extend timeDiff = abs(datetime_diff('second', TimeGenerated1, TimeGenerated))// <= 120\n| where timeDiff <= 300 \n// Consider commenting out the line above ^^^ played with the idea of joining only where the event \n// occurred within minutes of eachother but there could easily be too much latency though and log ingest lag time\n| where InitiatingProcessCommandLine startswith @\"\"\"SenseIR.exe\"\" \"\"OnlineSenseIR\"\"\"\n| project DeviceId, ProcessId, CommandsString;\nPIDs\n| join DeviceProcessEvents on $right.InitiatingProcessId == $left.ProcessId , $right.DeviceId == $left.DeviceId\n| where FileName !in (\"csc.exe\", \"conhost.exe\") // noisy processes\n| where InitiatingProcessFileName == \"powershell.exe\" and InitiatingProcessFileName == \"powershell.exe\"\n| where ProcessCommandLine !contains \"ew0KICAgICJTY2FubmVyQXJncyI\" // Disovery scan configs\n| where InitiatingProcessCommandLine !contains \"eyJEZXRlY3Rpb25LZXlzIjp\" // MDE deception lure configs\n| sort by DeviceId, TimeGenerated asc\n| extend EventSessionId = row_window_session(TimeGenerated, 10m, 3m, DeviceId != prev(DeviceId))\n| project DeviceName, TimeGenerated, FileName, ProcessCommandLine, EventSessionId, CommandsString\n```\n\n----------------------------------------\n\nTITLE: Detecting Anti-Forensics Commands in Defender XDR (KQL)\nDESCRIPTION: This Kusto Query Language (KQL) query for Defender XDR detects suspicious process executions indicative of anti-forensic activity. It filters `DeviceProcessEvents` for common Windows utilities and checks their command lines for arguments related to clearing event logs, manipulating timestamps, deleting shadow copies, or securely deleting files. The query helps identify attempts to remove forensic evidence.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Endpoint/AntiForensicsActivityOnEndpoint.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\nDeviceProcessEvents\n| where FileName in~ (\"rundll32.exe\", \"fsutil.exe\", \"wevtutil.exe\", \"auditpol.exe\", \"bcdedit.exe\", \"sdelete.exe\", \"cipher.exe\", \"wmic.exe\", \"powershell.exe\", \"cmd.exe\", \"del.exe\", \"vssadmin.exe\") \n| where (\n    // Clearing Shimcache or AppCompatCache\n    (FileName == \"rundll32.exe\" and ProcessCommandLine has_any (\"ShimFlushCache\", \"BaseFlushAppcompatCache\")) \n    // USN Journal tampering\n    or (FileName == \"fsutil.exe\" and ProcessCommandLine has \"usn\" and ProcessCommandLine !has \"queryJournal\")\n    // Clearing Windows Event Logs\n    or (FileName == \"wevtutil.exe\" and ProcessCommandLine has_any (\"cl\", \"clear-log\"))\n    or (FileName == \"powershell.exe\" and ProcessCommandLine has_all (\"Clear-EventLog\"))\n    or (FileName == \"auditpol.exe\" and ProcessCommandLine has \"/clear\")\n    // Secure delete / Encryption overwrite\n    or (FileName == \"sdelete.exe\")\n    or (FileName == \"cipher.exe\" and ProcessCommandLine has \"/w\")\n    // Disabling logging and security settings\n    or (FileName == \"bcdedit.exe\" and ProcessCommandLine has_any (\"/set bootstatuspolicy ignoreallfailures\", \"/set recoveryenabled no\"))\n    or (FileName == \"wmic.exe\" and ProcessCommandLine has_all (\"shadowcopy\", \"delete\"))\n    // Deleting recent files, Prefetch, and browser history\n    or (FileName == \"cmd.exe\" and ProcessCommandLine has \"del\" and ProcessCommandLine has_any (\"\\\\Microsoft\\\\Windows\\\\Recent\", \"\\\\Windows\\\\Prefetch\", \"history\", \"cookies\", \"cache\"))\n    // Timestomping Detection\n    or (FileName == \"powershell.exe\" and ProcessCommandLine has_all (\"Set-ItemProperty\", \"LastWriteTime\")) \n    // Shadow Copy & System Recovery Deletion\n    or (FileName == \"vssadmin.exe\" and ProcessCommandLine has_any (\"delete\", \"resize\"))\n    or (FileName == \"wmic.exe\" and ProcessCommandLine has_all (\"shadowcopy\", \"delete\"))\n    or (FileName == \"bcdedit.exe\" and ProcessCommandLine has_any (\"/delete\", \"/set safeboot\"))\n)\n```\n\n----------------------------------------\n\nTITLE: Detecting Non-Microsoft URLs in Advisory Emails (KQL)\nDESCRIPTION: This KQL query identifies potentially malicious emails that mimic Microsoft Admin Center Advisories within Microsoft Defender XDR. It filters EmailEvents originating from the official advisory address (@microsoft.com), extracts URLs specifically from the email body using EmailUrlInfo, and checks if the domain of the extracted URL belongs to a predefined list of trusted first-party Microsoft domains. Emails containing URLs outside these trusted domains are flagged as suspicious. It requires access to the EmailEvents and EmailUrlInfo tables.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Email-Collab/MS-Advisory-Note-Abuse.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\nlet firstPartyDomains = dynamic([\"office.com\", \"azure.net\", \"microsoft.com\", \"azure.com\", \"aka.ms\", \"bing.com\", \"cloud.microsoft\", \"windowsazure.com\", \"microsoft365.com\"]);\nlet emailIDs = EmailEvents\n| where SenderFromAddress =~ @\"o365mc@microsoft.com\"\n| project NetworkMessageId, RecipientEmailAddress;\nEmailUrlInfo\n| where NetworkMessageId in (emailIDs)\n| extend host_parts = split(UrlDomain, \".\")\n| extend Domain = strcat(tostring(host_parts[-2]), \".\", tostring(host_parts[-1]))\n| where UrlLocation == \"Body\" and Domain !in (firstPartyDomains)\n| join emailIDs on NetworkMessageId\n| project Timestamp, NetworkMessageId, Url, RecipientEmailAddress, ReportId\n```\n\n----------------------------------------\n\nTITLE: Querying Azure AD Provisioning Failures using KQL\nDESCRIPTION: This KQL query searches the AuditLogs for 'Process escrow' operations that resulted in a 'failure'. It extracts the application name and target user's display name, then pulls the detailed error message from the ResultDescription. Finally, it summarizes the latest error for each unique combination of application and target user.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Reports/UserProvisioningFailures.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\n// Retrieve a report on the latest application user provisioning (api/scim) failures\nAuditLogs\n| where OperationName == @\"Process escrow\" and Result == @\"failure\"\n| extend ApplicationName = tostring(parse_json(TargetResources)[0][\"displayName\"])\n| extend TargetUserDisplayName = tostring(parse_json(TargetResources)[1][\"displayName\"])\n| extend ErrorDetails = substring(ResultDescription, indexof(ResultDescription, \"Error:\"))\n| summarize arg_max(TimeGenerated, ErrorDetails) by ApplicationName, TargetUserDisplayName\n```\n\n----------------------------------------\n\nTITLE: Identify Archiving Processes Near Deception Alert (KQL)\nDESCRIPTION: This KQL query identifies process activity related to archiving tools (specifically 7Zip and bsdtar) on devices that triggered a Deception alert. It joins AlertEvidence with DeviceFileEvents to correlate process information within a one-hour window around the alert's time. Requires an `alertID` variable to be set with the ID of the Deception alert for investigation.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Deception Alert Triage/Suspicious Archiving Activity.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\n// Deception triage: Exfil\n// Identify archiving activity within a 2 hour timespan of a Deception detection\n// more to come, this currently only detects 7Zip and built-in Tar usage.\nlet alertID = \"\"; // change me\nlet entities = AlertEvidence\n| where AlertId == alertID\n| where EntityType in (\"Process\")\n| summarize by TimeGenerated, DeviceId;\nentities\n| join DeviceFileEvents on $left.DeviceId == $right.DeviceId\n| where TimeGenerated1 between ((TimeGenerated - 1h) .. (TimeGenerated + 1h))\n| where InitiatingProcessVersionInfoCompanyName == @\"Igor Pavlov\" or InitiatingProcessVersionInfoFileDescription == @\"bsdtar archive tool\"\n```\n\n----------------------------------------\n\nTITLE: Querying Logon Events for Deception Alerts - KQL\nDESCRIPTION: This KQL query identifies device logon events associated with machines or users involved in a specific deception alert. It extracts device and account information from `AlertEvidence` for a given `alertID` and joins it with `DeviceLogonEvents` to find relevant logins within a 2-hour window around the alert generation time, aiding in triage. It requires access to Defender XDR data.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Deception Alert Triage/User_Host Logon Info.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\n// Deception triage: Host/Acct\n// This query assumes the decoy was used on an MDE managed device\n// Identify the account that hit the decoy and how it accessed the system\nlet alertID = \"\"; // change me\nlet entities = AlertEvidence\n| where AlertId == alertID\n| where EntityType in (\"Machine\", \"User\")\n| summarize DeviceId = any(DeviceId), AccountName = any(AccountName) by TimeGenerated, AlertId;\nentities\n| join DeviceLogonEvents on $left.DeviceId == $right.DeviceId and $left.AccountName == $right.AccountName\n| where TimeGenerated1 between ((TimeGenerated - 1h) .. (TimeGenerated + 1h))\n| project-away TimeGenerated, DeviceId1, Timestamp\n| project-rename TimeGenerated = TimeGenerated1\n| sort by TimeGenerated\n// Keep an eye out for logins at odd hours or remote logins\n//| where parse_json(AdditionalFields).IsLocalLogon == false\n//| where isnotempty(RemoteIP)\n```\n\n----------------------------------------\n\nTITLE: Querying Device Network Events in Defender XDR KQL\nDESCRIPTION: This KQL query retrieves DeviceNetworkEvents for a specific device associated with a deception detection alert. It filters events within a one-hour window before and after the alert's trigger time, providing a comprehensive view of related network activity. The query requires an alert ID to identify the target device.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Deception Alert Triage/All Network Activity around Deception Detection.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\n// Deception triage: Network Conn\n// Identify network activity of a device connected related to a deception detection within a 2 hour timespan\nlet alertID = \"\"; //change me\nlet entities = AlertEvidence\n| where AlertId == alertID\n| where EntityType in (\"Machine\")\n| summarize DeviceId = any(DeviceId) by TimeGenerated, AlertId;\nentities\n| join DeviceNetworkEvents on $left.DeviceId == $right.DeviceId\n| where TimeGenerated1 between ((TimeGenerated - 1h) .. (TimeGenerated + 1h))\n| project-away TimeGenerated, DeviceId1, Timestamp\n| project-rename TimeGenerated = TimeGenerated1\n| sort by TimeGenerated\n```\n\n----------------------------------------\n\nTITLE: Querying Aggregated Network Events - KQL\nDESCRIPTION: This KQL query is used to identify remote IPs with a high volume of aggregated network connections to devices involved in a specific alert. It joins AlertEvidence with DeviceNetworkEvents, filters for 'AggregatedReport' actions, extracts and sums 'uniqueEventsAggregated' per RemoteIP, and reports connections exceeding a defined activity threshold. Requires an alert ID and threshold value.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Deception Alert Triage/Interesting Network Activity_aggregated.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\n// Deception triage: Network Conn\n// Identify interesting network connections to a device related to a deception detection\nlet alertID = \"\"; // change me\nlet activityThreshold = 10; // Adjust as necessary\nlet entities = AlertEvidence\n| where AlertId == alertID\n| where EntityType in (\"Machine\")\n| summarize DeviceId = any(DeviceId) by TimeGenerated, AlertId;\nentities\n| join DeviceNetworkEvents on $left.DeviceId == $right.DeviceId\n| where TimeGenerated1 between ((TimeGenerated - 1h) .. (TimeGenerated + 1h))\n| where ActionType endswith \"AggregatedReport\"\n| extend uniqueEventsAggregated = toint(extractjson(\"$.uniqueEventsAggregated\", AdditionalFields))\n| summarize Total = sum(uniqueEventsAggregated) by RemoteIP, ActionType\n| where Total > activityThreshold\n```\n\n----------------------------------------\n\nTITLE: Identify Multiple Missing Agents (KQL)\nDESCRIPTION: This KQL query identifies active devices that are missing one or more agents from a provided list. It finds active devices with recent interactive logons within a specified domain and compares their installed software against the list of target agents using `set_difference`. Replace the dynamic array with your list of target software names and \"<DOMAIN>\" with your domain.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Endpoint/EndpointMissingAgents.md#_snippet_1\n\nLANGUAGE: KQL\nCODE:\n```\nlet targetAgents = dynamic([\"\", \"\"]);\nlet activeDevices = DeviceLogonEvents\n| where TimeGenerated > ago(7d)\n| where LogonType == \"Interactive\"// or LogonType == \"RemoteInteractive\"\n| where AccountDomain == \"<DOMAIN>\" //set your domain\n| distinct DeviceName;\nDeviceTvmSoftwareInventory\n| where DeviceName in~ (activeDevices)\n| summarize Software = make_set(SoftwareName) by DeviceName\n| extend MissingAgents = set_difference(targetAgents, Software)\n| project-away Software\n```\n\n----------------------------------------\n\nTITLE: Identify a Specific Missing Agent (KQL)\nDESCRIPTION: This KQL query identifies active devices that are missing a single specified software agent. It finds devices with recent interactive logons within a specified domain and checks their software inventory for the absence of the target agent string. Replace \"<SOFTWARENAMESTRING>\" and \"<DOMAIN>\" with the actual software name and your organization's domain.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/Endpoint/EndpointMissingAgents.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\nlet targetAgent = \"<SOFTWARENAMESTRING>\";\nlet activeDevices = DeviceLogonEvents\n| where TimeGenerated > ago(7d)\n| where LogonType == \"Interactive\"// or LogonType == \"RemoteInteractive\"\n| where AccountDomain =~ \"<DOMAIN>\" //set your domain\n| distinct DeviceName;\nDeviceTvmSoftwareInventory\n// according to the docs software inventory syncs every 24 hours but I reccomend \n| where DeviceName in~ (activeDevices)\n| summarize Software = tostring(make_set(SoftwareName)) by DeviceName\n| where Software !has targetAgent\n```\n\n----------------------------------------\n\nTITLE: Querying Microsoft Teams Activity for Potential AI Bots - KQL\nDESCRIPTION: This KQL query for Microsoft Defender XDR analyzes OfficeActivity logs to identify potential AI bots joining Teams meetings. It filters for Microsoft Teams workload and non-GroupChat communication types, keeping relevant fields. The query includes optional filters like checking if UserKey equals UserId and specifically looks for clients whose extra properties indicate 'linux', based on common assumptions about some bot implementations. Note this query has a limited use-case and relies on specific assumptions mentioned in the accompanying text.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/KQL/OfficeActivity/Possible-AI-Bots-in-Teams-Meeting.md#_snippet_0\n\nLANGUAGE: KQL\nCODE:\n```\nOfficeActivity\n| project-keep TimeGenerated, Operation, OfficeWorkload, UserId, UserKey, CommunicationType, ExtraProperties, ClientIP, ItemName, ChatName\n| where OfficeWorkload == \"MicrosoftTeams\"\n| where CommunicationType != \"GroupChat\"\n| where UserKey == UserId\n| where ExtraProperties has \"linux\"\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft Graph PowerShell Module\nDESCRIPTION: This PowerShell command installs the Microsoft Graph module for the current user's scope, which is a prerequisite for running the Graph PowerShell scripts in this repository. Ensure PowerShell 7+ is installed before execution.\nSOURCE: https://github.com/attackthesoc/azure-secops/blob/main/README.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nInstall-Module Microsoft.Graph -Scope CurrentUser\n```"
  }
]