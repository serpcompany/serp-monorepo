[
  {
    "owner": "python-websockets",
    "repo": "websockets",
    "content": "TITLE: WebSocket Echo Server and Client using asyncio\nDESCRIPTION: An example implementation of a WebSocket echo server and client using the asyncio paradigm. The server accepts connections and echoes back any messages it receives.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/index.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python\n\n# Echo server and client implementations\n\nimport asyncio\nimport websockets.asyncio\n\n\nasync def echo(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\n\nasync def main():\n    async with websockets.asyncio.serve(echo, \"localhost\", 8765):\n        await asyncio.Future()  # run forever\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Echo Server with asyncio API in Python\nDESCRIPTION: An example of a WebSocket echo server implementation using the asyncio API from the websockets library. The server listens on localhost:8765 and echoes back any messages it receives from clients.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/README.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python\n\nimport asyncio\nfrom websockets.asyncio.server import serve\n\nasync def echo(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\nasync def main():\n    async with serve(echo, \"localhost\", 8765) as server:\n        await server.serve_forever()\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing Broadcasting to All WebSocket Connections\nDESCRIPTION: Demonstrates how to track all active connections and broadcast messages to them. The pattern uses a global set to store connections and handles proper cleanup when connections close.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/server.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nCONNECTIONS = set()\n\nasync def handler(websocket):\n    CONNECTIONS.add(websocket)\n    try:\n        await websocket.wait_closed()\n    finally:\n        CONNECTIONS.remove(websocket)\n\nfrom websockets.asyncio.server import broadcast\n\ndef message_all(message):\n    broadcast(CONNECTIONS, message)\n```\n\n----------------------------------------\n\nTITLE: Managing WebSocket Tasks with Proper Cancellation\nDESCRIPTION: This implementation shows a more robust way to handle consumer and producer tasks. It uses asyncio.wait() to monitor both tasks and cancels the pending task as soon as one of them completes, ensuring proper resource cleanup.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/patterns.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    consumer_task = asyncio.create_task(consumer_handler(websocket))\n    producer_task = asyncio.create_task(producer_handler(websocket))\n    done, pending = await asyncio.wait(\n        [consumer_task, producer_task],\n        return_when=asyncio.FIRST_COMPLETED,\n    )\n    for task in pending:\n        task.cancel()\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping a WebSocket Server in Python\nDESCRIPTION: Python implementation of a basic WebSocket server that listens on port 8001 and handles incoming connections. The server prints received messages and handles connection closures.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python\n\nimport asyncio\n\nfrom websockets.asyncio.server import serve\n\n\nasync def handler(websocket):\n    while True:\n        message = await websocket.recv()\n        print(message)\n\n\nasync def main():\n    async with serve(handler, \"\", 8001) as server:\n        await server.serve_forever()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Creating a WebSocket Server in Python\nDESCRIPTION: This Python script creates a WebSocket server that receives a name from the client, sends a greeting, and closes the connection.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/examples.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# server.py\n\nimport asyncio\nimport websockets\n\nasync def hello(websocket):\n    name = await websocket.recv()\n    print(f\"<<< {name}\")\n\n    greeting = f\"Hello {name}!\"\n    await websocket.send(greeting)\n    print(f\">>> {greeting}\")\n\nasync def main():\n    async with websockets.serve(hello, \"localhost\", 8765):\n        await asyncio.Future()  # run forever\n\nasync def main():\n    async with websockets.serve(hello, \"localhost\", 8765):\n        await asyncio.Future()  # run forever\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Initializing Game Connection in JavaScript\nDESCRIPTION: Defines a function to send an initialization event when the WebSocket connection is established, handling both new game and join game scenarios.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nfunction initGame(websocket) {\n  websocket.addEventListener(\"open\", () => {\n    // Send an \"init\" event according to who is connecting.\n    const params = new URLSearchParams(window.location.search);\n    let event = { type: \"init\" };\n    if (params.has(\"join\")) {\n      // Second player joins an existing game.\n      event.join = params.get(\"join\");\n    } else {\n      // First player starts a new game.\n    }\n    websocket.send(JSON.stringify(event));\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Premature Connection Closure in WebSocket Handlers\nDESCRIPTION: Demonstrates how to properly await asynchronous work in a WebSocket handler to prevent premature connection closure. The example shows replacing a non-awaited task creation with proper awaiting of the work function.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/server.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    asyncio.create_task(do_some_work())\n```\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    await do_some_work()\n```\n\n----------------------------------------\n\nTITLE: Implementing Graceful Server Shutdown with Signal Handling\nDESCRIPTION: Shows how to implement graceful shutdown of a WebSocket server in response to a signal (SIGTERM). The example uses asyncio signal handling to close the server when the process receives a termination signal.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/server.rst#2025-04-20_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nasync def server():\n    ...\n```\n\n----------------------------------------\n\nTITLE: WebSocket Hello World Client using asyncio\nDESCRIPTION: A simple WebSocket client implementation using the asyncio paradigm that connects to a server, sends a 'Hello world!' message, and prints the response.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/index.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python\n\n# Hello world client implementation\n\nimport asyncio\nimport websockets.asyncio\n\n\nasync def hello():\n    async with websockets.asyncio.connect(\"ws://localhost:8765\") as websocket:\n        await websocket.send(\"Hello world!\")\n        message = await websocket.recv()\n        print(f\"< {message}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(hello())\n```\n\n----------------------------------------\n\nTITLE: Implementing a WebSocket Consumer Pattern in Python\nDESCRIPTION: This snippet demonstrates how to receive messages from a WebSocket connection using an asynchronous for loop. The consumer_handler function continuously awaits messages from the WebSocket connection and processes them with a consume function that implements business logic.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/patterns.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def consumer_handler(websocket):\n    async for message in websocket:\n        await consume(message)\n```\n\n----------------------------------------\n\nTITLE: Implementing Play Function for Connect Four Game in Python\nDESCRIPTION: This function handles the game logic for both players in a Connect Four game. It processes moves, updates the game state, and broadcasts events to all connected clients.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nasync def play(websocket, game, player, connected):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Handler in Python\nDESCRIPTION: Coroutine that handles WebSocket connections, initializes the game, and processes moves.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport json\nimport logging\n\nfrom connect4 import Connect4\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.DEBUG)\n\nasync def handler(websocket):\n    # Initialize a Connect Four game.\n    game = Connect4()\n\n    try:\n        async for message in websocket:\n            # Parse a \"play\" event from the UI.\n            event = json.loads(message)\n            assert event[\"type\"] == \"play\"\n            column = event[\"column\"]\n\n            try:\n                # Play the move.\n                row = game.play(column)\n            except RuntimeError as exc:\n                # Send an \"error\" event if the move was invalid.\n                event = {\n                    \"type\": \"error\",\n                    \"message\": str(exc),\n                }\n                await websocket.send(json.dumps(event))\n                continue\n\n            # Send a \"play\" event to update the UI.\n            event = {\n                \"type\": \"play\",\n                \"player\": game.last_player,\n                \"column\": column,\n                \"row\": row,\n            }\n            await websocket.send(json.dumps(event))\n\n            # If move is winning, send a \"win\" event.\n            if game.winner is not None:\n                event = {\n                    \"type\": \"win\",\n                    \"player\": game.winner,\n                }\n                await websocket.send(json.dumps(event))\n    finally:\n        logging.debug(\"Connection closed\")\n```\n\n----------------------------------------\n\nTITLE: WebSocket Server for Counter Application in Python\nDESCRIPTION: This Python script implements a WebSocket server that manages a shared counter. It allows clients to increment or decrement the counter and broadcasts updates to all connected clients.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/examples.rst#2025-04-20_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# counter.py\n\nimport asyncio\nimport json\nimport websockets\n\nCOUNTER = 0\nUSERS = set()\n\ndef users_event():\n    return json.dumps({\"type\": \"users\", \"count\": len(USERS)})\n\ndef counter_event():\n    return json.dumps({\"type\": \"counter\", \"value\": COUNTER})\n\nasync def notify_users():\n    if USERS:  # asyncio.wait doesn't accept an empty list\n        message = users_event()\n        await asyncio.wait([user.send(message) for user in USERS])\n\nasync def notify_counter():\n    if USERS:  # asyncio.wait doesn't accept an empty list\n        message = counter_event()\n        await asyncio.wait([user.send(message) for user in USERS])\n\nasync def register(websocket):\n    USERS.add(websocket)\n    await notify_users()\n\nasync def unregister(websocket):\n    USERS.remove(websocket)\n    await notify_users()\n\nasync def counter(websocket, path):\n    # register(websocket) sends user_event() to websocket\n    global COUNTER\n    await register(websocket)\n    try:\n        await websocket.send(counter_event())\n        async for message in websocket:\n            data = json.loads(message)\n            if data[\"action\"] == \"+\":\n                COUNTER += 1\n                await notify_counter()\n            elif data[\"action\"] == \"-\":\n                COUNTER -= 1\n                await notify_counter()\n            else:\n                print(f\"unsupported event: {data}\")\n    finally:\n        await unregister(websocket)\n\nstart_server = websockets.serve(counter, \"localhost\", 6789)\n\nasyncio.get_event_loop().run_until_complete(start_server)\nasyncio.get_event_loop().run_forever()\n```\n\n----------------------------------------\n\nTITLE: Basic WebSocket Server Setup with Broadcasting\nDESCRIPTION: Template for setting up a WebSocket server with a broadcast function that sends messages to all connected clients. This shows the basic structure needed for integrating a broadcasting mechanism.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/broadcast.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom websockets.asyncio.server import serve\n\nasync def handler(websocket):\n    ...\n\nasync def broadcast(message):\n    ...\n\nasync def broadcast_messages():\n    while True:\n        await asyncio.sleep(1)\n        message = ...  # your application logic goes here\n        await broadcast(message)\n\nasync def main():\n    async with serve(handler, \"localhost\", 8765):\n        await broadcast_messages()  # runs forever\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Concurrent Broadcasting with Tasks\nDESCRIPTION: An improved broadcasting approach that uses asyncio tasks to send messages to clients concurrently. This prevents slow clients from blocking the entire broadcast operation.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/broadcast.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nasync def send(websocket, message):\n    try:\n        await websocket.send(message)\n    except ConnectionClosed:\n        pass\n\ndef broadcast(message):\n    for websocket in CLIENTS:\n        asyncio.create_task(send(websocket, message))\n```\n\n----------------------------------------\n\nTITLE: Implementing Graceful Shutdown for WebSocket Server in Python\nDESCRIPTION: This code snippet demonstrates how to implement a graceful shutdown for a WebSocket server using Python. It catches the SIGTERM signal to ensure proper cleanup when terminating the server process.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/index.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport signal\nimport websockets\n\nasync def echo(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\nasync def main():\n    # Set the stop condition when receiving SIGTERM.\n    loop = asyncio.get_running_loop()\n    stop = loop.create_future()\n    loop.add_signal_handler(signal.SIGTERM, stop.set_result, None)\n\n    async with websockets.serve(echo, \"\", 8765):\n        await stop\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Using WebSocket Connections with ClientConnection in Python\nDESCRIPTION: ClientConnection class for managing WebSocket connections. Provides methods for sending and receiving data, closing connections, and managing connection state. Also includes attributes for connection details and properties for connection status.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/asyncio/client.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass ClientConnection:\n    async def __aiter__(self)\n    async def recv(self)\n    async def recv_streaming(self)\n    async def send(data)\n    async def close(code=1000, reason=\"\")\n    async def wait_closed()\n    async def ping(data=None)\n    async def pong(data=None)\n\n    id\n    logger\n    local_address\n    remote_address\n    latency\n    state\n    request\n    response\n    subprotocol\n    close_code\n    close_reason\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Reconnection Logic\nDESCRIPTION: Implementation of an automatic reconnection mechanism using connect as an asynchronous iterator and handling ConnectionClosed exceptions.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/client.rst#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.asyncio.client import connect\nfrom websockets.exceptions import ConnectionClosed\n\nasync for websocket in connect(...):\n    try:\n        ...\n    except ConnectionClosed:\n        continue\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Server with Unix Socket in Python\nDESCRIPTION: Python script for a WebSocket server that uses Unix sockets for communication. It echoes messages back to clients and runs multiple instances managed by Supervisor.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/nginx.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport asyncio\nfrom websockets.server import serve\n\nasync def echo(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\nasync def main():\n    # Supervisor sets the PORT environment variable for each instance\n    socket = f\"/tmp/websockets_{os.environ['PORT']}.sock\"\n    async with serve(echo, unix=socket):\n        await asyncio.Future()  # run forever\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Sending JSON Event to Server in JavaScript\nDESCRIPTION: Shows how to create a JSON event and send it to the server using WebSocket in JavaScript.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst event = {type: \"play\", column: 3};\nwebsocket.send(JSON.stringify(event));\n```\n\n----------------------------------------\n\nTITLE: WebSocket Broadcasting Implementation - Python asyncio\nDESCRIPTION: Implementation of broadcasting functionality to send messages to multiple WebSocket connections simultaneously. Provides efficient message distribution to connected clients.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/asyncio/server.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Example broadcast usage\nasync def broadcast_handler(websocket):\n    async for message in websocket:\n        await broadcast(connected, message)\n\nconnected = set()\n```\n\n----------------------------------------\n\nTITLE: Simple Path-Based WebSocket Routing in Python\nDESCRIPTION: Demonstrates basic routing of WebSocket connections based on the request path using pattern matching. Handles different endpoints (/blue and /green) by directing them to specific handlers.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/routing.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    match websocket.request.path:\n        case \"/blue\":\n            await blue_handler(websocket)\n        case \"/green\":\n            await green_handler(websocket)\n        case _:\n            # No handler for this path. Close the connection.\n            return\n```\n\n----------------------------------------\n\nTITLE: Implementing a Python WebSockets Echo Server with Health Checks and Graceful Shutdown\nDESCRIPTION: A Python implementation of a WebSockets echo server that includes a health check endpoint at '/healthz' and handles SIGTERM signals for graceful shutdown. This server is designed to meet typical requirements for running on a Platform as a Service.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/fly.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python\n\nimport asyncio\nimport os\nimport signal\nimport sys\n\nfrom websockets.server import serve\n\n\nasync def echo(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\n\nasync def health_check(path, request_headers):\n    if path == \"/healthz\":\n        return http_response(\"OK\")\n    return None\n\n\ndef http_response(body, status=\"200 OK\", headers=None):\n    if headers is None:\n        headers = {}\n    if \"Content-Length\" not in headers:\n        headers[\"Content-Length\"] = str(len(body))\n    if \"Content-Type\" not in headers:\n        headers[\"Content-Type\"] = \"text/plain; charset=utf-8\"\n    headers_str = \"\\r\\n\".join(f\"{k}: {v}\" for k, v in headers.items())\n    return f\"HTTP/1.1 {status}\\r\\n{headers_str}\\r\\n\\r\\n{body}\"\n\n\nasync def main():\n    # Set the stop condition when receiving SIGTERM.\n    loop = asyncio.get_running_loop()\n    stop = loop.create_future()\n    loop.add_signal_handler(signal.SIGTERM, stop.set_result, None)\n\n    port = int(os.environ.get(\"PORT\", \"8080\"))\n    async with serve(\n        echo,\n        host=\"\",\n        port=port,\n        process_request=health_check,\n    ):\n        await stop\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Messages in WebSocket Server\nDESCRIPTION: This code snippet shows two methods for broadcasting messages to all connected clients in a WebSocket server. The first uses a loop, while the second uses the broadcast helper function for improved efficiency.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n\n    ...\n\n    for connection in connected:\n        await connection.send(json.dumps(event))\n\n    ...\n\nfrom websockets.asyncio.server import broadcast\n\nasync def handler(websocket):\n\n    ...\n\n    broadcast(connected, json.dumps(event))\n\n    ...\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Server Protocol\nDESCRIPTION: Code for initializing server protocol and handling connection acceptance/rejection.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/sansio.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.server import ServerProtocol\n\nprotocol = ServerProtocol()\n\nresponse = protocol.accept(request)\nprotocol.send_response(response)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Game Events to Connected Clients in Python\nDESCRIPTION: Sends game events to all connected WebSocket clients for a specific game instance.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n\n    ...\n\n    for connection in connected:\n        await connection.send(json.dumps(event))\n\n    ...\n```\n\n----------------------------------------\n\nTITLE: Combining Consumer and Producer Patterns with asyncio.gather()\nDESCRIPTION: This code demonstrates how to combine consumer and producer patterns to both send and receive messages on the same WebSocket connection. It uses asyncio.gather() to run both handlers concurrently as tasks.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/patterns.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nasync def handler(websocket):\n    await asyncio.gather(\n        consumer_handler(websocket),\n        producer_handler(websocket),\n    )\n```\n\n----------------------------------------\n\nTITLE: Converting Blocking Calls to Async in WebSocket Handlers\nDESCRIPTION: Demonstrates replacing blocking calls with their asynchronous equivalents to prevent blocking the event loop. The example shows replacing synchronous sleep with asyncio.sleep.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/server.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    time.sleep(1)\n    ...\n```\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    await asyncio.sleep(1)\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Publish-Subscribe Pattern for WebSocket Broadcasting in Python\nDESCRIPTION: A PubSub class implementation that creates a message stream supporting multiple consumers using asyncio. The stream is implemented as a linked list of futures, allowing consumers to read messages at their own pace without synchronization.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/broadcast.rst#2025-04-20_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass PubSub:\n    def __init__(self):\n        self.waiter = asyncio.get_running_loop().create_future()\n\n    def publish(self, value):\n        waiter = self.waiter\n        self.waiter = asyncio.get_running_loop().create_future()\n        waiter.set_result((value, self.waiter))\n\n    async def subscribe(self):\n        waiter = self.waiter\n        while True:\n            value, waiter = await waiter\n            yield value\n\n    __aiter__ = subscribe\n\nPUBSUB = PubSub()\n```\n\n----------------------------------------\n\nTITLE: Accessing HTTP Headers in WebSocket Request Processing\nDESCRIPTION: Shows how to access HTTP headers both during the initial handshake and after the connection is established. Uses the process_request handler and the connection object's request attribute.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/server.rst#2025-04-20_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef process_request(connection, request):\n    authorization = request.headers[\"Authorization\"]\n    ...\n\nasync with serve(handler, process_request=process_request):\n    ...\n```\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    authorization = websocket.request.headers[\"Authorization\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing a WebSocket Producer Pattern in Python\nDESCRIPTION: This snippet shows how to send messages to a WebSocket connection in a loop. It continuously produces messages and sends them until the client disconnects, which raises a ConnectionClosed exception and breaks the loop.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/patterns.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.exceptions import ConnectionClosed\n\nasync def producer_handler(websocket):\n    while True:\n        try:\n            message = await produce()\n            await websocket.send(message)\n        except ConnectionClosed:\n            break\n```\n\n----------------------------------------\n\nTITLE: Setting Timeout on WebSocket Receive in Python 3.11+\nDESCRIPTION: Using asyncio.timeout to set a timeout for the websocket.recv() method in Python 3.11 and newer versions. This allows handling scenarios where receiving a message takes longer than expected.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/common.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync with asyncio.timeout(timeout=10):\n    message = await websocket.recv()\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSockets Echo Server for Heroku\nDESCRIPTION: Python implementation of a WebSockets echo server that listens on the port specified by Heroku's environment variable and handles graceful shutdown on SIGTERM.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: WebSocket Connection Handler with PubSub in Python\nDESCRIPTION: An async handler function that subscribes to the PubSub stream and sends messages to WebSocket clients. This implementation supports handling slow clients with limited memory usage.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/broadcast.rst#2025-04-20_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    async for message in PUBSUB:\n        await websocket.send(message)\n```\n\n----------------------------------------\n\nTITLE: Naive Broadcasting Implementation with Client Tracking\nDESCRIPTION: A simple broadcasting approach that maintains a set of connected clients and sends messages to each one sequentially. This method has limitations with slow clients that can block the entire broadcasting process.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/broadcast.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nCLIENTS = set()\n\nasync def handler(websocket):\n    CLIENTS.add(websocket)\n    try:\n        await websocket.wait_closed()\n    finally:\n        CLIENTS.remove(websocket)\n```\n\n----------------------------------------\n\nTITLE: Receiving WebSocket Messages Concurrently in Python\nDESCRIPTION: Demonstrates the limitation of receiving WebSocket messages concurrently. Only one coroutine can receive messages at a time to avoid non-deterministic behavior. Attempting to await recv() in multiple coroutines will raise a RuntimeError.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/design.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nawait protocol.recv()\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Server with Dynamic Port Assignment in Python\nDESCRIPTION: This Python script sets up a WebSocket server that listens on a dynamically assigned port. The port is determined by an environment variable set by Supervisor, allowing multiple instances to run on different ports.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/haproxy.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport os\n\nimport websockets\n\nPORT = 8000 + int(os.environ[\"SUPERVISOR_PROCESS_NAME\"].split(\"-\")[-1])\n\nasync def echo(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\nasync def main():\n    async with websockets.serve(echo, \"localhost\", PORT):\n        await asyncio.Future()  # run forever\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Proper WebSocket Connection Handling with Await\nDESCRIPTION: Correct implementation showing how to properly wait for work to complete before closing the WebSocket connection.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/client.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync with connect(...) as websocket:\n    await do_some_work()\n```\n\n----------------------------------------\n\nTITLE: Setting Custom HTTP Headers in WebSocket Responses\nDESCRIPTION: Demonstrates how to set custom HTTP headers in WebSocket handshake responses using the process_response callback. This allows adding any headers to the initial HTTP response that establishes the WebSocket connection.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/server.rst#2025-04-20_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef process_response(connection, request, response):\n    response.headers[\"X-Blessing\"] = \"May the network be with you\"\n\nasync with serve(handler, process_response=process_response):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Secure WebSocket Server with TLS in Python\nDESCRIPTION: Example of configuring a WebSocket server to handle secure TLS connections using a local certificate. The server loads a TLS certificate from 'localhost.pem' and creates an SSL context for secure connections.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/encryption.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python\n\nimport asyncio\nimport pathlib\nimport ssl\nimport websockets\n\nssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\ncurrent_dir = pathlib.Path(__file__).parent\nssl_context.load_cert_chain(current_dir / \"localhost.pem\")\n\nasync def handler(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\nasync def main():\n    async with websockets.serve(handler, \"localhost\", 8765, ssl=ssl_context):\n        await asyncio.Future()  # run forever\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing Directed Messaging to Specific Users\nDESCRIPTION: Shows how to track connections by user identifier to send messages to specific users. The implementation stores connections in a dictionary keyed by user ID and provides a function to send messages to individual users.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/server.rst#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nCONNECTIONS = {}\n\nasync def handler(websocket):\n    user_id = ...  # identify user in your app's context\n    CONNECTIONS[user_id] = websocket\n    try:\n        await websocket.wait_closed()\n    finally:\n        del CONNECTIONS[user_id]\n\nasync def message_user(user_id, message):\n    websocket = CONNECTIONS[user_id]  # raises KeyError if user disconnected\n    await websocket.send(message)  # may raise websockets.exceptions.ConnectionClosed\n```\n\n----------------------------------------\n\nTITLE: Closing a WebSockets Server in Python\nDESCRIPTION: Demonstrates the proper sequence for closing a WebSockets server in Python. The code shows how to initialize a server, wait for a stop signal, close the server without forcibly closing connections, and await full closure.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/server.rst#2025-04-20_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nserver = await serve(echo, \"localhost\", 8765)\nawait stop\nserver.close(close_connections=False)\nawait server.wait_closed()\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to WebSocket Connection Handlers\nDESCRIPTION: Demonstrates how to pass additional arguments to connection handlers using functools.partial. This technique allows binding specific values to handler parameters when setting up the WebSocket server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/server.rst#2025-04-20_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport functools\n\nasync def handler(websocket, extra_argument):\n    ...\n\nbound_handler = functools.partial(handler, extra_argument=42)\n```\n\n----------------------------------------\n\nTITLE: Python WebSockets Echo Server Implementation\nDESCRIPTION: Implementation of a WebSockets echo server in Python that also includes health check endpoint and proper signal handling for graceful shutdown. This code is designed to meet Render's requirements for zero downtime deploys.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/render.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python\n\nimport asyncio\nimport os\nimport signal\nimport sys\n\nfrom websockets.server import serve\n\n\nasync def echo(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\n\nasync def health_check(path, headers):\n    if path == \"/healthz\":\n        return 200, {}, b\"\"\n\n\nasync def main():\n    # Set the stop condition when receiving SIGTERM.\n    loop = asyncio.get_running_loop()\n    stop = loop.create_future()\n    loop.add_signal_handler(signal.SIGTERM, stop.set_result, None)\n\n    port = int(os.environ.get(\"PORT\", \"8000\"))\n    async with serve(\n        echo, host=\"\", port=port, process_request=health_check\n    ):\n        await stop  # run until SIGTERM\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Customizing WebSocket Compression Settings with PerMessageDeflate Extension\nDESCRIPTION: Demonstrates how to explicitly configure compression settings for both client and server connections using the PerMessageDeflateFactory classes with custom window bits and memory level settings.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/compression.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.extensions import permessage_deflate\n\nconnect(\n    ...,\n    extensions=[\n        permessage_deflate.ClientPerMessageDeflateFactory(\n            server_max_window_bits=11,\n            client_max_window_bits=11,\n            compress_settings={\"memLevel\": 4},\n        ),\n    ],\n)\n\nserve(\n    ...,\n    extensions=[\n        permessage_deflate.ServerPerMessageDeflateFactory(\n            server_max_window_bits=11,\n            client_max_window_bits=11,\n            compress_settings={\"memLevel\": 4},\n        ),\n    ],\n)\n```\n\n----------------------------------------\n\nTITLE: Queue-Based Broadcasting Function\nDESCRIPTION: Broadcasting implementation that works with the per-client queue approach. It adds messages to all client queues without waiting for them to be sent.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/broadcast.rst#2025-04-20_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef broadcast(message):\n    for queue in CLIENTS:\n        queue.put_nowait(message)\n```\n\n----------------------------------------\n\nTITLE: Handling Game Initialization for First Player in Python\nDESCRIPTION: Initializes a new Connect Four game, generates a join key, and stores the game state and WebSocket connection in the global dictionary.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport secrets\n\nasync def handler(websocket):\n    ...\n\n    # Initialize a Connect Four game, the set of WebSocket connections\n    # receiving moves from this game, and secret access token.\n    game = Connect4()\n    connected = {websocket}\n\n    join_key = secrets.token_urlsafe(12)\n    JOIN[join_key] = game, connected\n\n    try:\n\n        ...\n\n    finally:\n        del JOIN[join_key]\n```\n\n----------------------------------------\n\nTITLE: WebSocket Server Creation and Routing - Python asyncio\nDESCRIPTION: Server creation and routing implementation using asyncio. Includes functions for serving WebSocket connections over TCP and Unix domain sockets, plus routing capabilities for connection handling.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/asyncio/server.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example serve and route usage\nasync def handler(websocket):\n    await websocket.send(\"Hello!\")\n\nasync def main():\n    async with serve(handler, \"localhost\", 8765):\n        await asyncio.Future()  # run forever\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Basic Authentication for WebSocket Client in Python\nDESCRIPTION: This code demonstrates how to authenticate a WebSocket client using HTTP Basic Authentication. It includes the username and password directly in the WebSocket URI when establishing the connection.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/authentication.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.asyncio.client import connect\n\nasync with connect(f\"wss://{username}:{password}@.../\") as websocket:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Generating Authentication Tokens with Django-Sesame\nDESCRIPTION: Example of generating authentication tokens for users in a Django shell using the django-sesame library.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/django.rst#2025-04-20_snippet_2\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from django.contrib.auth import get_user_model\n>>> User = get_user_model()\n>>> user = User.objects.get(username=\"<your username>\")\n>>> from sesame.utils import get_token\n>>> get_token(user)\n'<your token>'\n```\n\n----------------------------------------\n\nTITLE: Per-Client Queue Implementation for Broadcasting\nDESCRIPTION: An advanced approach using individual queues for each client to handle broadcasting. This allows for custom handling of slow clients by potentially implementing batching or skipping messages.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/broadcast.rst#2025-04-20_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nCLIENTS = set()\n\nasync def relay(queue, websocket):\n    while True:\n        # Implement custom logic based on queue.qsize() and\n        # websocket.transport.get_write_buffer_size() here.\n        message = await queue.get()\n        await websocket.send(message)\n\nasync def handler(websocket):\n    queue = asyncio.Queue()\n    relay_task = asyncio.create_task(relay(queue, websocket))\n    CLIENTS.add(queue)\n    try:\n        await websocket.wait_closed()\n    finally:\n        CLIENTS.remove(queue)\n        relay_task.cancel()\n```\n\n----------------------------------------\n\nTITLE: Implementing Secure WebSocket Client with TLS in Python\nDESCRIPTION: Example of configuring a WebSocket client to connect to a secure server using a self-signed certificate. The client creates an SSL context and loads the certificate to establish trust.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/encryption.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python\n\nimport asyncio\nimport pathlib\nimport ssl\nimport websockets\n\nssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\ncurrent_dir = pathlib.Path(__file__).parent\nssl_context.load_verify_locations(current_dir / \"localhost.pem\")\n\nasync def hello():\n    uri = \"wss://localhost:8765\"\n    async with websockets.connect(uri, ssl=ssl_context) as websocket:\n        await websocket.send(\"Hello world!\")\n        message = await websocket.recv()\n        print(message)\n\nif __name__ == \"__main__\":\n    asyncio.run(hello())\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Bearer Authentication for WebSocket Client in Python\nDESCRIPTION: This snippet shows how to authenticate a WebSocket client using HTTP Bearer Authentication. It adds an Authorization header with a Bearer token when establishing the WebSocket connection.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/authentication.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.asyncio.client import connect\n\nheaders = {\"Authorization\": f\"Bearer {token}\"}\nasync with connect(\"wss://.../\", additional_headers=headers) as websocket:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Creating Custom WebSocket Server Connection with Extra Arguments\nDESCRIPTION: Example of creating a custom ServerConnection subclass and using functools.partial to bind additional arguments when serving WebSocket connections. This allows passing custom parameters to the connection handler.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/common.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport functools\nfrom websockets.asyncio.server import ServerConnection, serve\n\nclass MyServerConnection(ServerConnection):\n    def __init__(self, *args, extra_argument=None, **kwargs):\n        super().__init__(*args, **kwargs)\n        # do something with extra_argument\n\ncreate_connection = functools.partial(ServerConnection, extra_argument=42)\nasync with serve(..., create_connection=create_connection):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Handling Game Join for Second Player in Python\nDESCRIPTION: Looks up an existing game using the join key, adds the new WebSocket connection to the set of connected clients, and handles cleanup when the connection closes.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    ...\n\n    join_key = ...\n\n    # Find the Connect Four game.\n    game, connected = JOIN[join_key]\n\n    # Register to receive moves from this game.\n    connected.add(websocket)\n    try:\n\n        ...\n\n    finally:\n        connected.remove(websocket)\n```\n\n----------------------------------------\n\nTITLE: Implementing Game Join Logic on Server in Python\nDESCRIPTION: Adds server-side logic to handle joining an existing game, including error handling for invalid join keys.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nasync def error(websocket, message):\n    event = {\n        \"type\": \"error\",\n        \"message\": message,\n    }\n    await websocket.send(json.dumps(event))\n\n\nasync def join(websocket, join_key):\n    # Find the Connect Four game.\n    try:\n        game, connected = JOIN[join_key]\n    except KeyError:\n        await error(websocket, \"Game not found.\")\n        return\n\n    # Register to receive moves from this game.\n    connected.add(websocket)\n    try:\n\n        # Temporary - for testing.\n        print(\"second player joined game\", id(game))\n        async for message in websocket:\n            print(\"second player sent\", message)\n\n    finally:\n        connected.remove(websocket)\n\n\nasync def handler(websocket):\n    # Receive and parse the \"init\" event from the UI.\n    message = await websocket.recv()\n    event = json.loads(message)\n    assert event[\"type\"] == \"init\"\n\n    if \"join\" in event:\n        # Second player joins an existing game.\n        await join(websocket, event[\"join\"])\n    else:\n        # First player starts a new game.\n```\n\n----------------------------------------\n\nTITLE: Using Async Iteration for WebSocket Message Handling\nDESCRIPTION: Simplified WebSocket message handling using Python's async for syntax, which automatically iterates over incoming messages until the client disconnects.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    async for message in websocket:\n        print(message)\n```\n\n----------------------------------------\n\nTITLE: Complex URL Pattern Routing for WebSockets using Werkzeug\nDESCRIPTION: Advanced routing implementation using Werkzeug's URL routing system. Demonstrates setting up a URL map with various patterns including static paths, dynamic segments, and subdomain routing.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/routing.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nurl_map = Map(\n    [\n        # Static paths\n        Rule(\"/static\", endpoint=\"static_handler\"),\n        # Dynamic segments\n        Rule(\"/users/<user_id>\", endpoint=\"user_handler\"),\n        # Optional segments\n        Rule(\"/items/<int:item_id>/?\", endpoint=\"item_handler\"),\n        # Multiple segments\n        Rule(\"/files/<path:file_path>\", endpoint=\"file_handler\"),\n        # Subdomain routing\n        Rule(\"/\", endpoint=\"subdomain_handler\", subdomain=\"<subdomain>\"),\n    ]\n)\n\nserver = await serve(route(url_map, handlers), \"localhost\", 8001)\nawait server.serve_forever()\n```\n\n----------------------------------------\n\nTITLE: Configuring HAProxy for WebSocket Load Balancing\nDESCRIPTION: This HAProxy configuration sets up load balancing for WebSocket connections across four server processes. It uses the 'leastconn' method to distribute connections evenly, which is optimal for long-running connections like WebSockets.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/haproxy.rst#2025-04-20_snippet_2\n\nLANGUAGE: haproxy\nCODE:\n```\nglobal\n    log /dev/log local0\n    log /dev/log local1 notice\n    daemon\n\ndefaults\n    log global\n    mode http\n    option httplog\n    option dontlognull\n    timeout connect 5000\n    timeout client 50000\n    timeout server 50000\n\nfrontend http-in\n    bind *:8080\n    default_backend websockets\n\nbackend websockets\n    balance leastconn\n    option http-server-close\n    option forwardfor\n    server websockets1 127.0.0.1:8001\n    server websockets2 127.0.0.1:8002\n    server websockets3 127.0.0.1:8003\n    server websockets4 127.0.0.1:8004\n```\n\n----------------------------------------\n\nTITLE: Configuring Kubernetes Deployment for WebSocket Server\nDESCRIPTION: This YAML file defines the Kubernetes Service and Deployment for the WebSocket server. It specifies the container image, port configurations, resource limits, and health check probes.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/kubernetes.rst#2025-04-20_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# Code not provided in the input text\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx for WebSocket Load Balancing\nDESCRIPTION: Nginx configuration for load balancing WebSocket connections across four server processes using Unix sockets. It includes settings for WebSocket protocol and connection handling.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/nginx.rst#2025-04-20_snippet_2\n\nLANGUAGE: nginx\nCODE:\n```\ndaemon off;\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    upstream websockets {\n        least_conn;\n        server unix:/tmp/websockets_0.sock;\n        server unix:/tmp/websockets_1.sock;\n        server unix:/tmp/websockets_2.sock;\n        server unix:/tmp/websockets_3.sock;\n    }\n\n    server {\n        listen 8080;\n        location / {\n            proxy_pass http://websockets;\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection $connection_upgrade;\n        }\n    }\n\n    map $http_upgrade $connection_upgrade {\n        default upgrade;\n        '' close;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: WebSocket Server for Synchronized Time Broadcasting in Python\nDESCRIPTION: This Python script creates a WebSocket server that broadcasts the same timestamp to all connected clients every second, ensuring synchronized updates.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/examples.rst#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# sync_time.py\n\nimport asyncio\nimport datetime\nimport websockets\n\nCONNECTIONS = set()\n\nasync def register(websocket):\n    CONNECTIONS.add(websocket)\n    try:\n        await websocket.wait_closed()\n    finally:\n        CONNECTIONS.remove(websocket)\n\nasync def show_time():\n    while True:\n        now = datetime.datetime.now().isoformat()\n        websockets.broadcast(CONNECTIONS, now)\n        await asyncio.sleep(1)\n\nasync def main():\n    async with websockets.serve(register, \"localhost\", 5678):\n        await show_time()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Client Registration Pattern for WebSocket Connections\nDESCRIPTION: This pattern demonstrates how to keep track of connected WebSocket clients by adding them to a set upon connection and removing them when they disconnect. This implementation works for single-process applications and allows broadcasting messages to all connected clients.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/patterns.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nconnected = set()\n\nasync def handler(websocket):\n    # Register.\n    connected.add(websocket)\n    try:\n        # Broadcast a message to all connected clients.\n        broadcast(connected, \"Hello!\")\n        await asyncio.sleep(10)\n    finally:\n        # Unregister.\n        connected.remove(websocket)\n```\n\n----------------------------------------\n\nTITLE: Naive Broadcasting Function with Error Handling\nDESCRIPTION: Implementation of the broadcast function that sequentially sends a message to all connected clients. It handles potential connection errors and makes a copy of the clients set to avoid iteration errors.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/broadcast.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.exceptions import ConnectionClosed\n\nasync def broadcast(message):\n    for websocket in CLIENTS.copy():\n        try:\n            await websocket.send(message)\n        except ConnectionClosed:\n            pass\n```\n\n----------------------------------------\n\nTITLE: WebSocket Hello World Client using threading\nDESCRIPTION: A simple WebSocket client implementation using the threading paradigm that connects to a server, sends a 'Hello world!' message, and prints the response.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/index.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python\n\n# Hello world client implementation\n\nimport websockets.sync\n\n\ndef hello():\n    with websockets.sync.connect(\"ws://localhost:8765\") as websocket:\n        websocket.send(\"Hello world!\")\n        message = websocket.recv()\n        print(f\"< {message}\")\n\n\nif __name__ == \"__main__\":\n    hello()\n```\n\n----------------------------------------\n\nTITLE: Implementing Health Check for WebSocket Server in Python\nDESCRIPTION: This code snippet shows how to implement a basic health check for a WebSocket server using Python. It uses the 'process_request' hook to respond to HTTP GET requests on the '/health/' path.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/index.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport websockets\n\nhealth_check_response = (\n    \"HTTP/1.1 200 OK\\r\\n\"\n    \"Content-Length: 0\\r\\n\"\n    \"\\r\\n\"\n)\n\nasync def health_check(path, request_headers):\n    if path == \"/health/\":\n        return health_check_response, []\n\nasync def echo(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\nasync def main():\n    async with websockets.serve(echo, \"\", 8765, process_request=health_check):\n        await asyncio.Future()  # run forever\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Authentication for WebSocket Server in Python\nDESCRIPTION: This snippet shows how to set up basic authentication for a WebSocket server using the websockets library. It defines a function to check credentials and uses the basic_auth decorator from websockets.asyncio.server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/authentication.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.asyncio.server import basic_auth as websockets_basic_auth\n\ndef check_credentials(username, password):\n    return username == get_user(password)\n\nbasic_auth = websockets_basic_auth(check_credentials=check_credentials)\n```\n\n----------------------------------------\n\nTITLE: Receiving Raw Binary Data Without UTF-8 Decoding in Python Websockets\nDESCRIPTION: Shows how to receive potentially invalid UTF-8 content by disabling automatic decoding. This demonstrates how UTF-8 validation can be bypassed when receiving messages.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/features.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnot_utf8_bytes = recv(decode=False)\n```\n\n----------------------------------------\n\nTITLE: Implementing sendMoves Function in JavaScript\nDESCRIPTION: Function to handle click events on the game board and send move events to the server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nfunction sendMoves(board, websocket) {\n  // When clicking a column, send a \"play\" event.\n  board.addEventListener(\"click\", ({ target }) => {\n    const column = target.dataset.column;\n    // Ignore clicks outside a column.\n    if (column === undefined) {\n      return;\n    }\n    const event = {\n      type: \"play\",\n      column: parseInt(column, 10),\n    };\n    websocket.send(JSON.stringify(event));\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Fly.toml for WebSockets Application Deployment\nDESCRIPTION: Configuration file for Fly.io that sets up HTTP and WebSocket traffic handling, TLS termination, health checks, and process management. This file defines how Fly.io should deploy and run the WebSockets application.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/fly.rst#2025-04-20_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\napp = \"websockets-echo\"\n\n[build]\n  builder = \"paketobuildpacks/builder:base\"\n\n[http_service]\n  internal_port = 8080\n  force_https = true\n  auto_stop_machines = true\n  auto_start_machines = true\n  min_machines_running = 0\n  processes = [\"app\"]\n  [http_service.concurrency]\n    type = \"connections\"\n    hard_limit = 1000\n    soft_limit = 500\n\n[[vm]]\n  cpu_kind = \"shared\"\n  cpus = 1\n  memory_mb = 256\n\n[checks]\n  [checks.health]\n    port = 8080\n    type = \"http\"\n    interval = \"15s\"\n    timeout = \"2s\"\n    grace_period = \"1s\"\n    method = \"get\"\n    path = \"/healthz\"\n\n[env]\n  PORT = \"8080\"\n\n[shutdown]\n  # Fly sends SIGINT followed by SIGTERM after this delay\n  delay = \"1s\"\n  # Fly terminates the VM if the app isn't stopped after this grace period\n  grace_period = \"1s\"\n```\n\n----------------------------------------\n\nTITLE: WebSocket Connection Management - Python asyncio\nDESCRIPTION: Core functionality for managing WebSocket server connections including opening/closing handshakes, message sending/receiving, and connection state management. Provides methods for ping/pong operations and connection metadata access.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/asyncio/server.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example ServerConnection usage\nasync with serve(handler, \"localhost\", 8765) as server:\n    async for connection in server:\n        await connection.send(\"Hello!\")\n        message = await connection.recv()\n        await connection.close()\n```\n\n----------------------------------------\n\nTITLE: Handling Closed WebSocket Connections in Python\nDESCRIPTION: Shows that attempting to send a frame after the WebSocket connection is closed will raise a ConnectionClosed exception, which is a safe behavior in the websockets library.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/design.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nraise websockets.exceptions.ConnectionClosed\n```\n\n----------------------------------------\n\nTITLE: Testing WebSocket Connection with JavaScript\nDESCRIPTION: JavaScript code for testing the WebSocket server from a browser console, connecting to the server, sending an authentication token, and logging received messages.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/django.rst#2025-04-20_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nwebsocket = new WebSocket(\"ws://localhost:8888/\");\nwebsocket.onopen = (event) => websocket.send(\"<your token>\");\nwebsocket.onmessage = (event) => console.log(event.data);\n```\n\n----------------------------------------\n\nTITLE: Configuring Websockets Performance Options\nDESCRIPTION: Example showing how to configure websockets for optimal performance by disabling compression, keepalive pings, and UTF-8 decoding when benchmarking against other libraries.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/misc.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncompression=None\nping_interval=None\n# Send bytes instead of str\n```\n\n----------------------------------------\n\nTITLE: Receiving WebSocket Messages in Python\nDESCRIPTION: Demonstrates how to receive messages from a WebSocket connection using the websockets library. The code shows both the old and new methods of handling connection closure.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/project/changelog.rst#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmessage = await websocket.recv()\nif message is None:\n    return\n```\n\nLANGUAGE: python\nCODE:\n```\nmessage = await websocket.recv()\n```\n\n----------------------------------------\n\nTITLE: Custom Request Processing with Basic Auth in WebSocket Server - Python\nDESCRIPTION: Shows how to combine HTTP Basic Authentication with custom request processing logic in the new implementation using async/await syntax.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/upgrade.rst#2025-04-20_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.asyncio.server import basic_auth, serve\n\nprocess_basic_auth = basic_auth(...)\n\nasync def process_request(connection, request):\n    ...  # some logic here\n    response = await process_basic_auth(connection, request)\n    if response is not None:\n        return response\n    ... # more logic here\n\nasync with serve(..., process_request=process_request):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Accessing HTTP Headers in WebSocket Connection\nDESCRIPTION: Demonstrates how to access request and response HTTP headers from an established WebSocket connection.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/client.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync with connect(...) as websocket:\n    websocket.request.headers\n    websocket.response.headers\n```\n\n----------------------------------------\n\nTITLE: Checking WebSocket Connection State in Python\nDESCRIPTION: This table demonstrates how to check if a WebSocket connection is open or closed in both the legacy and new implementations.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/upgrade.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Legacy asyncio implementation        New asyncio implementation\n..                                          from websockets.protocol import State\nconnection.open                         connection.state is State.OPEN\nconnection.closed                       connection.state is State.CLOSED\n```\n\n----------------------------------------\n\nTITLE: Updating Path and Header Access in Python WebSockets\nDESCRIPTION: This table shows how to update code that accesses path, request headers, and response headers when migrating from the legacy to the new WebSocket implementation.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/upgrade.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Legacy asyncio implementation        New asyncio implementation\nconnection.path                         connection.request.path\nconnection.request_headers              connection.request.headers\nconnection.response_headers             connection.response.headers\n```\n\n----------------------------------------\n\nTITLE: WebSocket Authentication Handler for Django\nDESCRIPTION: Implementation of a WebSocket server that authenticates connections using django-sesame tokens. It sets up Django, validates the token sent by the client, and authenticates the user.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/django.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# authentication.py\nimport asyncio\nimport os\n\nimport django\nfrom django.contrib.auth import get_user_model\n\nfrom sesame.utils import get_user\nfrom websockets.server import serve\n\n# Initialize Django\ndos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"<your project>.settings\")\ndjango.setup()\n\nUser = get_user_model()\n\n\nasync def handler(websocket):\n    # Receive and validate the token.\n    try:\n        token = await websocket.recv()\n    except Exception:\n        await websocket.close(1011, \"authentication failed\")\n        return\n\n    # Authenticate with django-sesame.\n    try:\n        user = await asyncio.to_thread(get_user, token)\n    except Exception:\n        await websocket.close(1011, \"authentication failed\")\n        return\n\n    # Check if a user was returned.\n    if user is None:\n        await websocket.close(1011, \"authentication failed\")\n        return\n\n    # Authentication successful!\n    await websocket.send(f\"Hello {user.username}!\")\n\n\nasync def main():\n    async with serve(handler, \"localhost\", 8888):\n        await asyncio.Future()  # run forever\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Handling Game Initialization on Server in Python\nDESCRIPTION: Implements the server-side logic for starting a new game or joining an existing game based on the initialization event received from the client.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport secrets\n\n\nJOIN = {}\n\n\nasync def start(websocket):\n    # Initialize a Connect Four game, the set of WebSocket connections\n    # receiving moves from this game, and secret access token.\n    game = Connect4()\n    connected = {websocket}\n\n    join_key = secrets.token_urlsafe(12)\n    JOIN[join_key] = game, connected\n\n    try:\n        # Send the secret access token to the browser of the first player,\n        # where it'll be used for building a \"join\" link.\n        event = {\n            \"type\": \"init\",\n            \"join\": join_key,\n        }\n        await websocket.send(json.dumps(event))\n\n        # Temporary - for testing.\n        print(\"first player started game\", id(game))\n        async for message in websocket:\n            print(\"first player sent\", message)\n\n    finally:\n        del JOIN[join_key]\n\n\nasync def handler(websocket):\n    # Receive and parse the \"init\" event from the UI.\n    message = await websocket.recv()\n    event = json.loads(message)\n    assert event[\"type\"] == \"init\"\n\n    # First player starts a new game.\n    await start(websocket)\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Echo Server in Python\nDESCRIPTION: This Python script implements a WebSocket echo server with artificial CPU starvation and health check endpoints. It uses the websockets library and includes endpoints for testing unresponsiveness and termination.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/kubernetes.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Code not provided in the input text\n```\n\n----------------------------------------\n\nTITLE: Supervisor Configuration for WebSockets Server\nDESCRIPTION: Supervisor configuration file (supervisord.conf) to manage and keep four instances of the WebSockets app running, restarting them if they exit.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/supervisor.rst#2025-04-20_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n.. literalinclude:: ../../example/deployment/supervisor/supervisord.conf\n```\n\n----------------------------------------\n\nTITLE: Preventing Event Loop Blocking in Continuous Message Sending\nDESCRIPTION: Shows how to yield control back to the event loop when sending messages continuously, preventing the application from blocking. This adds an explicit sleep(0) to allow other operations to process.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/server.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    while True:\n        await websocket.send(\"firehose!\")\n```\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    while True:\n        await websocket.send(\"firehose!\")\n        await asyncio.sleep(0)\n```\n\n----------------------------------------\n\nTITLE: Message-Based WebSocket Routing in Python\nDESCRIPTION: Shows how to route WebSocket connections based on the first message received from the client. Uses JSON parsing to extract routing information from the message content.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/routing.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nasync def handler(websocket):\n    message = await websocket.recv()\n    settings = json.loads(message)\n    match settings[\"color\"]:\n        case \"blue\":\n            await blue_handler(websocket)\n        case \"green\":\n            await green_handler(websocket)\n        case _:\n            # No handler for this message. Close the connection.\n            return\n```\n\n----------------------------------------\n\nTITLE: Implementing Application-Level WebSocket Keepalive in Python\nDESCRIPTION: Implementation of a background task that sends periodic keepalive messages to maintain WebSocket connections. The code demonstrates how to create a keepalive mechanism using JSON messages and handles connection closure gracefully.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/keepalive.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport itertools\nimport json\n\nfrom websockets.exceptions import ConnectionClosed\n\nasync def keepalive(websocket, ping_interval=30):\n    for ping in itertools.count():\n        await asyncio.sleep(ping_interval)\n        try:\n            await websocket.send(json.dumps({\"ping\": ping}))\n        except ConnectionClosed:\n            break\n\nasync def main():\n    async with connect(...) as websocket:\n        keepalive_task = asyncio.create_task(keepalive(websocket))\n        try:\n            ... # your application logic goes here\n        finally:\n            keepalive_task.cancel()\n```\n\n----------------------------------------\n\nTITLE: Disabling WebSocket Compression in Python Websockets\nDESCRIPTION: Shows how to disable the default compression when establishing connections with connect() and serve() functions by setting compression=None.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/compression.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nconnect(..., compression=None, ...)\n\nserve(..., compression=None, ...)\n```\n\n----------------------------------------\n\nTITLE: Forcing IP Address for WebSocket Connection\nDESCRIPTION: Example of how to specify a particular IP address for the WebSocket client connection using the host parameter.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/client.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nasync with connect(..., host=\"192.168.0.1\") as websocket:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Client Connection\nDESCRIPTION: Code for parsing WebSocket URI and initializing client protocol for connection. Shows how to create and send handshake request.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/sansio.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.uri import parse_uri\n\nuri = parse_uri(\"ws://example.com/\")\n\nfrom websockets.client import ClientProtocol\n\nprotocol = ClientProtocol(uri)\n\nrequest = protocol.connect()\nprotocol.send_request(request)\n```\n\n----------------------------------------\n\nTITLE: Yielding Control in Producer Loop with Asyncio and Websockets in Python\nDESCRIPTION: Demonstrates how to properly yield control to the event loop in a producer function that sends messages via websockets. This is necessary to allow other coroutines, such as message receivers, to run.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/asyncio.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def producer(websocket):\n    message = generate_next_message()\n    await websocket.send(message)\n    await asyncio.sleep(0)  # yield control to the event loop\n```\n\n----------------------------------------\n\nTITLE: Opening WebSocket Connection in JavaScript\nDESCRIPTION: Demonstrates how to open a WebSocket connection in JavaScript to communicate with the server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst websocket = new WebSocket(\"ws://localhost:8001/\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Cache for Django\nDESCRIPTION: Settings configuration for django-redis to connect to a Redis server, which will be used for Pub/Sub messaging between Django and the WebSocket server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/django.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_redis.cache.RedisCache\",\n        \"LOCATION\": \"redis://127.0.0.1:6379/1\",\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Watch Function for Connect Four Game Spectators\nDESCRIPTION: This function allows spectators to watch an ongoing Connect Four game. It adds the spectator's WebSocket to the connected set and waits for the connection to close.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nasync def watch(websocket, watch_key):\n\n    ...\n\n    connected.add(websocket)\n    try:\n        await websocket.wait_closed()\n    finally:\n        connected.remove(websocket)\n```\n\n----------------------------------------\n\nTITLE: Receiving WebSocket Network Data\nDESCRIPTION: Example code showing how to receive and process network data using sockets with WebSocket protocol.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/sansio.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    data = sock.recv(65536)\nexcept OSError:  # socket closed\n    data = b\"\"\nif data:\n    protocol.receive_data(data)\nelse:\n    protocol.receive_eof()\n```\n\n----------------------------------------\n\nTITLE: Sending WebSocket Network Data\nDESCRIPTION: Code demonstrating how to send protocol data over the network using sockets.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/sansio.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfor data in protocol.data_to_send():\n    if data:\n        sock.sendall(data)\n    else:\n        sock.shutdown(socket.SHUT_WR)\n```\n\n----------------------------------------\n\nTITLE: WebSocket Server for Time Broadcasting in Python\nDESCRIPTION: This Python script creates a WebSocket server that broadcasts the current time to all connected clients every second.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/examples.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# show_time.py\n\nimport asyncio\nimport datetime\nimport websockets\n\nasync def show_time(websocket):\n    while True:\n        now = datetime.datetime.now().isoformat()\n        await websocket.send(now)\n        await asyncio.sleep(1)\n\nasync def main():\n    async with websockets.serve(show_time, \"localhost\", 5678):\n        await asyncio.Future()  # run forever\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Upgrading Connection Handler Pattern in WebSockets Server\nDESCRIPTION: Shows how to migrate from the older two-parameter handler pattern to the newer single-parameter pattern where the path is accessed as an attribute of the request. This change was introduced in version 10.1.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/project/changelog.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(request, path):\n  ...\n```\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(request):\n    path = request.path  # only if handler() uses the path argument\n    ...\n```\n\n----------------------------------------\n\nTITLE: Starting Game in Connect Four WebSocket Server\nDESCRIPTION: This code snippet shows how to start a game by calling the play function for the first player in the Connect Four WebSocket server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nawait play(websocket, game, PLAYER1, connected)\n```\n\n----------------------------------------\n\nTITLE: WebSocket Echo Server and Client using threading\nDESCRIPTION: An example implementation of a WebSocket echo server and client using the threading paradigm. This alternative is good for clients and servers with few connections.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/index.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python\n\n# Echo server and client implementations\n\nimport threading\nimport websockets.sync\n\n\ndef echo(websocket):\n    for message in websocket:\n        websocket.send(message)\n\n\ndef main():\n    with websockets.sync.serve(echo, \"localhost\", 8765):\n        threading.Event().wait()  # run forever\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n----------------------------------------\n\nTITLE: Opening WebSocket Connections with asyncio in Python\nDESCRIPTION: Functions for establishing WebSocket connections using asyncio. Includes 'connect' for general connections and 'unix_connect' for Unix socket connections. Also includes a 'process_exception' function for handling connection exceptions.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/asyncio/client.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nconnect(uri, *, subprotocols=None, ...)\n```\n\nLANGUAGE: python\nCODE:\n```\nunix_connect(path, uri, *, subprotocols=None, ...)\n```\n\nLANGUAGE: python\nCODE:\n```\nprocess_exception(exc, hostname)\n```\n\n----------------------------------------\n\nTITLE: Configuring Django-Sesame Authentication Backend\nDESCRIPTION: Settings configuration for django-sesame to enable token-based authentication in a Django project. Adds the sesame backend alongside the default ModelBackend.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/django.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nAUTHENTICATION_BACKENDS = [\n    \"django.contrib.auth.backends.ModelBackend\",\n    \"sesame.backends.ModelBackend\",\n]\n```\n\n----------------------------------------\n\nTITLE: Joining Game in Connect Four WebSocket Server\nDESCRIPTION: This code snippet demonstrates how to join an existing game by calling the play function for the second player in the Connect Four WebSocket server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nawait play(websocket, game, PLAYER2, connected)\n```\n\n----------------------------------------\n\nTITLE: Sending Fragmented WebSocket Messages in Python\nDESCRIPTION: Illustrates the serialization constraint when sending fragmented WebSocket messages. If a coroutine is awaiting send() for a fragmented message, subsequent send() calls in other coroutines will wait until the first call completes.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/design.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nawait protocol.send()\n```\n\n----------------------------------------\n\nTITLE: Sending Events from Python Server\nDESCRIPTION: Demonstrates how to send JSON events from the Python server to the WebSocket client.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nevent = {\"type\": \"play\", \"player\": \"red\", \"column\": 3, \"row\": 0}\nawait websocket.send(json.dumps(event))\n```\n\n----------------------------------------\n\nTITLE: Running WebSocket Server with Auto-Restart\nDESCRIPTION: Command to run a Python WebSocket server with automatic restart capabilities using watchmedo. Monitors for changes in Python files recursively and sends SIGTERM signal for clean shutdown.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/autoreload.rst#2025-04-20_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ watchmedo auto-restart --pattern \"*.py\" --recursive --signal SIGTERM \\\n    python app.py\n```\n\n----------------------------------------\n\nTITLE: Initializing Global Game State Dictionary in Python\nDESCRIPTION: Creates a module-level dictionary to store game instances and connected WebSocket clients, enabling game lookups by identifier.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nJOIN = {}\n```\n\n----------------------------------------\n\nTITLE: Initializing Connect Four Board UI in JavaScript\nDESCRIPTION: JavaScript code that initializes the Connect Four board UI when the DOM content is loaded, using functions imported from connect4.js.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createBoard, playMove } from \"./connect4.js\";\n\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n  // Initialize the UI.\n  const board = document.querySelector(\".board\");\n  createBoard(board);\n});\n```\n\n----------------------------------------\n\nTITLE: Handling WebSocket Connection Closures in Python\nDESCRIPTION: Updated WebSocket server handler with exception handling for graceful connection closures, preventing stack traces in the server logs when clients disconnect.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.exceptions import ConnectionClosedOK\n\nasync def handler(websocket):\n    while True:\n        try:\n            message = await websocket.recv()\n        except ConnectionClosedOK:\n            break\n        print(message)\n```\n\n----------------------------------------\n\nTITLE: Testing WebSockets Connection with Interactive Client\nDESCRIPTION: Example of using the websockets interactive client to connect to the deployed echo server and test its functionality by sending a message and receiving the echo response.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/render.rst#2025-04-20_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ websockets wss://websockets-echo.onrender.com/\nConnected to wss://websockets-echo.onrender.com/.\n> Hello!\n< Hello!\nConnection closed: 1000 (OK).\n```\n\n----------------------------------------\n\nTITLE: Configuring Procfile for Running WebSockets Application on Fly.io\nDESCRIPTION: A Procfile that tells Fly.io how to run the WebSockets application. This instructs the platform to execute the app.py file with Python.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/fly.rst#2025-04-20_snippet_3\n\nLANGUAGE: text\nCODE:\n```\napp: python app.py\n```\n\n----------------------------------------\n\nTITLE: Containerizing WebSocket Server with Dockerfile\nDESCRIPTION: This Dockerfile sets up a container for the WebSocket server. It uses Python 3.11, installs the websockets library, copies the application code, and sets the command to run the server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/kubernetes.rst#2025-04-20_snippet_1\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM python:3.11\nRUN pip install websockets\nCOPY app.py .\nCMD [\"python\", \"app.py\"]\n```\n\n----------------------------------------\n\nTITLE: Receiving WebSocket Messages in JavaScript\nDESCRIPTION: Demonstrates how to receive and parse WebSocket messages from the server in JavaScript.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nwebsocket.addEventListener(\"message\", ({ data }) => {\n  const event = JSON.parse(data);\n  // do something with event\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Continuous Message Processing in WebSocket Handlers\nDESCRIPTION: Shows how to modify a handler to process multiple messages instead of just one. This transforms a single message reception into a continuous message processing loop using an async for loop.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/server.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    print(websocket.recv())\n```\n\nLANGUAGE: python\nCODE:\n```\nasync def handler(websocket):\n    async for message in websocket:\n        print(message)\n```\n\n----------------------------------------\n\nTITLE: Creating Basic HTML Structure for Connect Four Game\nDESCRIPTION: HTML template for the Connect Four game that includes a board container div and imports necessary CSS and JavaScript files.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Connect Four</title>\n    <link rel=\"stylesheet\" href=\"connect4.css\" />\n    <script src=\"main.js\" type=\"module\"></script>\n  </head>\n  <body>\n    <div class=\"board\"></div>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Configuring Supervisor for Multiple WebSocket Server Instances\nDESCRIPTION: Supervisor configuration to run four instances of the WebSocket server, each listening on a different Unix socket.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/nginx.rst#2025-04-20_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[supervisord]\nnodaemon=true\n\n[program:websockets]\ncommand=python app.py\nprocess_name=%(program_name)s_%(process_num)02d\nnumprocs=4\nenvironment=PORT=\"%(process_num)d\"\nautorestart=true\n```\n\n----------------------------------------\n\nTITLE: Setting Timeout on WebSocket Receive in Python <3.11\nDESCRIPTION: Using asyncio.wait_for to set a timeout for the websocket.recv() method in Python versions older than 3.11. This achieves the same functionality as the asyncio.timeout method in newer versions.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/common.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmessage = await asyncio.wait_for(websocket.recv(), timeout=10)\n```\n\n----------------------------------------\n\nTITLE: JavaScript for Counter Application\nDESCRIPTION: This JavaScript file handles the WebSocket connection for the counter application. It sends increment/decrement actions to the server and updates the UI based on received messages.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/examples.rst#2025-04-20_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst websocket = new WebSocket(\"ws://localhost:6789/\");\n\nconst users = document.getElementById('users');\nconst counter = document.getElementById('count');\n\nwebsocket.onmessage = ({ data }) => {\n    const event = JSON.parse(data);\n    switch (event.type) {\n        case 'users':\n            users.textContent = event.count;\n            break;\n        case 'counter':\n            counter.textContent = event.value;\n            break;\n        default:\n            console.error(\"unsupported event\", event);\n    }\n};\n\nconst plus = document.getElementById('plus');\nconst minus = document.getElementById('minus');\n\nplus.onclick = () => {\n    websocket.send(JSON.stringify({action: \"+\"}));\n}\n\nminus.onclick = () => {\n    websocket.send(JSON.stringify({action: \"-\"}));\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Keepalive Ping Timeout Error in Python WebSocket\nDESCRIPTION: Example of a traceback for a ConnectionClosedError due to a keepalive ping timeout. This occurs when there's excessive latency in the WebSocket connection, either due to poor network connectivity or high traffic.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/common.rst#2025-04-20_snippet_1\n\nLANGUAGE: pytb\nCODE:\n```\nconnection handler failed\nTraceback (most recent call last):\n  ...\nwebsockets.exceptions.ConnectionClosedError: sent 1011 (internal error) keepalive ping timeout; no close frame received\n```\n\n----------------------------------------\n\nTITLE: Handling ConnectionClosedError in Python WebSocket\nDESCRIPTION: Example of a traceback for a ConnectionClosedError, which occurs when a TCP connection is lost without properly closing the WebSocket connection. This can happen due to network issues or misconfigured load balancers.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/common.rst#2025-04-20_snippet_0\n\nLANGUAGE: pytb\nCODE:\n```\nconnection handler failed\nTraceback (most recent call last):\n  ...\nwebsockets.exceptions.ConnectionClosedError: no close frame received or sent\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Debug Logging Configuration\nDESCRIPTION: Sets up basic logging configuration when no logging is previously configured in the application. Configures the format to include timestamp and message, and sets logging level to DEBUG.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/debugging.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\nlogging.basicConfig(\n    format=\"%(asctime)s %(message)s\",\n    level=logging.DEBUG,\n)\n```\n\n----------------------------------------\n\nTITLE: Connecting a WebSocket Client in Python\nDESCRIPTION: This Python script creates a WebSocket client that sends a name to the server, receives a greeting, and closes the connection.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/examples.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# client.py\n\nimport asyncio\nimport websockets\n\nasync def hello():\n    uri = \"ws://localhost:8765\"\n    async with websockets.connect(uri) as websocket:\n        name = input(\"What's your name? \")\n\n        await websocket.send(name)\n        print(f\">>> {name}\")\n\n        greeting = await websocket.recv()\n        print(f\"<<< {greeting}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(hello())\n```\n\n----------------------------------------\n\nTITLE: Running WebSocket Server Tests\nDESCRIPTION: Commands for running the server compliance tests, including starting test servers and running the Autobahn test client in Docker.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/compliance/README.rst#2025-04-20_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ PYTHONPATH=src python compliance/asyncio/server.py\n$ PYTHONPATH=src python compliance/sync/server.py\n\n$ docker run --interactive --tty --rm \\\n    --volume \"${PWD}/compliance/config:/config\" \\\n    --volume \"${PWD}/compliance/reports:/reports\" \\\n    --name fuzzingclient \\\n    crossbario/autobahn-testsuite \\\n    wstest --mode fuzzingclient --spec /config/fuzzingclient.json\n\n$ open compliance/reports/servers/index.html\n```\n\n----------------------------------------\n\nTITLE: Creating Procfile for Heroku WebSockets Application\nDESCRIPTION: The Procfile tells Heroku how to run the WebSockets server application.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Basic Logging Configuration for WebSocket Server\nDESCRIPTION: Sets up basic logging configuration for a WebSocket server in production environment with timestamp and message format.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/logging.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nlogging.basicConfig(\n    format=\"%(asctime)s %(message)s\",\n    level=logging.INFO,\n)\n```\n\n----------------------------------------\n\nTITLE: WebSocket Server for Broadcasting Django Admin Events\nDESCRIPTION: Complete implementation of a WebSocket server that authenticates users, tracks their permissions, subscribes to Redis events, and broadcasts admin events to connected clients based on their permissions.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/django.rst#2025-04-20_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# notifications.py\nimport asyncio\nimport json\nimport os\n\nimport aioredis\nimport django\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.db import connection\n\nfrom sesame.utils import get_user\nfrom websockets.server import serve\n\n# Initialize Django\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"<your project>.settings\")\ndjango.setup()\n\nUser = get_user_model()\n\n# Store active websocket connections with their users and content types.\nconnections = {}\n\n\nasync def get_content_types(user):\n    \"\"\"Determine which content types a user can view and change.\"\"\"\n    # Close the connection to the database because we're in a long-running process.\n    connection.close()\n\n    # Filter content types by user permissions.\n    if user.is_superuser:\n        # Superusers can view and change all content types.\n        view = list(ContentType.objects.values_list(\"id\", flat=True))\n        change = view\n    else:\n        # For regular users, get the content types they can view or change.\n        perms = user.get_all_permissions()\n        view = [\n            ct.id\n            for ct in ContentType.objects.all()\n            if f\"{ct.app_label}.view_{ct.model}\" in perms\n        ]\n        change = [\n            ct.id\n            for ct in ContentType.objects.all()\n            if f\"{ct.app_label}.change_{ct.model}\" in perms\n        ]\n\n    return {\"view\": view, \"change\": change}\n\n\nasync def handler(websocket):\n    # Receive and validate the token.\n    try:\n        token = await websocket.recv()\n    except Exception:\n        await websocket.close(1011, \"authentication failed\")\n        return\n\n    # Authenticate with django-sesame.\n    try:\n        user = await asyncio.to_thread(get_user, token)\n    except Exception:\n        await websocket.close(1011, \"authentication failed\")\n        return\n\n    # Check if a user was returned.\n    if user is None:\n        await websocket.close(1011, \"authentication failed\")\n        return\n\n    # Get content types this user can access.\n    content_types = await asyncio.to_thread(get_content_types, user)\n\n    # Store the connection for later broadcast.\n    connections[websocket] = (user, content_types)\n\n    # Keep the connection open until the client disconnects.\n    try:\n        await websocket.wait_closed()\n    finally:\n        del connections[websocket]\n\n\nasync def events_listener():\n    \"\"\"Listen for events on Redis and broadcast them to clients.\"\"\"\n    redis = await aioredis.create_redis(\"redis://localhost:6379/1\")\n    channel = (await redis.subscribe(\"events\"))[0]\n\n    try:\n        async for message in channel.iter():\n            data = json.loads(message.decode())\n            # Find the content type ID for this model\n            app_label, model = data[\"model\"].split(\".\")\n            try:\n                content_type_id = await asyncio.to_thread(\n                    lambda: ContentType.objects.get(\n                        app_label=app_label, model=model\n                    ).id\n                )\n            except Exception:\n                continue\n\n            # Broadcast to users who can view this content type\n            for websocket, (user, content_types) in connections.items():\n                if content_type_id in content_types[\"view\"]:\n                    try:\n                        await websocket.send(json.dumps(data))\n                    except Exception:\n                        pass\n    finally:\n        # Clean up resources\n        redis.close()\n        await redis.wait_closed()\n\n\nasync def main():\n    # Start the events listener task\n    listener_task = asyncio.create_task(events_listener())\n    \n    # Start the WebSocket server\n    async with serve(handler, \"localhost\", 8888):\n        await asyncio.Future()  # run forever\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Migrating Extra Headers to Process Response in Python WebSockets\nDESCRIPTION: This example demonstrates how to migrate from using extra_headers to the new process_response handler in the WebSocket server implementation.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/upgrade.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Original implementation\n\nserve(..., extra_headers=HEADERS, ...)\n\n# New implementation\n\ndef process_response(connection, request, response):\n    response.headers.update(HEADERS)\n    return response\n\nserve(..., process_response=process_response, ...)\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Body Size in Python WebSockets\nDESCRIPTION: Defines the maximum size of the body of an HTTP response in the opening handshake. The default value is 1,048,576 bytes (1 MiB).\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/variables.rst#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nWEBSOCKETS_MAX_BODY_SIZE\n```\n\n----------------------------------------\n\nTITLE: Alternate Client Connection Handling Method\nDESCRIPTION: An alternative approach to track connected clients that processes incoming messages instead of just waiting for the connection to close. Functionally equivalent to the previous handler.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/broadcast.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync for _ in websocket:\n    pass\n```\n\n----------------------------------------\n\nTITLE: JavaScript for WebSocket Time Display\nDESCRIPTION: This JavaScript file establishes a WebSocket connection, receives time updates from the server, and updates the HTML to display the current time.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/examples.rst#2025-04-20_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst timeElement = document.getElementById('time');\n\nconst websocket = new WebSocket(\"ws://localhost:5678/\");\n\nwebsocket.onmessage = ({ data }) => {\n    const event = new Date(data);\n    const time = event.toLocaleTimeString();\n    timeElement.textContent = time;\n};\n```\n\n----------------------------------------\n\nTITLE: Benchmarking WebSocket Server with Python Script\nDESCRIPTION: This Python script is used for load testing the WebSocket server deployment. It creates multiple concurrent connections and sends messages to test the server's performance under load.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/kubernetes.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Code not provided in the input text\n```\n\n----------------------------------------\n\nTITLE: Testing Connection to Deployed WebSockets Server\nDESCRIPTION: Using the websockets command-line client to connect to the deployed Heroku app and verify it's running correctly.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n$ websockets wss://websockets-echo.herokuapp.com/\nConnected to wss://websockets-echo.herokuapp.com/.\n>\n```\n\n----------------------------------------\n\nTITLE: Importing WebSockets APIs from the asyncio Implementation\nDESCRIPTION: Examples of importing WebSockets connection functions from the new asyncio implementation, which became the default in version 14.0.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/project/changelog.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets import connect, unix_connext\nfrom websockets import broadcast, serve, unix_serve\n```\n\n----------------------------------------\n\nTITLE: Implementing showMessage Function in JavaScript\nDESCRIPTION: Function to display game messages and handle different event types received from the server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nfunction showMessage(message) {\n  window.setTimeout(() => window.alert(message), 50);\n}\n\nfunction receiveMoves(board, websocket) {\n  websocket.addEventListener(\"message\", ({ data }) => {\n    const event = JSON.parse(data);\n    switch (event.type) {\n      case \"play\":\n        // Update the UI with the move.\n        playMove(board, event.player, event.column, event.row);\n        break;\n      case \"win\":\n        showMessage(`Player ${event.player} wins!`);\n        // No further messages are expected; close the WebSocket connection.\n        websocket.close(1000);\n        break;\n      case \"error\":\n        showMessage(event.message);\n        break;\n      default:\n        throw new Error(`Unsupported event type: ${event.type}.`);\n    }\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: WebSockets Echo Server with Graceful Shutdown in Python\nDESCRIPTION: A Python script (app.py) implementing a WebSockets echo server with graceful shutdown on SIGTERM and SO_REUSEPORT option enabled.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/supervisor.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../example/deployment/supervisor/app.py\n```\n\n----------------------------------------\n\nTITLE: Testing Echo Functionality of WebSockets Server\nDESCRIPTION: Demonstrating the echo functionality of the deployed server where it returns any message sent to it.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n$ websockets wss://websockets-echo.herokuapp.com/\nConnected to wss://websockets-echo.herokuapp.com/.\n> Hello!\n< Hello!\nConnection closed: 1000 (OK).\n```\n\n----------------------------------------\n\nTITLE: Publishing Events to Redis from Django Admin Actions\nDESCRIPTION: Implementation of Django signal handlers that capture admin actions and publish them to a Redis Pub/Sub channel for consumption by the WebSocket server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/django.rst#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# signals.py\nimport json\n\nfrom django.contrib.admin.models import LogEntry\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom django_redis import get_redis_connection\n\n\n@receiver(post_save, sender=LogEntry)\ndef log_entry_saved(instance, created, **kwargs):\n    \"\"\"Publish LogEntry data to Redis when a change is made in the admin.\"\"\"\n    redis = get_redis_connection(\"default\")\n\n    # Extract data from the LogEntry\n    data = {\n        \"model\": f\"{instance.content_type.app_label}.{instance.content_type.model}\",\n        \"action\": instance.get_action_flag_display(),\n        \"user\": instance.user.username,\n        \"object\": instance.object_repr,\n    }\n\n    # Publish event to Redis\n    redis.publish(\"events\", json.dumps(data, cls=DjangoJSONEncoder))\n```\n\n----------------------------------------\n\nTITLE: Configuring Supervisor for Multiple WebSocket Instances\nDESCRIPTION: This Supervisor configuration file sets up four instances of the WebSocket server. Each instance is run with a unique process name, which is used to determine its port.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/haproxy.rst#2025-04-20_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[supervisord]\nnodaemon=true\n\n[program:websockets]\ncommand=python app.py\nprocess_name=%(program_name)s-%(process_num)02d\nnumprocs=4\ndirectory=/path/to/websockets/example\nautostart=true\nautorestart=true\n```\n\n----------------------------------------\n\nTITLE: Handling WebSocket Connection Close in Python\nDESCRIPTION: Example code showing how to handle WebSocket connection closure by adding a callback to cancel the task when the connection is closed.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/project/changelog.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef handler(websocket, path):\n    closed = asyncio.ensure_future(websocket.wait_closed())\n    closed.add_done_callback(lambda task: task.cancel())\n```\n\n----------------------------------------\n\nTITLE: Updating Subprotocol Selection in Python WebSockets\nDESCRIPTION: This example shows how to update the select_subprotocol function when migrating from the legacy to the new WebSocket server implementation.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/upgrade.rst#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Original implementation\n\ndef select_subprotocol(client_subprotocols, server_subprotocols):\n    if \"chat\" in client_subprotocols:\n        return \"chat\"\n\n# New implementation\n\ndef select_subprotocol(connection, subprotocols):\n    if \"chat\" in subprotocols:\n        return \"chat\"\n\nserve(..., select_subprotocol=select_subprotocol, ...)\n```\n\n----------------------------------------\n\nTITLE: Deploying WebSockets Server to Heroku\nDESCRIPTION: Command to push the WebSockets server code to Heroku for deployment. The output shows a successful deployment.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ git push heroku\n\n... lots of output...\n\nremote: -----> Launching...\nremote:        Released v1\nremote:        https://websockets-echo.herokuapp.com/ deployed to Heroku\nremote:\nremote: Verifying deploy... done.\nTo https://git.heroku.com/websockets-echo.git\n * [new branch]      main -> main\n```\n\n----------------------------------------\n\nTITLE: Implementing Modern HTTP Basic Auth in WebSocket Server - Python\nDESCRIPTION: Demonstrates the new implementation of HTTP Basic Authentication using the basic_auth function to generate a process_request coroutine.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/upgrade.rst#2025-04-20_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.asyncio.server import basic_auth, serve\n\nasync with serve(..., process_request=basic_auth(...)):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Custom Logger Adapter for X-Forwarded-For Header\nDESCRIPTION: Implements a custom LoggerAdapter to include connection ID and client IP address from X-Forwarded-For header in WebSocket logs.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/logging.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass LoggerAdapter(logging.LoggerAdapter):\n    \"\"\"Add connection ID and client IP address to websockets logs.\"\"\"\n    def process(self, msg, kwargs):\n        try:\n            websocket = kwargs[\"extra\"][\"websocket\"]\n        except KeyError:        # log entry not coming from a connection\n            return msg, kwargs\n        if websocket.request is None:   # opening handshake not complete\n            return msg, kwargs\n        xff = headers.get(\"X-Forwarded-For\")\n        return f\"{websocket.id} {xff} {msg}\", kwargs\n```\n\n----------------------------------------\n\nTITLE: Message Broadcasting Function with PubSub in Python\nDESCRIPTION: A simple broadcast function that publishes messages to the PubSub stream. This implementation eliminates explicit iteration over clients.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/broadcast.rst#2025-04-20_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef broadcast(message):\n    PUBSUB.publish(message)\n```\n\n----------------------------------------\n\nTITLE: Running WebSocket Client Tests\nDESCRIPTION: Commands for running the client compliance tests, including starting the Autobahn test server in Docker and running test clients.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/compliance/README.rst#2025-04-20_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ docker run --interactive --tty --rm \\\n    --volume \"${PWD}/compliance/config:/config\" \\\n    --volume \"${PWD}/compliance/reports:/reports\" \\\n    --publish 9001:9001 \\\n    --name fuzzingserver \\\n    crossbario/autobahn-testsuite \\\n    wstest --mode fuzzingserver --spec /config/fuzzingserver.json\n\n$ PYTHONPATH=src python compliance/asyncio/client.py\n$ PYTHONPATH=src python compliance/sync/client.py\n\n$ open compliance/reports/clients/index.html\n```\n\n----------------------------------------\n\nTITLE: Implementing Legacy HTTP Basic Auth in WebSocket Server - Python\nDESCRIPTION: Shows the original implementation of HTTP Basic Authentication using create_protocol with basic_auth_protocol_factory in the legacy server implementation.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/upgrade.rst#2025-04-20_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.legacy.auth import basic_auth_protocol_factory\nfrom websockets.legacy.server import serve\n\nasync with serve(..., create_protocol=basic_auth_protocol_factory(...)):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Base Extension Class Documentation\nDESCRIPTION: Documentation for the Extension base class that defines core functionality for implementing WebSocket extensions. Includes methods for encoding and decoding messages.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/extensions.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Extension:\n    name\n    def decode()\n    def encode()\n```\n\n----------------------------------------\n\nTITLE: Waiting for Concurrent Broadcasting to Complete\nDESCRIPTION: A variation of concurrent broadcasting that waits for all send operations to complete. This approach is not recommended as it can block until the slowest client times out.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/broadcast.rst#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nasync def broadcast(message):\n    if CLIENTS:  # asyncio.wait doesn't accept an empty list\n        await asyncio.wait([\n            asyncio.create_task(send(websocket, message))\n            for websocket in CLIENTS\n        ])\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Line Length in Python WebSockets\nDESCRIPTION: Defines the maximum length of the request or status line in the opening handshake. The default value is 8192 bytes.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/variables.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nWEBSOCKETS_MAX_LINE_LENGTH\n```\n\n----------------------------------------\n\nTITLE: Handling WebSocket Connection with Task Creation\nDESCRIPTION: Example showing incorrect way of handling WebSocket connection with task creation that may lead to premature connection closure.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/client.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync with connect(...) as websocket:\n    asyncio.create_task(do_some_work())\n```\n\n----------------------------------------\n\nTITLE: Client Extension Factory Documentation\nDESCRIPTION: Documentation for the ClientExtensionFactory class that manages client-side extension configuration and parameter processing.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/extensions.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass ClientExtensionFactory:\n    name\n    def get_request_params()\n    def process_response_params()\n```\n\n----------------------------------------\n\nTITLE: Updating Join Link in JavaScript\nDESCRIPTION: Modifies the receiveMoves function to handle the \"init\" message and set the target of the join link.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n    switch (event.type) {\n      case \"init\":\n        // Create link for inviting the second player.\n        document.querySelector(\".join\").href = \"?join=\" + event.join;\n        break;\n      // ...\n    }\n```\n\n----------------------------------------\n\nTITLE: HTML for Counter Application\nDESCRIPTION: This HTML file creates a webpage for the counter application, displaying the current count and providing buttons to increment or decrement the counter.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/examples.rst#2025-04-20_snippet_7\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>WebSocket demo</title>\n        <link rel=\"stylesheet\" href=\"counter.css\">\n    </head>\n    <body>\n        <div class=\"users\">Users: <span id=\"users\">-</span></div>\n        <div class=\"counter\">\n            <button id=\"minus\">-</button>\n            <span id=\"count\">-</span>\n            <button id=\"plus\">+</button>\n        </div>\n        <script src=\"counter.js\"></script>\n    </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Setting Server Header in Python WebSockets\nDESCRIPTION: Configures the Server header sent by websockets. The default format is \"Python/x.y.z websockets/X.Y\".\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/variables.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nWEBSOCKETS_SERVER\n```\n\n----------------------------------------\n\nTITLE: Testing WebSocket Connection with Interactive Client\nDESCRIPTION: Command to test the WebSocket server using websockets' interactive client, allowing manual sending of messages to verify server functionality.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ websockets ws://localhost:8001/\n```\n\n----------------------------------------\n\nTITLE: Setting Additional HTTP Headers for WebSocket Connection\nDESCRIPTION: Shows how to set custom HTTP headers when establishing a WebSocket connection using the additional_headers parameter.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/client.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync with connect(..., additional_headers={\"Authorization\": ...}) as websocket:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Logging for Existing Logger\nDESCRIPTION: Configures debug logging when logging is already set up in the application. Creates a logger specifically for websockets, sets its level to DEBUG, and adds a StreamHandler.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/debugging.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\nlogger = logging.getLogger(\"websockets\")\nlogger.setLevel(logging.DEBUG)\nlogger.addHandler(logging.StreamHandler())\n```\n\n----------------------------------------\n\nTITLE: Setting Up WebSockets Client for Testing\nDESCRIPTION: Commands to create a Python virtual environment and install the websockets package for testing the deployed server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ python -m venv websockets-client\n$ . websockets-client/bin/activate\n$ pip install websockets\n```\n\n----------------------------------------\n\nTITLE: Testing Graceful Shutdown During Deployment\nDESCRIPTION: Example showing how the WebSockets server performs a proper closing handshake when a new deployment is triggered, demonstrating the graceful shutdown functionality implemented in the server code.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/render.rst#2025-04-20_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ websockets wss://websockets-echo.onrender.com/\nConnected to wss://websockets-echo.onrender.com/.\nConnection closed: 1001 (going away).\n```\n\n----------------------------------------\n\nTITLE: Handling WebSocket Client Handshake Errors\nDESCRIPTION: Error handling code for WebSocket client handshake failures.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/sansio.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nif protocol.handshake_exc is not None:\n    raise protocol.handshake_exc\n```\n\n----------------------------------------\n\nTITLE: JSON Logging Configuration\nDESCRIPTION: Sets up logging configuration to output logs in JSON format using a custom formatter and handler.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/logging.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nhandler = logging.StreamHandler()\nhandler.setFormatter(formatter)\n\nlogger = logging.getLogger()\nlogger.addHandler(handler)\nlogger.setLevel(logging.INFO)\n```\n\n----------------------------------------\n\nTITLE: Installing WebSockets Package in Python\nDESCRIPTION: Commands to install the websockets package and verify its installation using pip.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ pip install websockets\n\n$ websockets --version\n```\n\n----------------------------------------\n\nTITLE: Setting Up WebSockets Client for Testing\nDESCRIPTION: Commands for creating a Python virtual environment and installing the websockets library to use its interactive client for testing the deployed WebSockets server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/render.rst#2025-04-20_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ python -m venv websockets-client\n$ . websockets-client/bin/activate\n$ pip install websockets\n```\n\n----------------------------------------\n\nTITLE: Importing WebSocket Client Protocol in Python\nDESCRIPTION: This snippet shows how to import the ClientProtocol class from the websockets.client module. The ClientProtocol class implements the WebSocket protocol for clients using a Sans-I/O approach.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/sansio/client.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.client import ClientProtocol\n```\n\n----------------------------------------\n\nTITLE: Server Extension Factory Documentation\nDESCRIPTION: Documentation for the ServerExtensionFactory class that handles server-side extension processing and parameter management.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/extensions.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass ServerExtensionFactory:\n    def process_request_params()\n```\n\n----------------------------------------\n\nTITLE: Creating Requirements File for WebSockets Application\nDESCRIPTION: The requirements.txt file specifies the websockets package as a dependency for the Heroku application.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Terminating a WebSockets Server Instance\nDESCRIPTION: Command to terminate a specific instance of the WebSockets server using its process ID.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/supervisor.rst#2025-04-20_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ kill -TERM 43597\n```\n\n----------------------------------------\n\nTITLE: Reverting to Original Exception Handling in Python WebSockets\nDESCRIPTION: This snippet demonstrates how to revert to the original exception handling behavior when connecting to a WebSocket server using the new implementation.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/upgrade.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync for ... in connect(..., process_exception=lambda exc: exc):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Importing WebSocket Client Connection in Python\nDESCRIPTION: Example showing the recommended way to import WebSocket client connection functionality using the real import path instead of convenience imports.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/project/changelog.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.client import connect\nfrom websockets.server import serve\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Number of Headers in Python WebSockets\nDESCRIPTION: Sets the maximum number of HTTP headers allowed in the opening handshake. The default value is 128 bytes.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/variables.rst#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nWEBSOCKETS_MAX_NUM_HEADERS\n```\n\n----------------------------------------\n\nTITLE: Restarting Heroku Dyno for Testing Shutdown\nDESCRIPTION: Command to restart the Heroku dyno to test graceful shutdown behavior of the WebSockets server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n$ heroku dyno:restart -a websockets-echo\nRestarting dynos on ⬢ websockets-echo... done\n```\n\n----------------------------------------\n\nTITLE: Observing Graceful Connection Closure on Restart\nDESCRIPTION: Observing that the WebSockets connection is closed with code 1001 (going away) which indicates a graceful shutdown.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_12\n\nLANGUAGE: console\nCODE:\n```\n$ websockets wss://websockets-echo.herokuapp.com/\nConnected to wss://websockets-echo.herokuapp.com/.\nConnection closed: 1001 (going away).\n```\n\n----------------------------------------\n\nTITLE: Importing WebSockets APIs from the Legacy Implementation\nDESCRIPTION: Shows how to continue using the legacy asyncio implementation by importing explicitly from the legacy module.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/project/changelog.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom websockets.legacy.client import connect, unix_connect\nfrom websockets.legacy.server import broadcast, serve, unix_serve\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Redirects in Python WebSockets\nDESCRIPTION: Sets the maximum number of redirects that the connect function will follow. The default value is 10.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/variables.rst#2025-04-20_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nWEBSOCKETS_MAX_REDIRECTS\n```\n\n----------------------------------------\n\nTITLE: Creating Git Repository for WebSockets Echo Server\nDESCRIPTION: Commands for initializing a Git repository for a WebSockets echo server project. This includes creating a directory, initializing Git, and making an empty initial commit.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/render.rst#2025-04-20_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mkdir websockets-echo\n$ cd websockets-echo\n$ git init -b main\nInitialized empty Git repository in websockets-echo/.git/\n$ git commit --allow-empty -m \"Initial commit.\"\n[main (root-commit) 816c3b1] Initial commit.\n```\n\n----------------------------------------\n\nTITLE: Installing Python Websockets Library via pip\nDESCRIPTION: Command for installing the websockets library using pip package manager. The library requires Python ≥ 3.9 and has no additional dependencies. Wheels are available for all platforms.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/index.rst#2025-04-20_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ pip install websockets\n```\n\n----------------------------------------\n\nTITLE: Updating Process Request Handler in Python WebSockets\nDESCRIPTION: This example shows how to update the process_request handler when migrating from the legacy to the new WebSocket server implementation.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/upgrade.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport http\n\n# Original implementation\n\ndef process_request(path, request_headers):\n    return http.HTTPStatus.OK, [], b\"OK\\n\"\n\n# New implementation\n\ndef process_request(connection, request):\n    return connection.respond(http.HTTPStatus.OK, \"OK\\n\")\n\nserve(..., process_request=process_request, ...)\n```\n\n----------------------------------------\n\nTITLE: Debug Logging Configuration for Development\nDESCRIPTION: Enables debug level logging for development purposes with timestamp and message format.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/logging.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nlogging.basicConfig(\n    format=\"%(asctime)s %(message)s\",\n    level=logging.DEBUG,\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Git Repository for Heroku Deployment\nDESCRIPTION: Commands to create and initialize a Git repository for deploying a WebSockets server to Heroku. This is the first step in the deployment process.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mkdir websockets-echo\n$ cd websockets-echo\n$ git init -b main\nInitialized empty Git repository in websockets-echo/.git/\n$ git commit --allow-empty -m \"Initial commit.\"\n[main (root-commit) 1e7947d] Initial commit.\n```\n\n----------------------------------------\n\nTITLE: Creating Heroku Application for WebSockets Server\nDESCRIPTION: Command to create a new Heroku application with a unique name for deploying the WebSockets echo server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ heroku create websockets-echo\nCreating ⬢ websockets-echo... done\nhttps://websockets-echo.herokuapp.com/ | https://git.heroku.com/websockets-echo.git\n```\n\n----------------------------------------\n\nTITLE: Installing WebSockets and Supervisor Dependencies\nDESCRIPTION: pip commands to install the required packages 'websockets' and 'supervisor' in the activated virtual environment.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/supervisor.rst#2025-04-20_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ pip install websockets\n$ pip install supervisor\n```\n\n----------------------------------------\n\nTITLE: Disable WebSocket Logging Configuration\nDESCRIPTION: Shows different methods to disable logging for websockets, including adding NullHandler and disabling propagation.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/logging.rst#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nlogging.getLogger(\"websockets\").addHandler(logging.NullHandler())\nlogging.getLogger(\"websockets\").propagate = False\n```\n\n----------------------------------------\n\nTITLE: Pushing Changes to GitHub\nDESCRIPTION: Command for pushing the committed changes to GitHub, which is a prerequisite for deploying to Render as Render requires the repository to be hosted on GitHub or GitLab.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/render.rst#2025-04-20_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ git push\n...\nTo github.com:<username>/websockets-echo.git\n   816c3b1..f26bf7f  main -> main\n```\n\n----------------------------------------\n\nTITLE: Shutting Down Supervisor and WebSockets Deployment\nDESCRIPTION: Command to gracefully shut down the Supervisor process, which in turn terminates all WebSockets server instances.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/supervisor.rst#2025-04-20_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ kill -TERM 43596\n```\n\n----------------------------------------\n\nTITLE: Starting Supervisor for WebSockets Deployment\nDESCRIPTION: Command to start Supervisor in the foreground using the specified configuration file.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/supervisor.rst#2025-04-20_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ supervisord -c supervisord.conf -n\n```\n\n----------------------------------------\n\nTITLE: HTML for WebSocket Time Display\nDESCRIPTION: This HTML file creates a simple webpage that connects to a WebSocket server and displays the received time.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/examples.rst#2025-04-20_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>WebSocket demo</title>\n    </head>\n    <body>\n        <div id=\"time\"></div>\n        <script src=\"show_time.js\"></script>\n    </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Configuring Initial Backoff Delay in Python WebSockets\nDESCRIPTION: Sets the maximum initial delay for reconnection attempts. The first attempt is delayed by a random amount between 0 and this value. The default is 5.0 seconds.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/variables.rst#2025-04-20_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nWEBSOCKETS_BACKOFF_INITIAL_DELAY\n```\n\n----------------------------------------\n\nTITLE: Verifying and Committing Application Files\nDESCRIPTION: Commands to confirm the creation of necessary files and commit them to the Git repository before deployment.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ ls\nProcfile         app.py           requirements.txt\n$ git add .\n$ git commit -m \"Initial implementation.\"\n[main 8418c62] Initial implementation.\n 3 files changed, 32 insertions(+)\n create mode 100644 Procfile\n create mode 100644 app.py\n create mode 100644 requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Sending Invalid UTF-8 as Text in Python Websockets\nDESCRIPTION: Demonstrates how to send invalid UTF-8 content as a text message by bypassing the normal UTF-8 encoding. This is shown as an example of a limitation where the library doesn't enforce proper UTF-8 validation when encoding is explicitly disabled.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/features.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsend(not_utf8_bytes, text=True)\n```\n\n----------------------------------------\n\nTITLE: Connecting to WebSockets Server Using WebSockets CLI\nDESCRIPTION: Command to connect to the deployed WebSockets server using the WebSockets CLI tool.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/supervisor.rst#2025-04-20_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ websockets ws://localhost:8080/\n```\n\n----------------------------------------\n\nTITLE: Committing Files to Git Repository\nDESCRIPTION: Commands for verifying the created files, adding them to Git, committing the changes, and pushing to GitHub. This prepares the repository for deployment on Render.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/render.rst#2025-04-20_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ ls\napp.py           requirements.txt\n$ git add .\n$ git commit -m \"Initial implementation.\"\n[main f26bf7f] Initial implementation.\n2 files changed, 37 insertions(+)\ncreate mode 100644 app.py\ncreate mode 100644 requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Configuring WebSocket Server with Legacy Behavior in Python\nDESCRIPTION: Shows how to enable legacy receive behavior when initializing a WebSocket server or client using the websockets library. This is useful for maintaining compatibility with older versions of the library.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/project/changelog.rst#2025-04-20_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nserve(legacy_recv=True)\nconnect(legacy_recv=True)\nWebSocketServerProtocol(legacy_recv=True)\nWebSocketClientProtocol(legacy_recv=True)\n```\n\n----------------------------------------\n\nTITLE: Starting the HTTP Server to Serve Static Files\nDESCRIPTION: Command to start Python's built-in HTTP server for serving the static HTML, CSS, and JavaScript files for the Connect Four game UI.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ python -m http.server\n```\n\n----------------------------------------\n\nTITLE: Creating Requirements.txt for WebSockets Dependency\nDESCRIPTION: A simple requirements.txt file that declares a dependency on the websockets package for Python applications.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/fly.rst#2025-04-20_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nwebsockets\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Backoff Delay in Python WebSockets\nDESCRIPTION: Defines the maximum delay between reconnection attempts. The default value is 90.0 seconds.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/variables.rst#2025-04-20_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nWEBSOCKETS_BACKOFF_MAX_DELAY\n```\n\n----------------------------------------\n\nTITLE: Installing Watchdog with Watchmedo\nDESCRIPTION: Command to install the watchdog package with watchmedo shell utility support for monitoring file changes.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/autoreload.rst#2025-04-20_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ pip install 'watchdog[watchmedo]'\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket and UI in JavaScript\nDESCRIPTION: Event listener for DOMContentLoaded that initializes the UI and WebSocket connection.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial1.rst#2025-04-20_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n  // Initialize the UI.\n  const board = document.querySelector(\".board\");\n  createBoard(board);\n  // Open the WebSocket connection and register event handlers.\n  const websocket = new WebSocket(\"ws://localhost:8001/\");\n  sendMoves(board, websocket);\n});\n```\n\n----------------------------------------\n\nTITLE: Building Python Extension for Performance\nDESCRIPTION: Command to compile the C extension for better performance before running tests.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/compliance/README.rst#2025-04-20_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ python setup.py build_ext --inplace\n```\n\n----------------------------------------\n\nTITLE: Configuring Backoff Factor in Python WebSockets\nDESCRIPTION: Sets the multiplier for increasing delay between reconnection attempts after the second attempt. The default value is 1.618.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/variables.rst#2025-04-20_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nWEBSOCKETS_BACKOFF_FACTOR\n```\n\n----------------------------------------\n\nTITLE: Common Import Error Example\nDESCRIPTION: Example of a common attribute error that occurs when a local file named 'websockets.py' conflicts with the websockets library import.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/faq/misc.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmodule 'websockets' has no attribute '...'\n```\n\n----------------------------------------\n\nTITLE: Adding Join Link to HTML\nDESCRIPTION: Adds an anchor element to the HTML to display the link for joining the game.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/tutorial2.rst#2025-04-20_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n  <body>\n    <div class=\"actions\">\n      <a class=\"action join\" href=\"\">Join</a>\n    </div>\n    <!-- ... -->\n  </body>\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating Virtual Environment for WebSockets Deployment\nDESCRIPTION: Commands to create a new virtual environment named 'supervisor-websockets' and activate it for the WebSockets deployment.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/supervisor.rst#2025-04-20_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ python -m venv supervisor-websockets\n$ . supervisor-websockets/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum Backoff Delay in Python WebSockets\nDESCRIPTION: Defines the delay for the second reconnection attempt. The default value is 3.1 seconds.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/variables.rst#2025-04-20_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nWEBSOCKETS_BACKOFF_MIN_DELAY\n```\n\n----------------------------------------\n\nTITLE: Installing SOCKS Proxy Support for Python WebSockets\nDESCRIPTION: Command to install the python-socks library with asyncio support, which is required for connecting through SOCKS proxies with the websockets library.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/proxies.rst#2025-04-20_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ pip install python-socks\\[asyncio\\]\n```\n\n----------------------------------------\n\nTITLE: Listing Optional Dependencies for Python Websockets\nDESCRIPTION: A plaintext list of dependencies required for extended functionality in the Python websockets package. It includes python-socks with asyncio support for SOCKS proxy integration and mitmproxy for HTTP inspection capabilities.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/tests/requirements.txt#2025-04-20_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npython-socks[asyncio]\nmitmproxy\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging Max Log Size in Python WebSockets\nDESCRIPTION: Sets the maximum size of each frame to show in debug logs. The default value is 75.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/variables.rst#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nWEBSOCKETS_MAX_LOG_SIZE\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents in reStructuredText for Websockets Documentation\nDESCRIPTION: This snippet defines a table of contents using reStructuredText syntax. It includes links to various documentation sections related to the websockets project, such as changelog, contributing guidelines, and licensing information.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/project/index.rst#2025-04-20_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :titlesonly:\n\n   changelog\n   contributing\n   sponsoring\n   For enterprise <tidelift>\n   support\n   license\n```\n\n----------------------------------------\n\nTITLE: WebSockets Requirements File\nDESCRIPTION: The requirements.txt file specifying the dependency on the websockets library, which is necessary for running the WebSockets echo server.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/render.rst#2025-04-20_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nwebsockets\n```\n\n----------------------------------------\n\nTITLE: Defining Topic Guide Structure in reStructuredText\nDESCRIPTION: This snippet defines the structure of topic guides using reStructuredText directives. It includes two main sections: general topic guides and optimization guides.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/topics/index.rst#2025-04-20_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n\n   authentication\n   broadcast\n   logging\n   proxies\n   routing\n\n.. toctree::\n   :maxdepth: 2\n\n   compression\n   keepalive\n   memory\n   security\n   performance\n```\n\n----------------------------------------\n\nTITLE: Configuring User-Agent Header in Python WebSockets\nDESCRIPTION: Sets the User-Agent header sent by websockets. The default format is \"Python/x.y.z websockets/X.Y\".\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/reference/variables.rst#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nWEBSOCKETS_USER_AGENT\n```\n\n----------------------------------------\n\nTITLE: Styling Tidelift Links in HTML and CSS\nDESCRIPTION: This snippet defines the CSS styling for Tidelift subscription links. It includes responsive design for different screen sizes and custom styling for 'Learn more' and 'Request a demo' buttons.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/project/tidelift.rst#2025-04-20_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<style type=\"text/css\">\n.tidelift-links {\n    display: flex;\n    justify-content: center;\n}\n@media only screen and (max-width: 600px)  {\n    .tidelift-links {\n        flex-direction: column;\n    }\n}\n.tidelift-links a {\n    border: thin solid #f6914d;\n    border-radius: 0.25em;\n    font-family: Verdana, sans-serif;\n    font-size: 15px;\n    margin: 0.5em 2em;\n    padding: 0.5em 2em;\n    text-align: center;\n    text-decoration: none;\n    text-transform: uppercase;\n}\n.tidelift-links a.tidelift-links__learn-more {\n    background-color: white;\n    color: #f6914d;\n}\n.tidelift-links a.tidelift-links__request-a-demo {\n    background-color: #f6914d;\n    color: white;\n}\n</style>\n```\n\n----------------------------------------\n\nTITLE: Setting Token Lifespan for Django-Sesame\nDESCRIPTION: Configuration for the maximum age of authentication tokens generated by django-sesame, set to 30 seconds to allow reasonable time for establishing WebSocket connections.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/howto/django.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nSESAME_MAX_AGE = 30\n```\n\n----------------------------------------\n\nTITLE: Rendering Tidelift Subscription Links in HTML\nDESCRIPTION: This HTML snippet creates two styled links for the Tidelift subscription: 'Learn more' and 'Request a demo'. The links are styled using the CSS defined in the previous snippet.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/project/tidelift.rst#2025-04-20_snippet_1\n\nLANGUAGE: HTML\nCODE:\n```\n<div class=\"tidelift-links\">\n<a class=\"tidelift-links__learn-more\" href=\"https://tidelift.com/subscription/pkg/pypi-websockets?utm_source=pypi-websockets&utm_medium=referral&utm_campaign=enterprise\">Learn more</a>\n<a class=\"tidelift-links__request-a-demo\" href=\"https://tidelift.com/subscription/request-a-demo?utm_source=pypi-websockets&utm_medium=referral&utm_campaign=enterprise\">Request a demo</a>\n</div>\n```\n\n----------------------------------------\n\nTITLE: CSS Styling for Counter Application\nDESCRIPTION: This CSS file provides styling for the counter application webpage, including layout and button styles.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/intro/examples.rst#2025-04-20_snippet_8\n\nLANGUAGE: css\nCODE:\n```\nbody {\n    font-family: sans-serif;\n}\n\n.users {\n    text-align: right;\n}\n\n.counter {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    width: 150px;\n    margin: 0 auto;\n}\n\n.counter button {\n    width: 40px;\n    height: 40px;\n    border-radius: 50%;\n    border: none;\n    font-weight: bold;\n}\n\n.counter button:hover {\n    background-color: #ccc;\n}\n\n.counter span {\n    font-size: 24px;\n}\n```\n\n----------------------------------------\n\nTITLE: Documentation Dependencies Requirements\nDESCRIPTION: Lists the required Python packages for building documentation with Sphinx, including styling theme (furo), build tools, and various Sphinx extensions for enhanced functionality.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/requirements.txt#2025-04-20_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\nfuro\nsphinx\nsphinx-autobuild\nsphinx-copybutton\nsphinx-inline-tabs\nsphinxcontrib-spelling\nsphinxcontrib-trio\nsphinxext-opengraph\nwerkzeug\n```\n\n----------------------------------------\n\nTITLE: Connecting to WebSocket Server with threading API in Python\nDESCRIPTION: An example of a WebSocket client implementation using the threading API from the websockets library. The client connects to a WebSocket server at ws://localhost:8765, sends a message, and prints the received response.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/README.rst#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python\n\nfrom websockets.sync.client import connect\n\ndef hello():\n    with connect(\"ws://localhost:8765\") as websocket:\n        websocket.send(\"Hello world!\")\n        message = websocket.recv()\n        print(f\"Received: {message}\")\n\nhello()\n```\n\n----------------------------------------\n\nTITLE: Testing Graceful Shutdown of WebSockets Server\nDESCRIPTION: Commands to test that the WebSockets server shuts down gracefully by restarting the Heroku dyno and observing the proper closing handshake.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/deploy/heroku.rst#2025-04-20_snippet_10\n\nLANGUAGE: console\nCODE:\n```\n$ websockets wss://websockets-echo.herokuapp.com/\nConnected to wss://websockets-echo.herokuapp.com/.\n>\n```\n\n----------------------------------------\n\nTITLE: Including LICENSE File with reStructuredText\nDESCRIPTION: Directive to include the project's LICENSE file from the parent directory into the documentation.\nSOURCE: https://github.com/python-websockets/websockets/blob/main/docs/project/license.rst#2025-04-20_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. include:: ../../LICENSE\n```"
  }
]