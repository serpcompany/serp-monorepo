[
  {
    "owner": "emelleby",
    "repo": "docwood",
    "content": "TITLE: Creating a New RedwoodJS Project using Yarn\nDESCRIPTION: Uses the `yarn create` command to initialize a new RedwoodJS application named 'my-redwood-project' in the current directory. This command scaffolds the basic project structure. Requires Node.js (=20.x) and Yarn (>=1.22.21) to be installed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn create redwood-app my-redwood-project\n```\n\n----------------------------------------\n\nTITLE: Creating a RedwoodJS Project with TypeScript using Yarn\nDESCRIPTION: This command utilizes Yarn's `create` command to initialize a new RedwoodJS application within a directory named `redwoodblog`. The `--ts` flag ensures the project is configured to use TypeScript. Requires Yarn to be installed globally.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/installation.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn create redwood-app --ts ./redwoodblog\n```\n\n----------------------------------------\n\nTITLE: Mapping Nhost Client Methods to Redwood Auth Interface - TypeScript\nDESCRIPTION: Implements createAuthImplementation to connect NhostClient methods to Redwood's custom auth interface. Each function wraps the corresponding Nhost auth SDK method for login, logout, signup, JWT retrieval, user info, and session restoration. Input parameters for signIn/signUp/signOut are passed directly to the SDK, supporting various authentication strategies as described in the Nhost documentation. This structure is required for Redwood's useAuth hook and AuthProvider component to function with a custom provider.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createAuthImplementation(client: AuthClient) {\n  return {\n    type: 'custom-auth',\n    client,\n    // See sign in options at https://docs.nhost.io/reference/javascript/auth/sign-in\n    login: async (options) => {\n      return await client.auth.signIn(options)\n    },\n    // See sign out options at https://docs.nhost.io/reference/javascript/auth/sign-out\n    logout: async (options) => {\n      return await client.auth.signOut(options)\n    },\n    // See sign up options at https://docs.nhost.io/reference/javascript/auth/sign-up\n    signup: async (options) => {\n      return await client.auth.signUp(options)\n    },\n    getToken: async () => {\n      return (await client.auth.getJWTToken()) || null\n    },\n    // See https://docs.nhost.io/reference/javascript/auth/get-user\n    getUserMetadata: async () => {\n      return await client.auth.getUser()\n    },\n    restoreAuthState: async () => {\n      return await client.auth.refreshSession()\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Contact Service Resolvers with Prisma and Type Safety (RedwoodJS, TypeScript)\nDESCRIPTION: This TypeScript snippet provides fully-typed service resolver implementations for the Contact resource in a RedwoodJS backend. It leverages types from the generated GraphQL schema (QueryResolvers, MutationResolvers), and performs CRUD operations using Prisma's API. Functions expect parameters typed according to GraphQL input requirements and return corresponding Prisma outputs. Dependencies include 'src/lib/db' for Prisma access and relevant GraphQL TypeScript types. Inputs and outputs must conform to the expected interfaces.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nimport type { QueryResolvers, MutationResolvers } from 'types/graphql'\\n\\nimport { db } from 'src/lib/db'\\n\\nexport const contacts: QueryResolvers['contacts'] = () => {\\n  return db.contact.findMany()\\n}\\n\\nexport const contact: QueryResolvers['contact'] = ({ id }) => {\\n  return db.contact.findUnique({\\n    where: { id },\\n  })\\n}\\n\\nexport const createContact: MutationResolvers['createContact'] = ({ input }) => {\\n  return db.contact.create({\\n    data: input,\\n  })\\n}\\n\\nexport const updateContact: MutationResolvers['updateContact'] = ({ id, input }) => {\\n  return db.contact.update({\\n    data: input,\\n    where: { id },\\n  })\\n}\\n\\nexport const deleteContact: MutationResolvers['deleteContact'] = ({ id }) => {\\n  return db.contact.delete({\\n    where: { id },\\n  })\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Setting up Supabase Auth with Redwood CLI (Bash)\nDESCRIPTION: This command initializes Supabase authentication within a RedwoodJS project. It installs required packages (@redwoodjs/auth-supabase-web, @supabase/supabase-js) and generates boilerplate code, including modifications to `App.js/tsx` and creation of `auth.js/tsx`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup auth supabase\n```\n\n----------------------------------------\n\nTITLE: Implementing GitHub OAuth Callback Logic in RedwoodJS Function (JavaScript)\nDESCRIPTION: JavaScript code for the `/api/src/functions/oauth/oauth.js` RedwoodJS serverless function. This function handles the GitHub OAuth callback: it receives an authorization code, exchanges it for an access token with GitHub, retrieves user details from GitHub (via `getProviderUser`), finds or creates a corresponding local user and identity record using `findOrCreateUser`, updates the identity record with the latest access token, scope, and login time, and returns the user object. It utilizes the Prisma client (`db`) for database interactions and transactions (`db.$transaction`) for atomic user/identity creation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// highlight-next-line\nimport { db } from 'src/lib/db'\n\nconst callback = async (event) => {\n  const { code } = event.queryStringParameters\n\n  const response = await fetch(`https://github.com/login/oauth/access_token`, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      client_id: process.env.GITHUB_OAUTH_CLIENT_ID,\n      client_secret: process.env.GITHUB_OAUTH_CLIENT_SECRET,\n      redirect_uri: process.env.GITHUB_OAUTH_REDIRECT_URI,\n      code,\n    }),\n  })\n\n  const { access_token, scope, error } = JSON.parse(await response.text())\n\n  if (error) {\n    return { statuscode: 400, body: error }\n  }\n\n  try {\n    const providerUser = await getProviderUser(access_token)\n    // highlight-start\n    const user = await getUser({ providerUser, accessToken: access_token, scope })\n    return {\n      body: JSON.stringify(user)\n    }\n    // highlight-end\n  } catch (e) {\n    return { statuscode: 500, body: e.message }\n  }\n}\n\n// highlight-start\nconst getUser = async ({ providerUser, accessToken, scope }) => {\n  const { user, identity } = await findOrCreateUser(providerUser)\n\n  await db.identity.update({\n    where: { id: identity.id },\n    data: { accessToken, scope, lastLoginAt: new Date() },\n  })\n\n  return user\n}\n// highlight-end\n\n// highlight-start\nconst findOrCreateUser = async (providerUser) => {\n  const identity = await db.identity.findFirst({\n    where: { provider: 'github', uid: providerUser.id.toString() }\n  })\n\n  if (identity) {\n    // identity exists, return the user\n    const user = await db.user.findUnique({ where: { id: identity.userId }})\n    return { user, identity }\n  }\n\n  // identity not found, need to create it and the user\n  return await db.$transaction(async (tx) => {\n    const user = await tx.user.create({\n      data: {\n        email: providerUser.email,\n        fullName: providerUser.name,\n      },\n    })\n\n    const identity = await tx.identity.create({\n      data: {\n        userId: user.id,\n        provider: 'github',\n        uid: providerUser.id.toString()\n      }\n    })\n\n    return { user, identity }\n  })\n}\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Defining Authenticated and Public Routes in Redwood Router (React, JSX)\nDESCRIPTION: This snippet demonstrates a Redwood routes configuration in JSX for a frontend React application. It details the setup of routing with both public and authenticated (PrivateSet) sections, layout wrapping using the ApplicationLayout component, and route-based component assignment. Dependencies include @redwoodjs/router and a custom useAuth hook, as well as imported layout/page components. Key props include paths, page components, and authentication hooks; outputs are the routed React components and access control. Notable constraints: only users authenticated are allowed into PrivateSet routes, and notfound provides a fallback for unmatched routes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/02_chapter0/what-is-redwood.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Route, Router, Set, PrivateSet } from '@redwoodjs/router'\nimport ApplicationLayout from 'src/layouts/ApplicationLayout'\nimport { useAuth } from './auth'\n\nconst Routes = () => {\n  return (\n    <Router useAuth={useAuth}>\n      <Set wrap={ApplicationLayout}>\n        <Route path=\"/login\" page={LoginPage} name=\"login\" />\n        <Route path=\"/signup\" page={SignupPage} name=\"signup\" />\n        <PrivateSet unauthenticated=\"login\">\n          <Route path=\"/dashboard\" page={DashboardPage} name=\"dashboard\" />\n          <Route path=\"/products/{sku}\" page={ProductsPage} name=\"products\" />\n        </PrivateSet>\n      </Set>\n\n      <Route path=\"/\" page={HomePage} name=\"home\" />\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Comment in RedwoodJS Service (TypeScript)\nDESCRIPTION: Adds a typed `createComment` function to 'api/src/services/comments/comments.ts'. It defines an interface `CreateCommentArgs` specifying the `input` parameter should conform to `Prisma.CommentCreateInput`. It uses `db.comment.create({ data: input })` for database insertion.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.ts\"\ninterface CreateCommentArgs {\n  input: Prisma.CommentCreateInput\n}\n\nexport const createComment = ({ input }: CreateCommentArgs) => {\n  return db.comment.create({\n    data: input,\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: RedwoodJS Webhook Handler for Secure Order Status Update (TypeScript/TSX)\nDESCRIPTION: Implements a RedwoodJS function handler that verifies signed webhook requests, parses request payloads, enforces order status transitions, and updates the Order model in the database upon valid requests. Uses the '@redwoodjs/api/webhooks' module for signature verification, expects a SHA256 signature in the 'X-Webhook-Signature' header, and throws HTTP 401 or 500 errors for verification or other failures. Inputs include the AWS Lambda event object, and outputs are standard HTTP responses. Requires RedwoodJS API services, Prisma ORM with the defined Order schema, and a secret key for signing. Only allows certain status transitions as defined in the logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { APIGatewayEvent } from 'aws-lambda'\nimport {\n  verifyEvent,\n  VerifyOptions,\n  WebhookVerificationError,\n} from '@redwoodjs/api/webhooks'\nimport { db } from 'src/lib/db'\n\nexport const handler = async (event: APIGatewayEvent) => {\n  let currentOrderStatus = 'UNKNOWN'\n\n  try {\n    const options = {\n      signatureHeader: 'X-Webhook-Signature',\n    } as VerifyOptions\n\n    verifyEvent('sha256Verifier', {\n      event,\n      secret: 'MY-VOICE-IS-MY-PASSPORT-VERIFY-ME',\n      options,\n    })\n\n    // Safely use the validated webhook payload body\n    const body = JSON.parse(event.body)\n    const trackingNumber = body.trackingNumber\n    const status = body.status\n\n    // You can only update the status if the order's current status allows\n    switch (status) {\n      case 'PLACED':\n        currentOrderStatus = 'UNKNOWN'\n        break\n      case 'SHIPPED':\n        currentOrderStatus = 'PLACED'\n        break\n      case 'DELIVERED':\n        currentOrderStatus = 'SHIPPED'\n        break\n      default:\n        currentOrderStatus = 'UNKNOWN'\n    }\n\n    // updated the order with the new status\n    // using the trackingNumber provided\n    const order = await db.order.update({\n      where: {\n        trackingNumber_status: { trackingNumber, status: currentOrderStatus },\n      },\n      data: { status: status },\n    })\n\n    return {\n      statusCode: 200, // Success!!!\n      body: JSON.stringify({\n        order,\n        message: `Updated order ${order.id} to ${order.status} at ${order.updatedAt}`,\n      }),\n    }\n  } catch (error) {\n    if (error instanceof WebhookVerificationError) {\n      return {\n        statusCode: 401, // Unauthorized\n      }\n    } else {\n      return {\n        statusCode: 500, // An error\n        body: JSON.stringify({\n          error: error.message,\n          message: `Unable to update the order status`,\n        }),\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining User and Role Models for Database RBAC in RedwoodJS (Prisma)\nDESCRIPTION: Presents a Prisma schema defining `User` and `UserRole` models for implementing database-backed RBAC. The `User` model links to potentially multiple `UserRole` entries via a one-to-many relationship. The `UserRole` model stores the role name and maintains a unique constraint per user per role name. This schema is required for fetching roles from a database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_2\n\nLANGUAGE: prisma\nCODE:\n```\nmodel User {\n  id        Int        @id @default(autoincrement())\n  uuid      String     @unique\n  createdAt DateTime   @default(now())\n  updatedAt DateTime   @default(now())\n  userRoles UserRole[]\n}\n\nmodel UserRole {\n  id        Int      @id @default(autoincrement())\n  createdAt DateTime @default(now())\n  updatedAt DateTime @default(now())\n  name      String\n  user      User?    @relation(fields: [userId], references: [id])\n  userId    Int?\n\n  @@unique([name, userId])\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Contact Page Component and Mutation in TSX\nDESCRIPTION: This TSX code defines the complete `ContactPage` component using RedwoodJS. It includes necessary imports, defines the `CREATE_CONTACT` GraphQL mutation using `gql`, sets up the `useMutation` hook with TypeScript types, implements the `onSubmit` handler, and renders the contact form using RedwoodJS form components (`Form`, `Label`, `TextField`, `TextAreaField`, `FieldError`, `Submit`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\nimport {\n  CreateContactMutation,\n  CreateContactMutationVariables,\n} from 'types/graphql'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const [create] = useMutation<\n    CreateContactMutation,\n    CreateContactMutationVariables\n  >(CREATE_CONTACT)\n\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    // highlight-next-line\n    create({ variables: { input: data } })\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Database Migration with Prisma CLI - Bash\nDESCRIPTION: This snippet provides the shell command to apply a schema migration using the Prisma CLI in a RedwoodJS project. By running 'yarn rw prisma migrate dev', developers apply all pending migrations, updating the database to include newly defined models such as Contact. The command assumes Yarn, RedwoodJS, and Prisma are installed and set up. It prompts for a migration name and applies changes to the development database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Submitting Comments with RedwoodJS Form (JavaScript)\nDESCRIPTION: Implements a comment form component in JavaScript using RedwoodJS forms and the useMutation hook for submitting GraphQL mutations. The code imports UI form components and creates a GraphQL mutation for comment creation. It defines an onSubmit handler to call the mutation with form input, handles errors via FormError, and manages button state while the mutation is loading. Dependencies include @redwoodjs/forms and @redwoodjs/web, and the form expects 'name' and 'body' as user input, returning comment data on success.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Form,\n  // highlight-next-line\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n// highlight-next-line\nimport { useMutation } from '@redwoodjs/web'\n\n// highlight-start\nconst CREATE = gql`\n  mutation CreateCommentMutation($input: CreateCommentInput!) {\n    createComment(input: $input) {\n      id\n      name\n      body\n      createdAt\n    }\n  }\n`\n// highlight-end\n\nconst CommentForm = () => {\n  // highlight-next-line\n  const [createComment, { loading, error }] = useMutation(CREATE)\n\n  // highlight-start\n  const onSubmit = (input) => {\n    createComment({ variables: { input } })\n  }\n  // highlight-end\n\n  return (\n    <div>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      // highlight-start\n      <Form className=\"mt-4 w-full\" onSubmit={onSubmit}>\n        <FormError\n          error={error}\n          titleClassName=\"font-semibold\"\n          wrapperClassName=\"bg-red-100 text-red-900 text-sm p-3 rounded\"\n        />\n        // highlight-end\n        <Label\n          name=\"name\"\n          className=\"block text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-sm \"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-sm\"\n          validation={{ required: true }}\n        />\n\n        <Submit\n          // highlight-next-line\n          disabled={loading}\n          className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\"\n        >\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n\n----------------------------------------\n\nTITLE: Implementing Contact Service Resolvers with Prisma (RedwoodJS, JavaScript)\nDESCRIPTION: This JavaScript snippet implements resolver functions in a service file for the Contact resource, using Prisma via RedwoodJS's db import. It provides CRUD operations: contacts retrieves all records, contact fetches one by ID, createContact inserts a record from input, and updateContact/deleteContact modify or remove by ID. These functions are automatically mapped to the SDL types based on naming convention. Dependencies include 'src/lib/db' with Prisma models, and required parameters are input and/or id where noted.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nimport { db } from 'src/lib/db'\\n\\nexport const contacts = () => {\\n  return db.contact.findMany()\\n}\\n\\nexport const contact = ({ id }) => {\\n  return db.contact.findUnique({\\n    where: { id },\\n  })\\n}\\n\\nexport const createContact = ({ input }) => {\\n  return db.contact.create({\\n    data: input,\\n  })\\n}\\n\\nexport const updateContact = ({ id, input }) => {\\n  return db.contact.update({\\n    data: input,\\n    where: { id },\\n  })\\n}\\n\\nexport const deleteContact = ({ id }) => {\\n  return db.contact.delete({\\n    where: { id },\\n  })\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Composing a Validated Form Using RedwoodJS Form Helpers in JavaScript/React\nDESCRIPTION: This example defines a React functional component (ContactPage) that constructs a validated form using RedwoodJS’s Form, Label, TextField, TextAreaField, FieldError, and Submit components. The snippet demonstrates field validation, custom styling for error states, and server/client error display for name, email, and message fields. It expects @redwoodjs/forms as a dependency. The onSubmit handler processes validated data via console.log. Input: User-submitted form fields; Output: Form data logged and error messages rendered for invalid inputs. Required parameters for components include name, validation, errorClassName, and className.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  FieldError,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <Form onSubmit={onSubmit}>\n      <Label name=\"name\" className=\"label\" errorClassName=\"label error\" />\n      <TextField\n        name=\"name\"\n        className=\"input\"\n        errorClassName=\"input error\"\n        validation={{ required: true }}\n      />\n      <FieldError name=\"name\" className=\"error-message\" />\n\n      <Label name=\"email\" className=\"label\" errorClassName=\"label error\" />\n      <TextField\n        name=\"email\"\n        className=\"input\"\n        errorClassName=\"input error\"\n        validation={{\n          required: true,\n          pattern: {\n            value: /[^@]+@[^\\.]+\\..+/, \n          },\n        }}\n      />\n      <FieldError name=\"email\" className=\"error-message\" />\n\n      <Label name=\"message\" className=\"label\" errorClassName=\"label error\" />\n      <TextAreaField\n        name=\"message\"\n        className=\"input\"\n        errorClassName=\"input error\"\n        validation={{ required: true }}\n      />\n      <FieldError name=\"message\" className=\"error-message\" />\n\n      <Submit className=\"button\">Save</Submit>\n    </Form>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Post Pagination GraphQL SDL - RedwoodJS - JavaScript\nDESCRIPTION: Defines a new GraphQL schema for paginated posts, introducing a 'PostPage' type with posts and count fields. This schema allows querying a specific page of posts with an optional 'page' parameter. Requires RedwoodJS GraphQL setup and Prisma with a 'Post' model, returning an object containing the posts for the page and the total post count.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport const schema = gql`\n  # ...\n\n  type PostPage {\n    posts: [Post!]!\n    count: Int!\n  }\n\n  type Query {\n    postPage(page: Int): PostPage\n    posts: [Post!]!\n    post(id: Int!): Post!\n  }\n\n  # ...\n`\n```\n\n----------------------------------------\n\nTITLE: Displaying Form Validation Errors using RedwoodJS Forms and Mutation Hooks (JavaScript/JSX)\nDESCRIPTION: This snippet demonstrates how to display validation error messages in a RedwoodJS web form component by leveraging Redwood's form helpers and Apollo's useMutation hook. It defines a contact form where the error property from the mutation hook is passed to FormError, ensuring relevant validation or API errors are shown to the user. Dependencies include @redwoodjs/forms, @redwoodjs/web, and an active GraphQL mutation; inputs are user form data, and outputs include new record IDs or error messages.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\nimport { Form, FormError, Label, TextField, Submit } from '@redwoodjs/forms'\nimport { useMutation } from '@redwoodjs/web'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: ContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\nconst ContactPage = () => {\n  const [create, { loading, error }] = useMutation(CREATE_CONTACT)\n\n  const onSubmit = (data) => {\n    create({ variables: { input: data }})\n  }\n\n  return (\n    <Form onSubmit={onSubmit}>\n      <FormError error={error}>\n      <Label name=\"email\">Email Address</Label>\n      <TextField name=\"email\" />\n      <Submit disabled={loading}>Save</Submit>\n    </Form>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a RedwoodJS Cell in JavaScript (JSX)\nDESCRIPTION: This snippet demonstrates the basic structure of a RedwoodJS Cell using JavaScript (JSX). It exports named constants: `QUERY` (a GraphQL query string tagged with `gql`), `Loading` (a component displayed during data fetching), `Empty` (a component shown when no data is returned), `Failure` (a component for handling errors), and `Success` (a component that receives and renders the fetched data). Redwood automatically manages rendering these components based on the query lifecycle.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query FindPosts {\n    posts {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>No posts yet!</div>\n\nexport const Failure = ({ error }) => (\n  <div>Error loading posts: {error.message}</div>\n)\n\nexport const Success = ({ posts }) => {\n  return posts.map((post) => (\n    <article key={post.id}>\n      <h2>{post.title}</h2>\n      <div>{post.body}</div>\n    </article>\n  ))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a NotFound Route with RedwoodJS Router - JSX\nDESCRIPTION: This snippet shows how to configure a RedwoodJS router by importing required components and defining a notfound route within the Router. The notfound Route specifies a custom page to render when no other routes match. The only key dependency is '@redwoodjs/router', and Routes must export as the default component. The input expects JSX/JavaScript and outputs a Router with a single notfound handling logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route } from '@redwoodjs/router'\n\nconst Routes = () => (\n  <Router>\n    <Route notfound page={NotFoundPage} />\n  </Router>\n)\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Verifying Stripe-like Webhooks using TimestampScheme in RedwoodJS (TypeScript)\nDESCRIPTION: This AWS Lambda handler function demonstrates verifying incoming webhook requests using the `timestampSchemeVerifier` from `@redwoodjs/api/webhooks`. It checks the signature (using `process.env.WEBHOOK_SECRET` stored in environment variables) and timestamp tolerance (defaulting to 5 minutes, but configurable via `VerifyOptions`) to prevent replay attacks. This method is suitable for services like Stripe or periodic tasks triggered by cron jobs. It uses `logger` for logging and calls an imported `perform()` function upon successful verification, handling potential `WebhookVerificationError` exceptions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\nimport type { APIGatewayEvent } from 'aws-lambda'\n\nimport {\n  verifyEvent,\n  VerifyOptions,\n  WebhookVerificationError,\n} from '@redwoodjs/api/webhooks'\nimport { logger } from 'src/lib/logger'\nimport { perform } from 'src/lib/orbit/jobs/loadActivitiesJob'\n\n/**\n * The handler function is your code that processes http request events.\n * You can use return and throw to send a response or error, respectively.\n *\n * @typedef { import('aws-lambda').APIGatewayEvent } APIGatewayEvent\n * @typedef { import('aws-lambda').Context } Context\n * @param { APIGatewayEvent } event - an object which contains information from the invoker.\n * @param { Context } context - contains information about the invocation,\n * function, and execution environment.\n */\nexport const handler = async (event: APIGatewayEvent) => {\n  const webhookInfo = { webhook: 'loadOrbitActivities-background' }\n\n  const webhookLogger = logger.child({ webhookInfo })\n\n  webhookLogger.trace('>> in loadOrbitActivities-background')\n\n  try {\n    const options = {\n      signatureHeader: 'RW-Webhook-Signature',\n      // You may override these defaults\n      // tolerance: 60_000,\n      // timestamp: new Date().getDate() - 1,\n    } as VerifyOptions\n\n    verifyEvent('timestampSchemeVerifier', {\n      event,\n      secret: process.env.WEBHOOK_SECRET,\n      options,\n    })\n\n    await perform()\n\n    return {\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      statusCode: 200,\n      body: JSON.stringify({\n        data: `loadOrbitActivities scheduled job invoked at ${Date.now()}`,\n      }),\n    }\n  } catch (error) {\n    if (error instanceof WebhookVerificationError) {\n      webhookLogger.warn(\n        { webhook: 'loadOrbitActivities-background' },\n        'Unauthorized'\n      )\n      return {\n        statusCode: 401,\n      }\n    } else {\n      webhookLogger.error(\n        { webhook: 'loadOrbitActivities-background', error },\n        error.message\n      )\n      return {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        statusCode: 500,\n        body: JSON.stringify({\n          error: error.message,\n        }),\n      }\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Exporting GraphQL Resolvers for Root Schema - TypeScript\nDESCRIPTION: This TypeScript snippet exports the Redwood root schema resolvers for a RedwoodJS GraphQL API, mapping custom scalars to resolver functions and providing query logic for the redwood field. It depends on various imported resolvers (e.g., BigIntResolver, JSONResolver), and expects context containing currentUser. On query, it exposes version info and access to the current user based on the provided context. Requires TypeScript support and related scalar resolver imports, with integration into the server's main resolver map.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\nexport const resolvers: Resolvers = {\n  BigInt: BigIntResolver,\n  Date: DateResolver,\n  Time: TimeResolver,\n  DateTime: DateTimeResolver,\n  JSON: JSONResolver,\n  JSONObject: JSONObjectResolver,\n  Query: {\n    redwood: () => ({\n      version: redwoodVersion,\n      prismaVersion: prismaVersion,\n      currentUser: (_args: any, context: GlobalContext) => {\n        return context?.currentUser\n      },\n    }),\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Validating and Creating Contact Entries in RedwoodJS Service - TypeScript\nDESCRIPTION: This snippet defines the createContact mutation resolver in a RedwoodJS TypeScript service file. It imports typed resolvers and the validate function to ensure the input's email is in a valid format before saving it to the database. The mutation expects input conforming to the relevant GraphQL types, leverages TypeScript for type safety, and depends on @redwoodjs/api and the local db client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_24\n\nLANGUAGE: ts\nCODE:\n```\nimport type { QueryResolvers, MutationResolvers } from 'types/graphql'\\n\\n// highlight-next-line\\nimport { validate } from '@redwoodjs/api'\\n\\n// ...\\n\\nexport const createContact: MutationResolvers['createContact'] = ({\\n  input,\\n}) => {\\n  // highlight-next-line\\n  validate(input.email, 'email', { email: true })\\n  return db.contact.create({ data: input })\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Handler with AuthDecoder in RedwoodJS (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure the GraphQL API handler in a RedwoodJS application by importing and supplying 'authDecoder' and 'getCurrentUser' for authentication. It sets up the handler with other standard dependencies like directives, SDLS, services, logger, and manages database disconnection on exception. This setup is essential for verifying and decoding JWT tokens included in web-side GraphQL requests and mapping them to user objects. Required dependencies include @redwoodjs/auth-auth0-api, @redwoodjs/graphql-server, database and logging libraries, and local authentication logic. Input is a standard GraphQL HTTP request bearing a JWT; output is the resolved GraphQL response with authorization enforced. All configuration is performed in 'api/src/functions/graphql.ts'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/authentication.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// highlight-next-line\nimport { authDecoder } from '@redwoodjs/auth-auth0-api'\nimport { createGraphQLHandler } from '@redwoodjs/graphql-server'\n\nimport directives from 'src/directives/**/*.{js,ts}'\nimport sdls from 'src/graphql/**/*.sdl.{js,ts}'\nimport services from 'src/services/**/*.{js,ts}'\n\n// highlight-next-line\nimport { getCurrentUser } from 'src/lib/auth'\nimport { db } from 'src/lib/db'\nimport { logger } from 'src/lib/logger'\n\nexport const handler = createGraphQLHandler({\n  // highlight-start\n  authDecoder,\n  getCurrentUser,\n  // highlight-end\n  loggerConfig: { logger, options: {} },\n  directives,\n  sdls,\n  services,\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Contact Creation Mutation with RedWoodJS (TypeScript, TSX)\nDESCRIPTION: This snippet defines the CreateContactMutation with TypeScript, including form value types. The CREATE_CONTACT constant holds the GraphQL mutation for contact creation, matching the server's SDL. Dependencies are RedwoodJS, TypeScript, and the backend GraphQL schema. The form expects name, email, and message fields; validation ensures required fields and email format. Exports the ContactPage component for usage.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\n// highlight-start\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n// highlight-end\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Restricting Private Routes by Single Role in RedwoodJS - JSX\nDESCRIPTION: This code shows the use of PrivateSet with a 'roles' prop to restrict certain routes to users with a specific role (e.g., 'admin'). If the current user lacks the required role or is not authenticated, they are redirected to the forbidden page. The code also includes a forbidden route and assumes the use of roles-based access logic. Dependencies include useAuth, PrivateSet, and the relevant page components.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n<Router useAuth={useAuth}>\n  <PrivateSet unauthenticated=\"forbidden\" roles=\"admin\">\n    <Route path=\"/admin/users\" page={UsersPage} name=\"users\" />\n  </PrivateSet>\n\n  <Route path=\"/forbidden\" page={ForbiddenPage} name=\"forbidden\" />\n</Router>\n```\n\n----------------------------------------\n\nTITLE: Complete RedwoodJS ContactPage with useForm Reset (JS)\nDESCRIPTION: Provides the full source code for the `ContactPage` component in JavaScript (`.jsx`). It integrates imports (`useForm`, `useMutation`, etc.), `useForm` initialization, passing `formMethods` to `<Form>`, form submission logic using `useMutation`, input fields with validation, and form reset on completion using `formMethods.reset()`. Includes standard RedwoodJS setup with Metadata, Toaster, and GraphQL mutation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_41\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport { toast, Toaster } from '@redwoodjs/web/toast'\nimport {\n  FieldError,\n  Form,\n  FormError,\n  Label,\n  Submit,\n  TextAreaField,\n  TextField,\n  useForm,\n} from '@redwoodjs/forms'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\nconst ContactPage = () => {\n  const formMethods = useForm()\n\n  const [create, { loading, error }] = useMutation(CREATE_CONTACT, {\n    onCompleted: () => {\n      toast.success('Thank you for your submission!')\n      formMethods.reset()\n    },\n  })\n\n  const onSubmit = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Toaster />\n      <Form\n        onSubmit={onSubmit}\n        config={{ mode: 'onBlur' }}\n        error={error}\n        formMethods={formMethods}\n      >\n        <FormError error={error} wrapperClassName=\"form-error\" />\n\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit disabled={loading}>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Using useMutation Hook with Types in RedwoodJS Contact Page (TSX)\nDESCRIPTION: This TypeScript snippet demonstrates using the `useMutation` hook from RedwoodJS within `ContactPage.tsx`. It imports `useMutation`, the generated GraphQL types (`CreateContactMutation`, `CreateContactMutationVariables`), and calls the hook with the `CREATE_CONTACT` constant, providing the imported types as generic arguments for type safety. The hook returns the `create` function typed according to the mutation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\n// highlight-next-line\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\n// highlight-start\nimport {\n  CreateContactMutation,\n  CreateContactMutationVariables,\n} from 'types/graphql'\n// highlight-end\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  // highlight-start\n  const [create] = useMutation<\n    CreateContactMutation,\n    CreateContactMutationVariables\n  >(CREATE_CONTACT)\n  // highlight-end\n\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Admin-Only Post Services with User Ownership - JavaScript\nDESCRIPTION: This service restricts all post queries and mutations to posts owned by the currently authenticated user (context.currentUser.id) within an admin context. It implements adminPosts and adminPost using Prisma's findMany and findFirst (instead of findUnique, to allow non-unique userId) and creates, updates, or deletes posts by attaching userId from the context. Key inputs are post id and input object; outputs are Post model records. Assumes RedwoodJS context and Prisma setup, with all code meant for use with admin-specific GraphQL queries.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const adminPosts = () => {\n  return db.post.findMany({ where: { userId: context.currentUser.id } })\n}\n\nexport const adminPost = ({ id }) => {\n  return db.post.findFirst({\n    where: { id, userId: context.currentUser.id },\n  })\n}\n\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    data: { ...input, userId: context.currentUser.id },\n  })\n}\n\nexport const updatePost = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost = ({ id }) => {\n  return db.post.delete({\n    where: { id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Signup Page with RedwoodJS CLI (Bash)\nDESCRIPTION: This command utilizes the RedwoodJS CLI (`yarn redwood generate page`) to scaffold a new page component named `SignupPage` and automatically adds a corresponding route (`/signup`) to the application's `Routes.[js/tsx]` file. It simplifies the initial setup for creating a new page view within a RedwoodJS project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate page signup\n```\n\n----------------------------------------\n\nTITLE: Default API Authentication Helpers in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript code shows the default implementation of authentication helper functions in `api/src/lib/auth.ts`, with type annotations. It includes `getCurrentUser`, which retrieves the user based on the session ID (initially selecting only the `id`), `isAuthenticated` to check login status, `hasRole` for role-based access control, and `requireAuth` to enforce authentication and roles, throwing errors if checks fail. Dependencies include `@redwoodjs/graphql-server` for error types, `./db` for the Prisma client, and `@redwoodjs/api` for types like `DbAuthSession`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/lib/auth.ts\"\nimport { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\nimport { db } from './db'\n\nimport type { DbAuthSession } from '@redwoodjs/api'\n\nexport const getCurrentUser = async (session: DbAuthSession<number>) => {\n  return await db.user.findUnique({\n    where: { id: session.id },\n    select: { id: true },\n  })\n}\n\nexport const isAuthenticated = (): boolean => {\n  return !!context.currentUser\n}\n\ntype AllowedRoles = string | string[] | undefined\n\nexport const hasRole = (roles: AllowedRoles): boolean => {\n  if (!isAuthenticated()) {\n    return false\n  }\n\n  const currentUserRoles = context.currentUser?.roles\n\n  if (typeof roles === 'string') {\n    if (typeof currentUserRoles === 'string') {\n      // roles to check is a string, currentUser.roles is a string\n      return currentUserRoles === roles\n    } else if (Array.isArray(currentUserRoles)) {\n      // roles to check is a string, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) => roles === allowedRole)\n    }\n  }\n\n  if (Array.isArray(roles)) {\n    if (Array.isArray(currentUserRoles)) {\n      // roles to check is an array, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) =>\n        roles.includes(allowedRole)\n      )\n    } else if (typeof currentUserRoles === 'string') {\n      // roles to check is an array, currentUser.roles is a string\n      return roles.some((allowedRole) => currentUserRoles === allowedRole)\n    }\n  }\n\n  // roles not found\n  return false\n}\n\nexport const requireAuth = ({ roles }: { roles?: AllowedRoles } = {}) => {\n  if (!isAuthenticated()) {\n    throw new AuthenticationError(\"You don't have permission to do that.\")\n  }\n\n  if (roles && !hasRole(roles)) {\n    throw new ForbiddenError(\"You don't have access to do that.\")\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Paginated Blog Posts GraphQL Query - RedwoodJS Cell - JavaScript\nDESCRIPTION: Defines a GraphQL query in a RedwoodJS Cell for fetching a page of blog posts and the total count for rendering. The query accepts a variable 'page', retrieves posts with id, title, body, createdAt, and post count, designed for frontend consumption. Requires RedwoodJS web setup and expects the API side to define the matching query schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query BlogPostsQuery($page: Int) {\n    postPage(page: $page) {\n      posts {\n        id\n        title\n        body\n        createdAt\n      }\n      count\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Configuring Login and Signup Routes - RedwoodJS - JavaScript\nDESCRIPTION: This React/JavaScript snippet demonstrates how to update the main Routes file in RedwoodJS to route the /login and /signup paths to the new LoginPasswordlessPage and SignupPage components. By including these <Route> entries inside the Router component and using the useAuth context, authentication-aware navigation is enabled. Prerequisites: previously created page components and registered useAuth provider. Inputs: URL path; outputs: serves the correct authentication page.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nconst Routes = () => {\n  // other stuff\n  return (\n    <Router useAuth={useAuth}>\n      <Route path=\"/login\" page={LoginPasswordlessPage} name=\"login\" />\n      <Route path=\"/signup\" page={SignupPage} name=\"signup\" />\n      {/*other routes*/}\n    </Router>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Expose User Roles in Authentication Logic - JavaScript\nDESCRIPTION: Modifies the getCurrentUser function to include the roles property when querying the current user. Ensures the frontend receives role information for access control checks. Dependencies: Prisma client, db context. Returns an object with id, email, and roles for the current session. Throws an error if the session is invalid.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport const getCurrentUser = async (session) => {\n  if (!session || typeof session.id !== 'number') {\n    throw new Error('Invalid session')\n  }\n\n  return await db.user.findUnique({\n    where: { id: session.id },\n    // highlight-next-line\n    select: { id: true, email: true, roles: true },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Realistic Prisma Scenario Data for Redwood Services - TypeScript\nDESCRIPTION: Demonstrates defining detailed and realistic scenario data for comments in TypeScript, complete with type safety using Prisma models. Seeds Jane and John Doe's comments with nested associated posts, mirroring expected real data structures. Dependencies: RedwoodJS, Prisma (with TypeScript types), defineScenario. Key details: structured string fields mapping real use cases, post linkage, automatic id/createdAt. Inputs: none; Outputs: comprehensive scenario data for use in TypeScript-based RedwoodJS tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_27\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Prisma } from '@prisma/client'\\n\\nexport const standard = defineScenario<Prisma.CommentCreateArgs>({\\n  comment: {\\n    // highlight-start\\n    jane: {\\n      data: {\\n        name: 'Jane Doe',\\n        body: 'I like trees',\\n        post: {\\n          create: {\\n            title: 'Redwood Leaves',\\n            body: 'The quick brown fox jumped over the lazy dog.',\\n          },\\n        },\\n      },\\n    },\\n    john: {\\n      data: {\\n        name: 'John Doe',\\n        body: 'Hug a tree today',\\n        post: {\\n          create: {\\n            title: 'Root Systems',\\n            body: 'The five boxing wizards jump quickly.',\\n          },\\n        },\\n      },\\n    },\\n    // highlight-end\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Importing RedwoodJS Service Validation Utilities (JavaScript/JSX)\nDESCRIPTION: Shows how to import the three primary RedwoodJS validation utilities: validate, validateWith, and validateUniqueness from '@redwoodjs/api'. Required for utilizing built-in business logic validation functions within Redwood's API (service) context. These should be imported at the top of service files and are necessary when performing business logic validation on incoming data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\nimport { validate, validateWith, validateUniqueness } from '@redwoodjs/api'\n```\n\n----------------------------------------\n\nTITLE: Implementing RedwoodJS Comment Form with useMutation (JS/TS)\nDESCRIPTION: React component (`CommentForm`) for submitting comments using RedwoodJS. It defines the `CreateCommentMutation` GraphQL mutation, utilizes the `useMutation` hook for execution, handles the form's `onSubmit` event, and incorporates `FormError` for displaying errors. Dependencies include `@redwoodjs/forms` and `@redwoodjs/web`. The component takes no props and manages its own state related to the mutation (loading, error). The TSX version adds type safety with GraphQL types and a `FormValues` interface.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/CommentForm/CommentForm.jsx\"\nimport {\n  Form,\n  // highlight-next-line\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n// highlight-next-line\nimport { useMutation } from '@redwoodjs/web'\n\n// highlight-start\nconst CREATE = gql`\n  mutation CreateCommentMutation($input: CreateCommentInput!) {\n    createComment(input: $input) {\n      id\n      name\n      body\n      createdAt\n    }\n  }\n`\n// highlight-end\n\nconst CommentForm = () => {\n  // highlight-next-line\n  const [createComment, { loading, error }] = useMutation(CREATE)\n\n  // highlight-start\n  const onSubmit = (input) => {\n    createComment({ variables: { input } })\n  }\n  // highlight-end\n\n  return (\n    <div>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      // highlight-start\n      <Form className=\"mt-4 w-full\" onSubmit={onSubmit}>\n        <FormError\n          error={error}\n          titleClassName=\"font-semibold\"\n          wrapperClassName=\"bg-red-100 text-red-900 text-sm p-3 rounded\"\n        />\n        // highlight-end\n        <Label\n          name=\"name\"\n          className=\"block text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-sm \"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-sm\"\n          validation={{ required: true }}\n        />\n\n        <Submit\n          // highlight-next-line\n          disabled={loading}\n          className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\"\n        >\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n```\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/CommentForm/CommentForm.tsx\"\n// highlight-start\nimport type {\n  CreateCommentMutation,\n  CreateCommentMutationVariables,\n} from 'types/graphql'\n// highlight-end\n\nimport {\n  Form,\n  // highlight-next-line\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  // highlight-next-line\n  SubmitHandler,\n} from '@redwoodjs/forms'\n// highlight-start\nimport type { TypedDocumentNode } from '@redwoodjs/web'\nimport { useMutation } from '@redwoodjs/web'\n// highlight-end\n\n// highlight-start\nconst CREATE: TypedDocumentNode<\n  CreateCommentMutation,\n  CreateCommentMutationVariables\n> = gql`\n  mutation CreateCommentMutation($input: CreateCommentInput!) {\n    createComment(input: $input) {\n      id\n      name\n      body\n      createdAt\n    }\n  }\n`\n// highlight-end\n\n// highlight-start\ninterface FormValues {\n  name: string\n  comment: string\n}\n// highlight-end\n\nconst CommentForm = () => {\n  // highlight-next-line\n  const [createComment, { loading, error }] = useMutation(CREATE)\n\n  // highlight-start\n  const onSubmit: SubmitHandler<FormValues> = (input) => {\n    createComment({ variables: { input } })\n  }\n  // highlight-end\n\n  return (\n    <div>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      // highlight-start\n      <Form className=\"mt-4 w-full\" onSubmit={onSubmit}>\n        <FormError\n          error={error}\n          titleClassName=\"font-semibold\"\n          wrapperClassName=\"bg-red-100 text-red-900 text-sm p-3 rounded\"\n        />\n        // highlight-end\n\n        <Label\n          name=\"name\"\n          className=\"block text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-sm \"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-sm\"\n          validation={{ required: true }}\n        />\n\n        <Submit\n          // highlight-next-line\n          disabled={loading}\n          className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\"\n        >\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Contact Form with FormError (RedwoodJS, JSX)\nDESCRIPTION: Demonstrates integrating RedwoodJS's <FormError> component for displaying server-side validation errors in a create contact form using GraphQL and the useMutation hook. This snippet covers setting up a mutation, handling errors via the 'error' object, and rendering field components along with the form error display. Requires '@redwoodjs/web', a GraphQL backend, and assumes React/RedwoodJS project context. Inputs are accepted via a <TextField> with no client-side validation, letting server validation surface through <FormError>.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useMutation } from '@redwoodjs/web'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: ContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\nconst ContactPage = () => {\n  const [create, { loading, error }] = useMutation(CREATE_CONTACT)\n\n  const onSubmit = (data) => {\n    create({ variables: { input: data }})\n  }\n\n  return (\n    <Form onSubmit={onSubmit}>\n      <FormError error={error}>\n      // No validation—any email goes!\n      <TextField name=\"email\" />\n    </Form>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Refetching GraphQL Queries After Mutation in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript snippet provides similar functionality as the JavaScript version but includes type annotations for the props and mutation types. It utilizes the refetchQueries option in useMutation to ensure the comments list updates after a mutation. Required dependencies are @redwoodjs/forms, @redwoodjs/web, TypeScript types, and the relevant GraphQL definitions. The CommentForm component receives a typed postId prop, and after create, it refetches the comments query. It takes mutation input variables and updates the state and UI accordingly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Form,\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\nimport { useMutation } from '@redwoodjs/web'\n\n// highlight-next-line\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n\n// ...\n\nconst CommentForm = ({ postId }: Props) => {\n  // highlight-start\n  const [createComment, { loading, error }] = useMutation(CREATE, {\n    refetchQueries: [{ query: CommentsQuery }],\n  })\n  // highlight-end\n\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Nulls with removeNulls in RedwoodJS Services (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates using the `removeNulls` utility function from `@redwoodjs/api` within a service mutation resolver (`updateUser`). It converts potential `null` values in the input object to `undefined` before passing the data to Prisma's `update` method, aligning with Prisma's expectation that `undefined` means 'do not update' while `null` explicitly sets the value to null.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// highlight-next-line\nimport { removeNulls } from '@redwoodjs/api'\n\nexport const updateUser: MutationResolvers['updateUser'] = ({ id, input }) => {\n  return db.user.update({\n    // highlight-next-line\n    data: removeNulls(input),\n    where: { id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS GraphQL Handler with Custom Directives (TypeScript/TSX)\nDESCRIPTION: Shows an example of initializing and exporting a RedwoodJS GraphQL handler with custom configuration, including directive imports, SDLs, services, custom logger and security configuration, plus a database disconnection callback for unhandled exceptions. This snippet depends on @redwoodjs/graphql-server's createGraphQLHandler as well as local imports for directives, services, SDLs, database access, and logger. Required parameters to the handler include loggerConfig, armorConfig, directives, sdls, and services; the onException function is used to gracefully disconnect from the database. Inputs are established via glob imports and config objects, and the exported handler is used as an API endpoint for GraphQL operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_40\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createGraphQLHandler } from '@redwoodjs/graphql-server'\n\nimport directives from 'src/directives/**/*.{js,ts}' // 👈 directives live here\nimport sdls from 'src/graphql/**/*.sdl.{js,ts}'\nimport services from 'src/services/**/*.{js,ts}'\n\nimport { db } from 'src/lib/db'\nimport { logger } from 'src/lib/logger'\n\nexport const handler = createGraphQLHandler({\n  loggerConfig: { logger, options: {} },\n  armorConfig, //  👈 custom GraphQL Security configuration\n  directives, //  👈 directives are added to the schema here\n  sdls,\n  services,\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Performing Basic CRUD Operations with RedwoodRecord (JavaScript/JSX)\nDESCRIPTION: Example JavaScript/JSX code showing common database operations using a RedwoodRecord model (`User`): finding all records (`all`), creating a new record (`create`), updating an attribute and saving (`save`), finding by primary key (`find`), finding by attribute (`findBy`), and deleting a record (`destroy`). These are asynchronous methods interacting with the database via Prisma.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nawait User.all()\nconst newUser = await User.create({ name: 'Rob', email: 'rob@redwoodjs.com' })\nnewUser.name = 'Robert'\nawait newUser.save()\nawait User.find(1)\nawait User.findBy({ email: 'rob@redwoodjs.com' })\nawait newUser.destroy()\n```\n\n----------------------------------------\n\nTITLE: Using useMutation Hook with Type Safety and Generated Types (TypeScript, TSX)\nDESCRIPTION: This snippet shows the usage of RedwoodJS's useMutation with TypeScript generics, utilizing generated types for increased type safety. The create function is typed using CreateContactMutation and CreateContactMutationVariables, automatically generated by RedwoodJS. Form values are strictly typed, and mutation results are easier to reason about. Required dependencies include RedwoodJS, TypeScript, and the generated GraphQL types. The expected input aligns with GraphQL schema for creating a contact.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\n// highlight-start\nimport {\n  CreateContactMutation,\n  CreateContactMutationVariables,\n} from 'types/graphql'\n// highlight-end\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  // highlight-start\n  const [create] = useMutation<\n    CreateContactMutation,\n    CreateContactMutationVariables\n  >(CREATE_CONTACT)\n  // highlight-end\n\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Options in redwood.toml - TOML\nDESCRIPTION: Demonstrates a baseline configuration for a RedwoodJS app using the redwood.toml file. Sets options for web, api, browser, and notifications sections, defining ports, URLs, and UI flags. No external dependencies are required, but values such as ports and URLs must match your deployment context. This snippet serves as the default starting state after initializing a RedwoodJS project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n  title = \"Redwood App\"\n  port = 8910\n  apiUrl = \"/.redwood/functions\"\n  includeEnvironmentVariables = []\n[api]\n  port = 8911\n[browser]\n  open = true\n[notifications]\n  versionUpdates = [\"latest\"]\n```\n\n----------------------------------------\n\nTITLE: Creating a RedwoodJS App - Bash\nDESCRIPTION: Initializes a new RedwoodJS application named 'uploader' and navigates into its directory. Requires Node.js, Yarn, and the RedwoodJS CLI installed globally. These commands set up the project structure and dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn create redwood-app uploader\\ncd uploader\n```\n\n----------------------------------------\n\nTITLE: Defining a New Contact Data Model in Prisma Schema - JavaScript\nDESCRIPTION: This snippet shows how to extend a Prisma schema file by adding a new Contact model for storing contact form submissions, including fields like id, name, email, message, and createdAt, each with type definitions and constraints. Dependencies include the Prisma ORM, a configured datasource (sqlite in this example), and the Prisma client generator. The expected input is the schema.prisma file, and the output is an updated schema ready for migration. Key parameters include type definitions and default values; limitations stem from the defined field types and constraints.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = \"native\"\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  body      String\n  createdAt DateTime @default(now())\n}\n\n// highlight-start\nmodel Contact {\n  id        Int      @id @default(autoincrement())\n  name      String\n  email     String\n  message   String\n  createdAt DateTime @default(now())\n}\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Creating a New RedwoodJS Project using Yarn\nDESCRIPTION: This command uses Yarn to execute the `create-redwood-app` package, scaffolding a new RedwoodJS application (referred to as a 'Project') in the specified directory. Replace `<path-to-directory>` with the desired project path. This is the standard method for initiating a new Redwood application development.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/contributing-walkthrough.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn create redwood-app <path-to-directory>\n```\n\n----------------------------------------\n\nTITLE: Creating a New RedwoodJS TypeScript Project (bash)\nDESCRIPTION: This snippet initializes a new RedwoodJS project using Yarn, specifying TypeScript with the --ts flag. The command scaffolds an opinionated monorepo ready for RedwoodJS development. Required: Yarn must be installed; omitting --ts will create a JavaScript-based project instead.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn create redwood-app my-project --ts\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Component via CLI - Bash\nDESCRIPTION: This command uses RedwoodJS's CLI to scaffold a new component called CommentForm. It creates boilerplate files required for a new React component in the RedwoodJS project structure. The only requirement is that the project has RedwoodJS and its CLI installed; it outputs the necessary files under the specified path.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g component CommentForm\n```\n\n----------------------------------------\n\nTITLE: Invoking the GraphQL Mutation Function in JavaScript\nDESCRIPTION: This JavaScript snippet shows an example of how to call the `create` function returned by the `useMutation` hook. It requires an object with a `variables` key, which in turn contains an `input` key holding the data (name, email, message) to be sent with the GraphQL mutation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n```js\ncreate({\n  variables: {\n    input: {\n      name: 'Rob',\n      email: 'rob@redwoodjs.com',\n      message: 'I love Redwood!',\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Updating TypeScript Comments Service Implementation\nDESCRIPTION: Modifies the `comments` service function in TypeScript (`comments.ts`). It adds a `postId` parameter with Prisma types (`Required<Pick<Prisma.CommentWhereInput, 'postId'>>`) and uses it in the `where` clause of `db.comment.findMany` to retrieve comments for a specific post.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/services/comments/comments.ts\"\nexport const comments = ({\n  postId,\n}: Required<Pick<Prisma.CommentWhereInput, 'postId'>>) => {\n  return db.comment.findMany({ where: { postId } })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Boilerplate RedwoodJS ArticlesCell Component (JavaScript/JSX)\nDESCRIPTION: This is the initial boilerplate code generated for the `ArticlesCell` in JavaScript (JSX) using `yarn rw g cell Articles`. It defines a GraphQL query (`QUERY`) to fetch data, and exports components for different states: `Loading`, `Empty`, `Failure`, and `Success`. The `Success` component receives the fetched data (initially expected as `articles` based on the cell name) and renders it, here stringifying each item.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticlesCell/ArticlesCell.jsx\"\nexport const QUERY = gql`\n  query ArticlesQuery {\n    articles {\n      id\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({ articles }) => {\n  return (\n    <ul>\n      {articles.map((item) => {\n        return <li key={item.id}>{JSON.stringify(item)}</li>\n      })}\n    </ul>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Checks in RedwoodJS auth.ts TypeScript\nDESCRIPTION: Presents the structure of the `api/src/lib/auth.ts` file, showing placeholder implementations for `isAuthenticated` and `requireAuth`. The `requireAuth` function checks authentication status (via `isAuthenticated`) and role membership (via `hasRole`), throwing `AuthenticationError` or `ForbiddenError` if checks fail. This function is invoked by the `@requireAuth` directive in the GraphQL schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_56\n\nLANGUAGE: ts\nCODE:\n```\n// ...\n\nexport const isAuthenticated = (): boolean => {\n  return true // 👈 replace with the appropriate check\n}\n\n// ...\n\nexport const requireAuth = ({ roles }: { roles: AllowedRoles }) => {\n  if (isAuthenticated()) {\n    throw new AuthenticationError(\"You don't have permission to do that.\")\n  }\n\n  if (!hasRole({ roles })) {\n    throw new ForbiddenError(\"You don't have access to do that.\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing getCurrentUser and Auth Helpers in Redwood API - TypeScript\nDESCRIPTION: This backend API snippet provides TypeScript implementations for getCurrentUser, isAuthenticated, hasRole, and requireAuth in RedwoodJS authentication routines. getCurrentUser accepts a DbAuthSession and fetches user data from the database, returning only the user's id; additional fields can be added as necessary. Includes proper type annotations and error handling for authentication/authorization. Requires @redwoodjs/graphql-server, Prisma database, @redwoodjs/api's DbAuthSession type, and correct typings for currentUser on the context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\nimport { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\\nimport { db } from './db'\\n\\nimport type { DbAuthSession } from '@redwoodjs/api'\\n\\nexport const getCurrentUser = async (session: DbAuthSession<number>) => {\\n  return await db.user.findUnique({\\n    where: { id: session.id },\\n    select: { id: true },\\n  })\\n}\\n\\nexport const isAuthenticated = (): boolean => {\\n  return !!context.currentUser\\n}\\n\\ntype AllowedRoles = string | string[] | undefined\\n\\nexport const hasRole = (roles: AllowedRoles): boolean => {\\n  if (!isAuthenticated()) {\\n    return false\\n  }\\n\\n  const currentUserRoles = context.currentUser?.roles\\n\\n  if (typeof roles === 'string') {\\n    if (typeof currentUserRoles === 'string') {\\n      // roles to check is a string, currentUser.roles is a string\\n      return currentUserRoles === roles\\n    } else if (Array.isArray(currentUserRoles)) {\\n      // roles to check is a string, currentUser.roles is an array\\n      return currentUserRoles?.some((allowedRole) => roles === allowedRole)\\n    }\\n  }\\n\\n  if (Array.isArray(roles)) {\\n    if (Array.isArray(currentUserRoles)) {\\n      // roles to check is an array, currentUser.roles is an array\\n      return currentUserRoles?.some((allowedRole) =>\\n        roles.includes(allowedRole)\\n      )\\n    } else if (typeof currentUserRoles === 'string') {\\n      // roles to check is an array, currentUser.roles is a string\\n      return roles.some((allowedRole) => currentUserRoles === allowedRole)\\n    }\\n  }\\n\\n  // roles not found\\n  return false\\n}\\n\\nexport const requireAuth = ({ roles }: { roles?: AllowedRoles } = {}) => {\\n  if (!isAuthenticated()) {\\n    throw new AuthenticationError(\"You don't have permission to do that.\")\\n  }\\n\\n  if (roles && !hasRole(roles)) {\\n    throw new ForbiddenError(\"You don't have access to do that.\")\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Netlify Webhooks using JWT Verifier in RedwoodJS (TypeScript)\nDESCRIPTION: This AWS Lambda handler function demonstrates verifying incoming Netlify webhooks using the `jwtVerifier` from `@redwoodjs/api/webhooks`. It configures `VerifyOptions` to specify the signature header (`X-Webhook-Signature`) and the required JWT issuer (`netlify`). Verification uses a secret stored in `process.env.NETLIFY_DEPLOY_WEBHOOK_SECRET`. The function logs events using `logger`, parses the JSON payload upon successful verification, and handles potential `WebhookVerificationError` or other exceptions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\nimport type { APIGatewayEvent } from 'aws-lambda'\nimport {\n  verifyEvent,\n  VerifyOptions,\n  WebhookVerificationError,\n} from '@redwoodjs/api/webhooks'\n\nimport { logger } from 'src/lib/logger'\n\n/**\n * The handler function is your code that processes http request events.\n * You can use return and throw to send a response or error, respectively.\n *\n * @typedef { import('aws-lambda').APIGatewayEvent } APIGatewayEvent\n * @typedef { import('aws-lambda').Context } Context\n * @param { APIGatewayEvent } event - an object which contains information from the invoker.\n * @param { Context } context - contains information about the invocation,\n * function, and execution environment.\n */\nexport const handler = async (event: APIGatewayEvent) => {\n  const netlifyInfo = {\n    webhook: 'verifyNetlifyWebhook',\n    headers: event.headers['x-netlify-event'],\n  }\n  const webhookLogger = logger.child({ netlifyInfo })\n\n  try {\n    webhookLogger.debug('Received Netlify event')\n\n    const options = {\n      signatureHeader: 'X-Webhook-Signature',\n      issuer: 'netlify',\n    } as VerifyOptions\n\n    verifyEvent('jwtVerifier', {\n      event,\n      secret: process.env.NETLIFY_DEPLOY_WEBHOOK_SECRET,\n      options,\n    })\n    const payload = JSON.parse(event.body)\n\n    // Safely use the validated webhook payload\n\n    webhookLogger.debug({ payload }, 'Now I can do things with the payload')\n\n    return {\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      statusCode: 200,\n      body: JSON.stringify({\n        data: payload,\n      }),\n    }\n  } catch (error) {\n    if (error instanceof WebhookVerificationError) {\n      webhookLogger.warn('Unauthorized')\n      return {\n        statusCode: 401,\n      }\n    } else {\n      webhookLogger.error({ error }, error.message)\n      return {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        statusCode: 500,\n        body: JSON.stringify({\n          error: error.message,\n        }),\n      }\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL SDL for Anonymous Contact Creation Mutation (RedwoodJS, TypeScript)\nDESCRIPTION: This TypeScript SDL snippet presents a pared-down schema for the Contact entity, limiting mutations to unauthenticated creation only by using the @skipAuth directive with createContact. It defines only the necessary input type and omits update/delete mutation types for enhanced security, in accordance with RedwoodJS conventions. This schema is suitable for public-facing forms and is paired with service resolvers for backend logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\\n  type Contact {\\n    id: Int!\\n    name: String!\\n    email: String!\\n    message: String!\\n    createdAt: DateTime!\\n  }\\n\\n  type Query {\\n    contacts: [Contact!]! @requireAuth\\n    contact(id: Int!): Contact @requireAuth\\n  }\\n\\n  input CreateContactInput {\\n    name: String!\\n    email: String!\\n    message: String!\\n  }\\n\\n  // highlight-start\\n  type Mutation {\\n    createContact(input: CreateContactInput!): Contact! @skipAuth\\n  }\\n  // highlight-end\\n`\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Mock Data for RedwoodJS Cell (JS/TS)\nDESCRIPTION: This code defines a standard mock function that returns sample data for the `articles` query. This data is used in tests and Storybook stories to simulate the successful response from the GraphQL API without needing a running server or database. The returned object has a key (`articles`) matching the prop expected by the `Success` component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nexport const standard = () => ({\n  articles: [\n    {\n      id: 1,\n      title: 'First Post',\n      body: `Neutra tacos hot chicken prism raw denim...`,\n      createdAt: '2020-01-01T12:34:56Z',\n    },\n    {\n      id: 2,\n      title: 'Second Post',\n      body: `Master cleanse gentrify irony put a bird on it...`,\n      createdAt: '2020-01-01T12:34:56Z',\n    },\n  ],\n})\n```\n```\n\nLANGUAGE: typescript\nCODE:\n```\n```javascript\nexport const standard = () => ({\n  articles: [\n    {\n      id: 1,\n      title: 'First Post',\n      body: `Neutra tacos hot chicken prism raw denim...`,\n      createdAt: '2020-01-01T12:34:56Z',\n    },\n    {\n      id: 2,\n      title: 'Second Post',\n      body: `Master cleanse gentrify irony put a bird on it...`,\n      createdAt: '2020-01-01T12:34:56Z',\n    },\n  ],\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL SDL for Contact Resource with Auth Directives (RedwoodJS, TypeScript)\nDESCRIPTION: This TypeScript code snippet provides the SDL for the Contact model, mirroring the JavaScript version but targeting TypeScript environments. The schema uses @requireAuth directives and includes all required input/output types for full CRUD on contacts. This definition is consumed automatically by RedwoodJS and mapped to service resolvers based on naming conventions. Dependencies include RedwoodJS's gql and GraphQL tooling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\\n  type Contact {\\n    id: Int!\\n    name: String!\\n    email: String!\\n    message: String!\\n    createdAt: DateTime!\\n  }\\n\\n  type Query {\\n    contacts: [Contact!]! @requireAuth\\n    contact(id: Int!): Contact @requireAuth\\n  }\\n\\n  input CreateContactInput {\\n    name: String!\\n    email: String!\\n    message: String!\\n  }\\n\\n  input UpdateContactInput {\\n    name: String\\n    email: String\\n    message: String\\n  }\\n\\n  type Mutation {\\n    createContact(input: CreateContactInput!): Contact! @requireAuth\\n    updateContact(id: Int!, input: UpdateContactInput!): Contact! @requireAuth\\n    deleteContact(id: Int!): Contact! @requireAuth\\n  }\\n`\n```\n\n----------------------------------------\n\nTITLE: Rendering HTML Output for FormError Scenario (HTML)\nDESCRIPTION: Shows the rendered HTML output when a RedwoodJS form, lacking client-side validation, fails GraphQL server validation and supplies an error message through <FormError>. This snippet illustrates the structure and style of the error message users would see, specifically highlighting invalid field formatting. No dependencies are required; this serves as a static illustration of produced output.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<div>\n  <p>Can't create new contact:</p>\n  <ul>\n    <li>email is not formatted like an email address</li>\n  </ul>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables in redwood.toml - TOML\nDESCRIPTION: This snippet demonstrates the use of environment variable interpolation in the redwood.toml configuration file for RedwoodJS. It shows how to set values like title, port, and apiUrl by interpolating them from environment variables with specified fallbacks. Required dependencies include a RedwoodJS project and a build process that recognizes this interpolation syntax. The inputs are environment variables (APP_TITLE, PORT, API_URL); outputs are substituted configuration values at build time. Only string fallbacks are supported and interpolation happens during the build.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_10\n\nLANGUAGE: TOML\nCODE:\n```\n[web]\n  // highlight-start\n  title = \"App running on ${APP_TITLE}\"\n  port = \"${PORT:8910}\"\n  apiUrl = \"${API_URL:/.redwood/functions}\"\n  // highlight-end\n  includeEnvironmentVariables = []\n```\n\n----------------------------------------\n\nTITLE: Implementing Sign Up Form with Auth Integration (RedwoodJS, JavaScript)\nDESCRIPTION: This SignupPage component renders a registration form using RedwoodJS forms, integrates authentication with the useAuth hook, and navigates the user to the sign-in page upon successful submission. It handles and displays errors returned during sign-up. Dependencies include '@redwoodjs/forms', '@redwoodjs/auth', '@redwoodjs/router', and the pre-existing GlobalLayout.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from '@redwoodjs/auth'\nimport { routes, navigate } from '@redwoodjs/router'\n\nimport GlobalLayout from 'src/layouts/GlobalLayout/GlobalLayout'\n\nconst SignupPage = () => {\n  const { client } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = (data) => {\n    setError(null)\n    client\n      .signup(data.email, data.password)\n      .then(() => navigate(routes.signin()))\n      .catch((error) => setError(error.message))\n  }\n\n  return (\n    <GlobalLayout>\n      <h1>Sign Up</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </GlobalLayout>\n  )\n}\n\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Protecting Routes with PrivateSet and Authentication in RedwoodJS - JSX\nDESCRIPTION: This example demonstrates using the PrivateSet component to restrict access to administrative routes based on user authentication status. The Router accepts a useAuth hook to determine authentication. When an unauthenticated user attempts to access the /admin route, they are redirected to the route named 'home'. This requires the useAuth function and appropriate route components to be available.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n<Router useAuth={useAuth}>\n  <Route path=\"/\" page={HomePage} name=\"home\" />\n  <PrivateSet unauthenticated=\"home\">\n    <Route path=\"/admin\" page={AdminPage} name=\"admin\" />\n  </PrivateSet>\n</Router>\n```\n\n----------------------------------------\n\nTITLE: Final AdminPosts Service with Ownership Verification\nDESCRIPTION: This snippet presents the complete `adminPosts.js` service file after implementing all CRUD operations with ownership verification. It includes the `verifyOwnership` helper function, functions to list all posts owned by the user (`adminPosts`), fetch a single owned post (`adminPost`), create a post associated with the user (`createPost`), and update (`updatePost`) and delete (`deletePost`) posts, both using the `verifyOwnership` check to ensure authorization.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ForbiddenError } from '@redwoodjs/graphql-server'\n\nimport { db } from 'src/lib/db'\n\nconst verifyOwnership = async ({ id }) => {\n  if (await adminPost({ id })) {\n    return true\n  } else {\n    throw new ForbiddenError(\"You don't have access to this post\")\n  }\n}\n\nexport const adminPosts = () => {\n  return db.post.findMany({ where: { userId: context.currentUser.id } })\n}\n\nexport const adminPost = ({ id }) => {\n  return db.post.findFirst({\n    where: { id, userId: context.currentUser.id },\n  })\n}\n\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    data: { ...input, userId: context.currentUser.id },\n  })\n}\n\nexport const updatePost = async ({ id, input }) => {\n  await verifyOwnership({ id })\n\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost = async ({ id }) => {\n  await verifyOwnership({ id })\n\n  return db.post.delete({\n    where: { id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration Object for Maximum Query Depth (GraphQL Armor, TypeScript)\nDESCRIPTION: Establishes the maxDepth plugin config structure for GraphQL Armor, with limiting enabled and maximum query depth set at 6. To be included as a field in armorConfig in RedwoodJS handler initialization. Used to prevent overly deep and resource-exhausting queries.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_68\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  maxDepth: {\n    enabled: true,\n    n: 6,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Introducing FieldError for Validation in RedwoodJS Contact Form (TSX)\nDESCRIPTION: This TSX snippet demonstrates the initial setup of a typed contact form page in RedwoodJS. It uses components from `@redwoodjs/forms` and defines a `FormValues` interface and uses `SubmitHandler` for type safety. It introduces the `<FieldError>` component to display validation messages for required fields, linking them via the `name` prop.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  // highlight-next-line\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"name\" />\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"email\" />\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"message\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Routes with Parameters - RedwoodJS - JSX\nDESCRIPTION: This set of snippets demonstrates how to define <Route> components with dynamic parameters in RedwoodJS. Parameterized routes enable matching and extraction of variable path segments, which are provided as props to page components. Dependencies: RedwoodJS Router. Required input is matching URL structure; outputs are route matches with extracted parameters sent to specified page components.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/user/{id}\" page={UserPage} name=\"user\" />\n```\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/blog/{year}/{month}/{day}/{slug}\" page={PostPage} name=\"post\" />\n```\n\nLANGUAGE: jsx\nCODE:\n```\nconst PostPage = ({ year, month, day, slug }) => { ... }\n```\n\n----------------------------------------\n\nTITLE: Exposing Create Comment Mutation in GraphQL SDL (JavaScript)\nDESCRIPTION: This GraphQL schema definition (SDL) snippet, intended for a JavaScript environment (`.sdl.js`), defines the necessary types for the comments API. It includes the `Comment` type, a `Query` to fetch comments (`@skipAuth` allows unauthenticated access), input types (`CreateCommentInput`, `UpdateCommentInput`), and adds a `Mutation` section. The `createComment` mutation accepts a non-null `CreateCommentInput` and returns the created `Comment`, also marked with `@skipAuth`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.js\"\nexport const schema = gql`\n  type Comment {\n    id: Int!\n    name: String!\n    body: String!\n    post: Post!\n    postId: Int!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    comments: [Comment!]! @skipAuth\n  }\n\n  input CreateCommentInput {\n    name: String!\n    body: String!\n    postId: Int!\n  }\n\n  input UpdateCommentInput {\n    name: String\n    body: String\n    postId: Int\n  }\n\n  // highlight-start\n  type Mutation {\n    createComment(input: CreateCommentInput!): Comment! @skipAuth\n  }\n  // highlight-end\n`\n```\n```\n\n----------------------------------------\n\nTITLE: Adding CORS Header to GraphQL Handler in RedwoodJS (JavaScript/TypeScript)\nDESCRIPTION: This snippet demonstrates how to add CORS headers to GraphQL responses in RedwoodJS by providing a 'cors' option with an 'origin' field to 'createGraphQLHandler'. The 'origin' parameter specifies which domains may make cross-origin requests to the API. Dependencies include RedwoodJS API functions and a deployed web domain. Input is a handler configuration object, output is an updated GraphQL handler enabling CORS for the designated domain. If multiple domains require access, an array of origins can be provided.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cors.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\nexport const handler = createGraphQLHandler({\\n  loggerConfig: { logger, options: {} },\\n  directives,\\n  sdls,\\n  services,\\n+ cors: {\\n+   origin: 'https://www.example.com', // <-- web side domain\\n+ },\\n  onException: () => {\\n    db.$disconnect()\\n  },\\n})\n```\n\nLANGUAGE: jsx\nCODE:\n```\ncors: {\\n  origin: ['https://example.com', 'https://www.example.com']\\n},\n```\n\n----------------------------------------\n\nTITLE: Using PrivateSet for Multi-Role Route Protection in RedwoodJS - JSX\nDESCRIPTION: This example expands PrivateSet usage to restrict access to a set of roles specified by an array (admin, editor, publisher). Only users with any of the specified roles, as well as authentication, can access the /admin/posts/{id:Int}/edit route. Unauthorized users are redirected to a forbidden page. Inputs include useAuth as the authentication provider, and routes must be defined accordingly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\n<Router useAuth={useAuth}>\n  <PrivateSet unauthenticated=\"forbidden\" roles={['admin', 'editor', 'publisher']}>\n    <Route path=\"/admin/posts/{id:Int}/edit\" page={EditPostPage} name=\"editPost\" />\n  </PrivateSet>\n\n  <Route path=\"/forbidden\" page={ForbiddenPage} name=\"forbidden\" />\n</Router>\n```\n\n----------------------------------------\n\nTITLE: Validating Single-Select Dropdown Input with React SelectField (JSX)\nDESCRIPTION: This snippet illustrates validation on a single-selection <SelectField> in a React form. The field enforces selection (required) and ensures the user does not select the initial placeholder option. A custom validate function returns an appropriate error message if validation fails. The <FieldError> component displays validation feedback. This pattern requires a validation-capable form library and expects string inputs, returning error messages as strings as needed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n<SelectField\n  name=\\\"selectSingle\\\"\n  validation={{\n    required: true,\n    validate: {\n      matchesInitialValue: (value) => {\n        return (\n          value !== 'Please select an option' ||\n          'Select an Option'\n        )\n      },\n    },\n  }}\n>\n  <option>Please select an option</option>\n  <option>Option 1</option>\n  <option>Option 2</option>\n</SelectField>\n<FieldError name=\\\"selectSingle\\\" style={{ color: 'red' }} />\n```\n\n----------------------------------------\n\nTITLE: Implementing Post Resolvers in RedwoodJS Service (TypeScript)\nDESCRIPTION: This TypeScript code provides the typed implementation (resolvers) for the GraphQL queries and mutations defined in `posts.sdl.ts`. Located in `api/src/services/posts/posts.ts`, it exports typed functions (`posts`, `post`, `createPost`, `updatePost`, `deletePost`) using generated types (`QueryResolvers`, `MutationResolvers`) for enhanced type safety. These functions interact with the database via Prisma Client (`db`) for CRUD operations. Redwood maps these service functions to the GraphQL schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/side-quest.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\nimport type { QueryResolvers, MutationResolvers } from 'types/graphql'\n\nexport const posts: QueryResolvers['posts'] = () => {\n  return db.post.findMany()\n}\n\nexport const post: QueryResolvers['post'] = ({ id }) => {\n  return db.post.findUnique({\n    where: { id },\n  })\n}\n\nexport const createPost: MutationResolvers['createPost'] = ({ input }) => {\n  return db.post.create({\n    data: input,\n  })\n}\n\nexport const updatePost: MutationResolvers['updatePost'] = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost: MutationResolvers['deletePost'] = ({ id }) => {\n  return db.post.delete({\n    where: { id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Job Workers with RedwoodJS JobManager in JavaScript\nDESCRIPTION: Illustrates creating a JobManager instance with multiple workers using the PrismaAdapter. Here, a single worker group is configured to spawn five worker threads on the default queue. This setup increases job processing concurrency by assigning multiple workers to the same queue and adapter. Required dependencies: JobManager, PrismaAdapter, db, logger. Inputs include adapter settings and worker options such as queue, count, maxAttempts, and others. Outputs are a configured JobManager instance ready to process jobs using specified settings.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_32\n\nLANGUAGE: js\nCODE:\n```\nexport const jobs = new JobManager({\n  adapters: {\n    prisma: new PrismaAdapter({ db, logger }),\n  },\n  queues: ['default'],\n  logger,\n  workers: [\n    {\n      adapter: 'prisma',\n      logger,\n      queue: '*',\n      // highlight-next-line\n      count: 5,\n      maxAttempts: 24,\n      maxRuntime: 14_400,\n      deleteFailedJobs: false,\n      sleepDelay: 5,\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema for Blog Posts with RedwoodJS in JavaScript\nDESCRIPTION: Defines the GraphQL schema for blog posts using RedwoodJS SDL in JavaScript, declaring the Post type, Query and Mutation operations, and input types. The SDL uses custom directives like @requireAuth for field-level authorization. This is placed in `api/src/graphql/posts.sdl.js` and expects corresponding resolver implementations in the services directory. Dependencies: RedwoodJS, gql tag. Input parameters include post ids and post fields, and output types aligned with the schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/side-quest.md#_snippet_0\n\nLANGUAGE: GraphQL\nCODE:\n```\nexport const schema = gql`\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    posts: [Post!]!\n    post(id: Int!): Post!\n  }\n\n  input CreatePostInput {\n    title: String!\n    body: String!\n  }\n\n  input UpdatePostInput {\n    title: String\n    body: String\n  }\n\n  type Mutation {\n    createPost(input: CreatePostInput!): Post! @requireAuth\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\n    deletePost(id: Int!): Post! @requireAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Protecting Routes with PrivateSet in RedwoodJS Router (TSX)\nDESCRIPTION: This TSX code illustrates how to use the 'PrivateSet' component within RedwoodJS's Router to restrict access to certain routes based on user authentication state. Unauthenticated users are redirected to the route specified by the 'unauthenticated' prop. This pattern is used in 'web/src/Routes.tsx' to easily declare protected areas of the app, such as 'admin' or 'secret' pages. Required dependencies are @redwoodjs/router and relevant page components. Inputs are route navigation requests; outputs are the rendered page or a redirection to a fallback route. Limitations include that more granular role-based restrictions may need further configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/authentication.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Router, Route, PrivateSet } from '@redwoodjs/router'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Route path=\"/\" page={HomePage} name=\"home\" />\n      <Route path=\"/login\" page={LoginPage} name=\"login\" />\n      // highlight-next-line\n      <PrivateSet unauthenticated=\"login\">\n        <Route path=\"/admin\" page={AdminPage} name=\"admin\" />\n        <Route path=\"/secret-page\" page={SecretPage} name=\"secret\" />\n      </PrivateSet>\n    </Router>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Generating CRUD Scaffolding for Posts with Redwood Generator - Bash\nDESCRIPTION: This Bash command uses RedwoodJS's CLI (`yarn rw`) to generate all the CRUD (scaffold) pages, components, GraphQL SDL, and Prisma services for a 'post' model in your application. The generator automatically builds route definitions, layout containers, GraphQL types/services, and UI pages for listing, viewing, editing, and deleting posts. Requires Redwood and dependencies to be installed in the project. Inputs: model name (post), outputs: full admin/editor CRUD experience for that model. You must run this from the project root, and it assumes a 'post' model/schema is already present in your database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/getting-dynamic.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g scaffold post\n```\n\n----------------------------------------\n\nTITLE: Customized RedwoodJS Cell Query and Success State - TypeScript (React TSX)\nDESCRIPTION: This TypeScript Cell changes the GraphQL query to fetch 'posts' and updates all relevant types and props. The Success component now destructures 'posts' from its props and displays the array. This pattern is necessary when the Cell's default generated query does not match the backend data model.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { ArticlesQuery, ArticlesQueryVariables } from 'types/graphql'\\n\\nimport type {\\n  CellFailureProps,\\n  CellSuccessProps,\\n  TypedDocumentNode,\\n} from '@redwoodjs/web'\\n\\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\\n  gql`\\n    query ArticlesQuery {\\n      // highlight-next-line\\n      posts {\\n        id\\n      }\\n    }\\n  `\\n\\nexport const Loading = () => <div>Loading...</div>\\n\\nexport const Empty = () => <div>Empty</div>\\n\\nexport const Failure = ({\\n  error,\\n}: CellFailureProps<ArticlesQueryVariables>) => (\\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\\n)\\n\\n// highlight-next-line\\nexport const Success = ({\\n  posts,\\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\\n  return (\\n    <ul>\\n      // highlight-next-line\\n      {posts.map((item) => {\\n        return <li key={item.id}>{JSON.stringify(item)}</li>\\n      })}\\n    </ul>\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Passing Page Parameter via Props to Homepage - RedwoodJS - TypeScript\nDESCRIPTION: Implements the HomePage component in TypeScript, expecting an optional 'page' prop with a default of 1, and passes it to 'BlogPostsCell' for paginated data queries. Utilizes RedwoodJS routing and layout conventions. This pattern allows seamless integration with query string page navigation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nconst HomePage = ({ page = 1 }) => {\n  return (\n    <BlogLayout>\n      <BlogPostsCell page={page} />\n    </BlogLayout>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Article Title Presence (JavaScript)\nDESCRIPTION: Uses `screen.getByText` to find an element containing the exact `article.title` and `expect(...).toBeInTheDocument()` to assert that such an element exists in the rendered component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nexpect(screen.getByText(article.title)).toBeInTheDocument()\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic FieldError in RedwoodJS Form (TypeScript)\nDESCRIPTION: Introduces the `<FieldError>` component from `@redwoodjs/forms` within a TypeScript environment. This snippet shows importing `FieldError` and related form components, defining an interface `FormValues` for type safety, using `SubmitHandler<FormValues>` for the submit function, and placing `<FieldError>` below corresponding input fields. The `name` prop links the error display to the specific field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  // highlight-next-line\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"name\" />\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"email\" />\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"message\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Root Jest Settings\nDESCRIPTION: This JSX (JavaScript) snippet displays the default content of the root `jest.config.js` file in a RedwoodJS project. It configures Jest to recognize the project root and discover individual Jest configuration files located within each side (`web`, `api`) of the application using the `projects` array.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/project-configuration-dev-test-build.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nmodule.exports = {\n  rootDir: '.',\n  projects: ['<rootDir>/{*,!(node_modules)/**/}/jest.config.js'],\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a RedwoodJS Cell Component in JavaScript (JSX)\nDESCRIPTION: This snippet demonstrates the basic structure of a RedwoodJS Cell using JavaScript (JSX). It exports a GraphQL query (`QUERY`) using the `gql` tag and several functional components (`Loading`, `Empty`, `Failure`, `Success`) that Redwood automatically renders based on the data fetching lifecycle (loading state, no data returned, error occurred, or data successfully fetched). The `Success` component receives the fetched data (`posts`) as props and renders the UI.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query FindPosts {\n    posts {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>No posts yet!</div>\n\nexport const Failure = ({ error }) => (\n  <div>Error loading posts: {error.message}</div>\n)\n\nexport const Success = ({ posts }) => {\n  return posts.map((post) => (\n    <article key={post.id}>\n      <h2>{post.title}</h2>\n      <div>{post.body}</div>\n    </article>\n  ))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Signing Up with Email/Password using RedwoodJS `useAuth` Hook (TypeScript)\nDESCRIPTION: Demonstrates creating a new user with an email and password using the `signUp` method from the RedwoodJS `useAuth` hook.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst { signUp } = useAuth()\n\nawait signUp({\n  email: 'example@email.com',\n  password: 'example-password',\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing a RedwoodJS Form Component in React - JavaScript\nDESCRIPTION: This JavaScript snippet initializes a bare RedwoodJS form in a React functional component using the <Form> component. The snippet imports required modules from '@redwoodjs/web' and '@redwoodjs/forms' and lays out the base structure for a contact page without form fields. Dependencies include RedwoodJS's web and forms packages. The input and output of the form are undefined at this stage; its purpose is to scaffold a form for future extension.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      // highlight-next-line\n      <Form></Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Secured AdminPosts Service for User-Scoped CRUD (JavaScript)\nDESCRIPTION: This snippet provides the backend implementation for admin-only post CRUD in the adminPosts service under RedwoodJS. Each operation is restricted to the admin’s own posts by filtering with context.currentUser.id, and supports full create, update, delete, and fetch by id or collection. Prisma’s findFirst() is used for flexible querying with multiple conditions. It requires RedwoodJS, Prisma, and appropriate context for authentication.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const adminPosts = () => {\n  return db.post.findMany({ where: { userId: context.currentUser.id } })\n}\n\nexport const adminPost = ({ id }) => {\n  return db.post.findFirst({\n    where: { id, userId: context.currentUser.id },\n  })\n}\n\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    data: { ...input, userId: context.currentUser.id },\n  })\n}\n\nexport const updatePost = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost = ({ id }) => {\n  return db.post.delete({\n    where: { id },\n  })\n}\n\n```\n\n----------------------------------------\n\nTITLE: Querying Related Comments from Post using Prisma Client (JavaScript)\nDESCRIPTION: Shows how to query all related `Comment` objects for a specific `Post` using the Prisma Client API. It employs `db.post.findUnique` to find the post by its ID and then chains `.comments()` to retrieve an array of associated comments, utilizing the relation defined in the Prisma schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\ndb.post.findUnique({ where: { id: 1 } }).comments()\n```\n\n----------------------------------------\n\nTITLE: Securing Create Testimonial Mutation with Context Auth - JavaScript\nDESCRIPTION: Provides a secured service function for creating a testimonial, verifying that the current user has the 'admin' role before performing a Prisma 'create' operation. Imports 'db' for Prisma access and 'AuthenticationError' for throwing auth errors. Requires 'context.currentUser' to be available (set up by RedwoodJS), and throws if the role requirement is not met. The function expects a data object and returns the created testimonial, rejecting unauthorized access.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter0/what-is-redwood.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\nimport { AuthenticationError } from '@redwoodjs/graphql-server'\n\nexport const createTestimonial = ({ data }) => {\n  if (context.currentUser.roles.includes('admin')) {\n    return db.testimonial.create({ data })\n  } else {\n    throw new AuthenticationError(\n      'You are not authorized to create testimonials'\n    )\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Signing In with Password using RedwoodJS `useAuth` Hook (TypeScript)\nDESCRIPTION: Shows the RedwoodJS way to sign in using email and password. It utilizes the `logIn` method from the `useAuth` hook, specifying `authMethod: 'password'` and passing the credentials.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst { logIn } = useAuth()\n\nawait logIn({\n  authMethod: 'password',\n  email: 'example@email.com',\n  password: 'example-password',\n})\n```\n\n----------------------------------------\n\nTITLE: Paginated Blog Posts GraphQL Query - RedwoodJS Cell - TypeScript\nDESCRIPTION: Implements a typed GraphQL query for paginated blog posts in RedwoodJS with TypeScript. Utilizes TypedDocumentNode for type safety, fetching posts with key attributes and the total count required for pagination controls. Depends on codegen-generated GraphQL types and the existence of API support for the 'postPage' query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { BlogPostsQuery, BlogPostsQueryVariables } from 'types/graphql'\n\nimport type { TypedDocumentNode } from '@redwoodjs/web'\n\nexport const QUERY: TypedDocumentNode<BlogPostsQuery, BlogPostsQueryVariables> =\n  gql`\n    query BlogPostsQuery($page: Int) {\n      postPage(page: $page) {\n        posts {\n          id\n          title\n          body\n          createdAt\n        }\n        count\n      }\n    }\n  `\n```\n\n----------------------------------------\n\nTITLE: Defining a Typed RedwoodJS Cell in TypeScript (TSX)\nDESCRIPTION: This snippet shows the TypeScript (TSX) implementation of a RedwoodJS Cell, providing type safety. It imports necessary types like `FindPosts`, `FindPostsVariables` (auto-generated GraphQL types) and Redwood's utility types (`CellFailureProps`, `CellSuccessProps`, `TypedDocumentNode`). Similar to the JavaScript version, it exports `QUERY`, `Loading`, `Empty`, `Failure`, and `Success` components, but with explicit type annotations for props and the query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { FindPosts, FindPostsVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypedDocumentNode,\n} from '@redwoodjs/web'\n\nexport const QUERY: TypedDocumentNode<FindPosts, FindPostsVariables> = gql`\n  query FindPosts {\n    posts {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>No posts yet!</div>\n\nexport const Failure = ({ error }: CellFailureProps<FindPostsVariables>) => (\n  <div>Error loading posts: {error.message}</div>\n)\n\nexport const Success = ({\n  posts,\n}: CellSuccessProps<FindPosts, FindPostsVariables>) => {\n  return posts.map((post) => (\n    <article key={post.id}>\n      <h2>{post.title}</h2>\n      <div>{post.body}</div>\n    </article>\n  ))\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Alias Limit for GraphQL Documents (GraphQL Armor, TypeScript)\nDESCRIPTION: Provides a config object example that enables the maxAliases plugin and sets the maximum allowed aliases in a document to 15. Used within the armorConfig supplied to createGraphQLHandler to prevent excessive or potentially malicious use of field aliases in queries. No code execution; only configuration structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_64\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  maxAliases: {\n    enabled: true,\n    n: 15,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a GraphQL Fragment with RedwoodJS (TypeScript)\nDESCRIPTION: This snippet shows how to define and register a GraphQL fragment in a RedwoodJS application using TypeScript. It imports the fragment type, registers the fragment via registerFragment from @redwoodjs/web/apollo, and returns a hook to use the registered fragment in components. This requires RedwoodJS, Apollo Client, and the appropriate GraphQL type definitions. The key parameter is the fragment (BookInfo) which selects specific book fields; outputs include hooks for fragment usage. Ensure @redwoodjs/web/apollo and 'gql' are available in the environment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Book } from 'types/graphql'\n\nimport { registerFragment } from '@redwoodjs/web/apollo'\n\nconst { useRegisteredFragment } = registerFragment(gql`\n  fragment BookInfo on Book {\n    id\n    title\n    author\n    publicationYear\n  }\n`)\n\n```\n\n----------------------------------------\n\nTITLE: Finding the First Matching Record by Criteria using `findBy()` in JSX\nDESCRIPTION: The `findBy()` method retrieves the first single record that matches the specified criteria. The first argument is an object defining the conditions (similar to Prisma's `findFirst()` `where` clause). The optional second argument allows for additional properties like ordering (`orderBy`) or limiting (`take`) to be applied before selecting the first match. It returns `null` if no matching record is found.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\nawait User.findBy({ email: 'rob@redwoodjs.com' })\nawait User.findBy({ email: { endsWith: { 'redwoodjs.com' } } }, { orderBy: { lastName: 'asc' }, take: 10 })\n```\n\n----------------------------------------\n\nTITLE: Boilerplate RedwoodJS Articles Cell - JavaScript (React JSX)\nDESCRIPTION: This snippet contains the generated boilerplate for an ArticlesCell in RedwoodJS using JavaScript and JSX. It defines a GraphQL query named 'ArticlesQuery' to fetch a list of articles, and includes standard cell component states: Loading, Empty, Failure, and Success. 'Success' expects an 'articles' prop and displays each article as a list item; no custom dependencies beyond RedwoodJS and React are required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\\n  query ArticlesQuery {\\n    articles {\\n      id\\n    }\\n  }\\n`\\n\\nexport const Loading = () => <div>Loading...</div>\\n\\nexport const Empty = () => <div>Empty</div>\\n\\nexport const Failure = ({ error }) => (\\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\\n)\\n\\nexport const Success = ({ articles }) => {\\n  return (\\n    <ul>\\n      {articles.map((item) => {\\n        return <li key={item.id}>{JSON.stringify(item)}</li>\\n      })}\\n    </ul>\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Adding HTML Required Attribute for Validation to RedwoodJS Contact Form in TypeScript\nDESCRIPTION: Demonstrates adding required HTML attribute for each form field to enable browser-level validation in the TypeScript implementation of the RedwoodJS contact form. The browser will not submit the form if any fields are empty, with uncustomizable native messages. No additional libraries are necessary.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nreturn (\n  <Form onSubmit={onSubmit}>\n    <label htmlFor=\"name\">Name</label>\n    // highlight-next-line\n    <TextField name=\"name\" required />\n    <label htmlFor=\"email\">Email</label>\n    // highlight-next-line\n    <TextField name=\"email\" required />\n    <label htmlFor=\"message\">Message</label>\n    // highlight-next-line\n    <TextAreaField name=\"message\" required />\n    <Submit>Save</Submit>\n  </Form>\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Apollo Provider for Redwood App - React JSX - jsx\nDESCRIPTION: This snippet shows the standard setup of RedwoodApolloProvider within a React application, which integrates RedwoodJS with Apollo Client out-of-the-box. It wraps child routes/components with the provider, making GraphQL client functionalities available throughout the component tree. Essential dependencies include @redwoodjs/web/apollo and @redwoodjs/router, with the main input being the application routes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { RedwoodApolloProvider } from '@redwoodjs/web/apollo'\n\n// ...\n\nconst App = () => (\n  <RedwoodApolloProvider>\n    <Routes />\n  </RedwoodApolloProvider>\n)\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Using RedwoodJS Label Component with Error Styling (JSX)\nDESCRIPTION: This JSX snippet demonstrates replacing standard HTML `<label>` elements with the RedwoodJS `<Label>` component, imported from `@redwoodjs/forms`. It shows how to use the `name` prop (instead of `htmlFor`) to associate the label with an input and the `errorClassName=\"error\"` prop to apply specific styles to the label itself when the associated field has a validation error.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  // highlight-next-line\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-start\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        // highlight-start\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"email\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        {/* ... rest of the form ... */}\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Posts and User Name in Articles GraphQL Cell (JSX/GraphQL)\nDESCRIPTION: This GraphQL Cell query, written in JSX, requests a list of articles (posts) along with each article's user name. It demonstrates how to annotate a RedwoodJS Cell to fetch not only post properties like id, title, body, and createdAt, but also the nested user's name. The query uses GraphQL's field selection and expects that a relation resolver or proper database query supplies the user data. Dependencies include RedwoodJS, Apollo Client, and the defined GraphQL schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query ArticlesQuery {\n    articles: posts {\n      id\n      title\n      body\n      createdAt\n      // highlight-start\n      user {\n        name\n      }\n      // highlight-end\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Testing Comments Service Query by postId - JavaScript\nDESCRIPTION: This test snippet from the Comments service checks that fetching comments by a given postId returns all related comments. It relies on a scenario object defined in test setup, and expects the result length to equal the number of comments for that post. It assumes the comments function accepts a postId parameter and has access to test scenario demodata.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_26\n\nLANGUAGE: JavaScript\nCODE:\n```\nscenario('returns all comments', async (scenario) => {\\n  // highlight-next-line\\n  const result = await comments({ postId: scenario.comment.jane.postId })\\n  expect(result.length).toEqual(Object.keys(scenario.comment).length)\\n})\n```\n\n----------------------------------------\n\nTITLE: Validating Presence with allowEmptyString Option using JavaScript/JSX\nDESCRIPTION: Here, the validate function is configured with allowEmptyString set to false, requiring that empty strings are not accepted as valid presence. This enforces that only non-empty, non-null, and non-undefined values are valid, making the validation stricter for text input. This requires a validation utility that supports the allowEmptyString parameter.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_45\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.value, 'Value', {\n  presence: { allowEmptyString: false },\n})\n// `null` fails\n// `undefined` fails\n// \"\" fails\n\n```\n\n----------------------------------------\n\nTITLE: User Creation with Email Uniqueness using validateUniqueness in JavaScript/JSX\nDESCRIPTION: Defines a createUser function that ensures email uniqueness before user creation. Uses validateUniqueness by passing 'user' as the table, a filter object with the email, and a creation callback. Prevents duplicate emails in the database. Assumes validateUniqueness() and db.user.create() are available.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_53\n\nLANGUAGE: jsx\nCODE:\n```\nconst createUser = (input) => {\n  return validateUniqueness('user', { email: input.email }, (db) => {\n    return db.user.create({ data: input })\n  })\n}\n\n```\n\n----------------------------------------\n\nTITLE: Handling Authentication and Token Expiration - JavaScript\nDESCRIPTION: This snippet demonstrates how to customize dbAuth's login, signup, and authentication handler options to implement passwordless login. It checks for token expiration, invalidates used tokens by clearing expiration and salt, customizes error messages, and maps required fields for dbAuth. Dependencies include dbAuthHandler from RedwoodJS, a configured db instance, and an existing user model. Inputs: user record, event/context. Outputs: authenticated user or errors. Only one-time tokens are accepted.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// ... other functions\nconst loginOptions = {\n  handler: async (user) => {\n    const loginExpiresAt = new Date(user.loginTokenExpiresAt)\n    const now = new Date()\n\n    if (loginExpiresAt < now) {\n      throw new Error('Login token expired')\n    }\n\n    // If the user logged in with a token we need to break the token. We'll do\n    // this by clearing the salt and expiration. This will make the token a\n    // one-time use token\n    db.user.update({\n      where: { id: user.id },\n      data: {\n        loginTokenExpiresAt: null,\n        salt: null,\n      },\n    })\n\n    return user\n  },\n  errors: {\n    // here I modified the following, feel free to modify the other messages\n    incorrectPassword: 'Incorrect token',\n  },\n}\n\n// we also need to update signupOptions\nconst signupOptions = {\n  handler: ({ username, hashedPassword, userAttributes }) => {\n    return db.user.create({\n      data: {\n        email: username,\n        loginToken: hashedPassword,\n        salt: null,\n        name: userAttributes.name,\n      },\n    })\n  },\n  // ... othter stuff\n}\n\n// and last we need to update the authFields\nconst authHandler = new DbAuthHandler(event, context, {\n  db: db,\n  authModelAccessor: 'user',\n  authFields: {\n    id: 'id',\n    username: 'email',\n    hashedPassword: 'loginToken',\n    salt: 'salt',\n    resetToken: 'resetToken',\n    resetTokenExpiresAt: 'resetTokenExpiresAt',\n  },\n  // ... other stuff\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating the Navigation Component into the Global Layout in RedwoodJS\nDESCRIPTION: Defines the `GlobalLayout` component in `web/src/layouts/GlobalLayout/GlobalLayout.js`. It imports and renders the `Navigation` component within a `header` element, ensuring the navigation appears consistently on pages using this layout. The `children` prop renders the specific page content within the `main` element.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_26\n\nLANGUAGE: jsx\nCODE:\n```\nimport Navigation from 'src/components/Navigation/Navigation'\n\nconst GlobalLayout = ({ children }) => {\n  return (\n    <>\n      <header>\n        <Navigation />\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default GlobalLayout\n```\n\n----------------------------------------\n\nTITLE: Defining Post Service Functions and Relation Resolver - RedwoodJS - JavaScript\nDESCRIPTION: This snippet defines standard CRUD operations for posts in a RedwoodJS service and demonstrates how to manually add a relation resolver that retrieves the user for a given post instance. It imports the database client and adds the 'Post' field resolver, mapping the 'user' property to retrieve the associated user using Prisma. Dependencies include 'src/lib/db' and the underlying Prisma data model. The key parameters for these functions are 'id' for lookup and mutation, and 'input' for creation and updates. The expected output is an array of posts, a single post, or a user object depending on the operation. If a user field resolver is present, it will always be executed regardless of post object shape.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const posts = () => {\n  return db.post.findMany()\n}\n\nexport const post = ({ id }) => {\n  return db.post.findUnique({\n    where: { id },\n  })\n}\n\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    data: input,\n  })\n}\n\nexport const updatePost = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost = ({ id }) => {\n  return db.post.delete({\n    where: { id },\n  })\n}\n\n// highlight-start\nexport const Post = {\n  user: (_obj, { root }) =>\n    db.post.findFirst({ where: { id: root.id } }).user(),\n}\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Updating GraphQL Query to Fetch More Fields in TypeScript (RedwoodJS Cell)\nDESCRIPTION: This TypeScript snippet shows modifying the typed `QUERY` constant within a RedwoodJS Cell (`ArticlesCell.tsx`). It adds the fields 'title', 'body', and 'createdAt' to the selection set for the aliased 'articles' field. This allows fetching more detailed article data, and the types associated with `TypedDocumentNode` would typically be regenerated to reflect these changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\n  gql`\n    query ArticlesQuery {\n      articles: posts {\n        id\n        // highlight-start\n        title\n        body\n        createdAt\n        // highlight-end\n      }\n    }\n`\n```\n\n----------------------------------------\n\nTITLE: Enforcing Moderator Role in Comment Deletion Service - RedwoodJS - TypeScript\nDESCRIPTION: This service code in TypeScript for RedwoodJS safeguards comment deletion by requiring the user to have the moderator role. It uses requireAuth and the Prisma client (db), applying type safety and TypeScript best practices. It expects an object with an 'id' property and returns the deleted comment. The snippet assumes prior setup of authentication utilities in src/lib/auth and a configured TypeScript/RedwoodJS project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_31\n\nLANGUAGE: ts\nCODE:\n```\n// highlight-next-line\nimport { requireAuth } from 'src/lib/auth'\nimport { db } from 'src/lib/db'\n\n// ...\n\nexport const deleteComment = ({ id }) => {\n  // highlight-next-line\n  requireAuth({ roles: 'moderator' })\n  return db.comment.delete({\n    where: { id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Using activeMatchParams with NavLink for Query Parameter Control - RedwoodJS - JSX\nDESCRIPTION: This snippet illustrates customizing how NavLink determines when a link is active by using the activeMatchParams prop. It enables granular matching of URL search/query parameters, letting the link's active state depend on specific parameters like 'tab' and 'page'. Requires '@redwoodjs/router'. Inputs are route params and search params, outputs are navigation links with correct active class application. This supports advanced menu highlighting based on detailed URL state.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { NavLink, routes } from '@redwoodjs/router'\n\n// Will render <a href=\\\"/?tab=tutorial&page=2\\\" className=\\\"activeLink\\\"> when on\n// any Home tutorial page\nconst MainMenu = () => (\n  <li>\n    <NavLink\n      className=\\\"link\\\"\n      activeClassName=\\\"activeLink\\\"\n      activeMatchParams={[{ tab: 'tutorial' }]}\n      to={routes.home({ tab: 'tutorial', page: '2' })}\n    >\n      Home > Tutorial\n    </NavLink>\n  </li>\n)\n```\n\nLANGUAGE: jsx\nCODE:\n```\n// Match /?tab=tutorial&page=*\nactiveMatchParams={[{ tab: 'tutorial' }, 'page' ]}\n```\n\n----------------------------------------\n\nTITLE: Implementing Signup Handler in JavaScript\nDESCRIPTION: Defines the `signup.handler` function within the dbAuth configuration. This function receives user details (`username`, `hashedPassword`, `salt`, `userAttributes`) and is responsible for creating the user record in the database using a database client (e.g., `db.user.create`). Returning the newly created user object automatically logs the user in. Before this handler runs, dbAuth ensures the username is unique.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nsignup: {\n  handler: ({ username, hashedPassword, salt, userAttributes }) => {\n    return db.user.create({\n      data: {\n        email: username,\n        hashedPassword: hashedPassword,\n        salt: salt,\n        name: userAttributes.name,\n      },\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Signing In with Email/Password using RedwoodJS `useAuth` Hook (TypeScript)\nDESCRIPTION: Logs in an existing user using their email and password via the `logIn` method from the RedwoodJS `useAuth` hook, setting `authMethod: 'password'`. Requires either email/password or phone/password.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst { logIn } = useAuth()\n\nawait logIn({\n  authMethod: 'password',\n  email: 'example@email.com',\n  password: 'example-password',\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Auth0 Sign-up in a React Component (TSX)\nDESCRIPTION: Provides an example React functional component (`HomePage`) demonstrating basic Auth0 integration. It utilizes the `useAuth` hook (imported from `src/auth`) provided by RedwoodJS's authentication setup to access the `isAuthenticated` state and the `signUp` function. Clicking the button triggers the Auth0 sign-up flow, and the component displays whether the user is currently authenticated.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/auth0.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAuth } from 'src/auth'\n\nconst HomePage = () => {\n  const { isAuthenticated, signUp } = useAuth()\n\n  return (\n    <>\n      {/* MetaTags, h1, paragraphs, etc. */}\n\n      <p>{JSON.stringify({ isAuthenticated })}</p>\n      <button onClick={signUp}>sign up</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Role-Based Access Control for Service Function (JavaScript/TypeScript)\nDESCRIPTION: Provides Jest/Scenario tests for the `deleteComment` service function. It uses `mockCurrentUser` to simulate different user states (moderator, regular user, logged out) and verifies the expected behavior: successful deletion for moderators, `ForbiddenError` for non-moderators, and `AuthenticationError` for logged-out users. Dependencies include `@redwoodjs/graphql-server` for error types and `src/lib/db` for database interaction.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_29\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.test.js\"\n// highlight-next-line\nimport { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\n\nimport { db } from 'src/lib/db'\n\n// highlight-next-line\nimport { comments, createComment, deleteComment } from './comments'\n\ndescribe('comments', () => {\n  scenario(\n    'returns all comments for a single post from the database',\n    async (scenario) => {\n      const result = await comments({ postId: scenario.comment.jane.postId })\n      const post = await db.post.findUnique({\n        where: { id: scenario.comment.jane.postId },\n        include: { comments: true },\n      })\n      expect(result.length).toEqual(post.comments.length)\n    }\n  )\n\n  scenario('postOnly', 'creates a new comment', async (scenario) => {\n    const comment = await createComment({\n      input: {\n        name: 'Billy Bob',\n        body: 'What is your favorite tree bark?',\n        postId: scenario.post.bark.id,\n      },\n    })\n\n    expect(comment.name).toEqual('Billy Bob')\n    expect(comment.body).toEqual('What is your favorite tree bark?')\n    expect(comment.postId).toEqual(scenario.post.bark.id)\n    expect(comment.createdAt).not.toEqual(null)\n  })\n\n  // highlight-start\n  scenario('allows a moderator to delete a comment', async (scenario) => {\n    mockCurrentUser({ roles: ['moderator'] })\n\n    const comment = await deleteComment({\n      id: scenario.comment.jane.id,\n    })\n    expect(comment.id).toEqual(scenario.comment.jane.id)\n\n    const result = await comments({ postId: scenario.comment.jane.postId })\n    expect(result.length).toEqual(0)\n  })\n\n  scenario(\n    'does not allow a non-moderator to delete a comment',\n    async (scenario) => {\n      mockCurrentUser({ roles: 'user' })\n\n      expect(() =>\n        deleteComment({\n          id: scenario.comment.jane.id,\n        })\n      ).toThrow(ForbiddenError)\n    }\n  )\n\n  scenario(\n    'does not allow a logged out user to delete a comment',\n    async (scenario) => {\n      mockCurrentUser(null)\n\n      expect(() =>\n        deleteComment({\n          id: scenario.comment.jane.id,\n        })\n      ).toThrow(AuthenticationError)\n    }\n  )\n  // highlight-end\n})\n```\n```\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/services/comments/comments.test.ts\"\n// highlight-next-line\nimport { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\n\nimport { db } from 'src/lib/db'\n\n// highlight-next-line\nimport { comments, createComment, deleteComment } from './comments'\n\nimport type { PostOnlyScenario, StandardScenario } from './comments.scenarios'\n\ndescribe('comments', () => {\n  scenario(\n    'returns all comments for a single post from the database',\n    async (scenario) => {\n      const result = await comments({ postId: scenario.comment.jane.postId })\n      const post = await db.post.findUnique({\n        where: { id: scenario.comment.jane.postId },\n        include: { comments: true },\n      })\n      expect(result.length).toEqual(post.comments.length)\n    }\n  )\n\n  scenario(\n    'postOnly',\n    'creates a new comment',\n    async (scenario: PostOnlyScenario) => {\n      const comment = await createComment({\n        input: {\n          name: 'Billy Bob',\n          body: 'What is your favorite tree bark?',\n          postId: scenario.post.bark.id,\n        },\n      })\n\n      expect(comment.name).toEqual('Billy Bob')\n      expect(comment.body).toEqual('What is your favorite tree bark?')\n      expect(comment.postId).toEqual(scenario.post.bark.id)\n      expect(comment.createdAt).not.toEqual(null)\n    }\n  )\n\n  // highlight-start\n  scenario(\n    'allows a moderator to delete a comment',\n    async (scenario: StandardScenario) => {\n      mockCurrentUser({\n        roles: 'moderator',\n        id: 1,\n        email: 'moderator@moderator.com',\n      })\n\n      const comment = await deleteComment({\n        id: scenario.comment.jane.id,\n      })\n      expect(comment.id).toEqual(scenario.comment.jane.id)\n\n      const result = await comments({ postId: scenario.comment.jane.postId })\n      expect(result.length).toEqual(0)\n    }\n  )\n\n  scenario(\n    'does not allow a non-moderator to delete a comment',\n    async (scenario: StandardScenario) => {\n      mockCurrentUser({ roles: 'user', id: 1, email: 'user@user.com' })\n\n      expect(() =>\n        deleteComment({\n          id: scenario.comment.jane.id,\n        })\n      ).toThrow(ForbiddenError)\n    }\n  )\n\n  scenario(\n    'does not allow a logged out user to delete a comment',\n    async (scenario: StandardScenario) => {\n      mockCurrentUser(null)\n\n      expect(() =>\n        deleteComment({\n          id: scenario.comment.jane.id,\n        })\n      ).toThrow(AuthenticationError)\n    }\n  )\n  // highlight-end\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Generating a Session Secret Key using RedwoodJS CLI\nDESCRIPTION: Shows the command `yarn rw g secret` used within a RedwoodJS project to generate a cryptographically secure secret key. This key is used to encrypt the session cookie. The command outputs the key to the console, and it must be manually added to the relevant environment configuration file (like `.env`), ensuring it's kept private.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw g secret\n```\n\n----------------------------------------\n\nTITLE: Configuring authFields in DbAuthHandler for Redwood - JavaScript\nDESCRIPTION: Specifies the mapping of user data fields to the dbAuth handler as expected by Redwood, allowing identification and customization when names differ from defaults. This object should be placed in the Redwood API function's auth.js handler during DbAuthHandler initialization. Make sure these properties match your Prisma User model fields for correct operation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nauthFields: {\n  id: 'id',\n  username: 'email',\n  hashedPassword: 'hashedPassword',\n  salt: 'salt',\n  resetToken: 'resetToken',\n  resetTokenExpiresAt: 'resetTokenExpiresAt',\n},\n```\n\n----------------------------------------\n\nTITLE: Signing In with SSO using RedwoodJS `useAuth` Hook (TypeScript)\nDESCRIPTION: Initiates a Single Sign-On (SSO) login flow. Uses the `logIn` method from the RedwoodJS `useAuth` hook with `authMethod: 'sso'`, providing the `providerId` (the SSO provider's identity UUID) or optionally a `domain` to initiate the flow.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst { logIn } = useAuth()\n\nawait logIn({\n  authMethod: 'sso',\n  providerId: 'sso-provider-identity-uuid',\n  domain: 'example.com',\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring maxDirectives in RedwoodJS GraphQL Handler - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to configure the maxDirectives security setting when initializing a RedwoodJS GraphQL handler. The maxDirectives property enables limiting the number of directives allowed in a query to mitigate resource exhaustion attacks. Key parameters include enabled (boolean) to activate the rule and n (number) specifying the maximum allowed directives.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_71\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  maxDirectives: {\n    enabled: true,\n    n: 50,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Server-Side Email Validation in RedwoodJS Service (TypeScript)\nDESCRIPTION: Imports and uses the `validate` function from `@redwoodjs/api` within the typed `createContact` service function (a `MutationResolver`) in `contacts.ts`. It validates the `input.email` field server-side using the `{ email: true }` directive before creating the contact, ensuring data integrity even if client-side validation is bypassed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_22\n\nLANGUAGE: ts\nCODE:\n```\nimport type { QueryResolvers, MutationResolvers } from 'types/graphql'\n\n// highlight-next-line\nimport { validate } from '@redwoodjs/api'\n\n// ...\n\nexport const createContact: MutationResolvers['createContact'] = ({\n  input,\n}) => {\n  // highlight-next-line\n  validate(input.email, 'email', { email: true })\n  return db.contact.create({ data: input })\n}\n\n```\n\n----------------------------------------\n\nTITLE: Paginated Post Resolver Implementation - RedwoodJS Services - JavaScript\nDESCRIPTION: Implements the 'postPage' query resolver, returning a fixed number of posts per page and the total count, using Prisma's 'findMany' and 'count'. The service expects a numeric 'page' parameter with a default of 1, calculates offset, and fetches posts ordered by creation date descending. Requires Prisma and correct RedwoodJS database setup; returns an object with 'posts' and 'count' properties.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst POSTS_PER_PAGE = 5\n\nexport const postPage = ({ page = 1 }) => {\n  const offset = (page - 1) * POSTS_PER_PAGE\n\n  return {\n    posts: db.post.findMany({\n      take: POSTS_PER_PAGE,\n      skip: offset,\n      orderBy: { createdAt: 'desc' },\n    }),\n    count: db.post.count(),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enhancing Article Rendering in Typed Success Component (TypeScript/TSX)\nDESCRIPTION: Updates the typed `Success` component in `ArticlesCell.tsx`. It maps over the `articles` array, rendering each article using JSX within an `<article>` tag, displaying the `title`, `body`, and `createdAt`. Type safety is ensured through the use of `CellSuccessProps` and generated types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_25\n\nLANGUAGE: tsx\nCODE:\n```\nexport const Success = ({\n  articles,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\n  return (\n    // highlight-start\n    <>\n      {articles.map((article) => (\n        <article key={article.id}>\n          <header>\n            <h2>{article.title}</h2>\n          </header>\n          <p>{article.body}</p>\n          <div>Posted at: {article.createdAt}</div>\n        </article>\n      ))}\n    </>\n    // highlight-end\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Comments Service: Match Comment Count with DB by postId - JavaScript (JSX test)\nDESCRIPTION: This test for the comments service checks that the number of comments returned by the service for a given postId matches exactly the number of comments attached to that post in the database. The test retrieves the post and its associated comments using Prisma's findUnique, then asserts the returned list's length. This requires access to db and assumes correct test data setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_30\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { comments, createComment } from './comments'\\n// highlight-next-line\\nimport { db } from 'src/lib/db'\\n\\ndescribe('comments', () => {\\n  scenario('returns all comments', async (scenario) => {\\n    const result = await comments({ postId: scenario.comment.jane.postId })\\n    // highlight-start\\n    const post = await db.post.findUnique({\\n      where: { id: scenario.comment.jane.postId },\\n      include: { comments: true },\\n    })\\n    expect(result.length).toEqual(post.comments.length)\\n    // highlight-end\\n  })\\n\\n  // ...\\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Routes to Include the Contact Page (TypeScript)\nDESCRIPTION: This TypeScript snippet configures the RedwoodJS router to include the new 'contact' route within the BlogLayout context. It uses explicit property typing and line breaks for clarity, supporting auto-completion and code safety. Dependencies: '@redwoodjs/router'. Outputs routes for SPA navigation and error handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set\n        wrap={ScaffoldLayout}\n        title=\"Posts\"\n        titleTo=\"posts\"\n        buttonLabel=\"New Post\"\n        buttonTo=\"newPost\"\n      >\n        <Route path=\"/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n        <Route\n          path=\"/posts/{id:Int}/edit\"\n          page={PostEditPostPage}\n          name=\"editPost\"\n        />\n        <Route path=\"/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n        <Route path=\"/posts\" page={PostPostsPage} name=\"posts\" />\n      </Set>\n      <Set wrap={BlogLayout}>\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n        // highlight-next-line\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS RedwoodRecord Models via CLI\nDESCRIPTION: This command generates a RedwoodRecord model file in `api/src/models` corresponding to a model defined in your `schema.prisma` file. It requires the model's name as defined in the schema. Options allow forcing overwrite (`--force`) and rolling back on error (`--rollback`). The command also implicitly runs `yarn rw record init` to ensure necessary setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_54\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate model <name>\n```\n\n----------------------------------------\n\nTITLE: Disabling File Scalar Inclusion in GraphQL - TOML and TypeScript Config\nDESCRIPTION: This two-part configuration snippet shows how to disable automatic inclusion of the File scalar in RedwoodJS's GraphQL server: first by setting includeScalars.File = false in redwood.toml, and then by explicitly setting includeScalars.File to false in the TypeScript handler config. Dependencies are the app's redwood.toml file and the TypeScript server implementation. Inputs are the config property settings; outputs are a schema without the File scalar. Limitations: both configs must be set for intended behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_24\n\nLANGUAGE: toml\nCODE:\n```\n[graphql]\n  includeScalars.File = false\n```\n\n----------------------------------------\n\nTITLE: Using the Presence Validator (Basic) in JSX\nDESCRIPTION: Demonstrates the basic usage of the `presence` validator. This rule requires that the input field's value must *not* be `null` or `undefined`. It's configured by setting `presence: true` in the validation options object and is commonly used for required fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_42\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.value, 'Value', {\n  presence: true,\n})\n\n```\n\n----------------------------------------\n\nTITLE: Using the Length Validator with `max` Option in JSX\nDESCRIPTION: Illustrates the `length` validator using only the `max` option to ensure the input string does not exceed a specified number of characters.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.company, 'Company', {\n  length: { max: 255 },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Validation Logic with validateWith - JavaScript\nDESCRIPTION: Demonstrates extending built-in service validations by adding business-specific rules via validateWith. The function checks if input.lastCarWashDate is more than a week old and throws an error if true, enforcing a clean car submission policy. Requires validateWith and a context with an input object containing lastCarWashDate. No return value; errors are thrown for violation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_31\n\nLANGUAGE: JavaScript\nCODE:\n```\nvalidateWith(() => {\n  const oneWeekAgo = new Date()\n  oneWeekAgo.setDate(oneWeekAgo.getDate() - 7)\n\n  if (input.lastCarWashDate < oneWeekAgo) {\n    throw new Error(\"We don't accept dirty cars\")\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Post Service Resolvers with Prisma in JavaScript\nDESCRIPTION: Implements concrete GraphQL resolvers for Post querying and mutations in a RedwoodJS blog app (`posts.js`) using JavaScript. This file imports a `db` instance from Prisma and exports functions directly matched to SDL query and mutation signatures (posts, post, createPost, updatePost, deletePost). Each resolver performs a single database operation and returns a promise. Requires Prisma setup with a Post model, RedwoodJS conventions, and the Prisma Client dependency.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/side-quest.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const posts = () => {\n  return db.post.findMany()\n}\n\nexport const post = ({ id }) => {\n  return db.post.findUnique({\n    where: { id },\n  })\n}\n\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    data: input,\n  })\n}\n\nexport const updatePost = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost = ({ id }) => {\n  return db.post.delete({\n    where: { id },\n  })\n}\n\n```\n\n----------------------------------------\n\nTITLE: Verifying Svix/Clerk Webhooks with Base64 SHA256 in RedwoodJS (TSX)\nDESCRIPTION: This AWS Lambda handler verifies webhooks from Svix (and by extension, Clerk) using Base64 encoded SHA256 signatures in a RedwoodJS application. It employs the `verifyEvent` function with the `base64Sha256Verifier`. Special handling is included via `options`: it reads the signature from the `svix-signature` header and uses a `signatureTransformer` to parse potentially space-separated, versioned signatures (e.g., \"v1,...\"), extracting only the 'v1' signature. The payload used for verification is constructed by concatenating the `svix-id`, `svix-timestamp` headers, and the raw request body. The secret is derived from the `CLERK_WH_SECRET` environment variable.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport type { APIGatewayEvent } from 'aws-lambda'\nimport {\n  verifyEvent,\n  VerifyOptions,\n  WebhookVerificationError,\n} from '@redwoodjs/api/webhooks'\n\nimport { logger } from 'src/lib/logger'\n\nexport const handler = async (event: APIGatewayEvent) => {\n  const clerkInfo = { webhook: 'clerk' }\n  const webhookLogger = logger.child({ clerkInfo })\n\n  webhookLogger.trace('Invoked clerkWebhook function')\n\n  try {\n    const options: VerifyOptions = {\n      signatureHeader: 'svix-signature',\n      signatureTransformer: (signature: string) => {\n        // Clerk can pass a space separated list of signatures.\n        // Let's just use the first one that's of version 1\n        const passedSignatures = signature.split(' ')\n\n        for (const versionedSignature of passedSignatures) {\n          const [version, signature] = versionedSignature.split(',')\n\n          if (version === 'v1') {\n            return signature\n          }\n        }\n      },\n    }\n\n    const svix_id = event.headers['svix-id']\n    const svix_timestamp = event.headers['svix-timestamp']\n\n    verifyEvent('base64Sha256Verifier', {\n      event,\n      secret: process.env.CLERK_WH_SECRET.slice(6),\n      payload: `${svix_id}.${svix_timestamp}.${event.body}`,\n      options,\n    })\n\n    webhookLogger.debug({ headers: event.headers }, 'Headers')\n\n    const payload = JSON.parse(event.body)\n\n    webhookLogger.debug({ payload }, 'Body payload')\n\n    // Safely use the validated webhook payload\n\n    return {\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      statusCode: 200,\n      body: JSON.stringify({\n        data: payload,\n      }),\n    }\n  } catch (error) {\n    if (error instanceof WebhookVerificationError) {\n      webhookLogger.warn('Unauthorized')\n\n      return {\n        statusCode: 401,\n      }\n    } else {\n      webhookLogger.error({ error }, error.message)\n\n      return {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        statusCode: 500,\n        body: JSON.stringify({\n          error: error.message,\n        }),\n      }\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Validating Multi-Select Dropdown Input with React SelectField (JSX)\nDESCRIPTION: This code configures a <SelectField> with the multiple prop and an advanced validation function in a React JSX form. The validation ensures the field is filled and the user has not selected the placeholder. If validation fails for any selected value, an error message is returned via a custom mapping function. The corresponding <FieldError> displays errors. This approach depends on a form system that supports array-type field values and custom validation, taking arrays of strings and returning error messages or boolean results.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n<SelectField\n  multiple={true}\n  name=\\\"selectMultiple\\\"\n  validation={{\n    required: true,\n    validate: {\n      matchesInitialValue: (value) => {\n        let returnValue = [true]\n        returnValue = value.map((element) => {\n          if (element === 'Please select an option')\n            return 'Select an Option'\n        })\n        return returnValue[0]\n      },\n    },\n  }}\n>\n  <option>Please select an option</option>\n  <option>Option 1</option>\n  <option>Option 2</option>\n</SelectField>\n<FieldError name=\\\"selectMultiple\\\" style={{ color: 'red' }} />\n```\n\n----------------------------------------\n\nTITLE: Defining a GraphQL QUERY with Variables (JSX)\nDESCRIPTION: This JSX code exports the QUERY constant for a Cell and demonstrates use of GraphQL query variables. The variables correspond to the props received by the Cell―here, numberToShow as an integer. The query fetches posts with the specified limit, mapping SDL variable requirements to Cell component props.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query ($numberToShow: Int!) {\n    posts(numberToShow: $numberToShow) {\n      id\n      title\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Creating Associated Records via Relation Proxy in JSX\nDESCRIPTION: New records can be created directly through the relation proxy (e.g., `user.posts.create(...)`). This automatically associates the new child record (e.g., `post`) with the parent record (`user`) by setting the appropriate foreign key (e.g., `userId`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_28\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = await User.find(123)\nconst post = await user.posts.create({ title: 'Related post!' })\npost.userId // => 123\n```\n\n----------------------------------------\n\nTITLE: Initializing a RedwoodJS Form Component in React - TypeScript\nDESCRIPTION: This TypeScript snippet mirrors the JavaScript example but provides static typing support via the TSX syntax. It imports modules from '@redwoodjs/web' and '@redwoodjs/forms', initializing a contact page component that renders an empty RedwoodJS form. The dependencies are the same as the JavaScript version, and it serves as a foundational structure upon which fields can be added.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n      // highlight-next-line\n      <Form></Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Validating and Creating a User with RedwoodJS Service Validations (JavaScript/JSX)\nDESCRIPTION: This code defines a RedwoodJS Service function for creating a user, utilizing several validation functions imported from '@redwoodjs/api'. It demonstrates how to validate input presence, exclude certain reserved names, check string length, and perform custom synchronous/asynchronous validations before creating a user in the database. Dependencies include the RedwoodJS API package and access to both the db client and context for current user information; expected input is an object containing user details, and the output is the result of creating a user record, with thrown errors if any validation fails.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\nimport {\n  validate,\n  validateWith,\n  validateWithSync,\n  validateUniqueness,\n} from '@redwoodjs/api'\n\nexport const createUser = async ({ input }) => {\n  validate(input.firstName, 'First name', {\n    presence: true,\n    exclusion: {\n      in: ['Admin', 'Owner'],\n      message: 'That name is reserved, sorry!',\n    },\n    length: { min: 2, max: 255 },\n  })\n  validateWithSync(() => {\n    if (\n      input.role === 'Manager' &&\n      !context.currentUser.roles.includes('admin')\n    ) {\n      throw 'Only Admins can create new Managers'\n    }\n  })\n  await validateWith(async () => {\n    const inviteCount = await db.invites.count({\n      where: { userId: currentUser.id },\n    })\n    if (inviteCount >= 10) {\n      throw 'You have already invited your max of 10 users'\n    }\n  })\n\n  return validateUniqueness('user', { username: input.username }, (db) => {\n    return db.user.create({ data: input })\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RedwoodJS Scenarios with Nested Creates for Relationships\nDESCRIPTION: This code demonstrates how to handle model relationships within RedwoodJS scenarios using Prisma's nested create syntax. It defines a 'comment' scenario that simultaneously creates an associated 'post' record, establishing the relationship between them during seeding.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_59\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = defineScenario({\n  comment: {\n    first: {\n      data: {\n        name: 'Tobbe',\n        body: 'But it uses some letters twice'\n        post: {\n          create: {\n            title: 'Every Letter',\n            body: 'The quick brown fox jumped over the lazy dog.'\n          }\n        }\n      },\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Typed RedwoodJS Cell Component in TypeScript (TSX)\nDESCRIPTION: This snippet illustrates the typed version of a RedwoodJS Cell using TypeScript (TSX). It leverages generated GraphQL types (`FindPosts`, `FindPostsVariables`) and Redwood's utility types (`CellFailureProps`, `CellSuccessProps`, `TypedDocumentNode`) for enhanced type safety. Similar to the JavaScript version, it exports `QUERY`, `Loading`, `Empty`, `Failure`, and `Success` components, but with explicit type annotations for props and the query definition.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { FindPosts, FindPostsVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypedDocumentNode,\n} from '@redwoodjs/web'\n\nexport const QUERY: TypedDocumentNode<FindPosts, FindPostsVariables> = gql`\n  query FindPosts {\n    posts {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>No posts yet!</div>\n\nexport const Failure = ({ error }: CellFailureProps<FindPostsVariables>) => (\n  <div>Error loading posts: {error.message}</div>\n)\n\nexport const Success = ({\n  posts,\n}: CellSuccessProps<FindPosts, FindPostsVariables>) => {\n  return posts.map((post) => (\n    <article key={post.id}>\n      <h2>{post.title}</h2>\n      <div>{post.body}</div>\n    </article>\n  ))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Testing the Comment Component with RedwoodJS Testing - TypeScript\nDESCRIPTION: This TypeScript test leverages @redwoodjs/testing to ensure that the Comment component renders the author\\'s name, body, and a correctly formatted creation date. Additional assertions confirm that the formatted date appears in a <time> tag with the matching 'datetime' attribute, preserving semantic structure. The test expects the formatted date for '2020-01-02T12:34:56Z' to be '2 January 2020', matching the date formatting utility in the component. The use of TypeScript ensures stricter type checking during the test.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/the-redwood-way.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n// highlight-next-line\nimport { render, screen } from '@redwoodjs/testing'\n\nimport Comment from './Comment'\n\ndescribe('Comment', () => {\n  it('renders successfully', () => {\n    // highlight-start\n    const comment = {\n      name: 'John Doe',\n      body: 'This is my comment',\n      createdAt: '2020-01-02T12:34:56Z',\n    }\n    render(<Comment comment={comment} />)\n\n    expect(screen.getByText(comment.name)).toBeInTheDocument()\n    expect(screen.getByText(comment.body)).toBeInTheDocument()\n    const dateExpect = screen.getByText('2 January 2020')\n    expect(dateExpect).toBeInTheDocument()\n    expect(dateExpect.nodeName).toEqual('TIME')\n    expect(dateExpect).toHaveAttribute('datetime', comment.createdAt)\n    // highlight-end\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Default API Authentication Helpers in RedwoodJS (JavaScript)\nDESCRIPTION: This JavaScript code shows the default implementation of authentication helper functions in `api/src/lib/auth.js`. It includes `getCurrentUser`, which retrieves the user based on the session ID (initially selecting only the `id`), `isAuthenticated` to check login status, `hasRole` for role-based access control, and `requireAuth` to enforce authentication and roles, throwing errors if checks fail. Dependencies include `@redwoodjs/graphql-server` for error types and `./db` for the Prisma client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/lib/auth.js\"\nimport { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\nimport { db } from './db'\n\nexport const getCurrentUser = async (session) => {\n  return await db.user.findUnique({\n    where: { id: session.id },\n    select: { id: true },\n  })\n}\n\nexport const isAuthenticated = () => {\n  return !!context.currentUser\n}\n\nexport const hasRole = (roles) => {\n  if (!isAuthenticated()) {\n    return false\n  }\n\n  const currentUserRoles = context.currentUser?.roles\n\n  if (typeof roles === 'string') {\n    if (typeof currentUserRoles === 'string') {\n      // roles to check is a string, currentUser.roles is a string\n      return currentUserRoles === roles\n    } else if (Array.isArray(currentUserRoles)) {\n      // roles to check is a string, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) => roles === allowedRole)\n    }\n  }\n\n  if (Array.isArray(roles)) {\n    if (Array.isArray(currentUserRoles)) {\n      // roles to check is an array, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) =>\n        roles.includes(allowedRole)\n      )\n    } else if (typeof currentUserRoles === 'string') {\n      // roles to check is an array, currentUser.roles is a string\n      return roles.some((allowedRole) => currentUserRoles === allowedRole)\n    }\n  }\n\n  // roles not found\n  return false\n}\n\nexport const requireAuth = ({ roles } = {}) => {\n  if (!isAuthenticated()) {\n    throw new AuthenticationError(\"You don't have permission to do that.\")\n  }\n\n  if (roles && !hasRole(roles)) {\n    throw new ForbiddenError(\"You don't have access to do that.\")\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Displaying Toast Notifications on Contact Form Submission in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript snippet builds a typed ContactPage component using RedwoodJS, integrating GraphQL mutation types and leveraging the `onCompleted` callback in the `useMutation` hook to show a toast notification after a successful contact form submission. It requires RedwoodJS and its form and toast modules, as well as GraphQL types for mutation variables and results. The form validates `name`, `email`, and `message` fields, and on successful creation, shows a user notification via the <Toaster/>. The `onSubmit` handler is typed using SubmitHandler for better type safety. All inputs and outputs mirror the JavaScript version, but with enhanced TypeScript type definitions for safer form handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata, useMutation } from '@redwoodjs/web'\\n// highlight-next-line\\nimport { toast, Toaster } from '@redwoodjs/web/toast'\\nimport {\\n  FieldError,\\n  Form,\\n  Label,\\n  TextField,\\n  TextAreaField,\\n  Submit,\\n  SubmitHandler,\\n} from '@redwoodjs/forms'\\n\\nimport {\\n  CreateContactMutation,\\n  CreateContactMutationVariables,\\n} from 'types/graphql'\\n\\nconst CREATE_CONTACT = gql`\\n  mutation CreateContactMutation($input: CreateContactInput!) {\\n    createContact(input: $input) {\\n      id\\n    }\\n  }\\n`\\n\\ninterface FormValues {\\n  name: string\\n  email: string\\n  message: string\\n}\\n\\nconst ContactPage = () => {\\n  // highlight-start\\n  const [create, { loading, error }] = useMutation<\\n    CreateContactMutation,\\n    CreateContactMutationVariables\\n  >(CREATE_CONTACT, {\\n    onCompleted: () => {\\n      toast.success('Thank you for your submission!')\\n    },\\n  })\\n  // highlight-end\\n\\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\\n    create({ variables: { input: data } })\\n  }\\n\\n  return (\\n    <>\\n      <Metadata title=\"Contact\" description=\"Contact page\" />\\n      // highlight-next-line\\n      <Toaster />\\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\\n        <Label name=\"name\" errorClassName=\"error\">\\n          Name\\n        </Label>\\n        <TextField\\n          name=\"name\"\\n          validation={{ required: true }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"name\" className=\"error\" />\\n\\n        <Label name=\"email\" errorClassName=\"error\">\\n          Email\\n        </Label>\\n        <TextField\\n          name=\"email\"\\n          validation={{\\n            required: true,\\n            pattern: {\\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\\n            },\\n          }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"email\" className=\"error\" />\\n\\n        <Label name=\"message\" errorClassName=\"error\">\\n          Message\\n        </Label>\\n        <TextAreaField\\n          name=\"message\"\\n          validation={{ required: true }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"message\" className=\"error\" />\\n\\n        <Submit disabled={loading}>Save</Submit>\\n      </Form>\\n    </>\\n  )\\n}\\n\\nexport default ContactPage\\n\n```\n\n----------------------------------------\n\nTITLE: Importing and Using useAuth Hook in RedwoodJS BlogLayout (JavaScript)\nDESCRIPTION: This snippet demonstrates importing the `useAuth` hook from `src/auth` in a JavaScript-based RedwoodJS `BlogLayout` component. It then destructures `isAuthenticated`, `currentUser`, and `logOut` from the hook to access authentication state and functions within the component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/layouts/BlogLayout/BlogLayout.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-next-line\nimport { useAuth } from 'src/auth'\n\nconst BlogLayout = ({ children }) => {\n  // highlight-next-line\n  const { isAuthenticated, currentUser, logOut } = useAuth()\n\n  return (\n    <>\n      <header>\n        <h1>\n          <Link to={routes.home()}>Redwood Blog</Link>\n        </h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n            <li>\n              <Link to={routes.contact()}>Contact</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a RedwoodJS Cell (ArticleCell) with States in JSX\nDESCRIPTION: This JSX code defines a RedwoodJS Cell component named `ArticleCell`. It includes a GraphQL query (`QUERY`) to fetch an article by ID and exports four distinct components (`Loading`, `Empty`, `Failure`, `Success`) to render different states based on the query result. The `Success` component utilizes an `Article` component to display the fetched data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_35\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticleCell/ArticleCell.js\"\nimport Article from 'src/components/Article'\n\nexport const QUERY = gql`\n  query GetArticle($id: Int!) {\n    article(id: $id) {\n      id\n      title\n      body\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => <div>Error: {error.message}</div>\n\nexport const Success = ({ article }) => {\n  return <Article article={article} />\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Handler with Authentication Functions in RedwoodJS (TypeScript)\nDESCRIPTION: This snippet initializes and exports the main GraphQL handler for the RedwoodJS API by supplying custom authDecoder and getCurrentUser functions to createGraphQLHandler. Dependencies include RedwoodJS core libraries, a defined authDecoder (from an integration or custom), and a getCurrentUser implementation. Inputs are GraphQL HTTP requests with Authorization headers; outputs are GraphQL responses with context populated by currentUser, enabling downstream resolvers to use authentication details.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/authentication.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport const handler = createGraphQLHandler({\n  authDecoder,\n  getCurrentUser,\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Auth Pages with Redwood CLI - Bash\nDESCRIPTION: Issues the Redwood CLI command to generate all authentication pages (Login, Signup, Forgot Password, Reset Password) pre-wired for dbAuth flows, prompting for WebAuthn options. This aids rapid onboarding and bootstrapping of frontend auth features. Pages are routed and customizable post-generation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g dbAuth\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS dbAuth Pages (Bash)\nDESCRIPTION: Executes the RedwoodJS `dbAuth` generator using Yarn. This command scaffolds the necessary pages, components, and configuration files for database-backed user authentication (login, signup, forgot password) within a RedwoodJS application. It requires a RedwoodJS project environment and assumes Yarn is used as the package manager.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g dbAuth\n```\n\n----------------------------------------\n\nTITLE: Saving Uploaded Files Using Pre-configured Savers - RedwoodJS TypeScript\nDESCRIPTION: Demonstrates usage of upload saver utilities within a service to persist uploaded File objects to storage, with automatic path persistence in the database. The function uses the `saveFiles` utility (set up via upload config) to process the input, converting file fields to storage paths, and then performs a Prisma update. This approach is tied to both GraphQL inputs and Prisma models, requiring properly configured savers for each model.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n// highlight-next-line\nimport { saveFiles } from 'src/lib/uploads'\n\nexport const updateProfile: MutationResolvers['updateProfile'] = async ({\n  id,\n  input,\n}) => {\n  // highlight-next-line\n  const processedInput = await saveFiles.forProfile(input)\n\n  // input.avatar (File) becomes a path string 👇\n  // Settings in src/lib/uploads.ts configures where the upload is saved\n  // processedInput.avatar -> '/mySavePath/profile/avatar/generatedId.jpg'\n\n  return db.profile.update({\n    data: processedInput,\n    where: { id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Post Service Resolvers with Prisma in TypeScript\nDESCRIPTION: Provides strongly-typed service resolver implementations for Post GraphQL API endpoints in a RedwoodJS blog application (`posts.ts`) using TypeScript. It imports Prisma, plus resolver type definitions from generated graphql types, ensuring type safety for query and mutation parameters and results. Resolvers are mapped directly to SDL operations and leverage Promise returns from Prisma's Client. Dependencies: TypeScript, RedwoodJS, Prisma, and generated GraphQL types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/side-quest.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { db } from 'src/lib/db'\nimport type { QueryResolvers, MutationResolvers } from 'types/graphql'\n\nexport const posts: QueryResolvers['posts'] = () => {\n  return db.post.findMany()\n}\n\nexport const post: QueryResolvers['post'] = ({ id }) => {\n  return db.post.findUnique({\n    where: { id },\n  })\n}\n\nexport const createPost: MutationResolvers['createPost'] = ({ input }) => {\n  return db.post.create({\n    data: input,\n  })\n}\n\nexport const updatePost: MutationResolvers['updatePost'] = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost: MutationResolvers['deletePost'] = ({ id }) => {\n  return db.post.delete({\n    where: { id },\n  })\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Contact Form with RedwoodJS (TypeScript)\nDESCRIPTION: Defines a functional React component `ContactPage` in TypeScript (TSX) for a RedwoodJS contact form. It imports necessary components from `@redwoodjs/forms` and `@redwoodjs/web`. An interface `FormValues` defines the shape of the form data, and the `SubmitHandler` type is used for the `onSubmit` function, providing type safety. The form structure and basic required validation are similar to the JavaScript version.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_29\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  // highlight-next-line\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-start\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n        // highlight-start\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"email\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n        // highlight-start\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        // highlight-end\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema for Posts in RedwoodJS (GraphQL)\nDESCRIPTION: This GraphQL Schema Definition Language (SDL) code defines the structure for 'Post' data, including its fields (id, title, body, createdAt), available queries (fetching all posts or a single post), and mutations (create, update, delete). It also defines input types for mutations. This schema, wrapped in JavaScript/TypeScript export, serves as the contract for the API endpoint, typically located in `api/src/graphql/posts.sdl.{js,ts}`. The `@requireAuth` directive indicates protected mutations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/side-quest.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    posts: [Post!]!\n    post(id: Int!): Post!\n  }\n\n  input CreatePostInput {\n    title: String!\n    body: String!\n  }\n\n  input UpdatePostInput {\n    title: String\n    body: String\n  }\n\n  type Mutation {\n    createPost(input: CreatePostInput!): Post! @requireAuth\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\n    deletePost(id: Int!): Post! @requireAuth\n  }\n`\n```\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    posts: [Post!]!\n    post(id: Int!): Post!\n  }\n\n  input CreatePostInput {\n    title: String!\n    body: String!\n  }\n\n  input UpdatePostInput {\n    title: String\n    body: String\n  }\n\n  type Mutation {\n    createPost(input: CreatePostInput!): Post! @requireAuth\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\n    deletePost(id: Int!): Post! @requireAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Deletion Mutation in RedwoodJS Component (JSX)\nDESCRIPTION: This updated JavaScript React component (`Comment.jsx`) implements comment deletion. It imports `useMutation` from `@redwoodjs/web` and the `CommentsQuery` from `CommentsCell`. It defines a `DELETE` GraphQL mutation string. The `useMutation` hook is called with the mutation and a `refetchQueries` option to update the comment list after deletion. The `moderate` function now calls the `deleteComment` function returned by the hook, passing the comment ID.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { useMutation } from '@redwoodjs/web'\n\nimport { useAuth } from 'src/auth'\n\n// highlight-next-line\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n\n// highlight-start\nconst DELETE = gql`\n  mutation DeleteCommentMutation($id: Int!) {\n    deleteComment(id: $id) {\n      postId\n    }\n  }\n`\n// highlight-end\n\nconst formattedDate = (datetime) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n\nconst Comment = ({ comment }) => {\n  const { hasRole } = useAuth()\n  // highlight-start\n  const [deleteComment] = useMutation(DELETE, {\n    refetchQueries: [\n      {\n        query: CommentsQuery,\n        variables: { postId: comment.postId },\n      },\n    ],\n  })\n  // highlight-end\n\n  const moderate = () => {\n    if (confirm('Are you sure?')) {\n      // highlight-start\n      deleteComment({\n        variables: { id: comment.id },\n      })\n      // highlight-end\n    }\n  }\n\n  return (\n    <div className=\"bg-gray-200 p-8 rounded-lg relative\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n      {hasRole('moderator') && (\n        <button\n          type=\"button\"\n          onClick={moderate}\n          className=\"absolute bottom-2 right-2 bg-red-500 text-xs rounded text-white px-2 py-1\"\n        >\n          Delete\n        </button>\n      )}\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Testing Comment Component Rendering and Role Logic in Jest (JavaScript)\nDESCRIPTION: This Jest test suite verifies the rendering of the `Comment` component in a RedwoodJS application using JavaScript. It uses `@redwoodjs/testing` utilities like `render`, `screen`, and `waitFor`. The tests check if the comment's name, body, and formatted date are displayed correctly. It also includes tests to ensure the 'Delete' button is conditionally rendered: hidden for logged-out users and visible for users mocked with the 'moderator' role using `mockCurrentUser`. The `waitFor` function is necessary because role checking involves asynchronous GraphQL calls.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_22\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Comment/Comment.test.jsx\"\n// highlight-next-line\nimport { render, screen, waitFor } from '@redwoodjs/testing'\n\nimport Comment from './Comment'\n\n// highlight-start\nconst COMMENT = {\n  name: 'John Doe',\n  body: 'This is my comment',\n  createdAt: '2020-01-02T12:34:56Z',\n}\n// highlight-end\n\ndescribe('Comment', () => {\n  it('renders successfully', () => {\n    // highlight-next-line\n    render(<Comment comment={COMMENT} />)\n\n    // highlight-start\n    expect(screen.getByText(COMMENT.name)).toBeInTheDocument()\n    expect(screen.getByText(COMMENT.body)).toBeInTheDocument()\n    // highlight-end\n    const dateExpect = screen.getByText('2 January 2020')\n    expect(dateExpect).toBeInTheDocument()\n    expect(dateExpect.nodeName).toEqual('TIME')\n    // highlight-next-line\n    expect(dateExpect).toHaveAttribute('datetime', COMMENT.createdAt)\n  })\n\n  // highlight-start\n  it('does not render a delete button if user is logged out', async () => {\n    render(<Comment comment={COMMENT} />)\n\n    await waitFor(() =>\n      expect(screen.queryByText('Delete')).not.toBeInTheDocument()\n    )\n  })\n\n  it('renders a delete button if the user is a moderator', async () => {\n    mockCurrentUser({\n      id: 1,\n      email: 'moderator@moderator.com',\n      roles: 'moderator',\n    })\n    render(<Comment comment={COMMENT} />)\n\n    await waitFor(() => expect(screen.getByText('Delete')).toBeInTheDocument())\n  })\n  // highlight-end\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Private Routes with PrivateSet in RedwoodJS (JSX)\nDESCRIPTION: This snippet demonstrates how to use the <PrivateSet> component from '@redwoodjs/router' to protect a group of routes. The <PrivateSet> wraps the admin-related routes for posts. The 'unauthenticated' prop specifies the route name ('home') to redirect to if the user is not logged in. This requires the 'useAuth' hook to be configured with the Router.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { PrivateSet, Router, Route, Set } from '@redwoodjs/router'\n\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nimport { useAuth } from './auth'\n\nconst Routes = () => {\n  return (\n    <Router useAuth={useAuth}>\n      // highlight-next-line\n      <PrivateSet unauthenticated=\"home\">\n        <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n          <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n          <Route path=\"/admin/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n          <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n          <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\n        </Set>\n      // highlight-next-line\n      </PrivateSet>\n      <Set wrap={BlogLayout}>\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { PrivateSet, Router, Route, Set } from '@redwoodjs/router'\n\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nimport { useAuth } from './auth'\n\nconst Routes = () => {\n  return (\n    <Router useAuth={useAuth}>\n      // highlight-next-line\n      <PrivateSet unauthenticated=\"home\">\n        <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n          <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n          <Route path=\"/admin/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n          <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n          <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\n        </Set>\n      // highlight-next-line\n      </PrivateSet>\n      <Set wrap={BlogLayout}>\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Generating User CRUD Scaffold - Zsh Shell\nDESCRIPTION: Generates complete CRUD pages and services for the User model using RedwoodJS scaffolding. Prerequisites: User model in schema.prisma, Prisma migration applied. Output: React pages/components, GraphQL SDL, and service files for User. Input: command from project root.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_4\n\nLANGUAGE: zsh\nCODE:\n```\nyarn rw g scaffold User\n```\n\n----------------------------------------\n\nTITLE: Adding a TextField to a RedwoodJS Form (JSX)\nDESCRIPTION: This snippet demonstrates adding a text input field to the `ContactPage` form using the `TextField` component from `@redwoodjs/forms`. The `TextField` is given a `name` attribute set to \"input\".\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form>\n        // highlight-next-line\n        <TextField name=\"input\" />\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Including Firebase Environment Variables in Redwood Web Config - TOML\nDESCRIPTION: This snippet modifies the redwood.toml configuration file to ensure that the Firebase API key and auth domain are available to the web-side code. The 'includeEnvironmentVariables' array within the '[web]' config block is updated so that the frontend has access to the required Firebase environment variables. Add both 'FIREBASE_API_KEY' and 'FIREBASE_AUTH_DOMAIN' as shown; these are needed for Firebase auth operations in the browser.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/firebase.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n  # ...\n  includeEnvironmentVariables = [\"FIREBASE_API_KEY\", \"FIREBASE_AUTH_DOMAIN\"]\n```\n\n----------------------------------------\n\nTITLE: Defining a GraphQL Query for Posts in RedwoodJS Cell (JavaScript/JSX)\nDESCRIPTION: This snippet defines a GraphQL query for retrieving a list of posts, including an intentionally untyped field 'unTypedField' to demonstrate error behavior in RedwoodJS Cells. The QUERY constant is typically exported from a Cell file and consumed by Redwood to execute data fetching. Requires the presence of gql from an appropriate GraphQL client and illustrates input fields (id, title, unTypedField); failure to type a field will cause this Cell to render its Failure state.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nconst QUERY = gql`\n  query {\n    posts {\n      id\n      title\n      unTypedField\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Applying @requireAuth Directive to Mutations in RedwoodJS GraphQL Schema\nDESCRIPTION: Shows a GraphQL schema definition (likely SDL within a `.ts` or `.graphql` file) where the `@requireAuth` directive is applied to mutations (`createPost`, `updatePost`, `deletePost`). This ensures that only authenticated users can perform these operations, relying on the `requireAuth` function implemented in `api/src/lib/auth.ts`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_55\n\nLANGUAGE: ts\nCODE:\n```\ntype Post {\n  id: Int!\n  title: String!\n  body: String!\n  authorId: Int!\n  author: User!\n  createdAt: DateTime!\n}\n\ninput CreatePostInput {\n  title: String!\n  body: String!\n  authorId: Int!\n}\n\ninput UpdatePostInput {\n  title: String\n  body: String\n  authorId: Int\n}\n\ntype Mutation {\n  createPost(input: CreatePostInput!): Post! @requireAuth\n  updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\n  deletePost(id: Int!): Post! @requireAuth\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator (Basic) in JSX\nDESCRIPTION: Shows the `numericality` validator checking if a number is within a range using `greaterThan` and `lessThanOrEqual` conditions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_29\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.year, 'Year', {\n  numericality: { greaterThan: 1900, lessThanOrEqual: 2021 },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Custom Label Tag With Inner Text (HTML)\nDESCRIPTION: Demonstrates providing text content within standard <label> tags, with error class handling via 'errorClassName'. When applied in Redwood forms, any text between label tags appears as the label's visible content. Shows how labels can be explicitly customized for greater clarity and accessibility.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<label name=\"name\" className=\"input\" errorClassName=\"input error\"\n  >Your Name</label\n>\n\n<!-- Renders: <label for=\"name\" class=\"input\">Your Name</label> -->\n```\n\n----------------------------------------\n\nTITLE: Integrating Controlled Third-Party ToggleButton with RedwoodJS Forms (TypeScript, TSX)\nDESCRIPTION: Demonstrates integrating a controlled UI component from 'primereact' with RedwoodJS forms by combining React Hook Form's Controller with Redwood error styling utilities. The ToggleButtonField component receives validation, errorClassName, and other props, and relays errors and value control according to RedwoodJS conventions. Dependencies include 'primereact', '@redwoodjs/forms', and React Hook Form; intended for robust form customization and third-party library support. Written in TypeScript with proper type interfaces.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ToggleButton } from 'primereact/togglebutton'\nimport type { ToggleButtonProps } from 'primereact/togglebutton'\n\nimport { Controller, RegisterOptions, useErrorStyles } from '@redwoodjs/forms'\n\ninterface Props extends ToggleButtonProps {\n  validation?: RegisterOptions\n  errorClassName?: string\n}\n\nconst ToggleButtonField = (props: Props) => {\n  const {\n    name,\n    className,\n    errorClassName,\n    defaultValue,\n    validation,\n    style,\n    ...propsRest\n  } = props\n\n  const { className: componentClassName, style: componentStyle } =\n    useErrorStyles({\n      className: className,\n      errorClassName: errorClassName,\n      name: name,\n    })\n\n  return (\n    <Controller\n      name={name}\n      defaultValue={defaultValue}\n      rules={validation}\n      render={({ field: { onChange, onBlur, value, name, ref } }) => (\n        <ToggleButton\n          {...propsRest}\n          checked={value}\n          onChange={onChange}\n          onBlur={onBlur}\n          ref={ref}\n          name={name}\n          className={componentClassName}\n          style={{ ...componentStyle, ...style }}\n        />\n      )}\n    />\n  )\n}\n\nexport default ToggleButtonField\n```\n\n----------------------------------------\n\nTITLE: Adding Labels to RedwoodJS Form Fields (TypeScript)\nDESCRIPTION: This snippet demonstrates adding standard HTML `<label>` elements with the `htmlFor` attribute to associate them with their respective form fields (`TextField`, `TextAreaField`) within a TypeScript RedwoodJS form component, enhancing accessibility.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-next-line\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" />\n        // highlight-next-line\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" />\n        // highlight-next-line\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Project Data with GraphQL - GraphQL - graphql\nDESCRIPTION: This GraphQL query fetches detailed information about a project by name, including its id, title, description, owner details, and associated tags. It demonstrates how to nest fields for rich, structured data retrieval. The key parameter is the project 'name' argument, and the query expects a server-side resolver capable of returning the full project object graph.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery GetProject {\n  project(name: \"GraphQL\") {\n    id\n    title\n    description\n    owner {\n      id\n      username\n    }\n    tags {\n      id\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Idempotent Seeding with Upsert (JavaScript)\nDESCRIPTION: Provides an example of seeding category data idempotently using Prisma's `upsert` method within the RedwoodJS seed script. It iterates over an array of category data and for each item, checks if a category with the unique `name` exists. If it exists, it updates the record; otherwise, it creates a new one. This ensures the seed script can be run multiple times without creating duplicates or errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/database-seeds.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// title=\"scripts/seed.js\"\nexport default async () => {\n  try {\n    const data = [\n      { name: 'Art', bisacCode: 'ART000000' },\n      { name: 'Biography', bisacCode: 'BIO000000' },\n      { name: 'Fiction', bisacCode: 'FIC000000' },\n      { name: 'Nature', bisacCode: 'NAT000000' },\n      { name: 'Travel', bisacCode: 'TRV000000' },\n      { name: 'World History', bisacCode: 'HIS037000' },\n    ]\n\n    for (const item of data) {\n      await db.category.upsert({\n        where: { name: item.name },\n        update: { code: item.code },\n        create: { name: item.name, code: item.code },\n      })\n    }\n  } catch (error) {\n    console.error(error)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Redwood Directives to GraphQL Query and Type Field (Authorization)\nDESCRIPTION: This GraphQL SDL snippet shows how to use the `@requireAuth` directive at both the query and field level for fine-grained access control in RedwoodJS. Access to the `user` query is restricted to authenticated users. Furthermore, accessing the `email` field itself requires the authenticated user to possess the 'ADMIN' role. Users without the 'ADMIN' role can query other fields of the `User` type but will be forbidden if they attempt to include `email` in their request.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_13\n\nLANGUAGE: graphql\nCODE:\n```\n  type User {\n    id: Int!\n    name: String!\n    email: String! @requireAuth(role: \"ADMIN\")\n    createdAt: DateTime!\n  }\n\n  type Query {\n    user(id: Int!): User @requireAuth\n  }\n```\n\n----------------------------------------\n\nTITLE: Rendering Book Information Conditionally - RedwoodJS - TypeScript\nDESCRIPTION: Renders a book component upon completion of data loading, displaying title, author, and publicationYear fields from the data object. Designed for use within RedwoodJS and Apollo's useQuery or useFragment hooks. Demonstrates JSX with inline expressions and keying for React rendering. Expects 'loading' and 'data' variables in scope.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\n{!loading  && (\\n  <div key={`book-id-${id}`}>\\n    <h3>Title: {data.title}</h3>\\n    <p>by {data.author} ({data.publicationYear})<>\\n  </div>\\n)}\\n\n```\n\n----------------------------------------\n\nTITLE: Transactional Uniqueness Checking with Prisma Directly in JavaScript/JSX\nDESCRIPTION: This example shows the underlying Prisma transaction logic that validates uniqueness. It runs a query to check for an existing user, throws a ServiceValidationError if found, otherwise creates a user. Used to illustrate what validateUniqueness abstracts over. Requires Prisma Client available as db and ServiceValidationError error type.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_52\n\nLANGUAGE: jsx\nCODE:\n```\nreturn await db.$transaction(async (db) => {\n  if (await db.user.findFirst({ username: input.username })) {\n    throw new ServiceValidationError('Username is not unique')\n  } else {\n    return db.user.create({ data: input })\n  }\n})\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Article with Comment Components in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript version of the Article component displays the article and, unless in summary mode, includes CommentForm and CommentsCell, forwarding article.id as postId. The component relies on RedwoodJS Router, the truncate utility, and standard React types. Parameters are typed similarly to the JavaScript example. The output ensures that both the comment form and the comment list are tied to the correct blog post, mirroring the functional pattern as the JavaScript version.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_31\n\nLANGUAGE: tsx\nCODE:\n```\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\\\"text-xl text-blue-700 font-semibold\\\">\\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\\n        </h2>\\n      </header>\\n      <div className=\\\"mt-2 text-gray-900 font-light\\\">\\n        {summary ? truncate(article.body, 100) : article.body}\\n      </div>\\n      {!summary && (\\n        <div className=\\\"mt-12\\\">\\n          <CommentForm postId={article.id} />\\n          <div className=\\\"mt-12\\\">\\n            // highlight-next-line\\n            <CommentsCell postId={article.id} />\\n          </div>\\n        </div>\\n      )}\\n    </article>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Including User Data in Single Post Query with Prisma (JavaScript)\nDESCRIPTION: This snippet demonstrates including related user information directly when fetching a single post with Prisma. By specifying the `include: { user: true }` option, the returned post object will always embed its associated user's data. Required dependencies are Prisma and a correctly configured database schema with the user-post relationship. This implementation may not optimize data usage, as user data is fetched even if not explicitly requested, and can disrupt further nesting in deeply nested GraphQL queries.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nexport const post = ({ id }) => {\n  return db.post.findUnique({\n    where: { id },\n    include: {\n      user: true,\n    },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pagination Component UI - RedwoodJS - TypeScript\nDESCRIPTION: Implements a paginated navigation component in TypeScript for RedwoodJS, generating links for each page based on the count of posts. Uses strong typing for the 'count' prop and leverages Redwood's routing utilities. The component is exportable, ready for inclusion in other components like BlogPostsCell.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n\nconst POSTS_PER_PAGE = 5\n\nconst Pagination = ({ count }: { count: number }) => {\n  const items = []\n\n  for (let i = 0; i < Math.ceil(count / POSTS_PER_PAGE); i++) {\n    items.push(\n      <li key={i}>\n        <Link to={routes.home({ page: i + 1 })}>{i + 1}</Link>\n      </li>\n    )\n  }\n\n  return (\n    <>\n      <h2>Pagination</h2>\n      <ul>{items}</ul>\n    </>\n  )\n}\n\nexport default Pagination\n```\n\n----------------------------------------\n\nTITLE: Extracting Ownership Verification Logic into a Helper Function\nDESCRIPTION: This snippet introduces a dedicated `verifyOwnership` async function to encapsulate the logic for checking if the current user owns a post identified by `id`. It uses the `adminPost` service function internally and throws a `ForbiddenError` if ownership cannot be verified. The `updatePost` function is then simplified to call `await verifyOwnership({ id })` before proceeding with the database update. This refactoring promotes code reuse, as the same verification logic is needed for `deletePost`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_27\n\nLANGUAGE: javascript\nCODE:\n```\n// highlight-start\nconst verifyOwnership = async ({ id }) => {\n  if (await adminPost({ id })) {\n    return true\n  } else {\n    throw new ForbiddenError(\"You don't have access to this post\")\n  }\n}\n// highlight-end\n\nexport const updatePost = async ({ id, input }) => {\n  // highlight-next-line\n  await verifyOwnership({ id })\n\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Comments Service Retrieval (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates a Jest test suite for a RedwoodJS service, analogous to the JavaScript version. It uses Redwood's `scenario` function with type annotations (`StandardScenario`) to test the `comments()` service function. The test ensures that the function retrieves all comments seeded by the scenario.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.test.ts\"\nimport { comments } from './comments'\n\ndescribe('comments', () => {\n  scenario('returns all comments', async (scenario: StandardScenario) => {\n    const result = await comments()\n\n    expect(result.length).toEqual(Object.keys(scenario.comment).length)\n  })\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Removing Email Pattern Validation from ContactPage Form - JavaScript\nDESCRIPTION: This diff snippet demonstrates how to temporarily remove the email pattern validation from the client-side RedwoodJS ContactPage component in JavaScript, allowing invalid email addresses to be sent to the server for validation. It focuses on editing the validation prop of the TextField for the email field by deleting the client-side regex and error message. This is useful for testing server-side validation behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_25\n\nLANGUAGE: diff\nCODE:\n```\n<TextField\\n  name=\"email\"\\n  validation={{\\n    required: true,\\n-    pattern: {\\n-      value: /^[^@]+@[^.]+\\..+$/,\\n-      message: 'Please enter a valid email address',\\n-    },\\n  }}\\n  errorClassName=\"error\"\\n/>\n```\n\n----------------------------------------\n\nTITLE: Building a Validated Comment Form using RedwoodJS Forms - JavaScript (JSX)\nDESCRIPTION: This JSX code defines a CommentForm React component using RedwoodJS form components to collect a user's name and comment with required validation. Dependencies include RedwoodJS's @redwoodjs/forms package. The form enforces validation for both 'name' and 'body' fields, and includes styled labels and input controls. The component is designed to be 100% width, with input validation handled via the 'validation' prop on each field. It does not handle submit logic, and must be connected to external submit functionality. Inputs: 'name', 'body'; Outputs: None (yet, as submission is not defined).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst CommentForm = () => {\n  return (\n    <div>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      <Form className=\"mt-4 w-full\">\n        <Label name=\"name\" className=\"block text-sm text-gray-600 uppercase\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-xs \"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-sm text-gray-600 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-xs\"\n          validation={{ required: true }}\n        />\n\n        <Submit\n          className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\"\n        >\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n\n----------------------------------------\n\nTITLE: Configuring MSAL.js PublicClientApplication with B2C Authority - JSX\nDESCRIPTION: This JavaScript/TypeScript code demonstrates the initialization of MSAL.js's PublicClientApplication for Azure AD B2C integration on the web side. It uses environment variables to set the clientId, authority, redirectUri, postLogoutRedirectUri, and most importantly knownAuthorities for B2C support. This setup is required for MSAL to recognize and correctly handle Azure B2C endpoints, allowing use of hosted user flows. It relies on environment variable injection and the msal-browser package being installed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/azure.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nconst azureActiveDirectoryClient = new PublicClientApplication({\n  auth: {\n    clientId: process.env.AZURE_ACTIVE_DIRECTORY_CLIENT_ID,\n    authority: process.env.AZURE_ACTIVE_DIRECTORY_AUTHORITY,\n    redirectUri: process.env.AZURE_ACTIVE_DIRECTORY_REDIRECT_URI,\n    postLogoutRedirectUri:\n      process.env.AZURE_ACTIVE_DIRECTORY_LOGOUT_REDIRECT_URI,\n    // highlight-next-line\n    knownAuthorities: [process.env.AZURE_ACTIVE_DIRECTORY_KNOWN_AUTHORITY],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Input Fields to RedwoodJS Contact Form in JavaScript\nDESCRIPTION: Expands the contact form to include 'name', 'email', and 'message' fields, with the use of TextAreaField for longer input. The JavaScript implementation demonstrates RedwoodJS form field components and renders each form element without validation. Outputs the full data object to the console upon submission. Necessary dependencies are still @redwoodjs/web and @redwoodjs/forms.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField, TextAreaField, Submit } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-start\n        <TextField name=\"name\" />\n        <TextField name=\"email\" />\n        <TextAreaField name=\"message\" />\n        // highlight-end\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Mutation Constant in RedwoodJS Contact Page (JSX)\nDESCRIPTION: This snippet shows the definition of the `CREATE_CONTACT` GraphQL mutation as a constant within the `ContactPage.jsx` component. It uses the `gql` tag to define the mutation structure, which takes an `input` object of type `CreateContactInput!` and requests the `id` of the created contact upon success. This constant is defined outside the component function, typically after imports.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\n// highlight-start\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n// highlight-end\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Integrating AuthProvider in Redwood App Component (JSX)\nDESCRIPTION: Shows the modified `web/src/App.[js/tsx]` file after running the `setup auth` command. It highlights the import of `AuthProvider` and `useAuth` from `./auth` and how `AuthProvider` wraps the application components, making authentication context available. The `useAuth` hook is passed to `RedwoodApolloProvider` to integrate authentication with GraphQL requests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { FatalErrorBoundary, RedwoodProvider } from '@redwoodjs/web'\nimport { RedwoodApolloProvider } from '@redwoodjs/web/apollo'\n\nimport FatalErrorPage from 'src/pages/FatalErrorPage'\nimport Routes from 'src/Routes'\n\nimport { AuthProvider, useAuth } from './auth'\n\nimport './index.css'\n\nconst App = () => (\n  <FatalErrorBoundary page={FatalErrorPage}>\n    <RedwoodProvider titleTemplate=\"%PageTitle | %AppTitle\">\n      <AuthProvider>\n        <RedwoodApolloProvider useAuth={useAuth}>\n          <Routes />\n        </RedwoodApolloProvider>\n      </AuthProvider>\n    </RedwoodProvider>\n  </FatalErrorBoundary>\n)\n\nexport default App\n```\n\n----------------------------------------\n\nTITLE: Importing and Using useAuth Hook in Redwood BlogLayout - TypeScript\nDESCRIPTION: This snippet implements the BlogLayout component in TypeScript, using the useAuth hook to extract authentication state, user information, and logout methods. A BlogLayoutProps type ensures type safety for the children prop. It sets up site navigation and expects a RedwoodJS authentication provider, @redwoodjs/router, and React types. Expects children of type React.ReactNode.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\\n\\n// highlight-next-line\\nimport { useAuth } from 'src/auth'\\n\\ntype BlogLayoutProps = {\\n  children?: React.ReactNode\\n}\\n\\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\\n  // highlight-next-line\\n  const { isAuthenticated, currentUser, logOut } = useAuth()\\n\\n  return (\\n    <>\\n      <header>\\n        <h1>\\n          <Link to={routes.home()}>Redwood Blog</Link>\\n        </h1>\\n        <nav>\\n          <ul>\\n            <li>\\n              <Link to={routes.home()}>Home</Link>\\n            </li>\\n            <li>\\n              <Link to={routes.about()}>About</Link>\\n            </li>\\n            <li>\\n              <Link to={routes.contact()}>Contact</Link>\\n            </li>\\n          </ul>\\n        </nav>\\n      </header>\\n      <main>{children}</main>\\n    </>\\n  )\\n}\\n\\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Running Prisma Database Migration with RedwoodJS CLI (Bash)\nDESCRIPTION: Executes the RedwoodJS command `yarn rw prisma migrate dev` to generate and apply database migrations based on changes made to the `schema.prisma` file. This command creates a migration file, updates the database schema, and ensures the development database reflects the latest model definitions. It prompts the user for a descriptive name for the migration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Adding a Text Field to a RedwoodJS Form - TypeScript\nDESCRIPTION: This TypeScript snippet adds a <TextField> form field with the name 'input' to the RedwoodJS form in a React functional component. It demonstrates typing advantages and setup in TypeScript environments, using '@redwoodjs/web' and '@redwoodjs/forms'. The field accepts user input but does not yet process submission or validation. This lays the groundwork for further extension with type safety.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form>\n        // highlight-next-line\n        <TextField name=\"input\" />\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Using Prisma Result Extensions for File Data Access - RedwoodJS TypeScript\nDESCRIPTION: Demonstrates how to use methods like `withDataUri()` on the result of a Prisma query amplified by the custom storage extension. The snippet queries a profile then applies the helper to transform file paths to data URI strings. Ensures the method is only called on awaited results for supported models/fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const profile = async ({ id }) => {\n  // 👇 await the result from your prisma query\n  const profile = await db.profile.findUnique({\n    where: { id },\n  })\n\n  // Convert the avatar field (which was persisted as a path) to data uri string\n  // highlight-next-line\n  return profile?.withDataUri()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Comment Form Component (JSX)\nDESCRIPTION: This snippet shows the JavaScript (JSX) implementation of the `CommentForm` React component. It uses RedwoodJS form helpers (`Form`, `Label`, `TextField`, `TextAreaField`, `Submit`) to create a form with 'Name' and 'Comment' fields. Basic styling is applied using Tailwind CSS classes, and simple client-side validation (`required: true`) is added to the input fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/CommentForm/CommentForm.jsx\"\nimport {\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst CommentForm = () => {\n  return (\n    <div>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      <Form className=\"mt-4 w-full\">\n        <Label name=\"name\" className=\"block text-sm text-gray-600 uppercase\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-xs \"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-sm text-gray-600 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-xs\"\n          validation={{ required: true }}\n        />\n\n        <Submit\n          className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\"\n        >\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Fragment Registry and Registration Utilities - RedwoodJS Apollo - TypeScript/JavaScript\nDESCRIPTION: This code demonstrates how to import utilities for managing GraphQL fragments in RedwoodJS via the '@redwoodjs/web/apollo' package. fragmentRegistry enables direct interactions with the fragment registry; registerFragment provides a mechanism to define and register fragments programmatically. This supports automatic registry and Apollo compatibility. No configuration is needed other than having '@redwoodjs/web' installed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { fragmentRegistry, registerFragment } from '@redwoodjs/web/apollo'\\n\n```\n\n----------------------------------------\n\nTITLE: Using useMutation Hook in RedwoodJS Contact Page (JSX)\nDESCRIPTION: This snippet illustrates how to use the `useMutation` hook provided by RedwoodJS within the `ContactPage.jsx` component. It imports `useMutation` and calls it with the previously defined `CREATE_CONTACT` mutation constant. The hook returns an array, where the first element is the function (`create`) used to trigger the mutation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\n// highlight-next-line\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\nconst ContactPage = () => {\n  // highlight-next-line\n  const [create] = useMutation(CREATE_CONTACT)\n\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Creating and Validating Car Submissions - RedwoodJS Service - JavaScript\nDESCRIPTION: This snippet defines an exported createCar function that uses RedwoodJS-style validate calls to enforce constraints on car form input fields before saving to the database. It includes inclusion, exclusion, format, absence, and numericality checks, demonstrating enforcement of valid makes, color disallowances, absence of damage, VIN formatting/length, and odometer restrictions. Dependencies include access to a validate method and a db (database) object. Inputs are expected to be in an input object, and the function returns the result of a db.car.create() operation. The function will throw validation exceptions if any field fails its constraints.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_27\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const createCar = ({ input }) => {\n  validate(input.make, 'make', {\n    inclusion: ['Audi', 'BMW', 'Ferrari', 'Lexus', 'Tesla'],\n  })\n  validate(input.color, 'color', {\n    exclusion: { in: ['Beige', 'Mauve'], message: 'No one wants that color' },\n  })\n  validate(input.hasDamage, 'hasDamage', {\n    absence: true,\n  })\n  validate(input.vin, 'vin', {\n    format: /[A-Z0-9]+/,\n    length: { equal: 17 },\n  })\n  validate(input.odometer, 'odometer', {\n    numericality: { positive: true, lessThanOrEqual: 10000 },\n  })\n\n  return db.car.create({ data: input })\n}\n```\n\n----------------------------------------\n\nTITLE: Building the API Side in a Separate Docker Build Stage - Dockerfile\nDESCRIPTION: This code defines the 'api_build' stage, extending from the previously defined base layer. It permits adding build-time arguments, copies the full ./api directory into the build context, and then executes 'yarn rw build api' to compile the API side of a RedwoodJS project. All file copying uses chown for node user security. This stage is designed to be reused or further copied in later production stages, and expects the Yarn install step to have been completed in the base image. No secrets are included; environment variables can be provided via ARG or build args if needed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_7\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM base as api_build\n\n# If your api side build relies on build-time environment variables,\n# specify them here as ARGs.\n#\n# ARG MY_BUILD_TIME_ENV_VAR\n\nCOPY --chown=node:node api api\nRUN yarn rw build api\n```\n\n----------------------------------------\n\nTITLE: Implementing Netlify Identity Sign Up Flow in RedwoodJS Home Page - TypeScript/TSX\nDESCRIPTION: This TypeScript/TSX snippet defines a RedwoodJS page component that triggers the Netlify Identity sign-up modal using the useAuth hook from Redwood's auth system. The component displays authentication status and provides a button to invoke signUp. Required dependencies: RedwoodJS, useAuth hook setup, and the project configured for Netlify Identity as described. Input includes user interaction; output is a modal for authentication and visual feedback of sign-in state. Note: This requires the Netlify Identity widget to be enabled and properly configured on the deployed Netlify app.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/netlify.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAuth } from 'src/auth'\n\nconst HomePage = () => {\n  const { isAuthenticated, signUp } = useAuth()\n\n  return (\n    <>\n      {/* MetaTags, h1, paragraphs, etc. */}\n\n      <p>{JSON.stringify({ isAuthenticated })}</p>\n      <button onClick={signUp}>sign up</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Length Validator with `equal` Option in JSX\nDESCRIPTION: Shows the `length` validator using the `equal` option to require the input string to have an exact number of characters.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_26\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.pin, 'PIN', {\n  length: { equal: 4 },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Example Output of Generating a RedwoodJS Component (Shell)\nDESCRIPTION: Illustrates the console output produced when successfully generating a 'user' component using the RedwoodJS CLI. It shows the execution steps and confirms the creation of the component's JavaScript and test files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood generate component user\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood g component user\n✔ Generating component files...\n✔ Writing $(./web/src/components/User/User.test.js)...\n✔ Writing $(./web/src/components/User/User.js)...\nDone in 1.02s.\n```\n\n----------------------------------------\n\nTITLE: Using isBrowser Boolean for Non-Component Client Detection (JavaScript/JSX)\nDESCRIPTION: Usage example of the isBrowser boolean utility to safely run browser-only initialization code outside React components (e.g., in module scope). Prevents execution of code like netlifyIdentity.init() during SSR/prerender. Must import isBrowser from '@redwoodjs/prerender/browserUtils'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { isBrowser } from '@redwoodjs/prerender/browserUtils'\n\nif (isBrowser) {\n  netlifyIdentity.init()\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a Comment in RedwoodJS Service (TypeScript)\nDESCRIPTION: Adds a typed `deleteComment` function to 'api/src/services/comments/comments.ts'. It accepts an object with an `id` property, typed using `Prisma.CommentWhereUniqueInput`, and utilizes `db.comment.delete({ where: { id } })` to perform the deletion in the database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/services/comments/comments.ts\"\nexport const deleteComment = ({ id }: Prisma.CommentWhereUniqueInput) => {\n  return db.comment.delete({\n    where: { id },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Rendering Article with Author Attribution in RedwoodJS Component (JSX)\nDESCRIPTION: This component renders an article and displays the author's name below the title using values from the queried data. It uses RedwoodJS's Link and routes, assumes the `article` prop includes nested `user.name`, and defines HTML structure for presenting the post and author. Dependencies are RedwoodJS Router and a compatible data schema for posts and users. The author's name is always rendered, requiring that all article objects include user metadata.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n\nconst Article = ({ article }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n          // highlight-start\n          <span className=\"ml-2 text-gray-400 font-normal\">\n            by {article.user.name}\n          </span>\n          // highlight-end\n        </h2>\n      </header>\n\n      <div className=\"mt-2 text-gray-900 font-light\">{article.body}</div>\n    </article>\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Defining the User Model with Hashed Password and Salt - Prisma\nDESCRIPTION: Shows the required Prisma schema fields to store a hashed password, salt, reset token, and token expiration for user authentication using dbAuth. Intended for insertion in the Prisma data model definition, this snippet ensures the backend can securely hash and store user credentials. Requires the Prisma ORM, and all fields follow recommended Redwood conventions for dbAuth compatibility.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_1\n\nLANGUAGE: prisma\nCODE:\n```\nmodel User {\n  id             Int @id @default(autoincrement())\n  email          String  @unique\n  hashedPassword      String    // <─┐\n  salt                String    // <─┼─ add these lines\n  resetToken          String?   // <─┤\n  resetTokenExpiresAt DateTime? // <─┘\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Create Comment Mutation to GraphQL Schema (JavaScript SDL)\nDESCRIPTION: Updates the GraphQL schema definition in 'api/src/graphql/comments.sdl.js' using the `gql` tag. It adds a `Mutation` type defining `createComment`, which accepts a non-nullable `CreateCommentInput!` and returns a `Comment!`. The `@skipAuth` directive allows unauthenticated access.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_16\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.js\"\nexport const schema = gql`\n  type Comment {\n    id: Int!\n    name: String!\n    body: String!\n    post: Post!\n    postId: Int!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    comments: [Comment!]! @skipAuth\n  }\n\n  input CreateCommentInput {\n    name: String!\n    body: String!\n    postId: Int!\n  }\n\n  input UpdateCommentInput {\n    name: String\n    body: String\n    postId: Int\n  }\n\n  // highlight-start\n  type Mutation {\n    createComment(input: CreateCommentInput!): Comment! @skipAuth\n  }\n  // highlight-end\n`\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Comment Deletion in RedwoodJS Component (JSX)\nDESCRIPTION: This updated `Comment.jsx` component implements the comment deletion functionality. It defines a `DELETE` GraphQL mutation, uses the `useMutation` hook from `@redwoodjs/web` to get a `deleteComment` function, and configures `refetchQueries` to update the comments list (using `CommentsQuery` imported from `CommentsCell`) after a successful deletion. The `moderate` function now calls `deleteComment` with the comment's ID.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { useMutation } from '@redwoodjs/web'\n\nimport { useAuth } from 'src/auth'\n\n// highlight-next-line\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n\n// highlight-start\nconst DELETE = gql`\n  mutation DeleteCommentMutation($id: Int!) {\n    deleteComment(id: $id) {\n      postId\n    }\n  }\n`\n// highlight-end\n\nconst formattedDate = (datetime) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n\nconst Comment = ({ comment }) => {\n  const { hasRole } = useAuth()\n  // highlight-start\n  const [deleteComment] = useMutation(DELETE, {\n    refetchQueries: [\n      {\n        query: CommentsQuery,\n        variables: { postId: comment.postId },\n      },\n    ],\n  })\n  // highlight-end\n\n  const moderate = () => {\n    if (confirm('Are you sure?')) {\n      // highlight-start\n      deleteComment({\n        variables: { id: comment.id },\n      })\n      // highlight-end\n    }\n  }\n\n  return (\n    <div className=\"bg-gray-200 p-8 rounded-lg relative\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n      {hasRole('moderator') && (\n        <button\n          type=\"button\"\n          onClick={moderate}\n          className=\"absolute bottom-2 right-2 bg-red-500 text-xs rounded text-white px-2 py-1\"\n        >\n          Delete\n        </button>\n      )}\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Using the Format Validator (Basic) in JSX\nDESCRIPTION: Shows the basic usage of the `format` validator. It checks if the input value matches a provided regular expression. In this example, it validates a US phone number format.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.usPhone, 'US Phone Number', {\n  format: /^[0-9-]{10,12}$/,\n})\n\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Route in Routes.tsx (TypeScript/TSX)\nDESCRIPTION: Defines a route for individual articles in `web/src/Routes.tsx`. The path `/article/{id}` includes a route parameter `{id}`, capturing the value from the URL. This route maps to the `ArticlePage` component and is named 'article'. This is the TypeScript version of the route definition.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/Routes.tsx\"\n<Route path=\"/article/{id}\" page={ArticlePage} name=\"article\" />\n```\n\n----------------------------------------\n\nTITLE: Boilerplate RedwoodJS Articles Cell - TypeScript (React TSX)\nDESCRIPTION: This snippet provides the TypeScript version of the ArticlesCell with appropriate type imports for query and cell props. It defines a strongly-typed GraphQL query and all standard RedwoodJS cell components. Dependencies include RedwoodJS, React, and definitions from 'types/graphql'. The 'Success' component expects an array of articles, each containing an 'id', to display as list items.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { ArticlesQuery, ArticlesQueryVariables } from 'types/graphql'\\n\\nimport type {\\n  CellFailureProps,\\n  CellSuccessProps,\\n  TypedDocumentNode,\\n} from '@redwoodjs/web'\\n\\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\\n  gql`\\n    query ArticlesQuery {\\n      articles {\\n        id\\n      }\\n    }\\n  `\\n\\nexport const Loading = () => <div>Loading...</div>\\n\\nexport const Empty = () => <div>Empty</div>\\n\\nexport const Failure = ({\\n  error,\\n}: CellFailureProps<ArticlesQueryVariables>) => (\\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\\n)\\n\\nexport const Success = ({\\n  articles,\\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\\n  return (\\n    <ul>\\n      {articles.map((item) => {\\n        return <li key={item.id}>{JSON.stringify(item)}</li>\\n      })}\\n    </ul>\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Multi-Root GraphQL QUERY in a Cell (JSX)\nDESCRIPTION: This JSX code snippet demonstrates exporting a GraphQL QUERY constant for a RedwoodJS Cell, allowing multiple root queries (posts, authors). It uses the gql template tag to define the query and expects the surrounding Cell and component infrastructure. Inputs are optional as variables are not used here; outputs are posts and authors, which are passed to the Success component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`{\n  query {\n    posts {\n      id\n      title\n    }\n    authors {\n      id\n      name\n    }\n  }\n}`\n```\n\n----------------------------------------\n\nTITLE: Caching Prisma findMany Query Results with Record-Aware Expiry Using cacheFindMany() - JavaScript\nDESCRIPTION: Shows how to use Redwood's `cacheFindMany()` utility to cache bulk query results, invalidating the cache when any underlying record changes. Supports passing plain model references or query conditions, and can be augmented with an explicit expiry. Ensures query results are fresh when data is updated, relying on record timestamp checks.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_71\n\nLANGUAGE: js\nCODE:\n```\nconst post = ({ id }) => {\\n  return cacheFindMany(`users`, db.user)\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Configuring ApolloProvider for Offset Pagination - RedwoodJS - JSX\nDESCRIPTION: Demonstrates how to enable offset pagination in RedwoodJS ApolloProvider by customizing the InMemoryCache with a type policy for the 'search' field. Requires '@apollo/client' and a pagination utility such as 'offsetLimitPagination'. The input is a config object to graphQLClientConfig, affecting cache instantiation during client setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<RedwoodApolloProvider graphQLClientConfig={{\\n  cacheConfig: {\\n    typePolicies: {\\n      Query: {\\n        fields: {\\n          search: {\\n            // Uses the offsetLimitPagination preset from \"@apollo/client/utilities\";\\n            ...offsetLimitPagination()\\n          }\\n        }\\n      }\\n    }\\n  }\\n}}>\n```\n\n----------------------------------------\n\nTITLE: Handling Form Submission with RedwoodJS in TypeScript\nDESCRIPTION: Provides a TypeScript example of a RedwoodJS contact form using typed input and an onSubmit handler. A FormValues interface specifies field types to ensure type safety. The @redwoodjs/web and @redwoodjs/forms packages are required. The SubmitHandler generic guarantees the onSubmit handler receives form data with the correct structure, logging submissions to the console.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField, Submit, SubmitHandler } from '@redwoodjs/forms'\n\n// highlight-start\ninterface FormValues {\n  input: string\n}\n// highlight-end\n\nconst ContactPage = () => {\n  // highlight-start\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n  // highlight-end\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n      // highlight-next-line\n      <Form onSubmit={onSubmit}>\n        <TextField name=\"input\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Defining Project Schema - GraphQL SDL - graphql\nDESCRIPTION: This snippet provides the GraphQL schema (SDL) for defining a Project type, including its fields and a query to fetch a project by name. Dependencies include GraphQL server setup with type definitions for Project, User, and Tag. The schema requires that a User resolver and Tag resolver are also defined, and expects an API that implements these types and the project query resolver.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\ntype Project {\n  id: ID!\n  title: String\n  description: String\n  owner: User!\n  tags: [Tag]\n}\n\n# ... User and Tag type definitions\n\ntype Query {\n  project(name: String!): Project\n}\n```\n\n----------------------------------------\n\nTITLE: Updating GraphQL Query to Fetch More Fields in JavaScript (RedwoodJS Cell)\nDESCRIPTION: This JavaScript snippet shows modifying the `QUERY` constant within a RedwoodJS Cell (`ArticlesCell.jsx`). It adds the fields 'title', 'body', and 'createdAt' to the selection set for the aliased 'articles' field, enabling the component to retrieve and display more detailed article information.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nexport const QUERY = gql`\n  query ArticlesQuery {\n    articles: posts {\n      id\n      // highlight-start\n      title\n      body\n      createdAt\n      // highlight-end\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Configuring Clerk API Keys in .env\nDESCRIPTION: Defines the necessary Clerk API keys as environment variables within the project's `.env` file. The `CLERK_PUBLISHABLE_KEY` is used on the client-side, and the `CLERK_SECRET_KEY` is used on the server-side for verifying tokens.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/clerk.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nCLERK_PUBLISHABLE_KEY=\"...\"\nCLERK_SECRET_KEY=\"...\"\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Contact GraphQL Schema (GraphQL)\nDESCRIPTION: This GraphQL schema defines the types, queries, and mutations for the Contact model generated by the RedwoodJS `generate sdl` command. It includes types for `Contact`, `CreateContactInput`, `UpdateContactInput`, queries for fetching contacts (`contacts`, `contact`), and mutations for creating, updating, and deleting contacts (`createContact`, `updateContact`, `deleteContact`). All queries and mutations initially require authentication via the `@requireAuth` directive. This example shows both JS and TS file variants.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/contacts.sdl.js\"\nexport const schema = gql`\n  type Contact {\n    id: Int!\n    name: String!\n    email: String!\n    message: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    contacts: [Contact!]! @requireAuth\n    contact(id: Int!): Contact @requireAuth\n  }\n\n  input CreateContactInput {\n    name: String!\n    email: String!\n    message: String!\n  }\n\n  input UpdateContactInput {\n    name: String\n    email: String\n    message: String\n  }\n\n  type Mutation {\n    createContact(input: CreateContactInput!): Contact! @requireAuth\n    updateContact(id: Int!, input: UpdateContactInput!): Contact! @requireAuth\n    deleteContact(id: Int!): Contact! @requireAuth\n  }\n`\n```\n```\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/contacts.sdl.ts\"\nexport const schema = gql`\n  type Contact {\n    id: Int!\n    name: String!\n    email: String!\n    message: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    contacts: [Contact!]! @requireAuth\n    contact(id: Int!): Contact @requireAuth\n  }\n\n  input CreateContactInput {\n    name: String!\n    email: String!\n    message: String!\n  }\n\n  input UpdateContactInput {\n    name: String\n    email: String\n    message: String\n  }\n\n  type Mutation {\n    createContact(input: CreateContactInput!): Contact! @requireAuth\n    updateContact(id: Int!, input: UpdateContactInput!): Contact! @requireAuth\n    deleteContact(id: Int!): Contact! @requireAuth\n  }\n`\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Article Route with Path Parameter (RedwoodJS, TypeScript)\nDESCRIPTION: This TypeScript route declaration mirrors the JavaScript snippet, adding a parameterized article route to the RedwoodJS router. The route expects an 'id' param in the URL, enabling navigation to specific articles, with ArticlePage as the target component. All dependencies for the RedwoodJS router and ArticlePage implementation must be present.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/article/{id}\" page={ArticlePage} name=\"article\" />\n```\n\n----------------------------------------\n\nTITLE: Implementing Role-Based Access Control with @requireAuth in RedwoodJS GraphQL Schema\nDESCRIPTION: Shows how to specify required roles using the `roles` argument within the `@requireAuth` directive for GraphQL mutations. For example, `createPost` requires 'AUTHOR' or 'EDITOR', `updatePost` requires 'EDITOR', and `deletePost` requires 'ADMIN', enabling Role-Based Access Control (RBAC) dependent on the `requireAuth` function's role checking logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_58\n\nLANGUAGE: ts\nCODE:\n```\ntype Mutation {\n  createPost(input: CreatePostInput!): Post! @requireAuth(roles: ['AUTHOR', 'EDITOR'])\n  updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth(roles: ['EDITOR']\n  deletePost(id: Int!): Post! @requireAuth(roles: ['ADMIN']\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Server-Side Email Validation in RedwoodJS Service (JavaScript)\nDESCRIPTION: Imports and uses the `validate` function from `@redwoodjs/api` within the `createContact` service function in `contacts.js`. This enforces server-side email format validation on the `input.email` field using the built-in `{ email: true }` directive before attempting to create a contact record in the database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_21\n\nLANGUAGE: js\nCODE:\n```\n// highlight-next-line\nimport { validate } from '@redwoodjs/api'\n\n// ...\n\nexport const createContact = ({ input }) => {\n  // highlight-next-line\n  validate(input.email, 'email', { email: true })\n  return db.contact.create({ data: input })\n}\n\n```\n\n----------------------------------------\n\nTITLE: Full RedwoodJS ContactPage with useForm and Reset (TypeScript)\nDESCRIPTION: Shows the complete ContactPage implementation in TypeScript for RedwoodJS applications, featuring typed GraphQL operations and form handlers. The form employs useForm to access formMethods for validation and reset, integrates custom onSubmit logic, applies validation patterns, and uses Toaster for user feedback. Required dependencies include RedwoodJS web and forms modules, as well as relevant types for mutation variables and payloads.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_39\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport { toast, Toaster } from '@redwoodjs/web/toast'\nimport {\n  FieldError,\n  Form,\n  FormError,\n  Label,\n  Submit,\n  SubmitHandler,\n  TextAreaField,\n  TextField,\n  useForm,\n} from '@redwoodjs/forms'\n\nimport {\n  CreateContactMutation,\n  CreateContactMutationVariables,\n} from 'types/graphql'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const formMethods = useForm()\n\n  const [create, { loading, error }] = useMutation<\n    CreateContactMutation,\n    CreateContactMutationVariables\n  >(CREATE_CONTACT, {\n    onCompleted: () => {\n      toast.success('Thank you for your submission!')\n      formMethods.reset()\n    },\n  })\n\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Toaster />\n      <Form\n        onSubmit={onSubmit}\n        config={{ mode: 'onBlur' }}\n        error={error}\n        formMethods={formMethods}\n      >\n        <FormError error={error} wrapperClassName=\"form-error\" />\n\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit disabled={loading}>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n\n```\n\n----------------------------------------\n\nTITLE: Passing ID Prop from ArticlePage to ArticleCell (TypeScript)\nDESCRIPTION: This updated TypeScript `ArticlePage` component (`web/src/pages/ArticlePage/ArticlePage.tsx`) defines a `Props` interface to type the incoming `id` prop (expected as `number` after potential route param type conversion). It receives the `id` from the route parameter and passes it down to the `ArticleCell`. RedwoodJS uses this prop to supply the value for the `$id` variable in the cell's GraphQL query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ArticlePage/ArticlePage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport ArticleCell from 'src/components/ArticleCell'\n\n// highlight-start\ninterface Props {\n  id: number\n}\n// highlight-end\n\n// highlight-next-line\nconst ArticlePage = ({ id }: Props) => {\n  return (\n    <>\n      <Metadata title=\"Article\" description=\"Article page\" />\n\n      // highlight-next-line\n      <ArticleCell id={id} />\n    </>\n  )\n}\n\nexport default ArticlePage\n```\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query and Prop Mapping with RedwoodJS Cells - JavaScript\nDESCRIPTION: This snippet illustrates how the name of the top-level field in a GraphQL query becomes the name of the prop passed to the Cell Success component. Changing 'posts' to 'articles' in the query will change the prop name accordingly. Applies to RedwoodJS Cell implementation in JavaScript.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nexport const QUERY = gql`\\n  query ArticlesQuery {\\n    // highlight-next-line\\n    posts {\\n      id\\n    }\\n  }\\n`\\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Sign In Form with Auth Integration (RedwoodJS, JavaScript)\nDESCRIPTION: Defines the SigninPage component with a form for user authentication, utilizing useAuth to perform login and navigate upon successful authentication. Includes client-side error handling and form validation. Depends on '@redwoodjs/forms', '@redwoodjs/auth', '@redwoodjs/router', and must run inside a RedwoodJS project with mature authentication setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_28\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from '@redwoodjs/auth'\nimport { navigate, routes } from '@redwoodjs/router'\n\nimport GlobalLayout from 'src/layouts/GlobalLayout/GlobalLayout'\n\nconst SigninPage = () => {\n  const { logIn } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = (data) => {\n    setError(null)\n    logIn({ email: data.email, password: data.password, remember: true })\n      .then(() => navigate(routes.home()))\n      .catch((error) => setError(error.message))\n  }\n\n  return (\n    <GlobalLayout>\n      <h1>Sign In</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign In</Submit>\n      </Form>\n    </GlobalLayout>\n  )\n}\n\nexport default SigninPage\n```\n\n----------------------------------------\n\nTITLE: Querying Current User with Prisma in RedwoodJS - TypeScript\nDESCRIPTION: This TypeScript snippet is functionally identical to the JavaScript version, defining getCurrentUser to retrieve the user record by session ID using Prisma. It expects a session parameter (typically typed) and a properly connected db object. The function returns the user's id and email, supporting type checking for more robust integration into a RedwoodJS API written in TypeScript.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_19\n\nLANGUAGE: ts\nCODE:\n```\nexport const getCurrentUser = async (session) => {\n  return await db.user.findUnique({\n    where: { id: session.id },\n    // highlight-next-line\n    select: { id: true, email: true },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Database Migrations with Redwood Prisma Migrate (Bash)\nDESCRIPTION: Introduces the general syntax for using the `prisma migrate` command namespace within a Redwood project. These commands handle database schema migrations based on changes in `schema.prisma`, generating and applying SQL migration files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_103\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood prisma migrate <command>\n```\n\n----------------------------------------\n\nTITLE: Conditionally Rendering UI Based on User Role in RedwoodJS (JSX)\nDESCRIPTION: This JavaScript React component (`Comment.jsx`) uses the `useAuth` hook from `src/auth` to get the `hasRole` function. It checks if the logged-in user has the 'moderator' role and conditionally renders a 'Delete' button. A placeholder `moderate` function is included for the button's click handler. It also includes a `formattedDate` utility function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { useAuth } from 'src/auth'\n\nconst formattedDate = (datetime) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n\nconst Comment = ({ comment }) => {\n  // highlight-start\n  const { hasRole } = useAuth()\n  const moderate = () => {\n    if (confirm('Are you sure?')) {\n      // TODO: delete comment\n    }\n  }\n  // highlight-end\n\n  return (\n    // highlight-next-line\n    <div className=\"bg-gray-200 p-8 rounded-lg relative\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n      // highlight-start\n      {hasRole('moderator') && (\n        <button\n          type=\"button\"\n          onClick={moderate}\n          className=\"absolute bottom-2 right-2 bg-red-500 text-xs rounded text-white px-2 py-1\"\n        >\n          Delete\n        </button>\n      )}\n      // highlight-end\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Adding Create Comment Functionality to JavaScript Service\nDESCRIPTION: This JavaScript snippet adds the `createComment` function to the comments service. It accepts a single argument `input`, which is an object containing the data for the new comment (e.g., `name`, `body`, `postId`). It uses `db.comment.create` with the provided `input` data to create and persist a new comment record in the database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.js\"\nexport const createComment = ({ input }) => {\n  return db.comment.create({\n    data: input,\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Importing React Hook Form Utilities via RedwoodJS in JavaScript/React\nDESCRIPTION: This snippet demonstrates how to import core hooks such as useForm and useFormContext from the @redwoodjs/forms package. These re-export all React Hook Form utilities for simplified access within RedwoodJS projects. Dependencies required: @redwoodjs/forms package, and, by extension, react-hook-form. No parameters are used. This enables convenient access to lower-level form APIs directly from RedwoodJS forms.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  useForm,\n  useFormContext,\n  /**\n   * Or anything else React Hook Form exports!\n   *\n   * @see {@link https://react-hook-form.com/api}\n   */\n} from '@redwoodjs/forms'\n```\n\n----------------------------------------\n\nTITLE: Complete RedwoodJS ContactPage with useForm Reset (TS)\nDESCRIPTION: Provides the full source code for the `ContactPage` component in TypeScript (`.tsx`). It integrates imports (`useForm`, `useMutation`, GraphQL types), `useForm` initialization, passing `formMethods` to `<Form>`, type definitions for form values and mutation variables, form submission logic using `useMutation`, input fields with validation, and form reset on completion using `formMethods.reset()`. Includes standard RedwoodJS setup with Metadata, Toaster, and a typed GraphQL mutation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_42\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport { toast, Toaster } from '@redwoodjs/web/toast'\nimport {\n  FieldError,\n  Form,\n  FormError,\n  Label,\n  Submit,\n  SubmitHandler,\n  TextAreaField,\n  TextField,\n  useForm,\n} from '@redwoodjs/forms'\n\nimport {\n  CreateContactMutation,\n  CreateContactMutationVariables,\n} from 'types/graphql'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const formMethods = useForm()\n\n  const [create, { loading, error }] = useMutation<\n    CreateContactMutation,\n    CreateContactMutationVariables\n  >(CREATE_CONTACT, {\n    onCompleted: () => {\n      toast.success('Thank you for your submission!')\n      formMethods.reset()\n    },\n  })\n\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Toaster />\n      <Form\n        onSubmit={onSubmit}\n        config={{ mode: 'onBlur' }}\n        error={error}\n        formMethods={formMethods}\n      >\n        <FormError error={error} wrapperClassName=\"form-error\" />\n\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit disabled={loading}>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Rendering ContactPage Form with Server Error Display in RedwoodJS - JavaScript (JSX)\nDESCRIPTION: This code provides a full ContactPage form implementation using RedwoodJS in JavaScript (JSX), demonstrating how to wire up the FormError component and display mutation errors alongside field errors. It uses useMutation to handle createContact GraphQL requests, includes Toaster notifications, and applies contextual error handling by passing the error object to the Form and FormError. This approach requires dependencies such as @redwoodjs/web, @redwoodjs/web/toast, and @redwoodjs/forms.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata, useMutation } from '@redwoodjs/web'\\nimport { toast, Toaster } from '@redwoodjs/web/toast'\\nimport {\\n  FieldError,\\n  Form,\\n  // highlight-next-line\\n  FormError,\\n  Label,\\n  TextField,\\n  TextAreaField,\\n  Submit,\\n} from '@redwoodjs/forms'\\n\\nconst CREATE_CONTACT = gql`\\n  mutation CreateContactMutation($input: CreateContactInput!) {\\n    createContact(input: $input) {\\n      id\\n    }\\n  }\\n`\\n\\nconst ContactPage = () => {\\n  const [create, { loading, error }] = useMutation(CREATE_CONTACT, {\\n    onCompleted: () => {\\n      toast.success('Thank you for your submission!')\\n    },\\n  })\\n\\n  const onSubmit = (data) => {\\n    create({ variables: { input: data } })\\n  }\\n\\n  return (\\n    <>\\n      <Metadata title=\"Contact\" description=\"Contact page\" />\\n\\n      <Toaster />\\n      // highlight-start\\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }} error={error}>\\n        <FormError error={error} wrapperClassName=\"form-error\" />\\n        // highlight-end\\n\\n        <Label name=\"name\" errorClassName=\"error\">\\n          Name\\n        </Label>\\n        <TextField\\n          name=\"name\"\\n          validation={{ required: true }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"name\" className=\"error\" />\\n\\n        <Label name=\"email\" errorClassName=\"error\">\\n          Email\\n        </Label>\\n        <TextField\\n          name=\"email\"\\n          validation={{\\n            required: true,\\n          }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"email\" className=\"error\" />\\n\\n        <Label name=\"message\" errorClassName=\"error\">\\n          Message\\n        </Label>\\n        <TextAreaField\\n          name=\"message\"\\n          validation={{ required: true }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"message\" className=\"error\" />\\n\\n        <Submit disabled={loading}>Save</Submit>\\n      </Form>\\n    </>\\n  )\\n}\\n\\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Handler Options Interface in RedwoodJS (TypeScript)\nDESCRIPTION: Defines the GraphQLHandlerOptions TypeScript interface for RedwoodJS applications, outlining the available properties for customizing a GraphQL handler, such as health checks, logging, authentication, context, security, schema imports, CORS, error masking, allowed operations, and plugins. Dependencies include related type imports such as LoggerConfig, Context, ContextFunction, services/sdls import types, and option objects for schema and security. Required parameters include services and loggerConfig; others are optional to customize handler behavior for authentication, error handling, or GraphQL schema extensions. Outputs depend on handler consumer code, with this interface enforcing structure and documentation for correct handler usage.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface GraphQLHandlerOptions {\n  /**\n   * @description The identifier used in the GraphQL health check response.\n   * It verifies readiness when sent as a header in the readiness check request.\n   *\n   * By default, the identifier is `yoga` as seen in the HTTP response header `x-yoga-id: yoga`\n   */\n  healthCheckId?: string\n\n  /**\n   * @description Customize GraphQL Logger\n   *\n   * Collect resolver timings, and exposes trace data for\n   * an individual request under extensions as part of the GraphQL response.\n   */\n  loggerConfig: LoggerConfig\n\n  /**\n   * @description Modify the resolver and global context.\n   */\n  context?: Context | ContextFunction\n\n  /**\n   * @description An async function that maps the auth token retrieved from the\n   * request headers to an object.\n   * Is it executed when the `auth-provider` contains one of the supported\n   * providers.\n   */\n  getCurrentUser?: GetCurrentUser\n\n  /**\n   * @description A callback when an unhandled exception occurs. Use this to disconnect your prisma instance.\n   */\n  onException?: () => void\n\n  /**\n   * @description Services passed from the glob import:\n   * import services from 'src/services/**/*.{js,ts}'\n   */\n  services: ServicesGlobImports\n\n  /**\n   * @description SDLs (schema definitions) passed from the glob import:\n   * import sdls from 'src/graphql/**/*.{js,ts}'\n   */\n  sdls: SdlGlobImports\n\n  /**\n   * @description Directives passed from the glob import:\n   * import directives from 'src/directives/**/*.{js,ts}'\n   */\n  directives?: DirectiveGlobImports\n\n  /**\n   * @description A list of options passed to [makeExecutableSchema]\n   * (https://www.graphql-tools.com/docs/generate-schema/#makeexecutableschemaoptions).\n   */\n  schemaOptions?: Partial<IExecutableSchemaDefinition>\n\n  /**\n   * @description CORS configuration\n   */\n  cors?: CorsConfig\n\n  /**\n   *  @description Customize GraphQL Armor plugin configuration\n   *\n   * @see https://escape-technologies.github.io/graphql-armor/docs/configuration/examples\n   */\n  armorConfig?: ArmorConfig\n\n  /**\n   * @description Customize the default error message used to mask errors.\n   *\n   * By default, the masked error message is \"Something went wrong\"\n   *\n   * @see https://github.com/dotansimha/envelop/blob/main/packages/core/docs/use-masked-errors.md\n   */\n  defaultError?: string\n\n  /**\n   * @description Only allows the specified operation types (e.g. subscription, query or mutation).\n   *\n   * By default, only allow query and mutation (ie, do not allow subscriptions).\n   *\n   * An array of GraphQL's OperationTypeNode enums:\n   * - OperationTypeNode.SUBSCRIPTION\n   * - OperationTypeNode.QUERY\n   * - OperationTypeNode.MUTATION\n   *\n   * @see https://github.com/dotansimha/envelop/tree/main/packages/plugins/filter-operation-type\n   */\n  allowedOperations?: AllowedOperations\n\n  /**\n   * @description Custom Envelop plugins\n   */\n  extraPlugins?: Plugin[]\n\n  /**\n   * @description Auth-provider specific token decoder\n   */\n  authDecoder?: Decoder\n\n  /**\n   * @description Customize the GraphiQL Endpoint that appears in the location bar of the GraphQL Playground\n   *\n   * Defaults to '/graphql' as this value must match the name of the `graphql` function on the api-side.\n   */\n  graphiQLEndpoint?: string\n  /**\n   * @description Function that returns custom headers (as string) for GraphiQL.\n   *\n   * Headers must set auth-provider, Authorization and (if using dbAuth) the encrypted cookie.\n   */\n  generateGraphiQLHeader?: GenerateGraphiQLHeader\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Delete Comment Functionality to JavaScript Service\nDESCRIPTION: This JavaScript snippet adds the `deleteComment` function to the service. It takes a single argument `id` representing the ID of the comment to be deleted. It uses `db.comment.delete` with a `where` clause specifying the `id` to remove the comment from the database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.js\"\nexport const deleteComment = ({ id }) => {\n  return db.comment.delete({\n    where: { id },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Linking Article Titles in ArticlesCell Component (JavaScript/JSX)\nDESCRIPTION: Updates the `ArticlesCell.jsx` component to import `Link` and `routes` from `@redwoodjs/router`. It then modifies the `Success` component to wrap each article title in a `Link` component, initially pointing to the base `article` route without an ID.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/components/ArticlesCell/ArticlesCell.jsx\"\n// highlight-next-line\nimport { Link, routes } from '@redwoodjs/router'\n\n// QUERY, Loading, Empty and Failure definitions...\n\nexport const Success = ({ articles }) => {\n  return (\n    <>\n      {articles.map((article) => (\n        <article key={article.id}>\n          <header>\n            <h2>\n              // highlight-next-line\n              <Link to={routes.article()}>{article.title}</Link>\n            </h2>\n          </header>\n          <p>{article.body}</p>\n          <div>Posted at: {article.createdAt}</div>\n        </article>\n      ))}\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a Divide Function with Missing Dividend - React/JSX/TypeScript\nDESCRIPTION: This TypeScript test case verifies the behavior of the 'divide' function when the 'dividend' value is missing in the query string. It creates a mock HTTP event without 'dividend', calls the handler, and expects a 400 status with a specific error message. Requires the mock event utility and the handler under test.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nit('requires a dividend', async () => {\n  const httpEvent = mockHttpEvent({\n    queryStringParameters: {\n      divisor: '5',\n    },\n  })\n\n  const result = await handler(httpEvent)\n  const body = result.body\n  expect(result.statusCode).toBe(400)\n  expect(body.message).toContain('Please specify both')\n  expect(body.quotient).toBeUndefined\n})\n\n```\n\n----------------------------------------\n\nTITLE: Calling toast Function for Notifications After Form Submit - RedwoodJS - JSX\nDESCRIPTION: This snippet shows how to invoke the toast function from @redwoodjs/web/toast to display informational or error messages after performing a GraphQL mutation (e.g., creating a post). It demonstrates usage within a form component, handling both successful and failed mutation outcomes. Dependencies include @redwoodjs/web/toast and a configured useMutation hook. Key parameters are the mutation and the toast message strings. Outputs are toast notifications displayed to the user.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/toast-notifications.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { toast } from '@redwoodjs/web/toast'\\n\\n// ...\\n\\nconst PostForm = () => {\\n  const [create, { loading, error }] = useMutation(CREATE_POST_MUTATION)\\n\\n  const onSubmit = async (data) => {\\n    try {\\n      await create({ variables: { input: data }})\\n      // highlight-next-line\\n      toast('Post created')\\n    }\\n    catch (e) {\\n      // highlight-next-line\\n      toast('Error creating post')\\n    }\\n  }\\n\\n  return (\\n    // <Form onSubmit={onSubmit}> ... </Form>\\n  )\\n})\\n\\nexport default PostForm\n```\n\n----------------------------------------\n\nTITLE: Configuring Redwood API Server with Fastify Plugins\nDESCRIPTION: This TypeScript snippet demonstrates using the `configureApiServer` option within `createServer`. This async function receives the Fastify server instance, allowing registration and configuration of Fastify plugins (like `@fastify/compress` and `@fastify/rate-limit`) before Redwood's core API plugin is registered, ensuring proper encapsulation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = await createServer({\n  logger,\n  async configureApiServer(server) {\n    await server.register(import('@fastify/compress'), {\n      global: true,\n      threshold: 1024,\n      encodings: ['deflate', 'gzip'],\n    })\n\n    await server.register(import('@fastify/rate-limit'), {\n      max: 100,\n      timeWindow: '5 minutes',\n    })\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Comment Model in Prisma Schema (Prisma/JavaScript)\nDESCRIPTION: Defines the Prisma schema in `api/db/schema.prisma`, adding a `Comment` model with fields like `name`, `body`, `postId`, and `createdAt`. It establishes a one-to-many relationship between `Post` and `Comment` using the `@relation` directive and updates the `Post` model to include a `comments` field. This schema is used by Prisma to manage database structure and generate the client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = \"native\"\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  body      String\n  // highlight-next-line\n  comments  Comment[]\n  createdAt DateTime @default(now())\n}\n\nmodel Contact {\n  id        Int      @id @default(autoincrement())\n  name      String\n  email     String\n  message   String\n  createdAt DateTime @default(now())\n}\n\nmodel User {\n  id                  Int @id @default(autoincrement())\n  name                String?\n  email               String @unique\n  hashedPassword      String\n  salt                String\n  resetToken          String?\n  resetTokenExpiresAt DateTime?\n}\n\n// highlight-start\nmodel Comment {\n  id        Int      @id @default(autoincrement())\n  name      String\n  body      String\n  post      Post     @relation(fields: [postId], references: [id])\n  postId    Int\n  createdAt DateTime @default(now())\n}\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Announcing Route Changes with RouteAnnouncement - RedwoodJS - JavaScript/React\nDESCRIPTION: Demonstrates how to use the RedwoodJS RouteAnnouncement component to announce new content on navigation changes for screen readers. This component wraps the element to be announced (in this case, an <h1>) and ensures accessible navigation experience. Dependencies include '@redwoodjs/router'; the HomePage functional component renders the announcement. No additional parameters are required; expected output is that the h1 content is announced on navigation. Best for straightforward announcements without custom visibility handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/a11y.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { RouteAnnouncement } from '@redwoodjs/router'\n\nconst HomePage = () => {\n  return (\n    // This will still be visible\n    <RouteAnnouncement>\n      <h1>Welcome to my site!</h1>\n    </RouteAnnouncement>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Implementing a RedwoodJS Blog Layout Component (JavaScript/JSX)\nDESCRIPTION: Defines the `BlogLayout` functional component in JavaScript (JSX). It imports `Link` and `routes` from `@redwoodjs/router` for navigation. The component structure includes a shared `<header>` with a title and navigation, and a `<main>` element that renders the `children` prop, which will be the content of the page wrapped by this layout.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { Link, routes } from '@redwoodjs/router'\n\nconst BlogLayout = ({ children }) => {\n  return (\n    // highlight-start\n    <>\n      <header>\n        <h1>Redwood Blog</h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n    // highlight-end\n  )\n}\n\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Testing Comment Creation API Service with Scenario Data - TypeScript\nDESCRIPTION: Provides type-checked integration tests for the comments service using RedwoodJS, leveraging named scenarios and strong type inference. The postOnly scenario ensures createComment correctly links new comments to posts, checking all expected properties and TypeScript type contracts. Depends on correctly typed scenario imports.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_20\n\nLANGUAGE: ts\nCODE:\n```\n// highlight-next-line\nimport { comments, createComment } from './comments'\n\n// highlight-next-line\nimport type { StandardScenario, PostOnlyScenario } from './comments.scenarios'\n\ndescribe('comments', () => {\n  scenario('returns all comments', async (scenario: StandardScenario) => {\n    const result = await comments()\n\n    expect(result.length).toEqual(Object.keys(scenario.comment).length)\n  })\n\n  // highlight-start\n  scenario(\n    'postOnly',\n    'creates a new comment',\n    async (scenario: PostOnlyScenario) => {\n      const comment = await createComment({\n        input: {\n          name: 'Billy Bob',\n          body: 'What is your favorite tree bark?',\n          post: {\n            connect: { id: scenario.post.bark.id },\n          },\n        },\n      })\n\n      expect(comment.name).toEqual('Billy Bob')\n      expect(comment.body).toEqual('What is your favorite tree bark?')\n      expect(comment.postId).toEqual(scenario.post.bark.id)\n      expect(comment.createdAt).not.toEqual(null)\n    }\n  )\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a GraphQL Union Type in an SDL File (GraphQL)\nDESCRIPTION: This snippet shows the definition of a GraphQL union type `CandyResult` within an SDL file. Redwood's type generation handles union types, generating appropriate resolver types. However, if the union involves complex types not directly mapped from Prisma models, custom resolver type definitions might be necessary.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/generated-types.md#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\ntype OutOfStock {\n  message: String!\n}\n\n// highlight-next-line\nunion CandyResult = Candy | OutOfStock\n\ntype Query {\n  candy(id: String!): CandyResult @skipAuth\n}\n```\n\n----------------------------------------\n\nTITLE: Caching with Instance Keys in Redwood Record (JavaScript)\nDESCRIPTION: This snippet utilizes Redwood Record to cache data by directly passing a record instance as the key. The cache system automatically generates a unique cache key internally for the record. This greatly simplifies usage and reduces the likelihood of cache key errors. Assumes that 'cache' is provided via RedwoodJS and that record instances have proper identity and serialization logic tied to them.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_60\n\nLANGUAGE: JavaScript\nCODE:\n```\ncache(product, () => {\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: RedwoodJS Build Error for Missing Auth Directives Bash\nDESCRIPTION: Illustrates a build failure error message from RedwoodJS. This error occurs when the schema validation process detects GraphQL queries or mutations (like `contacts`, `posts`, `updatePost`) that are missing necessary security directives (`@requireAuth` or `@skipAuth`), preventing a successful build.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_53\n\nLANGUAGE: bash\nCODE:\n```\n✖ Verifying graphql schema...\nBuilding API...\nCleaning Web...\nBuilding Web...\nPrerendering Web...\nYou must specify one of @requireAuth, @skipAuth or a custom directive for\n- contacts Query\n- posts Query\n- post Query\n- updatePost Mutation\n- deletePost Mutation\n```\n\n----------------------------------------\n\nTITLE: Setting Up Azure AD Auth Environment Variables - Bash\nDESCRIPTION: These bash commands demonstrate the string format for setting required Azure Active Directory authentication variables in a .env file. You must acquire your Azure app's Client ID and Directory (tenant) ID from your app registration and substitute them in the variable definitions. The AZURE_ACTIVE_DIRECTORY_AUTHORITY variable is constructed using the Directory (tenant) ID. No dependencies are required other than a valid .env file in your project root. The values are used by both API and web sides of RedwoodJS.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/azure.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nAZURE_ACTIVE_DIRECTORY_CLIENT_ID=\"...\"\n# Where `tenantId` is your app's \"Directory (tenant) ID\"\nAZURE_ACTIVE_DIRECTORY_AUTHORITY=\"https://login.microsoftonline.com/${tenantId}\"\n```\n\n----------------------------------------\n\nTITLE: Adding Post-Login Navigation in SigninPage using JSX\nDESCRIPTION: This snippet completes the sign-in flow in the `SigninPage` component. It imports `navigate` and `routes` from `@redwoodjs/router`. Upon successful login (within the `.then` block of the `logIn` promise), it uses `navigate(routes.home())` to redirect the user to the home page.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {3,12} title=\"web/src/pages/SigninPage/SigninPage.js\"\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from '@redwoodjs/auth'\nimport { navigate, routes } from '@redwoodjs/router'\n\nconst SigninPage = () => {\n  const { logIn } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = (data) => {\n    setError(null)\n    logIn({ email: data.email, password: data.password, remember: true })\n      .then(() => navigate(routes.home()))\n      .catch((error) => setError(error.message))\n  }\n\n  return (\n    <>\n      <h1>Sign In</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign In</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SigninPage\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Nested Sets with Contexts and Layouts in RedwoodJS - JSX\nDESCRIPTION: This code demonstrates the use of nested Set components in RedwoodJS for advanced route grouping. The outer Set wraps its routes with both BlogContext and BlogLayout, while a nested Set additionally applies BlogNavLayout to a child route. This pattern allows inheritance and composition of layout and context providers for sets of routes, which enhances code reuse and UI consistency. Imports for Router, Route, Set, and wrapper components are required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport BlogContext from 'src/contexts/BlogContext'\nimport BlogLayout from 'src/layouts/BlogLayout'\nimport BlogNavLayout from 'src/layouts/BlogNavLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={[BlogContext, BlogLayout]}>\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Set wrap={BlogNavLayout}>\n          <Route path=\"/blog-post/{id:Int}\" page={BlogPostPage} name=\"blogPost\" />\n        </Set>\n      </Set>\n    </Router>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RedwoodJS Background Job Logic (JavaScript)\nDESCRIPTION: Example implementation of a RedwoodJS background job named `SendWelcomeEmailJob`. It uses `jobs.createJob` to define the job's queue ('default') and the asynchronous `perform` function, which contains the core logic: fetching a user by ID from the database and sending a welcome email using the mailer. It requires the database client (`db`), `mailer`, and `jobs` library from `src/lib`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_9\n\nLANGUAGE: js\nCODE:\n```\nimport { db } from 'src/lib/db'\nimport { mailer } from 'src/lib/mailer'\nimport { jobs } from 'src/lib/jobs'\n\nexport const SendWelcomeEmailJob = jobs.createJob({\n  queue: 'default',\n  perform: async (userId) => {\n    const user = await db.user.findUnique({ where: { id: userId } })\n    await mailer.send(WelcomeEmail({ user }), {\n      to: user.email,\n      subject: `Welcome to the site!`,\n    })\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Conditionally Rendering Login/Logout UI in RedwoodJS BlogLayout (JavaScript)\nDESCRIPTION: This JavaScript snippet updates the `BlogLayout` component to conditionally render UI elements based on the authentication status obtained from `useAuth`. If `isAuthenticated` is true, it displays the user's email (`currentUser.email`) and a logout button that triggers the `logOut` function. Otherwise, it shows a link to the login route.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/layouts/BlogLayout/BlogLayout.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\nimport { useAuth } from 'src/auth'\n\nconst BlogLayout = ({ children }) => {\n  const { isAuthenticated, currentUser, logOut } = useAuth()\n\n  return (\n    <>\n      <header>\n        // highlight-next-line\n        <div className=\"flex-between\">\n          <h1>\n            <Link to={routes.home()}>Redwood Blog</Link>\n          </h1>\n          // highlight-start\n          {isAuthenticated ? (\n            <div>\n              <span>Logged in as {currentUser.email}</span>{' '}\n              <button type=\"button\" onClick={logOut}>\n                Logout\n              </button>\n            </div>\n          ) : (\n            <Link to={routes.login()}>Login</Link>\n          )}\n        </div>\n        // highlight-end\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n            <li>\n              <Link to={routes.contact()}>Contact</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Redwood Form Submission Behavior - JavaScript\nDESCRIPTION: This suite contains advanced tests for the RedwoodJS NameForm component, verifying correct submission logic. It uses async/await and waitFor for state synchronization, simulates user input with @testing-library/user-event, and checks conditions such as not submitting without required fields, submitting with valid fields, and passing the correct data to the onSubmit handler. Dependencies include @redwoodjs/testing/web and @testing-library/user-event. Inputs are simulated typed values; outputs are invocation of the onSubmit mock with correct data. Limitations include assumption of field placeholders and button text.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_48\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { render, screen, waitFor } from '@redwoodjs/testing/web'\nimport userEvent from '@testing-library/user-event'\n\nimport NameForm from './NameForm'\n\ndescribe('NameForm', () => {\n\n  it('does not submit when required fields are empty', async () => {\n    const onSubmit = jest.fn()\n\n    render(<NameForm onSubmit={onSubmit} />)\n\n    const submitButton = screen.getByText('Submit')\n\n    await waitFor(() => userEvent.click(submitButton))\n\n    expect(onSubmit).not.toHaveBeenCalled()\n  })\n\n  it('submits when required fields are entered', async () => {\n    const name = 'My Name'\n    const nickname = ''\n\n    const onSubmit = jest.fn()\n\n    render(<NameForm onSubmit={onSubmit} />)\n\n    const nameField = screen.getByPlaceholderText('Name')\n    const submitButton = screen.getByText('Submit')\n\n    await waitFor(() => userEvent.type(nameField, name))\n    await waitFor(() => userEvent.click(submitButton))\n\n    expect(onSubmit).toHaveBeenCalledTimes(1)\n    expect(onSubmit).toHaveBeenCalled()\n    expect(onSubmit).toHaveBeenCalledWith(\n      { name, nickname },\n      expect.objectContaining({\n        _reactName: 'onSubmit',\n        type: 'submit',\n      })\n    )\n  })\n\n  it('submits with the expected, entered data', async () => {\n    const name = 'My Name'\n    const nickname = 'My Nickname'\n\n    const onSubmit = jest.fn()\n\n    render(<NameForm onSubmit={onSubmit} />)\n\n    const nameField = screen.getByPlaceholderText('Name')\n    const nicknameField = screen.getByPlaceholderText('Nickname')\n    const submitButton = screen.getByText('Submit')\n\n    await waitFor(() => userEvent.type(nameField, name))\n    await waitFor(() => userEvent.type(nicknameField, nickname))\n    await waitFor(() => userEvent.click(submitButton))\n\n    expect(onSubmit).toHaveBeenCalledTimes(1)\n    expect(onSubmit).toHaveBeenCalled()\n    expect(onSubmit).toHaveBeenCalledWith(\n      { name, nickname },\n      expect.objectContaining({\n        _reactName: 'onSubmit',\n        type: 'submit',\n      })\n    )\n  })\n\n// })\n```\n\n----------------------------------------\n\nTITLE: Testing Service Retrieval Function with Redwood and Jest - JavaScript\nDESCRIPTION: Demonstrates how to define and run a test for the comments() retrieval service using RedwoodJS's scenario function for seeding test data. Requires Jest and RedwoodJS testing utilities, as well as the comments service. The test compares the length of results from the comments() function to the expected number of seeded comment records, ensuring database seeding and service retrieval logic are correct. Inputs: none directly—uses scenario data; Output: assertion on record count equality.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nimport { comments } from './comments'\\n\\ndescribe('comments', () => {\\n  scenario('returns all comments', async (scenario) => {\\n    const result = await comments()\\n\\n    expect(result.length).toEqual(Object.keys(scenario.comment).length)\\n  })\\n})\n```\n\n----------------------------------------\n\nTITLE: Focusing Custom Elements on Navigation with RouteFocus - RedwoodJS - JavaScript/React\nDESCRIPTION: Illustrates using the RouteFocus component from '@redwoodjs/router' to programmatically move focus to a particular element (here, a TextField) upon navigation. Particularly helpful in pages with complex navigation or forms, enhancing keyboard and screen reader usability. The example shows ContactPage rendering a navigation and then wraps the TextField within RouteFocus. Dependencies: '@redwoodjs/router', and presumably a TextField component. May require consideration to avoid disorienting users with unexpected focus changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/a11y.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { RouteFocus } from '@redwoodjs/router'\n\nconst ContactPage = () => (\n  <nav>\n    {/* Way too much nav... */}\n  </nav>\n\n  // The contact form the user actually wants to interact with\n  // highlight-start\n  <RouteFocus>\n    <TextField name=\"name\" />\n  </RouteFocus>\n  // highlight-end\n)\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Using the Inclusion Validator with a Custom Message in JSX\nDESCRIPTION: Illustrates providing a custom error message for the `inclusion` validator. The message is defined using the `message` property within the nested `inclusion` object, alongside the `in` array.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_22\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.role, 'Role', {\n  inclusion: {\n    in: ['Guest', 'Member', 'Manager'],\n    message: 'Please select a proper role',\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Boilerplate RedwoodJS ArticlesCell Component (TypeScript/TSX)\nDESCRIPTION: This is the initial boilerplate code generated for the `ArticlesCell` in TypeScript (TSX) using `yarn rw g cell Articles`. It includes type imports (`ArticlesQuery`, `ArticlesQueryVariables`, `CellFailureProps`, etc.) from generated GraphQL types and RedwoodJS, defines a typed GraphQL query (`QUERY`), and exports typed components for `Loading`, `Empty`, `Failure`, and `Success` states. The `Success` component receives typed data (`articles`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/ArticlesCell/ArticlesCell.tsx\"\nimport type { ArticlesQuery, ArticlesQueryVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypedDocumentNode,\n} from '@redwoodjs/web'\n\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> = // highlight-line\n  gql`\n    query ArticlesQuery {\n      articles {\n        id\n      }\n    }\n  `\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<ArticlesQueryVariables>) => ( // highlight-line\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  articles,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => { // highlight-line\n  return (\n    <ul>\n      {articles.map((item) => {\n        return <li key={item.id}>{JSON.stringify(item)}</li>\n      })}\n    </ul>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Mock Data with Spread Syntax in RedwoodJS Storybook Story (JSX/TSX)\nDESCRIPTION: This Storybook story file (`ArticlesCell.stories.jsx`/`tsx`) imports the `Success` component and the `standard` mock. It demonstrates rendering the `Success` component by spreading the entire result of the `standard()` mock function as props using `{...standard()}`. This works because the mock function returns an object with keys matching the expected props of the `Success` component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticlesCell/ArticlesCell.stories.jsx\"\nimport { Success } from './ArticlesCell'\nimport { standard } from './ArticlesCell.mock'\n\nexport const success = () => {\n  // highlight-next-line\n  return Success ? <Success {...standard()} /> : null\n}\n\nexport default { title: 'Cells/ArticlesCell' }\n```\n```\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/ArticlesCell/ArticlesCell.stories.tsx\"\nimport { Success } from './ArticlesCell'\nimport { standard } from './ArticlesCell.mock'\n\nexport const success = () => {\n  // highlight-next-line\n  return Success ? <Success {...standard()} /> : null\n}\n\nexport default { title: 'Cells/ArticlesCell' }\n```\n```\n\n----------------------------------------\n\nTITLE: Using the Length Validator (min/max) in JSX\nDESCRIPTION: Shows the `length` validator configured to enforce both a minimum (`min`) and maximum (`max`) character length for the input string value.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.answer, 'Answer', {\n  length: { min: 6, max: 200 },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Querying Comments Using RedwoodJS Cell - JavaScript (JSX)\nDESCRIPTION: Defines a RedwoodJS Cell for fetching and displaying a list of comments using a GraphQL query. It provides separate render states for loading, empty, and error, and on success, maps the list of comments to individual Comment components. Depends on the Comment component, GraphQL endpoint, and RedwoodJS hooks. Input props are received from the framework and must include a comments array for success.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\\nimport Comment from 'src/components/Comment'\\n\\nexport const QUERY = gql`\\n  query CommentsQuery {\\n    comments {\\n      id\\n      // highlight-start\\n      name\\n      body\\n      createdAt\\n      // highlight-end\\n    }\\n  }\\n`\\n\\nexport const Loading = () => <div>Loading...</div>\\n\\nexport const Empty = () => <div>Empty</div>\\n\\nexport const Failure = ({ error }) => (\\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\\n)\\n\\nexport const Success = ({ comments }) => {\\n  return (\\n  // highlight-start\\n    <>\\n      {comments.map((comment) => (\\n        <Comment key={comment.id} comment={comment} />\\n      ))}\\n    </>\\n  // highlight-end\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Server Errors in RedwoodJS Form (JavaScript/JSX)\nDESCRIPTION: Updates the `ContactPage.jsx` component to handle and display server-side errors from the `createContact` mutation. It imports `FormError`, passes the `error` object obtained from `useMutation` to both the `<Form>` component (via the `error` prop) and the new `<FormError>` component. This allows server validation messages (like the email format error) to be shown to the user.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport { toast, Toaster } from '@redwoodjs/web/toast'\nimport {\n  FieldError,\n  Form,\n  // highlight-next-line\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\nconst ContactPage = () => {\n  const [create, { loading, error }] = useMutation(CREATE_CONTACT, {\n    onCompleted: () => {\n      toast.success('Thank you for your submission!')\n    },\n  })\n\n  const onSubmit = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Toaster />\n      // highlight-start\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }} error={error}>\n        <FormError error={error} wrapperClassName=\"form-error\" />\n        // highlight-end\n\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit disabled={loading}>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n\n```\n\n----------------------------------------\n\nTITLE: Implementing User Role Validation in a RedwoodJS Validator Directive (TypeScript)\nDESCRIPTION: Shows an example implementation of the `validate` function for the `isSubscriber` directive in `/api/src/directives/isSubscriber/isSubscriber.ts`. It accesses `context.currentUser` to check if a user is authenticated and if their roles include 'SUBSCRIBER'. It throws an `AuthenticationError` or `ForbiddenError` if the checks fail, preventing further execution for unauthorized users.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_26\n\nLANGUAGE: tsx\nCODE:\n```\n// ...\n\nconst validate: ValidatorDirectiveFunc = ({ context }) => {\n  if (!context.currentUser)) {\n    throw new AuthenticationError(\"You don't have permission to do that.\")\n  }\n\n  if (!context.currentUser.roles?.includes('SUBSCRIBER')) {\n    throw new ForbiddenError(\"You don't have access to do that.\")\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Exporting Static Route Parameters in a routeHooks.js File (JavaScript)\nDESCRIPTION: Defines a 'routeParameters' export used by RedwoodJS to specify the set of dynamic parameters (such as IDs) to prerender. This allows build-time static generation of multiple versions of a dynamic page. The function should return an array of objects, each describing a route permutation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nexport function routeParameters() {\n  return [{ id: 1 }, { id: 2 }, { id: 3 }]\n}\n```\n\n----------------------------------------\n\nTITLE: Submitting Comments with RedwoodJS Form (TypeScript)\nDESCRIPTION: Provides a TypeScript version of the CommentForm component using RedwoodJS forms and typed GraphQL operations. This snippet uses typed document nodes and includes type definitions for mutation variables and form values, enhancing type safety for form submissions. The onSubmit function validates input types, and dependencies are similar to the JavaScript version but require TypeScript support. Inputs must be of type 'FormValues', and successful submissions return the created comment object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-start\nimport type {\n  CreateCommentMutation,\n  CreateCommentMutationVariables,\n} from 'types/graphql'\n// highlight-end\n\nimport {\n  Form,\n  // highlight-next-line\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  // highlight-next-line\n  SubmitHandler,\n} from '@redwoodjs/forms'\n// highlight-start\nimport type { TypedDocumentNode } from '@redwoodjs/web'\nimport { useMutation } from '@redwoodjs/web'\n// highlight-end\n\n// highlight-start\nconst CREATE: TypedDocumentNode<\n  CreateCommentMutation,\n  CreateCommentMutationVariables\n> = gql`\n  mutation CreateCommentMutation($input: CreateCommentInput!) {\n    createComment(input: $input) {\n      id\n      name\n      body\n      createdAt\n    }\n  }\n`\n// highlight-end\n\n// highlight-start\ninterface FormValues {\n  name: string\n  comment: string\n}\n// highlight-end\n\nconst CommentForm = () => {\n  // highlight-next-line\n  const [createComment, { loading, error }] = useMutation(CREATE)\n\n  // highlight-start\n  const onSubmit: SubmitHandler<FormValues> = (input) => {\n    createComment({ variables: { input } })\n  }\n  // highlight-end\n\n  return (\n    <div>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      // highlight-start\n      <Form className=\"mt-4 w-full\" onSubmit={onSubmit}>\n        <FormError\n          error={error}\n          titleClassName=\"font-semibold\"\n          wrapperClassName=\"bg-red-100 text-red-900 text-sm p-3 rounded\"\n        />\n        // highlight-end\n\n        <Label\n          name=\"name\"\n          className=\"block text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-sm \"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-sm\"\n          validation={{ required: true }}\n        />\n\n        <Submit\n          // highlight-next-line\n          disabled={loading}\n          className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\"\n        >\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n\n----------------------------------------\n\nTITLE: Grouping Routes in a Set with Context and Layout Wrappers - RedwoodJS - JSX\nDESCRIPTION: This example demonstrates how to use the Set component in RedwoodJS to group and wrap multiple routes with context and layout components. The Set's wrap prop can accept an array of wrapper components (such as BlogContext and BlogLayout). All routes within the Set inherit these wrappers, allowing shared layout and state. This requires the relevant context and layout modules to be imported, and is structured within the Router's JSX.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport BlogContext from 'src/contexts/BlogContext'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={[BlogContext, BlogLayout]}>\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Route path=\"/blog-post/{id:Int}\" page={BlogPostPage} name=\"blogPost\" />\n      </Set>\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Importing Image Asset in React with Vite - JavaScript\nDESCRIPTION: Illustrates a preferred method for importing image files directly into a React component. Vite will process the imported image, assigning it a hashed name or bundling it, depending on size. This pattern requires the React library and Vite's asset handling to be set up correctly. The imported logo is assigned as the src for an img element, and the Header component is exported for reuse.\nSOURCE: https://github.com/emelleby/docwood/blob/main/web/public/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from \\\"react\\\"\\nimport logo from \\\"./my-logo.jpg\\\"\\n\\n\\nfunction Header() {\\n  return <img src={logo} alt=\\\"Logo\\\" />\\n}\\n\\nexport default Header\n```\n\n----------------------------------------\n\nTITLE: Creating a Car with Service Validations - JavaScript\nDESCRIPTION: Defines a function to create a car entry after validating the input fields with built-in validators, ensuring only specific makes, excluding certain colors, confirming absence of damage, enforcing VIN format and length, and constraining odometer value. Requires the presence of validate (from a service validations library), and db modules. Input should adhere to the Car model structure; invalid data throws errors. Returns the result of inserting validated data into the db.car.create function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_29\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const createCar = ({ input }) => {\n  validate(input.make, 'make', {\n    inclusion: ['Audi', 'BMW', 'Ferrari', 'Lexus', 'Tesla'],\n  })\n  validate(input.color, 'color', {\n    exclusion: { in: ['Beige', 'Mauve'], message: 'No one wants that color' },\n  })\n  validate(input.hasDamage, 'hasDamage', {\n    absence: true,\n  })\n  validate(input.vin, 'vin', {\n    format: /[A-Z0-9]+/,\n    length: { equal: 17 },\n  })\n  validate(input.odometer, 'odometer', {\n    numericality: { positive: true, lessThanOrEqual: 10000 },\n  })\n\n  return db.car.create({ data: input })\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Custom GraphQL Armor Security Configuration (RedwoodJS, TypeScript)\nDESCRIPTION: Shows how to apply a custom GraphQL Armor configuration to the createGraphQLHandler for controlling security middleware in RedwoodJS. Requires the armorConfig object that specifies individual plugin settings (e.g., maxDepth, maxAliases). Supplies all core handler dependencies as before, and configures the handler to apply the provided armorConfig, improving defense against query abuse and attacks.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_61\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const handler = createGraphQLHandler({\n  authDecoder,\n  getCurrentUser,\n  loggerConfig: { logger, options: {} },\n  directives,\n  sdls,\n  services,\n  armorConfig, //  👉 custom GraphQL Security configuration\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Storybook Story with Sample Data in TypeScript\nDESCRIPTION: This TSX snippet updates the generated Storybook story for the 'Comment' component using TypeScript. It defines a `generated` export function that renders the `Comment` component, passing a sample `comment` object (matching the structure expected by the component) as a prop for display and development in Storybook.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/the-redwood-way.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport Comment from './Comment'\n\nexport const generated = () => {\n  // highlight-start\n  return (\n    <Comment\n      comment={{\n        name: 'Rob Cameron',\n        body: 'This is the first comment!',\n        createdAt: '2020-01-01T12:34:56Z',\n      }}\n    />\n  )\n  // highlight-end\n}\n\nexport default {\n  title: 'Components/Comment',\n  component: Comment,\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a New Page with Redwood CLI (Bash)\nDESCRIPTION: This command uses the RedwoodJS CLI (`yarn redwood generate page`) to create a new page named 'about'. Since no path is specified, Redwood automatically creates a route with the path `/about` and names the route 'about'. This command scaffolds the necessary page file (e.g., `web/src/pages/AboutPage/AboutPage.jsx` or `.tsx`) and adds the corresponding route definition to `Routes.jsx` or `Routes.tsx`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/second-page.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate page about\n```\n\n----------------------------------------\n\nTITLE: Resetting Form Fields using formMethods.reset() in RedwoodJS (TS)\nDESCRIPTION: Shows how to call the `reset()` method on the `formMethods` object within the `onCompleted` callback of the `useMutation` hook in TypeScript (`.tsx`). This action clears the form fields after a successful mutation (e.g., contact form submission) and typically follows a success notification. Includes generic types for the mutation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_40\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\n// ...\n\nconst [create, { loading, error }] = useMutation<\n  CreateContactMutation,\n  CreateContactMutationVariables\n>(CREATE_CONTACT, {\n  onCompleted: () => {\n    toast.success('Thank you for your submission!')\n    // highlight-next-line\n    formMethods.reset()\n  },\n})\n\n// ...\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Route Parameter Types - RedwoodJS - JSX and JavaScript\nDESCRIPTION: Shows creation and usage of custom route parameter types in RedwoodJS by providing match and parse functions in a paramTypes object. Enables extraction and transformation of custom path patterns, e.g., splitting slugs. Must be registered on the <Router>. Inputs: matching URLs, outputs: props as per parsing logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nconst userRouteParamTypes = {\n  slug: {\n    match: /\\w+-\\w+/,\n    parse: (param) => param.split('-'),\n  },\n}\n```\n\nLANGUAGE: jsx\nCODE:\n```\n<Router paramTypes={userRouteParamTypes}>\n  <Route path=\"/post/{name:slug}\" page={PostPage} name={post} />\n</Router>\n```\n\n----------------------------------------\n\nTITLE: Defining the requireAuth Function in RedwoodJS (JavaScript)\nDESCRIPTION: This code defines the `requireAuth` helper function, typically located in `api/src/lib/auth.js`. It checks if a user is authenticated using `isAuthenticated()` and, if roles are provided, checks if the user has the required role(s) using `hasRole()`. It throws an `AuthenticationError` or `ForbiddenError` if the checks fail.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nexport const requireAuth = ({ roles } = {}) => {\\n  if (!isAuthenticated()) {\\n    throw new AuthenticationError(\"You don't have permission to do that.\")\\n  }\\n\\n  if (roles && !hasRole(roles)) {\\n    throw new ForbiddenError(\"You don't have access to do that.\")\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking GraphQL Mutation with useMutation in Form Submission (JavaScript, JS)\nDESCRIPTION: This snippet demonstrates how to call the useMutation-generated create function for invoking the GraphQL mutation on form submission. The create function receives an object with variables matching the mutation's input interface. No dependencies beyond RedwoodJS and an available GraphQL endpoint are needed. Inputs, such as name, email, and message, will result in invoking the mutation and expecting an id in the response. No error handling or UI feedback is shown, representing a minimal call pattern.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_14\n\nLANGUAGE: js\nCODE:\n```\ncreate({\n  variables: {\n    input: {\n      name: 'Rob',\n      email: 'rob@redwoodjs.com',\n      message: 'I love Redwood!',\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: SDL Definition of Root Redwood GraphQL Types - GraphQL\nDESCRIPTION: This SDL (Schema Definition Language) snippet defines custom scalar types and the root Redwood type for a RedwoodJS GraphQL API. It includes application-wide scalars like BigInt, Date, Time, DateTime, JSON, and JSONObject, and sets up the Redwood and Query types with fields for versioning and current user access. The snippet is intended to be included in the root schema file and requires GraphQL-compliant server infrastructure that supports custom scalars. It serves as the backbone of the application's GraphQL API entry point, expecting no direct inputs and outputs type definitions for usage in resolvers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_16\n\nLANGUAGE: graphql\nCODE:\n```\nscalar BigInt\nscalar Date\nscalar Time\nscalar DateTime\nscalar JSON\nscalar JSONObject\n\ntype Redwood {\n  version: String\n  currentUser: JSON\n  prismaVersion: String\n}\n\ntype Query {\n  redwood: Redwood\n}\n```\n\n----------------------------------------\n\nTITLE: Restarting Background Workers (Production) using Bash\nDESCRIPTION: This command effectively stops and then starts the background job worker processes. It's useful for applying configuration changes or restarting workers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs restart\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Scalar in RedwoodJS GraphQL Schema (TypeScript)\nDESCRIPTION: This snippet defines a custom scalar type (Currency) by augmenting the GraphQL schema within a TypeScript SDL file using the gql template literal. No dependencies are needed beyond typical RedwoodJS and GraphQL setup. The scalar must be added to your schema definition file (e.g., scalars.sdl.ts) to enable further referencing and validation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_26\n\nLANGUAGE: TSX\nCODE:\n```\nexport const schema = gql`\n  scalar Currency\n`\n```\n\n----------------------------------------\n\nTITLE: Fetching User Roles from Database in RedwoodJS getCurrentUser (JavaScript)\nDESCRIPTION: Shows an alternative `getCurrentUser` implementation in `api/lib/auth.js` that retrieves roles from a database instead of the JWT. It uses Prisma Client (`db`) to query the `UserRole` table, filtering by the user's `uuid` (found in the decoded JWT's `sub` claim). The fetched role names are then mapped into an array and added to the returned `currentUser` object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nexport const getCurrentUser = async (decoded) => {\n  const userRoles = await db.userRole.findMany({\n    where: { user: { uuid: decoded.sub } },\n    select: { name: true },\n  })\n\n  const roles = userRoles.map((role) => {\n    return role.name\n  })\n\n  return context.currentUser || { roles }\n}\n```\n\n----------------------------------------\n\nTITLE: Redirecting after Successful Authentication in RedwoodJS Sign In Page in JSX\nDESCRIPTION: This final version of the SigninPage adds redirection upon successful login. It imports 'navigate' and 'routes' from '@redwoodjs/router', and after calling 'logIn', checks for errors in the response. If none, it redirects the user to the home route. Required dependencies are '@redwoodjs/forms', 'src/auth', '@redwoodjs/router', and React. It takes email and password as input, sets error if authentication fails, or redirects home if successful.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from 'src/auth'\nimport { navigate, routes } from '@redwoodjs/router'\n\nconst SigninPage = () => {\n  const { logIn } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = async (data) => {\n    setError(null)\n    try {\n      const response = await logIn({ email: data.email, password: data.password })\n      response?.error?.message ? setError(response.error.message) : navigate(routes.home())\n    } catch(error) {\n      setError(error.message)\n    }\n  }\n\n  return (\n    <>\n      <h1>Sign In</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign In</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SigninPage\n```\n\n----------------------------------------\n\nTITLE: Registering a GraphQL Fragment for RedwoodJS/Apollo - TypeScript\nDESCRIPTION: This snippet shows registering a fragment named 'BookInfo' using RedwoodJS's registerFragment utility for Apollo Client. The fragment is tagged by gql and specifies the Book fields to retrieve. Registration ensures the fragment is available for inclusion in queries throughout the project. Dependencies: @redwoodjs/web/apollo, 'gql' tag accessible in scope.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { registerFragment } from '@redwoodjs/web/apollo'\\n\\nregisterFragment(gql`\\n  fragment BookInfo on Book {\\n    id\\n    title\\n    author\\n    publicationYear\\n  }\\n`)\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Mock Data with __typename for Apollo Client (TypeScript)\nDESCRIPTION: This example provides a mock data object for the Book type, structured to satisfy both a query and its fragment requirements during testing or in Storybook. It includes a mandatory __typename field with a TypeScript as const assertion for compatibility with Apollo Client. Inputs are hardcoded mock values, including id, title, author, publicationYear, and description. Ensure __typename matches the GraphQL type exactly; this helps Apollo Client map the object to the right fragment type. Used in tests or Storybook for reliable frontend development.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport const standard = {\n  book: {\n    __typename: 'Book' as const,\n    id: 42,\n    title: 'Ulysses',\n    author: 'James Joyce',\n    publicationYear: 1922,\n    description:\n      'The experiences of three Dubliners over the course of a single day, 16 June 1904.',\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initial Attempt at Updating Post with Ownership Check in Prisma (JavaScript)\nDESCRIPTION: This snippet shows an initial, incorrect attempt to update a post using Prisma's `update` method. It tries to include `userId: context.currentUser.id` in the `where` clause to ensure ownership, but Prisma only allows unique fields (like `id`) in the `where` clause for updates based on unique indexes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/adminPosts/adminPosts.js\"\nexport const updatePost = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    // highlight-next-line\n    where: { id, userId: context.currentUser.id },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Passing Configuration Options to useForm Hook in RedwoodJS (JS)\nDESCRIPTION: Explains and demonstrates that when `useForm` is called manually in JavaScript (`.jsx`), any configuration options (like validation mode) previously passed via the `<Form>` component's `config` prop must now be passed directly as an argument to the `useForm()` hook itself.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_43\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nconst ContactPage = () => {\n  const formMethods = useForm({ mode: 'onBlur' })\n  //...\n```\n```\n\n----------------------------------------\n\nTITLE: Conditionally Rendering Content Based on Auth State in RedwoodJS (JSX)\nDESCRIPTION: This `HomePage` component uses the `useAuth` hook from `@redwoodjs/auth` to access the authentication state (`isAuthenticated`) and current user information (`currentUser`). It conditionally renders a welcome message including the user's name if `isAuthenticated` is true, and a login button (triggering the `logIn` function from `useAuth`) if `isAuthenticated` is false. This demonstrates adapting UI based on user login status.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAuth } from '@redwoodjs/auth'\n\nconst HomePage = () => {\n  const { isAuthenticated, currentUser, logIn } = useAuth()\n\n  return (\n    <>\n      <header>\n        { isAuthenticated && <h1>Welcome back {currentUser.name}</h1> }\n      </header>\n      <main>\n        { !isAuthenticated && <button onClick={logIn}>Login</button> }\n      </main>\n    </>\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Caching with Dynamic or Array-Based Keys in Redwood cache() - JavaScript\nDESCRIPTION: Demonstrates how to generate dynamic string or array-based keys for more granular cache management in RedwoodJS. Uses parameterized keys (e.g., based on post id and update timestamp) to ensure cache validity is synchronized to record updates. All `cache()` calls return Promises that can be awaited or returned directly from resolvers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_70\n\nLANGUAGE: js\nCODE:\n```\nconst post = ({ id }) => {\\n  return cache(`posts-${id}-${updatedAt.getTime()}`, () => {\\n    return db.post.findUnique({ where: { id } })\\n  })\\n}\\n\\n// or\\n\\nconst post = ({ id }) => {\\n  return cache(['posts', id, updatedAt.getTime()], () => {\\n    return db.post.findUnique({ where: { id } })\\n  })\\n}\n```\n\n----------------------------------------\n\nTITLE: Setting HTTP Headers for Authenticated Requests - Bash\nDESCRIPTION: Illustrates the HTTP headers required when calling an authenticated RedwoodJS serverless function. Requires the user's Bearer access token, selecting the correct auth provider (e.g., supabase), and the Content-Type. If using dbAuth, a dbAuth Cookie should also be present. These headers must be included with each request as there is no login flow for serverless functions. The snippet forms the template for constructing authorized HTTP requests to the API.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nAuthorization: Bearer myJWT.accesstoken.signature\nauth-provider: supabase\nContent-Type: application/json\n```\n\n----------------------------------------\n\nTITLE: Complete RedwoodJS AdminPosts Service with Ownership Verification (JavaScript)\nDESCRIPTION: This snippet shows the final version of the `adminPosts` service (`api/src/services/adminPosts/adminPosts.js`). It includes the reusable `verifyOwnership` function and uses it within both `updatePost` and `deletePost` to ensure the logged-in user owns the post before modification or deletion. It also includes functions for fetching multiple posts (`adminPosts`), a single post (`adminPost`), and creating a post (`createPost`), all scoped to the current user.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/adminPosts/adminPosts.js\"\nimport { ForbiddenError } from '@redwoodjs/graphql-server'\n\nimport { db } from 'src/lib/db'\n\nconst verifyOwnership = async ({ id }) => {\n  if (await adminPost({ id })) {\n    return true\n  } else {\n    throw new ForbiddenError(\"You don't have access to this post\")\n  }\n}\n\nexport const adminPosts = () => {\n  return db.post.findMany({ where: { userId: context.currentUser.id } })\n}\n\nexport const adminPost = ({ id }) => {\n  return db.post.findFirst({\n    where: { id, userId: context.currentUser.id },\n  })\n}\n\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    data: { ...input, userId: context.currentUser.id },\n  })\n}\n\nexport const updatePost = async ({ id, input }) => {\n  await verifyOwnership({ id })\n\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost = async ({ id }) => {\n  await verifyOwnership({ id })\n\n  return db.post.delete({\n    where: { id },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Caching User-specific Data Using Context (JavaScript)\nDESCRIPTION: This snippet shows how to cache recommended products for individual users by including a user-specific identifier in the cache key. It relies on 'context.currentUser.id' to differentiate cache entries per user. Dependencies: an authentication context providing a unique user id and a 'cache' function. Main parameter is the user id, ensuring recommended data is scoped per user. The approach is useful for features like personalized recommendations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_64\n\nLANGUAGE: JavaScript\nCODE:\n```\ncache(`recommended-${context.currentUser.id}`, () => {\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Validation Logic with validateWith - TypeScript\nDESCRIPTION: Implements the same custom validation as the JavaScript version in a TypeScript context. Checks lastCarWashDate against a one-week threshold and throws an error for cars deemed too dirty. Designed for use with TypeScript environments where input types for lastCarWashDate are defined. Relies on validateWith and proper type or interface for input.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_32\n\nLANGUAGE: JavaScript\nCODE:\n```\nvalidateWith(() => {\n  const oneWeekAgo = new Date()\n  oneWeekAgo.setDate(oneWeekAgo.getDate() - 7)\n\n  if (input.lastCarWashDate < oneWeekAgo) {\n    throw new Error(\"We don't accept dirty cars\")\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Restricting Route Access Based on Role in RedwoodJS Router\nDESCRIPTION: These snippets demonstrate how to restrict access to a set of admin routes using the `<PrivateSet>` component in RedwoodJS (`web/src/Routes.jsx` or `web/src/Routes.tsx`). The `roles=\"admin\"` prop ensures that only authenticated users with the 'admin' role can access the nested routes (e.g., `/admin/posts`). Users without this role are redirected (to 'home' in this case).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\n<PrivateSet unauthenticated=\"home\" roles=\"admin\">\n  <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n    <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n    <Route path=\"/admin/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n    <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n    <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\n  </Set>\n</PrivateSet>\n```\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\n<PrivateSet unauthenticated=\"home\" roles=\"admin\">\n  <Set\n    wrap={ScaffoldLayout}\n    title=\"Posts\"\n    titleTo=\"posts\"\n    buttonLabel=\"New Post\"\n    buttonTo=\"newPost\"\n  >\n    <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n    <Route\n      path=\"/admin/posts/{id:Int}/edit\"\n      page={PostEditPostPage}\n      name=\"editPost\"\n    />\n    <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n    <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\n  </Set>\n</PrivateSet>\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Cell Component\nDESCRIPTION: Uses the RedwoodJS CLI `generate cell` command to create a Cell named 'examplePosts'. Redwood Cells are a declarative way to handle data fetching, automatically managing loading, empty, failure, and success states for a component. This command typically generates the Cell component file, associated Storybook stories (`.stories.js` or `.stories.tsx`), and test files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw generate cell examplePosts\n```\n\n----------------------------------------\n\nTITLE: Enabling Experimental SDL Code Generation in redwood.toml (TOML)\nDESCRIPTION: This configuration snippet within the `redwood.toml` file enables an experimental feature (`experimentalSdlCodeGen`). Setting `useSDLCodeGenForGraphQLTypes` to `true` switches the type generation for resolvers to use the `sdl-codegen` library, which generates types on a per-file basis.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/generated-types.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[experimental]\n  useSDLCodeGenForGraphQLTypes = true\n```\n\n----------------------------------------\n\nTITLE: Implementing Post Resolvers in RedwoodJS Service (JavaScript)\nDESCRIPTION: This JavaScript code provides the implementation (resolvers) for the GraphQL queries and mutations defined in `posts.sdl.js`. Located in `api/src/services/posts/posts.js`, it exports functions (`posts`, `post`, `createPost`, `updatePost`, `deletePost`) that interact with the database using Prisma Client (`db`) to perform CRUD operations on the `Post` model. Redwood automatically maps these exported functions to the corresponding GraphQL schema definitions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/side-quest.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const posts = () => {\n  return db.post.findMany()\n}\n\nexport const post = ({ id }) => {\n  return db.post.findUnique({\n    where: { id },\n  })\n}\n\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    data: input,\n  })\n}\n\nexport const updatePost = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost = ({ id }) => {\n  return db.post.delete({\n    where: { id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Securing RedwoodJS Serverless Functions with useRequireAuth Wrapper - TypeScript/TSX\nDESCRIPTION: Demonstrates how to secure a RedwoodJS serverless function by wrapping a handler with the useRequireAuth higher-order function. Dependencies include @redwoodjs/auth-dbauth-api, @redwoodjs/graphql-server, project-specific auth utilities, and logging utilities. The handler checks if the user is authenticated using isAuthenticated(), responding with 200 for authenticated users and 401 otherwise. Required parameters include the handler function, getCurrentUser, and authDecoder. This pattern ensures secure access control and is extensible for custom auth logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_28\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { APIGatewayEvent, Context } from 'aws-lambda'\n\n// highlight-next-line\nimport { authDecoder } from '@redwoodjs/auth-dbauth-api'\n// highlight-next-line\nimport { useRequireAuth } from '@redwoodjs/graphql-server'\n\n// highlight-next-line\nimport { getCurrentUser, isAuthenticated } from 'src/lib/auth'\nimport { logger } from 'src/lib/logger'\n\nconst myHandler = async (event: APIGatewayEvent, context: Context) => {\n  logger.info('Invoked myHandler')\n\n  // highlight-next-line\n  if (isAuthenticated()) {\n    logger.info('Access myHandler as authenticated user')\n\n    return {\n      statusCode: 200,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        data: 'myHandler function',\n      }),\n    }\n    // highlight-start\n  } else {\n    logger.error('Access to myHandler was denied')\n\n    return {\n      statusCode: 401,\n    }\n  }\n  // highlight-end\n}\n\nexport const handler = useRequireAuth({\n  handlerFn: myHandler,\n  getCurrentUser,\n  authDecoder,\n})\n```\n\n----------------------------------------\n\nTITLE: Handling OAuth Callback Response and Setting a Secure Cookie in RedwoodJS (JavaScript)\nDESCRIPTION: This snippet defines an async callback function for an OAuth provider (e.g., GitHub) that exchanges an OAuth authorization code for an access token, fetches user information, retrieves or creates a corresponding user record, and returns a 302 response with a secure dbAuth-compatible cookie. It relies on 'crypto-js' for encryption and the presence of specific environment variables (e.g., GITHUB_OAUTH_CLIENT_ID, SESSION_SECRET). Parameters include the incoming event object and query string; it outputs a redirect with headers and authentication cookies set. Ensure dependencies 'crypto-js', '@redwoodjs/auth-dbauth-api', and valid environment variables are available.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_14\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport CryptoJS from 'crypto-js'\nimport { cookieName } from '@redwoodjs/auth-dbauth-api'\nimport { cookieName as cookie } from 'src/lib/auth'\n\nconst callback = async (event) => {\n  const { code } = event.queryStringParameters\n\n  const response = await fetch(`https://github.com/login/oauth/access_token`, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      client_id: process.env.GITHUB_OAUTH_CLIENT_ID,\n      client_secret: process.env.GITHUB_OAUTH_CLIENT_SECRET,\n      redirect_uri: process.env.GITHUB_OAUTH_REDIRECT_URI,\n      code,\n    }),\n  })\n\n  const { access_token, scope, error } = JSON.parse(await response.text())\n\n  if (error) {\n    return { statuscode: 400, body: error }\n  }\n\n  try {\n    const providerUser = await getProviderUser(access_token)\n    const user = await getUser({\n      providerUser,\n      accessToken: access_token,\n      scope,\n    })\n    // highlight-start\n    const cookie = secureCookie(user)\n\n    return {\n      statusCode: 302,\n      headers: {\n        'Set-Cookie': cookie,\n        Location: '/',\n      },\n    }\n    // highlight-end\n  } catch (e) {\n    return { statuscode: 500, body: e.message }\n  }\n}\n\n// highlight-start\nconst secureCookie = (user) => {\n  const expires = new Date()\n  expires.setFullYear(expires.getFullYear() + 1)\n\n  const cookieAttrs = [\n    `Expires=${expires.toUTCString()}`,\n    'HttpOnly=true',\n    'Path=/',\n    'SameSite=Lax',\n    `Secure=${process.env.NODE_ENV !== 'development'}`,\n  ]\n  const data = JSON.stringify({ id: user.id })\n\n  const encrypted = CryptoJS.AES.encrypt(\n    data,\n    process.env.SESSION_SECRET\n  ).toString()\n  //if you're using dbAuth v7.6.2, you have to change the cookie name. You can comment out the line below and make the next line as comment.\n  //return [`${cookieName(cookie)}=${encrypted}`, ...cookieAttrs].join('; ')\n  return [`session=${encrypted}`, ...cookieAttrs].join('; ')\n}\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL SDL for Queries and Authenticated Mutations - JavaScript\nDESCRIPTION: Extends the SDL with both query and mutation types, adding 'createTestimonial' and 'deleteTestimonial' mutations which require authentication. The input type is defined for mutation payloads, while '@skipAuth' and '@requireAuth' directives control access policy. This snippet ensures only authenticated users can create or delete testimonials, and requires the RedwoodJS backend with authentication middleware integrated.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter0/what-is-redwood.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nexport const schema = gql`\n  type Testimonial {\n    id: Int!\n    author: String!\n    quote: String!\n    createdAt: DateTime!\n    updatedAt: DateTime!\n  }\n\n  type CreateTestimonialInput {\n    author: String!\n    quote: String!\n  }\n\n  type Query {\n    testimonials: [Testimonial!] @skipAuth\n  }\n\n  type Mutation {\n    createTestimonal($input: CreateTestimonialInput!): Testimonial! @requireAuth\n    deleteTestimonal($id: Int!): Testimonial! @requireAuth\n  }\n`\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Redwood Router in JSX\nDESCRIPTION: This snippet demonstrates how to define application routes using Redwood's declarative Router component. It imports necessary components like `Route`, `Router`, `Set`, and `PrivateSet` from '@redwoodjs/router'. The example shows nesting routes within a `Set` to apply a common `ApplicationLayout`, defining public routes (`/login`, `/signup`), private routes (`/dashboard`, `/products/{sku}`) protected by authentication using `PrivateSet` (redirecting unauthenticated users to 'login'), a root route (`/`), and a `notfound` route. It also passes the `useAuth` hook to the `Router` for authentication context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter0/what-is-redwood.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Route, Router, Set, PrivateSet } from '@redwoodjs/router'\nimport ApplicationLayout from 'src/layouts/ApplicationLayout'\nimport { useAuth } from './auth'\n\nconst Routes = () => {\n  return (\n    <Router useAuth={useAuth}>\n      <Set wrap={ApplicationLayout}>\n        <Route path=\"/login\" page={LoginPage} name=\"login\" />\n        <Route path=\"/signup\" page={SignupPage} name=\"signup\" />\n        <PrivateSet unauthenticated=\"login\">\n          <Route path=\"/dashboard\" page={DashboardPage} name=\"dashboard\" />\n          <Route path=\"/products/{sku}\" page={ProductsPage} name=\"products\" />\n        </PrivateSet>\n      </Set>\n\n      <Route path=\"/\" page={HomePage} name=\"home\" />\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Comment Component Rendering and Role Logic in Jest (TypeScript)\nDESCRIPTION: This Jest test suite verifies the rendering of the `Comment` component in a RedwoodJS application using TypeScript. It utilizes `@redwoodjs/testing` utilities such as `render`, `screen`, and `waitFor`. The tests ensure the correct display of the comment's name, body, and formatted timestamp. It specifically tests conditional rendering logic: the 'Delete' button should not appear for logged-out users but should be present when the user is mocked as a 'moderator' via `mockCurrentUser`. The `waitFor` utility handles the asynchronous nature of the role verification, which involves background GraphQL calls.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_23\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/Comment/Comment.test.tsx\"\n// highlight-next-line\nimport { render, screen, waitFor } from '@redwoodjs/testing'\n\nimport Comment from './Comment'\n\n// highlight-start\nconst COMMENT = {\n  id: 1,\n  name: 'John Doe',\n  body: 'This is my comment',\n  createdAt: '2020-01-02T12:34:56Z',\n  postId: 1,\n}\n// highlight-end\n\ndescribe('Comment', () => {\n  it('renders successfully', () => {\n    // highlight-next-line\n    render(<Comment comment={COMMENT} />)\n\n    // highlight-start\n    expect(screen.getByText(COMMENT.name)).toBeInTheDocument()\n    expect(screen.getByText(COMMENT.body)).toBeInTheDocument()\n    // highlight-end\n    const dateExpect = screen.getByText('2 January 2020')\n    expect(dateExpect).toBeInTheDocument()\n    expect(dateExpect.nodeName).toEqual('TIME')\n    // highlight-next-line\n    expect(dateExpect).toHaveAttribute('datetime', COMMENT.createdAt)\n  })\n\n  // highlight-start\n  it('does not render a delete button if user is logged out', async () => {\n    render(<Comment comment={COMMENT} />)\n\n    await waitFor(() =>\n      expect(screen.queryByText('Delete')).not.toBeInTheDocument()\n    )\n  })\n\n  it('renders a delete button if the user is a moderator', async () => {\n    mockCurrentUser({\n      id: 1,\n      email: 'moderator@moderator.com',\n      roles: 'moderator',\n    })\n\n    render(<Comment comment={COMMENT} />)\n\n    await waitFor(() => expect(screen.getByText('Delete')).toBeInTheDocument())\n  })\n  // highlight-end\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Prisma Migrations in RedwoodJS Development\nDESCRIPTION: Executes the RedwoodJS CLI command (`yarn rw prisma migrate dev`) to apply schema changes defined in `schema.prisma` to the development database. This command creates a new migration file, updates the database schema, and generates/updates the Prisma Client. It's a standard step after modifying the data model.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Generating a Cell with RedwoodJS CLI - Bash\nDESCRIPTION: This Bash command uses RedwoodJS's code generator to scaffold a new CommentsCell component. It creates the component boilerplate along with mocks and stories for Storybook, easing UI development and testing. The command requires RedwoodJS CLI and a properly initialized RedwoodJS project (“yarn rw” available); the “Comments” argument sets the cell’s entity name.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g cell Comments\n```\n\n----------------------------------------\n\nTITLE: Defining Post Pagination GraphQL SDL - RedwoodJS - TypeScript\nDESCRIPTION: Defines the GraphQL SDL in TypeScript for a RedwoodJS app, introducing a paged PostPage query with an optional 'page' argument, which returns posts and a total count for pagination UI. Requires '@redwoodjs/graphql-server' and Prisma models for Post, facilitating frontend pagination logic. The schema extends the Query type with 'postPage', 'posts', and 'post' queries.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const schema = gql`\n  # ...\n\n  type PostPage {\n    posts: [Post!]!\n    count: Int!\n  }\n\n  type Query {\n    postPage(page: Int): PostPage\n    posts: [Post!]!\n    post(id: Int!): Post!\n  }\n\n  # ...\n`\n```\n\n----------------------------------------\n\nTITLE: Querying Auctions and Bids with Live Queries - GraphQL\nDESCRIPTION: Demonstrates live querying for auctions and placing bids using GraphQL with RedwoodJS. The `GetCurrentAuctionBids` query leverages the `@live` directive for automatic updates, while the `MakeBid` mutation submits a new bid for an auction. No external dependencies beyond RedwoodJS and a compliant GraphQL server. Query parameter is the auction ID; mutation values include the auction ID and the bid amount. Returns auction and bid information, auto-refreshing the client on data changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\nquery GetCurrentAuctionBids @live {\n  auction(id: \"1\") {\n    bids {\n      amount\n    }\n    highestBid {\n      amount\n    }\n    id\n    title\n  }\n}\n\nmutation MakeBid {\n  bid(input: { auctionId: \"1\", amount: 10 }) {\n    amount\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing getCurrentUser and Auth Helpers in Redwood API - JavaScript\nDESCRIPTION: This backend snippet configures getCurrentUser, isAuthenticated, hasRole, and requireAuth utility functions for RedwoodJS API authentication in JavaScript. getCurrentUser retrieves the authenticated user's id via Prisma db querying and populates currentUser on the context, while isAuthenticated and hasRole implement authorization logic. Requires @redwoodjs/graphql-server, a Prisma db instance, and Redwood's API context. The getCurrentUser function currently only returns the id field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nimport { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\\nimport { db } from './db'\\n\\nexport const getCurrentUser = async (session) => {\\n  return await db.user.findUnique({\\n    where: { id: session.id },\\n    select: { id: true },\\n  })\\n}\\n\\nexport const isAuthenticated = () => {\\n  return !!context.currentUser\\n}\\n\\nexport const hasRole = (roles) => {\\n  if (!isAuthenticated()) {\\n    return false\\n  }\\n\\n  const currentUserRoles = context.currentUser?.roles\\n\\n  if (typeof roles === 'string') {\\n    if (typeof currentUserRoles === 'string') {\\n      // roles to check is a string, currentUser.roles is a string\\n      return currentUserRoles === roles\\n    } else if (Array.isArray(currentUserRoles)) {\\n      // roles to check is a string, currentUser.roles is an array\\n      return currentUserRoles?.some((allowedRole) => roles === allowedRole)\\n    }\\n  }\\n\\n  if (Array.isArray(roles)) {\\n    if (Array.isArray(currentUserRoles)) {\\n      // roles to check is an array, currentUser.roles is an array\\n      return currentUserRoles?.some((allowedRole) =>\\n        roles.includes(allowedRole)\\n      )\\n    } else if (typeof currentUserRoles === 'string') {\\n      // roles to check is an array, currentUser.roles is a string\\n      return roles.some((allowedRole) => currentUserRoles === allowedRole)\\n    }\\n  }\\n\\n  // roles not found\\n  return false\\n}\\n\\nexport const requireAuth = ({ roles } = {}) => {\\n  if (!isAuthenticated()) {\\n    throw new AuthenticationError(\"You don't have permission to do that.\")\\n  }\\n\\n  if (roles && !hasRole(roles)) {\\n    throw new ForbiddenError(\"You don't have access to do that.\")\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Using useAuth Hook in Redwood BlogLayout - JavaScript\nDESCRIPTION: This snippet demonstrates setting up the BlogLayout component in JavaScript with the useAuth hook to access authentication state, user info, and logOut functionality. It establishes the structure for a blog layout with navigation links and shows how to extract isAuthenticated, currentUser, and logOut but does not yet render login/logout UI. Requires @redwoodjs/router and src/auth, and expects that the app is set up with RedwoodJS authentication (dbAuth or other provider). Expects children React nodes as input.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\\n\\n// highlight-next-line\\nimport { useAuth } from 'src/auth'\\n\\nconst BlogLayout = ({ children }) => {\\n  // highlight-next-line\\n  const { isAuthenticated, currentUser, logOut } = useAuth()\\n\\n  return (\\n    <>\\n      <header>\\n        <h1>\\n          <Link to={routes.home()}>Redwood Blog</Link>\\n        </h1>\\n        <nav>\\n          <ul>\\n            <li>\\n              <Link to={routes.home()}>Home</Link>\\n            </li>\\n            <li>\\n              <Link to={routes.about()}>About</Link>\\n            </li>\\n            <li>\\n              <Link to={routes.contact()}>Contact</Link>\\n            </li>\\n          </ul>\\n        </nav>\\n      </header>\\n      <main>{children}</main>\\n    </>\\n  )\\n}\\n\\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Generating GraphQL SDL and Service in RedwoodJS (Bash)\nDESCRIPTION: This command generates a GraphQL schema definition (SDL) file and a corresponding service object based on a specified Prisma model. It inspects `schema.prisma` to infer types and relations, although the mapping might not be perfect. It includes options like `--crud`, `--docs`, `--force`, `--tests`, `--typescript`, and `--rollback` to customize the generation process.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_75\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate sdl <model>\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Password Validation Logic in JavaScript\nDESCRIPTION: Defines the `signup.passwordValidation` function to enforce specific password complexity rules during signup. It receives the `password` as input. The example checks for minimum length (8 characters) and the presence of at least one capital letter. If the password is valid, it returns `true`. If invalid, it throws a `PasswordValidationError` with a user-friendly message. This validation occurs server-side.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nsignup: {\n  passwordValidation: (password) => {\n    if (password.length < 8) {\n      throw new PasswordValidationError(\n        'Password must be at least 8 characters'\n      )\n    }\n\n    if (!password.match(/[A-Z]/)) {\n      throw new PasswordValidationError(\n        'Password must contain at least one capital letter'\n      )\n    }\n\n    return true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Login Handler Logic in dbAuth - JavaScript\nDESCRIPTION: Shows an example of customizing the dbAuth login.handler function to require email validation before allowing user login. The handler performs an additional check on user.verified and throws an error if validation is not complete. Place this code in the login section of the dbAuth configuration object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nlogin: {\n  handler: (user) => {\n    if (!user.verified) {\n      throw new Error('Please validate your email first!')\n    } else {\n      return user\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Signing In with OAuth using RedwoodJS `useAuth` Hook (TypeScript)\nDESCRIPTION: Initiates the OAuth sign-in flow for a third-party provider (e.g., GitHub). Uses the `logIn` method from the RedwoodJS `useAuth` hook with `authMethod: 'oauth'` and specifies the provider.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst { logIn } = useAuth()\n\nawait logIn({\n  authMethod: 'oauth',\n  provider: 'github',\n})\n```\n\n----------------------------------------\n\nTITLE: Getting Current URL with useLocation - RedwoodJS React Hook - JavaScript/JSX\nDESCRIPTION: Shows how to read the current browser URL using the useLocation hook from RedwoodJS, giving access to pathname, search, and hash as reactive values. Requires '@redwoodjs/router'. Snippet also demonstrates using React.useEffect for logging navigation and conditional rendering based on the hash part of the URL. Inputs are the user's navigation actions; outputs include updated state and possibly different render output.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_22\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useLocation } from '@redwoodjs/router'\n\nconst App = () => {\n  const { pathname, search, hash } = useLocation()\n\n  // log the URL when the pathname changes\n  React.useEffect(() => {\n    myLogger(pathname)\n  }, [pathname])\n\n  // initiate a query state with the search val\n  const [query, setQuery] = React.useState(search)\n\n  // conditionally render based on hash\n  if (hash === '#ping') {\n    return <Pong />\n  }\n\n  return <>...</>\n}\n```\n\n----------------------------------------\n\nTITLE: Ensuring Uniqueness with validateUniqueness and Prisma in JavaScript/JSX\nDESCRIPTION: validateUniqueness guarantees that certain field values are unique before executing a database operation. In this example, it prevents creating a user with a duplicate username by first checking existence and then invoking a callback if unique. This relies on Prisma's transaction API and accepts a table name, filter, and callback. Requires validateUniqueness() and a Prisma-like db client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_51\n\nLANGUAGE: jsx\nCODE:\n```\nreturn validateUniqueness('user', { username: input.username }, (db) => {\n  return db.user.create({ data: input })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Comments Query by postId in Service Layer - JavaScript\nDESCRIPTION: This service function implements the logic to fetch comments filtered by postId in a RedwoodJS application using JavaScript. It relies on the db.comment.findMany Prisma query and expects a destructured postId parameter. All returned comments are tied to the specified postId, with no additional filtering or constraints.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_34\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const comments = ({ postId }) => {\\n  return db.comment.findMany({ where: { postId } })\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT Verification Options for Netlify in RedwoodJS (TypeScript)\nDESCRIPTION: This snippet shows how to configure `VerifyOptions` for JWT-based webhook verification using `@redwoodjs/api/webhooks`, specifically tailored for Netlify. It specifies the `signatureHeader` ('X-Webhook-Signature') expected in the incoming request and the required `issuer` claim ('netlify') within the JWT payload. These options ensure the webhook originates from Netlify and the signature is correctly located.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\n    const options = {\n      signatureHeader: 'X-Webhook-Signature',\n      issuer: 'netlify',\n    } as VerifyOptions\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Social Login Environment Variables - Bash\nDESCRIPTION: Lists the required SuperTokens environment variables to enable social login providers (Apple, GitHub, Google). These client IDs and secrets are necessary for enabling OAuth flows and must be set for each desired provider. Place in .env and ensure values are kept secure. Input: Social login client credentials. Output: Social authentication is enabled in the application.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supertokens.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nSUPERTOKENS_APPLE_CLIENT_ID=4398792-io.supertokens.example.service\nSUPERTOKENS_APPLE_SECRET_KEY_ID=7M48Y4RYDL\nSUPERTOKENS_APPLE_SECRET_PRIVATE_KEY=-----BEGIN PRIVATE KEY-----\\nMIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgu8gXs+XYkqXD6Ala9Sf/iJXzhbwcoG5dMh1OonpdJUmgCgYIKoZIzj0DAQehRANCAASfrvlFbFCYqn3I2zeknYXLwtH30JuOKestDbSfZYxZNMqhF/OzdZFTV0zc5u5s3eN+oCWbnvl0hM+9IW0UlkdA\\n-----END PRIVATE KEY-----\nSUPERTOKENS_APPLE_SECRET_TEAM_ID=YWQCXGJRJL\nSUPERTOKENS_GITHUB_CLIENT_ID=467101b197249757c71f\nSUPERTOKENS_GITHUB_CLIENT_SECRET=e97051221f4b6426e8fe8d51486396703012f5bd\nSUPERTOKENS_GOOGLE_CLIENT_ID=1060725074195-kmeum4crr01uirfl2op9kd5acmi9jutn.apps.googleusercontent.com\nSUPERTOKENS_GOOGLE_CLIENT_SECRET=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\n```\n\n----------------------------------------\n\nTITLE: Testing Article Comment Rendering with RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript-based test suite for RedwoodJS mirrors the JavaScript version and provides type-safe assurance for Article component rendering. It imports necessary testing utilities and mock data, ensuring thorough coverage of both full and summary article render modes. Key parameters include the typed article object and summary flag. It checks comment display logic and uses waitFor() for asynchronous assertions. Inputs are typed article data and rendering mode; outputs verify the expected presence or absence of comments in the DOM. Requires a TypeScript-enabled RedwoodJS environment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\n// highlight-start\\nimport { render, screen, waitFor } from '@redwoodjs/testing'\\n\\nimport { standard } from 'src/components/CommentsCell/CommentsCell.mock'\\n// highlight-end\\n\\nimport Article from './Article'\\n\\nconst ARTICLE = {\\n  id: 1,\\n  title: 'First post',\\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\\n  createdAt: new Date().toISOString(),\\n}\\n\\ndescribe('Article', () => {\\n  it('renders a blog post', () => {\\n    render(<Article article={ARTICLE} />)\\n\\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\\n    expect(screen.getByText(ARTICLE.body)).toBeInTheDocument()\\n  })\\n\\n  // highlight-start\\n  it('renders comments when displaying a full blog post', async () => {\\n    const comment = standard().comments[0]\\n    render(<Article article={ARTICLE} />)\\n\\n    await waitFor(() =>\\n      expect(screen.getByText(comment.body)).toBeInTheDocument()\\n    )\\n  })\\n  // highlight-end\\n\\n  it('renders a summary of a blog post', () => {\\n    render(<Article article={ARTICLE} summary={true} />)\\n\\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\\n    expect(\\n      screen.getByText(\\n        'Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Str...'\\n      )\\n    ).toBeInTheDocument()\\n  })\\n\\n  // highlight-start\\n  it('does not render comments when displaying a summary', async () => {\\n    const comment = standard().comments[0]\\n    render(<Article article={ARTICLE} summary={true} />)\\n\\n    await waitFor(() =>\\n      expect(screen.queryByText(comment.body)).not.toBeInTheDocument()\\n    )\\n  })\\n  // highlight-end\\n})\\n\n```\n\n----------------------------------------\n\nTITLE: Enhancing Comment Component with Styling and Date Formatting in JavaScript\nDESCRIPTION: This JSX snippet enhances the 'Comment' component by adding styling using Tailwind CSS classes and implementing a `formattedDate` helper function. The function takes an ISO8601 datetime string, parses it, and returns a more readable date format (e.g., '1 January 2020'). The component structure is updated to apply styles and use the formatted date.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/the-redwood-way.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-start\nconst formattedDate = (datetime) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n// highlight-end\n\nconst Comment = ({ comment }) => {\n  return (\n    // highlight-start\n    <div className=\"bg-gray-200 p-8 rounded-lg\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n    </div>\n    // highlight-end\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Custom Fonts in web/public (Shell/Text)\nDESCRIPTION: Illustrates the recommended practice of placing custom font files (e.g., `RedwoodNeue.woff2`) within a dedicated `fonts` subdirectory inside the `web/public` folder. This ensures the fonts are copied to the build output and served statically.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/assets-and-files.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nweb/\n├── src\n├── App.tsx\n├── entry.client.tsx\n├── index.css\n├── ...\n├── public\n│ ├── favicon.png\n│ ├── fonts\n// highlight-next-line\n│ │ └── RedwoodNeue.woff2\n```\n\n----------------------------------------\n\nTITLE: Managing Passwordless Login Page State - RedwoodJS - JavaScript\nDESCRIPTION: This JavaScript/JSX snippet implements the LoginPasswordlessPage for RedwoodJS, which controls and renders either a token input form or email input form based on the application's state. It uses useState and useEffect to manage state variables (waitingForCode, email, code) and parses URL query parameters to handle automatic logins. The page selects and passes appropriate props to child components, and requires dependencies: @redwoodjs/web, @redwoodjs/router, and local form components. Inputs: email/code from URL params; output: renders the next authentication form.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useEffect, useState } from 'react'\n\nimport { useLocation } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\n\nimport LoginPasswordlessForm from 'src/components/LoginPasswordlessForm/LoginPasswordlessForm'\nimport LoginPasswordlessTokenForm from 'src/components/LoginPasswordlessTokenForm/LoginPasswordlessTokenForm'\n\nconst LoginPasswordlessPage = () => {\n  const [waitingForCode, setWaitingForCode] = useState(false)\n  const [email, setEmail] = useState('')\n  const [code, setCode] = useState('')\n\n  const { search } = useLocation()\n\n  useEffect(() => {\n    const params = new URLSearchParams(search)\n    const magic = params.get('magic')\n    const decoded = window.atob(magic)\n\n    // if magic param exists, set email and waitingForCode\n    if (magic) {\n      // decoded is email:code\n      const [email, code] = decoded.split(':')\n\n      setEmail(email)\n      setCode(code)\n      setWaitingForCode(true)\n    }\n  }, [search])\n\n  return (\n    <>\n      <Metadata\n        title=\"LoginPasswordless\"\n        description=\"LoginPasswordless page\"\n      />\n\n      {waitingForCode ? (\n        <LoginPasswordlessTokenForm\n          email={email}\n          setWaitingForCode={setWaitingForCode}\n          code={code}\n        />\n      ) : (\n        <LoginPasswordlessForm\n          setWaitingForCode={setWaitingForCode}\n          setEmail={setEmail}\n        />\n      )}\n    </>\n  )\n}\n\nexport default LoginPasswordlessPage\n```\n\n----------------------------------------\n\nTITLE: Accessing the Supabase Auth Client in RedwoodJS (TypeScript)\nDESCRIPTION: Shows how to get direct access to the initialized Supabase authentication client instance using the `client` property from the RedwoodJS `useAuth` hook. This allows calling any Supabase JS SDK auth methods directly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst { client } = useAuth()\n```\n\n----------------------------------------\n\nTITLE: Constructing Public File URLs on the Client-Side in TypeScript\nDESCRIPTION: This TypeScript code shows how to construct the full public URL for a file on the client-side (web) after configuring a public directory on the API server (as shown in the previous `api/server.js` example). It combines the global `RWJS_API_URL` with the relative file path stored in `profile.avatar`, replacing the internal storage path prefix with the publicly configured URL prefix (`public_uploads/`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst publicUrl = `${global.RWJS_API_URL}/${profile.avatar.replace(\n  'uploads/public_profile_photos/',\n  'public_uploads/'\n)}`\n```\n\n----------------------------------------\n\nTITLE: Handling GraphQL Handler Loading Warning in RedwoodJS (Shell)\nDESCRIPTION: Displays the shell warning that occurs if the GraphQL handler is missing or could not be loaded during RedwoodJS builds. No direct dependencies or parameters, but helps diagnose build issues due to handler location or import errors. The warning informs users that Cells will render in their Loading state until the issue is resolved.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n⚠️ Could not load your GraphQL handler.\nYour Cells have been prerendered in the \"Loading\" state.\n```\n\n----------------------------------------\n\nTITLE: Defining ArticleCell GraphQL Query and States (TypeScript)\nDESCRIPTION: This TypeScript snippet defines the typed `ArticleCell` component (`web/src/components/ArticleCell/ArticleCell.tsx`). It uses `TypedDocumentNode` for the `FindArticleQuery`, specifying input (`FindArticleQueryVariables`) and output (`FindArticleQuery`) types. The query fetches a post by `$id`, aliased as `article`. Typed components for `Loading`, `Empty`, `Failure` (using `CellFailureProps`), and `Success` (using `CellSuccessProps`) states are provided.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/ArticleCell/ArticleCell.tsx\"\nimport type { FindArticleQuery, FindArticleQueryVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypedDocumentNode,\n} from '@redwoodjs/web'\n\nexport const QUERY: TypedDocumentNode<\n  FindArticleQuery,\n  FindArticleQueryVariables\n> = gql`\n  query FindArticleQuery($id: Int!) {\n    // highlight-next-line\n    article: post(id: $id) {\n      id\n      // highlight-start\n      title\n      body\n      createdAt\n      // highlight-end\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<FindArticleQueryVariables>) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  article,\n}: CellSuccessProps<FindArticleQuery, FindArticleQueryVariables>) => {\n  return <div>{JSON.stringify(article)}</div>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Building and Saving a New Record using `build()` and `save()` in JSX\nDESCRIPTION: This snippet shows an alternative way to create records. First, use the static `build()` method to create a new, unsaved instance of the model with initial data. Then, call the instance method `save()` to persist it to the database. `save()` returns `false` on failure, unless `{ throw: true }` is passed as an argument, in which case it throws an error. After a failed save (without throwing), error details can be inspected via `user.hasErrors` and `user.errors`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = User.build({ firstName: 'Peter', lastName: 'Pistorius' })\nawait user.save()\n// or\nawait user.save({ throw: true })\n// check for errors\nuser.hasErrors // => true\nuser.errors.email // => ['can\\'t be null']\n```\n\n----------------------------------------\n\nTITLE: Adding Toaster Component for Toast Notifications - RedwoodJS - JSX\nDESCRIPTION: This snippet demonstrates how to integrate the Toaster component from @redwoodjs/web/toast at the layout level to globally enable toast notifications for the application. The Toaster should typically be placed in a Layout or App component so that toast messages can appear on any page. It requires the @redwoodjs/web/toast dependency, no parameters beyond the React component standard, and expects children to be rendered alongside the toaster. The key effect is enabling global rendering of toast pop-ups.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/toast-notifications.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\\nimport { Toaster } from '@redwoodjs/web/toast'\\n\\nconst MainLayout = ({ children }) => {\\n  return (\\n    <>\\n      // highlight-next-line\\n      <Toaster />\\n      <main>{children}</main>\\n    </>\\n  )\\n}\\n\\nexport default MainLayout\n```\n\n----------------------------------------\n\nTITLE: Modifying ArticlesCell Query and Success Prop (TypeScript/TSX)\nDESCRIPTION: This code modifies the generated `ArticlesCell.tsx` to align with an existing `posts` data model. The GraphQL query within `QUERY` is changed to fetch `posts { id }` instead of `articles`. The `Success` component's props are updated to destructure `posts` (received via `CellSuccessProps`), and the mapping iterates over `posts`. Note that the `ArticlesQuery` type imported might become inaccurate and require regeneration using `yarn rw g types` or manual adjustment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/ArticlesCell/ArticlesCell.tsx\"\nimport type { ArticlesQuery, ArticlesQueryVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypedDocumentNode,\n} from '@redwoodjs/web'\n\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> = // highlight-line\n  gql`\n    query ArticlesQuery {\n      // highlight-next-line\n      posts {\n        id\n      }\n    }\n  `\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<ArticlesQueryVariables>) => ( // highlight-line\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\n// highlight-next-line\nexport const Success = ({\n  posts,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => { // highlight-line\n  return (\n    <ul>\n      // highlight-next-line\n      {posts.map((item) => {\n        return <li key={item.id}>{JSON.stringify(item)}</li>\n      })}\n    </ul>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Displaying Toast Notifications on Contact Form Submission in RedwoodJS (JavaScript)\nDESCRIPTION: This snippet defines a RedwoodJS ContactPage component in JavaScript, which uses the `useMutation` hook with the `onCompleted` option to show a toast notification upon successful form submission. Dependencies include RedwoodJS components such as `Form`, `Label`, and `TextField`, and the toast notification utilities from '@redwoodjs/web/toast'. The snippet receives user input via a form, validates required fields (name, email, message), and sends the data via a GraphQL mutation. On success, a toast message is shown using the <Toaster/> component. Inputs include `name`, `email`, and `message` fields, and the output is a submission saved on the backend with a success notification presented to the user.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata, useMutation } from '@redwoodjs/web'\\n// highlight-next-line\\nimport { toast, Toaster } from '@redwoodjs/web/toast'\\nimport {\\n  FieldError,\\n  Form,\\n  Label,\\n  TextField,\\n  TextAreaField,\\n  Submit,\\n} from '@redwoodjs/forms'\\n\\nconst CREATE_CONTACT = gql`\\n  mutation CreateContactMutation($input: CreateContactInput!) {\\n    createContact(input: $input) {\\n      id\\n    }\\n  }\\n`\\n\\nconst ContactPage = () => {\\n  // highlight-start\\n  const [create, { loading, error }] = useMutation(CREATE_CONTACT, {\\n    onCompleted: () => {\\n      toast.success('Thank you for your submission!')\\n    },\\n  })\\n  // highlight-end\\n\\n  const onSubmit = (data) => {\\n    create({ variables: { input: data } })\\n  }\\n\\n  return (\\n    <>\\n      <Metadata title=\"Contact\" description=\"Contact page\" />\\n\\n      // highlight-next-line\\n      <Toaster />\\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\\n        <Label name=\"name\" errorClassName=\"error\">\\n          Name\\n        </Label>\\n        <TextField\\n          name=\"name\"\\n          validation={{ required: true }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"name\" className=\"error\" />\\n\\n        <Label name=\"email\" errorClassName=\"error\">\\n          Email\\n        </Label>\\n        <TextField\\n          name=\"email\"\\n          validation={{\\n            required: true,\\n            pattern: {\\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\\n            },\\n          }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"email\" className=\"error\" />\\n\\n        <Label name=\"message\" errorClassName=\"error\">\\n          Message\\n        </Label>\\n        <TextAreaField\\n          name=\"message\"\\n          validation={{ required: true }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"message\" className=\"error\" />\\n\\n        <Submit disabled={loading}>Save</Submit>\\n      </Form>\\n    </>\\n  )\\n}\\n\\nexport default ContactPage\\n\n```\n\n----------------------------------------\n\nTITLE: Refetching Comments Query on Comment Creation in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript variant of the useMutation hook similarly refetches the CommentsQuery with the relevant postId variable after a successful comment creation. The setup uses Apollo Client, the CREATE mutation, and expects proper type definitions for Comment creation and CommentsQuery. Inputs are the CREATE mutation, CommentsQuery, and postId variable; outputs are the updated local cache, ensuring the comment list is refreshed to include new data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_35\n\nLANGUAGE: jsx\nCODE:\n```\nconst [createComment, { loading, error }] = useMutation(CREATE, {\\n  onCompleted: () => {\\n    setHasPosted(true)\\n    toast.success('Thank you for your comment!')\\n  },\\n  // highlight-next-line\\n  refetchQueries: [{ query: CommentsQuery, variables: { postId } }],\\n})\n```\n\n----------------------------------------\n\nTITLE: Updating GraphQL Query for Refetching in RedwoodJS Cell (TSX)\nDESCRIPTION: This snippet shows the updated GraphQL query (`QUERY`) within the `CommentsCell.tsx` file, using TypeScript. The `postId` field is added to the selection set, similar to the JavaScript version. The query constant is typed using `TypedDocumentNode` along with generated types (`CommentsQuery`, `CommentsQueryVariables`) for enhanced type safety.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\n//\nexport const QUERY: TypedDocumentNode<CommentsQuery, CommentsQueryVariables> =\n  gql`\n    query CommentsQuery($postId: Int!) {\n      comments(postId: $postId) {\n        id\n        name\n        body\n        // highlight-next-line\n        postId\n        createdAt\n      }\n    }\n  `\n```\n\n----------------------------------------\n\nTITLE: Defining Explicit Many-to-Many Relation for RedwoodJS CRUD in Prisma Schema\nDESCRIPTION: This Prisma schema snippet demonstrates an explicit many-to-many relationship between `Product` and `Tag` using a manually defined join table `ProductsOnTag`. This join table includes its own `id` field (`@id @default(autoincrement())`) and enforces uniqueness on the combination of `tagId` and `productId` using `@@unique`. This structure is compatible with RedwoodJS SDL and scaffold generators requiring a single ID for CRUD operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/schema-relations.md#_snippet_1\n\nLANGUAGE: prisma\nCODE:\n```\nmodel Product {\n  id    Int         @id @default(autoincrement())\n  title String\n  desc  String\n  tags  ProductsOnTag[]\n}\n\nmodel Tag {\n  id       Int      @id @default(autoincrement())\n  name     String\n  products ProductsOnTag[]\n}\n\nmodel ProductsOnTag {\n  id        Int     @id @default(autoincrement())\n  tagId     Int\n  tag       Tag     @relation(fields: [tagId], references: [id])\n  productId Int\n  product   Product @relation(fields: [productId], references: [id])\n\n  @@unique([tagId, productId])\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Service Retrieval Function with Redwood and Jest - TypeScript\nDESCRIPTION: This snippet adapts the RedwoodJS comments() retrieval service test to TypeScript, using type information for the scenario argument to improve type safety. Requires RedwoodJS, Jest, TypeScript, and the relevant Prisma type definitions. The test validates that the comments() function retrieves the correct number of comments seeded by the scenario setup, comparing the result's length with the seeded scenario's comment count. Inputs: scenario data typed as StandardScenario; Output: assertion of array length equality.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nimport { comments } from './comments'\\n\\ndescribe('comments', () => {\\n  scenario('returns all comments', async (scenario: StandardScenario) => {\\n    const result = await comments()\\n\\n    expect(result.length).toEqual(Object.keys(scenario.comment).length)\\n  })\\n})\n```\n\n----------------------------------------\n\nTITLE: Testing List Rendering Using getByRole with React Testing Library in JavaScript\nDESCRIPTION: Demonstrates how to assert that links for each user in a data array are rendered with the correct accessible role and label. Uses screen.getByRole with option 'name' to target specific links. 'render' is called with a List component and test data. Each user's name is checked to be present as a link. Requires React, '@redwoodjs/testing/web', List component, and a data array. Useful for accessibility and ensuring semantic HTML.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nit('renders a link with a name', () => {\n  render(<List data={[{ name: 'Rob' }, { name: 'Tom' }]} />)\n\n  expect(screen.getByRole('link', { name: 'Rob' })).toBeInTheDocument()\n  expect(screen.getByRole('link', { name: 'Tom' })).toBeInTheDocument()\n})\n```\n\n----------------------------------------\n\nTITLE: Applying Field-Level @requireAuth in RedwoodJS GraphQL Schema\nDESCRIPTION: Demonstrates applying the `@requireAuth` directive directly to a specific field (`body`) within a GraphQL type definition (`Post`). This enforces authentication checks specifically when a client requests this field, allowing for granular authorization control at the field level.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_57\n\nLANGUAGE: ts\nCODE:\n```\ntype Post {\n  id: Int!\n  title: String!\n  body: String! @requireAuth\n  authorId: Int!\n  author: User!\n  createdAt: DateTime!\n}\n```\n\n----------------------------------------\n\nTITLE: User Creation with Custom Uniqueness Error Message using validateUniqueness in JavaScript/JSX\nDESCRIPTION: Similar to the previous example, this version provides a custom message if the email is not unique by leveraging the options parameter. The error 'Your email is already in use' will be shown if validation fails. Useful for friendly user feedback in signup forms. Requires validateUniqueness(), db.user.create(), and familiarity with the options argument.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_54\n\nLANGUAGE: jsx\nCODE:\n```\nconst createUser = (input) => {\n  return validateUniqueness(\n    'user',\n    { email: input.email },\n    { message: 'Your email is already in use' },\n    (db) => db.user.create({ data: input })\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating BlogLayout Component in RedwoodJS (JavaScript)\nDESCRIPTION: Defines a BlogLayout component in JavaScript that provides a shared header and main structure for wrapped pages in RedwoodJS. The layout imports Link and routes from '@redwoodjs/router', displays a navigation header, and renders any child content inside the main section. This pattern centralizes UI elements common to multiple pages, reducing duplication. Required dependencies: @redwoodjs/router. The children prop receives the page's unique content, supporting composition.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\\n\\nconst BlogLayout = ({ children }) => {\\n  return (\\n    // highlight-start\\n    <>\\n      <header>\\n        <h1>Redwood Blog</h1>\\n        <nav>\\n          <ul>\\n            <li>\\n              <Link to={routes.about()}>About</Link>\\n            </li>\\n          </ul>\\n        </nav>\\n      </header>\\n      <main>{children}</main>\\n    </>\\n    // highlight-end\\n  )\\n}\\n\\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Rendering Paginated Blog Posts Success - RedwoodJS Cell - JavaScript\nDESCRIPTION: Defines the 'Success' component in a RedwoodJS Cell, mapping over 'postPage.posts' and rendering a 'BlogPost' for each, using the post ID as a key. This pattern is used in Cell components post successful GraphQL fetch. Expects a prop postPage containing the 'posts' array, aligning with the query result structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Success = ({ postPage }) => {\n  return postPage.posts.map((post) => <BlogPost key={post.id} post={post} />)\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Relation Resolvers with Prisma Include (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates optimizing a relation resolver by including the related data (`author`) in the parent query (`post`) using Prisma's `include` option. The `Post.author` resolver then first checks if `root.author` is already populated before potentially fetching it, reducing database queries when the author is frequently needed alongside the post. The trade-off is potentially fetching the author even when not explicitly requested in the GraphQL query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const post: QueryResolvers['post'] = ({ id }) => {\n  return db.post.findUnique({\n    // highlight-start\n    include: {\n      author: true,\n    },\n    // highlight-end\n    where: { id },\n  })\n}\n\nexport const Post: PostRelationResolvers = {\n  author: async (_obj, { root }) => {\n   // highlight-start\n    if (root.author) {\n      return root.author\n    }\n  // highlight-end\n\n  const maybeAuthor = await db.post.findUnique(// ...\n\n```\n\n----------------------------------------\n\nTITLE: Testing Article Component Rendering and Summary in JavaScript (JSX)\nDESCRIPTION: This JavaScript test suite uses `@redwoodjs/testing` (`render`, `screen`) to verify the rendering behavior of the `Article` component. It defines a constant `ARTICLE` containing sample blog post data. The first test case (`renders a blog post`) checks if the component renders the full article title and body when no `summary` prop is provided. The second test case (`renders a summary of a blog post`) asserts that the component renders the title and a specific truncated version of the body when the `summary={true}` prop is passed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Article/Article.test.jsx\"\nimport { render, screen } from '@redwoodjs/testing'\n\nimport Article from './Article'\n\n// highlight-start\nconst ARTICLE = {\n  id: 1,\n  title: 'First post',\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\n  createdAt: new Date().toISOString(),\n}\n// highlight-end\n\ndescribe('Article', () => {\n  it('renders a blog post', () => {\n    // highlight-next-line\n    render(<Article article={ARTICLE} />)\n\n    // highlight-start\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(screen.getByText(ARTICLE.body)).toBeInTheDocument()\n    // highlight-end\n  })\n\n  // highlight-start\n  it('renders a summary of a blog post', () => {\n    render(<Article article={ARTICLE} summary={true} />)\n\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(\n      screen.getByText(\n        'Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Str...'\n      )\n    ).toBeInTheDocument()\n  })\n  // highlight-end\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Mapping Auth SDK to Redwood Auth Interface - Basic Placeholder - TypeScript\nDESCRIPTION: Defines the createAuthImplementation function connecting a generic client object to Redwood's expected authentication interface. Includes asynchronous wrappers for all critical authentication flows (login, logout, signup, token retrieval, user metadata). This is intended as a template to be adapted for any provider, retaining method names but replacing their implementations for provider-specific APIs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// This is where most of the integration work will take place. You should keep\n// the shape of this object (i.e. keep all the key names) but change all the\n// values/functions to use methods from the auth service provider client sdk\n// you're integrating with\nfunction createAuthImplementation(client: AuthClient) {\n  return {\n    type: 'custom-auth',\n    client,\n    login: async () => client.login(),\n    logout: async () => client.logout(),\n    signup: async () => client.signup(),\n    getToken: async () => client.getToken(),\n    /**\n     * Actual user metadata might look something like this\n     * {\n     *   \"id\": \"11111111-2222-3333-4444-5555555555555\",\n     *   \"aud\": \"authenticated\",\n     *   \"role\": \"authenticated\",\n     *   \"roles\": [\"admin\"],\n     *   \"email\": \"email@example.com\",\n     *   \"app_metadata\": {\n     *     \"provider\": \"email\"\n     *   },\n     *   \"user_metadata\": null,\n     *   \"created_at\": \"2016-05-15T19:53:12.368652374-07:00\",\n     *   \"updated_at\": \"2016-05-15T19:53:12.368652374-07:00\"\n     * }\n     */\n    getUserMetadata: async () => client.getUserMetadata(),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Prisma Migrate Dev for Schema Changes (Shell)\nDESCRIPTION: This command runs a development migration using Prisma, applying schema changes to the database as defined in 'schema.prisma'. The user is prompted to provide a name for the migration. Requires a valid Prisma setup within a Redwood project and a properly defined schema. Results in updated database tables matching schema changes, and a new migration file in the project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Rendering Paginated Blog Posts Success - RedwoodJS Cell - TypeScript\nDESCRIPTION: Implements the 'Success' Cell component in TypeScript for rendering paginated blog posts, receiving the typed 'postPage' prop from the GraphQL query. Maps over the returned posts and renders a 'BlogPost' component for each, ensuring type safety with typed CellSuccessProps. Relies on type definitions generated by RedwoodJS's GraphQL tooling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nexport const Success = ({\n  postPage,\n}: CellSuccessProps<BlogPostsQuery, BlogPostsQueryVariables>) => {\n  return postPage.posts.map((post) => <BlogPost key={post.id} post={post} />)\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Subscription Event - RedwoodJS CLI - Bash/Plaintext\nDESCRIPTION: This output represents the steps and results when generating a subscription event via RedwoodJS CLI. The prompts and confirmations show the process. Dependencies: valid RedwoodJS environment with realtime support and yarn. Inputs: event name; outputs: new subscription files and types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_66\n\nLANGUAGE: plaintext\nCODE:\n```\n~/redwood-app$ yarn rw g realtime NewSub\n? What type of realtime event would you like to create? › - Use arrow-keys. Return to submit.\nLive Query\n❟ Subscription - Create a Subscription to watch for events\n\n✔ What type of realtime event would you like to create? › Subscription\n✔ Checking for realtime environment prerequisites ...\n✔ Adding newsub example subscription ...\n✔ Generating types ...\n```\n\n----------------------------------------\n\nTITLE: Mocking currentUser for Moderator View in Storybook (JSX)\nDESCRIPTION: This JSX snippet demonstrates mocking the current user within the `moderatorView` story using the globally available `mockCurrentUser` function provided by RedwoodJS in the Storybook environment. It passes a user object with `id`, `email`, and the `roles` property set to 'moderator' to simulate an authenticated moderator user, enabling role-specific rendering (like a delete button) within the `Comment` component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Comment/Comment.stories.jsx\"\nexport const moderatorView = () => {\n  // highlight-start\n  mockCurrentUser({\n    id: 1,\n    email: 'moderator@moderator.com',\n    roles: 'moderator',\n  })\n  // highlight-end\n\n  return (\n    <Comment\n      comment={{\n        id: 1,\n        name: 'Rob Cameron',\n        body: 'This is the first comment!',\n        createdAt: '2020-01-01T12:34:56Z',\n        postId: 1,\n      }}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Email-Only Signup Page - RedwoodJS - JavaScript\nDESCRIPTION: This snippet defines the SignupPage component for registering users using only their email address within a RedwoodJS application. It uses RedwoodJS form components for input validation and state management, auto-focuses the email input, and generates a random password via the randomString function. Upon submission, it calls signUp with the user's email and a random password, handles responses using toast notifications, and navigates accordingly. Required dependencies are @redwoodjs/forms, @redwoodjs/router, @redwoodjs/web, @redwoodjs/web/toast, and a custom useAuth hook. Inputs: email; outputs: creates a user account and manages authentication and notifications.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useEffect, useRef } from 'react'\n\nimport { Form, Label, TextField, FieldError, Submit } from '@redwoodjs/forms'\nimport { Link, navigate, routes } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\nimport { toast, Toaster } from '@redwoodjs/web/toast'\n\nimport { useAuth } from 'src/auth'\n\nfunction randomString(length) {\n  const defaultLength = 32\n  const characterSet =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n  const array = new Uint8Array(length || defaultLength)\n\n  window.crypto.getRandomValues(array)\n\n  const returnString = Array.from(array)\n    .map((value) => characterSet[value % characterSet.length])\n    .join('')\n\n  return returnString\n}\n\nconst SignupPage = () => {\n  const { isAuthenticated, signUp } = useAuth()\n\n  useEffect(() => {\n    if (isAuthenticated) {\n      navigate(routes.home())\n    }\n  }, [isAuthenticated])\n\n  // focus on username box on page load\n  const emailRef = useRef(null)\n  useEffect(() => {\n    emailRef.current?.focus()\n  }, [])\n\n  const onSubmit = async (data) => {\n    const response = await signUp({\n      username: data.email,\n      password: randomString(), // this is a random string and is not important\n    })\n\n    if (response.message) {\n      toast(response.message)\n    } else if (response.error) {\n      toast.error(response.error)\n    } else {\n      // user is signed in automatically\n      toast.success('Welcome!')\n    }\n  }\n\n  return (\n    <>\n      <Metadata title=\"Signup\" />\n\n      <main className=\"rw-main\">\n        <Toaster toastOptions={{ className: 'rw-toast', duration: 6000 }} />\n        <div className=\"rw-scaffold rw-login-container\">\n          <div className=\"rw-segment\">\n            <header className=\"rw-segment-header\">\n              <h2 className=\"rw-heading rw-heading-secondary\">Signup</h2>\n            </header>\n\n            <div className=\"rw-segment-main\">\n              <div className=\"rw-form-wrapper\">\n                <Form onSubmit={onSubmit} className=\"rw-form-wrapper\">\n                  <Label\n                    name=\"email\"\n                    className=\"rw-label\"\n                    errorClassName=\"rw-label rw-label-error\"\n                  >\n                    Email\n                  </Label>\n                  <TextField\n                    name=\"email\"\n                    className=\"rw-input\"\n                    errorClassName=\"rw-input rw-input-error\"\n                    ref={emailRef}\n                    validation={{\n                      required: {\n                        value: true,\n                        message: 'Email is required',\n                      },\n                    }}\n                  />\n                  <FieldError name=\"email\" className=\"rw-field-error\" />\n\n                  <div className=\"rw-button-group\">\n                    <Submit className=\"rw-button rw-button-blue\">\n                      Sign Up\n                    </Submit>\n                  </div>\n                </Form>\n              </div>\n            </div>\n          </div>\n          <div className=\"rw-login-link\">\n            <span>Already have an account?</span>{' '}\n            <Link to={routes.login()} className=\"rw-link\">\n              Log in!\n            </Link>\n          </div>\n        </div>\n      </main>\n    </>\n  )\n}\n\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Caching Data with Default and Custom Expiry Using Redwood cache() - JavaScript\nDESCRIPTION: Shows example usages of RedwoodJS's `cache()` utility for wrapping data-fetching operations, with and without expiry. The `cache` function caches the resolved data for future retrieval, supporting both indefinite and time-limited (e.g., one hour) persistence. Requires an initialized cache client and access to a database query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_69\n\nLANGUAGE: js\nCODE:\n```\n// cache forever\\nconst posts = () => {\\n  return cache(`posts`, () => {\\n    return db.post.findMany()\\n  })\\n}\\n\\n// cache for 1 hour\\nconst posts = () => {\\n  return cache(\\n    `posts`,\\n    () => {\\n      return db.post.findMany()\\n    },\\n    { expires: 3600 }\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Current User ID and Email in RedwoodJS Auth\nDESCRIPTION: This function, `getCurrentUser`, asynchronously retrieves the currently authenticated user's data from the database using Prisma (`db`). It takes a `session` object containing the user's ID as input. The function uses `db.user.findUnique` to query the database, specifying the user's ID in the `where` clause and explicitly selecting only the `id` and `email` fields in the `select` clause. This ensures only necessary user information is fetched.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/lib/auth.js\"\nexport const getCurrentUser = async (session) => {\n  return await db.user.findUnique({\n    where: { id: session.id },\n    // highlight-next-line\n    select: { id: true, email: true },\n  })\n}\n```\n```\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/lib/auth.ts\"\nexport const getCurrentUser = async (session) => {\n  return await db.user.findUnique({\n    where: { id: session.id },\n    // highlight-next-line\n    select: { id: true, email: true },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Server-Side Trusted Documents Store in TypeScript\nDESCRIPTION: This snippet from `api/src/lib/trustedDocumentsStore.ts` shows the server-side store, which is automatically generated. It holds the mapping between the SHA-256 hash (e.g., `76308e971322b1ece4cdff75185bb61d7139e343`) and the corresponding GraphQL query string. The GraphQL server uses this store to look up the query associated with the hash received in a client request.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nexport const store = {\n  // ...\n  '76308e971322b1ece4cdff75185bb61d7139e343':\n    'query FindPosts { __typename posts { __typename authorId body createdAt id title } }',\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking requireAuth for Multiple Roles (JavaScript)\nDESCRIPTION: This snippet demonstrates invoking the `requireAuth` function to check if the current user is authenticated and has at least one of the specified roles ('admin', 'author', 'publisher'). It's used to protect backend operations requiring any of these roles.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nrequireAuth({ roles: ['admin', 'author', 'publisher'] })\n```\n\n----------------------------------------\n\nTITLE: Adding Sentry Envelop Plugin to Redwood GraphQL Handler - TypeScript\nDESCRIPTION: Shows how to integrate @envelop/sentry with the RedwoodJS GraphQL handler for enhanced API monitoring in a TypeScript project. Dependencies match the JavaScript version, specifically @envelop/sentry, @redwoodjs/graphql-server, and the local Sentry library setup. Parameters passed to 'createGraphQLHandler' control handler behavior; Sentry integration occurs with extraPlugins. File location is 'api/src/functions/graphql.ts'. The handler function output includes automatic Sentry error/performance reporting.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/monitoring/sentry.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useSentry } from '@envelop/sentry'\n\nimport { createGraphQLHandler } from '@redwoodjs/graphql-server'\n\nimport directives from 'src/directives/**/*.{js,ts}'\nimport sdls from 'src/graphql/**/*.sdl.{js,ts}'\nimport services from 'src/services/**/*.{js,ts}'\n\nimport 'src/lib/sentry'\n\n...\n\nexport const handler = createGraphQLHandler({\n  directives,\n  sdls,\n  services,\n  extraPlugins: [useSentry()],\n  ...\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Create Comment Functionality to TypeScript Service\nDESCRIPTION: This TypeScript snippet adds the `createComment` function with type safety. It defines an interface `CreateCommentArgs` specifying the `input` argument should conform to `Prisma.CommentCreateInput`. The function then uses `db.comment.create` to persist the new comment data provided in the `input` object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.ts\"\ninterface CreateCommentArgs {\n  input: Prisma.CommentCreateInput\n}\n\nexport const createComment = ({ input }: CreateCommentArgs) => {\n  return db.comment.create({\n    data: input,\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Testimonials with Prisma in RedwoodJS - JavaScript\nDESCRIPTION: This service function queries all testimonials from the database using Prisma within a RedwoodJS project. It requires the Prisma client to be configured and imported from 'src/lib/db'. When invoked, it fetches testimonial records with \\'findMany()\\' and returns them for use in a GraphQL query. Inputs/outputs strictly follow the types generated by Prisma, and there are no parameters for this function as it retrieves all entries.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/02_chapter0/what-is-redwood.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const testimonials = () => {\n  return db.testimonial.findMany()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Conditionally Rendering UI Based on User Role in RedwoodJS (TSX)\nDESCRIPTION: This TypeScript React component (`Comment.tsx`) uses the `useAuth` hook from `src/auth` to get the `hasRole` function. It checks if the logged-in user has the 'moderator' role and conditionally renders a 'Delete' button, similar to the JavaScript version but with TypeScript types for props and function parameters. A placeholder `moderate` function is included.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\nimport { useAuth } from 'src/auth'\n\nconst formattedDate = (datetime: ConstructorParameters<typeof Date>[0]) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n\ninterface Props {\n  comment: {\n    name: string\n    createdAt: string\n    body: string\n  }\n}\n\nconst Comment = ({ comment }: Props) => {\n  // highlight-start\n  const { hasRole } = useAuth()\n  const moderate = () => {\n    if (confirm('Are you sure?')) {\n      // TODO: delete comment\n    }\n  }\n  // highlight-end\n\n  return (\n    // highlight-next-line\n    <div className=\"bg-gray-200 p-8 rounded-lg relative\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n      // highlight-start\n      {hasRole('moderator') && (\n        <button\n          type=\"button\"\n          onClick={moderate}\n          className=\"absolute bottom-2 right-2 bg-red-500 text-xs rounded text-white px-2 py-1\"\n        >\n          Delete\n        </button>\n      )}\n      // highlight-end\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Accessing Uploaded File Details in a RedwoodJS Service\nDESCRIPTION: Shows how an uploaded file is received and accessed within a RedwoodJS service function (`updateProfile`). The `input.avatar` argument represents the uploaded file and conforms to the standard Web API `File` interface, providing properties like `filename`, `mimetype`, and methods like `arrayBuffer()` (or `createReadStream`) to access the file's content. The example logs the file details and shows a basic manual file write using Node.js `fs` module.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/services/profiles/profiles.ts\"\nexport const updateProfile = async ({ id, input }) => {\n  // highlight-next-line\n  console.log(input.avatar)\n  // File {\n  //   filename: 'profile-picture.jpg',\n  //   mimetype: 'image/jpeg',\n  //   createReadStream: [Function: createReadStream]\n  //  ...\n  // }\n\n  // Example without using the built-in helpers\n  await fs.writeFile(\n    '/test/profile.jpg',\n    Buffer.from(await input.avatar.arrayBuffer())\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Generating a New Page with Redwood CLI - Bash\nDESCRIPTION: This code snippet demonstrates using the RedwoodJS CLI to generate a new page named 'home' at the root path ('/'). The command will scaffold a React component, an associated test file, and a Storybook story, as well as add a route for the page. Prerequisite: RedwoodJS installed and project initialized. The only argument required is the page name and path; additional options are available via the Redwood documentation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/first-page.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate page home /\n```\n\n----------------------------------------\n\nTITLE: Implementing Article Component Logic in TSX with Types\nDESCRIPTION: Updates the TypeScript 'Article' component (`web/src/components/Article/Article.tsx`) to receive an 'article' object (typed as 'Post' from GraphQL types) as a prop via a defined 'Props' interface. It imports `Link` and `routes` from `@redwoodjs/router` to link to the detail page and displays the article's title (linked), body, and creation timestamp within an `<article>` tag. Requires the `Post` type definition from 'types/graphql'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_28\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-next-line\nimport type { Post } from 'types/graphql'\n\n// highlight-start\ninterface Props {\n  article: Post\n}\n// highlight-end\n\n// highlight-next-line\nconst Article = ({ article }: Props) => {\n  return (\n    // highlight-start\n    <article>\n      <header>\n        <h2>\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div>{article.body}</div>\n      <div>Posted at: {article.createdAt}</div>\n    </article>\n    // highlight-end\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Adding Computed Field Resolver (age) to User - RedwoodJS - JSX\nDESCRIPTION: Demonstrates how to define a computed field resolver in RedwoodJS by adding an 'age' property to the Users resolver object. Calculates age based on birthDate property. Assumes User object includes a 'birthDate' Date field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Users = {\\n  id: (_args, { root }) => root.id,\\n  email: (_args, { root }) => root.email,\\n  name: (_args, { root }) => root.name,\\n  age: (_args, { root }) =>\\n    new Date().getFullYear() - root.birthDate.getFullYear(),\\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Bedtime Story Update Event via PubSub in TypeScript\nDESCRIPTION: This TypeScript code snippet shows how to publish an event to a PubSub system using `context.pubSub.publish`. It publishes a `story` payload to the `newStory` topic associated with a specific `id`, intended to update subscribers (like a GraphQL subscription) with new content deltas, likely from a streaming OpenAI response.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_22\n\nLANGUAGE: ts\nCODE:\n```\ncontext.pubSub.publish('newStory', id, story)\n```\n\n----------------------------------------\n\nTITLE: Formatting Logs with rw-log-formatter (Bash)\nDESCRIPTION: Shows how to pipe JSON log output through the RedwoodJS log formatter CLI tool for improved readability. Requires RedwoodJS CLI installed with the 'rw-log-formatter' binary available. Input: JSON-formatted log line; Output: formatted, colorized log line with emoji and timestamp. Useful for quickly viewing log output in the terminal during development or when serving the API. Works best with 'yarn rw dev' or piped from 'yarn rw serve'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\necho \"{\\\"level\\\": 30, \\\"message\\\": \\\"Hello RedwoodJS\\\"}\" | yarn rw-log-formatter\n```\n\n----------------------------------------\n\nTITLE: Initializing useForm in RedwoodJS Component (TS)\nDESCRIPTION: Demonstrates calling the imported `useForm` hook inside the `ContactPage` functional component in TypeScript (`.tsx`). This initializes React Hook Form and returns the `formMethods` object, which contains functions (like `reset`) and state for managing the form.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_36\n\nLANGUAGE: tsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nconst ContactPage = () => {\n  // highlight-next-line\n  const formMethods = useForm()\n  //...\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Scheduler Instance in JavaScript\nDESCRIPTION: This code shows how to create a scheduler instance using the `createScheduler` method on an initialized `JobManager` (`jobs`). It requires specifying which configured adapter ('prisma' in this case) the scheduler should use for enqueuing jobs. An optional logger can also be provided.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nexport const later = jobs.createScheduler({\n  adapter: 'prisma',\n})\n```\n\n----------------------------------------\n\nTITLE: Seeding Post Data with User Association (JavaScript)\nDESCRIPTION: Example JSON object used within scripts/seed.js to seed the development database, showcasing a Post entry with its required userId field. Intended as a fix for seeding issues after enforcing the userId constraint on posts. Assumes Prisma and RedwoodJS seeding conventions, and should be integrated as part of the seed.js script. Inputs are static post data, output is inserted database records tied to a User.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  id: 1,\n  name: 'John Doe',\n  title: 'Welcome to the blog!',\n  body:\n    \"I'm baby single- origin coffee kickstarter lo - fi paleo skateboard.Tumblr hashtag austin whatever DIY plaid knausgaard fanny pack messenger bag blog next level woke.Ethical bitters fixie freegan,helvetica pitchfork 90's tbh chillwave mustache godard subway tile ramps art party. Hammock sustainable twee yr bushwick disrupt unicorn, before they sold out direct trade chicharrones etsy polaroid hoodie. Gentrify offal hoodie fingerstache.\",\n  // highlight-next-line\n  userId: 1,\n},\n```\n\n----------------------------------------\n\nTITLE: Allowing User Fields Returned to Client in dbAuth - JavaScript\nDESCRIPTION: Configures the allowedUserFields property for Redwood dbAuth, restricting which user fields (like id, email) are accessible to handler return values and thus to client consumption. This enhances security by ensuring sensitive fields such as hashedPassword and salt are not exposed. The array can be expanded with additional safe user properties.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nallowedUserFields: ['id', 'email']\n```\n\n----------------------------------------\n\nTITLE: Defining User Model for dbAuth in Prisma Schema\nDESCRIPTION: This snippet adds a `User` model definition to the `api/db/schema.prisma` file. This model is essential for RedwoodJS `dbAuth`, defining fields like `id`, `name`, `email`, `hashedPassword`, `salt`, `resetToken`, and `resetTokenExpiresAt` to store user authentication credentials and password reset information.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/db/schema.prisma\"\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = \"native\"\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  body      String\n  createdAt DateTime @default(now())\n}\n\nmodel Contact {\n  id        Int @id @default(autoincrement())\n  name      String\n  email     String\n  message   String\n  createdAt DateTime @default(now())\n}\n\n// highlight-start\nmodel User {\n  id                  Int       @id @default(autoincrement())\n  name                String?\n  email               String    @unique\n  hashedPassword      String\n  salt                String\n  resetToken          String?\n  resetTokenExpiresAt DateTime?\n}\n// highlight-end\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Incorrect Secret in RedwoodJS Webhook (JSX)\nDESCRIPTION: This JSX snippet defines a test scenario for a RedwoodJS webhook handler. It simulates receiving a webhook event that is signed, but with an incorrect secret ('MY-NAME-IS-WERNER-BRANDES-VERIFY-ME' instead of the expected one). The test uses `mockSignedWebhook` and asserts that the handler correctly rejects the request with a 401 Unauthorized status code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\nscenario(\n  'with the wrong webhook secret the webhook is unauthorized',\n  async (scenario) => {\n    const order = scenario.order.placed\n\n    const payload = {\n      trackingNumber: order.trackingNumber,\n      status: 'DELIVERED',\n    }\n    const event = mockSignedWebhook({\n      payload,\n      signatureType: 'sha256Verifier',\n      signatureHeader: 'X-Webhook-Signature',\n      secret: 'MY-NAME-IS-WERNER-BRANDES-VERIFY-ME',\n    })\n\n    const result = await handler(event)\n\n    expect(result.statusCode).toBe(401)\n  }\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Post IDs Using Prisma with Redwood Console in Bash\nDESCRIPTION: This Prisma command fetches all post IDs from the database, useful for referencing available posts when creating related comments. The 'select' option limits the output to only the 'id' field of each post. No input is required, and the output is an array of objects, each containing a single 'id' property.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ndb.post.findMany({ select: { id: true } })\n```\n\n----------------------------------------\n\nTITLE: Displaying Image Thumbnails in a List with Click-to-View in RedwoodJS (JavaScript)\nDESCRIPTION: This longer snippet provides a complete ImagesList component, responsible for displaying a list of images in a table. It supports thumbnail display with clickable links to full images, delete/edit actions, and integrates with GraphQL for image deletion and query refetching. Utility functions truncate, jsonTruncate, timeTag, and checkboxInputTag help format values. Requires '@redwoodjs/web', '@redwoodjs/web/toast', '@redwoodjs/router', filestack/react, and a GraphQL API backend. Expected input is an array of image objects, and output is a responsive HTML table.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {76-78} title=\\\"web/src/components/Images/Images.js\\\"\nimport { useMutation } from '@redwoodjs/web'\nimport { toast } from '@redwoodjs/web/toast'\nimport { Link, routes } from '@redwoodjs/router'\n\nimport { QUERY } from 'src/components/Image/ImagesCell'\n\nconst DELETE_IMAGE_MUTATION = gql`\n  mutation DeleteImageMutation($id: Int!) {\n    deleteImage(id: $id) {\n      id\n    }\n  }\n`\n\nconst MAX_STRING_LENGTH = 150\n\nconst truncate = (text) => {\n  let output = text\n  if (text && text.length > MAX_STRING_LENGTH) {\n    output = output.substring(0, MAX_STRING_LENGTH) + '...'\n  }\n  return output\n}\n\nconst jsonTruncate = (obj) => {\n  return truncate(JSON.stringify(obj, null, 2))\n}\n\nconst timeTag = (datetime) => {\n  return (\n    <time dateTime={datetime} title={datetime}>\n      {new Date(datetime).toUTCString()}\n    </time>\n  )\n}\n\nconst checkboxInputTag = (checked) => {\n  return <input type=\\\"checkbox\\\" checked={checked} disabled />\n}\n\nconst ImagesList = ({ images }) => {\n  const [deleteImage] = useMutation(DELETE_IMAGE_MUTATION, {\n    onCompleted: () => {\n      toast.success('Image deleted')\n    },\n    // This refetches the query on the list page. Read more about other ways to\n    // update the cache over here:\n    // https://www.apollographql.com/docs/react/data/mutations/#making-all-other-cache-updates\n    refetchQueries: [{ query: QUERY }],\n    awaitRefetchQueries: true,\n  })\n\n  const onDeleteClick = (id) => {\n    if (confirm('Are you sure you want to delete image ' + id + '?')) {\n      deleteImage({ variables: { id } })\n    }\n  }\n\n  return (\n    <div className=\\\"rw-segment rw-table-wrapper-responsive\\\">\\n      <table className=\\\"rw-table\\\">\\n        <thead>\\n          <tr>\\n            <th>Id</th>\\n            <th>Title</th>\\n            <th>Url</th>\\n            <th>&nbsp;</th>\\n          </tr>\\n        </thead>\\n        <tbody>\\n          {images.map((image) => (\\n            <tr key={image.id}>\\n              <td>{truncate(image.id)}</td>\\n              <td>{truncate(image.title)}</td>\\n              <td>\\n                <a href={image.url} target=\\\"_blank\\\">\\n                  <img src={image.url} style={{ maxWidth: '50px' }} />\\n                </a>\\n              </td>\\n              <td>\\n                <nav className=\\\"rw-table-actions\\\">\\n                  <Link\\n                    to={routes.image({ id: image.id })}\\n                    title={'Show image ' + image.id + ' detail'}\\n                    className=\\\"rw-button rw-button-small\\\"\\n                  >\\n                    Show\\n                  </Link>\\n                  <Link\\n                    to={routes.editImage({ id: image.id })}\\n                    title={'Edit image ' + image.id}\\n                    className=\\\"rw-button rw-button-small rw-button-blue\\\"\\n                  >\\n                    Edit\\n                  </Link>\\n                  <button\\n                    type=\\\"button\\\"\\n                    title={'Delete image ' + image.id}\\n                    className=\\\"rw-button rw-button-small rw-button-red\\\"\\n                    onClick={() => onDeleteClick(image.id)}\\n                  >\\n                    Delete\\n                  </button>\\n                </nav>\\n              </td>\\n            </tr>\\n          ))}\\n        </tbody>\\n      </table>\\n    </div>\n  )\n}\n\nexport default ImagesList\n```\n```\n\n----------------------------------------\n\nTITLE: Full RedwoodJS ContactPage with useForm and Reset (JavaScript)\nDESCRIPTION: Presents the entire ContactPage component using RedwoodJS and React Hook Form in JavaScript. The implementation demonstrates importing dependencies, defining a GraphQL mutation, using useForm for manual form state handling, and resetting the form on mutation completion. Key parameters include form configuration, validation rules on each field, and mutation operation. The component expects formMethods to be passed to Form, and all user input is validated and handled appropriately.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_38\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport { toast, Toaster } from '@redwoodjs/web/toast'\nimport {\n  FieldError,\n  Form,\n  FormError,\n  Label,\n  Submit,\n  TextAreaField,\n  TextField,\n  useForm,\n} from '@redwoodjs/forms'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\nconst ContactPage = () => {\n  const formMethods = useForm()\n\n  const [create, { loading, error }] = useMutation(CREATE_CONTACT, {\n    onCompleted: () => {\n      toast.success('Thank you for your submission!')\n      formMethods.reset()\n    },\n  })\n\n  const onSubmit = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Toaster />\n      <Form\n        onSubmit={onSubmit}\n        config={{ mode: 'onBlur' }}\n        error={error}\n        formMethods={formMethods}\n      >\n        <FormError error={error} wrapperClassName=\"form-error\" />\n\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit disabled={loading}>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n\n```\n\n----------------------------------------\n\nTITLE: Fetching and Displaying Raw JSON Data in React (JSX)\nDESCRIPTION: Defines a simple React functional component `HomePage` using `useState` to hold the fetched forecast data and `useEffect` to trigger the fetch request for `/forecast.json` when the component mounts. It uses the browser's native `fetch` API to get the data and then renders the raw JSON content using `JSON.stringify` to verify successful data retrieval.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/disable-api-database.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useState, useEffect } from 'react'\n\nconst HomePage = () => {\n  const [forecast, setForecast] = useState({})\n\n  useEffect(() => {\n    fetch('/forecast.json')\n      .then((response) => response.json())\n      .then((json) => setForecast(json))\n  }, [])\n\n  return <div>{JSON.stringify(forecast)}</div>\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Implementing logOut Functionality in SignoutBtn using JSX\nDESCRIPTION: This snippet updates the `SignoutBtn` component to perform the sign-out action. It imports `useAuth` from `@redwoodjs/auth`, destructures the `logOut` function, and calls `logOut()` within the `onClick` handler when the button is clicked.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {1,4,7} title=\"web/src/components/SignoutBtn/SignoutBtn.js\"\nimport { useAuth } from '@redwoodjs/auth'\n\nconst SignoutBtn = () => {\n  const { logOut } = useAuth()\n\n  const onClick = () => {\n    logOut()\n  }\n\n  return <button onClick={() => onClick()}>Sign Out</button>\n}\n\nexport default SignoutBtn\n```\n```\n\n----------------------------------------\n\nTITLE: Testing the Chat Room Subscription - TypeScript\nDESCRIPTION: Multiline TypeScript comment illustrates usage for testing a 'newMessage' subscription and sending a message mutation using GraphQL Playground. First part shows subscription to new messages, second demonstrates publishing a message with a mutation. For end-to-end testing of RedwoodJS chat subscription implementations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * To test this NewMessage subscription, run the following in one GraphQL Playground to subscribe:\n *\n * subscription ListenForNewMessagesInRoom {\n *   newMessage(roomId: \"1\") {\n *     body\n *     from\n *   }\n * }\n *\n *\n * And run the following in another GraphQL Playground to publish and send a message to the room:\n *\n * mutation SendMessageToRoom {\n *   sendMessage(input: {roomId: \"1\", from: \"hello\", body: \"bob\"}) {\n *     body\n *     from\n *   }\n * }\n */\n```\n\n----------------------------------------\n\nTITLE: Scheduling RedwoodJS Job with Delay (JavaScript)\nDESCRIPTION: Example of scheduling a RedwoodJS job (`SendWelcomeEmailJob`) to run after a specific delay. The `later` function is called with the job, its arguments, and an options object containing `wait: 300`, causing the job to execute 5 minutes (300 seconds) after being scheduled.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_12\n\nLANGUAGE: js\nCODE:\n```\nlater(SendWelcomeEmailJob, [user.id], { wait: 300 })\n```\n\n----------------------------------------\n\nTITLE: Refetching GraphQL Queries After Mutation in RedwoodJS (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to refetch a specific GraphQL query using Apollo's refetchQueries option in the useMutation hook provided by RedwoodJS. The QUERY constant is imported and passed to the mutation so that after creating a comment, the comments list is updated. Dependencies required include @redwoodjs/forms and @redwoodjs/web. The CommentForm component takes a postId prop and triggers the refetch after a successful create. Inputs are the mutation variables; output is the automatic refetch of the comments list.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Form,\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\nimport { useMutation } from '@redwoodjs/web'\n\n// highlight-next-line\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n\n// ...\n\nconst CommentForm = ({ postId }) => {\n  // highlight-start\n  const [createComment, { loading, error }] = useMutation(CREATE, {\n    refetchQueries: [{ query: CommentsQuery }],\n  })\n  // highlight-end\n\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Comment with UI Feedback using RedwoodJS and react-hot-toast (TypeScript)\nDESCRIPTION: This TypeScript version provides strongly-typed interfaces for mutation response, variables, and component props. The core logic is otherwise similar: after successful comment creation, the form hides and the user receives a react-hot-toast notification. Strict input/output typing aids maintainability, and the snippet emphasizes compatibility with RedwoodJS's forms and GraphQL typegen. As with JavaScript, a Toaster must exist in a parent layout for notifications to display.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\nimport { useState } from 'react'\n\nimport type {\n  CreateCommentMutation,\n  CreateCommentMutationVariables,\n} from 'types/graphql'\n\nimport {\n  Form,\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\nimport type { TypedDocumentNode } from '@redwoodjs/web'\nimport { useMutation } from '@redwoodjs/web'\n// highlight-next-line\nimport { toast } from '@redwoodjs/web/toast'\n\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n\nconst CREATE: TypedDocumentNode<\n  CreateCommentMutation,\n  CreateCommentMutationVariables\n> = gql`\n  mutation CreateCommentMutation($input: CreateCommentInput!) {\n    createComment(input: $input) {\n      id\n      name\n      body\n      createdAt\n    }\n  }\n`\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\ninterface Props {\n  postId: number\n}\n\nconst CommentForm = ({ postId }: Props) => {\n  // highlight-next-line\n  const [hasPosted, setHasPosted] = useState(false)\n  const [createComment, { loading, error }] = useMutation(CREATE, {\n    // highlight-start\n    onCompleted: () => {\n      setHasPosted(true)\n      toast.success('Thank you for your comment!')\n    },\n    // highlight-end\n    refetchQueries: [{ query: CommentsQuery }],\n  })\n\n  const onSubmit: SubmitHandler<FormValues> = (input) => {\n    createComment({ variables: { input: { postId, ...input } } })\n  }\n\n  return (\n    // highlight-next-line\n    <div className={hasPosted ? 'hidden' : ''}>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      <Form className=\"mt-4 w-full\" onSubmit={onSubmit}>\n        <FormError\n          error={error}\n          titleClassName=\"font-semibold\"\n          wrapperClassName=\"bg-red-100 text-red-900 text-sm p-3 rounded\"\n        />\n        <Label\n          name=\"name\"\n          className=\"block text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-sm \"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-sm\"\n          validation={{ required: true }}\n        />\n\n        <Submit\n          disabled={loading}\n          className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\"\n        >\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n\n----------------------------------------\n\nTITLE: Querying and Rendering Comments with RedwoodJS - TypeScript\nDESCRIPTION: This TypeScript snippet defines a RedwoodJS Cell for fetching and displaying comments, leveraging GraphQL typings and TypeScript interfaces for props. It ensures type safety for retrieved data and cell states, using a Comment child component for each comment entry. Dependencies include RedwoodJS, GraphQL types, and an existing Comment component; props are strongly typed, enhancing maintainability, and it can be integrated directly into RedwoodJS applications.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { CommentsQuery, CommentsQueryVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypedDocumentNode,\n} from '@redwoodjs/web'\n\n// highlight-next-line\nimport Comment from 'src/components/Comment'\n\nexport const QUERY: TypedDocumentNode<CommentsQuery, CommentsQueryVariables> =\n  gql`\n    query CommentsQuery {\n      comments {\n        id\n        // highlight-start\n        name\n        body\n        createdAt\n        // highlight-end\n      }\n    }\n  `\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<CommentsQueryVariables>) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  comments,\n}: CellSuccessProps<CommentsQuery, CommentsQueryVariables>) => {\n  return (\n    // highlight-start\n    <>\n      {comments.map((comment) => (\n        <Comment key={comment.id} comment={comment} />\n      ))}\n    </>\n    // highlight-end\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Post Model in Prisma Schema (JavaScript/Prisma)\nDESCRIPTION: Defines a 'Post' data model within the Prisma schema file located at `api/db/schema.prisma`. This model specifies the structure for posts in the database, including an auto-incrementing integer ID (`id`), string fields for `title` and `body`, and a `createdAt` timestamp that defaults to the current time. Prisma uses this schema definition to interact with the database and generate migrations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  body      String\n  createdAt DateTime @default(now())\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL SDL Type and Query Definition - RedwoodJS - JSX\nDESCRIPTION: Defines GraphQL types and queries for a User in RedwoodJS. Uses gql template strings to declare types in 'api/src/graphql/user.sdl.js'. No dependencies beyond RedwoodJS basics; used to provide schema to the GraphQL server.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nexport const schema = gql`\\n  type User {\\n    id: Int!\\n    email: String!\\n    name: String\\n  }\\n\\n  type Query {\\n    users: [User!]!\\n  }\\n`\n```\n\n----------------------------------------\n\nTITLE: Defining Contact Model in Prisma Schema - JavaScript\nDESCRIPTION: This snippet demonstrates how to define a new Contact model in a Prisma schema file using JavaScript-flavored DSL. It adds a Contact model with fields for id, name, email, message, and createdAt. Dependencies include a configured Prisma setup and an environment variable for the database URL. The schema defines the data types and sets default values for id and createdAt; all fields are required as shown. The output is a schema file used by Prisma for generating the corresponding database table.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = \"native\"\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  body      String\n  createdAt DateTime @default(now())\n}\n\n// highlight-start\nmodel Contact {\n  id        Int      @id @default(autoincrement())\n  name      String\n  email     String\n  message   String\n  createdAt DateTime @default(now())\n}\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Defining Authenticated and Public Routes in RedwoodJS (JavaScript)\nDESCRIPTION: This JavaScript code snippet defines application routes using RedwoodJS's Router, emphasizing the use of <PrivateSet> to restrict access to admin pages and redirect unauthenticated users to the home route. Dependencies include @redwoodjs/router, layout components (ScaffoldLayout, BlogLayout), and the useAuth hook. The <PrivateSet> ensures all nested routes enforce authentication, while public routes remain accessible. Key parameters include named routes, component bindings, and authentication logic. Outputs are controlled navigation and access control; constraints involve proper authentication context and component wiring.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\\nimport { PrivateSet, Router, Route, Set } from '@redwoodjs/router'\\n\\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\\nimport BlogLayout from 'src/layouts/BlogLayout'\\n\\nimport { useAuth } from './auth'\\n\\nconst Routes = () => {\\n  return (\\n    <Router useAuth={useAuth}>\\n      // highlight-next-line\\n      <PrivateSet unauthenticated=\"home\">\\n        <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\\n          <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\\n          <Route path=\"/admin/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\\n          <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\\n          <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\\n        </Set>\\n      // highlight-next-line\\n      </PrivateSet>\\n      <Set wrap={BlogLayout}>\\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\\n        <Route path=\"/\" page={HomePage} name=\"home\" />\\n      </Set>\\n      <Route notfound page={NotFoundPage} />\\n    </Router>\\n  )\\n}\\n\\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Signing Out User using RedwoodJS `useAuth` Hook (TypeScript)\nDESCRIPTION: Signs out the currently logged-in user using the `logOut` method from the RedwoodJS `useAuth` hook. This removes the user session from the browser (localStorage) and triggers a `SIGNED_OUT` event.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst { logOut } = useAuth()\n\nlogOut()\n```\n\n----------------------------------------\n\nTITLE: Applying Prisma Schema Changes with Migration\nDESCRIPTION: This bash command uses the RedwoodJS CLI (`rw`) to execute a Prisma database migration in the development environment (`dev`). It applies the changes defined in `schema.prisma`, specifically creating the `User` table based on the newly added model, and prompts for a migration name (e.g., 'create user'). This requires Prisma and the RedwoodJS CLI.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn rw prisma migrate dev\n```\n```\n\n----------------------------------------\n\nTITLE: Deleting a Record using `destroy()` in JSX\nDESCRIPTION: To delete a record, first retrieve the instance (e.g., using `find()`). Then, call the `destroy()` instance method. An optional argument can be passed to forward properties to Prisma's delete operation or include `{ throw: true }` to throw an error if the deletion fails. The method returns the deleted record instance on success, or `false` on failure (if not throwing).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_26\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = await User.find(123)\nawait user.destroy()\n// or\nawait user.destroy({ throw: true })\n```\n\n----------------------------------------\n\nTITLE: Using PageLoadingContext for Loading UI - RedwoodJS Context API - JavaScript/JSX\nDESCRIPTION: Demonstrates using the usePageLoadingContext hook to access loading state from the router, which allows displaying a custom loading UI when lazily-loaded page chunks are being fetched. Can be used in any child component of the router, including layouts. Returns an object with a boolean 'loading' property.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_34\n\nLANGUAGE: jsx\nCODE:\n```\nimport { usePageLoadingContext } from '@redwoodjs/router'\n\nconst SomeLayout = (props) => {\n  const { loading } = usePageLoadingContext()\n  return (\n    <div>\n      {loading && <div>Loading...</div>}\n      <main>{props.children}</main>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Apollo Cache Contents via useCache.extract (TypeScript)\nDESCRIPTION: Uses the extract function from useCache to obtain a serialized JSON representation of the Apollo cache's current state, suitable for logging or persisting cache data. Usually invoked for debugging or hydration/dehydration of the cache on client/server boundaries.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_34\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst Fruit = ({ id }: { id: FragmentIdentifier }) => {\n  const { extract } = useCache()\n\n  // Logs the cache's current contents\n  console.log(extract())\n\n```\n\n----------------------------------------\n\nTITLE: Using the Acceptance Validator (Basic) in JSX\nDESCRIPTION: Demonstrates the basic usage of the `acceptance` validator. This rule requires the input value to be exactly `true`. It's commonly used for checkbox fields like Terms of Service agreement.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.terms, 'Terms of Service', {\n  acceptance: true,\n})\n\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Blog Post Schema with Prisma - JavaScript\nDESCRIPTION: Defines the Prisma schema for a 'Post' model in a RedwoodJS application. Specifies fields including an auto-increment integer ID, title, body, and createdAt timestamp with a default of the current time. Requires a valid Prisma setup and database URL, and configuration for both the datasource and Prisma client generator. Inputs and outputs are reflected through database reads and writes; constraints include use of SQLite and standard field types. This file is defined within 'api/db/schema.prisma'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/getting-dynamic.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = \"native\"\n}\n\n// highlight-start\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  body      String\n  createdAt DateTime @default(now())\n}\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Configuring Datadog Log Transport Stream in RedwoodJS\nDESCRIPTION: Example configuration (`api/src/lib/logger.ts`) for sending RedwoodJS logs to Datadog using `pino-datadog`. It imports `pino-datadog`, creates a synchronous write stream (`createWriteStreamSync`) configured with Datadog API key and settings (source, tags, service), and initializes the RedwoodJS logger using `createLogger` with this stream as `destination`. Requires `pino-datadog` package and `DATADOG_API_KEY` environment variable.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\n/**\n * Stream logs to Datadog\n */\n// api/src/lib/logger.ts\nimport datadog from 'pino-datadog'\n\n/**\n * Creates a synchronous pino-datadog stream\n *\n * @param {object} options - Datadog options including your account's API Key\n *\n * @typedef {DestinationStream}\n */\nexport const stream = datadog.createWriteStreamSync({\n  apiKey: process.env.DATADOG_API_KEY,\n  ddsource: 'my-source-name',\n  ddtags: 'tag,not,it',\n  service: 'my-service-name',\n  size: 1,\n})\n\n/**\n * Creates a logger with RedwoodLoggerOptions\n *\n * These extend and override default LoggerOptions,\n * can define a destination like a file or other supported pino log transport stream,\n * and sets whether or not to show the logger configuration settings (defaults to false)\n *\n * @param RedwoodLoggerOptions\n *\n * RedwoodLoggerOptions have\n * @param {options} LoggerOptions - defines how to log, such as redaction and format\n * @param {string | DestinationStream} destination - defines where to log, such as a transport stream or file\n * @param {boolean} showConfig - whether to display logger configuration on initialization\n */\nexport const logger = createLogger({\n  options: {},\n  destination: stream,\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Custom RedwoodJS Validation on Form Fields in TypeScript\nDESCRIPTION: Updates the TypeScript version of the contact form to use the RedwoodJS 'validation' prop on each field, replacing the HTML required attribute. This allows for custom validation messages and logic. The form fields are validated client-side with rules specified as objects, paving the way for more sophisticated validation strategies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\nreturn (\n  <Form onSubmit={onSubmit}>\n    <label htmlFor=\"name\">Name</label>\n    // highlight-next-line\n    <TextField name=\"name\" validation={{ required: true }} />\n    <label htmlFor=\"email\">Email</label>\n    // highlight-next-line\n    <TextField name=\"email\" validation={{ required: true }} />\n    <label htmlFor=\"message\">Message</label>\n    // highlight-next-line\n    <TextAreaField name=\"message\" validation={{ required: true }} />\n    <Submit>Save</Submit>\n  </Form>\n)\n```\n\n----------------------------------------\n\nTITLE: Testing CommentsCell Rendering States with RedwoodJS in TypeScript\nDESCRIPTION: This TypeScript snippet tests the CommentsCell component, ensuring all main states (loading, empty, failure, and success) render without errors using RedwoodJS's test tools. Type safety is applied throughout, using @redwoodjs/testing/web for rendering. The test uses various simulated props and states, confirming that the component is robust against errors. Prerequisites include the appropriate TypeScript code setup, proper imports, and the CommentsCell component and mock definitions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { render } from '@redwoodjs/testing/web'\n\nimport { Loading, Empty, Failure, Success } from './CommentsCell'\nimport { standard } from './CommentsCell.mock'\n\ndescribe('CommentsCell', () => {\n  it('renders Loading successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  it('renders Empty successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  it('renders Failure successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  it('renders Success successfully', async () => {\n    expect(() => {\n      render(<Success comments={standard().comments} />)\n    }).not.toThrow()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL File Discovery for Fragments - RedwoodJS - JavaScript\nDESCRIPTION: This snippet configures the graphql.config.js file to inform VS Code and tooling where GraphQL fragments are located in a RedwoodJS project. The 'documents' attribute is set to match all GraphQL documents in the web/src tree except for TypeScript definition files, improving DX with tooling such as Apollo and VS Code plugins. Requires '@redwoodjs/internal'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n// graphql.config.js\\n\\nconst { getPaths } = require('@redwoodjs/internal')\\n\\nmodule.exports = {\\n  schema: getPaths().generated.schema,\\n  documents: './web/src/**/!(*.d).{ts,tsx,js,jsx}', // \\\\uD83D\\\\uDC49 Tells VS Code plugin where to find fragments\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Integrating ArticlesCell into HomePage (TypeScript/TSX)\nDESCRIPTION: This snippet demonstrates importing and rendering the `ArticlesCell` component within the `HomePage.tsx` page component in a TypeScript-based RedwoodJS project. The `ArticlesCell` is imported and included in the JSX returned by the `HomePage` functional component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/HomePage/HomePage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\n\n// highlight-next-line\nimport ArticlesCell from 'src/components/ArticlesCell'\n\nconst HomePage = () => {\n  return (\n    <>\n      <Metadata title=\"Home\" description=\"Home page\" />\n      // highlight-next-line\n      <ArticlesCell />\n    </>\n  )\n}\n\nexport default HomePage\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Mock Data for a Redwood Cell Query\nDESCRIPTION: Illustrates the standard pattern for mocking a Redwood Cell's `QUERY`. A file named `*Cell.mock.js` exports a `standard` object. This object represents the default mock data that will be returned for the `QUERY` defined in the corresponding `*Cell.js` file. The `__typename` is important for Apollo Client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/mocking-graphql-requests.md#_snippet_9\n\nLANGUAGE: graphql\nCODE:\n```\nexport const QUERY = gql`\n  query UserProfileQuery {\n    userProfile {\n       id\n    }\n  }\n`\n```\n\nLANGUAGE: jsx\nCODE:\n```\n// UserProfileCell/UserProfileCell.mock.js\nexport const standard = {\n  userProfile: {\n    __typename: 'UserProfile' as const,\n    id: 42\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Weather Details with Helper Functions in RedwoodJS - JSX\nDESCRIPTION: This component extends the basic weather display by formatting the output. Helper functions extract temperature (converted to Fahrenheit from Kelvin), weather condition, and the icon URL. The form input is validated as previously, but if weather data is present, it displays the city name, icon, temperature, and condition formatted in the UI. Required dependencies include '@redwoodjs/forms' and a valid API key. The component expects weather data in OpenWeather's JSON format and outputs a styled result.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useState } from 'react'\nimport { Form, TextField, Submit } from '@redwoodjs/forms'\n\nconst HomePage = () => {\n  const [weather, setWeather] = useState()\n\n  const onSubmit = (data) => {\n    fetch(\n      `https://api.openweathermap.org/data/2.5/weather?zip=${data.zip},us&appid=YOUR_API_KEY`\n    )\n      .then((response) => response.json())\n      .then((json) => setWeather(json))\n  }\n\n  const temp = () => Math.round(((weather.main.temp - 273.15) * 9) / 5 + 32)\n\n  const condition = () => weather.weather[0].main\n\n  const icon = () => {\n    return `http://openweathermap.org/img/wn/${weather.weather[0].icon}@2x.png`\n  }\n\n  return (\n    <>\n      <Form onSubmit={onSubmit}>\n        <TextField\n          name=\"zip\"\n          placeholder=\"Zip code\"\n          maxLength=\"5\"\n          validation={{ required: true, pattern: /^\\d{5}$/ }}\n        />\n        <Submit>Go</Submit>\n      </Form>\n      {weather && (\n        <section>\n          <h1>{weather.name}</h1>\n          <h2>\n            <img src={icon()} style={{ maxWidth: '2rem' }} />\n            <span>\n              {temp()}°F and {condition()}\n            </span>\n          </h2>\n        </section>\n      )}\n    </>\n  )\n}\n\nexport default HomePage\n\n```\n\n----------------------------------------\n\nTITLE: Associating Posts with the Current User on Creation - RedwoodJS - JavaScript\nDESCRIPTION: Illustrates how to attach the current logged-in user's id from context to a new post during creation in a RedwoodJS service. This method assumes authentication and that 'context.currentUser' is populated. On post creation, the service merges input fields with the userId, so each new post is tied to the user making the request. Main inputs are the incoming post data and the available user context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    // highlight-next-line\n    data: { ...input, userId: context.currentUser.id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Global Layout to Routes using RedwoodJS Router Set Component\nDESCRIPTION: Updates the application's routes in `web/src/Routes.[js/tsx]` to use the `GlobalLayout`. It imports the `Set` component from `@redwoodjs/router` and the `GlobalLayout`. The `Set` component wraps specific `Route` definitions (`HomePage`, `SignUpPage`, `SignInPage`), applying the `GlobalLayout` to them via the `wrap` prop, thus ensuring these pages share the common layout structure including the navigation bar.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport GlobalLayout from 'src/layouts/GlobalLayout/GlobalLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={GlobalLayout}>\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n        <Route path=\"/signup\" page={SignUpPage} name=\"signup\" />\n        <Route path=\"/signin\" page={SignInPage} name=\"signin\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Generating Data URIs for Profile Avatars in TypeScript\nDESCRIPTION: This TypeScript snippet, within a RedwoodJS service (`profiles.ts`), shows how to retrieve a profile and convert its upload field (`avatar`) into a Base64 Data URI string using the `.withDataUri()` method. This approach is suitable for smaller files, embedding the file content directly into the response, eliminating the need for a separate request to fetch the file. Note that `.withDataUri()` is an asynchronous operation and should be awaited if further processing is needed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport const profile = async ({ id }) => {\n  const profile = await db.profile.findUnique({\n    where: { id },\n  })\n\n  // highlight-next-line\n  return profile?.withDataUri()\n}\n```\n\n----------------------------------------\n\nTITLE: Linking Article Title with Route Parameter (RedwoodJS, JavaScript)\nDESCRIPTION: This snippet demonstrates how to dynamically generate a Link to the article detail page with a given article's ID as a parameter. Using the routes helper from RedwoodJS, it ensures the resulting URL is correctly formatted. It is used within a component render, expects article objects with an 'id' property, and creates accessible links for each article record.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n<h2>\\n  <Link to={routes.article({ id: article.id })}>{article.title}</Link>\\n</h2>\n```\n\n----------------------------------------\n\nTITLE: Protecting RedwoodJS NavLink for a Single Role (JSX)\nDESCRIPTION: This snippet shows how to conditionally render a `NavLink` component within a Layout based on user role. It uses the `useAuth` hook from `@redwoodjs/auth` to get the `hasRole` function, which checks if the current authenticated user has the 'admin' role before rendering the 'Manage Users' link.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { NavLink, Link, routes } from '@redwoodjs/router'\\nimport { useAuth } from '@redwoodjs/auth'\\n\\nconst SidebarLayout = ({ children }) => {\\n  const { hasRole } = useAuth()\\n\\n  return (\\n    ...\\n    {hasRole('admin') && (\\n      <NavLink\\n        to={routes.users()} className=\"text-gray-600\" activeClassName=\"text-gray-900\"\\n      >\\n      Manage Users\\n    </NavLink>\\n    ...\\n   )}\\n )\\n}\n```\n\n----------------------------------------\n\nTITLE: Paginated Post Resolver Implementation - RedwoodJS Services - TypeScript\nDESCRIPTION: Provides the TypeScript implementation for the paginated posts resolver in RedwoodJS, returning both the posts for the requested page and the overall post count. Utilizes Prisma's 'findMany' and 'count' methods, with page and offset logic consistent with the JavaScript version. Dependencies include '@redwoodjs/api' and Prisma ORM, ensuring typed responses where applicable.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst POSTS_PER_PAGE = 5\n\nexport const postPage = ({ page = 1 }) => {\n  const offset = (page - 1) * POSTS_PER_PAGE\n\n  return {\n    posts: db.post.findMany({\n      take: POSTS_PER_PAGE,\n      skip: offset,\n      orderBy: { createdAt: 'desc' },\n    }),\n    count: db.post.count(),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Email Validator with a Custom Message in JSX\nDESCRIPTION: Demonstrates providing a custom error message for the `email` validator using the `message` property within the nested `email` object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.email, {\n  email: { message: 'Please provide a valid email address'\n})\n\n```\n\n----------------------------------------\n\nTITLE: Setting Up Caching Client with Redwood CLI (Bash)\nDESCRIPTION: Executes the RedwoodJS `setup cache` command using Yarn to configure caching with Memcached or Redis. Replace `<client>` with either `memcached` or `redis`. This command creates a setup file in `api/src/lib/cache.{ts|js}`. Use the optional `--force` or `-f` flag to overwrite existing cache configuration files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_109\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup cache <client>\n```\n\n----------------------------------------\n\nTITLE: Creating Babel Configuration File for Web\nDESCRIPTION: This shell command creates an empty `babel.config.js` file within the `web` directory of a RedwoodJS project. This file is used for custom Babel configurations specific to the web side, allowing users to add plugins or presets beyond the defaults provided by Redwood.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/project-configuration-dev-test-build.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntouch web/babel.config.js\n```\n\n----------------------------------------\n\nTITLE: Typing getCurrentUser Session Argument with DbAuthSession in TypeScript\nDESCRIPTION: Illustrates how to use the `DbAuthSession` utility type to type the `session` parameter of the `getCurrentUser` function in `api/src/lib/auth.ts`. The generic (`<number>`) specifies the type of the user's ID field stored in the session, ensuring type safety when accessing `session.id`. Depends on `@redwoodjs/api` and a Prisma client instance (`db`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nexport const getCurrentUser = async (session: DbAuthSession<number>) => {\n  return await db.user.findUnique({\n    where: { id: session.id },\n    select: { id: true },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Blocking Route Transitions with useBlocker - RedwoodJS React Hook & Forms - JavaScript/JSX\nDESCRIPTION: Demonstrates blocking navigation transitions conditionally using useBlocker and RedwoodJS's useForm. Shows integration with form state to only allow navigation away when formState.isDirty is false, and exposes UI for confirming or aborting blocked navigation. Dependencies: '@redwoodjs/router' useBlocker, '@redwoodjs/forms' useForm, and supporting form UI. Supports custom logic in the confirmation/abort handler.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_29\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useBlocker } from '@redwoodjs/router'\nimport { useForm } from '@redwoodjs/forms'\n\nconst SomeForm = () => {\n  const form = useForm<FormInput>()\n  const blocker = useBlocker({ when: form.formState.isDirty })\n\n  return (\n    <Form formMethods={form} onSubmit={onSubmit} error={props.error}>\n      {blocker.state === 'BLOCKED' && (\n        <div>\n          <button type=\"button\" onClick={() => blocker.confirm()}>\n            Confirm\n          </button>\n          <button type=\"button\" onClick={() => blocker.abort()}>\n            Abort\n          </button>\n        </div>\n      )}\n      ...\n    </Form>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Explicitly Deleting Cache Keys using deleteCacheKey() - JavaScript\nDESCRIPTION: Explains how to use Redwood's `deleteCacheKey()` to remove specific cache entries (e.g., after an update operation), ensuring subsequent data fetches are fresh. Highlights the integration of cache key construction logic with update mutations, and advises caution with manual cache busting in complex update scenarios.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_75\n\nLANGUAGE: javascript\nCODE:\n```\nimport { cache, deleteCacheKey } from 'src/lib/cache'\\n\\nconst user = ({ id }) => {\\n  return cache(`user-${id}`, () => {\\n    return db.user.findUnique({ where: { id } })\\n  })\\n})\\n\\nconst updateUser = async ({ id, input }) => {\\n  await deleteCacheKey(`user-${id}`)\\n  return db.user.update({ where: { id }, data: { input } })\\n})\n```\n\n----------------------------------------\n\nTITLE: Rendering Article with Comment Components in RedwoodJS (JavaScript)\nDESCRIPTION: This snippet shows a React component for displaying a blog article and, if not rendering a summary, embedding both the CommentForm and CommentsCell components, passing down the current article's id as postId. Dependencies include RedwoodJS Router (Link, routes) and the truncate utility. The key parameters are article (containing the post data) and summary (toggles between full and summarized view). Outputs the HTML structure with embedded child components, ensuring each post's comments and form are correctly associated via prop-drilling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_30\n\nLANGUAGE: jsx\nCODE:\n```\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\\\"text-xl text-blue-700 font-semibold\\\">\\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\\n        </h2>\\n      </header>\\n      <div className=\\\"mt-2 text-gray-900 font-light\\\">\\n        {summary ? truncate(article.body, 100) : article.body}\\n      </div>\\n      {!summary && (\\n        <div className=\\\"mt-12\\\">\\n          <CommentForm postId={article.id} />\\n          <div className=\\\"mt-12\\\">\\n            // highlight-next-line\\n            <CommentsCell postId={article.id} />\\n          </div>\\n        </div>\\n      )}\\n    </article>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Using AdminPosts Query in PostsCell Component - JSX\nDESCRIPTION: This snippet updates PostsCell's GET query to use the adminPosts endpoint, allowing admin users to fetch all their own posts. The query result is aliased as posts, preserving existing component prop shape. It returns the id, title, body, and createdAt of each post. Requires adminPosts GraphQL query to be implemented and accessible only for authorized admin users.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_22\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query POSTS {\n    // highlight-next-line\n    posts: adminPosts {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Configuring SuperTokens for Production - Bash\nDESCRIPTION: Sets critical SuperTokens environment variables for production deployments. Adjusts website and JWKS URL to match the deployed domain. Must be placed in the hosting provider configuration or environment. Input: Production domain URLs. Output: Production environment correctly references authentication services.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supertokens.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nSUPERTOKENS_WEBSITE_DOMAIN=https://myapp.com\nSUPERTOKENS_JWKS_URL=https://myapp.com/.redwood/functions/auth/jwt/jwks.json\n```\n\n----------------------------------------\n\nTITLE: Enabling Corepack for Yarn Support - Dockerfile\nDESCRIPTION: This snippet enables Corepack, allowing Yarn to utilize the 'packageManager' field from your project's package.json for selecting the right version. This step ensures future Yarn commands behave consistently and align with your specified version control strategy. It requires that the Node.js 20+ base image includes corepack (as it does by default) and is typically used immediately after establishing the base image.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_1\n\nLANGUAGE: Dockerfile\nCODE:\n```\nRUN corepack enable\n```\n\n----------------------------------------\n\nTITLE: Querying and Rendering Comments with RedwoodJS - JavaScript\nDESCRIPTION: This React (JavaScript) snippet defines a RedwoodJS Cell fetching a list of comments and rendering each with a Comment component. It includes a GraphQL query for comment fields and displays loading, empty, failure, and success states. Dependencies include RedwoodJS's Cell conventions and a separately defined Comment component; expected input is a GraphQL comments array, with loading/error/empty handling built-in.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport Comment from 'src/components/Comment'\n\nexport const QUERY = gql`\n  query CommentsQuery {\n    comments {\n      id\n      // highlight-start\n      name\n      body\n      createdAt\n      // highlight-end\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({ comments }) => {\n  return (\n  // highlight-start\n    <>\n      {comments.map((comment) => (\n        <Comment key={comment.id} comment={comment} />\n      ))}\n    </>\n  // highlight-end\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing isEmpty Lifecycle Hook for Conditional Empty Rendering (JSX)\nDESCRIPTION: This code defines a custom isEmpty hook, extending the default RedwoodJS behavior to conditionally render the Empty state based on complex logic, in this case both the default data emptiness and a specific property check. Receives data and an object with isDataEmpty for chaining default logic. Useful for scenarios where the Empty state depends on business rules.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nexport const isEmpty = (data, { isDataEmpty }) => {\n  return isDataEmpty(data) || data?.blog?.status === 'hidden'\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Persisted Query Error Message (Function) in TypeScript\nDESCRIPTION: This example shows an alternative way to customize the error for disallowed ad-hoc queries in the GraphQL handler configuration (`api/src/functions/graphql.ts`). Instead of a static string, `customErrors.persistedQueryOnly` is set to a function. This function receives the request `payload` as an argument and must return a `GraphQLError` object, allowing for more dynamic or context-aware error generation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\n  trustedDocuments: {\n    store,\n    customErrors: {\n      persistedQueryOnly: (payload) => {\n        console.log('payload', payload)\n        return new GraphQLError('Sorry!')\n      },\n    },\n  }\n```\n\n----------------------------------------\n\nTITLE: Scheduling RedwoodJS Job After User Creation (JavaScript)\nDESCRIPTION: Illustrates how to schedule the `SendWelcomeEmailJob` using the `later` function within a `createUser` service method. It imports the `later` scheduler object and the `SendWelcomeEmailJob` definition, then calls `later` after successfully creating a user, passing the job object and the new `user.id` as arguments to queue the email sending task.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_11\n\nLANGUAGE: js\nCODE:\n```\n// highlight-start\nimport { later } from 'src/lib/jobs'\nimport { SendWelcomeEmailJob } from 'src/jobs/SendWelcomeEmailJob'\n// highlight-end\n\nexport const createUser = async ({ input }) {\n  const user = await db.user.create({ data: input })\n  // highlight-next-line\n  await later(SendWelcomeEmailJob, [user.id])\n  return user\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating authDecoder in RedwoodJS GraphQL Handler\nDESCRIPTION: This snippet demonstrates how to integrate the custom `authDecoder` into the RedwoodJS GraphQL setup. The `authDecoder` function (along with `getCurrentUser`, which is assumed to exist) is imported from `src/lib/auth` and passed to the `createGraphQLHandler` function in `api/src/functions/graphql.ts`. This configures the GraphQL server to use the custom logic for authenticating requests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_14\n\nLANGUAGE: ts\nCODE:\n```\n// highlight-next-line\nimport { authDecoder, getCurrentUser } from 'src/lib/auth'\n\n// ...\n\nexport const handler = createGraphQLHandler({\n  // highlight-next-line\n  authDecoder,\n  getCurrentUser,\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with `even` Option in JSX\nDESCRIPTION: Illustrates the `numericality` validator using the `even` option set to `true` to ensure the input number is even.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_37\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.skip, 'Skip', {\n  numericality: { even: true },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with `negative` Option in JSX\nDESCRIPTION: Illustrates the `numericality` validator using the `negative` option set to `true` to ensure the input number is less than 0.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_40\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.debt, 'Debt', {\n  numericality: { negative: true },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Integrating CommentsCell in Article Page - TypeScript (TSX)\nDESCRIPTION: Demonstrates the TypeScript version of including a CommentsCell in an Article component with type-safe props. Renders the CommentsCell based on the summary flag, and requires types from the GraphQL schema and RedwoodJS router and CommentsCell component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\\n// highlight-next-line\\nimport CommentsCell from 'src/components/CommentsCell'\\n\\nimport type { Post } from 'types/graphql'\\n\\nconst truncate = (text: string, length: number) => {\\n  return text.substring(0, length) + '...'\\n}\\n\\ninterface Props {\\n  article: Omit<Post, 'createdAt'>\\n  summary?: boolean\\n}\\n\\nconst Article = ({ article, summary = false }: Props) => {\\n  return (\\n    <article>\\n      <header>\\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\\n        </h2>\\n      </header>\\n      <div className=\"mt-2 text-gray-900 font-light\">\\n        {summary ? truncate(article.body, 100) : article.body}\\n      </div>\\n      // highlight-next-line\\n      {!summary && <CommentsCell />}\\n    </article>\\n  )\\n}\\n\\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Running RedwoodJS Tests (Bash)\nDESCRIPTION: Starts the RedwoodJS test runner in interactive watch mode. This command is typically executed in the terminal within the project's root directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test\n```\n\n----------------------------------------\n\nTITLE: Modifying Apollo Cache Objects via useCache.modify (TypeScript)\nDESCRIPTION: Demonstrates updating one or more fields of a cached object by providing modifier functions to useCache.modify. In this example, the name field of a fruit entity is converted to uppercase on a button click. Useful for manually editing cached data after an optimistic update, mutation, or UI interaction.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_36\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst Fruit = ({ id }: { id: FragmentIdentifier }) => {\n  const { modify } = useCache()\n  const { data: fruit, complete } = useRegisteredFragment<Fruit>(id)\n\n  // Modify the name of a given fruit entity to be uppercase\n\n  <button onClick={() => modify(fruit,  {\n    name(cachedName) {\n      return cachedName.toUpperCase()\n  }})}>\n    Uppercase {fruit.name}\n  </button>\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Saving File Lists with \"saveFiles.inList\" Utility - RedwoodJS TypeScript\nDESCRIPTION: Provides an example for using `saveFiles.inList` to persist an array of uploaded files and map their paths for storage in related tables. Inputs (e.g., arrays in GraphQL SDL) are processed, and the resulting array of file paths is mapped as nested create operations within a Prisma update. Assists in scenarios where file arrays are not first-class fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const updateAlbum = async ({\n  id,\n  input,\n}) => {\n\n  // notice we're passing in the file list, and not the input!\n  // highlight-next-line\n  const processedInput = await saveFiles.inList(input.photos)\n  /* Returns an array like this:\n  [\n    '/baseStoragePath/AG1258019MAFGK.jpg',\n    '/baseStoragePath/BG1059149NAKKE.jpg',\n  ]\n  */\n\n  const mappedPhotos = processedInput.map((path) => ({ path }))\n  /* Will make `mappedPhotos` be an array of objects like this:\n  [\n    { path: '/baseStoragePath/AG1258019MAFGK.jpg' },\n    { path: '/baseStoragePath/BG1059149NAKKE.jpg' },\n  ]\n  */\n\n  return db.album.update({\n    data: {\n      ...input,\n      photo: {\n        createMany: {\n          data: mappedPhotos,\n        },\n      },\n    },\n    where: { id },\n  })\n\n\n```\n\n----------------------------------------\n\nTITLE: Output of User Role Update Command\nDESCRIPTION: This JSON output displays the result returned by the `db.user.update` command executed in the RedwoodJS console. It shows the updated user object, confirming that the `roles` field has been successfully changed to 'admin'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  id: 1,\n  name: null,\n  email: 'admin@admin.com',\n  hashedPassword: 'a12f3975a3722953fd8e326dd108d5645ad9563042fe9f154419361eeeb775d8',\n  salt: '9abf4665293211adce1c99de412b219e',\n  resetToken: null,\n  resetTokenExpiresAt: null,\n  roles: 'admin'\n}\n```\n\n----------------------------------------\n\nTITLE: Scoped Uniqueness with $scope in validateUniqueness for Multi-Tenant Systems in JavaScript/JSX\nDESCRIPTION: Checks that a new post title is unique within the scope of the current user only. $scope is used in the uniqueness filter so different users can have the same title, but not duplicates for a single user. Works well for multi-tenant or owner-specific data. validateUniqueness should support $scope in its filter objects, and context.currentUser.id must be available.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_57\n\nLANGUAGE: jsx\nCODE:\n```\nconst createPost = (input) => {\n  return validateUniqueness(\n    'post',\n    {\n      title: input.title,\n      $scope: { userId: context.currentUser.id },\n    },\n    (db) => {\n      return db.user.create({ data: input })\n    }\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Layout with Skip Links Using SkipNavLink and SkipNavContent - RedwoodJS - JavaScript/React\nDESCRIPTION: Illustrates the inclusion of skip navigation links in a main layout for keyboard and assistive technology users. Uses SkipNavLink and SkipNavContent from '@redwoodjs/router' with corresponding CSS import to allow users to skip navigation and jump to main content. Dependencies: '@redwoodjs/router', '@redwoodjs/router/skip-nav.css'. MainLayout accepts and renders children components, placing skip link and content in proper locations. Inputs: children. Outputs: a layout with a functional skip link for accessibility.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/a11y.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { SkipNavLink, SkipNavContent } from '@redwoodjs/router'\nimport '@redwoodjs/router/skip-nav.css'\n\nconst MainLayout = ({ children }) => {\n  return (\n    <>\n      <SkipNavLink />\n      <nav></nav>\n      <SkipNavContent />\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default MainLayout\n```\n\n----------------------------------------\n\nTITLE: Handling Signup Errors with React State in SignupPage - JavaScript\nDESCRIPTION: This enhancement adds user-facing error feedback using React.useState for error management. Errors from the signup attempt are displayed above the form if they exist, and error state is reset at the start of each submission. This requires importing React and using functional component conventions. No input/output change for successful signups, but unsuccessful attempts now yield an inline error message for the user.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from '@redwoodjs/auth'\n\nconst SignupPage = () => {\n  const { client } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = (data) => {\n    setError(null)\n    client\n      .signup(data.email, data.password)\n      .then((res) => console.log(res))\n      .catch((error) => setError(error.message))\n  }\n\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Signing Up with Redirect URL using RedwoodJS `useAuth` Hook (TypeScript)\nDESCRIPTION: Illustrates creating a new user and specifying a redirect URL for email confirmation using the `signUp` method from the RedwoodJS `useAuth` hook and the `options.emailRedirectTo` property.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst { signUp } = useAuth()\n\nawait signUp({\n  email: 'example@email.com',\n  password: 'example-password',\n  options: {\n    emailRedirectTo: 'https://example.com/welcome',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Centralized GraphQL Logging Configuration vs Service-Level Logging in TypeScript/JavaScript\nDESCRIPTION: Illustrates configuring the GraphQL handler (`createGraphQLHandler`) to log request `data`, `operationName`, and `query` centrally using `loggerConfig`. This approach avoids repetitive logging statements within individual service functions (like the example `post` function shown in JavaScript), keeping service logic cleaner while still capturing essential debugging information. Requires a `logger` instance. The example service retrieves a post from a database (`db`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_47\n\nLANGUAGE: jsx\nCODE:\n```\n// ...\nexport const handler = createGraphQLHandler({\n  loggerConfig: { logger, options: { data: true, operationName: true, query: true } },\n// ...\n```\n\nLANGUAGE: js\nCODE:\n```\n// api/src/services/posts.js\n//...\nexport const post = async ({ id }) => {\n  return await db.post.findUnique({\n    where: { id },\n  })\n}\n//...\n```\n\n----------------------------------------\n\nTITLE: Fetching the First Matching Record using `first()` Alias in JSX\nDESCRIPTION: The `first()` method is an alias for `findBy()`. It serves the same purpose of finding the first record matching given criteria but can be used to semantically indicate the intention of retrieving only the first record when multiple matches might exist.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\nconst randomCoreMember = await User.first({ email: { endsWith: { 'redwoodjs.com' } } })\n```\n\n----------------------------------------\n\nTITLE: Updating BlogLayout Component with Home Links in RedwoodJS (TypeScript)\nDESCRIPTION: This TSX snippet presents the TypeScript version of the `BlogLayout` component. It defines props using `BlogLayoutProps` type. Similar to the JavaScript version, it uses `Link` and `routes` from `@redwoodjs/router` to add links to the homepage within the header title and navigation list.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n```jsx title=\"web/src/layouts/BlogLayout/BlogLayout.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\ntype BlogLayoutProps = {\n  children?: React.ReactNode\n}\n\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\n  return (\n    <>\n      <header>\n        // highlight-start\n        <h1>\n          <Link to={routes.home()}>Redwood Blog</Link>\n        </h1>\n        // highlight-end\n        <nav>\n          <ul>\n            // highlight-start\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            // highlight-end\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n```\n\n----------------------------------------\n\nTITLE: Updating Seed Script to Include userId for Posts\nDESCRIPTION: Shows an example modification within the database seed script (`scripts/seed.js`). It adds the `userId: 1` key-value pair to a post object literal. This update is required to make the seed script compatible with the updated `Post` model schema, which now mandates a `userId` field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  id: 1,\n  name: 'John Doe',\n  title: 'Welcome to the blog!',\n  body:\n    \"I'm baby single- origin coffee kickstarter lo - fi paleo skateboard.Tumblr hashtag austin whatever DIY plaid knausgaard fanny pack messenger bag blog next level woke.Ethical bitters fixie freegan,helvetica pitchfork 90's tbh chillwave mustache godard subway tile ramps art party. Hammock sustainable twee yr bushwick disrupt unicorn, before they sold out direct trade chicharrones etsy polaroid hoodie. Gentrify offal hoodie fingerstache.\",\n  // highlight-next-line\n  userId: 1,\n},\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with Custom Message and Interpolation in JSX\nDESCRIPTION: Shows providing a custom error message for the `numericality` validator that uses string interpolation. Placeholders for specific numerical options (e.g., `${otherThan}`, `${lessThan}`, `${equal}`) can be used within the message string (using single or double quotes, not backticks).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_41\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.floor, 'Floor', {\n  numericality: {\n    otherThan: 13,\n    message: 'You cannot go to floor ${otherThan}',\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Named GraphQL Query in a Redwood Cell (JavaScript/GraphQL)\nDESCRIPTION: This code shows how to define a named GraphQL query (`FindBlogPostQuery`) within a RedwoodJS Cell component (`BlogPostCell.tsx`) using the `gql` template literal tag. Naming the operation is crucial as Redwood uses this name to generate corresponding TypeScript types for the query result and variables.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/generated-types.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const QUERY = gql`\n  # 👇 Make sure to name your GraphQL operations\n  query FindBlogPostQuery($id: Int!) {\n    blogPost: post(id: $id) {\n      title\n      body\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Handling Basic Form Submission in RedwoodJS (TypeScript)\nDESCRIPTION: This snippet demonstrates defining a typed `onSubmit` function in a TypeScript React component using RedwoodJS. It utilizes the `SubmitHandler` type and a `FormValues` interface to define the structure of the submitted data, which is then logged to the console. The `<Form>` component from `@redwoodjs/forms` uses this typed handler.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField, Submit, SubmitHandler } from '@redwoodjs/forms'\n\n// highlight-start\ninterface FormValues {\n  input: string\n}\n// highlight-end\n\nconst ContactPage = () => {\n  // highlight-start\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n  // highlight-end\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n      // highlight-next-line\n      <Form onSubmit={onSubmit}>\n        <TextField name=\"input\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Comment Deletion in RedwoodJS Component (TSX)\nDESCRIPTION: This is the TypeScript version (`Comment.tsx`) implementing comment deletion. It includes type imports for the GraphQL mutation (`DeleteCommentMutation`, `DeleteCommentMutationVariables`) and the comment object (`IComment`). The `DELETE` mutation is defined using `TypedDocumentNode` for type safety. The `useMutation` hook and `moderate` function work similarly to the JSX version but with added type checking.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-start\nimport type {\n  Comment as IComment,\n  DeleteCommentMutation,\n  DeleteCommentMutationVariables,\n} from 'types/graphql'\n\nimport type { TypedDocumentNode } from '@redwoodjs/web'\nimport { useMutation } from '@redwoodjs/web'\n\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n// highlight-end\nimport { useAuth } from 'src/auth'\n\n// highlight-start\nconst DELETE: TypedDocumentNode<\n  DeleteCommentMutation,\n  DeleteCommentMutationVariables\n> = gql`\n  mutation DeleteCommentMutation($id: Int!) {\n    deleteComment(id: $id) {\n      postId\n    }\n  }\n`\n// highlight-end\n\nconst formattedDate = (datetime: ConstructorParameters<typeof Date>[0]) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n\ninterface Props {\n  // highlight-next-line\n  comment: Pick<IComment, 'postId' | 'id' | 'name' | 'createdAt' | 'body'>\n}\n\nconst Comment = ({ comment }: Props) => {\n  const { hasRole } = useAuth()\n  // highlight-start\n  const [deleteComment] = useMutation(DELETE, {\n    refetchQueries: [\n      {\n        query: CommentsQuery,\n        variables: { postId: comment.postId },\n      },\n    ],\n  })\n  // highlight-end\n\n  const moderate = () => {\n    if (confirm('Are you sure?')) {\n      // highlight-start\n      deleteComment({\n        variables: { id: comment.id },\n      })\n      // highlight-end\n    }\n  }\n\n  return (\n    <div className=\"bg-gray-200 p-8 rounded-lg relative\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n      {hasRole('moderator') && (\n        <button\n          type=\"button\"\n          onClick={moderate}\n          className=\"absolute bottom-2 right-2 bg-red-500 text-xs rounded text-white px-2 py-1\"\n        >\n          Delete\n        </button>\n      )}\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Initializing Nhost Auth Client - TypeScript\nDESCRIPTION: Initializes a Nhost authentication client in the web environment. The NhostClient is created with a required backendUrl, which should be sourced from environment variables for security. To use this, install '@nhost/nhost-js' and ensure a valid backend URL is provided. This code is foundational for connecting RedwoodJS to Nhost's authentication services, enabling subsequent login, signup, and token retrieval flows.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NhostClient } from '@nhost/nhost-js'\n\nconst client = new NhostClient({\n  backendUrl: '...',\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Required Relation in GraphQL SDL (GraphQL)\nDESCRIPTION: This GraphQL schema definition language (SDL) snippet defines a `Post` type with a required `author` field, which is a relation to the `Author` type. The `!` indicates that the `author` field cannot be null, setting the context for handling this required relation in the corresponding service resolver under TypeScript strict mode.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\n  type Post {\n    id: Int!\n    title: String!\n    // highlight-next-line\n    author: Author! # 👈 This is a relation; the \\`!\\` makes it a required field\n    authorId: Int!\n    # ...\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Using the Absence Validator with `allowEmptyString` Option in JSX\nDESCRIPTION: Demonstrates the `absence` validator with the `allowEmptyString` option set to `true`. This configuration allows an empty string (`\"\"`) to pass the validation, in addition to `null` and `undefined`. It's useful for optional fields or honeypots.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.honeypot, 'Honeypot', {\n  absence: { allowEmptyString: true },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Records Through an Explicit Many-to-Many Join Table in JSX\nDESCRIPTION: For explicit many-to-many relationships involving a join table (e.g., `ProductCategories`), accessing related records requires a two-step process. First, fetch the join table records using the one-to-many relation proxy (e.g., `product.productCategories.all()`). Then, for each join record, fetch the target record using the belongs-to relationship (e.g., `pc.category`). `Promise.all` is used to handle the asynchronous fetching of target records.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_33\n\nLANGUAGE: jsx\nCODE:\n```\nconst product = await Product.find(123)\nconst productCategories = await product.productCategories.all()\nconst categories = await Promise.all(\n  productCategories.map(async (pc) => await pc.category)\n)\n```\n\n----------------------------------------\n\nTITLE: Generating a New Home Page with Redwood CLI - Bash\nDESCRIPTION: Demonstrates Redwood CLI usage for generating a new Home page component. This sets up a new route and component file for HomePage in the project, used later for showcasing SuperTokens integration. Requires correct project setup and installed Redwood CLI. Input: CLI command. Output: new files for HomePage route and component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supertokens.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g page home /\n```\n\n----------------------------------------\n\nTITLE: Prisma Model Definition for User - RedwoodJS/Prisma - JSX\nDESCRIPTION: Shows a Prisma ORM model for 'User' with id, email, and name fields. Used for database schema definition within RedwoodJS projects. Requires a 'schema.prisma' database file and Prisma migration tooling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nmodel User {\\n  id    Int     @id @default(autoincrement())\\n  email String  @unique\\n  name  String?\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Path Aliases in tsconfig.json for RedwoodJS - JSON\nDESCRIPTION: This JSON snippet demonstrates configuring custom path aliases within the compilerOptions section of tsconfig.json for a RedwoodJS project. By customizing the 'paths' property, you can create aliases like '@adminUI/*' to map to deep directory structures, improving import convenience and readability. The configuration supports advanced scenarios such as mirroring generated types from the .redwood directory and is compatible with TypeScript 3.0+.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/introduction.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n...\n    \"paths\": {\n      \"src/*\": [\"./src/*\", \"../.redwood/types/mirror/api/src/*\"],\n\n      \"@adminUI/*\": [\n        \"./src/components/modules/admin/common/ui/*\",\n        \"../.redwood/types/mirror/web/src/components/modules/admin/common/ui/*\"\n      ],\n\n      \"types/*\": [\"./types/*\", \"../types/*\"],\n      \"@redwoodjs/testing\": [\"../node_modules/@redwoodjs/testing/api\"]\n    }\n  }\n...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Post Model in Prisma Schema (JavaScript/Prisma)\nDESCRIPTION: This Prisma schema (`api/db/schema.prisma`) defines the data structure for blog posts. It specifies SQLite as the database provider, configures the Prisma client generator, and defines a `Post` model with an auto-incrementing integer ID, string fields for title and body, and an automatically generated `createdAt` timestamp. This schema is used by Prisma Migrate to manage database structure changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/getting-dynamic.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = \"native\"\n}\n\n// highlight-start\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  body      String\n  createdAt DateTime @default(now())\n}\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Mocking a GraphQL Query in a RedwoodJS Test (JSX)\nDESCRIPTION: This test uses RedwoodJS testing utilities (`@redwoodjs/testing/web`) to test the `Article` component. It employs `mockGraphQLQuery` to intercept the 'getArticle' GraphQL query, providing a predefined mock response. The test renders the `Article` component with `id={1}` and uses the asynchronous `screen.findByText` to assert that the title from the mocked data ('Foobar') is eventually rendered, accommodating the component's loading state. The test function is marked `async` and uses `await` for the assertion.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\nimport { render, screen } from '@redwoodjs/testing/web'\nimport Article from 'src/components/Article'\n\ndescribe('Article', () => {\n  it('renders the title of an article', async () => {\n    mockGraphQLQuery('getArticle', (variables) => {\n      return {\n        article: {\n          id: variables.id,\n          title: 'Foobar',\n          body: 'Lorem ipsum...',\n        }\n      }\n    })\n\n    render(<Article id={1} />)\n\n    expect(await screen.findByText('Foobar')).toBeInTheDocument()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Ordering Scenario Record Access in RedwoodJS - JSX\nDESCRIPTION: Showcases how defineScenario supports ordered record creation, enabling scenario functions to access previously defined records. Each scenario's data function can refer to earlier records via the scenario parameter. This allows advanced relational structures such as cascading dependencies among user, post, and comment entities for complex fixture construction.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_65\n\nLANGUAGE: jsx\nCODE:\n```\nexport const standard = defineScenario({\n  user: {\n    kris: {\n      data: { name: 'Kris' },\n    },\n  },\n  post: {\n    first: (scenario) => ({\n      // Here you have access to the user above via `scenario.user`\n    }),\n  },\n  comment: {\n    first: (scenario) => ({\n      // Here you have access to both `scenario.user` and `scenario.post`\n    }),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Alternate Post User Relation Resolver via User Lookup in RedwoodJS (JavaScript)\nDESCRIPTION: This alternative resolver for the `Post.user` relation directly looks up the user by their `userId` associated with the post. Instead of fetching the post and then the user, it queries the user table with `root.userId`. This approach also requires access to Prisma via the `db` dependency and is suitable only when the post object always includes a valid `userId`. As with the previous resolver, this method may result in N+1 queries for GraphQL.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nexport const Post = {\n  user: (_obj, { root }) => db.user.findFirst({ where: { id: root.userId } }),\n}\n```\n\n----------------------------------------\n\nTITLE: Using toast.promise for Async Toast Notifications - RedwoodJS - JSX\nDESCRIPTION: This snippet covers calling the toast.promise function to provide async status notification (loading, success, error) during an asynchronous mutation. It demonstrates wrapping a call to a GraphQL mutation with toast.promise to automatically manage notification states. Dependencies are @redwoodjs/web/toast and a useMutation hook. The toast.promise object accepts strings for loading, success, and error messages, correlating with the promise's lifecycle. It is not compatible with the useMutation onError callback.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/toast-notifications.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { toast } from '@redwoodjs/web/toast'\\n\\n// ...\\n\\nconst PostForm = () => {\\n  const [create, { loading, error }] = useMutation(CREATE_POST_MUTATION)\\n\\n  const onSubmit = (data) => {\\n    // highlight-next-line\\n    toast.promise(create({ variables: { input: data }}), {\\n      loading: 'Creating post...',\\n      success: 'Post created',\\n      error: 'Error creating post',\\n    })\\n  }\\n\\n  return (\\n    // <Form onSubmit={onSubmit}> ... </Form>\\n  )\\n})\\n\\nexport default PostForm\n```\n\n----------------------------------------\n\nTITLE: Declaring a Custom Weather GraphQL SDL with RedwoodJS - JavaScript\nDESCRIPTION: This JavaScript snippet defines a GraphQL schema using RedwoodJS conventions, specifying the 'Weather' type and the 'getWeather' query. The Weather type expects zip code, city, conditions, temperature, and icon, all as non-nullable fields. This schema serves as the contract between frontend and backend, requiring a valid zip string as input and returning the Weather object with formatted data. No external dependencies beyond Redwood's GraphQL tools are required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nexport const schema = gql`\n  type Weather {\n    zip: String!\n    city: String!\n    conditions: String!\n    temp: Int!\n    icon: String!\n  }\n\n  type Query {\n    getWeather(zip: String!): Weather! @skipAuth\n  }\n`\n\n```\n\n----------------------------------------\n\nTITLE: Implementing requireAuth Logic in RedwoodJS (TypeScript)\nDESCRIPTION: Demonstrates the structure of `isAuthenticated` and `requireAuth` functions in `api/src/lib/auth.ts`. `isAuthenticated` should contain logic to verify user authentication, while `requireAuth` uses it and `hasRole` (not shown) to enforce authentication and role-based access, throwing `AuthenticationError` or `ForbiddenError` if checks fail. This example is a placeholder requiring specific auth provider logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\n// ...\n\nexport const isAuthenticated = (): boolean => {\n  return true // 👈 replace with the appropriate check\n}\n\n// ...\n\nexport const requireAuth = ({ roles }: { roles: AllowedRoles }) => {\n  if (isAuthenticated()) {\n    throw new AuthenticationError(\"You don't have permission to do that.\")\n  }\n\n  if (!hasRole({ roles })) {\n    throw new ForbiddenError(\"You don't have access to do that.\")\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying SelectField Submit Result as an Integer Object (JSX)\nDESCRIPTION: This code shows the format of the submission data when a number-coerced <SelectField> is used in a React form. Selecting an option results in an object mapping the select field name to the selected integer value. It demonstrates the data structure received by the onSubmit handler, with input being a selected numeric option and output an object containing the primitive number.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n{\n  select: 3,\n}\n\n```\n\n----------------------------------------\n\nTITLE: Instantiating Nhost Auth Client Using .env Variable - TypeScript\nDESCRIPTION: Instantiates the NhostClient for authentication using the backend URL obtained from the NHOST_BACKEND_URL environment variable. This code ensures sensitive configuration is managed outside the codebase and integrates cleanly with Redwood and dotenv conventions. The import and instantiation steps are core to enabling Nhost-based authentication flows on the web side.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAuthentication } from '@redwoodjs/auth'\n\nimport { NhostClient } from '@nhost/nhost-js'\n\n// ...\n\nconst client = new NhostClient({\n  backendUrl: process.env.NHOST_BACKEND_URL,\n})\n```\n\n----------------------------------------\n\nTITLE: Getting Current User Metadata in RedwoodJS Component (TSX)\nDESCRIPTION: Retrieves the full Supabase user session object, including metadata, using the `userMetadata` property from the RedwoodJS `useAuth` hook. This corresponds to the result of Supabase's `auth.getSession()`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nconst { userMetadata } = useAuth()\n\n<p>{JSON.stringify({ userMetadata })}</p>\n```\n\n----------------------------------------\n\nTITLE: GraphQL SDL with Documentation Comments - GraphQL\nDESCRIPTION: This GraphQL SDL snippet showcases the use of triple-quoted and single-quoted description comments for documenting directives, inputs, types, queries, and mutations. These comments are inserted into the schema when the SDL generator is run with the --docs flag, enhancing API self-documentation. The snippet defines directives, input types, a Post type, mutations, and queries, all with descriptions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_83\n\nLANGUAGE: graphql\nCODE:\n```\n\"\"\"\nUse to check whether or not a user is authenticated and is associated\nwith an optional set of roles.\n\"\"\"\ndirective @requireAuth(roles: [String]) on FIELD_DEFINITION\n\n\"\"\"Use to skip authentication checks and allow public access.\"\"\"\ndirective @skipAuth on FIELD_DEFINITION\n\n\"\"\"\nAutogenerated input type of InputPost.\n\"\"\"\ninput CreatePostInput {\n  \"The content of a post.\"\n  body: String!\n\n  \"The title of a post.\"\n  title: String!\n}\n\n\"\"\"\nAutogenerated input type of UpdatePost.\n\"\"\"\ninput UpdatePostInput {\n  \"The content of a post.\"\n  body: String\n\n  \"The title of a post.\"\n  title: String\n}\n\n\"\"\"\nA blog post.\n\"\"\"\ntype Post {\n  \"The content of a post.\"\n  body: String!\n\n  \"Description for createdAt.\"\n  createdAt: DateTime!\n\n  \"The unique identifier of a post.\"\n  id: Int!\n\n  \"The title of a post.\"\n  title: String!\n}\n\n\"\"\"\nAbout mutations\n\"\"\"\ntype Mutation {\n  \"Creates a new Post.\"\n  createPost(input: CreatePostInput!): Post!\n\n  \"Deletes an existing Post.\"\n  deletePost(id: Int!): Post!\n\n  \"Updates an existing Post.\"\n  updatePost(id: Int!, input: UpdatePostInput!): Post!\n}\n\n\"\"\"\nAbout queries\n\"\"\"\ntype Query {\n  \"Fetch a Post by id.\"\n  post(id: Int!): Post\n\n  \"Fetch Posts.\"\n  posts: [Post!]!\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Expiration for Cache Entries (JavaScript)\nDESCRIPTION: This code shows how to cache a product using a simple key and force cache expiration after a specified time. The cache is built with a key pattern incorporating the product id and a configuration setting an 'expires' option to 3600 seconds (1 hour). Dependencies: a 'cache' function supporting expiration options. Parameters include the cache key, a computation callback, and an option object with 'expires'. The cache is rebuilt periodically regardless of data changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_62\n\nLANGUAGE: JavaScript\nCODE:\n```\ncache(\n  `product-${id}`,\n  () => {\n    // ...\n  },\n  { expires: 3600 }\n)\n```\n\n----------------------------------------\n\nTITLE: Generating a Session Secret with RedwoodJS CLI in Bash\nDESCRIPTION: Executes the RedwoodJS command to generate a cryptographically secure secret string. This generated secret is intended to be used for the `SESSION_SECRET` environment variable in the deployment environment (Netlify), crucial for securing user sessions when using dbAuth.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/deployment.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g secret\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query for Fetching Comments with Nested Post Data\nDESCRIPTION: This GraphQL snippet shows an example query `CommentsQuery` to fetch a list of comments. For each comment, it requests the `id`, `name`, `body`, `createdAt`, and details of the associated `post` (its `id`, `title`, `body`, `createdAt`). This demonstrates how the `Comment.post` resolver defined in the service enables nested data fetching.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\nquery CommentsQuery {\n  comments {\n    id\n    name\n    body\n    createdAt\n    post {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Blog Layout with Authentication and Navigation - RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript/React component implements a layout for a blog, utilizing RedwoodJS for routing and toast notifications. It provides navigation links, authentication-aware UI (login/logout), and displays the current user's email when authenticated. Dependencies include @redwoodjs/router, @redwoodjs/web/toast, and a useAuth hook supplying authentication state and logout functionality. The component accepts child nodes, renders a styled header and main content area, and exposes logout logic via a button when the user is logged in.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n// highlight-next-line\nimport { Toaster } from '@redwoodjs/web/toast'\n\nimport { useAuth } from 'src/auth'\n\ntype BlogLayoutProps = {\n  children?: React.ReactNode\n}\n\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\n  const { logOut, isAuthenticated, currentUser } = useAuth()\n\n  return (\n    <>\n      // highlight-next-line\n      <Toaster />\n      <header className=\"relative flex justify-between items-center py-4 px-8 bg-blue-700 text-white\">\n        <h1 className=\"text-5xl font-semibold tracking-tight\">\n          <Link\n            className=\"text-blue-400 hover:text-blue-100 transition duration-100\"\n            to={routes.home()}\n          >\n            Redwood Blog\n          </Link>\n        </h1>\n        <nav>\n          <ul className=\"relative flex items-center font-light\">\n            <li>\n              <Link\n                className=\"py-2 px-4 hover:bg-blue-600 transition duration-100 rounded\"\n                to={routes.about()}\n              >\n                About\n              </Link>\n            </li>\n            <li>\n              <Link\n                className=\"py-2 px-4 hover:bg-blue-600 transition duration-100 rounded\"\n                to={routes.contact()}\n              >\n                Contact\n              </Link>\n            </li>\n            <li>\n              {isAuthenticated ? (\n                <div>\n                  <button type=\"button\" onClick={logOut} className=\"py-2 px-4\">\n                    Logout\n                  </button>\n                </div>\n              ) : (\n                <Link to={routes.login()} className=\"py-2 px-4\">\n                  Login\n                </Link>\n              )}\n            </li>\n          </ul>\n          {isAuthenticated && (\n            <div className=\"absolute bottom-1 right-0 mr-12 text-xs text-blue-300\">\n              {currentUser.email}\n            </div>\n          )}\n        </nav>\n      </header>\n      <main className=\"max-w-4xl mx-auto p-12 bg-white shadow rounded-b\">\n        {children}\n      </main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Retrieve Current Route Path with useRoutePath - RedwoodJS React Hook - JavaScript/JSX\nDESCRIPTION: Demonstrates both default and named route usage of the useRoutePath hook from RedwoodJS to retrieve the path for the current or a given route. Inputs are zero or one route name; output is the string path corresponding to that route. Supports dynamic route lookup without manual mapping.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_24\n\nLANGUAGE: jsx\nCODE:\n```\n// returns \"/about\" if you're currently on https://example.org/about\nconst aboutPath = useRoutePath()\n```\n\nLANGUAGE: jsx\nCODE:\n```\n// returns \"/about\"\nconst aboutPath = useRoutePath('about')\n```\n\n----------------------------------------\n\nTITLE: Accessing Loading and Error States from useMutation in JSX\nDESCRIPTION: This JSX snippet demonstrates how to destructure the `loading` and `error` properties from the result array returned by the RedwoodJS `useMutation` hook. These states can be used to provide feedback to the user during the mutation process.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\n// ...\n\nconst ContactPage = () => {\n  // highlight-next-line\n  const [create, { loading, error }] = useMutation(CREATE_CONTACT)\n\n  const onSubmit = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (...)\n}\n\n// ...\n```\n```\n\n----------------------------------------\n\nTITLE: Query Posts Including User Name - RedwoodJS Cell - GraphQL (in JSX)\nDESCRIPTION: A frontend GraphQL query used in a RedwoodJS Cell component to fetch articles (posts) along with the related user's name. No dependencies beyond RedwoodJS's standard GraphQL setup. Returns a list of articles, each containing id, title, body, createdAt, and the related user's name when available. The query is parameterless and suitable for components like homepages or lists.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_11\n\nLANGUAGE: graphql\nCODE:\n```\nquery ArticlesQuery {\n  articles: posts {\n    id\n    title\n    body\n    createdAt\n    // highlight-start\n    user {\n      name\n    }\n    // highlight-end\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Submitting Contact Form with Mutation - RedwoodJS - TypeScript\nDESCRIPTION: This TypeScript snippet defines the ContactPage component using RedwoodJS's typed hooks and GraphQL schema. It also defines a GraphQL mutation for contact creation, types form values, and sets up the form using React and RedwoodJS components. Validation is performed on each field, form state is managed with onBlur, and contact creation is invoked on submit. Required dependencies include RedwoodJS web, forms, and types/graphql. The form handles name, email, and message fields, expects FormValues, and submits a GraphQL mutation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\nimport {\n  CreateContactMutation,\n  CreateContactMutationVariables,\n} from 'types/graphql'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const [create] = useMutation<\n    CreateContactMutation,\n    CreateContactMutationVariables\n  >(CREATE_CONTACT)\n\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    // highlight-next-line\n    create({ variables: { input: data } })\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Passing Route Parameter to Link in ArticlesCell.tsx (TypeScript/TSX)\nDESCRIPTION: Updates the `Link` component within `ArticlesCell.tsx`. It uses the named route function `routes.article()` and passes an object `{ id: article.id }` as an argument to construct the URL with the article's ID, like `/article/1`. This is the TypeScript version.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/components/ArticlesCell/ArticlesCell.tsx\"\n<h2>\n  <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n</h2>\n```\n\n----------------------------------------\n\nTITLE: Implementing a RedwoodJS Validator Directive (`@requireAuth`) with Arguments (TypeScript)\nDESCRIPTION: Shows the TypeScript implementation for the `@requireAuth` validator directive. It defines the schema accepting a `roles` argument and uses `createValidatorDirective`. The `validate` function extracts `directiveArgs` and calls the application's `requireAuth` function from `src/lib/auth` to enforce authentication and role-based access control. Requires `@redwoodjs/graphql-server` and application-specific auth logic (`src/lib/auth`, `src/lib/logger`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport gql from 'graphql-tag'\n\nimport { createValidatorDirective } from '@redwoodjs/graphql-server'\n\nimport { requireAuth as applicationRequireAuth } from 'src/lib/auth'\nimport { logger } from 'src/lib/logger'\n\nexport const schema = gql`\n  directive @requireAuth(roles: [String]) on FIELD_DEFINITION\n`\n\nconst validate = ({ directiveArgs }) => {\n  const { roles } = directiveArgs\n\n  applicationRequireAuth({ roles })\n}\n\nconst requireAuth = createValidatorDirective(schema, validate)\n\nexport default requireAuth\n```\n\n----------------------------------------\n\nTITLE: Defining ArticleCell GraphQL Query and States (JavaScript)\nDESCRIPTION: This JavaScript snippet defines the `ArticleCell` component (`web/src/components/ArticleCell/ArticleCell.jsx`). It includes a GraphQL query `FindArticleQuery` that accepts an `$id` (Int!) variable to fetch a specific post, aliasing `post` to `article` and retrieving `id`, `title`, `body`, and `createdAt` fields. It also exports standard components for `Loading`, `Empty`, `Failure`, and `Success` states, with `Success` initially stringifying the result.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticleCell/ArticleCell.jsx\"\nexport const QUERY = gql`\n  query FindArticleQuery($id: Int!) {\n    // highlight-next-line\n    article: post(id: $id) {\n      id\n      // highlight-start\n      title\n      body\n      createdAt\n      // highlight-end\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({ article }) => {\n  return <div>{JSON.stringify(article)}</div>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS CRUD Scaffold for Post Model (bash)\nDESCRIPTION: This command utilizes the RedwoodJS CLI's scaffold generator (`yarn rw g scaffold`) to automatically create a complete set of files necessary for Create, Read, Update, and Delete (CRUD) operations on the specified 'Post' model. It generates associated pages, components, cells, SDL definitions, services, and routes, providing a functional interface for managing posts. This command requires the RedwoodJS framework to be set up and a 'Post' model defined in the Prisma schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/getting-dynamic.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g scaffold post\n```\n\n----------------------------------------\n\nTITLE: Testing a Divide Function for Successful Division - React/JSX/TypeScript\nDESCRIPTION: This snippet demonstrates a unit test written in TypeScript using RedwoodJS's testing utilities to validate the correct behavior of a 'divide' serverless function. It mocks an HTTP event with dividend and divisor, invokes the handler, and checks for a successful division result (status 200 and correct quotient). Dependencies include '@redwoodjs/testing/api' for mock event creation, and the 'divide' function handler.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { mockHttpEvent } from '@redwoodjs/testing/api'\nimport { handler } from './divide'\n\ndescribe('divide serverless function',  () => {\n  it('divides two numbers successfully', async () => {\n    const httpEvent = mockHttpEvent({\n      queryStringParameters: {\n        dividend: '20',\n        divisor: '5',\n      },\n    })\n\n    const result = await handler(httpEvent)\n    const body = result.body\n\n    expect(result.statusCode).toBe(200)\n    expect(body.message).toContain('=')\n    expect(body.quotient).toEqual(4)\n  })\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Button Conditionally with RedwoodJS Auth in JSX\nDESCRIPTION: This JSX snippet demonstrates a React component using the `useAuth` hook from RedwoodJS to get the current user and a `hasRole` function. It conditionally renders a 'Delete User' button only if the `hasRole('admin')` function returns true. This pattern is used to illustrate testing role-based rendering.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_28\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\nconst { currentUser, hasRole } = useAuth()\n\nreturn (\n  { hasRole('admin') && <button onClick={deleteUser}>Delete User</button> }\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Protecting RedwoodJS Component Content for Multiple Roles (JSX)\nDESCRIPTION: This snippet demonstrates protecting content within a React component (`Post`) based on multiple roles. The 'Delete' button is rendered only if the authenticated user possesses either the 'admin' or 'publisher' role, checked using the `hasRole` function from `useAuth`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAuth } from '@redwoodjs/auth'\\n\\nconst Post = ({ post }) => {\\n  const { hasRole } = useAuth()\\n\\n  return (\\n    <nav className=\"rw-button-group\">\\n      {(hasRole(['admin', 'publisher'])) && (\\n          <a href=\"#\" className=\"rw-button rw-button-red\" onClick={() => onDeleteClick(post.id)}>\\n            Delete\\n          </a>\\n        ))}\\n    </nav>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Routes Using Redwood Router - TypeScript\nDESCRIPTION: Shows how to define and export routes in a RedwoodJS application using TypeScript. The pattern is identical to the JavaScript version, but intended for use in a TSX file. Imports required modules, provides two main routes (homepage and NotFoundPage), and exports the Routes function. Relies on typed components and is suitable for inclusion in 'web/src/Routes.tsx'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/first-page.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route } from '@redwoodjs/router'\n\nconst Routes = () => {\n  return (\n    <Router>\n      // highlight-next-line\n      <Route path=\"/\" page={HomePage} name=\"home\" />\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Implementing Role-Based Access Control in Service Function (JavaScript/TypeScript)\nDESCRIPTION: Shows the service implementation for `deleteComment`. It imports and calls the `requireAuth` function from `src/lib/auth`, explicitly requiring the 'moderator' role before proceeding to delete the comment from the database using `db.comment.delete`. This provides protection even if the function is called internally, bypassing the GraphQL layer.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.js\"\n// highlight-next-line\nimport { requireAuth } from 'src/lib/auth'\nimport { db } from 'src/lib/db'\n\n// ...\n\nexport const deleteComment = ({ id }) => {\n  // highlight-next-line\n  requireAuth({ roles: 'moderator' })\n  return db.comment.delete({\n    where: { id },\n  })\n}\n```\n```\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/services/comments/comments.ts\"\n// highlight-next-line\nimport { requireAuth } from 'src/lib/auth'\nimport { db } from 'src/lib/db'\n\n// ...\n\nexport const deleteComment = ({ id }) => {\n  // highlight-next-line\n  requireAuth({ roles: 'moderator' })\n  return db.comment.delete({\n    where: { id },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Current User with Prisma in RedwoodJS - JavaScript\nDESCRIPTION: This function defines getCurrentUser, which asynchronously queries the database for a user matching the provided session's ID using Prisma's findUnique method. It requires a valid session object with an id property and depends on the presence of a configured db instance (Prisma client). The function returns an object with the user's id and email fields or null if not found, and is intended for use in authenticated routes within a RedwoodJS app.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nexport const getCurrentUser = async (session) => {\n  return await db.user.findUnique({\n    where: { id: session.id },\n    // highlight-next-line\n    select: { id: true, email: true },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Comments and Related Post in RedwoodJS Service (JavaScript)\nDESCRIPTION: Implements functions within 'api/src/services/comments/comments.js' to retrieve all comments (`db.comment.findMany()`) and a specific comment by ID (`db.comment.findUnique()`) using the Prisma client (`db`). Includes a resolver `Comment.post` to fetch the post related to a comment via `db.comment.findUnique({ where: { id: root.id } }).post()`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.js\"\nimport { db } from 'src/lib/db'\n\nexport const comments = () => {\n  return db.comment.findMany()\n}\n\nexport const comment = ({ id }) => {\n  return db.comment.findUnique({\n    where: { id },\n  })\n}\n\nexport const Comment = {\n  post: (_obj, { root }) =>\n    db.comment.findUnique({ where: { id: root.id } }).post(),\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Generating a Page with Redwood CLI - Bash\nDESCRIPTION: Demonstrates how to generate a new page in a RedwoodJS project using the command line. Runs the 'yarn redwood generate page home /' command, which auto-creates a new page component, its test, a Storybook story, and a corresponding route. No prerequisites other than having a RedwoodJS project and CLI installed. The command does not take further input beyond page name and route URL, and outputs several files in relevant locations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/first-page.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate page home /\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Function using CLI\nDESCRIPTION: Uses the RedwoodJS command-line interface (`yarn rw g function`) to scaffold a new serverless function named `serverTime`. This creates the necessary files and boilerplate code within the RedwoodJS project structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw generate function serverTime\n```\n\n----------------------------------------\n\nTITLE: Creating a Comment with UI Feedback using RedwoodJS and react-hot-toast (JavaScript)\nDESCRIPTION: Implements a comment form with RedwoodJS Forms, Apollo useMutation, and react-hot-toast for user notifications. On comment creation, the form is hidden, and a success toast is shown. If triggered, the refetchQueries option ensures new comments appear right away. Key dependencies are @redwoodjs/forms, @redwoodjs/web, and @redwoodjs/web/toast. Parameters include postId, name, and comment body. The main limitation is the simplistic hide/show logic, and the toast relies on the Toaster being mounted somewhere in the app (see next snippet).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { useState } from 'react'\n\nimport {\n  Form,\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\nimport { useMutation } from '@redwoodjs/web'\n// highlight-next-line\nimport { toast } from '@redwoodjs/web/toast'\n\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n\nconst CREATE = gql`\n  mutation CreateCommentMutation($input: CreateCommentInput!) {\n    createComment(input: $input) {\n      id\n      name\n      body\n      createdAt\n    }\n  }\n`\n\nconst CommentForm = ({ postId }) => {\n  // highlight-next-line\n  const [hasPosted, setHasPosted] = useState(false)\n  const [createComment, { loading, error }] = useMutation(CREATE, {\n    // highlight-start\n    onCompleted: () => {\n      setHasPosted(true)\n      toast.success('Thank you for your comment!')\n    },\n    // highlight-end\n    refetchQueries: [{ query: CommentsQuery }],\n  })\n\n  const onSubmit = (input) => {\n    createComment({ variables: { input: { postId, ...input } } })\n  }\n\n  return (\n    // highlight-next-line\n    <div className={hasPosted ? 'hidden' : ''}>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      <Form className=\"mt-4 w-full\" onSubmit={onSubmit}>\n        <FormError\n          error={error}\n          titleClassName=\"font-semibold\"\n          wrapperClassName=\"bg-red-100 text-red-900 text-sm p-3 rounded\"\n        />\n        <Label\n          name=\"name\"\n          className=\"block text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-sm \"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-sm\"\n          validation={{ required: true }}\n        />\n\n        <Submit\n          disabled={loading}\n          className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\"\n        >\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n\n----------------------------------------\n\nTITLE: Defining Route with Integer Param Type in RedwoodJS (JavaScript)\nDESCRIPTION: Configures a RedwoodJS route in `Routes.jsx`. The path `/article/{id:Int}` uses a route param type (`:Int`) to specify that the `id` parameter should be treated as an integer. This ensures the router only matches URLs where `id` is numeric and automatically converts the parameter to a number before passing it to the `ArticlePage`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Metadata Configuration Example in JSX\nDESCRIPTION: Provides a typical example of using the `<Metadata>` component with multiple props to configure a full set of metadata tags, including title, description, robots directive, Open Graph (og) properties like image, and Twitter card details (card type, site handle, creator handle).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata\n  title=\"My Website\"\n  description=\"An amazing website created with RedwoodJS\"\n  robots=\"noindex,nofollow\"\n  og={{ image: \"https://example.com/images/og-image.png\" }}\n  twitter={{\n    card: 'summary',\n    site: '@mysite',\n    creator: '@redwoodjs'\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Setting Up Tailwind CSS with Redwood CLI - Shell\nDESCRIPTION: This shell command uses Redwood's CLI to automatically configure Tailwind CSS in the project web side. It sets up all required dependencies and configuration files for Tailwind CSS support in the frontend. No additional parameters are required; just execute the command to begin using Tailwind's utility classes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/vite-configuration.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nyarn rw setup ui tailwindcss\n```\n\n----------------------------------------\n\nTITLE: Implementing Typed RedwoodJS ArticlesCell with Aliased Query (TypeScript)\nDESCRIPTION: Shows the complete TypeScript implementation of `ArticlesCell.tsx`. It includes the typed `QUERY` constant (`TypedDocumentNode`) with the `articles: posts` alias, standard `Loading`, `Empty`, and typed `Failure`/`Success` components using RedwoodJS utility types (`CellFailureProps`, `CellSuccessProps`) and generated GraphQL types. The `Success` component iterates over the typed `articles` array.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\n  gql`\n    query ArticlesQuery {\n      // highlight-next-line\n      articles: posts {\n        id\n      }\n    }\n  `\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<ArticlesQueryVariables>) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  // highlight-next-line\n  articles,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\n  return (\n    <ul>\n      // highlight-next-line\n      {articles.map((item) => {\n        return <li key={item.id}>{JSON.stringify(item)}</li>\n      })}\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Workflow: Validation Errors, Correction, and `save()` (JavaScript/JSX)\nDESCRIPTION: A JavaScript/JSX code sequence showing the practical application of model validations. It demonstrates building a record with invalid data (`username` too short), failing the asynchronous `save()` call, inspecting the resulting errors, correcting the data attributes (`email`, `username`), and then successfully saving the valid record.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = User.build({ username: 'r' })\nawait user.save() // => false\nuser.errors.email = ['must be present']\nuser.errors.username = ['must be at least 2 characters']\nuser.email = 'rob@redwoodjs.com'\nuser.username = 'rob'\nawait user.save()\n```\n\n----------------------------------------\n\nTITLE: Handling and Testing GraphQL Errors in a RedwoodJS Component (JSX)\nDESCRIPTION: This example demonstrates updating the `Article` component to handle potential errors returned by the `useQuery` hook. It destructures `error` from the hook's result and renders an error message if `error` is truthy. The accompanying test code shows how to use `mockGraphQLQuery` with `ctx.errors()` to trigger this error state and then uses `screen.findByText` to assert that the specific error message ('Sorry, there was an error') is correctly displayed in the component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_24\n\nLANGUAGE: jsx\nCODE:\n```\nconst Article = ({ id }) => {\n  const { data, error } = useQuery(GET_ARTICLE, {\n    variables: { id },\n  })\n\n  if (error) {\n    return <div>Sorry, there was an error</div>\n  }\n\n  if (data) {\n    // ...\n  }\n}\n\n// web/src/components/Article/Article.test.js\n\nit('renders an error message', async () => {\n  mockGraphQLQuery('getArticle', (variables, { ctx }) => {\n    ctx.errors([{ message: 'Error' }])\n  })\n\n  render(<Article id={1} />)\n\n  expect(await screen.findByText('Sorry, there was an error')).toBeInTheDocument()\n})\n```\n\n----------------------------------------\n\nTITLE: Limiting Post Service Queries by User with RedwoodJS/Prisma (JavaScript)\nDESCRIPTION: This snippet updates the backend posts service so all data access operations (list, retrieve, create) are scoped to the logged-in user via context.currentUser.id. It utilizes Prisma via db.post and enforces that queries return or manage only those posts owned by the user. Dependencies include RedwoodJS context and Prisma. Inputs typically include standard CRUD parameters (id, input), and outputs are filtered Post models. Note that update and delete are not yet protected against cross-user access.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const posts = () => {\n  // highlight-next-line\n  return db.post.findMany({ where: { userId: context.currentUser.id } })\n}\n\nexport const post = ({ id }) => {\n  // highlight-start\n  return db.post.findFirst({\n    where: { id, userId: context.currentUser.id },\n  })\n  // highlight-end\n}\n\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    data: { ...input, userId: context.currentUser.id },\n  })\n}\n\nexport const updatePost = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost = ({ id }) => {\n  return db.post.delete({\n    where: { id },\n  })\n}\n\nexport const Post = {\n  user: (_obj, { root }) =>\n    db.post.findFirst({ where: { id: root.id } }).user(),\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining RedwoodJS Service Functions with Caching (TypeScript)\nDESCRIPTION: Demonstrates implementing caching in RedwoodJS service functions using `cacheFindMany` for lists and `cache` for single items. The `listProducts` function caches a list of products, while the `product` function caches an individual product based on its ID, both with an expiration time.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_71\n\nLANGUAGE: ts\nCODE:\n```\nexport const listProducts: QueryResolvers['listProducts'] = () => {\n  // highlight-next-line\n  return cacheFindMany('products-list', db.product, {\n    expires: 3600,\n  })\n}\n\nexport const product: QueryResolvers['product'] = async ({ id }) => {\n  // highlight-next-line\n  return cache(\n    `cached-product-${id}`,\n    () =>\n      db.product.findUnique({\n        where: { id },\n      }),\n    { expires: 3600 }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Prisma Schema for PostgreSQL (GraphQL Prisma SDL)\nDESCRIPTION: Updates schema.prisma to set the datasource provider to postgresql and load the database URL from the environment. Required for switching Prisma from SQLite to Postgres. Assumes environment variable DATABASE_URL is defined in the project's .env file. Used by RedwoodJS and Prisma CLI for code generation and migrations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_7\n\nLANGUAGE: graphql\nCODE:\n```\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Type Check to authDecoder in TypeScript\nDESCRIPTION: This snippet enhances the `authDecoder` function by adding a check for the authentication `type`. It ensures that the function only processes tokens associated with the 'custom-auth' type, returning `null` if the type doesn't match, thereby skipping verification for other potential authentication methods.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\nexport const authDecoder = async (token: string, type: string) => {\n  if (type !== 'custom-auth') {\n    return null\n  }\n\n  // decode token...\n}\n```\n\n----------------------------------------\n\nTITLE: Customized RedwoodJS Cell Query and Success State - JavaScript (React JSX)\nDESCRIPTION: This variant refactors the ArticlesCell query to fetch 'posts' instead of 'articles', resolving name misalignment with backend data. The 'Success' component is updated to expect a 'posts' prop and display the corresponding list. Understanding the mapping between backend query names and frontend props is important for correct data flow in RedwoodJS Cells.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\\n  query ArticlesQuery {\\n    // highlight-next-line\\n    posts {\\n      id\\n    }\\n  }\\n`\\n\\nexport const Loading = () => <div>Loading...</div>\\n\\nexport const Empty = () => <div>Empty</div>\\n\\nexport const Failure = ({ error }) => (\\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\\n)\\n\\n// highlight-next-line\\nexport const Success = ({ posts }) => {\\n  return (\\n    <ul>\\n      // highlight-next-line\\n      {posts.map((item) => {\\n        return <li key={item.id}>{JSON.stringify(item)}</li>\\n      })}\\n    </ul>\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Authenticated and Public Routes in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript version mirrors the JavaScript routing logic for RedwoodJS, using <PrivateSet> to wrap admin routes which require authentication, and designating public blog routes outside of <PrivateSet>. Dependencies include typings, @redwoodjs/router, and referenced layout and page components. The unauthenticated parameter in <PrivateSet> manages redirect behavior. This ensures type safety in navigation logic, and the main output is a strongly-typed authenticated router.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\\nimport { PrivateSet, Router, Route, Set } from '@redwoodjs/router'\\n\\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\\nimport BlogLayout from 'src/layouts/BlogLayout'\\n\\nimport { useAuth } from './auth'\\n\\nconst Routes = () => {\\n  return (\\n    <Router useAuth={useAuth}>\\n      // highlight-next-line\\n      <PrivateSet unauthenticated=\"home\">\\n        <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\\n          <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\\n          <Route path=\"/admin/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\\n          <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\\n          <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\\n        </Set>\\n      // highlight-next-line\\n      </PrivateSet>\\n      <Set wrap={BlogLayout}>\\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\\n        <Route path=\"/\" page={HomePage} name=\"home\" />\\n      </Set>\\n      <Route notfound page={NotFoundPage} />\\n    </Router>\\n  )\\n}\\n\\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Accessing Query Data via Data Prop in Success Component (JavaScript/JSX)\nDESCRIPTION: This success component demonstrates the standard way to access query data within a Cell by destructuring the data prop. This version retrieves posts and authors from the passed-in data object. Dependencies include React in a RedwoodJS Cell context; expects a single prop 'data' containing queried results, enabling flexible but possibly verbose data handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Success = ({ data }) => {\n  const { posts, authors } = data\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Cell with Various Naming Conventions - Bash\nDESCRIPTION: These examples demonstrate using the RedwoodJS CLI to generate a cell component with multiple valid naming conventions (snake_case, kebab-case, camelCase, PascalCase). All commands result in the same file output, provided the name separation is clear. Proper naming affects generator output path and file name.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g cell blog_articles\\nyarn rw g cell blog-articles\\nyarn rw g cell blogArticles\\nyarn rw g cell BlogArticles\n```\n\n----------------------------------------\n\nTITLE: Using Article Component in ArticlesCell Success State (TSX)\nDESCRIPTION: Modifies the `Success` component within `ArticlesCell.tsx` to use the reusable `Article` component. It imports `Article` and maps over the `articles` array (provided via `CellSuccessProps` with type `ArticlesQuery`), rendering an `<Article>` component for each post, passing the `article` data and `key` as props.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_30\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { ArticlesQuery, ArticlesQueryVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypedDocumentNode,\n} from '@redwoodjs/web'\n\n// highlight-next-line\nimport Article from 'src/components/Article'\n\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\n  gql`\n    query ArticlesQuery {\n      articles: posts {\n        id\n        title\n        body\n        createdAt\n      }\n    }\n  `\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<ArticlesQueryVariables>) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  articles,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\n  return (\n    <>\n      {articles.map((article) => (\n        // highlight-next-line\n        <Article key={article.id} article={article} />\n      ))}\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Article Component in ArticleCell Success State (JSX)\nDESCRIPTION: Updates the `Success` component within `ArticleCell.jsx` (used for displaying a single article). It imports the `Article` component and renders it, passing the single `article` object fetched by the cell as a prop.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_31\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport Article from 'src/components/Article'\n\nexport const QUERY = gql`\n  query FindArticleQuery($id: Int!) {\n    article: post(id: $id) {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({ article }) => {\n  // highlight-next-line\n  return <Article article={article} />\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding apiDbAuthUrl in redwood.toml - TOML (diff format)\nDESCRIPTION: Demonstrates how to add or edit apiDbAuthUrl in the [web] section of redwood.toml using diff notation. This setting allows dbAuth authentication endpoints to be served from a custom domain or separate host without affecting other API endpoints. Useful in projects needing externalized authentication flows.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n [web]\n   apiUrl = \"/.redwood/functions\"\n+  apiDbAuthUrl = \"https://api.coolredwoodapp.com/auth\"\n```\n\n----------------------------------------\n\nTITLE: Passing Page Parameter via Props to Homepage - RedwoodJS - JavaScript\nDESCRIPTION: Defines the HomePage component to accept a 'page' prop (defaulting to 1), passing it to 'BlogPostsCell', enabling URL query parameter-driven pagination. This leverages RedwoodJS's automatic prop mapping from URL query strings, supporting dynamic data fetching in the child cell. 'BlogLayout' serves as the layout wrapper.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nconst HomePage = ({ page = 1 }) => {\n  return (\n    <BlogLayout>\n      <BlogPostsCell page={page} />\n    </BlogLayout>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Helper Function for Typed Documents in TypeScript\nDESCRIPTION: This snippet from `web/src/graphql/gql.ts` shows part of the generated code for the RedwoodJS web side. The `graphql` function (and its alias `gql`) likely uses the generated TypeScript types associated with GraphQL documents. It ensures that when developers reference a query (like `FindPosts`), they get strong typing and potentially integrates with the underlying mechanism that uses document hashes instead of the full query text.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// ...\nexport function graphql(\n  source: '\\n  query FindPosts {\\n    posts {\\n      id\\n      title\\n      body\\n      authorId\\n      createdAt\\n    }\\n  }\\n'\n): (typeof documents)['\\n  query FindPosts {\\n    posts {\\n      id\\n      title\\n      body\\n      authorId\\n      createdAt\\n    }\\n  }\\n']\n// ...\nexport function gql(source: string) {\n  return graphql(source)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Prisma Client with PgBouncer Connection String\nDESCRIPTION: Demonstrates how to configure a PostgreSQL connection URL for use with Prisma Client and PgBouncer by appending the `?pgbouncer=true` parameter. This is necessary for connection pooling in serverless environments. Note that PgBouncer typically uses port 6543, differing from the standard Postgres port 5432. Migrations should connect directly to the database, bypassing PgBouncer.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/connection-pooling.md#_snippet_0\n\nLANGUAGE: uri\nCODE:\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?pgbouncer=true\n```\n\n----------------------------------------\n\nTITLE: Customizing the Default Error Message in RedwoodJS GraphQL Handler - TypeScript/TSX\nDESCRIPTION: This TSX snippet shows how to set a custom default error message using the defaultError property in createGraphQLHandler. If an unhandled error occurs, the specified string (e.g., 'Sorry about that') is sent in the response instead of the error detail. Other properties initialize logging, directives, and services. The onException callback allows custom handling such as disconnecting from the database. Requires RedwoodJS server libraries and relevant GraphQL handler dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\nexport const handler = createGraphQLHandler({\n  loggerConfig: { logger, options: {} },\n  directives,\n  sdls,\n  services,\n  defaultError: 'Sorry about that', // \\uD83D\\uDC49 Customize the error message\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Building a Validated Comment Form using RedwoodJS Forms - TypeScript (TSX)\nDESCRIPTION: This TSX code defines a CommentForm React component in TypeScript, utilizing RedwoodJS form components for capturing a user's name and comment with required validation. It imports form primitives from @redwoodjs/forms. Both name and comment fields require input; form elements are styled for accessibility and appearance. The component is stateless, 100% width, and must be wired to custom submission logic. All input validations are handled client-side. Inputs: 'name', 'body'; Outputs: None provided by default.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Form, Label, TextField, TextAreaField, Submit } from '@redwoodjs/forms'\n\nconst CommentForm = () => {\n  return (\n    <div>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      <Form className=\"mt-4 w-full\">\n        <Label name=\"name\" className=\"block text-sm text-gray-600 uppercase\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-xs\"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-sm text-gray-600 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-xs\"\n          validation={{ required: true }}\n        />\n\n        <Submit className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\">\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n\n----------------------------------------\n\nTITLE: Using a Registered Fragment in a Query with RedwoodJS/Apollo - TypeScript\nDESCRIPTION: Demonstrates use of the previously registered 'BookInfo' fragment in a GetBookDetails query inside a RedwoodJS component. Defines a typed useQuery call using generated GraphQL types. Also shows component import for rendering book info. Inputs: bookId as query variable. Requires: '@redwoodjs/web', generated types, fragment registration. Returns a 'book' with spread fragment data and 'description'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport type { GetBookDetails } from 'types/graphql'\\n\\nimport { useQuery } from '@redwoodjs/web'\\n\\nimport BookInfo from 'src/components/BookInfo'\\n\\nconst GET_BOOK_DETAILS = gql`\\n  query GetBookDetails($bookId: ID!) {\\n    book(id: $bookId) {\\n      ...BookInfo\\n      description\\n      # Include other fields specific to this query\\n    }\\n  }\\n\\n...\\n\\nconst { data, loading} = useQuery<GetBookDetails>(GET_BOOK_DETAILS)\\n\n```\n\n----------------------------------------\n\nTITLE: Creating Storybook Stories for Article Component (JSX)\nDESCRIPTION: This JavaScript (JSX) snippet sets up Storybook stories for the `Article` component. It defines a constant `ARTICLE` with sample data. It exports two stories: `full`, which renders the component showing the entire article body, and `summary`, which renders the component with the `summary` prop set to true, showing the truncated version.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-story.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/components/Article/Article.stories.jsx\"\nimport Article from './Article'\n\n// highlight-start\nconst ARTICLE = {\n  id: 1,\n  title: 'First Post',\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\n}\n// highlight-end\n\n// highlight-start\nexport const full = () => {\n  return <Article article={ARTICLE} />\n}\n// highlight-end\n\n// highlight-start\nexport const summary = () => {\n  return <Article article={ARTICLE} summary={true} />\n}\n// highlight-end\n\nexport default { title: 'Components/Article' }\n```\n```\n\n----------------------------------------\n\nTITLE: Integrating CommentsCell into Article Component - JavaScript\nDESCRIPTION: This JavaScript React snippet shows how to insert CommentsCell into the main Article component, conditionally rendering it below article content. It demonstrates dependency imports and a helper function for text truncation, displaying comments only when not in summary mode. This code depends on CommentsCell, RedwoodJS router, and expects article and summary props; it outputs a composed blog article display.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n// highlight-next-line\nimport CommentsCell from 'src/components/CommentsCell'\n\nconst truncate = (text, length) => {\n  return text.substring(0, length) + '...'\n}\n\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      // highlight-next-line\n      {!summary && <CommentsCell />}\n    </article>\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Mutation Constant in RedwoodJS Contact Page (TSX)\nDESCRIPTION: This snippet demonstrates defining the `CREATE_CONTACT` GraphQL mutation as a constant within the `ContactPage.tsx` component using TypeScript. It uses the `gql` tag for the mutation definition, specifying an input variable `$input` of type `CreateContactInput!` and returning the `id` on successful creation. The code also includes type definitions for form values (`FormValues`) and uses `SubmitHandler` for the form submission function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\n// highlight-start\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n// highlight-end\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing the Typename of the Registered Fragment - RedwoodJS Apollo - TypeScript/JavaScript\nDESCRIPTION: Imports the 'typename' helper from '@redwoodjs/web/apollo', enabling retrieval of the GraphQL typename for a previously registered fragment. This is primarily useful for forming cache keys or type-discriminated operations. Depends on a registered fragment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport { typename } from '@redwoodjs/web/apollo'\\n\n```\n\n----------------------------------------\n\nTITLE: Importing Redwood GraphQL Context Globally - RedwoodJS - JSX\nDESCRIPTION: Shows how to import the shared Redwood context object from '@redwoodjs/graphql-server' so it becomes available throughout all services. Required for context-aware logic inside server modules.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { context } from '@redwoodjs/graphql-server'\n```\n\n----------------------------------------\n\nTITLE: Using postId Prop in CommentForm Submission (TypeScript)\nDESCRIPTION: This TSX snippet updates the TypeScript `CommentForm` component. It defines a `Props` interface to type the incoming `postId` prop. The `onSubmit` handler is updated to merge the `postId` with the rest of the form input (`...input`) before sending it in the `createComment` mutation variables.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\n```jsx title=\"web/src/components/CommentForm/CommentForm.tsx\"\n// highlight-start\ninterface Props {\n  postId: number\n}\n// highlight-end\n\n// highlight-next-line\nconst CommentForm = ({ postId }: Props) => {\n  const [createComment, { loading, error }] = useMutation(CREATE)\n\n  const onSubmit: SubmitHandler<FormValues> = (input) => {\n    // highlight-next-line\n    createComment({ variables: { input: { postId, ...input } } })\n  }\n\n  return (\n    //...\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Ignoring .env File in .gitignore (Plaintext)\nDESCRIPTION: This snippet shows a portion of a typical Redwood project's `.gitignore` file. It highlights that the `.env` file is explicitly listed (line 2), ensuring that Git ignores it. This is a crucial security practice to prevent sensitive credentials or configuration stored in `.env` from being committed to version control.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/environment-variables.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n```plaintext {2}\n.DS_Store\n.env\n.netlify\ndev.db\ndist\ndist-babel\nnode_modules\nyarn-error.log\n```\n```\n\n----------------------------------------\n\nTITLE: Using Received Query Results in Success Component (JSX)\nDESCRIPTION: This JSX snippet shows how a Success component in a RedwoodJS Cell receives and uses the data results from a multi-root GraphQL query. The destructuring of posts and authors provides clarity and direct access to query results. Used in the Cell lifecycle, it displays or processes the received records as needed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Success = ({ posts, authors }) => {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a Divide Function with Zero Divisor - React/JSX/TypeScript\nDESCRIPTION: This test ensures that dividing by zero is handled gracefully by the 'divide' serverless function. It mocks a request with divisor set to '0', checks that the handler returns a 500 status and includes an error message. Diesel to demonstrate expected error-handling for invalid mathematical operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n  it('cannot divide by 0', async () => {\n    const httpEvent = mockHttpEvent({\n      queryStringParameters: {\n        dividend: '20',\n        divisor: '0',\n      },\n    })\n\n    const result = await handler(httpEvent)\n    const body = result.body\n\n    expect(result.statusCode).toBe(500)\n    expect(body.message).toContain('Could not divide')\n    expect(body.quotient).toBeUndefined\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Using Standard Mock with Spread Syntax in Storybook (TypeScript/TSX)\nDESCRIPTION: Shows how to use the spread operator to inject all mock properties into the Success component for Storybook in TypeScript/TSX. Imports both Success and standard, and returns the appropriately mocked Success component. This is the idiomatic RedwoodJS approach for mocking cell data in stories.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Success } from './ArticlesCell'\\nimport { standard } from './ArticlesCell.mock'\\n\\nexport const success = () => {\\n  // highlight-next-line\\n  return Success ? <Success {...standard()} /> : null\\n}\\n\\nexport default { title: 'Cells/ArticlesCell' }\n```\n\n----------------------------------------\n\nTITLE: Generating Home Page at Root Path (Bash)\nDESCRIPTION: This command uses the RedwoodJS CLI (`yarn redwood generate page`) to generate a new page component named `HomePage` and configures its route to be the application's root path (`/`). This is often used to create the main landing page or dashboard of the application, which the user might be redirected to after login or signup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate page home /\n```\n\n----------------------------------------\n\nTITLE: Receiving and Using Post ID in CommentForm (JSX/TSX)\nDESCRIPTION: This snippet shows how the `CommentForm` component (in both JavaScript and TypeScript) receives the `postId` prop and incorporates it into the variables sent with the `createComment` GraphQL mutation. The `postId` is destructured from the props and added to the `input` object within the `onSubmit` handler using the spread syntax.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/CommentForm/CommentForm.jsx\"\n// highlight-next-line\nconst CommentForm = ({ postId }) => {\n  const [createComment, { loading, error }] = useMutation(CREATE)\n\n  const onSubmit = (input) => {\n    // highlight-next-line\n    createComment({ variables: { input: { postId, ...input } } })\n  }\n\n  return (\n    //...\n  )\n}\n```\n```\n\nLANGUAGE: tsx\nCODE:\n```\n```jsx title=\"web/src/components/CommentForm/CommentForm.tsx\"\n// highlight-start\ninterface Props {\n  postId: number\n}\n// highlight-end\n\n// highlight-next-line\nconst CommentForm = ({ postId }: Props) => {\n  const [createComment, { loading, error }] = useMutation(CREATE)\n\n  const onSubmit: SubmitHandler<FormValues> = (input) => {\n    // highlight-next-line\n    createComment({ variables: { input: { postId, ...input } } })\n  }\n\n  return (\n    //...\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Simulating Auction Bid Traffic - Bash\nDESCRIPTION: Shell script usage explanation for simulating bid submission on auctions. Accepts options to target specific auctions and adjust bid count. Designed for automated, CLI-driven testing of real-time auction features in RedwoodJS. Includes help flags and argument descriptions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/simulate_bids.sh -h\nUsage: ./scripts/simulate_bids.sh [options]\n\nOptions:\n  -a <auctionId>  Specify the auction ID (1-5) for which to send bids (optional).\n  -n <num_bids>   Specify the number of bids to send (optional).\n  -h, --help      Display this help message.\n```\n\n----------------------------------------\n\nTITLE: Testing the Logged-In State using mockCurrentUser in RedwoodJS (JSX)\nDESCRIPTION: This test suite verifies the `HomePage` component's behavior when a user is logged in, using Redwood's `mockCurrentUser` utility. Before rendering the component, `mockCurrentUser` is called with a mock user object ({ name: 'Rob' }). Two separate test cases (`it` blocks) are shown: one uses `waitFor` and `screen.queryByRole` to assert that the login button is *not* present, and the other uses the asynchronous `screen.findByText` to assert that the personalized welcome message ('Welcome back Rob') *is* present. This demonstrates testing conditional rendering based on mocked authentication state, including handling asynchronous updates.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\nimport { render, screen, waitFor } from '@redwoodjs/testing/web'\nimport HomePage from './HomePage'\n\ndescribe('HomePage', () => {\n  it('renders a login button when logged out', () => {\n    render(<HomePage />)\n\n    expect(screen.getByRole('button', { name: 'Login' })).toBeInTheDocument()\n  })\n\n  it('does not render a login button when logged in', async () => {\n    mockCurrentUser({ name: 'Rob' })\n\n    render(<HomePage />)\n\n    await waitFor(() => {\n      expect(\n        screen.queryByRole('button', { name: 'Login' })\n      ).not.toBeInTheDocument()\n    })\n  })\n\n  it('renders a welcome message when logged in', async () => {\n    mockCurrentUser({ name: 'Rob' })\n\n    render(<HomePage />)\n\n    expect(await screen.findByText('Welcome back Rob')).toBeInTheDocument()\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Adding Delete Comment Functionality to TypeScript Service\nDESCRIPTION: This TypeScript snippet adds the `deleteComment` function with type safety. The `id` argument is typed using `Prisma.CommentWhereUniqueInput`. The function uses `db.comment.delete` with the provided `id` in the `where` clause to remove the specified comment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/services/comments/comments.ts\"\nexport const deleteComment = ({ id }: Prisma.CommentWhereUniqueInput) => {\n  return db.comment.delete({\n    where: { id },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Generated Resolver Types in a Redwood Service (TypeScript)\nDESCRIPTION: This code illustrates importing and applying generated resolver types (`QueryResolvers`, `MutationResolvers`) in a RedwoodJS service file (`api/src/services/posts.ts`). Applying types like `QueryResolvers['posts']` to service functions ensures their parameters and return values align with the GraphQL schema defined in SDL files, leveraging Prisma types where names match.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/generated-types.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// highlight-next-line\nimport type { QueryResolvers, MutationResolvers } from 'types/graphql'\n\nimport { db } from 'src/lib/db'\n\n// highlight-next-line\nexport const posts: QueryResolvers['posts'] = () => {\n  return db.post.findMany()\n}\n\n// highlight-next-line\nexport const post: QueryResolvers['post'] = ({ id }) => {\n  return db.post.findUnique({\n    where: { id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Successful Comment Submission with Toast Notification in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript variant of the RedwoodJS comment form features fully typed props, mutation types, and uses onCompleted with toast.success to notify the user. It maintains hasPosted state to conditionally hide the form and is connected to a typed GraphQL mutation. Dependencies involve @redwoodjs/forms, @redwoodjs/web, TypeScript GraphQL types, and @redwoodjs/web/toast. The form captures name and body, appends postId, and on success, notifies and hides the form. For the toast to display, a Toaster component must be rendered elsewhere in the app.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\nimport { useState } from 'react'\n\nimport type {\n  CreateCommentMutation,\n  CreateCommentMutationVariables,\n} from 'types/graphql'\n\nimport {\n  Form,\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\nimport type { TypedDocumentNode } from '@redwoodjs/web'\nimport { useMutation } from '@redwoodjs/web'\n// highlight-next-line\nimport { toast } from '@redwoodjs/web/toast'\n\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n\nconst CREATE: TypedDocumentNode<\n  CreateCommentMutation,\n  CreateCommentMutationVariables\n> = gql`\n  mutation CreateCommentMutation($input: CreateCommentInput!) {\n    createComment(input: $input) {\n      id\n      name\n      body\n      createdAt\n    }\n  }\n`\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\ninterface Props {\n  postId: number\n}\n\nconst CommentForm = ({ postId }: Props) => {\n  // highlight-next-line\n  const [hasPosted, setHasPosted] = useState(false)\n  const [createComment, { loading, error }] = useMutation(CREATE, {\n    // highlight-start\n    onCompleted: () => {\n      setHasPosted(true)\n      toast.success('Thank you for your comment!')\n    },\n    // highlight-end\n    refetchQueries: [{ query: CommentsQuery }],\n  })\n\n  const onSubmit: SubmitHandler<FormValues> = (input) => {\n    createComment({ variables: { input: { postId, ...input } } })\n  }\n\n  return (\n    // highlight-next-line\n    <div className={hasPosted ? 'hidden' : ''}>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      <Form className=\"mt-4 w-full\" onSubmit={onSubmit}>\n        <FormError\n          error={error}\n          titleClassName=\"font-semibold\"\n          wrapperClassName=\"bg-red-100 text-red-900 text-sm p-3 rounded\"\n        />\n        <Label\n          name=\"name\"\n          className=\"block text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-sm \"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-sm\"\n          validation={{ required: true }}\n        />\n\n        <Submit\n          disabled={loading}\n          className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\"\n        >\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n\n----------------------------------------\n\nTITLE: Public GraphQL SDL for Read-Only Post Access (JavaScript)\nDESCRIPTION: This snippet is a GraphQL SDL defining the public-facing post queries for a RedwoodJS app, giving anyone read access to posts and post details via @skipAuth. The Post type includes core fields and a user relation, and no mutations are provided. It is imported by the public-facing services and respects the separation between admin and general access.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nexport const schema = gql`\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n    user: User!\n  }\n\n  type Query {\n    posts: [Post!]! @skipAuth\n    post(id: Int!): Post @skipAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Regenerating RedwoodJS SDLs with Force After Reinstating Relations\nDESCRIPTION: These RedwoodJS CLI commands regenerate the SDLs for `Book` and `Shelf` using the `--force` flag to overwrite existing files and `--no-tests` to preserve existing tests. This step is performed after uncommenting the relation fields in the Prisma schema to update the generated files with the relationship information.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/schema-relations.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g sdl Book --force --no-tests\n# ...\n\nyarn rw g sdl Shelf --force --no-tests\n# ...\n```\n\n----------------------------------------\n\nTITLE: Manually Triggering Type Generation using Redwood CLI (Shell)\nDESCRIPTION: This command manually initiates the RedwoodJS type generation process. While typically run automatically during development (`yarn rw dev`), this command can be used explicitly to generate or update types based on the current project state, particularly after changes to SDL files or GraphQL operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/generated-types.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw g types\n# or\n# yarn redwood generate types\n```\n\n----------------------------------------\n\nTITLE: Verifying All Mock Comments Display in CommentsCell Success Test with RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript test verifies that all comments from the mock data are displayed in the CommentsCell's success state. It renders the Success component with the mock data and ensures each comment's body is present in the DOM, using RedwoodJS's render and screen from @redwoodjs/testing/web. Inputs are dynamically retrieved from the mock. Outputs are confirmed by DOM assertions. This test helps prevent failures due to hard-coded data or comment counts, ensuring the test adapts to future changes in the mock structure. Dependencies remain the same as previous tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// highlight-next-line\nimport { render, screen } from '@redwoodjs/testing/web'\n\nimport { Loading, Empty, Failure, Success } from './CommentsCell'\nimport { standard } from './CommentsCell.mock'\n\ndescribe('CommentsCell', () => {\n  it('renders Loading successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  it('renders Empty successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  it('renders Failure successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  it('renders Success successfully', async () => {\n    // highlight-start\n    const comments = standard().comments\n    render(<Success comments={comments} />)\n\n    comments.forEach((comment) => {\n      expect(screen.getByText(comment.body)).toBeInTheDocument()\n    })\n    // highlight-end\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Case-Insensitive Username Matching for Login in JavaScript\nDESCRIPTION: Sets the username matching behavior for the login process within the dbAuth configuration. Assigning `'insensitive'` to the `usernameMatch` property enables case-insensitive checks when looking up a user during login. Database support and configuration requirements apply.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nlogin: {\n  usernameMatch: 'insensitive'\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Loading and Error States from useMutation in TSX\nDESCRIPTION: This TSX snippet shows how to destructure the `loading` and `error` properties from the result array returned by the RedwoodJS `useMutation` hook, providing type safety using generic type arguments for the mutation and its variables (`CreateContactMutation`, `CreateContactMutationVariables`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\n// ...\n\nconst ContactPage = () => {\n  // highlight-next-line\n  const [create, { loading, error }] = useMutation<\n    CreateContactMutation,\n    CreateContactMutationVariables\n  >(CREATE_CONTACT)\n\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (...)\n}\n\n// ...\n```\n```\n\n----------------------------------------\n\nTITLE: Default and Custom og:type Generation - JSX\nDESCRIPTION: These examples show <Metadata>'s handling of the 'og:type' property: adding a default 'og:type=website' if any 'og' prop exists, and allowing for override by specifying a value in the og object. Inputs are boolean og prop or object with 'type'; outputs are meta tags with the correct property and content.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata og />\n// generates\n<meta property=\"og:type\" content=\"website\" />\n\n```\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata og={{ type: 'music:album' }}/>\n// generates\n<meta property=\"og:type\" content=\"music:album\" />\n\n```\n\n----------------------------------------\n\nTITLE: Refactoring Ownership Verification into a Reusable Function (JavaScript)\nDESCRIPTION: This snippet extracts the ownership verification logic into a reusable asynchronous function `verifyOwnership`. This function takes an `id`, calls `adminPost` to check if the current user owns the post with that `id`, and throws a `ForbiddenError` if not. The `updatePost` function is updated to call `verifyOwnership` before proceeding with the Prisma update.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/adminPosts/adminPosts.js\"\n// highlight-start\nconst verifyOwnership = async ({ id }) => {\n  if (await adminPost({ id })) {\n    return true\n  } else {\n    throw new ForbiddenError(\"You don't have access to this post\")\n  }\n}\n// highlight-end\n\nexport const updatePost = async ({ id, input }) => {\n  // highlight-next-line\n  await verifyOwnership({ id })\n\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Signup Page with Redwood CLI - Bash\nDESCRIPTION: This command uses RedwoodJS's CLI to scaffold a Signup page, creating boilerplate files, including a new route and a component under the specified path. Requires a RubywoodJS project with the CLI installed. No parameters required; it generates the route and page automatically. Outputs filesystem changes with new SignupPage component and an updated routes file.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate page Signup\n```\n\n----------------------------------------\n\nTITLE: Default RedwoodJS Seed Script Structure (JavaScript)\nDESCRIPTION: Shows the default structure of the `scripts/seed.js` file in a RedwoodJS project. It imports the Prisma client instance (`db`) and includes commented-out example code for seeding users using `createMany`. It serves as a starting point for adding custom seed logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/database-seeds.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// title=\"scripts/seed.js\"\nimport { db } from 'api/src/lib/db'\n\nexport default async () => {\n  try {\n    // Create your database records here! For example, seed some users:\n    //\n    // const users = [\n    //   { name: 'Alice', email: 'alice@redwoodjs.com },\n    //   { name: 'Bob', email: 'bob@redwoodjs.com },\n    // ]\n    //\n    // await db.user.createMany({ data: users })\n\n    console.info(\n      '\\n  No seed data, skipping. See scripts/seed.ts to start seeding your database!\\n'\n    )\n  } catch (error) {\n    console.error(error)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Directive Interactively via CLI\nDESCRIPTION: This example demonstrates using the RedwoodJS CLI (`yarn rw g` is shorthand for `yarn redwood generate`) to generate a directive named 'myDirective'. Since the `--type` option is omitted, the CLI interactively prompts the user to choose between creating a 'Validator' or 'Transformer' directive.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g directive myDirective\n\n? What type of directive would you like to generate? › - Use arrow-keys. Return to submit.\n❯ Validator - Implement a validation: throw an error if criteria not met to stop execution\nTransformer - Modify values of fields or query responses\n```\n\n----------------------------------------\n\nTITLE: Invoking renderHook for Custom Hook Testing in RedwoodJS (JS)\nDESCRIPTION: This JavaScript snippet shows the basic usage of the `renderHook` function from `@redwoodjs/testing/web` to test a custom React hook (`useAccumulator`). It calls the hook within an inline function passed to `renderHook` and destructures the returned `result` object, which contains the hook's return value in `result.current`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_32\n\nLANGUAGE: js\nCODE:\n```\n```js\nconst { result } = renderHook(() => useAccumulator(0))\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Prerendered Dynamic Routes with Parameter Hooks in RedwoodJS (JavaScript/JSX)\nDESCRIPTION: Shows how to set up a dynamic route for prerendering by adding 'prerender' and using a parameterized path. Used when routing with dynamic segments (e.g., blog post IDs). This snippet requires further configuration via a routeHooks file to define which dynamic values to prerender at build time.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/blog-post/{id}\" page={BlogPostPage} name=\"blogPost\" prerender />\n```\n\n----------------------------------------\n\nTITLE: Importing Nested Components with and without Path Aliases - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the use of both verbose and concise import paths for a deeply nested CustomModal component in a RedwoodJS project. Alias configuration, as illustrated previously, allows developers to replace long relative or absolute paths with meaningful aliases, streamlining code organization and imports.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/introduction.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Instead of this 🥵\nimport { CustomModal } from 'src/components/modules/admin/common/ui/CustomModal/CustomModal'\n\n// they could look like this ✨\nimport { CustomModal } from '@adminUI/CustomModal'\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS API Server Only\nDESCRIPTION: This shell command starts only the API server component of a RedwoodJS application. This approach is used when a separate, dedicated web server like Nginx is configured to handle serving the static web-side files and proxying API requests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_36\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw serve api\n```\n\n----------------------------------------\n\nTITLE: Creating a New Redwood Project - Bash\nDESCRIPTION: Provides the command syntax to create a new Redwood project, specifying the target directory and optional configuration flags. Dependencies: Yarn, npx, redwood CLI. Parameters: <project directory>, [option] (many flags for customization). Input: Command invocation. Output: New project scaffold in specified directory. Limitation: Directory must be accessible/writable.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nyarn create redwood-app <project directory> [option]\n```\n\n----------------------------------------\n\nTITLE: Conditional Cached Query with Expiry using cacheFindMany() - JavaScript\nDESCRIPTION: Examines passing both conditions (to filter, e.g., admin users) and an explicit expiry (in seconds) to `cacheFindMany()`, providing highly granular cache control over a set of records and auto-invalidation based on updates.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_74\n\nLANGUAGE: js\nCODE:\n```\nconst post = ({ id }) => {\\n  return cacheFindMany(`users`, db.user, {\\n    conditions: { where: { roles: 'admin' } },\\n    expires: 86400,\\n  })\\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Margin Above CommentsCell in Article - TypeScript (TSX)\nDESCRIPTION: Updates the Article component in TypeScript to add vertical spacing above the CommentsCell using a div with 'mt-12'. Maintains all type safety and interface usage, improving the visual layout between article content and comments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nconst Article = ({ article, summary = false }: Props) => {\\n  return (\\n    <article>\\n      <header>\\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\\n        </h2>\\n      </header>\\n      <div className=\"mt-2 text-gray-900 font-light\">\\n        {summary ? truncate(article.body, 100) : article.body}\\n      </div>\\n      // highlight-start\\n      {!summary && (\\n        <div className=\"mt-12\">\\n          <CommentsCell />\\n        </div>\\n      )}\\n      // highlight-end\\n    </article>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Adding User Field to Post GraphQL SDL (JS)\nDESCRIPTION: Updates the JavaScript GraphQL SDL file (`posts.sdl.js`) by adding a `user` field of type `User!` to the `Post` type definition. The `User!` type signifies that every post must have an associated user (non-nullable). This change enables querying the related user object when fetching posts via the GraphQL API.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n    // highlight-next-line\n    user: User!\n  }\n```\n\n----------------------------------------\n\nTITLE: Passing postId Prop to CommentForm in Article (JavaScript)\nDESCRIPTION: This JSX snippet updates the `Article` component to pass the `article.id` as a `postId` prop to the `CommentForm`. This is necessary because the GraphQL mutation for creating a comment requires the `postId` to associate the comment with the correct post.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Article/Article.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\nimport CommentsCell from 'src/components/CommentsCell'\nimport CommentForm from 'src/components/CommentForm'\n\nconst truncate = (text, length) => {\n  return text.substring(0, length) + '...'\n}\n\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      {!summary && (\n        <div className=\"mt-12\">\n          // highlight-next-line\n          <CommentForm postId={article.id} />\n          <div className=\"mt-12\">\n            <CommentsCell />\n          </div>\n        </div>\n      )}\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring JobManager and Scheduler for Jobs - JavaScript\nDESCRIPTION: This JavaScript file configures the JobManager (for job handling) and a scheduler (for enqueuing jobs) using '@redwoodjs/jobs' and PrismaAdapter. It connects the JobManager to the database and logger and defines worker options such as retry attempts and concurrency. It exports the jobs instance and a 'later' scheduler. Requires '@redwoodjs/jobs', PrismaAdapter, and the app's database and logger. Used as the central reference for job-related operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { PrismaAdapter, JobManager } from '@redwoodjs/jobs'\n\nimport { db } from 'src/lib/db'\nimport { logger } from 'src/lib/logger'\n\nexport const jobs = new JobManager({\n  adapters: {\n    prisma: new PrismaAdapter({ db, logger }),\n  },\n  queues: ['default'],\n  logger,\n  workers: [\n    {\n      adapter: 'prisma',\n      logger,\n      queue: '*',\n      count: 1,\n      maxAttempts: 24,\n      maxRuntime: 14_400,\n      deleteFailedJobs: false,\n      sleepDelay: 5,\n    },\n  ],\n})\n\nexport const later = jobs.createScheduler({\n  adapter: 'prisma',\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Logflare Logging Stream in RedwoodJS (JavaScript)\nDESCRIPTION: Shows how to configure and use the pino-logflare stream as the logging destination in RedwoodJS. Requires the pino-logflare package and valid API key and source token set in environment variables. The logger is initialized by specifying the custom destination stream, enabling log export to Logflare. This code goes in 'api/src/lib/logger.ts'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createWriteStream } from 'pino-logflare'\n\n/**\n * Creates a pino-logflare stream\n *\n * @param {object} options - Logflare options including\n * your account's API Key and source token id\n *\n * @typedef {DestinationStream}\n */\nexport const stream = createWriteStream({\n  apiKey: process.env.LOGFLARE_API_KEY,\n  sourceToken: process.env.LOGFLARE_SOURCE_TOKEN,\n})\n\nexport const logger = createLogger({\n  options: {},\n  destination: stream,\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Navigation to HomePage Component (TypeScript/JSX)\nDESCRIPTION: This snippet shows the HomePage functional component in TypeScript (`.tsx`). It imports `Link` and `routes` from `@redwoodjs/router`. A header containing the blog title and a navigation list is added. The navigation includes a `<Link>` component that uses the named route function `routes.about()` to link to the About page. The `Metadata` component is used for setting page title and description. This version is functionally identical to the JavaScript example but resides in a `.tsx` file.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/second-page.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\n\nconst HomePage = () => {\n  return (\n    <>\n      <Metadata title=\"Home\" description=\"Home page\" />\n\n      // highlight-start\n      <header>\n        <h1>Redwood Blog</h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>Home</main>\n      // highlight-end\n    </>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Applying a RedwoodJS Layout to Routes using Set (TypeScript/TSX)\nDESCRIPTION: Demonstrates configuring routes in `web/src/Routes.tsx` (TypeScript version) to use the `BlogLayout`. It imports the `Set` component and the `BlogLayout`, then uses `<Set wrap={BlogLayout}>` to enclose the routes (`/about`, `/`) that should share this common layout structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-start\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport BlogLayout from 'src/layouts/BlogLayout'\n// highlight-end\n\nconst Routes = () => {\n  return (\n    <Router>\n      // highlight-start\n      <Set wrap={BlogLayout}>\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      // highlight-end\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Customizing Health Check ID in GraphQL Handler - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to customize the x-yoga-id header sent by the RedwoodJS GraphQL handler during health and readiness checks. It sets the healthCheckId property when instantiating createGraphQLHandler and includes standard configuration fields for server context, logging, and directives. Requires setup of related imports and dependencies in api/src/functions/graphql.ts, with the input being the handler's configuration and output a server instance with a custom health check identifier. There are no constraints beyond those of standard RedwoodJS apps.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_20\n\nLANGUAGE: ts\nCODE:\n```\nexport const handler = createGraphQLHandler({\n  // This will be the value of the `x-yoga-id` header\n  // highlight-next-line\n  healthCheckId: 'my-redwood-graphql-server',\n  getCurrentUser,\n  loggerConfig: { logger, options: {} },\n  directives,\n  sdls,\n  services,\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Customizing Dev Server Debug Port in redwood.toml\nDESCRIPTION: This TOML snippet demonstrates how to modify the `redwood.toml` file to customize the behavior of the `yarn rw dev` command. It shows changing the default API debugger port using `debugPort` and enabling/disabling automatic browser opening with the `open` setting under the `[browser]` section.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/project-configuration-dev-test-build.mdx#_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n  # .\n[api]\n  # .\n  // highlight-next-line\n  debugPort = 18911 # change me!\n[browser]\n  // highlight-next-line\n  open = true # change me!\n```\n\n----------------------------------------\n\nTITLE: Formatting Dates and Styling the Comment Component - RedwoodJS JavaScript\nDESCRIPTION: This snippet adds a date formatting utility and applies Tailwind CSS-based styles to the Comment component. The formattedDate function transforms an ISO datetime string into a 'D Month YYYY' format, improving readability. The component\\'s main wrapper and children receive classes for background, padding, rounded corners, and typography, ensuring design consistency. No external dependencies are required beyond React and Tailwind CSS.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/the-redwood-way.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// highlight-start\nconst formattedDate = (datetime) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n// highlight-end\n\nconst Comment = ({ comment }) => {\n  return (\n    // highlight-start\n    <div className=\"bg-gray-200 p-8 rounded-lg\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n    </div>\n    // highlight-end\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Installing RedwoodJS Jobs and Migrating Prisma Schema - Bash\nDESCRIPTION: These shell commands initialize jobs support in RedwoodJS and generate the necessary database schema migration using Prisma. The setup creates a jobs config file; the migration applies the Prisma schema changes. Run the commands sequentially. Necessary only once during initial setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup jobs\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Passing ID Prop to ArticleCell in ArticlePage (TypeScript)\nDESCRIPTION: Updates the `ArticlePage` component (TypeScript version) to accept the `id` prop, defining its type as `number` via an interface (`Props`). This `id`, provided by the RedwoodJS router, is passed as a prop to the `ArticleCell` to be used in its data fetching query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\nimport ArticleCell from 'src/components/ArticleCell'\n\n// highlight-start\ninterface Props {\n  id: number\n}\n// highlight-end\n\n// highlight-next-line\nconst ArticlePage = ({ id }: Props) => {\n  return (\n    <>\n      <Metadata title=\"Article\" description=\"Article page\" />\n\n      // highlight-next-line\n      <ArticleCell id={id} />\n    </>\n  )\n}\n\nexport default ArticlePage\n```\n\n----------------------------------------\n\nTITLE: GraphQL Error Message for Missing Argument\nDESCRIPTION: Shows a text error message from the server console. This error indicates that a GraphQL query for the 'comments' field failed because the required 'postId' argument (defined as 'Int!') was not provided in the request.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_29\n\nLANGUAGE: text\nCODE:\n```\n```text\nField \"comments\" argument \"postId\" of type \"Int!\" is required, but it was not provided.\n```\n```\n\n----------------------------------------\n\nTITLE: Integrating Navigation into Global Layout (RedwoodJS, JavaScript)\nDESCRIPTION: This snippet sets up the GlobalLayout component, importing the Navigation component and embedding it within a header. The children prop allows for page-specific content, ensuring all main pages inherit navigation and consistent layout structure. Intended to be used as a wrapper around page components in the RedwoodJS app.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\nimport Navigation from 'src/components/Navigation/Navigation'\n\nconst GlobalLayout = ({ children }) => {\n  return (\n    <>\n      <header>\n        <Navigation />\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default GlobalLayout\n```\n\n----------------------------------------\n\nTITLE: Protecting a RedwoodJS Service with requireAuth (JavaScript)\nDESCRIPTION: This example shows how to protect a RedwoodJS service function (`createPost`). It calls `requireAuth` at the beginning, specifying the roles ('admin', 'author', 'publisher') required to execute the database creation logic. If the check fails, an error is thrown, preventing the operation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\\nimport { requireAuth } from 'src/lib/auth'\\n\\nconst CREATE_POST_ROLES = ['admin', 'author', 'publisher']\\n\\nexport const createPost = ({ input }) => {\\n  requireAuth({ role: CREATE_POST_ROLES })\\n\\n  return db.post.create({\\n    data: {\\n      ...input,\\n      authorId: context.currentUser.sub,\\n      publisherId: context.currentUser.sub,\\n    },\\n  })\\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Current User Information in RedwoodJS Component (TSX)\nDESCRIPTION: Retrieves the current authenticated user's information, typically set by the API side authentication, using the `currentUser` property from the RedwoodJS `useAuth` hook. The example shows how to display this information.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nconst { currentUser } = useAuth()\n\n<p>{JSON.stringify({ currentUser })}</p>\n```\n\n----------------------------------------\n\nTITLE: Starting the Docusaurus Development Server\nDESCRIPTION: This command, `yarn start`, executed within the Docusaurus project directory (`docs`), builds the site and starts the Docusaurus development server. This allows viewing the generated GraphQL documentation and the rest of the Docusaurus site locally in a web browser.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_93\n\nLANGUAGE: terminal\nCODE:\n```\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Integrating useAuth Hook for Authentication Client (JSX)\nDESCRIPTION: This snippet updates the `SignupPage` component to integrate with the RedwoodJS authentication system. It imports the `useAuth` hook from `src/auth` (the conventional location for RedwoodJS auth setup) and calls it within the component to destructure the `client` object. This `client` object provides access to the underlying authentication provider's functions (e.g., Supabase GoTrue-JS).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from 'src/auth'\n\nconst SignupPage = () => {\n  const { client } = useAuth()\n  const onSubmit = (data) => {\n    // do something here\n  }\n\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form onSubmit={onSubmit}>\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Adding Sentry Envelop Plugin to Redwood GraphQL Handler - JavaScript\nDESCRIPTION: Demonstrates how to add the @envelop/sentry plugin to the RedwoodJS GraphQL handler for API error and performance monitoring in a JavaScript project. Requires dependencies: @envelop/sentry, @redwoodjs/graphql-server, and the application's sentry library (src/lib/sentry). Important parameters include 'directives', 'sdls', 'services', and 'extraPlugins' for correct GraphQL handler context. Input consists of existing Redwood GraphQL server setup, output is a handler function with integrated Sentry monitoring. This snippet must be placed in the 'api/src/functions/graphql.js' file, and the plugin is included via 'extraPlugins: [useSentry()]'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/monitoring/sentry.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useSentry } from '@envelop/sentry'\n\nimport { createGraphQLHandler } from '@redwoodjs/graphql-server'\n\nimport directives from 'src/directives/**/*.{js,ts}'\nimport sdls from 'src/graphql/**/*.sdl.{js,ts}'\nimport services from 'src/services/**/*.{js,ts}'\n\nimport 'src/lib/sentry'\n\n...\n\nexport const handler = createGraphQLHandler({\n  directives,\n  sdls,\n  services,\n  extraPlugins: [useSentry()],\n  ...\n})\n```\n\n----------------------------------------\n\nTITLE: Running Supabase Auth Setup Command in RedwoodJS (Bash)\nDESCRIPTION: Executes the RedwoodJS CLI command to install necessary packages, scaffold files, and configure the project for Supabase authentication.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup auth supabase\n```\n\n----------------------------------------\n\nTITLE: Building RedwoodJS for Netlify Deployment\nDESCRIPTION: This command prepares a RedwoodJS application for deployment on Netlify. It typically involves building the project, applying database migrations (Prisma), and migrating data. Requires `yarn` and RedwoodJS CLI. Options control build, Prisma migrations, and data migrations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood deploy netlify\n```\n\n----------------------------------------\n\nTITLE: Defining Mock Comments Data for CommentsCell in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript snippet exports a function returning standardized comments mock data for CommentsCell tests. Each comment object includes required fields to match the GraphQL query, ensuring the unit tests receive all necessary attributes, such as postId. It serves as the test data source for CommentsCell and expects consumers to destructure the comments object as needed. Only basic comment parameters are provided, and post objects are omitted.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = () => ({\\n  comments: [\\n    {\\n      id: 1,\\n      name: 'Rob Cameron',\\n      body: 'First comment',\\n      // highlight-next-line\\n      postId: 1,\\n      createdAt: '2020-01-02T12:34:56Z',\\n    },\\n    {\\n      id: 2,\\n      name: 'David Price',\\n      body: 'Second comment',\\n      // highlight-next-line\\n      postId: 2,\\n      createdAt: '2020-02-03T23:00:00Z',\\n    },\\n  ],\\n})\n```\n\n----------------------------------------\n\nTITLE: Testing RedwoodJS Components with Jest and React Testing Library (JSX)\nDESCRIPTION: This code defines an Article component and a corresponding (idealized, but brittle) Jest test. It demonstrates import of RedwoodJS’s test helpers and basic usage of expect(...).toEqual on the render output. Prerequisites: RedwoodJS, @redwoodjs/testing/web, and the React component under test. Inputs are the Article component’s props; the expected output is a string of rendered HTML, but such direct string matching is discouraged as the output shape can easily change.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nconst Article = ({ article }) => {\\n  return <article>{ article.title }</article>\\n}\\n\\n// web/src/components/Article/Article.test.js\\n\\nimport { render } from '@redwoodjs/testing/web'\\nimport Article from 'src/components/Article'\\n\\ndescribe('Article', () => {\\n  it('renders an article', () => {\\n    expect(render(<Article article={ title: 'Foobar' } />))\\n      .toEqual('<article>Foobar</article>')\\n  })\\n})\n```\n\n----------------------------------------\n\nTITLE: Granting Public Access to Single and Multiple Post Queries in RedwoodJS (JavaScript)\nDESCRIPTION: This JavaScript GraphQL schema snippet enables public (unauthenticated) access to both 'posts' and single 'post' queries using the @skipAuth directive. All mutations continue to require authentication via @requireAuth. This approach is useful for exposing post data to public-facing pages while keeping data modification protected. Place this in the RedwoodJS API codebase, ensuring any sensitive logic is handled on the backend.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_9\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\\n  type Post {\\n    id: Int!\\n    title: String!\\n    body: String!\\n    createdAt: DateTime!\\n  }\\n\\n  type Query {\\n    posts: [Post!]! @skipAuth\\n    // highlight-next-line\\n    post(id: Int!): Post @skipAuth\\n  }\\n\\n  input CreatePostInput {\\n    title: String!\\n    body: String!\\n  }\\n\\n  input UpdatePostInput {\\n    title: String\\n    body: String\\n  }\\n\\n  type Mutation {\\n    createPost(input: CreatePostInput!): Post! @requireAuth\\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\\n    deletePost(id: Int!): Post! @requireAuth\\n  }\\n`\n```\n\n----------------------------------------\n\nTITLE: Adding Loading and Error State to Contact Form - RedwoodJS - JavaScript\nDESCRIPTION: This JavaScript code demonstrates how to enhance the contact form by destructuring loading and error from the useMutation hook in order to track the mutation status. With loading true, it is possible to prevent multiple submits or indicate in-progress status. The dependencies remain RedwoodJS web and forms, and the mutation defined elsewhere. This changes the setup to allow for UI state awareness and further error or loading feedback.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n// ...\n\nconst ContactPage = () => {\n  // highlight-next-line\n  const [create, { loading, error }] = useMutation(CREATE_CONTACT)\n\n  const onSubmit = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (...)\n}\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Accessing Query Variables in mockGraphQLQuery Callback (JavaScript/JSX)\nDESCRIPTION: This snippet demonstrates how to access the variables passed to the original `useQuery` hook within the callback function provided to `mockGraphQLQuery`. The `variables` object (the first argument to the callback) contains the parameters sent with the query (e.g., `{ id: 1 }`). This allows the mock response to be dynamic based on the query input, as shown by returning an article object whose `id` matches `variables.id`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_22\n\nLANGUAGE: jsx\nCODE:\n```\nreturn {\n  article: {\n    id: variables.id,\n    title: 'Foobar',\n    body: 'Lorem ipsum...',\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Article Component with CommentsCell and CommentForm - React (JavaScript)\nDESCRIPTION: This snippet demonstrates how the Article component in a RedwoodJS application receives an article object, renders its data, and conditionally includes both CommentForm and CommentsCell components with the current article's postId. Dependencies include React, RedwoodJS routing, and helper utilities like truncate. Inputs include an 'article' object and 'summary' flag; outputs are the rendered JSX tree. Ensures each Article knows which comments to display and attach by passing postId as prop.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_38\n\nLANGUAGE: JSX\nCODE:\n```\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      {!summary && (\n        <div className=\"mt-12\">\n          <CommentForm postId={article.id} />\n          <div className=\"mt-12\">\n            // highlight-next-line\n            <CommentsCell postId={article.id} />\n          </div>\n        </div>\n      )}\n    </article>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Access Control for Posts (JavaScript)\nDESCRIPTION: This GraphQL schema defines types and query/mutation permissions for posts in RedwoodJS using JavaScript, highlighting the use of @skipAuth on the 'posts' query to allow unauthenticated users to retrieve all posts. The 'post' query and all mutations remain protected with @requireAuth. Dependencies include Redwood's gql helper and the GraphQL API server. Inputs are GraphQL queries/mutations, and outputs are post objects with strict authentication directives. The code must be processed by a RedwoodJS backend.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_7\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\\n  type Post {\\n    id: Int!\\n    title: String!\\n    body: String!\\n    createdAt: DateTime!\\n  }\\n\\n  type Query {\\n    // highlight-next-line\\n    posts: [Post!]! @skipAuth\\n    post(id: Int!): Post @requireAuth\\n  }\\n\\n  input CreatePostInput {\\n    title: String!\\n    body: String!\\n  }\\n\\n  input UpdatePostInput {\\n    title: String\\n    body: String\\n  }\\n\\n  type Mutation {\\n    createPost(input: CreatePostInput!): Post! @requireAuth\\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\\n    deletePost(id: Int!): Post! @requireAuth\\n  }\\n`\n```\n\n----------------------------------------\n\nTITLE: Modifying ArticlesCell Query and Success Prop (JavaScript/JSX)\nDESCRIPTION: This code modifies the generated `ArticlesCell.jsx` to fetch data from the `posts` query field instead of the default `articles`. The GraphQL query inside `QUERY` is updated to request `posts { id }`. Consequently, the prop destructured in the `Success` component is changed from `articles` to `posts`, and the mapping logic is updated to iterate over the `posts` array.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticlesCell/ArticlesCell.jsx\"\nexport const QUERY = gql`\n  query ArticlesQuery {\n    // highlight-next-line\n    posts {\n      id\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\n// highlight-next-line\nexport const Success = ({ posts }) => {\n  return (\n    <ul>\n      // highlight-next-line\n      {posts.map((item) => {\n        return <li key={item.id}>{JSON.stringify(item)}</li>\n      })}\n    </ul>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Hiding Sensitive Fields in User GraphQL SDL (JS)\nDESCRIPTION: Modifies the JavaScript GraphQL SDL file (`users.sdl.js`) for the `User` type. It comments out sensitive fields like `hashedPassword`, `salt`, `resetToken`, and `resetTokenExpiresAt` to ensure they are not queryable through the GraphQL API, enhancing security.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n  type User {\n    ...\n    # hashedPassword: String!\n    # salt: String!\n    # resetToken: String\n    # resetTokenExpiresAt: DateTime\n  }\n```\n\n----------------------------------------\n\nTITLE: Dynamically Setting Metadata in a RedwoodJS Cell using JSX\nDESCRIPTION: Demonstrates how to use the `<Metadata>` component within the `Success` component of a RedwoodJS Cell. It dynamically sets the page title, author meta tag, and description meta tag using data (`post.title`, `post.author.name`, `post.snippet`) fetched via the associated GraphQL query (`FindPostById`). This allows metadata to be updated based on the specific content being displayed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n\nimport Post from 'src/components/Post/Post'\n\nexport const QUERY = gql`\n  query FindPostById($id: Int!) {\n    post: post(id: $id) {\n      title\n      snippet\n      author {\n        name\n      }\n    }\n  }\n`\n\nexport const Loading = /* ... */\n\nexport const Empty = /* ... */\n\nexport const Success = ({ post }) => {\n  return (\n    <>\n      <Metadata\n        title={post.title}\n        author={post.author.name}\n        description={post.snippet}\n      />\n      <Post post={post} />\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema with Role-Based Auth for deleteComment - RedwoodJS - JavaScript\nDESCRIPTION: This code defines the GraphQL schema for the comments API in a RedwoodJS project. It demonstrates how to use the @requireAuth directive with a roles argument to restrict the deleteComment mutation to users in the moderator role, while createComment remains open to unauthenticated users via @skipAuth. The schema includes Comment types, Query and Mutation definitions, and input types for creating and updating comments. Requires RedwoodJS, GraphQL and authentication setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_28\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql\\`\n  type Comment {\n    id: Int!\n    name: String!\n    body: String!\n    post: Post!\n    postId: Int!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    comments(postId: Int!): [Comment!]! @skipAuth\n  }\n\n  input CreateCommentInput {\n    name: String!\n    body: String!\n    postId: Int!\n  }\n\n  input UpdateCommentInput {\n    name: String\n    body: String\n    postId: Int\n  }\n\n  type Mutation {\n    createComment(input: CreateCommentInput!): Comment! @skipAuth\n    // highlight-next-line\n    deleteComment(id: Int!): Comment! @requireAuth(roles: \"moderator\")\n  }\n\\`\n```\n\n----------------------------------------\n\nTITLE: Adding the Toaster Component for Global Toast Notifications in RedwoodJS (JavaScript)\nDESCRIPTION: This snippet shows how to add the Toaster component from react-hot-toast in the RedwoodJS BlogLayout for global access to toast notifications across the entire app. By placing <Toaster /> at the layout root, all toast messages (including those from comment submissions) will be displayed regardless of which component triggers them. Dependencies are @redwoodjs/web/toast and @redwoodjs/router. Recommended usage is to include Toaster in the top-level layout so notifications are visible application-wide.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n// highlight-next-line\nimport { Toaster } from '@redwoodjs/web/toast'\n\nimport { useAuth } from 'src/auth'\n\nconst BlogLayout = ({ children }) => {\n  const { logOut, isAuthenticated, currentUser } = useAuth()\n\n  return (\n    <>\n      // highlight-next-line\n      <Toaster />\n      <header className=\"relative flex justify-between items-center py-4 px-8 bg-blue-700 text-white\">\n        <h1 className=\"text-5xl font-semibold tracking-tight\">\n          <Link\n            className=\"text-blue-400 hover:text-blue-100 transition duration-100\"\n            to={routes.home()}\n          >\n            Redwood Blog\n          </Link>\n        </h1>\n        <nav>\n          <ul className=\"relative flex items-center font-light\">\n            <li>\n              <Link\n```\n\n----------------------------------------\n\nTITLE: Adding Navigation to AboutPage Component (JavaScript/JSX)\nDESCRIPTION: This snippet updates the AboutPage functional component in JavaScript (`.jsx`). It adds the same header structure as the HomePage for consistency and includes a paragraph of content. Crucially, it adds a `<Link>` component that uses the named route function `routes.home()` to provide navigation back to the Home page. It also retains the link to the About page itself within the header navigation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/second-page.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <>\n      <Metadata title=\"About\" description=\"About page\" />\n\n      // highlight-start\n      <header>\n        <h1>Redwood Blog</h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>\n        <p>\n          This site was created to demonstrate my mastery of Redwood: Look on my\n          works, ye mighty, and despair!\n        </p>\n        <Link to={routes.home()}>Return home</Link>\n      </main>\n      // highlight-end\n    </>\n  )\n}\n\nexport default AboutPage\n```\n\n----------------------------------------\n\nTITLE: Manually Initializing a Git Repository for a Redwood App in Terminal\nDESCRIPTION: Provides the sequence of shell commands to manually initialize a Git repository within the newly created Redwood app directory (`<your-app-name>`). It changes into the project directory, initializes Git, stages all files using `git add .`, and creates an initial commit with the message \"Initial commit\". This is useful if Git initialization was skipped during the `create-redwood-app` process.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/create-redwood-app.md#_snippet_3\n\nLANGUAGE: terminal\nCODE:\n```\ncd <your-app-name>\ngit init\ngit add .\ngit commit -m \"Initial commit\"\n```\n\n----------------------------------------\n\nTITLE: Copying Core Configuration Files for Build and Production - Dockerfile\nDESCRIPTION: This snippet copies Redwood's config (redwood.toml), GraphQL config (graphql.config.js), and shared environment defaults (.env.defaults) into the container with correct ownerships. These are required for both the build and runtime stages; they should not contain production secrets. The operation assumes these files exist in the project root directory and are structured according to Redwood conventions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_6\n\nLANGUAGE: Dockerfile\nCODE:\n```\nCOPY --chown=node:node redwood.toml .\nCOPY --chown=node:node graphql.config.js .\nCOPY --chown=node:node .env.defaults .env.defaults\n```\n\n----------------------------------------\n\nTITLE: Defining Custom CurrentUser Type in auth.ts (TypeScript)\nDESCRIPTION: This snippet defines a TypeScript interface `MyCurrentUser` and specifies it as the return type for the `getCurrentUser` function within `api/src/lib/auth.ts`. RedwoodJS infers this type and applies it globally to `useAuth().currentUser` on the web side and `context.currentUser` on the API side, ensuring consistent user object typing throughout the application.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/generated-types.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MyCurrentUser {\n  id: string\n  roles: string[]\n  email: string\n  projectId: number\n}\n\nconst getCurrentUser = ({ decoded }): MyCurrentUser => {\n  //..\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Redwood Auth Setup Options (Shell)\nDESCRIPTION: This command lists available authentication setup options in Redwood, supporting database-backed and third-party providers. Intended to help developers add authentication to their applications. Requires a setup Redwood project. Outputs various auth installation instructions and provider options.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup auth --help\n```\n\n----------------------------------------\n\nTITLE: Passing Additional Props to RedwoodJS Cell (TypeScript)\nDESCRIPTION: Illustrates passing an extra prop (`rand`) along with the required `id` prop to `ArticleCell` in TypeScript. RedwoodJS differentiates between props needed for the query (`id`) and other props (`rand`), making all of them available in the Cell's rendering components.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\n<ArticleCell id={id} rand={Math.random()} />\n```\n\n----------------------------------------\n\nTITLE: Setting Up Deployment Configuration with Redwood CLI (Bash)\nDESCRIPTION: Executes the RedwoodJS `setup deploy` command using Yarn to generate deployment configuration files for a specific hosting provider. Replace `<provider>` with the target deployment platform (e.g., `netlify`, `render`, `vercel`, `aws-serverless`). Options like `--database, -d` (for Render, choices: \"none\", \"postgresql\", \"sqlite\") and `--force, -f` (to overwrite existing configuration) are available.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_113\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup deploy <provider>\n```\n\n----------------------------------------\n\nTITLE: Using RedwoodJS Label Component with Error Styling (TSX)\nDESCRIPTION: This TSX snippet illustrates using the RedwoodJS `<Label>` component within a typed form. It imports `Label` from `@redwoodjs/forms` and uses its `name` prop for field association and `errorClassName=\"error\"` to conditionally style the label text when the corresponding input field fails validation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_28\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  // highlight-next-line\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-start\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        // highlight-start\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"email\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        {/* ... rest of the form ... */}\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Environment Variable Inclusion - TOML\nDESCRIPTION: Updates the 'redwood.toml' configuration to include 'NHOST_BACKEND_URL' in the list of environment variables available to the web side of the application. This step is necessary to ensure the Nhost backend URL is accessible from browser-executed code. Add or adjust this snippet under the '[web]' block for a functional Nhost client integration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n  # ...\n  includeEnvironmentVariables = [\"NHOST_BACKEND_URL\"]\n```\n\n----------------------------------------\n\nTITLE: Starting a RedwoodJS Project with TypeScript - Shell\nDESCRIPTION: This shell command initializes a new RedwoodJS project with full TypeScript support by specifying the --typescript flag with the yarn create redwood-app command. It does not require any additional dependencies other than Node.js and Yarn. Replace 'my-redwood-app' with a desired project name; the command scaffolds the application using TypeScript from the outset.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/introduction.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn create redwood-app my-redwood-app --typescript\n```\n\n----------------------------------------\n\nTITLE: Creating an Email Sending Function with Nodemailer and SendInBlue (TypeScript)\nDESCRIPTION: Defines an asynchronous function `sendEmail` in `email.ts` using `nodemailer` to send emails via SendInBlue's SMTP relay. It configures the transporter with SendInBlue credentials (host, port, auth using the `SEND_IN_BLUE_KEY` environment variable) and sends an email with specified recipient(s), subject, text, and HTML content. Requires the `nodemailer` package and the `SEND_IN_BLUE_KEY` environment variable to be set.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as nodemailer from 'nodemailer'\n\ninterface Options {\n  to: string | string[]\n  subject: string\n  text: string\n  html: string\n}\n\nexport async function sendEmail({ to, subject, text, html }: Options) {\n  console.log('Sending email to:', to)\n\n  // create reusable transporter object using SendInBlue for SMTP\n  const transporter = nodemailer.createTransport({\n    host: 'smtp-relay.sendinblue.com',\n    port: 587,\n    secure: false, // true for 465, false for other ports\n    auth: {\n      user: 'your@email.com',\n      pass: process.env.SEND_IN_BLUE_KEY,\n    },\n  })\n\n  // send mail with defined transport object\n  const info = await transporter.sendMail({\n    from: '\"Your Name\" <your@email.com>',\n    to: Array.isArray(to) ? to : [to], // list of receivers\n    subject, // Subject line\n    text, // plain text body\n    html, // html body\n  })\n\n  return info\n}\n```\n\n----------------------------------------\n\nTITLE: Caching findMany with Conditions in cacheFindMany() - JavaScript\nDESCRIPTION: Demonstrates caching a filtered set of records (e.g., only admin users) using `cacheFindMany()` with query conditions. Provides for cache key stability while ensuring results are refreshed upon updates to any matching record, supporting extended options like expiry configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_72\n\nLANGUAGE: js\nCODE:\n```\nconst post = ({ id }) => {\\n  return cacheFindMany(`users`, db.user, {\\n    conditions: { where: { roles: 'admin' } },\\n  })\\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping Routes with BlogLayout in RedwoodJS (TypeScript)\nDESCRIPTION: Demonstrates routing setup in TypeScript to apply BlogLayout to selected pages via the Set wrap prop in RedwoodJS. The Router, Route, and Set components from @redwoodjs/router are used, and BlogLayout is imported using a src path alias. This ensures that /about and / share consistent layout styling, while supporting compile-time type checking. Prerequisites: @redwoodjs/router, correct path aliases.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-start\\nimport { Router, Route, Set } from '@redwoodjs/router'\\nimport BlogLayout from 'src/layouts/BlogLayout'\\n// highlight-end\\n\\nconst Routes = () => {\\n  return (\\n    <Router>\\n      // highlight-start\\n      <Set wrap={BlogLayout}>\\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\\n        <Route path=\"/\" page={HomePage} name=\"home\" />\\n      </Set>\\n      // highlight-end\\n      <Route notfound page={NotFoundPage} />\\n    </Router>\\n  )\\n}\\n\\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Testing createComment for Authenticated and Anonymous Comments - JSX\nDESCRIPTION: Contains two scenario-based tests for createComment. The first tests attaching a comment to the provided userId when a user is logged in, asserting comment.userId is assigned. The second verifies that when mockCurrentUser is null, the created comment has a userId of null (anonymous). Relies on mockCurrentUser utility, database scenario data, and the createComment service implementation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_70\n\nLANGUAGE: jsx\nCODE:\n```\nscenario('attaches a comment to a logged in user', async (scenario) => {\n  mockCurrentUser({ id: 123, name: 'Rob' })\n\n  const comment = await createComment({\n    input: {\n      body: 'It is the nature of all greatness not to be exact.',\n      postId: scenario.comment.jane.postId,\n    },\n  })\n\n  expect(comment.userId).toEqual(123)\n})\n\nscenario('creates anonymous comment if logged out', async (scenario) => {\n  // currentUser will return `null` by default in tests, but it's\n  // always nice to be explicit in tests that are testing specific\n  // behavior (logged in or not)—future devs may not go in with the\n  // same knowledge/assumptions as us!\n  mockCurrentUser(null)\n\n  const comment = await createComment({\n    input: {\n      body: 'When we build, let us think that we build for ever.',\n      postId: scenario.comment.jane.postId,\n    },\n  })\n\n  expect(comment.userId).toEqual(null)\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling GraphQL Operation Name Logging in TypeScript\nDESCRIPTION: Configures the `createGraphQLHandler` via `loggerConfig` to log the `operationName` of incoming GraphQL requests by setting `options.operationName` to `true`. This helps in debugging and associating logs with specific application parts (like RedwoodJS Cells). Requires a `logger` instance.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_45\n\nLANGUAGE: jsx\nCODE:\n```\n// ...\nexport const handler = createGraphQLHandler({\n  loggerConfig: { logger, options: { operationName: true } },\n// ...\n```\n\n----------------------------------------\n\nTITLE: Mocking Standard Comments Data for Storybook - TypeScript\nDESCRIPTION: This TypeScript mock function provides typed mock comment data for use with RedwoodJS Storybook, improving type safety for UI testing. It exports a “standard” function returning two example comments, matching the expected GraphQL response shape. This mock enables Storybook rendering of CommentsCell in TypeScript projects without needing a real API.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nexport const standard = () => ({\n  // highlight-start\n  comments: [\n    {\n      id: 1,\n      name: 'Rob Cameron',\n      body: 'First comment',\n      createdAt: '2020-01-02T12:34:56Z',\n    },\n    {\n      id: 2,\n      name: 'David Price',\n      body: 'Second comment',\n      createdAt: '2020-02-03T23:00:00Z',\n    },\n  ],\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Studio via Yarn (Bash)\nDESCRIPTION: This command starts the RedwoodJS Studio development tool using the Yarn package manager. It executes the Redwood CLI command `rw studio`, which typically makes the Studio UI available at `localhost:4318`. The first time this command is run, it may need to install the Studio package.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/studio.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw studio\n```\n\n----------------------------------------\n\nTITLE: Passing Configuration Options to useForm Hook in RedwoodJS (TS)\nDESCRIPTION: Explains and demonstrates that when `useForm` is called manually in TypeScript (`.tsx`), any configuration options (like validation mode) previously passed via the `<Form>` component's `config` prop must now be passed directly as an argument to the `useForm()` hook itself.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_44\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nconst ContactPage = () => {\n  const formMethods = useForm({ mode: 'onBlur' })\n  //...\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring onBlur Validation for RedwoodJS Form (TypeScript)\nDESCRIPTION: Shows how to configure a RedwoodJS `Form` component in TypeScript (TSX) to trigger validation when a user navigates away from a field (onBlur event). This is achieved by adding the `config` prop to the `Form` component and setting its value to `{ mode: 'onBlur' }`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_33\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\n<Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Variable in Redwood API Function (JSX)\nDESCRIPTION: This JavaScript code defines a Redwood API function handler (`hello.js`). It demonstrates accessing an environment variable (`HELLO_ENV`), previously defined in `.env`, using the standard Node.js `process.env.HELLO_ENV` mechanism. The value is then returned in the HTTP response body.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/environment-variables.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {6} title=\"./api/src/functions/hello.js\"\nexport const handler = async (event, context) => {\n  return {\n    statusCode: 200,\n    body: `${process.env.HELLO_ENV}`,\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Handler Implementation for the 'divide' Serverless Function - TypeScript (TSX Syntax)\nDESCRIPTION: This is a detailed serverless function handler for division, managing correct, error, and edge cases. It parses input parameters from the event query string, validates their presence, performs division with error checking (e.g., division by zero or missing arguments), and returns appropriate status codes (200, 400, 500) alongside informative JSON bodies. Requires aws-lambda types (for APIGatewayEvent). Key inputs: 'dividend', 'divisor'. Outputs: JSON response with message, inputs, and quotient or error. Shows robust error handling pattern for RedwoodJS API handlers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { APIGatewayEvent } from 'aws-lambda'\n\nexport const handler = async (event: APIGatewayEvent) => {\n  // sets the default response\n  let statusCode = 200\n  let message = ''\n\n  try {\n    // get the two numbers to divide from the event query string\n    const { dividend, divisor } = event.queryStringParameters\n\n    // make sure the values to divide are provided\n    if (dividend === undefined || divisor === undefined) {\n      statusCode = 400\n      message = `Please specify both a dividend and divisor.`\n      throw Error(message)\n    }\n\n    // divide the two numbers\n    const quotient = parseInt(dividend) / parseInt(divisor)\n    message = `${dividend} / ${divisor} = ${quotient}`\n\n    // check if the numbers could be divided\n    if (!isFinite(quotient)) {\n      statusCode = 500\n      message = `Sorry. Could not divide ${dividend} by ${divisor}`\n      throw Error(message)\n    }\n\n    return {\n      statusCode,\n      body: {\n        message,\n        dividend,\n        divisor,\n        quotient,\n      },\n    }\n  } catch (error) {\n    return {\n      statusCode,\n      body: {\n        message: error.message,\n      },\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scenario Data for Comments with RedwoodJS - JavaScript\nDESCRIPTION: Defines two database preload scenarios using defineScenario for comment service tests. The 'postOnly' scenario creates a single post entity with title and body to be used for new comment associations. No external dependencies are required beyond RedwoodJS' test framework.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = defineScenario({\n  // ...\n})\n\n// highlight-start\nexport const postOnly = defineScenario({\n  post: {\n    bark: {\n      data: {\n        title: 'Bark',\n        body: \"A tree's bark is worse than its bite\",\n      },\n    },\n  },\n})\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Adding Filestack React Library - Bash\nDESCRIPTION: Installs the Filestack React integration as a dependency in the web workspace. Makes the Picker and related upload components available for use in React components. 'filestack-react' must be added before importing PickerInline.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace web add filestack-react\n```\n\n----------------------------------------\n\nTITLE: Displaying Static Image Asset - HTML\nDESCRIPTION: Shows how to use an img tag to display a logo file that has been placed in a static subfolder. This method is suitable for assets that are not part of the JavaScript module system, such as images or other resources intended to be served as-is. The src value reflects the build output location. No dependencies are required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/web/public/README.md#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<img src=\\\"/static-files/my-logo.jpg\\\"> alt=\\\"Logo\\\" />\n```\n\n----------------------------------------\n\nTITLE: Executing Custom RedwoodJS Scripts\nDESCRIPTION: This command executes a script previously generated using `yarn redwood generate script <name>`. It allows running one-off tasks, background jobs, or utility scripts within the RedwoodJS context. Arbitrary flags can be passed to the script.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_27\n\nLANGUAGE: shell\nCODE:\n```\n❯ yarn redwood exec syncStripeProducts foo --firstParam 'hello' --two 'world'\n\n[18:13:56] Generating Prisma client [started]\n[18:13:57] Generating Prisma client [completed]\n[18:13:57] Running script [started]\n:: Executing script with args ::\n{ _: [ 'exec', 'foo' ], firstParam: 'hello', two: 'world', '$0': 'rw' }\n[18:13:58] Running script [completed]\n✨  Done in 4.37s.\n```\n\n----------------------------------------\n\nTITLE: Capturing Exceptions with Sentry in Redwood API Function - TypeScript\nDESCRIPTION: Presents a try-catch block in an async API handler that uses Sentry.captureException to log errors. The snippet is valid in both JavaScript and TypeScript, but the file extension here is TypeScript by example (.ts). Key dependencies are the Sentry library and Redwood serverless function conventions. Inputs include typical Redwood API event/context; any caught error is reported to Sentry, aiding in diagnostics. Intended for serverless function files named 'api/src/functions/foo.{js,ts}'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/monitoring/sentry.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport Sentry from 'src/lib/sentry'\n\nexport const handler = async (event, context) => {\n  try {\n    ...\n  } catch (err) {\n    Sentry.captureException(err)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Success Component with Articles Prop (JavaScript/JSX)\nDESCRIPTION: Defines the Success component in JavaScript/JSX, which receives an 'articles' prop and maps over it to render each article using the Article component. Assumes the input prop matches the mocked 'articles' array shape. Used as the target for passing mock data in stories and tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\\nexport const Success = ({ articles }) => {\\n  return (\\n    { articles.map((article) => <Article article={article} />) }\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nested Logging Key in RedwoodJS Logger\nDESCRIPTION: Specifies the `nestedKey` option (set to 'log' here) for the RedwoodJS logger configuration. This nests all logged metadata under the specified key ('log') to prevent collisions with pino or transport keys. Requires adjustment of redaction paths (e.g., 'log.email' instead of 'email').\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nnestedKey: 'log',\n```\n\n----------------------------------------\n\nTITLE: Configuring maxTokens in RedwoodJS GraphQL Handler - TypeScript\nDESCRIPTION: This TypeScript snippet configures the maxTokens property to limit the number of lexical tokens in incoming GraphQL documents, providing an important layer of security against complex or malicious queries. It accepts enabled (boolean) to activate the rule and n (number) to set the token cap. This is used in the GraphQL handler's initialization config.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  maxTokens: {\n    enabled: true,\n    n: 1000,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete OAuth Function Handler for Multiple Providers in RedwoodJS (JavaScript/JSX)\nDESCRIPTION: This snippet showcases a full RedwoodJS API-side handler for OAuth authentication, switching on request paths, delegating to the callback logic, facilitating user creation, and handling errors. It requires dependencies including 'crypto-js', a connected Prisma db client, and various environment variables. Internal functions handle secure cookie creation, fetching provider user data via HTTP, database transaction for user/identity creation, and user information updating. Inputs are AWS Lambda-style event objects; outputs are HTTP responses with appropriate status codes, headers, and data. The design enables easy extension for multiple providers and robust error handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_15\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport CryptoJS from 'crypto-js'\n\nimport { db } from 'src/lib/db'\n\nexport const handler = async (event, _context) => {\n  switch (event.path) {\n    case '/oauth/callback':\n      return await callback(event)\n    default:\n      // Whatever this is, it's not correct, so return \"Not Found\"\n      return {\n        statusCode: 404,\n      }\n  }\n}\n\nconst callback = async (event) => {\n  const { code } = event.queryStringParameters\n\n  const response = await fetch(`https://github.com/login/oauth/access_token`, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      client_id: process.env.GITHUB_OAUTH_CLIENT_ID,\n      client_secret: process.env.GITHUB_OAUTH_CLIENT_SECRET,\n      redirect_uri: process.env.GITHUB_OAUTH_REDIRECT_URI,\n      code,\n    }),\n  })\n\n  const { access_token, scope, error } = JSON.parse(await response.text())\n\n  if (error) {\n    return { statuscode: 400, body: error }\n  }\n\n  try {\n    const providerUser = await getProviderUser(access_token)\n    const user = await getUser({\n      providerUser,\n      accessToken: access_token,\n      scope,\n    })\n    const cookie = secureCookie(user)\n\n    return {\n      statusCode: 302,\n      headers: {\n        'Set-Cookie': cookie,\n        Location: '/',\n      },\n    }\n  } catch (e) {\n    return { statuscode: 500, body: e.message }\n  }\n}\n\nconst secureCookie = (user) => {\n  const expires = new Date()\n  expires.setFullYear(expires.getFullYear() + 1)\n\n  const cookieAttrs = [\n    `Expires=${expires.toUTCString()}`,\n    'HttpOnly=true',\n    'Path=/',\n    'SameSite=Lax',\n    `Secure=${process.env.NODE_ENV !== 'development'}`,\n  ]\n  const data = JSON.stringify({ id: user.id })\n\n  const encrypted = CryptoJS.AES.encrypt(\n    data,\n    process.env.SESSION_SECRET\n  ).toString()\n\n  return [`session=${encrypted}`, ...cookieAttrs].join('; ')\n}\n\nconst getProviderUser = async (token) => {\n  const response = await fetch('https://api.github.com/user', {\n    headers: { Authorization: `Bearer ${token}` },\n  })\n  const body = JSON.parse(await response.text())\n\n  return body\n}\n\nconst getUser = async ({ providerUser, accessToken, scope }) => {\n  const { user, identity } = await findOrCreateUser(providerUser)\n\n  await db.identity.update({\n    where: { id: identity.id },\n    data: { accessToken, scope, lastLoginAt: new Date() },\n  })\n\n  return user\n}\n\nconst findOrCreateUser = async (providerUser) => {\n  const identity = await db.identity.findFirst({\n    where: { provider: 'github', uid: providerUser.id.toString() },\n  })\n\n  if (identity) {\n    // identity exists, return the user\n    const user = await db.user.findUnique({ where: { id: identity.userId } })\n    return { user, identity }\n  }\n\n  // identity not found, need to create it and the user\n  return await db.$transaction(async (tx) => {\n    const user = await tx.user.create({\n      data: {\n        email: providerUser.email,\n        fullName: providerUser.name,\n      },\n    })\n\n    const identity = await tx.identity.create({\n      data: {\n        userId: user.id,\n        provider: 'github',\n        uid: providerUser.id.toString(),\n      },\n    })\n\n    return { user, identity }\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Updating ArticlesCell to Display Summaries (JSX)\nDESCRIPTION: This snippet modifies the JavaScript `ArticlesCell` component. Within the `Success` component, which renders the list of articles fetched via the `QUERY`, it now passes the `summary={true}` prop to each `Article` component instance. This ensures that the list of articles displayed by this cell will show summaries instead of full content.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-story.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticlesCell/ArticlesCell.jsx\"\nimport Article from 'src/components/Article'\n\nexport const QUERY = gql`\n  query ArticlesQuery {\n    articles: posts {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => <div>Error: {error.message}</div>\n\nexport const Success = ({ articles }) => {\n  return (\n    <div className=\"space-y-10\">\n      {articles.map((article) => (\n        // highlight-next-line\n        <Article article={article} key={article.id} summary={true} />\n      ))}\n    </div>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Supabase Sign Up in RedwoodJS Component (TSX)\nDESCRIPTION: Demonstrates a basic sign-up implementation within a React component (`HomePage`). It uses the `useAuth` hook from `src/auth` to get the `isAuthenticated` state and the `signUp` function, then triggers sign-up with hardcoded credentials on button click.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAuth } from 'src/auth'\n\nconst HomePage = () => {\n  const { isAuthenticated, signUp } = useAuth()\n\n  return (\n    <>\n      {/* MetaTags, h1, paragraphs, etc. */}\n\n      <p>{JSON.stringify({ isAuthenticated })}</p>\n      <button\n        onClick={() =>\n          signUp({\n            email: 'your.email@email.com',\n            password: 'super secret password',\n          })\n        }\n      >\n        sign up\n      </button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Article Component for Summary View (TSX)\nDESCRIPTION: This TypeScript (TSX) snippet modifies the `Article` component to add text truncation functionality. It defines a `truncate` function with type annotations, adds an optional `summary` boolean prop to the `Props` interface, and conditionally renders either the truncated (100 characters) or the full `article.body` based on the `summary` prop. It depends on `@redwoodjs/router` for linking and uses the `Post` type from GraphQL definitions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-story.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/Article/Article.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\nimport type { Post } from 'types/graphql'\n\n// highlight-start\nconst truncate = (text: string, length: number) => {\n  return text.substring(0, length) + '...'\n}\n// highlight-end\n\ninterface Props {\n  // highlight-start\n  article: Omit<Post, 'createdAt'>\n  summary?: boolean\n  // highlight-end\n}\n\n// highlight-next-line\nconst Article = ({ article, summary = false }: Props) => {\n  return (\n    <article className=\"mt-10\">\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        // highlight-next-line\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\n----------------------------------------\n\nTITLE: Executing Database Seed Script with RedwoodJS Prisma\nDESCRIPTION: Executes the RedwoodJS CLI command (`yarn rw prisma db seed`) to run the database seeding script, typically located at `scripts/seed.js`. This command populates the database with predefined data, useful for development environments or setting up initial application state after migrations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma db seed\n```\n\n----------------------------------------\n\nTITLE: Defining User Roles in Prisma Schema - JavaScript\nDESCRIPTION: Adds a roles property to the User model in the Prisma schema. This setup enables role-based logic within the application by introducing a new string field. Required dependency: Prisma. Key parameters: roles (string) stores the user role; required on every user record. There is no default value, so new rows will fail migration unless handled.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nmodel User {\n  id                  Int @id @default(autoincrement())\n  name                String?\n  email               String @unique\n  hashedPassword      String\n  salt                String\n  resetToken          String?\n  resetTokenExpiresAt DateTime?\n  // highlight-next-line\n  roles               String\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Job with Queue and Priority in JavaScript\nDESCRIPTION: This snippet demonstrates defining a job (`SendWelcomeEmailJob`) using `jobs.createJob`. It includes optional configuration for the job's `queue` (assigning it to the 'email' queue) and `priority` (setting it to 1, which is higher priority). The `perform` function contains the actual job logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nimport { jobs } from 'src/lib/jobs'\n\nexport const SendWelcomeEmailJob = jobs.createJob({\n  // highlight-start\n  queue: 'email',\n  priority: 1,\n  // highlight-end\n  perform: async (userId) => {\n    // job details...\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Webhook Signature Verifier - JavaScript/TypeScript\nDESCRIPTION: This function illustrates how to instantiate a webhook signature verifier using the createVerifier method, which accepts a verifier type and an options object. The type argument specifies which verification strategy to use (from SupportedVerifiers), and options allows for detailed configuration (such as secret keys, headers, and other required settings). The createVerifier method is essential for verifying incoming webhook requests with the appropriate scheme based on third-party requirements. This pattern supports extensibility and adaptability for multiple external webhook providers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ncreateVerifier(type, options)\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with `integer` Option in JSX\nDESCRIPTION: Demonstrates the `numericality` validator using the `integer` option set to `true` to ensure the input value is a whole number.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_30\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.age, 'Age', {\n  numericality: { integer: true },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Refetching Comments Query on Comment Creation in RedwoodJS (JavaScript)\nDESCRIPTION: In this React useMutation call, refetchQueries is configured to re-run the CommentsQuery with the current postId after successfully creating a comment. This ensures the UI is updated to include new comments immediately. Dependencies include Apollo Client's useMutation, the CREATE mutation definition, CommentsQuery, and appropriate postId context passed into the component. The key outputs are the updated comment list, automatically synchronized after mutation completion.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_34\n\nLANGUAGE: jsx\nCODE:\n```\nconst [createComment, { loading, error }] = useMutation(CREATE, {\\n  onCompleted: () => {\\n    setHasPosted(true)\\n    toast.success('Thank you for your comment!')\\n  },\\n  // highlight-next-line\\n  refetchQueries: [{ query: CommentsQuery, variables: { postId } }],\\n})\n```\n\n----------------------------------------\n\nTITLE: Excluding .yarn Folder from VSCode Search\nDESCRIPTION: This JSON snippet shows how to configure VSCode's `settings.json` to exclude the `.yarn` directory from project-wide search results. The `search.exclude` setting uses a glob pattern (`**/.yarn`) to match the directory anywhere in the project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/project-configuration-dev-test-build.mdx#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n  \"search.exclude\": {\n    \"**/.yarn\": true\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom React Hook useAccumulator in JavaScript\nDESCRIPTION: This JavaScript code defines a custom React hook named `useAccumulator`. It utilizes the `useState` hook to maintain an accumulator state (`total`), initialized with `initialValue`. It returns an object containing the current `total` and an `add` function to increment the total.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_33\n\nLANGUAGE: js\nCODE:\n```\n```js title=\"web/src/hooks/useAccumulator/useAccumulator.js\"\nconst useAccumulator = (initialValue) => {\n  const [total, setTotal] = useState(initialValue)\n\n  const add = (value) => {\n    const newTotal = total + value\n    setTotal(newTotal)\n    return newTotal\n  }\n\n  return { total, add }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Integrating CommentForm into Article Component (JSX/TSX)\nDESCRIPTION: This snippet shows the modification of the `Article` component (in both JavaScript and TypeScript) to include the `CommentForm` and `CommentsCell` components. The `CommentForm` and `CommentsCell` are rendered only when the `summary` prop is false (i.e., on the full article view), placed within a div with top margin.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Article/Article.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-next-line\nimport CommentForm from 'src/components/CommentForm'\nimport CommentsCell from 'src/components/CommentsCell'\n\nconst truncate = (text, length) => {\n  return text.substring(0, length) + '...'\n}\n\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      {!summary && (\n        // highlight-start\n        <div className=\"mt-12\">\n          <CommentForm />\n          // highlight-end\n          <div className=\"mt-12\">\n            <CommentsCell />\n          </div>\n        // highlight-next-line\n        </div>\n      )}\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/Article/Article.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-next-line\nimport CommentForm from 'src/components/CommentForm'\nimport CommentsCell from 'src/components/CommentsCell'\n\nimport type { Post } from 'types/graphql'\n\nconst truncate = (text: string, length: number) => {\n  return text.substring(0, length) + '...'\n}\n\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      {!summary && (\n        // highlight-start\n        <div className=\"mt-12\">\n          <CommentForm />\n          // highlight-end\n          <div className=\"mt-12\">\n            <CommentsCell />\n          </div>\n          // highlight-next-line\n        </div>\n      )}\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\n----------------------------------------\n\nTITLE: Destroying RedwoodJS Serverless Functions via CLI\nDESCRIPTION: This command removes a previously generated RedwoodJS serverless Function and its associated files from the `api/src/functions` directory. It requires the name of the function to destroy as an argument. This effectively reverses the `generate function` command.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_44\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood destroy function <name>\n```\n\n----------------------------------------\n\nTITLE: Defining Comment GraphQL Schema with Public Access (GraphQL/TypeScript)\nDESCRIPTION: Defines the GraphQL schema for the `Comment` type and related queries/inputs within `api/src/graphql/comments.sdl.ts` for a TypeScript project. It mirrors the JavaScript version, specifying `Comment` fields, a `comments` query with `@skipAuth` for public access, and input types (`CreateCommentInput`, `UpdateCommentInput`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\n  type Comment {\n    id: Int!\n    name: String!\n    body: String!\n    post: Post!\n    postId: Int!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    // highlight-next-line\n    comments: [Comment!]! @skipAuth\n  }\n\n  input CreateCommentInput {\n    name: String!\n    body: String!\n    postId: Int!\n  }\n\n  input UpdateCommentInput {\n    name: String\n    body: String\n    postId: Int\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Throwing a UserInputError for Validation - TypeScript/TSX\nDESCRIPTION: This TSX code demonstrates importing and using the UserInputError from the RedwoodJS server package to throw validation errors in a GraphQL service. Throwing this error type exposes its message to the user in the GraphQL response, bypassing the default error masking. Requires the '@redwoodjs/graphql-server' dependency. Parameters include an error message string.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\nimport { UserInputError } from '@redwoodjs/graphql-server'\n// ...\nthrow new UserInputError('An email is required.')\n```\n\n----------------------------------------\n\nTITLE: Initializing JobManager with PrismaAdapter in JavaScript\nDESCRIPTION: This snippet demonstrates how to initialize the `JobManager` by providing a configuration object. It specifically shows how to add and configure the `PrismaAdapter` under the key 'prisma'. The adapter requires a PrismaClient instance (`db`), optionally accepts a model name (defaults to 'BackgroundJob'), and a logger.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nexport const jobs = new JobManager({\n  adapters: {\n    // highlight-next-line\n    prisma: new PrismaAdapter({ db, model: 'BackgroundJob', logger }),\n  },\n  // remaining config...\n})\n```\n\n----------------------------------------\n\nTITLE: Starting Individual RedwoodJS Job Worker Instances with Index and ID Flags in Bash\nDESCRIPTION: Provides the command to start a single job worker instance using the yarn rw-jobs-worker CLI utility, specifying the worker group via --index and the id of the worker via --id. This allows for manual scaling and monitoring of workers, useful in conjunction with external process monitors. Inputs are CLI flags; the command starts one job worker process according to the supplied configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw-jobs-worker --index=0 --id=0\n```\n\n----------------------------------------\n\nTITLE: Setting Up PM2 Process Management for API and Web Sides in RedwoodJS (JavaScript)\nDESCRIPTION: Specifies the pm2 ecosystem configuration in JavaScript for launching and managing multiple cluster-mode processes of RedwoodJS 'api' and 'web' sides. This is used with pm2 and expects the 'rw' CLI to be available in node_modules. The script, working directory, arguments, and additional pm2 options (like cluster mode, instance maxing, waiting for readiness, and listening timeouts) are defined for both services.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nmodule.exports = {\n  apps: [\n    {\n      name: 'api',\n      cwd: 'current',\n      script: 'node_modules/.bin/rw',\n      args: 'serve api',\n      instances: 'max',\n      exec_mode: 'cluster',\n      wait_ready: true,\n      listen_timeout: 10000,\n    },\n    {\n      name: 'web',\n      cwd: 'current',\n      script: 'node_modules/.bin/rw',\n      args: 'serve web',\n      instances: 'max',\n      exec_mode: 'cluster',\n      wait_ready: true,\n      listen_timeout: 10000,\n    },\n  ],\n}\n\n```\n\n----------------------------------------\n\nTITLE: Updating JavaScript Comments Service Implementation\nDESCRIPTION: Modifies the `comments` service function in JavaScript (`comments.js`) to accept a `postId` argument. It uses this `postId` in the Prisma `findMany` query's `where` clause to filter comments belonging only to the specified post.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.js\"\nexport const comments = ({ postId }) => {\n  return db.comment.findMany({ where: { postId } })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Returning Binary Data as Base64 with API Gateway - TypeScript\nDESCRIPTION: Shows how to return binary file data (e.g., images) from a RedwoodJS serverless function by reading the file, encoding it as Base64, and setting the isBase64Encoded flag in the API Gateway response. Depends on aws-lambda event types and fs for reading files. Expects the file path to be specified, and returns the file with correct headers for content type and length. Designed for small files due to memory and execution time limitations in serverless environments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { APIGatewayEvent, Context } from 'aws-lambda'\nimport fs from 'fs'\n\nexport const handler = async (event: APIGatewayEvent, context: Context) => {\n  const file = await fs.promises.readFile('/path/to/image.png')\n\n  return {\n    statusCode: 200,\n    headers: {\n      'Content-Type': 'image/png',\n      'Content-Length': file.length,\n    },\n    body: file.toString('base64'),\n    isBase64Encoded: true,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating BlogLayout Component with Home Links in RedwoodJS (JavaScript)\nDESCRIPTION: This JSX snippet shows the `BlogLayout` component for a RedwoodJS application. It imports `Link` and `routes` from `@redwoodjs/router` to create navigation. Links to the homepage (`routes.home()`) are added to the main header title (`h1`) and as a navigation list item.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/layouts/BlogLayout/BlogLayout.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\nconst BlogLayout = ({ children }) => {\n  return (\n    <>\n      <header>\n        // highlight-start\n        <h1>\n          <Link to={routes.home()}>Redwood Blog</Link>\n        </h1>\n        // highlight-end\n        <nav>\n          <ul>\n            // highlight-start\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            // highlight-end\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n```\n\n----------------------------------------\n\nTITLE: Generating CRUD Scaffold from Model - RedwoodJS CLI - Bash\nDESCRIPTION: This Bash snippet demonstrates the RedwoodJS CLI scaffold generator, which takes a database model name and creates a full suite (SDL, service, layout, pages, cells, components) for basic CRUD operations. Accepts flags for documentation, TypeScript, Tailwind, force, and rollback. Requires a database model to exist and a RedwoodJS project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_67\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate scaffold <model>\n```\n\n----------------------------------------\n\nTITLE: Configuring Fastify Server Options in Redwood Server File\nDESCRIPTION: This TypeScript snippet shows how to pass configuration options directly to the underlying Fastify server instance. The `fastifyServerOptions` object is passed to the `createServer` function, allowing customization according to Fastify's documentation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = await createServer({\n  logger,\n  // highlight-start\n  fastifyServerOptions: {\n    // ...\n  },\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Initial Article Component Structure (TSX)\nDESCRIPTION: Shows the basic functional component structure for `Article.tsx` as generated by the RedwoodJS CLI. This initial version is a simple React component rendering placeholder content, written in TypeScript. Note that `React` is implicitly imported by RedwoodJS.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_26\n\nLANGUAGE: tsx\nCODE:\n```\nconst Article = () => {\n  return (\n    <div>\n      <h2>{'Article'}</h2>\n      <p>{'Find me in ./web/src/components/Article/Article.tsx'}</p>\n    </div>\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Converting Date to ISO 8601 String Using JavaScript for Prisma DateTime\nDESCRIPTION: Provides a code example for converting a JavaScript Date object into an ISO 8601 string, mirroring how Prisma returns DateTime fields. This is necessary for accurate Jest equality assertions involving DateTime values returned by Prisma. Requires only native JavaScript Date API. Output is an ISO string suitable for use in tests. Assumes input is a string parseable by Date.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\n//  Output: '2021-10-15T19:40:33.000Z'\nconst isoString = new Date('2021-10-15T19:40:33Z').toISOString()\n```\n\n----------------------------------------\n\nTITLE: Resetting Apollo Store via useCache.resetStore (TypeScript)\nDESCRIPTION: Demonstrates a total Apollo cache reset using useCache.resetStore, erasing all local cache data, typically used on user sign-out or reset actions. This operation differs from clearStore in that it also refetches all active queries. Recommended for security-sensitive workflow.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_38\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst Fruit = ({ id }: { id: FragmentIdentifier }) => {\n  const { resetStore } = useCache()\n\n  resetStore()\n}\n```\n\n----------------------------------------\n\nTITLE: Calling the Test Email Function within Users Service (TypeScript)\nDESCRIPTION: Shows the replacement of a `console.log` statement with an asynchronous call to the `sendTestEmail` function, passing the user's email address (`user.email`). This integrates the email sending logic into an existing function, likely a mutation handler like `emailUser`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\n\nawait sendTestEmail(user.email)\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Setting up TailwindCSS in RedwoodJS Project (Bash)\nDESCRIPTION: This command uses the RedwoodJS CLI (`rw`) to set up the TailwindCSS UI framework within the current project. It's intended for users continuing the tutorial with their existing codebase who want to apply the same styling used in subsequent examples.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/06_intermission.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup ui tailwindcss\n```\n\n----------------------------------------\n\nTITLE: Creating Schedulers for Multiple Adapters in RedwoodJS Jobs JavaScript\nDESCRIPTION: Presents how to instantiate schedulers for different job adapters using the jobs object. This enables coordination of jobs backed by various storage solutions, such as Prisma or Redis. Although a RedisAdapter is not yet provided, this pattern shows the extensibility of the job system. Requires a jobs JobManager instance with registered adapters. Each call configures a job scheduler tied to the specified adapter.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_34\n\nLANGUAGE: js\nCODE:\n```\nexport const prismaLater = jobs.createScheduler({\n  adapter: 'prisma',\n})\n\nexport const redisLater = jobs.createScheduler({\n  adapter: 'redis',\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Auth Loading Indicator in RedwoodJS Router (JSX)\nDESCRIPTION: Demonstrates how to use the `whileLoadingAuth` prop within a `PrivateSet` component in `Routes.jsx`. This prop accepts a component (e.g., `SkeletonLoader`) to render while RedwoodJS fetches user authentication details before rendering the private routes. The `whileLoadingPage` prop is also shown for page chunk loading.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_35\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"Routes.jsx\"\n<Router useAuth={useAuth}>\n  <PrivateSet\n    wrap={DashboardLayout}\n    unauthenticated=\"login\"\n    whileLoadingAuth={SkeletonLoader} //<-- auth loader\n    whileLoadingPage={SkeletonLoader} // <-- page chunk loader\n    prerender\n  >\n    <Route path=\"/dashboard\" page={DashboardHomePage} name=\"dashboard\" />\n\n    {/* other routes */}\n  </PrivateSet>\n</Router>\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Comments Using RedwoodJS Cell - TypeScript (TSX)\nDESCRIPTION: Implements the CommentsCell as a strongly-typed RedwoodJS Cell using TypeScript types for GraphQL results and props. Handles all Redwood cell states and includes type annotations for better tooling. Inputs include the comments array, and it is dependent on type definitions from generated GraphQL types and RedwoodJS packages.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { CommentsQuery, CommentsQueryVariables } from 'types/graphql'\\n\\nimport type {\\n  CellFailureProps,\\n  CellSuccessProps,\\n  TypedDocumentNode,\\n} from '@redwoodjs/web'\\n\\n// highlight-next-line\\nimport Comment from 'src/components/Comment'\\n\\nexport const QUERY: TypedDocumentNode<CommentsQuery, CommentsQueryVariables> =\\n  gql`\\n    query CommentsQuery {\\n      comments {\\n        id\\n        // highlight-start\\n        name\\n        body\\n        createdAt\\n        // highlight-end\\n      }\\n    }\\n  `\\n\\nexport const Loading = () => <div>Loading...</div>\\n\\nexport const Empty = () => <div>Empty</div>\\n\\nexport const Failure = ({\\n  error,\\n}: CellFailureProps<CommentsQueryVariables>) => (\\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\\n)\\n\\nexport const Success = ({\\n  comments,\\n}: CellSuccessProps<CommentsQuery, CommentsQueryVariables>) => {\\n  return (\\n    // highlight-start\\n    <>\\n      {comments.map((comment) => (\\n        <Comment key={comment.id} comment={comment} />\\n      ))}\\n    </>\\n    // highlight-end\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Filestack - Env\nDESCRIPTION: Defines the Filestack API key as an environment variable in the .env file, following Redwood/Vite conventions for environment variable expansion. This key is required for authenticating API usage in the app; the variable REDWOOD_ENV_FILESTACK_API_KEY must be set with your actual Filestack API key for uploads to function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_1\n\nLANGUAGE: env\nCODE:\n```\nREDWOOD_ENV_FILESTACK_API_KEY=AM18i8xV4QpoiGwetoTWd\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Logger Log Level (TypeScript)\nDESCRIPTION: Shows how to instantiate a logger with a specific log level using RedwoodLoggerOptions and createLogger. Requires '@redwoodjs/api/logger' to be installed. Inputs include the options object with the 'level' key determining minimum log severity. Outputs are structured log messages at or above the specified level. Useful when the default environment-based log level needs overriding, especially for troubleshooting deployed applications. No output for messages below the set level.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createLogger } from '@redwoodjs/api/logger'\n\n/**\n * Creates a logger with RedwoodLoggerOptions\n *\n * These extend and override default LoggerOptions,\n * can define a destination like a file or other supported pino log transport stream,\n * and sets whether or not to show the logger configuration settings (defaults to false)\n *\n * @param RedwoodLoggerOptions\n *\n * RedwoodLoggerOptions have\n * @param {options} LoggerOptions - defines how to log, such as redaction and format\n * @param {string | DestinationStream} destination - defines where to log, such as a transport stream or file\n * @param {boolean} showConfig - whether to display logger configuration on initialization\n */\nexport const logger = createLogger({ options: { level: 'info' } })\n```\n\n----------------------------------------\n\nTITLE: Output of Namespaced Redwood Scaffold Generation (plaintext)\nDESCRIPTION: Displays the file structure created by `yarn redwood generate scaffold admin/user`, illustrating how namespacing creates additional directory levels (e.g., `Admin`) for generated files, alongside the default model-based nesting (e.g., `User`) unless disabled.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_70\n\nLANGUAGE: plaintext\nCODE:\n```\n~/redwood-app$ yarn redwood generate scaffold admin/user\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood g scaffold admin/user\n  ✔ Generating scaffold files...\n    ✔ Successfully wrote file `./api/src/graphql/users.sdl.js`\n    ✔ Successfully wrote file `./api/src/services/users/users.js`\n    ✔ Successfully wrote file `./api/src/services/users/users.scenarios.js`\n    ✔ Successfully wrote file `./api/src/services/users/users.test.js`\n    ✔ Successfully wrote file `./web/src/layouts/Admin/UsersLayout/UsersLayout.js`\n    ✔ Successfully wrote file `./web/src/pages/Admin/User/EditUserPage/EditUserPage.js`\n    ✔ Successfully wrote file `./web/src/pages/Admin/User/UserPage/UserPage.js`\n    ✔ Successfully wrote file `./web/src/pages/Admin/User/UsersPage/UsersPage.js`\n    ✔ Successfully wrote file `./web/src/pages/Admin/User/NewUserPage/NewUserPage.js`\n    ✔ Successfully wrote file `./web/src/components/Admin/User/EditUserCell/EditUserCell.js`\n    ✔ Successfully wrote file `./web/src/components/Admin/User/User/User.js`\n    ✔ Successfully wrote file `./web/src/components/Admin/User/UserCell/UserCell.js`\n    ✔ Successfully wrote file `./web/src/components/Admin/User/UserForm/UserForm.js`\n    ✔ Successfully wrote file `./web/src/components/Admin/User/Users/Users.js`\n    ✔ Successfully wrote file `./web/src/components/Admin/User/UsersCell/UsersCell.js`\n    ✔ Successfully wrote file `./web/src/components/Admin/User/NewUser/NewUser.js`\n  ✔ Adding layout import...\n  ✔ Adding set import...\n  ✔ Adding scaffold routes...\n  ✔ Adding scaffold asset imports...\nDone in 1.21s.\n```\n\n----------------------------------------\n\nTITLE: Routing OAuth Callback with RedwoodJS API Function (JavaScript)\nDESCRIPTION: Defines the exportable handler for the RedwoodJS serverless function, routing requests based on event.path. Only '/oauth/callback' leads to the callback handler, while others return 404. No dependencies beyond Redwood API runtime; relies on event context for dispatching. Accepts API Gateway-style event, triggers OAuth callback logic, and outputs correct HTTP status codes for endpoint validation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nexport const handler = async (event, _context) => {\n  switch (event.path) {\n    case '/oauth/callback':\n      return await callback(event)\n    default:\n      // Whatever this is, it's not correct, so return \"Not Found\"\n      return {\n        statusCode: 404,\n      }\n  }\n}\n\nconst callback = async (event) => {\n  return { body: 'ok' }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Authenticated User and Logout Option in BlogLayout - TypeScript\nDESCRIPTION: This enhanced BlogLayout implementation in TypeScript introduces authentication-aware UI that conditionally displays the logged-in user's email and a logout button, or a login link if the user is not authenticated. Leverages TypeScript static typing on the BlogLayoutProps interface. Requires dependencies on @redwoodjs/router and src/auth, and expects currentUser to have an email attribute returned from the backend configuration. Accepts children as main content.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\\n\\nimport { useAuth } from 'src/auth'\\n\\ntype BlogLayoutProps = {\\n  children?: React.ReactNode\\n}\\n\\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\\n  const { isAuthenticated, currentUser, logOut } = useAuth()\\n\\n  return (\\n    <>\\n      <header>\\n        // highlight-next-line\\n        <div className=\"flex-between\">\\n          <h1>\\n            <Link to={routes.home()}>Redwood Blog</Link>\\n          </h1>\\n          // highlight-start\\n          {isAuthenticated ? (\\n            <div>\\n              <span>Logged in as {currentUser.email}</span>{' '}\\n              <button type=\"button\" onClick={logOut}>\\n                Logout\\n              </button>\\n            </div>\\n          ) : (\\n            <Link to={routes.login()}>Login</Link>\\n          )}\\n        </div>\\n        // highlight-end\\n        <nav>\\n          <ul>\\n            <li>\\n              <Link to={routes.home()}>Home</Link>\\n            </li>\\n            <li>\\n              <Link to={routes.about()}>About</Link>\\n            </li>\\n            <li>\\n              <Link to={routes.contact()}>Contact</Link>\\n            </li>\\n          </ul>\\n        </nav>\\n      </header>\\n      <main>{children}</main>\\n    </>\\n  )\\n}\\n\\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Linking Article Title with Route Parameter (RedwoodJS, TypeScript)\nDESCRIPTION: This TypeScript snippet mirrors the JavaScript example, passing the article id as a parameter into the routes helper to construct the correct article detail URL. It is used inside a React component and integrates with RedwoodJS's typed routes. The code expects 'article.id' to be available, and the type of the 'id' parameter should match the route definition (string or number).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n<h2>\\n  <Link to={routes.article({ id: article.id })}>{article.title}</Link>\\n</h2>\n```\n\n----------------------------------------\n\nTITLE: Preparing Query Variables for Pagination - RedwoodJS Cell beforeQuery - TypeScript\nDESCRIPTION: Defines a strongly typed 'beforeQuery' function for a RedwoodJS Cell, converting the page query parameter to a number and returning it as part of the variables object. Incorporates type annotations for query variables and options, enhancing type safety across the data-fetch flow. This function is critical to ensuring the query receives properly typed inputs from string-based URL query params.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nexport const beforeQuery = ({\n  page,\n}: FindBlogPostQueryVariables): GraphQLQueryHookOptions<\n  FindBlogPostQuery,\n  FindBlogPostQueryVariables\n> => {\n  page = page ? parseInt(page, 10) : 1\n\n  return { variables: { page } }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Authenticated User and Logout Option in BlogLayout - JavaScript\nDESCRIPTION: This enhanced BlogLayout implementation in JavaScript includes authenticated user display and login/logout links based on authentication state. It uses the useAuth hook to dynamically show the current user's email and a logout button, or a login link if unauthenticated. Requires @redwoodjs/router, src/auth, and configured authentication; currentUser must have an email property available from the backend. Accepts children as layout content.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\\n\\nimport { useAuth } from 'src/auth'\\n\\nconst BlogLayout = ({ children }) => {\\n  const { isAuthenticated, currentUser, logOut } = useAuth()\\n\\n  return (\\n    <>\\n      <header>\\n        // highlight-next-line\\n        <div className=\"flex-between\">\\n          <h1>\\n            <Link to={routes.home()}>Redwood Blog</Link>\\n          </h1>\\n          // highlight-start\\n          {isAuthenticated ? (\\n            <div>\\n              <span>Logged in as {currentUser.email}</span>{' '}\\n              <button type=\"button\" onClick={logOut}>\\n                Logout\\n              </button>\\n            </div>\\n          ) : (\\n            <Link to={routes.login()}>Login</Link>\\n          )}\\n        </div>\\n        // highlight-end\\n        <nav>\\n          <ul>\\n            <li>\\n              <Link to={routes.home()}>Home</Link>\\n            </li>\\n            <li>\\n              <Link to={routes.about()}>About</Link>\\n            </li>\\n            <li>\\n              <Link to={routes.contact()}>Contact</Link>\\n            </li>\\n          </ul>\\n        </nav>\\n      </header>\\n      <main>{children}</main>\\n    </>\\n  )\\n}\\n\\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Setting Up RedwoodJS GraphQL Logger Configuration (JavaScript/JSX)\nDESCRIPTION: Provides a minimal example for configuring the RedwoodJS GraphQL handler to use a custom logger via the loggerConfig option. This snippet requires importing a logger instance from 'src/lib/logger' and passing it to createGraphQLHandler to enable enriched and structured logging for the GraphQL API endpoint. The logger can be extended with options for tracing, error reporting, or advanced telemetry. The export named handler may be directly used by the framework as the GraphQL API endpoint.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_41\n\nLANGUAGE: jsx\nCODE:\n```\n// ...\n\nimport { logger } from 'src/lib/logger'\n\n// ...\nexport const handler = createGraphQLHandler({\n  loggerConfig: { logger, options: {} },\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Scenario Data for Comment Service - RedwoodJS (JavaScript)\nDESCRIPTION: Defines scenario data for comment-related tests using RedwoodJS's scenario utility in JavaScript. The 'standard' scenario placeholder is included, while a 'postOnly' scenario is created, which seeds the database with a single post. This enables custom database state during tests and is used by test cases to ensure repeatable results. Requires RedwoodJS and related test runners, with data keyed by descriptive names ('bark'). Input is static data, output is a scenario object loaded into the DB.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = defineScenario({\n  // ...\n})\n\n// highlight-start\nexport const postOnly = defineScenario({\n  post: {\n    bark: {\n      data: {\n        title: 'Bark',\n        body: \"A tree's bark is worse than its bite\",\n      },\n    },\n  },\n})\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Monitor PM2-Managed Processes via Terminal Dashboard - Bash\nDESCRIPTION: Invokes the PM2 monitoring dashboard, showing real-time information about all managed services in a terminal interface. Useful for checking health, logs, and status without a web browser. PM2 must be installed and running.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\npm2 monit\n```\n\n----------------------------------------\n\nTITLE: Sample GraphQL Query Operation - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates a GraphQL operation embedded in TypeScript notation. The operation fetches current user's id and username using the 'me' field, serving as an example for tokenization security rules. No external dependencies are required; it consists of a simple query with expected outputs as user fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\n graphql {\n   me {\n     id\n     user\n   }\n }\n```\n\n----------------------------------------\n\nTITLE: Example Prisma Migration Error with Digital Ocean Pooling\nDESCRIPTION: Shows a potential error message (`ERROR: prepared statement \"s0\" already exists`) that can occur when running Prisma migrations against a Digital Ocean PostgreSQL database using connection pooling if the `DATABASE_URL` is not configured correctly with the `pgbouncer=true` parameter.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/connection-pooling.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nError: Migration engine error:\ndb error: ERROR: prepared statement \"s0\" already exists\n```\n\n----------------------------------------\n\nTITLE: Serving Only the Web Side with RedwoodJS - Bash\nDESCRIPTION: Starts a static server for only the 'web' side using built assets from 'web/dist'. Recommended when debugging the web interface, including prerender, or for scalable deployments with decoupled frontend/backend servers. Supports parameters like --port, --socket, and --apiHost for API proxying. Output is a static file server. Supports formatted log output via piping.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_135\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw serve web\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw serve web | yarn rw-log-formatter\n```\n\n----------------------------------------\n\nTITLE: Defining the Data Migration Tracking Model in Prisma Schema\nDESCRIPTION: Shows the Prisma model `RW_DataMigration` definition added to `api/db/schema.prisma` by the `yarn rw data-migrate install` command. This model is used internally by RedwoodJS to track which data migrations have been successfully executed, storing the version, name, and start/finish timestamps.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/data-migrations.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nmodel RW_DataMigration {\n  version    String   @id\n  name       String\n  startedAt  DateTime\n  finishedAt DateTime\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests in a RedwoodJS Project using Jest\nDESCRIPTION: Executes the project's test suite using the integrated Jest test runner via the `yarn rw test` command. Redwood automatically generates test files for components, services, and cells, and this command runs all tests found in the project for both frontend and backend code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw test\n```\n\n----------------------------------------\n\nTITLE: Defining a File Scalar in RedwoodJS GraphQL Schema\nDESCRIPTION: Defines an input type `UpdateProfileInput` in a GraphQL schema definition language (SDL) file. It includes a field `avatar` of type `File`, which leverages RedwoodJS's pre-configured `File` scalar to enable file uploads through GraphQL mutations. This setup informs GraphQL Yoga how to handle multipart form requests containing files for this field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/profiles.sdl.ts\"\ninput UpdateProfileInput {\n  id: Int\n  firstName: String\n  # ...other fields\n  // highlight-next-line\n  avatar: File\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Displaying Typed Toast Notification on Mutation Completion in RedwoodJS (TypeScript)\nDESCRIPTION: This TSX snippet demonstrates the TypeScript implementation for displaying a success notification using `react-hot-toast` upon successful GraphQL mutation (`CREATE_CONTACT`) in a RedwoodJS contact page. It imports necessary types, `toast`, and `Toaster`. The `useMutation` hook is strongly typed, and its `onCompleted` callback triggers `toast.success()`. The `<Toaster>` component is rendered, and types for form values (`FormValues`) and mutation variables are defined.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata, useMutation } from '@redwoodjs/web'\n// highlight-next-line\nimport { toast, Toaster } from '@redwoodjs/web/toast'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\nimport {\n  CreateContactMutation,\n  CreateContactMutationVariables,\n} from 'types/graphql'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  // highlight-start\n  const [create, { loading, error }] = useMutation<\n    CreateContactMutation,\n    CreateContactMutationVariables\n  >(CREATE_CONTACT, {\n    onCompleted: () => {\n      toast.success('Thank you for your submission!')\n    },\n  })\n  // highlight-end\n\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n      // highlight-next-line\n      <Toaster />\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit disabled={loading}>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Programmatic Navigation with navigate - RedwoodJS Router API - JavaScript/JSX\nDESCRIPTION: Illustrates imperative routing with the navigate function from '@redwoodjs/router', typically used in event handlers to change the active page. Dependencies include both navigate and routes for route resolution. Input is a function call optionally with an options object; output is a change in browser history and page location. Supports advanced navigation with options like replace or scroll.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\nimport { navigate, routes } from '@redwoodjs/router'\n\nconst SomePage = () => {\n  const onSomeAction = () => {\n    navigate(routes.home())\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Forcing Dependency Re-installation with Yarn\nDESCRIPTION: This command instructs Yarn to forcefully re-fetch and reinstall all package dependencies, replacing any existing ones in the `node_modules` directory. This is particularly useful when switching between branches or if dependency inconsistencies are suspected. `yarn -f` serves as the shorthand for this command.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/contributing-walkthrough.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn install --force\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn -f\n```\n\n----------------------------------------\n\nTITLE: Processing RedwoodJS Jobs Once with workoff (Bash)\nDESCRIPTION: Command to process all currently available background jobs and then stop. `yarn rw jobs workoff` initiates the worker process, executes all jobs that are eligible to run based on their `runAt` time, and then terminates automatically. This is useful for clearing the queue without keeping a persistent worker running.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs workoff\n```\n\n----------------------------------------\n\nTITLE: Customizing Route Path for HomePage in RedwoodJS - JavaScript\nDESCRIPTION: This JavaScript snippet shows how to modify the route path to '/hello', associating it with the HomePage component and the route named 'home'. Use this when changing the homepage URL or for testing alternate paths. Dependencies include proper imports for Route and the existence of HomePage. Only the path property is changed; other logic is unaffected.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/first-page.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/hello\" page={HomePage} name=\"home\" />\n```\n\n----------------------------------------\n\nTITLE: Refactored Article Component with Props (JSX)\nDESCRIPTION: Updates the `Article.jsx` component to accept an `article` object as a prop. It imports `Link` and `routes` from `@redwoodjs/router` to create a link to the individual article's page using its ID. The component displays the article's title, body, and creation timestamp.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-next-line\nconst Article = ({ article }) => {\n  return (\n    // highlight-start\n    <article>\n      <header>\n        <h2>\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div>{article.body}</div>\n      <div>Posted at: {article.createdAt}</div>\n    </article>\n    // highlight-end\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Cell Component (Shell)\nDESCRIPTION: Command to generate a RedwoodJS Cell component, which encapsulates data fetching logic and different display states (Loading, Empty, Failure, Success). Requires a unique `<name>` for the cell. Options allow forcing overwrites, specifying TypeScript, customizing the query name, generating list cells, and controlling test/story generation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate cell <name>\n```\n\n----------------------------------------\n\nTITLE: Overriding Debug Port via CLI Flag\nDESCRIPTION: This Bash command demonstrates how to override the `debugPort` setting specified in `redwood.toml` by passing the `--debugPort` flag directly to the `yarn rw dev` command. Command-line flags take precedence over `redwood.toml` settings.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/project-configuration-dev-test-build.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw dev --debugPort 75028\n```\n\n----------------------------------------\n\nTITLE: Conditionally Rendering Delete Button in RedwoodJS Component (JSX)\nDESCRIPTION: This snippet shows how to use the `useAuth` hook from `src/auth` in a RedwoodJS React component (`Comment.jsx`) to get the `hasRole` function. It then conditionally renders a 'Delete' button only if the currently logged-in user has the 'moderator' role. A placeholder `moderate` function is included for the button's click handler.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { useAuth } from 'src/auth'\n\nconst formattedDate = (datetime) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n\nconst Comment = ({ comment }) => {\n  // highlight-start\n  const { hasRole } = useAuth()\n  const moderate = () => {\n    if (confirm('Are you sure?')) {\n      // TODO: delete comment\n    }\n  }\n  // highlight-end\n\n  return (\n    // highlight-next-line\n    <div className=\"bg-gray-200 p-8 rounded-lg relative\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n      // highlight-start\n      {hasRole('moderator') && (\n        <button\n          type=\"button\"\n          onClick={moderate}\n          className=\"absolute bottom-2 right-2 bg-red-500 text-xs rounded text-white px-2 py-1\"\n        >\n          Delete\n        </button>\n      )}\n      // highlight-end\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL SDL with Authentication Directives - JavaScript\nDESCRIPTION: This enhanced SDL extends the testimonial schema with input types, queries, mutations, and `@requireAuth`/`@skipAuth` directives for access control using RedwoodJS conventions. It outlines which GraphQL operations require authenticated users (mutations) and which are public (query). Place this code in an SDL definition file. Expects the service layer to implement create and delete logic for testimonials. Dependencies include RedwoodJS GraphQL support and appropriate service function implementations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/02_chapter0/what-is-redwood.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nexport const schema = gql`\n  type Testimonial {\n    id: Int!\n    author: String!\n    quote: String!\n    createdAt: DateTime!\n    updatedAt: DateTime!\n  }\n\n  type CreateTestimonialInput {\n    author: String!\n    quote: String!\n  }\n\n  type Query {\n    testimonials: [Testimonial!] @skipAuth\n  }\n\n  type Mutation {\n    createTestimonal($input: CreateTestimonialInput!): Testimonial! @requireAuth\n    deleteTestimonal($id: Int!): Testimonial! @requireAuth\n  }\n`\n\n```\n\n----------------------------------------\n\nTITLE: Updating getCurrentUser to Select Roles in RedwoodJS Auth\nDESCRIPTION: These snippets show how to modify the `getCurrentUser` function in RedwoodJS's authentication logic (`api/src/lib/auth.js` or `api/src/lib/auth.ts`). The change involves adding `roles: true` to the `select` object in the `db.user.findUnique` call, ensuring that the user's roles are fetched along with their ID and email and made available in `currentUser`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nexport const getCurrentUser = async (session) => {\n  if (!session || typeof session.id !== 'number') {\n    throw new Error('Invalid session')\n  }\n\n  return await db.user.findUnique({\n    where: { id: session.id },\n    // highlight-next-line\n    select: { id: true, email: true, roles: true },\n  })\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport const getCurrentUser = async (session) => {\n  return await db.user.findUnique({\n    where: { id: session.id },\n    // highlight-next-line\n    select: { id: true, email: true, roles: true },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Generating GraphQL SDL and Service for Comment Model with RedwoodJS CLI (Bash)\nDESCRIPTION: Uses the RedwoodJS generator command `yarn rw g sdl Comment --no-crud` to scaffold the necessary GraphQL Schema Definition Language (SDL) file and the corresponding service file for the `Comment` model. The `--no-crud` flag ensures only basic query functionality is generated initially, allowing for custom implementation of mutations later.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g sdl Comment --no-crud\n```\n\n----------------------------------------\n\nTITLE: Defining the User Model in Prisma Schema for dbAuth\nDESCRIPTION: This Prisma schema definition (`schema.prisma`) adds a `User` model required for RedwoodJS dbAuth. It includes standard fields like `id`, `name`, `email`, and specific fields for dbAuth: `hashedPassword`, `salt`, `resetToken`, and `resetTokenExpiresAt`. The `email` field is marked as unique. This schema definition is used by Prisma to manage the database structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/db/schema.prisma\"\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = \"native\"\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  body      String\n  createdAt DateTime @default(now())\n}\n\nmodel Contact {\n  id        Int @id @default(autoincrement())\n  name      String\n  email     String\n  message   String\n  createdAt DateTime @default(now())\n}\n\n// highlight-start\nmodel User {\n  id                  Int       @id @default(autoincrement())\n  name                String?\n  email               String    @unique\n  hashedPassword      String\n  salt                String\n  resetToken          String?\n  resetTokenExpiresAt DateTime?\n}\n// highlight-end\n```\n```\n\n----------------------------------------\n\nTITLE: Protecting RedwoodJS Page Markup for a Single Role (JSX)\nDESCRIPTION: This example illustrates protecting specific markup within a RedwoodJS Page component (`SettingsPage`). It uses the `useAuth` hook to check for authentication (`isAuthenticated`) and then uses `hasRole` to conditionally render an 'Edit on Netlify' link only for users with the 'admin' role.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAuth } from \"@redwoodjs/auth\";\\nimport SidebarLayout from \"src/layouts/SidebarLayout\";\\n\\nconst SettingsPage = () => {\\n  const { isAuthenticated, userMetadata, hasRole } = useAuth();\\n\\n  return (\\n    {isAuthenticated && (\\n      <div className=\"ml-4 flex-shrink-0\">\\n        {hasRole(\"admin\") && (\\n          <a\\n            href={`https://app.netlify.com/sites/${process.env.SITE_NAME}/identity/${userMetadata.id}`}\\n            target=\"_blank\"\\n            rel=\"noreferrer\"\\n          >\\n            Edit on Netlify\\n          </a>\\n        )}\\n      </div>\\n    )}\\n  )}\\n}\n```\n\n----------------------------------------\n\nTITLE: Generating CRUD Scaffold for Post Model (Shell)\nDESCRIPTION: This Redwood CLI command auto-generates all front-end and back-end files necessary for CRUD operations on the 'Post' model, including pages, components, and services. It leverages the Prisma schema previously defined and migrated. Required dependencies include a working Redwood project and successful Prisma migration. Generates code under the conventional Redwood structure. The model argument should match the name of the model in 'schema.prisma'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood generate scaffold post\n```\n\n----------------------------------------\n\nTITLE: Securing Routes with Role-Based Access in RedwoodJS - TypeScript (TSX)\nDESCRIPTION: Implements role-based protection on post admin routes using <PrivateSet> in TypeScript/TSX. Only the 'admin' role has access, and all nesting, props, and roles handling are fully type-safe. Redirects non-admin or unauthenticated users to home. Dependencies: RedwoodJS Router, TSX syntax, roles prop handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\n<PrivateSet unauthenticated=\"home\" roles=\"admin\">\n  <Set\n    wrap={ScaffoldLayout}\n    title=\"Posts\"\n    titleTo=\"posts\"\n    buttonLabel=\"New Post\"\n    buttonTo=\"newPost\"\n  >\n    <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n    <Route\n      path=\"/admin/posts/{id:Int}/edit\"\n      page={PostEditPostPage}\n      name=\"editPost\"\n    />\n    <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n    <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\n  </Set>\n</PrivateSet>\n```\n\n----------------------------------------\n\nTITLE: Recreating Prisma Migrations for PostgreSQL - Bash\nDESCRIPTION: Runs the Yarn RedwoodJS command to generate and apply a new set of Prisma migrations compatible with PostgreSQL. This consolidates your data model changes into a single migration file and applies it to the connected Postgres instance via DATABASE_URL. Assumes .env is properly configured with a valid Postgres connection string. Outputs SQL schema changes, and errors if the database is unreachable or credentials are invalid.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/deployment.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Using RedwoodJS Directives on Type Fields and Queries (GraphQL)\nDESCRIPTION: Illustrates applying RedwoodJS directives (`@requireAuth`, `@maskedEmail`) to both regular fields (`email`, `name`) within a GraphQL type (`UserExample`) and to Query fields (`userExamples`, `userExamples(id: Int!)`). This shows how directives can enforce rules (like authentication) or apply transformations (like masking) at different levels of the schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\ntype UserExample {\n  id: Int!\n  email: String! @requireAuth\n  name: String @maskedEmail # 👈 will maskedEmail name in the response!\n}\n\ntype Query {\n userExamples: [UserExample!]! @requireAuth 👈 will enforce auth when fetching all users\n userExamples(id: Int!): UserExample @requireAuth 👈 will enforce auth when fetching a single user\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Create Comment Mutation to GraphQL Schema (TypeScript SDL)\nDESCRIPTION: Updates the GraphQL schema definition in 'api/src/graphql/comments.sdl.ts' (a TypeScript file using `gql`). It mirrors the JavaScript SDL version by adding a `Mutation` type with the `createComment` operation. This mutation requires `CreateCommentInput!` and returns `Comment!`, with `@skipAuth` applied.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_17\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.ts\"\nexport const schema = gql`\n  type Comment {\n    id: Int!\n    name: String!\n    body: String!\n    post: Post!\n    postId: Int!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    comments: [Comment!]! @skipAuth\n  }\n\n  input CreateCommentInput {\n    name: String!\n    body: String!\n    postId: Int!\n  }\n\n  input UpdateCommentInput {\n    name: String\n    body: String\n    postId: Int\n  }\n\n  // highlight-start\n  type Mutation {\n    createComment(input: CreateCommentInput!): Comment! @skipAuth\n  }\n  // highlight-end\n`\n```\n```\n\n----------------------------------------\n\nTITLE: Generating CRUD Scaffold for a Model with RedwoodJS\nDESCRIPTION: Uses the RedwoodJS CLI `generate scaffold` command to automatically create all the necessary frontend and backend components for performing Create, Retrieve, Update, and Delete (CRUD) operations on the specified 'post' model. This includes generating pages, components, SDL (Schema Definition Language), and services.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood generate scaffold post\n```\n\n----------------------------------------\n\nTITLE: Testing RedwoodJS Service Email Sending with Jest in TypeScript\nDESCRIPTION: Demonstrates testing a RedwoodJS service (`contacts`) that sends emails using Jest within a scenario test (`api/src/services/contacts/contacts.test.ts`). It retrieves the mailer's test handler (`InMemoryMailHandler`), asserts that exactly one email was sent (`testHandler.inbox.length`), verifies email metadata (to, from, subject, etc.) using `toMatchInlineSnapshot`, and checks the rendered HTML and text content against Jest snapshots (`toMatchSnapshot`). This relies on the mailer being configured for test mode, often using the `@redwoodjs/mailer-handler-in-memory` package.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/mailer.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=api/src/services/contacts/contacts.test.ts\ndescribe('contacts', () => {\n  scenario('creates a contact', async () => {\n    const result = await createContact({\n      input: { name: 'String', email: 'String', message: 'String' },\n    })\n\n    expect(result.name).toEqual('String')\n    expect(result.email).toEqual('String')\n    expect(result.message).toEqual('String')\n\n    // Mail\n    const testHandler = mailer.getTestHandler() as InMemoryMailHandler\n    expect(testHandler.inbox.length).toBe(1)\n    const sentMail = testHandler.inbox[0]\n    expect({\n      ...sentMail,\n      htmlContent: undefined,\n      textContent: undefined,\n    }).toMatchInlineSnapshot(`\n      {\n        \"attachments\": [],\n        \"bcc\": [],\n        \"cc\": [],\n        \"from\": \"contact-us@example.com\",\n        \"handler\": \"nodemailer\",\n        \"handlerOptions\": undefined,\n        \"headers\": {},\n        \"htmlContent\": undefined,\n        \"renderer\": \"reactEmail\",\n        \"rendererOptions\": {},\n        \"replyTo\": \"String\",\n        \"subject\": \"New Contact Us Submission\",\n        \"textContent\": undefined,\n        \"to\": [\n          \"inbox@example.com\",\n        ],\n      }\n    `)\n    expect(sentMail.htmlContent).toMatchSnapshot()\n    expect(sentMail.textContent).toMatchSnapshot()\n  })\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing useForm Form Methods in RedwoodJS Forms in JavaScript/React\nDESCRIPTION: This snippet shows how to directly use react-hook-form's useForm hook for advanced form control, passing the resulting formMethods to the RedwoodJS Form component. Demonstrated functionality includes using the reset method to clear form fields after successful submission. Requires react-hook-form and @redwoodjs/forms as dependencies. The ContactPage component handles form submission, processes data, and then resets form state. Input: User-submitted form fields; Output: Data logged and form reset upon submit.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useForm } from 'react-hook-form'\n\nconst ContactPage = () => {\n  const formMethods = useForm()\n\n  const onSubmit = (data) => {\n    console.log(data)\n    formMethods.reset()\n  }\n\n  return (\n    <Form formMethods={formMethods} onSubmit={onSubmit}>\n      // Still works!\n      <TextField name=\"name\" validation={{ required: true }}>\n    </Form>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Handling File Uploads in a RedwoodJS Mutation Hook\nDESCRIPTION: Illustrates using the `useMutation` hook from `@redwoodjs/web` to handle form submissions that include file uploads. It defines a GraphQL mutation (`UPDATE_PROFILE_MUTATION`) expecting the `UpdateProfileInput` type (which includes the `File` scalar). The `onSave` function processes the form data, extracts the first file from the `FileField`'s `FileList` output, and passes it to the `updateProfile` mutation function. Redwood's Apollo client automatically handles the GraphQL Multipart Request specification for the upload.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/EditProfile.tsx\"\nimport { useMutation } from '@redwoodjs/web'\n\nconst UPDATE_PROFILE_MUTATION = gql`\n  // This is the Input type we setup with File earlier!\n  // highlight-next-line\n  mutation UpdateProfileMutation($input: UpdateProfileInput!) {\n    updateProfile(input: $input) {\n      firstName\n      lastName\n      // highlight-next-line\n      avatar\n    }\n  }\n`\n\nconst EditProfile = ({ profile }) => {\n  const [updateProfile, { loading, error }] = useMutation(\n    UPDATE_PROFILE_MUTATION,\n    {\n      /*..*/\n    }\n  )\n\n  const onSave = (formData: UpdateProfileInput) => {\n    // We have to extract the first file from the input\n\n    const input = {\n      ...formData,\n      // FileField returns an array, we want the first and only file; Multi-file\n      // uploads are available\n      // highlight-next-line\n      avatar: formData.avatar?.[0],\n    }\n\n    updateProfile({ variables: { input } })\n  }\n\n  return (\n    <ProfileForm\n      profile={profile}\n      onSave={onSave}\n      error={error}\n      loading={loading}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Links to Named Routes with Link and routes Object in RedwoodJS - JSX\nDESCRIPTION: This snippet demonstrates how to generate links to named routes using the Link component and the routes object in RedwoodJS. It imports Link and routes from '@redwoodjs/router', and uses routes.home() to safely create a navigational link. Named route functions help avoid hardcoded URL paths, increasing maintainability. The only dependencies are the RedwoodJS router package and the valid naming of route 'home' elsewhere in the routing configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n\n// Given the route in the last section, this produces: <a href=\"/\">\nconst SomePage = () => <Link to={routes.home()} />\n```\n\n----------------------------------------\n\nTITLE: Navigating, Installing Dependencies, and Starting RedwoodJS Dev Server\nDESCRIPTION: This sequence of commands first changes the current directory to the newly created project folder 'my-redwood-project'. Then, it installs all necessary project dependencies defined in `package.json` using `yarn install`. Finally, it starts the RedwoodJS development server using `yarn redwood dev`, which typically makes the application available at `http://localhost:8910` and watches for file changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd my-redwood-project\nyarn install\nyarn redwood dev\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Directives using CLI (Bash)\nDESCRIPTION: Illustrates using the `yarn redwood generate directive` command to create a custom GraphQL directive. The command prompts the user to select between a Validator type (for checks before resolving) and a Transformer type (for modifying resolved values). The `--type` flag can also be used for non-interactive generation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate directive myDirective\n\n? What type of directive would you like to generate? › - Use arrow-keys. Return to submit.\n❯ Validator - Implement a validation: throw an error if criteria not met to stop execution\nTransformer - Modify values of fields or query responses\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL Database in Prisma Schema - JSX\nDESCRIPTION: This code block is a snippet from a Prisma schema file used in Redwood projects to configure the use of PostgreSQL in production. It specifies the datasource provider as 'postgresql' and retrieves the database connection string from the environment variable 'DATABASE_URL'. Dependencies: Prisma ORM in the Redwood project's API side; requires correct environment variable setup. Expects Prisma to read this configuration at build or migration time; connection string may need to include SSL or pooling details depending on your provider.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/introduction.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\ndatasource db {\\n  provider = \\\"postgresql\\\"\\n  url      = env(\\\"DATABASE_URL\\\")\\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Prisma Migration to Database - Zsh Shell\nDESCRIPTION: Runs a Prisma migration named 'email' to align the database schema with the Prisma models. Dependencies: Prisma CLI, configured database connection, models defined in schema.prisma. Usage: Run from within the RedwoodJS API workspace. Output: Updated database tables and migration files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_3\n\nLANGUAGE: zsh\nCODE:\n```\nyarn rw prisma migrate dev --name email\n```\n\n----------------------------------------\n\nTITLE: Exchanging OAuth Code for Access Token with GitHub (JavaScript)\nDESCRIPTION: Handles POSTing the code received from GitHub's OAuth flow to its access_token endpoint using fetch. Relies on process.env for GITHUB_OAUTH credentials, parses query string parameters, and formats the JSON fetch body accordingly. Returns error responses if GitHub signals an error, otherwise responds with access_token, scope, and error as JSON. Assumes proper environment configuration and query string structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst callback = async (event) => {\n  // highlight-start\n  const { code } = event.queryStringParameters\n\n  const response = await fetch(`https://github.com/login/oauth/access_token`, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      client_id: process.env.GITHUB_OAUTH_CLIENT_ID,\n      client_secret: process.env.GITHUB_OAUTH_CLIENT_SECRET,\n      redirect_uri: process.env.GITHUB_OAUTH_REDIRECT_URI,\n      code,\n    }),\n  })\n\n  const { access_token, scope, error } = JSON.parse(await response.text())\n\n  if (error) {\n    return { statuscode: 400, body: error }\n  }\n\n  return {\n    body: JSON.stringify({ access_token, scope, error }),\n  }\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Validating and Creating Contact Entries in RedwoodJS Service - JavaScript\nDESCRIPTION: This snippet defines the createContact function in a RedwoodJS service file written in JavaScript, which uses the validate function from @redwoodjs/api to enforce an email format check before creating a contact entry in the database. It ensures that no invalid email addresses are accepted at the API level, regardless of client-side validation status. Dependencies include the @redwoodjs/api package for validation and access to the db instance; it expects an object input with an email property and returns the result of db.contact.create.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_23\n\nLANGUAGE: js\nCODE:\n```\n// highlight-next-line\\nimport { validate } from '@redwoodjs/api'\\n\\n// ...\\n\\nexport const createContact = ({ input }) => {\\n  // highlight-next-line\\n  validate(input.email, 'email', { email: true })\\n  return db.contact.create({ data: input })\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema with Role-Based Mutation Access (GraphQL)\nDESCRIPTION: Defines the GraphQL schema for comments, including types, queries, and mutations. The `deleteComment` mutation is secured using the `@requireAuth(roles: \"moderator\")` directive, ensuring only users with the 'moderator' role can execute it. Other operations like fetching comments (`comments`) and creating comments (`createComment`) use `@skipAuth`, allowing public access.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_27\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.js\"\nexport const schema = gql`\n  type Comment {\n    id: Int!\n    name: String!\n    body: String!\n    post: Post!\n    postId: Int!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    comments(postId: Int!): [Comment!]! @skipAuth\n  }\n\n  input CreateCommentInput {\n    name: String!\n    body: String!\n    postId: Int!\n  }\n\n  input UpdateCommentInput {\n    name: String\n    body: String\n    postId: Int\n  }\n\n  type Mutation {\n    createComment(input: CreateCommentInput!): Comment! @skipAuth\n    // highlight-next-line\n    deleteComment(id: Int!): Comment! @requireAuth(roles: \"moderator\")\n  }\n`\n```\n```\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.ts\"\nexport const schema = gql`\n  type Comment {\n    id: Int!\n    name: String!\n    body: String!\n    post: Post!\n    postId: Int!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    comments(postId: Int!): [Comment!]! @skipAuth\n  }\n\n  input CreateCommentInput {\n    name: String!\n    body: String!\n    postId: Int!\n  }\n\n  input UpdateCommentInput {\n    name: String\n    body: String\n    postId: Int\n  }\n\n  type Mutation {\n    createComment(input: CreateCommentInput!): Comment! @skipAuth\n    // highlight-next-line\n    deleteComment(id: Int!): Comment! @requireAuth(roles: \"moderator\")\n  }\n`\n```\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema for Blog Posts with RedwoodJS in TypeScript\nDESCRIPTION: Defines the GraphQL schema for blog posts using RedwoodJS SDL in TypeScript (`posts.sdl.ts`), mirroring the JavaScript SDL but typically providing type support for downstream usage in TypeScript services. It uses the same fields, input types, and authorization directives. Must be paired with TypeScript services that implement resolvers matching these types. Requires RedwoodJS and TypeScript.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/side-quest.md#_snippet_1\n\nLANGUAGE: GraphQL\nCODE:\n```\nexport const schema = gql`\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    posts: [Post!]!\n    post(id: Int!): Post!\n  }\n\n  input CreatePostInput {\n    title: String!\n    body: String!\n  }\n\n  input UpdatePostInput {\n    title: String\n    body: String\n  }\n\n  type Mutation {\n    createPost(input: CreatePostInput!): Post! @requireAuth\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\n    deletePost(id: Int!): Post! @requireAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Creating BlogLayout Component in RedwoodJS (TypeScript)\nDESCRIPTION: Implements a type-safe BlogLayout component using TypeScript, adding prop type definitions for better maintainability. Like the JavaScript version, it provides a standardized header and main section, but explicitly types children as a possible ReactNode. The layout uses Link and routes from '@redwoodjs/router', and is suitable for teams preferring static analysis and strict typing. Dependencies: @redwoodjs/router, React types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\\n\\ntype BlogLayoutProps = {\\n  children?: React.ReactNode\\n}\\n\\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\\n  return (\\n    // highlight-start\\n    <>\\n      <header>\\n        <h1>Redwood Blog</h1>\\n        <nav>\\n          <ul>\\n            <li>\\n              <Link to={routes.about()}>About</Link>\\n            </li>\\n          </ul>\\n        </nav>\\n      </header>\\n      <main>{children}</main>\\n    </>\\n    // highlight-end\\n  )\\n}\\n\\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Typing Cell Success Props with CellSuccessProps in TypeScript\nDESCRIPTION: Explains how to use the `CellSuccessProps` utility type from `@redwoodjs/web` to strongly type the props passed to a Redwood Cell's `Success` component. It takes generic arguments for the query data type (`TData`) and query variables type (`TVariables`), ensuring both the fetched data and Apollo Client's `queryResult` are typed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport type {\n  FindBlogPostQuery,\n  FindBlogPostQueryVariables,\n} from 'types/graphql'\n\n// highlight-next-line\nimport type { CellSuccessProps } from '@redwoodjs/web'\n\n// ...\n\n// highlight-next-line\ntype SuccessProps = CellSuccessProps<\n  FindBlogPostQuery,\n  FindBlogPostQueryVariables\n>\n\nexport const Success = ({\n  blogPost, // From the query. This is typed of course\n  queryResult, // 👈 From Apollo Client. This is typed too!\n  // highlight-next-line\n}: SuccessProps) => {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking RedwoodJS GraphQL Mutation in Storybook (JS/TS)\nDESCRIPTION: Storybook configuration for the `CommentForm` component demonstrating mutation mocking. It uses `mockGraphQLMutation` from RedwoodJS testing utilities to intercept the `CreateCommentMutation`. The mock function receives mutation variables and context (`ctx`), simulates a network delay using `ctx.delay`, and returns a mock response object matching the expected GraphQL schema. This enables testing the form's behavior, including loading states, in isolation. The TSX version includes generic types for `mockGraphQLMutation` for enhanced type safety.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/CommentForm/CommentForm.stories.jsx\"\nimport CommentForm from './CommentForm'\n\nexport const generated = () => {\n  // highlight-start\n  mockGraphQLMutation('CreateCommentMutation', (variables, { ctx }) => {\n    const id = Math.floor(Math.random() * 1000)\n    ctx.delay(1000)\n\n    return {\n      createComment: {\n        id,\n        name: variables.input.name,\n        body: variables.input.body,\n        createdAt: new Date().toISOString(),\n      },\n    }\n  })\n  // highlight-end\n\n  return <CommentForm />\n}\n\nexport default { title: 'Components/CommentForm' }\n```\n```\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/CommentForm/CommentForm.stories.tsx\"\nimport CommentForm from './CommentForm'\n\n// highlight-start\nimport type {\n  CreateCommentMutation,\n  CreateCommentMutationVariables,\n} from 'types/graphql'\n// highlight-end\n\nexport const generated = () => {\n  // highlight-start\n  mockGraphQLMutation<CreateCommentMutation, CreateCommentMutationVariables>(\n    'CreateCommentMutation',\n    (variables, { ctx }) => {\n      const id = Math.floor(Math.random() * 1000)\n      ctx.delay(1000)\n\n      return {\n        createComment: {\n          id,\n          name: variables.input.name,\n          body: variables.input.body,\n          createdAt: new Date().toISOString(),\n        },\n      }\n    }\n  )\n  // highlight-end\n\n  return <CommentForm />\n}\n\nexport default { title: 'Components/CommentForm' }\n```\n```\n\n----------------------------------------\n\nTITLE: Structuring Jest Tests with Nested Describes and beforeEach in RedwoodJS (JSX)\nDESCRIPTION: This snippet showcases a Jest test suite structure for a `HomePage` component using nested `describe` blocks. It utilizes a `beforeEach` hook within the 'log in' describe block to mock a logged-in user using `mockCurrentUser` and render the component before each test in that block, reducing setup duplication. The tests assert the presence or absence of elements like the login button and a welcome message based on the mocked user state.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_30\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\ndescribe('HomePage', () => {\n  describe('logged out', () => {\n    it('renders a login button when logged out', () => {\n      render(<HomePage />)\n\n      expect(screen.getByRole('button', { name: 'Login' })).toBeInTheDocument()\n    })\n  })\n\n  describe('log in', () => {\n    beforeEach(() => {\n      mockCurrentUser({ name: 'Rob' })\n\n      render(<HomePage />)\n    })\n\n    it('does not render a login button when logged in', async () => {\n      await waitFor(() => {\n        expect(\n          screen.queryByRole('button', { name: 'Login' })\n        ).not.toBeInTheDocument()\n      })\n    })\n\n    it('renders a welcome message when logged in', async () => {\n      expect(await screen.findByText('Welcome back Rob')).toBeInTheDocument()\n    })\n  })\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Blog Layout with RedwoodJS in TypeScript\nDESCRIPTION: This React component implements a blog layout using RedwoodJS, integrating routing, authentication, and user interaction. It defines navigation links, login/logout functionality, and displays the authenticated user's email, with styling provided via Tailwind CSS classes. It depends on '@redwoodjs/router', '@redwoodjs/web/toast', and a custom 'useAuth' hook, taking an optional 'children' prop for rendering nested content. Inputs include authentication state, and outputs the composed layout with navigation and responsive styles.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\\n// highlight-next-line\\nimport { Toaster } from '@redwoodjs/web/toast'\\n\\nimport { useAuth } from 'src/auth'\\n\\ntype BlogLayoutProps = {\\n  children?: React.ReactNode\\n}\\n\\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\\n  const { logOut, isAuthenticated, currentUser } = useAuth()\\n\\n  return (\\n    <>\\n      // highlight-next-line\\n      <Toaster />\\n      <header className=\"relative flex justify-between items-center py-4 px-8 bg-blue-700 text-white\">\\n        <h1 className=\"text-5xl font-semibold tracking-tight\">\\n          <Link\\n            className=\"text-blue-400 hover:text-blue-100 transition duration-100\"\\n            to={routes.home()}\\n          >\\n            Redwood Blog\\n          </Link>\\n        </h1>\\n        <nav>\\n          <ul className=\"relative flex items-center font-light\">\\n            <li>\\n              <Link\\n                className=\"py-2 px-4 hover:bg-blue-600 transition duration-100 rounded\"\\n                to={routes.about()}\\n              >\\n                About\\n              </Link>\\n            </li>\\n            <li>\\n              <Link\\n                className=\"py-2 px-4 hover:bg-blue-600 transition duration-100 rounded\"\\n                to={routes.contact()}\\n              >\\n                Contact\\n              </Link>\\n            </li>\\n            <li>\\n              {isAuthenticated ? (\\n                <div>\\n                  <button type=\"button\" onClick={logOut} className=\"py-2 px-4\">\\n                    Logout\\n                  </button>\\n                </div>\\n              ) : (\\n                <Link to={routes.login()} className=\"py-2 px-4\">\\n                  Login\\n                </Link>\\n              )}\\n            </li>\\n          </ul>\\n          {isAuthenticated && (\\n            <div className=\"absolute bottom-1 right-0 mr-12 text-xs text-blue-300\">\\n              {currentUser.email}\\n            </div>\\n          )}\\n        </nav>\\n      </header>\\n      <main className=\"max-w-4xl mx-auto p-12 bg-white shadow rounded-b\">\\n        {children}\\n      </main>\\n    </>\\n  )\\n}\\n\\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Refactored Test Suite for ArticlesCell (TSX)\nDESCRIPTION: A comprehensive test suite for the `ArticlesCell` component in TSX (TypeScript), mirroring the JSX version. It includes tests for Loading, Empty, Failure, and an improved Success state test that dynamically checks for truncation (absence of full body, presence of partial body and ellipsis).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\nimport { render, screen, within } from '@redwoodjs/testing'\n\nimport { Loading, Empty, Failure, Success } from './ArticlesCell'\nimport { standard } from './ArticlesCell.mock'\n\ndescribe('ArticlesCell', () => {\n  test('Loading renders successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  test('Empty renders successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  test('Failure renders successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  test('Success renders successfully', async () => {\n    const articles = standard().articles\n    render(<Success articles={articles} />)\n\n    // highlight-start\n    articles.forEach((article) => {\n      const truncatedBody = article.body.substring(0, 10)\n      const matchedBody = screen.getByText(truncatedBody, { exact: false })\n      const ellipsis = within(matchedBody).getByText('...', { exact: false })\n\n      expect(screen.getByText(article.title)).toBeInTheDocument()\n      expect(screen.queryByText(article.body)).not.toBeInTheDocument()\n      expect(matchedBody).toBeInTheDocument()\n      expect(ellipsis).toBeInTheDocument()\n    })\n    // highlight-end\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Typed Route Parameters and Multiple Route Matches - RedwoodJS - JSX\nDESCRIPTION: Shows how to define route parameters with automatic type conversion by adding a colon and type (e.g., :Int) to parameter names. Enables numeric and string route distinctions and ensures correct props are passed to target pages. Inputs: URLs conforming to specified types; outputs: props with values converted (e.g., as number for :Int).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/user/{id:Int}\" page={UserPage} name=\"user\" />\n```\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/user/{id:Int}\" page={UserIntPage} name=\"userInt\" />\n<Route path=\"/user/{id}\" page={UserStringPage} name=\"userString\" />\n```\n\n----------------------------------------\n\nTITLE: Simulating GraphQL Errors with mockGraphQLQuery (JavaScript/JSX)\nDESCRIPTION: This snippet shows how to simulate a GraphQL error response using `mockGraphQLQuery`. The callback function receives a second argument, an object containing context information, from which `ctx` can be destructured. Calling `ctx.errors()` with an array of error objects instructs the mock to return an error state instead of data, allowing testing of component error handling logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\nmockGraphQLQuery('getArticle', (variables, { ctx }) => {\n  ctx.errors([{ message: 'Error' }])\n})\n```\n\n----------------------------------------\n\nTITLE: Calling toast Variants for Success and Error Notifications - RedwoodJS - JSX\nDESCRIPTION: This snippet illustrates usage of the toast.success and toast.error variant functions to display styled success and error notifications after a GraphQL mutation completes. The component demonstrates the onCompleted and onError callbacks of the useMutation hook, providing distinct messages for each outcome. Required dependencies are @redwoodjs/web/toast and the GraphQL mutation setup. The user receives styled feedback based on the result of their action. Callback parameters and mutation options are key to its operation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/toast-notifications.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { toast } from '@redwoodjs/web/toast'\\n\\n// ...\\n\\nconst PostForm = () => {\\n  const [create, { loading, error }] = useMutation(CREATE_POST_MUTATION, {\\n    onCompleted: () => {\\n      // highlight-next-line\\n      toast.success('Post created')\\n    }\\n    onError: () => {\\n      // highlight-next-line\\n      toast.error('Error creating post')\\n    }\\n  })\\n\\n  const onSubmit = (data) => {\\n    create({ variables: { input: data }})\\n  }\\n\\n  return (\\n    // <Form onSubmit={onSubmit}> ... </Form>\\n  )\\n})\\n\\nexport default PostForm\n```\n\n----------------------------------------\n\nTITLE: Adding Loading and Error State to Contact Form - RedwoodJS - TypeScript\nDESCRIPTION: This TypeScript code enhances the ContactPage component by destructuring loading and error from the result of useMutation, fully typed with CreateContactMutation and CreateContactMutationVariables. This provides the ability to check mutation progress and display feedback or disable actions accordingly. Dependencies include RedwoodJS, typed GraphQL, and the mutation. Used together with form state logic, it prepares the ground for UI/UX enhancements on submission.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\n// ...\n\nconst ContactPage = () => {\n  // highlight-next-line\n  const [create, { loading, error }] = useMutation<\n    CreateContactMutation,\n    CreateContactMutationVariables\n  >(CREATE_CONTACT)\n\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (...)\n}\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Open RedwoodJS Console - Bash\nDESCRIPTION: Starts the RedwoodJS interactive console, allowing developers to run database operations and commands. Also highlights that 'yarn rw c' is a valid shortcut to launch the console. Dependency: RedwoodJS CLI. Allows for direct manipulation of the database (e.g., updating roles).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw c\n```\n\n----------------------------------------\n\nTITLE: Initializing Redwood Data Migration Environment - Bash\nDESCRIPTION: Shows the command to initialize the data migration system, which updates schema.prisma and generates migration directories/scripts. Dependencies: Redwood CLI, Prisma. Input: Command. Output: Migrations setup in project. Limitation: Must run before using 'up'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood data-migrate install\n```\n\n----------------------------------------\n\nTITLE: Creating a New Comment with Specific postId Using Prisma in Redwood Console (Bash)\nDESCRIPTION: This command creates a new comment associated with a specific post by calling 'create' on Prisma's 'comment' model with the required data fields: 'name', 'body', and 'postId'. It returns the newly created comment object including its unique 'id' and timestamp. Inputs include the commenter's name, body content, and target 'postId'; output is the full comment record.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ndb.comment.create({ data: { name: 'Peter', body: 'I also like leaving comments', postId: 2 } })\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Handler CORS with Credentials in RedwoodJS (JavaScript/TypeScript)\nDESCRIPTION: This snippet configures CORS with credentials for the RedwoodJS GraphQL handler by adding both 'origin' and 'credentials: true' to the CORS option. This allows cross-origin requests from the specified domain to include cookies or HTTP authentication in requests. Required files are in 'api/src/functions/graphql.js' or 'graphql.ts'. The configuration targets web clients that need to authenticate with cookie-based systems such as dbAuth. Outputs are GraphQL responses with correct CORS and credential headers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cors.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\nexport const handler = createGraphQLHandler({\\n  loggerConfig: { logger, options: {} },\\n  directives,\\n  sdls,\\n  services,\\n+ cors: {\\n+   origin: 'https://www.example.com', // <-- web side domain\\n+   credentials: true,\\n+ },\\n  onException: () => {\\n    db.$disconnect()\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Worker Groups in JobManager JavaScript\nDESCRIPTION: This code shows the `workers` array within the `JobManager` configuration. Each object in the array defines a worker group. This example configures a single group using the 'prisma' adapter, logging via `logger`, watching all queues (`*`), running 1 worker (`count: 1`), and setting various operational parameters like `maxAttempts`, `maxRuntime`, `deleteFailedJobs`, `deleteSuccessfulJobs`, and `sleepDelay`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nexport const jobs = new JobManager({\n  // .. more config\n  workers: [\n    {\n      adapter: 'prisma',\n      logger,\n      queue: '*',\n      count: 1,\n      maxAttempts: 24,\n      maxRuntime: 14_400,\n      deleteFailedJobs: true,\n      deleteSuccessfulJobs: false,\n      sleepDelay: 5,\n    },\n  ],\n\n})\n```\n\n----------------------------------------\n\nTITLE: Example Azure AD B2C Environment Configuration for .env.example - Bash\nDESCRIPTION: This is a complete illustrative .env.example for Azure AD B2C, showing realistic tenant data for demonstration (not for production use). The example includes the authority, JWT issuer, and known authority endpoints needed for B2C flows, using sample GUIDs and identifiers. Developers should use their own actual Azure tenant and user flow identifiers when configuring production apps.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/azure.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nAZURE_ACTIVE_DIRECTORY_AUTHORITY=https://rwauthtestb2c.b2clogin.com/rwauthtestb2c.onmicrosoft.com/B2C_1_signupsignin1\nAZURE_ACTIVE_DIRECTORY_JWT_ISSUER=https://rwauthtestb2c.b2clogin.com/775527ef-8a37-4307-8b3d-cc311f58d922/v2.0/\nAZURE_ACTIVE_DIRECTORY_KNOWN_AUTHORITY=https://rwauthtestb2c.b2clogin.com\n```\n\n----------------------------------------\n\nTITLE: Assigning User ID to New Post via Context in RedwoodJS Service (JavaScript)\nDESCRIPTION: This snippet extends the post creation service to include the ID of the currently logged-in user by extracting it from the `context.currentUser` object. When creating a post, the service merges the user ID with the form input, preventing manual setting of userId from the frontend. This approach requires user authentication to populate `context.currentUser` and is secure because userId assignment is enforced server-side.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    // highlight-next-line\n    data: { ...input, userId: context.currentUser.id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Additional Fastify Plugins in Redwood Server File\nDESCRIPTION: This TypeScript snippet shows how to register additional Fastify plugins directly onto the server instance returned by `createServer`. This registration happens after the `createServer` call and outside the `configureApiServer` option, suitable for plugins that don't need to be configured before the core Redwood API plugin.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = await createServer({\n  logger,\n})\n\n// highlight-next-line\nserver.register(myFastifyPlugin)\n```\n\n----------------------------------------\n\nTITLE: Using Standard Mock with Spread Syntax in Storybook (JavaScript/JSX)\nDESCRIPTION: Demonstrates how to use the spread syntax to pass all properties of the standard mock to the Success component in a JavaScript/JSX Storybook story. Relies on importing the 'standard' mock and Success components, returning the Success component with mock props. This provides a concise way to simulate a successful GraphQL query result.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Success } from './ArticlesCell'\\nimport { standard } from './ArticlesCell.mock'\\n\\nexport const success = () => {\\n  // highlight-next-line\\n  return Success ? <Success {...standard()} /> : null\\n}\\n\\nexport default { title: 'Cells/ArticlesCell' }\n```\n\n----------------------------------------\n\nTITLE: Making Standard Mock Robust to Missing Variables (JavaScript/JSX)\nDESCRIPTION: This modified `standard` mock function adds checks to ensure `variables` exists before accessing its properties (e.g., `variables?.id`, `variables && variables.status`). This prevents errors when the mock is called directly in tests without passing variables, providing default values or logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_44\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {4,15} title=\"web/src/components/ArticleCell/ArticleCell.mock.js\"\nexport const standard = (variables) => {\n  return {\n    product: {\n      __typename: 'Product',\n      id: variables?.id || 1,\n      name: 'T-shirt',\n      inventory: variables && variables.status === 'instock' ? 100 : 0\n    }\n  }\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Setting up TailwindCSS in RedwoodJS (bash)\nDESCRIPTION: This snippet runs Redwood's setup command to install TailwindCSS and its peer dependencies, automatically generating the tailwind.config.js file. This setup is necessary for styling and integrating Tremor's UI components. Runs within the RedwoodJS root directory using Yarn.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup ui tailwindcss\n```\n\n----------------------------------------\n\nTITLE: Viewing RedwoodJS Project Structure (TypeScript)\nDESCRIPTION: Displays the standard directory layout for a RedwoodJS project configured for TypeScript. It mirrors the JavaScript structure but uses TypeScript file extensions (`.ts`, `.tsx`) for relevant files like `graphql.ts`, `auth.ts`, `seed.ts`, `App.tsx`, and `Routes.tsx`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/file-structure.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n├── api\n│   ├── db\n│   │   └── schema.prisma\n│   └── src\n│       ├── directives\n│       │   ├── requireAuth\n│       │   └── skipAuth\n│       ├── functions\n│       │   └── graphql.ts\n│       ├── graphql\n│       ├── lib\n│       │   ├── auth.ts\n│       │   ├── db.ts\n│       │   └── logger.ts\n│       └── services\n│\n├── scripts\n│   └── seed.ts\n│\n└── web\n    ├── public\n    │   ├── favicon.png\n    │   ├── README.md\n    │   └── robots.txt\n    └── src\n        ├── components\n        ├── layouts\n        ├── pages\n        │   ├── FatalErrorPage\n        │   │   └── FatalErrorPage.tsx\n        │   └── NotFoundPage\n        │       └── NotFoundPage.tsx\n        ├── App.tsx\n        ├── entry.client.tsx\n        ├── index.css\n        ├── index.html\n        └── Routes.tsx\n```\n\n----------------------------------------\n\nTITLE: Styling FieldError Component with className (JavaScript)\nDESCRIPTION: Demonstrates how to apply CSS styling to the `<FieldError>` component in a RedwoodJS form using the `className` prop. This example adds `className=\"error\"` to each `<FieldError>`, assuming an `.error` class is defined in the project's CSS (e.g., `index.css`) to visually distinguish the error messages.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"name\" className=\"error\" />\n\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"email\" className=\"error\" />\n\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Enhancing Article Rendering in Success Component (JavaScript/JSX)\nDESCRIPTION: Updates the `Success` component in `ArticlesCell.jsx`. It iterates over the `articles` array and renders each article within an `<article>` tag, displaying the `title`, `body`, and `createdAt` fields in a more structured and readable HTML format using JSX.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_24\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Success = ({ articles }) => {\n  return (\n    // highlight-start\n    <>\n      {articles.map((article) => (\n        <article key={article.id}>\n          <header>\n            <h2>{article.title}</h2>\n          </header>\n          <p>{article.body}</p>\n          <div>Posted at: {article.createdAt}</div>\n        </article>\n      ))}\n    </>\n    // highlight-end\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RedwoodJS Cell Success Component (JSX/TSX)\nDESCRIPTION: This demonstrates the structure of the `Success` component within a RedwoodJS cell. It receives data via props (e.g., `articles`) and renders UI based on that data, mapping over the articles to display each one using an `Article` component. The highlighted `articles` prop directly corresponds to the key used in the mock data definition (`standard().articles`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\n// highlight-next-line\nexport const Success = ({ articles }) => {\n  return (\n    { articles.map((article) => <Article article={article} />) }\n  )\n}\n```\n```\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nexport const Success = ({\n  // highlight-next-line\n  articles,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\n  return\n  {\n    articles.map((article) => <Article article={article} />)\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Prisma Schema for PostgreSQL (GraphQL)\nDESCRIPTION: Defines the Prisma schema (`api/db/prisma.schema`) for a RedwoodJS application. It sets the database provider to `postgresql`, retrieves the connection string from the `DATABASE_URL` environment variable, configures the Prisma client generator, and defines a `UserExample` model with an auto-incrementing ID, a unique email, and an optional name.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = \"native\"\n}\n\nmodel UserExample {\n  id    Int     @id @default(autoincrement())\n  email String  @unique\n  name  String?\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Routes for Home and NotFound Pages in RedwoodJS - JavaScript\nDESCRIPTION: This JavaScript snippet sets up application routes in 'web/src/Routes.jsx' using RedwoodJS's Router and Route components. It defines the root path ('/') to render the HomePage component, and includes a fallback NotFoundPage route. Make sure '@redwoodjs/router' is installed. Inputs include navigation paths, and outputs are the respective page components rendered on navigation. Ensure HomePage and NotFoundPage exist to avoid runtime errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/first-page.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route } from '@redwoodjs/router'\n\nconst Routes = () => {\n  return (\n    <Router>\n      // highlight-next-line\n      <Route path=\"/\" page={HomePage} name=\"home\" />\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Enabling GraphQL Request ID Logging in TypeScript\nDESCRIPTION: Sets up the `createGraphQLHandler` using `loggerConfig` to include the request identifier in logs by enabling the `options.requestId` flag. This uses the `requestId` from the event if available (e.g., from AWS API Gateway/Lambda) or generates a UUID, aiding in tracing requests through infrastructure. Requires a `logger` instance.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_46\n\nLANGUAGE: jsx\nCODE:\n```\n// ...\nexport const handler = createGraphQLHandler({\n  loggerConfig: { logger, options: { requestId: true } },\n// ...\n```\n\n----------------------------------------\n\nTITLE: Prerendering a Not Found (404) Page in RedwoodJS (JavaScript/JSX Diff)\nDESCRIPTION: Demonstrates how to enable prerendering for the NotFoundPage (the 404 page) by adding the 'prerender' prop. When built, this will output a '404.html' in the distribution directory. No path parameter is required for this usage.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n-      <Route notfound page={NotFoundPage} />\n+      <Route notfound page={NotFoundPage} prerender/>\n```\n\n----------------------------------------\n\nTITLE: Example Object Illustrating Cache Serialization (JavaScript)\nDESCRIPTION: Provides a simple JavaScript object example containing a `Date` object. This illustrates that complex objects like Dates are serialized (typically to strings) when stored in the cache, which is relevant when writing cache tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_75\n\nLANGUAGE: js\nCODE:\n```\n{\n  id: 5,\n  published: new Date('12/10/1995')\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating a Cell with Redwood CLI (Bash)\nDESCRIPTION: This Bash snippet shows how to use the RedwoodJS CLI to generate a new Cell. It creates a directory and boilerplate files for the Cell, including test, story, and mock files. Required dependency is RedwoodJS CLI (rw). The <name> argument specifies the Cell to generate; running this will scaffold code in the web/src/components directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw generate cell <name>\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL SDL for Contact Resource with Auth Directives (RedwoodJS, JavaScript)\nDESCRIPTION: This JavaScript code snippet exports a GraphQL schema definition for the Contact model, specifying types, input objects, and queries/mutations using RedwoodJS conventions. It uses schema directives like @requireAuth to require authentication for queries/mutations, and includes input types for creating and updating contacts. This SDL is required to enable GraphQL queries and mutations for the Contact entity, and relies on the gql tag and RedwoodJS GraphQL tooling. Inputs must match the shape expected by the service layer, and fields marked with ! are required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\\n  type Contact {\\n    id: Int!\\n    name: String!\\n    email: String!\\n    message: String!\\n    createdAt: DateTime!\\n  }\\n\\n  type Query {\\n    contacts: [Contact!]! @requireAuth\\n    contact(id: Int!): Contact @requireAuth\\n  }\\n\\n  input CreateContactInput {\\n    name: String!\\n    email: String!\\n    message: String!\\n  }\\n\\n  input UpdateContactInput {\\n    name: String\\n    email: String\\n    message: String\\n  }\\n\\n  type Mutation {\\n    createContact(input: CreateContactInput!): Contact! @requireAuth\\n    updateContact(id: Int!, input: UpdateContactInput!): Contact! @requireAuth\\n    deleteContact(id: Int!): Contact! @requireAuth\\n  }\\n`\n```\n\n----------------------------------------\n\nTITLE: Refactoring hasRole Logic for String Role Types - TypeScript\nDESCRIPTION: Updates the hasRole function to remove type checks for array role storage due to roles now being a string. Ensures proper authorization checks by supporting both string and array comparisons for roles. Dependency: TypeScript, RedwoodJS context/currentUser structure. Roles are checked via strict equality for strings; arrays are still supported for authorization guards.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport const hasRole = (roles: AllowedRoles): boolean => {\n  if (!isAuthenticated()) {\n    return false\n  }\n\n  const currentUserRoles = context.currentUser?.roles\n\n  if (typeof roles === 'string') {\n    if (typeof currentUserRoles === 'string') {\n      // roles to check is a string, currentUser.roles is a string\n      return currentUserRoles === roles\n    }\n  }\n\n  if (Array.isArray(roles)) {\n    if (Array.isArray(currentUserRoles)) {\n      // roles to check is an array, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) =>\n        roles.includes(allowedRole)\n      )\n    } else if (typeof currentUserRoles === 'string') {\n      // roles to check is an array, currentUser.roles is a string\n      return roles.some((allowedRole) => currentUserRoles === allowedRole)\n    }\n  }\n\n  // roles not found\n  return false\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Redwood Version and Current User via GraphQL - GraphQL\nDESCRIPTION: This snippet demonstrates a simple GraphQL query to retrieve the Redwood API version and current user by querying the root redwood type. Intended for testing and exploring the redwood GraphQL API, it requires a running RedwoodJS server and access to the GraphQL Playground. Inputs are the root-level query, and outputs include the version and the currentUser object as JSON. There are no complex parameters or constraints but assumes that the root schema is defined and resolves currentUser in context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_15\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  redwood {\n    version\n    currentUser\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic User Query Service Implementation - RedwoodJS - JSX\nDESCRIPTION: Implements a basic GraphQL resolver for fetching all users via Prisma inside a RedwoodJS service file. Dependencies: Prisma client (imported as db). Returns a list of users from the database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { db } from 'src/lib/db'\\n\\nexport const users = () => {\\n  return db.user.findMany()\\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RedwoodJS/Netlify Function Handler with Callbacks (JavaScript)\nDESCRIPTION: This snippet shows how to define a serverless function handler in RedwoodJS using the callback pattern, common in older Node.js or specific Lambda runtimes. The handler checks if the HTTP method is GET; if not, it calls back with a 404 status. Otherwise, it calls back successfully (first argument `null`) with a 200 status, JSON content type header, and the current server time stringified in the body. This contrasts with the preferred `async/await` syntax and is generally discouraged due to potential complexity.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nexport const handler = (event, context, callback) => {\n  if (event.httpMethod !== 'GET') {\n    callback(null, { statusCode: 404 })\n  }\n\n  callback(null, {\n    statusCode: 200,\n    headers: { 'Content-Type': 'application/json ' },\n    body: JSON.stringify({ time: new Date() }),\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Skip Link Targets with contentId and id Props - RedwoodJS - JavaScript/React\nDESCRIPTION: Demonstrates how to change target identifiers of skip navigation links for more precise control over skip destinations. By setting contentId on SkipNavLink and id on SkipNavContent to the same value, developers can direct the skip link to a specific part of the page. No dependencies beyond '@redwoodjs/router'. Useful in layouts with multiple main content areas or deep navigation trees.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/a11y.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<SkipNavLink contentId=\"main-content\" />\n{/* ... */}\n<SkipNavContent id=\"main-content\" />\n```\n\n----------------------------------------\n\nTITLE: Testing the Logged-Out State of an Auth-Aware Component (JSX)\nDESCRIPTION: This test verifies the behavior of the `HomePage` component when no user is logged in (the default state). It uses `render` from `@redwoodjs/testing/web` to mount the component and `screen.getByRole` from React Testing Library to assert that a button element with the accessible name 'Login' exists in the rendered output. This confirms the component correctly displays the login prompt for unauthenticated users.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_26\n\nLANGUAGE: jsx\nCODE:\n```\nimport { render, screen } from '@redwoodjs/testing/web'\nimport HomePage from './HomePage'\n\ndescribe('HomePage', () => {\n  it('renders a login button', () => {\n    render(<HomePage />)\n\n    expect(screen.getByRole('button', { name: 'Login' })).toBeInTheDocument()\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Serverless Functions via CLI\nDESCRIPTION: This command scaffolds a serverless function file within the `api/src/functions` directory, intended for deployment to serverless platforms like AWS Lambda. It requires the function's name as an argument. Options allow forcing overwrite (`--force`), generating TypeScript files (`--typescript`), and rolling back on error (`--rollback`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate function <name>\n```\n\n----------------------------------------\n\nTITLE: Switching Active Node.js Version with nvm\nDESCRIPTION: This command tells nvm to switch the currently active Node.js version in the shell session to the specified version. Replace `<version number>` with the desired, already installed Node.js version (e.g., '16.14.0'). Note that Redwood has specific version requirements.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnvm use <version number>\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Data Migration Script (Shell)\nDESCRIPTION: Command to generate a data migration script file within the `api/db/dataMigrations` directory. Requires a `<name>` for the migration, which will be automatically prefixed with a timestamp upon generation. Used for managing database schema changes or data transformations that require custom logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_38\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood generate dataMigration <name>\n```\n\n----------------------------------------\n\nTITLE: Example Response for Deferred Fast Field - JSON\nDESCRIPTION: JSON response showing instant delivery of the fast field before deferred fields are ready. Contains data only for `fastField`. Generated as part of a deferred GraphQL query. No dependencies; output only.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\": {\n    \"fastField\": \"I am speedy\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Coercing SelectField Value to Number with React SelectField (JSX)\nDESCRIPTION: This snippet shows how to use the valueAsNumber validation option to coerce a selected option's value from a string to an integer in a <SelectField> component. Each <option> is given a numerical value, and when an option is selected, the field returns its value as an integer. This setup is useful when working with numeric identifiers, with the output reflecting the selected number. Requires a form system supporting valueAsNumber.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n<SelectField name=\\\"select\\\" validation={{ valueAsNumber: true }}>\n  <option value={1}>Option 1</option>\n  <option value={2}>Option 2</option>\n  <option value={3}>Option 3</option>\n</SelectField>\n```\n\n----------------------------------------\n\nTITLE: Configuring Notifications in redwood.toml - TOML\nDESCRIPTION: Establishes notification preferences in the [notifications] section, so the Redwood framework can alert about new version updates. The versionUpdates array accepts version tags, e.g., latest, tailoring which releases trigger notifications. Requires no external dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\n[notifications]\n  versionUpdates = [\"latest\"]\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Contact Creation Mutation with RedwoodJS (JavaScript, JSX)\nDESCRIPTION: This snippet defines a GraphQL mutation named CreateContactMutation using the gql template string in a RedwoodJS application. It can be placed outside of the component, after imports, and prepares the mutation for later use by the contact form. No dependencies are required beyond RedwoodJS and a GraphQL backend. The mutation expects an input of type CreateContactInput and returns the id of the created contact. Input should contain name, email, and message. Limitations may depend on backend SDL definition.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\n// highlight-start\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n// highlight-end\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Generated Quote Page with Route Param - RedwoodJS - JavaScript (JSX)\nDESCRIPTION: This JSX file is generated for a page with a route parameter ({id}). It uses RedwoodJS's router imports, expects a prop named 'id', and displays a placeholder showing the file's location with comments explaining the route naming convention. No additional dependencies beyond RedwoodJS. Inputs: prop 'id'. Outputs: JSX displaying page and id. Limitations: must correspond to matching route in Routes.js.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_62\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n\nconst QuotePage = ({ id }) => {\n  return (\n    <>\n      <h1>QuotePage</h1>\n      <p>Find me in \"./web/src/pages/QuotePage/QuotePage.js\"</p>\n      {/*\n        My default route is named \"quote\", link to me with `\n        <Link to={routes.quote({ id: 42 })}>Quote 42</Link>`\n        The parameter passed to me is {id}\n      */}\n    </>\n  )\n}\n\nexport default QuotePage\n```\n\n----------------------------------------\n\nTITLE: Cleaning up Boilerplate Code in ArticlePage.tsx (TypeScript/Diff)\nDESCRIPTION: Shows the removal of the unused import for `Link` and `routes`, and the commented-out boilerplate `Link` component from the generated `ArticlePage.tsx`. This fixes an error caused by the boilerplate link missing the required `id` parameter.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\ntitle=\"web/src/pages/ArticlePage.tsx\"\n- import { Link, routes } from '@redwoodjs/router'\n  import { Metadata } from '@redwoodjs/web'\n\n  const ArticlePage = () => {\n    return (\n      <>\n        <Metadata title=\"Article\" description=\"Article page\" />\n\n        <h1>ArticlePage</h1>\n        <p>\n          Find me in <code>./web/src/pages/ArticlePage/ArticlePage.tsx</code>\n        </p>\n        {/*\n          My default route is named <code>article</code>, link to me with `\n          <Link to={routes.article()}>Article</Link>`\n        */}\n      </>\n    )\n  }\n\n  export default ArticlePage\n```\n\n----------------------------------------\n\nTITLE: Overriding Empty Field Values with emptyAs Prop (JSX fragment)\nDESCRIPTION: Provides configuration samples for NumberField components in RedwoodJS forms, demonstrating use of the emptyAs prop to explicitly control the value submitted for empty fields. Shows how to convert empty fields to undefined or null, overriding default coercion behaviors. Applicable in cases where backend expects specific empty value representations, requiring only RedwoodJS forms setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n<NumberField name=\"quantity\" emptyAs=\"undefined\" />\n<NumberField name=\"score\" emptyAs={null} />\n```\n\n----------------------------------------\n\nTITLE: Prerendering Private Routes with whileLoadingAuth in RedwoodJS (JavaScript/JSX)\nDESCRIPTION: Explains how to prerender routes behind authentication by using the 'whileLoadingAuth' prop. The sample shows a PrivateSet with a protected Route and a loading skeleton. The 'whileLoadingAuth' parameter provides a fallback UI until authentication status is determined.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<PrivateSet>\n  // Loading is shown while we're checking to see if the user's logged in\n  <Route path=\"/super-secret-admin-dashboard\" page={SuperSecretAdminDashboard} name=\"ssad\" whileLoadingAuth={() => <Loading />} prerender/>\n</PrivateSet>\n```\n\n----------------------------------------\n\nTITLE: Prisma Model for RedwoodJS Background Jobs - Prisma\nDESCRIPTION: This Prisma schema defines the 'BackgroundJob' model to store job metadata in the database, including status, scheduling, and error fields. Required by RedwoodJS for persistent job storage, it supports fields for run and failure tracking, locking, and automatic creation/updated timestamps. It must be present in the schema before running migrations that create the table.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_6\n\nLANGUAGE: prisma\nCODE:\n```\nmodel BackgroundJob {\n  id        Int       @id @default(autoincrement())\n  attempts  Int       @default(0)\n  handler   String\n  queue     String\n  priority  Int\n  runAt     DateTime?\n  lockedAt  DateTime?\n  lockedBy  String?\n  lastError String?\n  failedAt  DateTime?\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing hasRole Function for String Roles (TypeScript)\nDESCRIPTION: This diff snippet shows the necessary changes to the `hasRole` function in `api/src/lib/auth.ts` to correctly handle the `roles` property, which is now always a string fetched from the database. The code removes the check for `Array.isArray(currentUserRoles)` when `roles` (the required role) is a string, as `currentUser.roles` can no longer be an array based on the updated Prisma schema and `getCurrentUser` function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\nexport const hasRole = (roles: AllowedRoles): boolean => {\n  if (!isAuthenticated()) {\n    return false\n  }\n\n  const currentUserRoles = context.currentUser?.roles\n\n  if (typeof roles === 'string') {\n    if (typeof currentUserRoles === 'string') {\n      // roles to check is a string, currentUser.roles is a string\n      return currentUserRoles === roles\n-    } else if (Array.isArray(currentUserRoles)) {\n-      // roles to check is a string, currentUser.roles is an array\n-      return currentUserRoles?.some((allowedRole) => roles === allowedRole)\n    }\n  }\n\n  if (Array.isArray(roles)) {\n    if (Array.isArray(currentUserRoles)) {\n      // roles to check is an array, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) =>\n        roles.includes(allowedRole)\n      )\n    } else if (typeof currentUserRoles === 'string') {\n      // roles to check is an array, currentUser.roles is a string\n      return roles.some((allowedRole) => currentUserRoles === allowedRole)\n    }\n  }\n\n  // roles not found\n  return false\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RedwoodJS Function Handler Returning JSON in JavaScript\nDESCRIPTION: Modifies the `serverTime` function handler in `api/src/functions/serverTime.js` to return a proper JSON response. It sets the `Content-Type` header to `application/json` and uses `JSON.stringify` to format the response body, containing the current server time under the `time` key.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nexport const handler = async (event, context) => {\n  return {\n    statusCode: 200,\n    headers: { 'Content-Type': 'application/json ' },\n    body: JSON.stringify({ time: new Date() }),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RedwoodJS Route with Integer Parameter Type (JavaScript)\nDESCRIPTION: This JavaScript snippet from `web/src/Routes.jsx` shows how to define a route path with a typed route parameter in RedwoodJS. By adding `:Int` to the route parameter `{id}`, RedwoodJS ensures that the extracted `id` value is automatically converted to an integer before being passed to the `ArticlePage`. It also validates that the URL segment matches the integer format.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/Routes.jsx\"\n<Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Development Editor via .env (Text)\nDESCRIPTION: This `.env` file entry defines the `REDWOOD_ENV_EDITOR` variable. Redwood uses this variable during development to create links on its `FatalErrorPage` that open source files directly in the specified editor (e.g., 'vscode'). This allows developers to quickly navigate from an error stack trace to the relevant code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/environment-variables.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n```text title=\".env\"\nREDWOOD_ENV_EDITOR=vscode\n```\n```\n\n----------------------------------------\n\nTITLE: Testing for Expected Errors using Try/Catch in JavaScript\nDESCRIPTION: This snippet illustrates how to test for expected error conditions. It attempts to call the `add` function with only one argument (`add(1)`), anticipating an error. A `try/catch` block is used to capture the potential error. The test 'passes' if the caught error message `e` matches the expected string 'add() requires two arguments'. This introduces the concept of testing error-throwing behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\ntry {\n  add(1)\n} catch (e) {\n  if (e === 'add() requires two arguments') {\n    console.log('pass')\n  } else {\n    console.error('fail')\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Latest Node.js Version with nvm\nDESCRIPTION: This command uses nvm to download and install the latest available stable version of Node.js. Nvm handles the download and setup process.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnvm install latest\n```\n\n----------------------------------------\n\nTITLE: Using AdminPost Query in PostCell Component - JSX\nDESCRIPTION: Here, the PostCell component's query is updated to fetch a post via the adminPost endpoint, intended for admin usage. The $id argument locates a specific post, returning fields id, title, body, and createdAt. The use of post: adminPost aliases the result to 'post' for seamless integration. To function, requires the presence of the adminPost query defined on the backend.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query FindPostById($id: Int!) {\n    // highlight-next-line\n    post: adminPost(id: $id) {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Webhook Function Scaffold (Bash)\nDESCRIPTION: Runs the RedwoodJS CLI to generate a new serverless function named 'updateOrderStatus'. This sets up the src/functions directory structure, including TypeScript handler, scenario, and test files. Requires Yarn and a RedwoodJS project context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw generate function updateOrderStatus\n```\n\n----------------------------------------\n\nTITLE: Updating Storybook Story with Sample Data in JavaScript\nDESCRIPTION: This JSX snippet updates the generated Storybook story for the 'Comment' component. It defines a `generated` export function that renders the `Comment` component, passing a sample `comment` object as a prop. This allows for isolated development and testing of the component's appearance in Storybook.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/the-redwood-way.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport Comment from './Comment'\n\nexport const generated = () => {\n  // highlight-start\n  return (\n    <Comment\n      comment={{\n        name: 'Rob Cameron',\n        body: 'This is the first comment!',\n        createdAt: '2020-01-01T12:34:56Z'\n      }}\n    />\n  )\n  // highlight-end\n}\n\nexport default {\n  title: 'Components/Comment',\n  component: Comment,\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering Production Deployment with Yarn - Bash\nDESCRIPTION: This Bash command executes the production deployment process configured in package.json and pm2.config.js. It manages Git pull, build, migrations, server reload, and PM2 state save. The environment must be correctly set up prior to use. Typically run from project root or CI/CD environment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/self-hosting-redwood.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn deploy\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Logging for Data, Operation Name, and Query in TypeScript\nDESCRIPTION: Shows how to configure the `loggerConfig` in `createGraphQLHandler` to include the response `data`, GraphQL `operationName`, and the GraphQL `query` string in the logs by setting the respective keys to `true` within the `options` object. This setup requires a `logger` instance to be passed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_42\n\nLANGUAGE: jsx\nCODE:\n```\nexport const handler = createGraphQLHandler({\n  loggerConfig: {\n    logger,\n    options: { data: true, operationName: true, query: true },\n  },\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Testing RedwoodJS Service Functions with Database Access - JavaScript\nDESCRIPTION: This code demonstrates both implementation and testing of a RedwoodJS service that creates users in the database and tests the business logic using Jest. The service uses Prisma client (db.user.create) to store user data, and the test verifies user creation by checking returned properties. The service is asynchronous by return type, requiring async/await in the tests for correctness. Dependencies include RedwoodJS, the db client (Prisma), and Jest. Inputs are user data objects; outputs are created user records with id and properties.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_50\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const createUser = ({ input }) => {\n  return db.user.create({ data: input })\n}\n\n// api/src/services/users/users.test.js\nimport { createUser } from './users'\n\ndescribe('users service', () => {\n  it('creates a user', async () => {\n    const record = await createUser({ name: 'David' })\n\n    expect(record.id).not.toBeNull()\n    expect(record.name).toEqual('David')\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Starting the RedwoodJS Development Server - Bash\nDESCRIPTION: Starts the RedwoodJS development server, enabling live editing and preview of the application as changes are made. Dependency: A RedwoodJS project must be initialized and all dependencies installed. Usage: run in project root. Output: local server available for development.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/intermission.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw dev\n```\n\n----------------------------------------\n\nTITLE: Querying Comments by postId - GraphQL Query (TypeScript)\nDESCRIPTION: The TypeScript version of the comments query uses strong typing with TypedDocumentNode to enforce the structure of both the expected response and variables. Accepts an integer postId as input to fetch the corresponding comments, ensuring type safety throughout data operations. Dependencies: RedwoodJS/Apollo Client gql, GraphQL Codegen types. Limitations: postId variable must be supplied and typing must be up-to-date with the schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_41\n\nLANGUAGE: GraphQL\nCODE:\n```\nexport const QUERY: TypedDocumentNode<CommentsQuery, CommentsQueryVariables> =\n  gql`\n    // highlight-start\n    query CommentsQuery($postId: Int!) {\n      comments(postId: $postId) {\n      // highlight-end\n        id\n        name\n        body\n        createdAt\n      }\n    }\n  `\n```\n\n----------------------------------------\n\nTITLE: Focusing API Workspace Dependencies Using Yarn Plug'n'Play Caching - RedwoodJS - Dockerfile\nDESCRIPTION: This snippet creates necessary cache directories for Yarn in a node user's home folder and uses Docker's cache mounts to improve build speed. It invokes 'yarn workspaces focus api --production' using the official Yarn v4 workspace tools to install only the production dependencies of the api workspace. The cached layers optimize network and compute use in incremental builds. Prerequisites include cacheable .yarn/berry and .cache directories and proper use of Yarn workspaces.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_10\n\nLANGUAGE: Dockerfile\nCODE:\n```\nRUN mkdir -p /home/node/.yarn/berry/index\\nRUN mkdir -p /home/node/.cache\\n\\nRUN --mount=type=cache,target=/home/node/.yarn/berry/cache,uid=1000 \\\\\\n    --mount=type=cache,target=/home/node/.cache,uid=1000 \\\\\\n    CI=1 yarn workspaces focus api --production\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Job Workers as Background Process (Bash)\nDESCRIPTION: Command to start RedwoodJS job workers as persistent, detached background processes. `yarn rw jobs start` initiates the workers based on the configuration and allows them to run indefinitely, suitable for production or long-running development environments. Use `yarn rw jobs stop` or `yarn rw jobs restart` to manage these detached worker processes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs start\n```\n\n----------------------------------------\n\nTITLE: Bare Minimum Serverless Function Handler - JavaScript (JSX Syntax)\nDESCRIPTION: This snippet provides the basic structure for a RedwoodJS serverless function handler. It demonstrates how to export an asynchronous handler that returns a standard API Gateway response, including status code, headers, and a JSON-serialized body. No external dependencies are required. Input: event, context. Output: JSON response. This minimal pattern is reusable for all serverless endpoints and forms the core foundation of Redwood function files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nexport const handler = async (event, context) => {\n  return {\n    statusCode: 200,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      data: '${name} function',\n    }),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Dates and Styling the Comment Component - RedwoodJS TypeScript\nDESCRIPTION: This TypeScript snippet enhances the Comment component with a typed date formatting function and stylistic classes for better visual presentation. The formattedDate utility parses the 'createdAt' prop to a human-friendly string format, maintaining type safety using ConstructorParameters<typeof Date>[0]. Styles applied via Tailwind CSS classes ensure the component blends well with modern designs. No external dependencies are needed beyond React, TypeScript, and Tailwind CSS.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/the-redwood-way.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// highlight-start\nconst formattedDate = (datetime: ConstructorParameters<typeof Date>[0]) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n// highlight-end\n\n// Just a temporary type. We'll replace this later\ninterface Props {\n  comment: {\n    name: string\n    createdAt: string\n    body: string\n  }\n}\n\nconst Comment = ({ comment }: Props) => {\n  return (\n    // highlight-start\n    <div className=\"bg-gray-200 p-8 rounded-lg\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n    </div>\n    // highlight-end\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Using Cell Mocks in RedwoodJS Component Tests (JavaScript/JSX)\nDESCRIPTION: This test file imports mock data (`standard` and `missingBody`) from the corresponding `.mocks.js` file. It then uses these mocks as props when rendering the `Success` component of the `ArticleCell` to test different scenarios, ensuring the component renders correctly with varying data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_39\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticleCell/ArticleCell.test.js\"\nimport { render, screen } from '@redwoodjs/testing/web'\nimport { Loading, Empty, Failure, Success } from './ArticleCell'\nimport { standard, missingBody } from './ArticleCell.mock'\n\ndescribe('ArticleCell', () => {\n  /// other tests...\n\n  it('Success renders successfully', async () => {\n    expect(() => {\n      render(<Success article={standard().article} />)\n    }).not.toThrow()\n  })\n\n\n  it('Success renders successfully without a body', async () => {\n    expect(() => {\n      render(<Success article={missingBody.article} />)\n    }).not.toThrow()\n  })\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Single Article and Author in Article GraphQL Cell (JSX/GraphQL)\nDESCRIPTION: This JSX GraphQL Cell defines a query to fetch a single article (post), including its author’s name by requesting the nested user field. The query accepts an article id as a parameter and can be used by the frontend to display article details with author attribution. Prerequisites include proper backend resolver setup to resolve the user field, and dependencies such as RedwoodJS and Apollo Client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query ArticleQuery($id: Int!) {\n    article: post(id: $id) {\n      id\n      title\n      body\n      createdAt\n      // highlight-start\n      user {\n        name\n      }\n      // highlight-end\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Importing and Using ArticleCell in ArticlePage (TypeScript)\nDESCRIPTION: Imports the generated `ArticleCell` component into the `ArticlePage` React component (TypeScript version). It renders the `ArticleCell` within the page structure to handle data fetching and display for a single article. Initially, no props are passed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport ArticleCell from 'src/components/ArticleCell'\n\nconst ArticlePage = () => {\n  return (\n    <>\n      <Metadata title=\"Article\" description=\"Article page\" />\n\n      // highlight-next-line\n      <ArticleCell />\n    </>\n  )\n}\n\nexport default ArticlePage\n```\n\n----------------------------------------\n\nTITLE: Adding Emotion Babel Plugin Dependency\nDESCRIPTION: This command uses Yarn workspaces to add the `@emotion/babel-plugin` package as a development dependency specifically to the `web` workspace. This is a necessary step before configuring Babel to use the Emotion plugin for CSS-in-JS styling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/project-configuration-dev-test-build.mdx#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn workspace web add --dev @emotion/babel-plugin\n```\n\n----------------------------------------\n\nTITLE: Using Article Component in ArticleCell Success State (TSX)\nDESCRIPTION: Updates the `Success` component within `ArticleCell.tsx` (used for displaying a single article). It imports the `Article` component and renders it, passing the single `article` object (provided via `CellSuccessProps` with type `FindArticleQuery`) fetched by the cell as a prop.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_32\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { FindArticleQuery, FindArticleQueryVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypedDocumentNode,\n} from '@redwoodjs/web'\n\n// highlight-next-line\nimport Article from 'src/components/Article'\n\nexport const QUERY: TypedDocumentNode<\n  FindArticleQuery,\n  FindArticleQueryVariables\n> = gql`\n  query FindArticleQuery($id: Int!) {\n    article: post(id: $id) {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<FindArticleQueryVariables>) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  article,\n}: CellSuccessProps<FindArticleQuery, FindArticleQueryVariables>) => {\n  // highlight-next-line\n  return <Article article={article} />\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Database Migrations with RedwoodJS Prisma (Shell)\nDESCRIPTION: Runs the RedwoodJS command `yarn rw prisma migrate dev --name init` to apply schema changes defined in `prisma.schema` to the development database. This command generates migration files and updates the database schema accordingly. Requires a valid `DATABASE_URL` in `.env`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nyarn rw prisma migrate dev --name init\n```\n\n----------------------------------------\n\nTITLE: Defining ArticlesCell Component with Aliased Query in TypeScript (TSX)\nDESCRIPTION: This TSX snippet shows the complete definition of the typed `ArticlesCell.tsx` component. It includes the typed GraphQL `QUERY` (using `TypedDocumentNode`) with the 'posts' field aliased to 'articles', standard RedwoodJS Cell exports for Loading, Empty, and Failure states (with types), and a typed Success component that receives and maps over the `articles` prop (`CellSuccessProps`) to render a list.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\n  gql`\n    query ArticlesQuery {\n      // highlight-next-line\n      articles: posts {\n        id\n      }\n    }\n  `\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<ArticlesQueryVariables>) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  // highlight-next-line\n  articles,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\n  return (\n    <ul>\n      // highlight-next-line\n      {articles.map((item) => {\n        return <li key={item.id}>{JSON.stringify(item)}</li>\n      })}\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using RedwoodJS Validation Prop for Required Fields (TypeScript)\nDESCRIPTION: This partial snippet demonstrates applying RedwoodJS's `validation` prop with `{ required: true }` to `TextField` and `TextAreaField` components within a TypeScript component's TSX return statement. This approach leverages RedwoodJS's validation system over standard HTML attributes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nreturn (\n  <Form onSubmit={onSubmit}>\n    <label htmlFor=\"name\">Name</label>\n    // highlight-next-line\n    <TextField name=\"name\" validation={{ required: true }} />\n    <label htmlFor=\"email\">Email</label>\n    // highlight-next-line\n    <TextField name=\"email\" validation={{ required: true }} />\n    <label htmlFor=\"message\">Message</label>\n    // highlight-next-line\n    <TextAreaField name=\"message\" validation={{ required: true }} />\n    <Submit>Save</Submit>\n  </Form>\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Logger Redaction in RedwoodJS TypeScript\nDESCRIPTION: Demonstrates initializing the RedwoodJS logger in `/api/src/lib/logger.ts`. It configures redaction paths using the default `redactionsList` and adds custom paths like `'email'` and `'data.users[*].email'` to prevent sensitive information (e.g., top-level email fields or user emails within returned data arrays) from appearing in logs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_49\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createLogger, redactionsList } from '@redwoodjs/api/logger'\n\nexport const logger = createLogger({\n  options: {\n    redact: [...redactionsList, 'email', 'data.users[*].email'],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up Custom Auth Provider using RedwoodJS CLI - Bash\nDESCRIPTION: This script initializes a custom authentication setup in a RedwoodJS project using the built-in CLI. The 'yarn rw setup auth custom' command modifies project configuration files and scaffolds necessary boilerplate code for custom auth integration. It must be run from the project root prior to further customization. No parameters are needed, and proper project setup and permissions are required for this command to execute successfully.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup auth custom\n```\n\n----------------------------------------\n\nTITLE: Declaring a Typed TransformerDirectiveFunc for Masked Email Directive in TypeScript\nDESCRIPTION: This snippet defines a MaskedEmailTransform type alias that specifies the expected types for the transformer directive function: it operates on string fields and accepts an object with an optional permittedRoles string array as directive arguments. This ensures that when building a transformer for a @maskedEmail directive, the developer receives strong typing for both the field and its associated directive arguments, facilitating correctness and IDE support. The TransformerDirectiveFunc type is required for this definition, and the key parameters are the field's value (string) and the directive's argument (permittedRoles).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype MaskedEmailTransform = TransformerDirectiveFunc<\\n  string,\\n  { permittedRoles?: string[] }\\n>\n```\n\n----------------------------------------\n\nTITLE: Mocking currentUser for Moderator View in Storybook (TSX)\nDESCRIPTION: This TSX snippet demonstrates mocking the current user within the `moderatorView` story using the globally available `mockCurrentUser` function in a TypeScript context, provided by RedwoodJS in the Storybook environment. It passes a user object with `id`, `email`, and the `roles` property set to 'moderator' to simulate an authenticated moderator user, allowing testing of role-specific UI elements (like a delete button) in the `Comment` component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/Comment/Comment.stories.tsx\"\nexport const moderatorView = () => {\n  // highlight-start\n  mockCurrentUser({\n    id: 1,\n    email: 'moderator@moderator.com',\n    roles: 'moderator',\n  })\n  // highlight-end\n\n  return (\n    <Comment\n      comment={{\n        id: 1,\n        name: 'Rob Cameron',\n        body: 'This is the first comment!',\n        createdAt: '2020-01-01T12:34:56Z',\n        postId: 1,\n      }}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining About Page with Metadata in RedwoodJS TypeScript\nDESCRIPTION: This TypeScript About page defines page-level metadata via @redwoodjs/web's Metadata component and presents a static description. It relies on layout inheritance for navigation and does not accept props. Dependencies required: @redwoodjs/web and TypeScript. Renders metadata and an informational paragraph.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <>\n      <Metadata title=\"About\" description=\"About page\" />\n\n      <p>\n        This site was created to demonstrate my mastery of Redwood: Look on my\n        works, ye mighty, and despair!\n      </p>\n    </>\n  )\n}\n\nexport default AboutPage\n```\n\n----------------------------------------\n\nTITLE: Receiving Aliased Data in TypeScript Success Component (RedwoodJS Cell)\nDESCRIPTION: This TypeScript snippet shows the signature of a typed RedwoodJS Cell's Success component. It receives the 'articles' prop, destructured with appropriate TypeScript types (`CellSuccessProps`) derived from the GraphQL query (`ArticlesQuery`, `ArticlesQueryVariables`), reflecting the aliased field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport const Success = ({ articles }: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => { ... }\n```\n\n----------------------------------------\n\nTITLE: Customizing RedwoodJS API URL Path\nDESCRIPTION: This snippet shows how to modify the `redwood.toml` configuration file to change the default API endpoint path. By setting `apiUrl = \"/api\"` under the `[web]` section, API requests from the frontend will be directed to `/api` instead of the default `/.redwood/functions`. This change requires a corresponding update in the reverse proxy (Nginx) configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_39\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n  title = \"My App\"\n  port = 8910\n  host = '0.0.0.0'\n// highlight-next-line\n  apiUrl = \"/api\"\n[api]\n  port = 8911\n[browser]\n  open = true\n```\n\n----------------------------------------\n\nTITLE: Binding RedwoodJS Web Server for External Access and API Proxying (TOML)\nDESCRIPTION: This TOML configuration binds the RedwoodJS web server to all network interfaces by setting 'host' to '0.0.0.0', making it accessible externally for development/testing. The 'apiUrl' parameter is set to a publicly available domain (such as an ngrok tunnel) to proxy API requests during local development. The '[browser]' section optionally auto-opens the browser. Requirements: correct port assignment, and a running ngrok or similar tunnel.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cors.md#_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[web]\\n  title = \"Redwood App\"\\n  port = 8910\\n  host = '0.0.0.0'\\n  apiUrl = '/.redwood/functions'\\n  includeEnvironmentVariables = []\\n[api]\\n  port = 8911\\n[browser]\\n  open = true\n```\n\nLANGUAGE: toml\nCODE:\n```\n[web]\\n  title = \"Redwood App\"\\n  port = 8910\\n  host = '0.0.0.0'\\n  apiUrl = 'https://fb6d701c44b5.ngrok.io'\\n  includeEnvironmentVariables = []\\n[api]\\n  port = 8911\\n[browser]\\n  open = true\n```\n\n----------------------------------------\n\nTITLE: Scheduling a Background Job in RedwoodJS Service - JavaScript\nDESCRIPTION: This JavaScript service function demonstrates scheduling a background job after creating a new user in the database. It imports the job and scheduler, creates the user, and calls 'later' to enqueue the job with argument(s) and a delay option (60 seconds). It expects valid input for user creation and accesses a previously defined job. Requires 'src/lib/db', 'src/lib/jobs', and a job definition (here, 'SampleJob'). Outputs the created user entity.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n// highlight-start\nimport { later } from 'src/lib/jobs'\nimport { SampleJob } from 'src/jobs/SampleJob'\n// highlight-end\n\nexport const createUser = async ({ input }) => {\n  const user = await db.user.create({ data: input })\n  // highlight-next-line\n  await later(SampleJob, [user.id], { wait: 60 })\n  return user\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering an Optimized Image Thumbnail using Transform Function in RedwoodJS (JavaScript)\nDESCRIPTION: This JSX snippet uses the previously defined thumbnail function to ensure that the displayed image is loaded as a 100px wide thumbnail. The img tag sets the maximum display width to 50px while still serving a higher-resolution asset for high-DPI screens. Input is an image object with a CDN url property; output is an HTML image tag optimized for both bandwidth and display quality.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\\\"web/src/components/Images/Images.js\\\"\n<img src={thumbnail(image.url)} style={{ maxWidth: '50px' }} />\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling GraphQL Tracing in RedwoodJS Handler TypeScript\nDESCRIPTION: Configures the RedwoodJS GraphQL handler in `api/src/functions/graphql.ts` to enable performance tracing. The `tracing: true` option within `loggerConfig` instructs the server to include Apollo Tracing data (detailing query execution timing) in the logs for each request.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_50\n\nLANGUAGE: jsx\nCODE:\n```\n// ...\nexport const handler = createGraphQLHandler({\n  loggerConfig: { logger, options: { tracing: true } },\n// ...\n```\n\n----------------------------------------\n\nTITLE: Setting Character Set with Metadata Component in JSX\nDESCRIPTION: Shows how the `charSet` prop on the `<Metadata>` component is used to generate an HTML `<meta>` tag with the `charset` attribute set to the provided value.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata charSet=\"utf-8\" />\n// generates\n<meta charset=\"utf-8\" />\n```\n\n----------------------------------------\n\nTITLE: Asserting Ellipsis Presence (JavaScript)\nDESCRIPTION: Asserts that the element found earlier (containing the ellipsis within the truncated body element) is present in the document using `expect(ellipsis).toBeInTheDocument()`. This confirms the truncation indicator was rendered.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nexpect(ellipsis).toBeInTheDocument()\n```\n\n----------------------------------------\n\nTITLE: Configuring NHOST_JWT_SECRET Environment Variable\nDESCRIPTION: This snippet demonstrates how to add the Nhost JWT Secret to the project's `.env` file. This secret is crucial for verifying the signature of JWT tokens issued by Nhost and will be used by the 'jose' library within the `authDecoder`. The actual secret value, obtained from the Nhost dashboard, should replace the ellipsis.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nNHOST_JWT_SECRET=\"...\"\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with useQuery in a RedwoodJS Component (JSX)\nDESCRIPTION: This React component, `Article`, receives an `id` prop and uses the `useQuery` hook from `@redwoodjs/web` to fetch corresponding article data via a GraphQL query named `GET_ARTICLE`. It displays a loading message until the data is available, then renders the article's title and body. It relies on Redwood's GraphQL setup and the `@redwoodjs/web` package.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useQuery } from '@redwoodjs/web'\n\nconst GET_ARTICLE = gql`\n  query getArticle($id: Int!) {\n    article(id: $id) {\n      id\n      title\n      body\n    }\n  }\n`\n\nconst Article = ({ id }) => {\n  const { data } = useQuery(GET_ARTICLE, { variables: { id } })\n\n  if (data) {\n    return (\n      <article>\n        <h1>{data.article.title}</h1>\n        <div>{data.article.body}</div>\n      </article>\n    )\n  } else {\n    return 'Loading...'\n  }\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Adding Delete Comment Mutation to GraphQL Schema (JavaScript SDL)\nDESCRIPTION: Extends the `Mutation` type in 'api/src/graphql/comments.sdl.js'. It adds the `deleteComment` mutation, which requires an `id` (Int!) as input and returns the deleted `Comment!`. The `@requireAuth` directive ensures only authenticated users (blog owners) can execute this mutation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_20\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.js\"\ntype Mutation {\n  createComment(input: CreateCommentInput!): Comment! @skipAuth\n  // highlight-next-line\n  deleteComment(id: Int!): Comment! @requireAuth\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Handling Form Submission with useMutation in JSX\nDESCRIPTION: This JSX snippet shows the `onSubmit` function within a React component. It takes the form `data` as input and calls the `create` mutation function (obtained from RedwoodJS's `useMutation` hook) with the data structured as input variables.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n  const onSubmit = (data) => {\n    // highlight-next-line\n    create({ variables: { input: data } })\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Updating Navigation in BlogLayout with RedwoodJS (TypeScript)\nDESCRIPTION: This snippet adds a 'Contact' link to the BlogLayout using TypeScript and JSX. It ensures type safety for the 'children' prop and includes the new navigation entry. Dependencies: '@redwoodjs/router', React. Inputs/outputs are similar to the JavaScript version, with optional type checking enhancing maintainability.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n\ntype BlogLayoutProps = {\n  children?: React.ReactNode\n}\n\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\n  return (\n    <>\n      <header>\n        <h1>\n          <Link to={routes.home()}>Redwood Blog</Link>\n        </h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n            // highlight-start\n            <li>\n              <Link to={routes.contact()}>Contact</Link>\n            </li>\n            // highlight-end\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Implementing Pagination Component UI - RedwoodJS - JavaScript\nDESCRIPTION: Creates a simple pagination component generating numeric page links using RedwoodJS routing. Calculates page numbers from total count and displays them as an unordered list, calling routes.home with the page parameter. Expects a 'count' prop indicating total number of posts, and provides minimal structure for easy further styling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n\nconst POSTS_PER_PAGE = 5\n\nconst Pagination = ({ count }) => {\n  const items = []\n\n  for (let i = 0; i < Math.ceil(count / POSTS_PER_PAGE); i++) {\n    items.push(\n      <li key={i}>\n        <Link to={routes.home({ page: i + 1 })}>{i + 1}</Link>\n      </li>\n    )\n  }\n\n  return (\n    <>\n      <h2>Pagination</h2>\n      <ul>{items}</ul>\n    </>\n  )\n}\n\nexport default Pagination\n```\n\n----------------------------------------\n\nTITLE: Refetching GraphQL Queries with Mutations in RedwoodJS (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to configure a RedwoodJS mutation hook to refetch the comments query immediately after a new comment is created, ensuring UI consistency without manual cache manipulation. It imports and reuses the exported CommentsCell query, passing it into the refetchQueries option of the useMutation hook on a createComment mutation. Key parameters include the CREATE mutation document and CommentsQuery. Dependencies: @redwoodjs/web, @redwoodjs/forms, and a defined CREATE mutation. Inputs include the postId and form data; outputs are managed by Apollo's caching and query triggering.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Form,\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\nimport { useMutation } from '@redwoodjs/web'\n\n// highlight-next-line\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n\n// ...\n\nconst CommentForm = ({ postId }) => {\n  // highlight-start\n  const [createComment, { loading, error }] = useMutation(CREATE, {\n    refetchQueries: [{ query: CommentsQuery }],\n  })\n  // highlight-end\n\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Attaching Comments to Logged-in Users with createComment - JSX\nDESCRIPTION: Implements createComment for associating comments with the currently authenticated user or leaving them anonymous if no user context is present. Utilizes db.comment.create with conditional userId assignment. This service function is central to writing tests that verify user-comment relationships and requires an operational database and context.currentUser support.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_69\n\nLANGUAGE: jsx\nCODE:\n```\nexport const createComment = ({ input }) => {\n  if (context.currentUser) {\n    return db.comment.create({\n      data: { userId: context.currentUser.id, ...input },\n    })\n  } else {\n    return db.comment.create({ data: input })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a RedwoodJS Scenario with Multiple Models\nDESCRIPTION: This example illustrates defining a single 'standard' scenario that seeds data for multiple database models ('product', 'order', 'paymentMethod'). This allows setting up a more complex database state involving different types of related or unrelated data required for a test.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_57\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = defineScenario({\n  product: {\n    shirt: {\n      data: {\n        name: 'T-shirt',\n        inventory: 5,\n      },\n    },\n  },\n  order: {\n    first: {\n      data: {\n        poNumber: 'ABC12345',\n      },\n    },\n  },\n  paymentMethod: {\n    credit: {\n      data: {\n        type: 'Visa',\n        last4: 1234,\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Redwood Data Migration Command Usage - Bash\nDESCRIPTION: Outlines the command to interact with data migrations, supporting subcommands ‘install’ and ‘up’ for setup and execution respectively. Dependencies: Redwood CLI, schema.prisma, db. Parameters: <command>. Input: CLI command. Output: Data migration directory/scripts or execution of pending migrations. Limitation: Only for Redwood projects using Prisma.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood data-migrate <command>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Session using Supabase Client in RedwoodJS (TypeScript)\nDESCRIPTION: Illustrates retrieving the current user session by accessing the Supabase client via `useAuth().client` and calling its `getSession` method. This is typically done within a `useEffect` hook in React components.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst { client } = useAuth()\n\nuseEffect(() => {\n  const { data, error } = await client.getSession()\n}, [client])\n```\n\n----------------------------------------\n\nTITLE: Defining Redwood Prisma Scenario Data with Type Information - TypeScript\nDESCRIPTION: Defines a standard scenario for the comments model in TypeScript, using Prisma type information for better type safety and IDE support. Seeds two comments each with a nested post creation, using simple string placeholder values. Requires RedwoodJS, TypeScript, Prisma models, and defineScenario. Key parameters: structured data per Prisma schema definitions; auto-managed id/createdAt fields. Inputs: none, output is exported scenario data for use in test seeds.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_25\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Prisma } from '@prisma/client'\\n\\nexport const standard = defineScenario<Prisma.CommentCreateArgs>({\\n  comment: {\\n    one: {\\n      data: {\\n        name: 'String',\\n        body: 'String',\\n        post: { create: { title: 'String', body: 'String' } },\\n      },\\n    },\\n    two: {\\n      data: {\\n        name: 'String',\\n        body: 'String',\\n        post: { create: { title: 'String', body: 'String' } },\\n      },\\n    },\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Disabling Submit Button During Loading State - RedwoodJS - TypeScript\nDESCRIPTION: This TypeScript/TSX snippet demonstrates disabling the form's Submit button during mutation loading by setting the disabled attribute to the loading value. It relies on the loading property from useMutation result and makes the UI unresponsive while awaiting server response, preventing users from duplicate submissions. Applicable only within components using RedwoodJS form and mutation hooks.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nreturn (\n  // ...\n  // highlight-next-line\n  <Submit disabled={loading}>Save</Submit>\n  // ...\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Passwordless Login Token Form - RedwoodJS - JavaScript\nDESCRIPTION: This JavaScript/JSX snippet defines the LoginPasswordlessTokenForm component for passwordless authentication in RedwoodJS. It leverages RedwoodJS's form and routing utilities, displaying a form for users to input the email and the authentication code sent to them. It handles submission by calling logIn with the appropriate parameters, uses react hooks for state and navigation, displays error messages, and includes a button to request a new token. Dependencies include @redwoodjs/forms, @redwoodjs/router, @redwoodjs/web, @redwoodjs/web/toast, and a custom useAuth hook. Inputs: email (readonly) and loginToken; output: form submission triggers authentication and provides feedback.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useEffect } from 'react'\n\nimport { Form, Label, TextField, Submit, FieldError } from '@redwoodjs/forms'\nimport { navigate, routes, Link } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\nimport { Toaster, toast } from '@redwoodjs/web/toast'\n\nimport { useAuth } from 'src/auth'\n\nconst LoginPasswordlessTokenForm = ({ setWaitingForCode, email, code }) => {\n  const { isAuthenticated, logIn } = useAuth()\n  useEffect(() => {\n    if (isAuthenticated) {\n      navigate(routes.home())\n    }\n\n    if (email && code) {\n      console.log('email', email)\n      logIn({ username: email, password: code })\n    }\n  }, [isAuthenticated, email, code, logIn])\n\n  const onSubmit = async (data) => {\n    // login expects a username and password for dbauth\n    // so we are passing them.\n    const response = await logIn({ username: email, password: data.loginToken })\n\n    if (response.error) {\n      toast.error(response.error)\n    }\n  }\n\n  return (\n    <>\n      <Metadata title=\"Login\" />\n      <main className=\"rw-main\">\n        <Toaster toastOptions={{ className: 'rw-toast', duration: 6000 }} />\n        <div className=\"rw-scaffold rw-login-container\">\n          <div className=\"rw-segment\">\n            <header className=\"rw-segment-header\">\n              <h2 className=\"rw-heading rw-heading-secondary\">\n                Login with Token\n              </h2>\n            </header>\n\n            <div className=\"rw-segment-main\">\n              <div className=\"rw-form-wrapper\">\n                <Form onSubmit={onSubmit} className=\"rw-form-wrapper\">\n                  <Label\n                    name=\"email\"\n                    className=\"rw-label\"\n                    errorClassName=\"rw-label rw-label-error\"\n                  >\n                    Email\n                  </Label>\n                  <TextField\n                    name=\"email\"\n                    className=\"rw-input\"\n                    errorClassName=\"rw-input rw-input-error\"\n                    readOnly={true}\n                    defaultValue={email}\n                  />\n\n                  <FieldError name=\"email\" className=\"rw-field-error\" />\n                  <Label\n                    name=\"loginToken\"\n                    className=\"rw-label\"\n                    errorClassName=\"rw-label rw-label-error\"\n                  >\n                    Token\n                  </Label>\n                  <TextField\n                    name=\"loginToken\"\n                    className=\"rw-input\"\n                    errorClassName=\"rw-input rw-input-error\"\n                  />\n\n                  <FieldError name=\"loginToken\" className=\"rw-field-error\" />\n                  <div className=\"rw-button-group\">\n                    <Submit className=\"rw-button rw-button-blue\">Login</Submit>\n                  </div>\n                  <div className=\"rw-button-group\">\n                    <button\n                      className=\"rw-button rw-button-blue\"\n                      onClick={() => {\n                        setWaitingForCode(false)\n                      }}\n                    >\n                      Get another Token\n                    </button>\n                  </div>\n                </Form>\n              </div>\n            </div>\n          </div>\n          <div className=\"rw-login-link\">\n            <span>Don&apos;t have an account?</span>{' '}\n            <Link to={routes.signup()} className=\"rw-link\">\n              Sign up!\n            </Link>\n          </div>\n        </div>\n      </main>\n    </>\n  )\n}\n\nexport default LoginPasswordlessTokenForm\n```\n\n----------------------------------------\n\nTITLE: Conditionally Rendering Cells by Auth State in RedwoodJS Pages (JavaScript)\nDESCRIPTION: Shows how to use the useAuth hook to render content conditionally based on authentication status in a RedwoodJS page. Depends on the @redwoodjs/auth package for authentication context. The main parameter is isAuthenticated, and the snippet demonstrates rendering MyPrivateCell for authenticated users and NoAccess otherwise. Input: user auth state; Output: different components based on state.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_16\n\nLANGUAGE: js\nCODE:\n```\nimport { useAuth } from '@redwoodjs/auth'\n\nconst HomePage = () => {\n  // highlight-next-line\n  const { isAuthenticated } = useAuth\n\n  return (\n    <>\n      // highlight-next-line\n      { isAuthenticated ? <MyPrivateCell /> : <NoAccess /> }\n    </>\n\n```\n\n----------------------------------------\n\nTITLE: Testing Comments Service Retrieval (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates a Jest test suite for a RedwoodJS service. It uses Redwood's `scenario` function, which seeds a test database and provides the seeded data to the test function. This specific test verifies that the `comments()` service function retrieves all comments defined in the corresponding scenario.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.test.js\"\nimport { comments } from './comments'\n\ndescribe('comments', () => {\n  scenario('returns all comments', async (scenario) => {\n    const result = await comments()\n\n    expect(result.length).toEqual(Object.keys(scenario.comment).length)\n  })\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Integrating ArticleCell into ArticlePage (JavaScript)\nDESCRIPTION: This snippet shows the initial JavaScript version of the `ArticlePage` component located at `web/src/pages/ArticlePage/ArticlePage.jsx`. It imports the newly generated `ArticleCell` and renders it within the page structure. At this stage, no props are being passed to the cell.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ArticlePage/ArticlePage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport ArticleCell from 'src/components/ArticleCell'\n\nconst ArticlePage = () => {\n  return (\n    <>\n      <Metadata title=\"Article\" description=\"Article page\" />\n\n      // highlight-next-line\n      <ArticleCell />\n    </>\n  )\n}\n\nexport default ArticlePage\n```\n```\n\n----------------------------------------\n\nTITLE: Constructing AboutPage in RedwoodJS (JavaScript)\nDESCRIPTION: Builds the AboutPage component in JavaScript, importing navigation and metadata support from @redwoodjs/router and @redwoodjs/web. The component specifies the page's meta information via the Metadata component, and presents a paragraph followed by a navigation link to the home page. It expects no props and outputs a fragment of JSX. Requires: @redwoodjs/router, @redwoodjs/web.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\\nimport { Metadata } from '@redwoodjs/web'\\n\\nconst AboutPage = () => {\\n  return (\\n    <>\\n      <Metadata title=\"About\" description=\"About page\" />\\n\\n      <p>\\n        This site was created to demonstrate my mastery of Redwood: Look on my\\n        works, ye mighty, and despair!\\n      </p>\\n      <Link to={routes.home()}>Return home</Link>\\n    </>\\n  )\\n}\\n\\nexport default AboutPage\n```\n\n----------------------------------------\n\nTITLE: Declarative SEO Meta and OpenGraph Tags with \\u003cMetadata\\u003e - JSX\nDESCRIPTION: This code illustrates using RedwoodJS's <Metadata> component to set standard meta tags, OpenGraph properties, and custom tags in a React page. The component supports props like 'title', 'description', 'og', and 'robots', and allows for custom <meta> children. Dependencies are '@redwoodjs/web' and React; key props define metadata content, and the output is a complete set of SEO-friendly meta tags injected into the <head>. Limitations: Requires Redwood 6.6.0+ and correct use of supported props.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <div>\n      <Metadata\n        title=\"About page\"\n        description=\"About the awesome team\"\n        og={{ image: \"https://example.com/images/og.png\", url: \"https://example.com/start\" }}\n        robots=\"nofollow\"\n      >\n        <meta httpEquiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n      </Metadata>\n\n      <h2>About Page</h2>\n      <p className=\"font-light\">This is the about page!</p>\n    </div>\n  )\n}\n\nexport default AboutPage\n\n```\n\n----------------------------------------\n\nTITLE: Integrating ArticlesCell into HomePage - JavaScript (React JSX)\nDESCRIPTION: This integration snippet shows how to import and render the ArticlesCell component in a RedwoodJS HomePage using JavaScript. It ensures that the cell is displayed on the homepage, leveraging Redwood's Metadata component and supporting SSR/SEO props. No special dependencies are required apart from RedwoodJS web imports.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\\n\\n// highlight-next-line\\nimport ArticlesCell from 'src/components/ArticlesCell'\\n\\nconst HomePage = () => {\\n  return (\\n    <>\\n      <Metadata title=\"Home\" description=\"Home page\" />\\n      // highlight-next-line\\n      <ArticlesCell />\\n    </>\\n  )\\n}\\n\\nexport default HomePage\\n\n```\n\n----------------------------------------\n\nTITLE: Signing In with ID Token using RedwoodJS `useAuth` Hook (TypeScript)\nDESCRIPTION: Logs in a user using an ID Token obtained from an identity provider (e.g., Apple). Uses the `logIn` method from the RedwoodJS `useAuth` hook with `authMethod: 'id_token'`, providing the provider name and the token.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst { logIn } = useAuth()\n\nawait logIn({\n  authMethod: 'id_token',\n  provider: 'apple',\n  token: 'cortland-apple-id-token',\n})\n```\n\n----------------------------------------\n\nTITLE: Managing Database Schema with Redwood Prisma DB (Bash)\nDESCRIPTION: Provides the general syntax for using the `prisma db` command namespace within a Redwood project. These commands operate directly against the database for development tasks like schema pulling, pushing, and seeding.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_96\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood prisma db <command>\n```\n\n----------------------------------------\n\nTITLE: Disabling Command-Line Argument Parsing in createServer\nDESCRIPTION: This TypeScript snippet demonstrates how to prevent the `createServer` function from automatically parsing command-line arguments (`process.argv`) for host and port flags. Setting `parseArgv: false` disables this behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nawait createServer({\n  parseArgv: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Verifying Comment Rendering in CommentsCell Success State (TSX)\nDESCRIPTION: This updated TSX test for the `CommentsCell` component (`web/src/components/CommentsCell/CommentsCell.test.tsx`) enhances the `Success` state test using TypeScript. It imports `screen` in addition to `render` from `@redwoodjs/testing/web`. The test renders the `Success` component with mock comments from `standard().comments`. It then loops through the comments array and uses `screen.getByText(comment.body)` combined with `expect().toBeInTheDocument()` to verify that each comment's body is correctly rendered on the screen.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\nimport { render, screen } from '@redwoodjs/testing/web'\n\nimport { Loading, Empty, Failure, Success } from './CommentsCell'\nimport { standard } from './CommentsCell.mock'\n\ndescribe('CommentsCell', () => {\n  it('renders Loading successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  it('renders Empty successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  it('renders Failure successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  it('renders Success successfully', async () => {\n    // highlight-start\n    const comments = standard().comments\n    render(<Success comments={comments} />)\n\n    comments.forEach((comment) => {\n      expect(screen.getByText(comment.body)).toBeInTheDocument()\n    })\n    // highlight-end\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Verifying Comment Rendering in CommentsCell Success State (JSX)\nDESCRIPTION: This updated JSX test for the `CommentsCell` component (`web/src/components/CommentsCell/CommentsCell.test.jsx`) enhances the `Success` state test. It imports `screen` alongside `render` from `@redwoodjs/testing/web`. The test renders the `Success` component with mock comments retrieved from `standard().comments`. It then iterates through these comments, using `screen.getByText` to assert that each `comment.body` is present in the rendered document, ensuring the correct data is displayed rather than just checking for render errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { render, screen } from '@redwoodjs/testing/web'\n\nimport { Loading, Empty, Failure, Success } from './CommentsCell'\nimport { standard } from './CommentsCell.mock'\n\ndescribe('CommentsCell', () => {\n  it('renders Loading successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  it('renders Empty successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  it('renders Failure successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  it('renders Success successfully', async () => {\n    // highlight-start\n    const comments = standard().comments\n    render(<Success comments={comments} />)\n\n    comments.forEach((comment) => {\n      expect(screen.getByText(comment.body)).toBeInTheDocument()\n    })\n    // highlight-end\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Updating CommentsCell Mock Data in JavaScript\nDESCRIPTION: This JavaScript code snippet shows how to update the mock data for the `CommentsCell` component. It adds the `postId` field to each comment object within the `standard` mock export. This resolves potential test errors caused by the `CommentsCell` query requesting `postId`, which was previously missing from the mock data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"web/src/components/CommentsCell/CommentsCell.mock.js\"\nexport const standard = () => ({\n  comments: [\n    {\n      id: 1,\n      name: 'Rob Cameron',\n      body: 'First comment',\n      // highlight-next-line\n      postId: 1,\n      createdAt: '2020-01-02T12:34:56Z',\n    },\n    {\n      id: 2,\n      name: 'David Price',\n      body: 'Second comment',\n      // highlight-next-line\n      postId: 2,\n      createdAt: '2020-02-03T23:00:00Z',\n    },\n  ],\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Job Workers via Yarn CLI Commands in Bash\nDESCRIPTION: Shows the command-line instruction for starting background job workers using RedwoodJS built-in utilities. The \\\"yarn rw jobs start\\\" command launches worker processes as configured. This approach detaches workers to run jobs continuously. Assumes valid jobs configuration and that Yarn CLI is installed. No input parameters are needed beyond project setup; expected output is the launch of job worker processes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs start\n```\n\n----------------------------------------\n\nTITLE: Defining RedwoodJS Route with Integer Parameter Type (TypeScript)\nDESCRIPTION: This TypeScript snippet from `web/src/Routes.tsx` demonstrates defining a route path with the `:Int` route parameter type constraint. This instructs the RedwoodJS router to convert the `{id}` parameter from the URL string to a number and ensures the route only matches URL segments containing digits, improving type safety and routing behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/Routes.tsx\"\n<Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n```\n```\n\n----------------------------------------\n\nTITLE: Checking the Installed Yarn Version in Terminal\nDESCRIPTION: Displays the currently installed Yarn package manager version in the terminal. This command helps verify that the Yarn version meets Redwood's requirement (v1.22.21 or higher).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/create-redwood-app.md#_snippet_2\n\nLANGUAGE: terminal\nCODE:\n```\nyarn -v\n```\n\n----------------------------------------\n\nTITLE: Defining Default Test Scenarios for Comments (JavaScript)\nDESCRIPTION: This JavaScript snippet shows the default scenario definition for the `comments` service, typically located in `comments.scenarios.js`. It uses Redwood's `defineScenario` function to export a `standard` scenario containing initial data for the `comment` model, including related `post` data using Prisma's nested create syntax. This data is used by tests employing the `scenario` function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments.scenarios.js\"\nexport const standard = defineScenario({\n  comment: {\n    one: {\n      data: {\n        name: 'String',\n        body: 'String',\n        post: { create: { title: 'String', body: 'String' } },\n      },\n    },\n    two: {\n      data: {\n        name: 'String',\n        body: 'String',\n        post: { create: { title: 'String', body: 'String' } },\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Cleaning Git Repository while Excluding .env File\nDESCRIPTION: This variant of the `git clean` command performs the same cleaning operation (removing untracked files and directories, including ignored ones) but specifically excludes (`-e`) the `.env` file from deletion. This allows preserving local environment configurations while resetting the rest of the workspace.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/contributing-walkthrough.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ngit clean -fxd -e .env\n```\n\n----------------------------------------\n\nTITLE: Limiting Maximum Query Depth with GraphQL Armor (RedwoodJS, TypeScript)\nDESCRIPTION: Configures the createGraphQLHandler with a custom maxDepth setting in the armorConfig object, changing the permitted maximum depth of GraphQL queries to 2. Use this pattern to reduce nested query complexity and reduce the attack surface. This snippet depends on RedwoodJS and GraphQL Armor middleware; all other handler parameters (authDecoder, getCurrentUser, etc.) remain required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_62\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const handler = createGraphQLHandler({\n  authDecoder,\n  getCurrentUser,\n  loggerConfig: { logger, options: {} },\n  directives,\n  sdls,\n  services,\n  armorConfig: { maxDepth: { n: 2 } },\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Seeding and Retrieving Data in Service Tests - JavaScript\nDESCRIPTION: These snippets show Jest test cases for verifying data retrieval in RedwoodJS service tests using pre-seeded test data. The first test asserts that retrieving users after insertion returns the correct count; the second validates retrieval of a single user by id. Seeding happens using createUser, and results are compared to seed data to ensure maintainability and avoid hardcoding. Requires the createUser, users, and user functions, as well as the Jest test runner and Prisma database connection.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_51\n\nLANGUAGE: JavaScript\nCODE:\n```\nit('retrieves all users', async () => {\n  const data = await createUser({ name: 'David' })\n\n  const list = await users({ id: data.id })\n\n  expect(list.length).toEqual(1)\n})\n\nit('retrieves a single user', async () => {\n  const data = await createUser({ name: 'David' })\n\n  const record = await user({ id: data.id })\n\n  expect(record.id).toEqual(data.id)\n  expect(record.name).toEqual(data.name)\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Git Repository for RedwoodJS Project\nDESCRIPTION: This set of commands initializes a new Git repository within the project directory. It then stages all current files and directories for tracking ('git add .') and creates the initial commit with the message 'First commit'. This is a recommended step for version control, especially if planning to deploy later. Requires Git to be installed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/installation.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit init\ngit add .\ngit commit -m 'First commit'\n```\n\n----------------------------------------\n\nTITLE: Automatically Adding SSH Key on Terminal Start (.zshrc)\nDESCRIPTION: Provides an example command `ssh-add ~/.ssh/id_ed25519` intended to be placed in a shell configuration file like `~/.zshrc` (for Zsh users). This ensures the specified SSH key is automatically added to the `ssh-agent` every time a new terminal session starts, avoiding the need to add it manually after restarts.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nssh-add ~/.ssh/id_ed25519\n```\n\n----------------------------------------\n\nTITLE: Defining HomePage in RedwoodJS (TypeScript)\nDESCRIPTION: Provides a typed HomePage component implementation in TypeScript for RedwoodJS, including a page-level Metadata descriptor from @redwoodjs/web. Outputs a static string and expects no incoming props. Useful for basic page scaffolding and SEO meta-tagging. Dependencies: @redwoodjs/web.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\\n\\nconst HomePage = () => {\\n  return (\\n    <>\\n      <Metadata title=\"Home\" description=\"Home page\" />\\n      Home\\n    </>\\n  )\\n}\\n\\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Refactored Test Suite for ArticlesCell (JSX)\nDESCRIPTION: A comprehensive test suite for the `ArticlesCell` component in JSX, including tests for Loading, Empty, Failure, and an improved Success state. The Success test now dynamically checks that the full body is *not* present, while a portion of the body and an ellipsis *are* present, making it more robust against changes in truncation length.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { render, screen, within } from '@redwoodjs/testing'\n\nimport { Loading, Empty, Failure, Success } from './ArticlesCell'\nimport { standard } from './ArticlesCell.mock'\n\ndescribe('ArticlesCell', () => {\n  test('Loading renders successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  test('Empty renders successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  test('Failure renders successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  test('Success renders successfully', async () => {\n    const articles = standard().articles\n    render(<Success articles={articles} />)\n\n    // highlight-start\n    articles.forEach((article) => {\n      const truncatedBody = article.body.substring(0, 10)\n      const matchedBody = screen.getByText(truncatedBody, { exact: false })\n      const ellipsis = within(matchedBody).getByText('...', { exact: false })\n\n      expect(screen.getByText(article.title)).toBeInTheDocument()\n      expect(screen.queryByText(article.body)).not.toBeInTheDocument()\n      expect(matchedBody).toBeInTheDocument()\n      expect(ellipsis).toBeInTheDocument()\n    })\n    // highlight-end\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Removing Client-Side Email Validation for Testing (JavaScript)\nDESCRIPTION: Modifies the `ContactPage.jsx` component by removing the client-side email `pattern` validation from the `<TextField>` for the email input. This temporary change allows testing the server-side validation logic by permitting incorrectly formatted emails to be submitted.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_23\n\nLANGUAGE: diff\nCODE:\n```\n <TextField\n   name=\"email\"\n   validation={{\n     required: true,\n-    pattern: {\n-      value: /^[^@]+@[^.]+\\..+$/,\n-      message: 'Please enter a valid email address',\n-    },\n   }}\n   errorClassName=\"error\"\n />\n\n```\n\n----------------------------------------\n\nTITLE: Example Output with Signed URL for Avatar Field in TypeScript\nDESCRIPTION: This TypeScript code represents an example object returned by a RedwoodJS service after generating a signed URL. The `avatar` field, originally holding a file path or key, now contains a complete signed URL string. This URL includes the endpoint (`/.redwood/functions/signedUrl`), a signature (`s=...`), an expiry timestamp (`expiry=...`), and the file path/key (`path=...`), ready to be used in a client application.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  id: 125,\n  avatar: '/.redwood/functions/signedUrl?s=s1gnatur3&expiry=1725190749613&path=path.png'\n}\n```\n\n----------------------------------------\n\nTITLE: Refining Error Expectation Testing in JavaScript\nDESCRIPTION: This snippet improves upon the previous error test by explicitly handling the case where the code under test *doesn't* throw an error when one is expected. A `console.error('fail: no error thrown')` is added after the `add(1)` call within the `try` block. If this line is reached, it signifies a test failure because the expected error wasn't thrown. The `catch` block also differentiates between the correct error and an incorrect one.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\ntry {\n  add(1)\n  console.error('fail: no error thrown')\n} catch (e) {\n  if (e === 'add() requires two arguments') {\n    console.log('pass')\n  } else {\n    console.error('fail: wrong error')\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Using ArticleCell in ArticlePage (JavaScript)\nDESCRIPTION: Imports the generated `ArticleCell` component into the `ArticlePage` React component (JavaScript version). It renders the `ArticleCell` within the page structure to handle data fetching and display for a single article. Initially, no props are passed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport ArticleCell from 'src/components/ArticleCell'\n\nconst ArticlePage = () => {\n  return (\n    <>\n      <Metadata title=\"Article\" description=\"Article page\" />\n\n      // highlight-next-line\n      <ArticleCell />\n    </>\n  )\n}\n\nexport default ArticlePage\n```\n\n----------------------------------------\n\nTITLE: Initializing the Navigation Component and Importing Dependencies in RedwoodJS\nDESCRIPTION: Defines the initial structure of the `Navigation` functional component in `web/src/components/Navigation/Navigation.js`. It imports the `Link` component and `routes` object from `@redwoodjs/router` for navigation, and the `useAuth` hook from `src/auth` to access the authentication state.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_22\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { useAuth } from 'src/auth'\n\nconst Navigation = () => {\n  return <nav></nav>\n}\n\nexport default Navigation\n```\n\n----------------------------------------\n\nTITLE: Rendering Article Component With Prop - JavaScript (JSX)\nDESCRIPTION: This code snippet demonstrates how to use the Article component by passing an article object via the article prop in JSX. Used in the actual application context outside Storybook, the article data must be supplied from an external source such as application state or API data. There are no dependencies except the previously defined Article component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/storybook.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Article article={article} />\n```\n\n----------------------------------------\n\nTITLE: Generated RedwoodJS Component Code (JavaScript/JSX)\nDESCRIPTION: Example code structure generated for a standard RedwoodJS function component (`User.js`). It provides a basic React functional component structure with placeholder JSX content and a default export.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_37\n\nLANGUAGE: jsx\nCODE:\n```\nconst User = () => {\n  return (\n    <div>\n      <h2>{'User'}</h2>\n      <p>{'Find me in ./web/src/components/User/User.js'}</p>\n    </div>\n  )\n}\n\nexport default User\n```\n\n----------------------------------------\n\nTITLE: Fetching User Roles from JWT in RedwoodJS getCurrentUser (JavaScript)\nDESCRIPTION: Demonstrates implementing the `getCurrentUser` function in `api/lib/auth.js` for RedwoodJS authentication. This snippet uses the `parseJWT` helper from `@redwoodjs/api` to extract roles directly from the decoded JWT payload (`decoded`), checking standard locations like `app_metadata`. The resulting user object, including roles, is returned or assigned to the context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { parseJWT } from '@redwoodjs/api'\n\nexport const getCurrentUser = async (decoded) => {\n  return (\n    context.currentUser || { ...decoded, roles: parseJWT({ decoded }).roles }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Skipping Persisted Operation Validation in GraphQL Server Configuration (JavaScript/TypeScript)\nDESCRIPTION: Configure the server to skip validation for persisted GraphQL operations using the `trustedDocuments` option. This assumes operations are pre-validated (e.g., during build) and requires a `store` object containing the trusted operations. Setting `skipDocumentValidation` to `true` improves performance by reducing server load and request latency.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n  trustedDocuments: {\n    store,\n    skipDocumentValidation: true,\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining One-to-Many Relation in Prisma Schema (Book/Shelf Example)\nDESCRIPTION: This Prisma schema defines a one-to-many relationship where a `Shelf` can have many `Book`s, and a `Book` belongs to one optional `Shelf`. This schema is used as an example to illustrate potential issues with RedwoodJS generators when related model SDLs haven't been generated yet.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/schema-relations.md#_snippet_2\n\nLANGUAGE: prisma\nCODE:\n```\nmodel Book {\n  id      Int    @id @default(autoincrement())\n  title   String @unique\n  // highlight-start\n  shelf   Shelf? @relation(fields: [shelfId], references: [id])\n  shelfId Int?\n  // highlight-end\n}\n\nmodel Shelf {\n  id    Int    @id @default(autoincrement())\n  name  String @unique\n  // highlight-next-line\n  books Book[]\n}\n```\n\n----------------------------------------\n\nTITLE: Running All Tests with RedwoodJS - Bash\nDESCRIPTION: This Bash snippet executes the RedwoodJS test runner to check all test suites in the project directory. It requires prior setup of RedwoodJS and a valid codebase. Typical use involves running this command during development or continuous integration to quickly ensure code quality and catch regressions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/the-redwood-way.md#_snippet_9\n\nLANGUAGE: Bash\nCODE:\n```\nyarn rw test\n```\n\n----------------------------------------\n\nTITLE: Output of RedwoodJS Directive Generation (Bash)\nDESCRIPTION: Displays the typical console output after successfully generating a RedwoodJS directive named `myDirective`. It confirms the creation of the directive implementation file (`myDirective.ts`) and its test file (`myDirective.test.ts`) within the `api/src/directives` directory, along with examples of how to apply the new directive (`@myDirective`) to fields or queries/mutations in SDL files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n  ✔ Generating directive file ...\n    ✔ Successfully wrote file `./api/src/directives/myDirective/myDirective.test.ts`\n    ✔ Successfully wrote file `./api/src/directives/myDirective/myDirective.ts`\n  ✔ Generating TypeScript definitions and GraphQL schemas ...\n  ✔ Next steps...\n\n    After modifying your directive, you can add it to your SDLs e.g.:\n     // example todo.sdl.js\n     # Option A: Add it to a field\n     type Todo {\n       id: Int!\n       body: String! @myDirective\n     }\n\n     # Option B: Add it to query/mutation\n     type Query {\n       todos: [Todo] @myDirective\n     }\n```\n\n----------------------------------------\n\nTITLE: Generating a Global Layout using Redwood CLI\nDESCRIPTION: Uses the RedwoodJS CLI command `yarn redwood generate layout global` to create a `GlobalLayout` component in the `web/src/layouts/` directory. This layout will serve as a template to wrap common page structures, such as headers containing navigation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate layout global\n```\n\n----------------------------------------\n\nTITLE: Importing DbAuthSession Utility Type in TypeScript\nDESCRIPTION: Shows the necessary import statement to bring the `DbAuthSession` utility type from the `@redwoodjs/api` package into scope within the `api/src/lib/auth.ts` file for use in Redwood's DbAuth implementation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport type { DbAuthSession } from '@redwoodjs/api'\n```\n\n----------------------------------------\n\nTITLE: Configuring GitHub Actions Workflow for RedwoodJS CI (YAML)\nDESCRIPTION: Defines a GitHub Actions workflow (`.github/workflows/ci.yml`) for Continuous Integration of a RedwoodJS application. The workflow triggers on push/pull_request events to the `main` branch, sets up Node.js 20.x, starts a PostgreSQL service container, defines necessary database environment variables, installs dependencies using Yarn, builds the Redwood app, and runs both API and web test suites using `yarn rw test`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_8\n\nLANGUAGE: yml\nCODE:\n```\nname: Redwood CI\n\non:\n  push:\n    branches: ['main']\n  pull_request:\n    branches: ['main']\n\nenv:\n  DATABASE_URL: postgres://postgres:postgres@localhost:5432/postgres\n  TEST_DATABASE_URL: postgres://postgres:postgres@localhost:5432/postgres\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [20.x]\n        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/\n\n    services:\n      # Label used to access the service container\n      postgres:\n        # Docker Hub image\n        image: postgres\n        # Provide the password for postgres\n        env:\n          POSTGRES_PASSWORD: postgres\n        # Set health checks to wait until postgres has started\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          # Maps tcp port 5432 on service container to the host\n          - 5432:5432\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.node-version }}\n      - run: corepack enable\n      # install all the dependencies\n      - run: yarn install\n      # build the redwood app\n      - run: yarn rw build\n      # run the api tests\n      - run: yarn rw test api --no-watch\n      # run the web tests\n      - run: yarn rw test web --no-watch\n```\n\n----------------------------------------\n\nTITLE: Mocking useLocation in RedwoodJS Component Tests (JSX)\nDESCRIPTION: This snippet details how to mock the useLocation hook in RedwoodJS by wrapping the test subject in the LocationProvider and injecting a custom location object. Prerequisites are RedwoodJS and @redwoodjs/router. Inputs: location object defining pathname and search string; output: component rendered with mocked location context for predictable test results.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { LocationProvider } from '@redwoodjs/router'\\n\\nrender(\\n  <LocationProvider location={{ pathname: '', search: '?cancelled=true' }}>\\n    <Component />\\n  </LocationProvider>\\n)\n```\n\n----------------------------------------\n\nTITLE: Custom Loader While Pages Load Using whileLoadingPage Prop - RedwoodJS Router - JavaScript/JSX\nDESCRIPTION: Demonstrates adding a loading indicator component for page transitions using the whileLoadingPage prop on Route grouping components such as Set. Requires the SkeletonLoader component to be imported and supplied. Input: React router configuration; output: enhanced user experience with conditional loader display during page chunk loads.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_32\n\nLANGUAGE: jsx\nCODE:\n```\nimport SkeletonLoader from 'src/components/SkeletonLoader'\n<Router>\n  <Set whileLoadingPage={SkeletonLoader}>\n    <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n    <Route path=\"/about\" page={AboutPage} name=\"about\" />\n  </Set>\n</Router>\n```\n\n----------------------------------------\n\nTITLE: Initializing a Redwood App with Specific Flags in Terminal\nDESCRIPTION: Demonstrates creating a Redwood app using `yarn create redwood-app` while bypassing interactive prompts by providing configuration flags directly. This specific command creates an app named `<your-app-name>`, configures it to use TypeScript (`--typescript`), initializes a Git repository (`--git-init`) with a specified commit message (`--commit-message`), and automatically runs `yarn install` (`--yarn-install`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/create-redwood-app.md#_snippet_6\n\nLANGUAGE: terminal\nCODE:\n```\nyarn create redwood-app <your-app-name> --typescript --git-init --commit-message \"Initial commit\" --yarn-install\n```\n\n----------------------------------------\n\nTITLE: Testing Float Precision in Jest with Expect for Prisma Float Type in JavaScript\nDESCRIPTION: Illustrates a failure scenario when using 'Float' type in Prisma due to precision errors during equality checks. Expects the output of result.floatingNumber to match the precise float, but floating point math may cause '.toEqual' to fail. No explicit dependencies beyond Jest and whatever generates result.floatingNumber. Important for identifying the potential mismatch between expected and received float values due to floating point inaccuracies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nExpected: 1498892.0256940164\nReceived: 1498892.025694016\n\nexpect(result.floatingNumber).toEqual(1498892.0256940164)\n```\n\n----------------------------------------\n\nTITLE: Accessing PostgreSQL Interactive Terminal (psql) (Bash)\nDESCRIPTION: Attempts to access the interactive PostgreSQL terminal using the psql command. Requires Postgres to be installed and running. Expects a local database with the same name as your system user; otherwise, may result in an error.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ psql\n```\n\n----------------------------------------\n\nTITLE: Passing Extra Props to a RedwoodJS Cell (JavaScript)\nDESCRIPTION: This JavaScript example illustrates passing an additional prop (`rand`) to the `ArticleCell` component, alongside the `id` prop required for the GraphQL query. RedwoodJS Cells automatically make all passed props available to their render components (`Success`, `Loading`, etc.), but only props matching defined GraphQL variables are passed to the query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\n<ArticleCell id={id} rand={Math.random()} />\n```\n```\n\n----------------------------------------\n\nTITLE: Sample Error Message for Token Limit Exceeded - Text\nDESCRIPTION: This plain text snippet shows the error message produced when a GraphQL query exceeds the configured token limit. It clarifies the output expected by the handler's enforcement logic, reporting both the configured limit and the count encountered.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_74\n\nLANGUAGE: text\nCODE:\n```\n'Syntax Error: Token limit of 2 exceeded, found 3.'\n```\n\n----------------------------------------\n\nTITLE: Configuring Routes for Home and NotFound Pages in RedwoodJS - TypeScript\nDESCRIPTION: This TypeScript snippet mirrors the JavaScript example for setting up routes in 'web/src/Routes.tsx', leveraging strict typing. It registers the root ('/') to HomePage and all unmatched paths to NotFoundPage. '@redwoodjs/router' should be installed for type definitions. Page components should be present at the given references. All props including 'page' and 'name' inform the routing behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/first-page.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route } from '@redwoodjs/router'\n\nconst Routes = () => {\n  return (\n    <Router>\n      // highlight-next-line\n      <Route path=\"/\" page={HomePage} name=\"home\" />\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Accessing Custom Clerk Claims in RedwoodJS getCurrentUser\nDESCRIPTION: Illustrates how custom claims added to the Clerk session token via the Clerk dashboard are accessible within the `decoded` object parameter of the `getCurrentUser` function in `api/src/lib/auth.ts`. This allows leveraging custom user data on the API side.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/clerk.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nexport const getCurrentUser = async (\n  decoded, // 👈 All the claims you add will be available on the `decoded` object\n  // ...\n) => {\n  decoded.myClaim...\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Example Console Error for Missing Field in GraphQL Mock\nDESCRIPTION: This snippet shows an example console error message that might appear during RedwoodJS test runs. It indicates that a field ('postId' in this case) requested by a GraphQL query was missing from the mock data provided for the test. This typically occurs when the query in a Cell component is updated, but the corresponding mock file (e.g., `CommentsCell.mock.js`) has not been updated to include the new field in its mock response.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nconsole.error\n  Missing field 'postId' while writing result {\n    \"id\": 1,\n    \"name\": \"Rob Cameron\",\n    \"body\": \"First comment\",\n    \"createdAt\": \"2020-01-02T12:34:56Z\"\n  }\n```\n```\n\n----------------------------------------\n\nTITLE: Registering Helper and Creating Cache Key for Fragment Data - RedwoodJS Apollo - TypeScript/JavaScript\nDESCRIPTION: Shows how to import the 'getCacheKey' helper from '@redwoodjs/web/apollo', which constructs Apollo Client cache keys from an entity's typename and id. This is used when working with normalized Apollo cache for cache manipulation or reading. Requires fragment registration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport { getCacheKey } from '@redwoodjs/web/apollo'\\n\n```\n\n----------------------------------------\n\nTITLE: Restoring Public Post Service (All/Single Post Without User Restriction) - JavaScript\nDESCRIPTION: This snippet shows a public-facing RedwoodJS posts service enabling retrieval of all posts or a single post by id, without filtering by user. It utilizes db.post.findMany and findUnique. The Post relation resolver is kept for accessing the user owning the post. This code is used by public queries and non-admin pages, requires Prisma ORM and RedwoodJS's db context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const posts = () => {\n  return db.post.findMany()\n}\n\nexport const post = ({ id }) => {\n  return db.post.findUnique({ where: { id } })\n}\n\nexport const Post = {\n  user: (_obj, { root }) =>\n    db.post.findFirst({ where: { id: root.id } }).user(),\n}\n```\n\n----------------------------------------\n\nTITLE: Launching Storybook for RedwoodJS Components - Bash\nDESCRIPTION: This command starts the Storybook server so that RedwoodJS components, including the new CommentForm, can be previewed, interacted with, and developed in isolation. Its principal dependency is that Storybook is configured in the project, and 'yarn' and 'rw' scripts are available.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw storybook\n```\n\n----------------------------------------\n\nTITLE: Protecting RedwoodJS NavLink for Multiple Roles (JSX)\nDESCRIPTION: This snippet demonstrates conditionally rendering a `NavLink` component for users belonging to any of the specified roles ('admin', 'author', 'editor', 'publisher'). It utilizes the `hasRole` function from the `useAuth` hook to perform the check for the authenticated user.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { NavLink, Link, routes } from '@redwoodjs/router'\\nimport { useAuth } from '@redwoodjs/auth'\\n\\nconst SidebarLayout = ({ children }) => {\\n  const { hasRole } = useAuth()\\n\\n  return (\\n    ...\\n    {hasRole(['admin', 'author', 'editor', 'publisher']) && (\\n      <NavLink\\n        to={routes.posts()} className=\"text-gray-600\" activeClassName=\"text-gray-900\"\\n      >\\n      Manage Posts\\n    </NavLink>\\n    ...\\n   )}\\n )\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Model Validations with `validates` (JavaScript/JSX)\nDESCRIPTION: JavaScript/JSX code demonstrating how to define validation rules for a RedwoodRecord model (`User`) using the static `validates` class property. This example includes common validation types like `presence`, `email` format, and `length` constraints, mirroring capabilities found in Redwood Service Validations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nexport default class User extends RedwoodRecord {\n  static validates = {\n    email: { presence: true, email: true },\n    username: { length: { min: 2, max: 50 } },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Redwood Server with Host/Port Environment Variables\nDESCRIPTION: This shell script shows how to set the `REDWOOD_API_HOST` and `REDWOOD_API_PORT` environment variables before running the server file. These variables are the second level of precedence for configuring the listening host and port.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nexport REDWOOD_API_HOST='0.0.0.0'\nexport REDWOOD_API_PORT='8913'\nyarn node api/dist/server.js\n```\n\n----------------------------------------\n\nTITLE: Performance Optimization with describeScenario in RedwoodJS - JavaScript\nDESCRIPTION: Introduces the use of describeScenario to group multiple tests under a single database setup and teardown, which accelerates test execution but trades away test isolation. Tests must manually retrieve the current scenario via getScenario(). This pattern fits scenarios where rapid iteration is desired and the risk of interconnected data state is acceptable. Dependencies: RedwoodJS testing harness with describeScenario.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_66\n\nLANGUAGE: js\nCODE:\n```\n// highlight-next-line\ndescribeScenario('contacts', (getScenario) => {\n  // You can imagine the scenario setup happens here\n\n  // All these tests now use the same setup 👇\n  it('xxx', () => {\n    // Notice that the scenario has to be retrieved using the getter\n    // highlight-next-line\n    const scenario = getScenario()\n    //...\n  })\n\n  it('xxx', () => {\n    const scenario = getScenario()\n    /...\n  })\n\n})\n```\n\n----------------------------------------\n\nTITLE: Generating a Sample Job with RedwoodJS CLI - Bash\nDESCRIPTION: This bash command uses RedwoodJS's generator to scaffold a new background job called 'SampleJob'. It creates job logic, test, and scenario files under the API directory, providing a template for defining actual background job work. No arguments are needed beyond the desired job name.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g job SampleJob\n```\n\n----------------------------------------\n\nTITLE: Configuring the NotFoundPage Route in RedwoodJS Router (JSX)\nDESCRIPTION: Shows how to configure the router in `web/src/Routes.jsx` to use a specific page component (`NotFoundPage`) as the handler for unmatched routes. This is achieved by adding the `notfound` prop to the corresponding `Route` definition.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_37\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/Routes.jsx\"\nimport { Router, Route } from '@redwoodjs/router'\n\nconst Routes = () => (\n  <Router>\n    // highlight-next-line\n    <Route notfound page={NotFoundPage} />\n  </Router>\n)\n\nexport default Routes\n```\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL SDL for Anonymous Contact Creation Mutation (RedwoodJS, JavaScript)\nDESCRIPTION: This JavaScript SDL file shows a restricted GraphQL schema for the Contact resource, where only the createContact mutation is exposed with the @skipAuth directive, allowing unauthenticated clients to create contacts. The mutation accepts a CreateContactInput object, reflecting fields defined as required. This is useful for forms that should be submitted without authentication, with query security enforced by omitting update and delete fields. The schema operates within RedwoodJS, using GraphQL SDL syntax.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\\n  type Contact {\\n    id: Int!\\n    name: String!\\n    email: String!\\n    message: String!\\n    createdAt: DateTime!\\n  }\\n\\n  type Query {\\n    contacts: [Contact!]! @requireAuth\\n    contact(id: Int!): Contact @requireAuth\\n  }\\n\\n  input CreateContactInput {\\n    name: String!\\n    email: String!\\n    message: String!\\n  }\\n\\n  // highlight-start\\n  type Mutation {\\n    createContact(input: CreateContactInput!): Contact! @skipAuth\\n  }\\n  // highlight-end\\n`\n```\n\n----------------------------------------\n\nTITLE: Testing Moderator-Only Deletion and Auth Scenarios for Comments - RedwoodJS - TypeScript\nDESCRIPTION: This TypeScript test file provides comprehensive unit tests for the comment deletion access controls in a RedwoodJS application. It checks that only users with moderator roles can delete comments, enforcing correct errors for unauthorized access. The test uses mockCurrentUser to set up different user roles and ids, covers creation and retrieval, and utilizes AuthenticationError/ForbiddenError from RedwoodJS. Importantly, it uses TypeScript scenario typing for strong type guarantees.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_33\n\nLANGUAGE: ts\nCODE:\n```\n// highlight-next-line\nimport { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\n\nimport { db } from 'src/lib/db'\n\n// highlight-next-line\nimport { comments, createComment, deleteComment } from './comments'\n\nimport type { PostOnlyScenario, StandardScenario } from './comments.scenarios'\n\ndescribe('comments', () => {\n  scenario(\n    'returns all comments for a single post from the database',\n    async (scenario) => {\n      const result = await comments({ postId: scenario.comment.jane.postId })\n      const post = await db.post.findUnique({\n        where: { id: scenario.comment.jane.postId },\n        include: { comments: true },\n      })\n      expect(result.length).toEqual(post.comments.length)\n    }\n  )\n\n  scenario(\n    'postOnly',\n    'creates a new comment',\n    async (scenario: PostOnlyScenario) => {\n      const comment = await createComment({\n        input: {\n          name: 'Billy Bob',\n          body: 'What is your favorite tree bark?',\n          postId: scenario.post.bark.id,\n        },\n      })\n\n      expect(comment.name).toEqual('Billy Bob')\n      expect(comment.body).toEqual('What is your favorite tree bark?')\n      expect(comment.postId).toEqual(scenario.post.bark.id)\n      expect(comment.createdAt).not.toEqual(null)\n    }\n  )\n\n  // highlight-start\n  scenario(\n    'allows a moderator to delete a comment',\n    async (scenario: StandardScenario) => {\n      mockCurrentUser({\n        roles: 'moderator',\n        id: 1,\n        email: 'moderator@moderator.com',\n      })\n\n      const comment = await deleteComment({\n        id: scenario.comment.jane.id,\n      })\n      expect(comment.id).toEqual(scenario.comment.jane.id)\n\n      const result = await comments({ postId: scenario.comment.jane.postId })\n      expect(result.length).toEqual(0)\n    }\n  )\n\n  scenario(\n    'does not allow a non-moderator to delete a comment',\n    async (scenario: StandardScenario) => {\n      mockCurrentUser({ roles: 'user', id: 1, email: 'user@user.com' })\n\n      expect(() =>\n        deleteComment({\n          id: scenario.comment.jane.id,\n        })\n      ).toThrow(ForbiddenError)\n    }\n  )\n\n  scenario(\n    'does not allow a logged out user to delete a comment',\n    async (scenario: StandardScenario) => {\n      mockCurrentUser(null)\n\n      expect(() =>\n        deleteComment({\n          id: scenario.comment.jane.id,\n        })\n      ).toThrow(AuthenticationError)\n    }\n  )\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up Redwood Server File using Yarn\nDESCRIPTION: This shell command uses the RedwoodJS CLI (`rw`) to scaffold the server file (`api/src/server.ts`) necessary for customizing the API server startup and configuration. It's the initial step to enable server file usage.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup server-file\n```\n\n----------------------------------------\n\nTITLE: Introducing FieldError for Validation in RedwoodJS Contact Form (JSX)\nDESCRIPTION: This JSX snippet demonstrates the initial setup of a contact form page in RedwoodJS using components from `@redwoodjs/forms`. It introduces the `<FieldError>` component, imported alongside other form elements, to display validation messages for required fields (`name`, `email`, `message`). The `name` prop of `<FieldError>` links it to the corresponding input field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  // highlight-next-line\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"name\" />\n\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"email\" />\n\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"message\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Refetching Comments After Creating a Comment - React Mutation Hook (TypeScript)\nDESCRIPTION: A TypeScript implementation of the comment creation mutation hook, ensuring after a new comment is successfully posted the related comments are refetched using the postId variable. This maintains the correct comments list per post in the UI for RedwoodJS projects with typed GraphQL operations. Requires React, Apollo useMutation, typed CREATE mutation, and CommentsQuery with variables. Outputs: updated display and user feedback each submission.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_43\n\nLANGUAGE: JSX\nCODE:\n```\nconst [createComment, { loading, error }] = useMutation(CREATE, {\n  onCompleted: () => {\n    setHasPosted(true)\n    toast.success('Thank you for your comment!')\n  },\n  // highlight-next-line\n  refetchQueries: [{ query: CommentsQuery, variables: { postId } }],\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Input Fields to RedwoodJS Contact Form in TypeScript\nDESCRIPTION: Updates the TypeScript contact form to define 'name', 'email', and 'message' fields, with a FormValues interface for strict typing. Uses TextAreaField for messages and configures a type-safe onSubmit handler. After submission, the entire form data object is logged to the console. Dependencies are unchanged: @redwoodjs/web and @redwoodjs/forms.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n// highlight-start\nimport {\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n// highlight-end\n\ninterface FormValues {\n  // highlight-start\n  name: string\n  email: string\n  message: string\n  // highlight-end\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-start\n        <TextField name=\"name\" />\n        <TextField name=\"email\" />\n        <TextAreaField name=\"message\" />\n        // highlight-end\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Generating a Contact Page with RedwoodJS CLI\nDESCRIPTION: Uses the RedwoodJS command-line interface (`yarn rw g page`) to scaffold a new page named 'contact'. This command automatically creates the necessary page component, test file, and potentially a story file within the RedwoodJS project structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g page contact\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Response Caching in RedwoodJS API Handler\nDESCRIPTION: Demonstrates how to configure the RedwoodJS GraphQL handler (`api/src/functions/graphql.ts`) to use the `useResponseCache` plugin. It shows importing the plugin, adding it to `extraPlugins`, and configuring options like `session` and `ttlPerSchemaCoordinate` to set cache durations for specific queries (e.g., `Query.recentPosts`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/caching.md#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nimport { useResponseCache } from '@graphql-yoga/plugin-response-cache'\n\nimport { createGraphQLHandler } from '@redwoodjs/graphql-server'\n\nimport directives from 'src/directives/**/*.{js,ts}'\nimport sdls from 'src/graphql/**/*.sdl.{js,ts}'\nimport services from 'src/services/**/*.{js,ts}'\n\nimport { db } from 'src/lib/db'\nimport { logger } from 'src/lib/logger'\n\nexport const handler = createGraphQLHandler({\n  loggerConfig: { logger, options: {} },\n  directives,\n  sdls,\n  services,\n  extraPlugins: [\n    useResponseCache({\n      session: () => null,\n      ttlPerSchemaCoordinate: {\n        'Query.recentPosts': 10 * 1_000, // cache the `recentPosts` query for 10 seconds\n      },\n    }),\n  ],\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Post Service with User Relation Resolver in RedwoodJS (JavaScript)\nDESCRIPTION: This snippet defines a set of API service functions for managing posts using Prisma ORM in the RedwoodJS backend. It includes CRUD operations and manually adds a GraphQL relation resolver (`Post.user`) to fetch the associated user for each post. The resolver leverages Prisma's `findFirst` method and supports field-level resolution for nested GraphQL queries. Prisma and `src/lib/db` are required dependencies, and all service functions expect typical post-related input parameters. The notable limitation here is potential N+1 query inefficiency when resolving users for many posts.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const posts = () => {\n  return db.post.findMany()\n}\n\nexport const post = ({ id }) => {\n  return db.post.findUnique({\n    where: { id },\n  })\n}\n\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    data: input,\n  })\n}\n\nexport const updatePost = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost = ({ id }) => {\n  return db.post.delete({\n    where: { id },\n  })\n}\n\n// highlight-start\nexport const Post = {\n  user: (_obj, { root }) =>\n    db.post.findFirst({ where: { id: root.id } }).user(),\n}\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Defining User-Post Relationship in Prisma Schema (JavaScript)\nDESCRIPTION: Defines a one-to-many relationship between User and Post models in the Prisma schema using JavaScript. The Post model adds a userId foreign key and establishes a relation to User, while the User model receives a posts field. This enables Prisma's relational mapping and ensures referential integrity between posts and users. Required dependency: Prisma ORM. Inputs are database records for User and Post, outputs are relational models. Only to be changed via schema updates and migrations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_0\n\nLANGUAGE: prisma\nCODE:\n```\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  body      String\n  comments  Comment[]\n  // highlight-start\n  user      User     @relation(fields: [userId], references: [id])\n  userId    Int\n  // highlight-end\n  createdAt DateTime @default(now())\n}\n\nmodel User {\n  id                  Int @id @default(autoincrement())\n  name                String?\n  email               String @unique\n  hashedPassword      String\n  salt                String\n  resetToken          String?\n  resetTokenExpiresAt DateTime?\n  roles               String @default(\"moderator\")\n  // highlight-next-line\n  posts               Post[]\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Email with RedwoodJS Mailer in a Service (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to use the configured RedwoodJS Mailer within a service function (`api/src/services/contacts.ts`). It imports the `mailer` instance and an email template component (`ContactUsEmail`). Inside the `createContact` resolver, after creating a database record, it calls `mailer.send()`, passing the instantiated email component with props and an options object specifying the recipient (`to`), `subject`, `replyTo`, and `from` address.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/mailer.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n```ts title=api/src/services/contacts.ts\nimport { mailer } from 'src/lib/mailer'\nimport { ContactUsEmail } from 'src/mail/Example/Example'\n\n// ...\n\nexport const createContact: MutationResolvers['createContact'] = async ({\n  input,\n}) => {\n  const contact = await db.contact.create({\n    data: input,\n  })\n\n  // Send email\n  await mailer.send(\n    ContactUsEmail({\n      name: input.name,\n      email: input.email,\n      // Note the date is hardcoded here for the sake of test snapshot consistency\n      when: new Date(0).toLocaleString(),\n    }),\n    {\n      to: 'inbox@example.com',\n      subject: 'New Contact Us Submission',\n      replyTo: input.email,\n      from: 'contact-us@example.com',\n    }\n  )\n\n  return contact\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Active Links with NavLink - RedwoodJS - JSX\nDESCRIPTION: Demonstrates how to use the NavLink component from RedwoodJS to conditionally apply active CSS classes based on the current URL. The code shows customization of className and activeClassName props for different navigation items, with comments explaining how URL matching affects rendered classes. Dependencies include '@redwoodjs/router' and requires a RedwoodJS project with route definitions. Inputs include the current browser URL and outputs are <a> elements with appropriate classes, switching between 'link' and 'activeLink' states.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport { NavLink, routes } from '@redwoodjs/router'\n\nconst MainMenu = () =>\n  <ul>\n    <li>\n      <!--\n        Normally renders as `<a className=\\\"link homeLink\\\" ...>`, but when the\n        URL matches \\\"/\\\" it'll switch to render\n        `<a className=\\\"activeLink homeLink\\\" ...>`\n      -->\n      <NavLink\n        className=\\\"link homeLink\\\"\n        activeClassName=\\\"activeLink homeLink\\\"\n        to={routes.home()}>\n        Home\n      </NavLink>\n    </li>\n    <li>\n      <!--\n        Normally renders as `<a className=\\\"link\\\" ...>`, but when the URL\n        matches \\\"/?tab=tutorial\\\" (params order insensitive) it'll switch to\n        render `<a className=\\\"activeLink\\\" ...>`\n      -->\n      <NavLink\n        className=\\\"link\\\"\n        activeClassName=\\\"activeLink\\\"\n        to={routes.home({ tab: 'tutorial' })}>\n          Home > Tutorial\n      </NavLink>\n    </li>\n  </ul>\n```\n\n----------------------------------------\n\nTITLE: Full Routes File with Layouts and Named Params (RedwoodJS, TypeScript)\nDESCRIPTION: This TypeScript version of the main routing file provides identical layout and dynamic route setup as the JavaScript counterpart but with typing support for improved maintainability. It configures parameterized, nested, and notfound routes for various resources, leveraging RedwoodJS's router composition features. It requires all routes' component pages and layouts to be properly defined and imported.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route, Set } from '@redwoodjs/router'\\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\\nimport BlogLayout from 'src/layouts/BlogLayout'\\n\\nconst Routes = () => {\\n  return (\\n    <Router>\\n      <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\\n        <Route path=\"/posts/new\" page={PostNewPostPage} name=\"newPost\" />\\n        <Route path=\"/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\\n        <Route path=\"/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\\n        <Route path=\"/posts\" page={PostPostsPage} name=\"posts\" />\\n      </Set>\\n      <Set wrap={BlogLayout}>\\n        // highlight-next-line\\n        <Route path=\"/article/{id}\" page={ArticlePage} name=\"article\" />\\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\\n        <Route path=\"/\" page={HomePage} name=\"home\" />\\n      </Set>\\n      <Route notfound page={NotFoundPage} />\\n    </Router>\\n  )\\n}\\n\\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Adding Pattern Validation to Email Field in RedwoodJS Form (JSX)\nDESCRIPTION: Illustrates adding email format validation to the `TextField` component for the email field within a RedwoodJS form using JSX. The `validation` prop is updated to include a `pattern` object, which specifies a regular expression (`value`) to match against and a custom `message` to display if the pattern fails.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_30\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\n<TextField\n  name=\"email\"\n  validation={{\n    required: true,\n    // highlight-start\n    pattern: {\n      value: /^[^@]+@[^.]+\\..+$/,\n      message: 'Please enter a valid email address',\n    },\n    // highlight-end\n  }}\n  errorClassName=\"error\"\n/>\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a Submit Button to a RedwoodJS Form (TSX)\nDESCRIPTION: This snippet shows how to add a submit button to the `ContactPage` form using the `Submit` component from `@redwoodjs/forms` in TypeScript. The button displays the text \"Save\".\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField, Submit } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form>\n        <TextField name=\"input\" />\n        // highlight-next-line\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up Deployment Provider with Redwood CLI - Shell\nDESCRIPTION: This shell command uses the Redwood CLI to initialize deployment configuration for a specific hosting provider. It automatically adds necessary code and configuration files to your project based on the provider specified. Dependencies: Requires RedwoodJS CLI installed and access to the target project; <provider> must be replaced with a supported deploy target such as 'netlify' or 'vercel'. No input or output files by default, but modifies project-level configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/introduction.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup deploy <provider>\n```\n\n----------------------------------------\n\nTITLE: Invoking requireAuth for a Single Role (JavaScript)\nDESCRIPTION: This snippet shows the basic invocation of the `requireAuth` function to enforce that the current user is authenticated and possesses the 'editor' role. This is typically used at the beginning of backend service or function logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nrequireAuth({ roles: 'editor' })\n```\n\n----------------------------------------\n\nTITLE: Configuring PM2 for Redwood App and Deployment - JavaScript\nDESCRIPTION: This JavaScript file (pm2.config.js) configures PM2 to run and deploy a Redwood app. It specifies the Node.js process, environment variables for dev and production, and the deployment workflow with Git, SSH, and post-deploy commands for build, migrations, and PM2 reload. Requires Node.js, PM2, SSH key auth, and correctly set repository variables.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/self-hosting-redwood.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst name = 'redwood-pm2' // Name to use in PM2\nconst repo = 'git@github.com:njjkgeerts/redwood-pm2.git' // Link to your repo\nconst user = 'deploy' // Server user\nconst path = `/home/${user}/${name}` // Path on the server to deploy to\nconst host = 'example.com' // Server hostname\nconst port = 8911 // Port to use locally on the server\nconst build = `yarn install && yarn rw build && yarn rw prisma migrate deploy`\n\nmodule.exports = {\n  apps: [\n    {\n      name,\n      node_args: '-r dotenv/config',\n      cwd: `${path}/current/`,\n      script: 'yarn rw serve api',\n      args: `--port ${port}`,\n      env: {\n        NODE_ENV: 'development',\n      },\n      env_production: {\n        NODE_ENV: 'production',\n      },\n    },\n  ],\n\n  deploy: {\n    production: {\n      user,\n      host,\n      ref: 'origin/master',\n      repo,\n      path,\n      ssh_options: 'ForwardAgent=yes',\n      'post-deploy': `${build} && pm2 reload pm2.config.js --env production && pm2 save`,\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Form Integration and State Management in HomePage - RedwoodJS - JSX\nDESCRIPTION: Implements a form where users input a US zip code, manages zip state using React's useState, and conditionally renders the WeatherCell with the entered zip. Utilizes RedwoodJS Form and TextField components with validation for 5-digit zip codes. Dependencies include '@redwoodjs/forms' and 'react'; expects user input and displays the results from WeatherCell, showing feedback for invalid or unsubmitted zips.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, Submit } from '@redwoodjs/forms'\nimport { useState } from 'react'\nimport WeatherCell from 'src/components/WeatherCell'\n\nconst HomePage = () => {\n  const [zip, setZip] = useState()\n\n  const onSubmit = (data) => {\n    setZip(data.zip)\n  }\n\n  return (\n    <>\n      <Form onSubmit={onSubmit} style={{ fontSize: '2rem' }}>\n        <TextField\n          name=\"zip\"\n          placeholder=\"Zip code\"\n          maxLength=\"5\"\n          validation={{ required: true, pattern: /^\\d{5}$/ }}\n        />\n        <Submit>Go</Submit>\n      </Form>\n      {zip && <WeatherCell zip={zip} />}\n    </>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Building a Custom Required Field Component (RedwoodJS, JSX)\nDESCRIPTION: Implements a composite custom input field component in RedwoodJS, integrating react-hook-form registration and Redwood's error styling utilities. The RequiredField component provides internal label rendering, input binding, error display via <FieldError>, and automatic required validation. It requires '@redwoodjs/forms' package, and is meant for complex domain-specific fields within custom forms.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { FieldError, useErrorStyles, useRegister } from '@redwoodjs/forms'\n\nconst RequiredField = ({ label, name, validation }) => {\n  const register = useRegister({\n    name,\n    validation: {...validation, required: true}\n  })\n\n  const { className: labelClassName, style: labelStyle } = useErrorStyles({\n    className: `my-label-class`,\n    errorClassName: `my-label-error-class`,\n    name,\n  })\n\n  const { className: inputClassName, style: inputStyle } = useErrorStyles({\n    className: `my-input-class`,\n    errorClassName: `my-input-error-class`,\n    name,\n  })\n\n  return (\n    <>\n      <label className={labelClassName} style={labelStyle}>{label}</label>\n      <input\n        className={inputClassName}\n        style={inputStyle}\n        type=\"text\"\n        {...register}\n      />\n      <FieldError name={name}>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Rendering Delete Button in RedwoodJS Component (TSX)\nDESCRIPTION: This snippet provides the TypeScript version (`Comment.tsx`) of conditionally rendering a 'Delete' button. It uses the `useAuth` hook and `hasRole` function similar to the JavaScript version but includes TypeScript type annotations for props (`Props` interface) and function parameters.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\nimport { useAuth } from 'src/auth'\n\nconst formattedDate = (datetime: ConstructorParameters<typeof Date>[0]) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n\ninterface Props {\n  comment: {\n    name: string\n    createdAt: string\n    body: string\n  }\n}\n\nconst Comment = ({ comment }: Props) => {\n  // highlight-start\n  const { hasRole } = useAuth()\n  const moderate = () => {\n    if (confirm('Are you sure?')) {\n      // TODO: delete comment\n    }\n  }\n  // highlight-end\n\n  return (\n    // highlight-next-line\n    <div className=\"bg-gray-200 p-8 rounded-lg relative\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n      // highlight-start\n      {hasRole('moderator') && (\n        <button\n          type=\"button\"\n          onClick={moderate}\n          className=\"absolute bottom-2 right-2 bg-red-500 text-xs rounded text-white px-2 py-1\"\n        >\n          Delete\n        </button>\n      )}\n      // highlight-end\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Updating User Model in Prisma Schema for Identities\nDESCRIPTION: Updates the `User` model in the Prisma schema (`/api/db/schema.prisma`). It adds a one-to-many relation `identities` linking to the `Identity` model. It also makes the `hashedPassword` and `salt` fields optional (`?`) to accommodate users who authenticate solely through external providers like GitHub.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_6\n\nLANGUAGE: prisma\nCODE:\n```\nmodel User {\n  id                  Int       @id @default(autoincrement())\n  email               String    @unique\n  // highlight-start\n  hashedPassword      String?\n  salt                String?\n  identities          Identity[]\n  // highlight-end\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Rendering Error with Failure Component in RedwoodJS Cell (JavaScript/JSX)\nDESCRIPTION: This Failure component receives an error and an errorCode, and conditionally renders the error heading. It utilizes the useTranslation hook for error message localization and displays both the error message and code. Requires React, useTranslation (from i18n library), and CellFailureProps typing if using TypeScript; error and errorCode are expected props, and outputs a red error message block.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Failure = ({ error, errorCode }: CellFailureProps) => {\n  const { t } = useTranslation()\n  return (\n    <div style={{ color: 'red' }}>\n      {errorCode === 'NO_CONFIG' ? <h1>NO_CONFIG</h1> : <h1>ERROR</h1>}\n      Error: {error.message} - Code: {errorCode} - {t(`error.${errorCode}`)}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS SDL and Service Files (Bash)\nDESCRIPTION: This command uses the RedwoodJS CLI (`rw`) to generate the GraphQL SDL (Schema Definition Language) file and the corresponding service file for the 'Contact' model. This automates the creation of boilerplate code for defining the GraphQL API and its business logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g sdl Contact\n```\n\n----------------------------------------\n\nTITLE: Implementing Comments Query by postId in Service Layer - TypeScript\nDESCRIPTION: The TypeScript service snippet defines the comments function to accept a postId argument (matching a Prisma.CommentWhereInput partial) and uses Prisma's db.comment.findMany API for data retrieval. This ensures type safety and returns all comments related to a given postId. Ensures the argument signature matches Prisma's expected input.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_35\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const comments = ({\\n  postId,\\n}: Required<Pick<Prisma.CommentWhereInput, 'postId'>>) => {\\n  return db.comment.findMany({ where: { postId } })\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a GraphQL Fragment - GraphQL\nDESCRIPTION: This snippet showcases the declaration of a reusable GraphQL fragment (BookInfo) and demonstrates its inclusion in a query (GetBookDetails). It enables reusing field selections across multiple queries to improve code maintainability and consistency. Inputs include a variable ($bookId: ID!), and the expected output is a book object with the specified fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n# Define a GraphQL fragment for book information\\nfragment BookInfo on Book {\\n  id\\n  title\\n  author\\n  publicationYear\\n}\\n\\n# Example query using the BookInfo fragment\\nquery GetBookDetails($bookId: ID!) {\\n  book(id: $bookId) {\\n    ...BookInfo\\n    description\\n    # Include other fields specific to this query\\n  }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Weather Data with React State and RedwoodJS Forms - JSX\nDESCRIPTION: This snippet defines a React component for RedwoodJS that includes a form to accept a zip code, fetches weather data from the OpenWeather API upon form submission, stores the result in local state, and renders a raw JSON dump to the UI. It requires '@redwoodjs/forms' for form elements and expects a valid OpenWeather API key. The input field is validated for exactly five digits, and the component returns either the fetched JSON or nothing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useState } from 'react'\nimport { Form, TextField, Submit } from '@redwoodjs/forms'\n\nconst HomePage = () => {\n  const [weather, setWeather] = useState()\n\n  const onSubmit = (data) => {\n    fetch(\n      `https://api.openweathermap.org/data/2.5/weather?zip=${data.zip},us&appid=YOUR_API_KEY`\n    )\n      .then((response) => response.json())\n      .then((json) => setWeather(json))\n  }\n\n  return (\n    <>\n      <Form onSubmit={onSubmit}>\n        <TextField\n          name=\"zip\"\n          placeholder=\"Zip code\"\n          maxLength=\"5\"\n          validation={{ required: true, pattern: /^\\d{5}$/ }}\n        />\n        <Submit>Go</Submit>\n      </Form>\n      {weather && JSON.stringify(weather)}\n    </>\n  )\n}\n\nexport default HomePage\n\n```\n\n----------------------------------------\n\nTITLE: Testing Article Component with Conditional Comments in RedwoodJS (JSX)\nDESCRIPTION: This JSX code demonstrates unit tests for the `Article` component using `@redwoodjs/testing`. It verifies rendering of the full article, a summary view, and specifically tests that comments (using data from `CommentsCell.mock`) are rendered only when the full article is displayed (`summary` prop is false) and not when the summary is shown. It utilizes `render`, `screen`, and `waitFor` for asynchronous operations like waiting for comments to potentially load.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n// title=\"web/src/components/Article/Article.test.jsx\"\n// highlight-start\nimport { render, screen, waitFor } from '@redwoodjs/testing'\n\nimport { standard } from 'src/components/CommentsCell/CommentsCell.mock'\n// highlight-end\n\nimport Article from './Article'\n\nconst ARTICLE = {\n  id: 1,\n  title: 'First post',\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\n  createdAt: new Date().toISOString(),\n}\n\ndescribe('Article', () => {\n  it('renders a blog post', () => {\n    render(<Article article={ARTICLE} />)\n\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(screen.getByText(ARTICLE.body)).toBeInTheDocument()\n  })\n\n  // highlight-start\n  it('renders comments when displaying a full blog post', async () => {\n    const comment = standard().comments[0]\n    render(<Article article={ARTICLE} />)\n\n    await waitFor(() =>\n      expect(screen.getByText(comment.body)).toBeInTheDocument()\n    )\n  })\n  // highlight-end\n\n  it('renders a summary of a blog post', () => {\n    render(<Article article={ARTICLE} summary={true} />)\n\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(\n      screen.getByText(\n        'Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Str...'\n      )\n    ).toBeInTheDocument()\n  })\n\n  // highlight-start\n  it('does not render comments when displaying a summary', async () => {\n    const comment = standard().comments[0]\n    render(<Article article={ARTICLE} summary={true} />)\n\n    await waitFor(() =>\n      expect(screen.queryByText(comment.body)).not.toBeInTheDocument()\n    )\n  })\n  // highlight-end\n})\n\n```\n\n----------------------------------------\n\nTITLE: Refactoring RedwoodJS AboutPage Component (JavaScript/JSX)\nDESCRIPTION: Shows the simplified `AboutPage` component in JavaScript (JSX) after moving the shared header and main wrapper to the `BlogLayout`. This component now only contains the content specific to the 'About' page, including a paragraph and a link back home, along with the `Metadata` component. It still imports `Link` and `routes` for the internal link.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <>\n      <Metadata title=\"About\" description=\"About page\" />\n\n      <p>\n        This site was created to demonstrate my mastery of Redwood: Look on my\n        works, ye mighty, and despair!\n      </p>\n      <Link to={routes.home()}>Return home</Link>\n    </>\n  )\n}\n\nexport default AboutPage\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Scalar in GraphQL Types and Mutations (TypeScript)\nDESCRIPTION: Shows how to apply the custom Currency scalar to type fields and mutation input types in the GraphQL SDL, enabling field-level validation within queries and mutations for stricter data semantics. Placing the scalar in relevant field definitions enforces input/output validation at the schema level.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_28\n\nLANGUAGE: TSX\nCODE:\n```\nexport const schema = gql`\n  type Product {\n    id: Int!\n    name: String!\n    description: String!\n    currency_iso_4217: Currency! // validate on query\n    createdAt: DateTime!\n  }\n\n  type Query {\n    products: [Product!]! @requireAuth\n    product(id: Int!): Product @requireAuth\n  }\n\n  input CreateProductInput {\n    name: String!\n    description: String!\n    currency_iso_4217: Currency! // validate on mutation\n  }\n\n  input UpdateProductInput {\n    name: String\n    description: String\n    currency_iso_4217: Currency // validate on mutation\n  }\n\n  type Mutation {\n    createProduct(input: CreateProductInput!): Product! @requireAuth\n    updateProduct(id: Int!, input: UpdateProductInput!): Product! @requireAuth\n    deleteProduct(id: Int!): Product! @requireAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Defining Route with Integer Param Type in RedwoodJS (TypeScript)\nDESCRIPTION: Configures a RedwoodJS route in `Routes.tsx` using TypeScript. The path `/article/{id:Int}` uses a route param type (`:Int`) to ensure the `id` parameter is numeric and converts it to a number before passing it to the `ArticlePage`. This prevents type mismatches with the GraphQL query variable.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\n<Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n```\n\n----------------------------------------\n\nTITLE: Defining Typed Test Scenarios with defineScenario (Single Model) in TypeScript\nDESCRIPTION: Demonstrates using the `defineScenario` function to create typed test scenarios for a single Prisma model. It leverages generics like `Prisma.PostCreateArgs` (for data structure), `'post'` (model name), and `'one'` (scenario key) to provide type checking and autocompletion when defining scenario data. Depends on `@prisma/client` types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Prisma, Post } from '@prisma/client'\n\nexport const standard = defineScenario<Prisma.PostCreateArgs, 'post', 'one'>({ // highlight-line\n  //👇 TName\n  post: {\n    // 👇 TKey\n    one: {\n      // 👇 PrismaCreateType. Notice how we import the type from @prisma/client\n      data: { title: 'String', body: 'String', metadata: { foo: 'bar' } },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Returning GraphQL Errors in Mock Response using ctx.errors in JSX\nDESCRIPTION: Illustrates using the `ctx.errors()` method within a mock function handler to return a GraphQL error object in the response. This is useful for testing error handling logic in components. The example returns a single error with a message.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/mocking-graphql-requests.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nmockGraphQLQuery('OperationName', (_variables, { ctx }) => {\n  ctx.errors([{ message: 'Uh, oh!' }])\n})\n```\n\n----------------------------------------\n\nTITLE: Adding a Dashboard Route in RedwoodJS (tsx)\nDESCRIPTION: This JSX snippet adds a new route to the RedwoodJS routes file, mapping the root path to the DashboardPage. It ensures the newly generated dashboard page is accessible at '/'. Must be added to web/src/Routes.tsx.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// web/src/Routes.tsx`\n\n<Route path=\"/\" page={DashboardPage} name=\"dashboard\" />\n```\n\n----------------------------------------\n\nTITLE: Querying Comments by postId with GraphQL in RedwoodJS (TypeScript)\nDESCRIPTION: This snippet declares a typed GraphQL query in TypeScript for fetching comments tied to a specific post via the postId variable. It's intended for use with TypedDocumentNode to enable TypeScript safety within Redwood Cells or Apollo Client. Required inputs are CommentsQuery, CommentsQueryVariables types, and postId (Int). The output structure includes the comment fields for a post, and it assumes proper GraphQL backend schema support.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_33\n\nLANGUAGE: graphql\nCODE:\n```\nexport const QUERY: TypedDocumentNode<CommentsQuery, CommentsQueryVariables> =\\n  gql`\\n    // highlight-start\\n    query CommentsQuery($postId: Int!) {\\n      comments(postId: $postId) {\\n      // highlight-end\\n        id\\n        name\\n        body\\n        createdAt\\n      }\\n    }\\n  `\n```\n\n----------------------------------------\n\nTITLE: Submitting Contact Form with Mutation - RedwoodJS - JavaScript\nDESCRIPTION: This snippet shows a functional ContactPage component in JavaScript using RedwoodJS. It defines an onSubmit function that triggers the create mutation with the form data, handles default field validations, and renders a basic contact form with name, email, and message fields. Dependencies include RedwoodJS's web and forms components as well as a GraphQL mutation created elsewhere. The form expects name, email, and message fields, performs validation, and submits a contact creation request.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nconst onSubmit = (data) => {\n  // highlight-next-line\n  create({ variables: { input: data } })\n}\n\nreturn (\n  <>\n    <Metadata title=\"Contact\" description=\"Contact page\" />\n\n    <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n      <Label name=\"name\" errorClassName=\"error\">\n        Name\n      </Label>\n      <TextField\n        name=\"name\"\n        validation={{ required: true }}\n        errorClassName=\"error\"\n      />\n      <FieldError name=\"name\" className=\"error\" />\n\n      <Label name=\"email\" errorClassName=\"error\">\n        Email\n      </Label>\n      <TextField\n        name=\"email\"\n        validation={{\n          required: true,\n          pattern: {\n            value: /^[^@]+@[^.]+\\..+$/,\n            message: 'Please enter a valid email address',\n          },\n        }}\n        errorClassName=\"error\"\n      />\n      <FieldError name=\"email\" className=\"error\" />\n\n      <Label name=\"message\" errorClassName=\"error\">\n        Message\n      </Label>\n      <TextAreaField\n        name=\"message\"\n        validation={{ required: true }}\n        errorClassName=\"error\"\n      />\n      <FieldError name=\"message\" className=\"error\" />\n\n      <Submit>Save</Submit>\n    </Form>\n  </>\n)\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Creating a RedwoodJS Project with JavaScript using Yarn\nDESCRIPTION: This command uses Yarn's `create` command to scaffold a new RedwoodJS application in a directory named `redwoodblog`. It specifically sets up the project using JavaScript as the primary language. Requires Yarn to be installed globally.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/installation.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn create redwood-app ./redwoodblog\n```\n\n----------------------------------------\n\nTITLE: Querying All Post IDs in GraphQL Playground - GraphQL\nDESCRIPTION: This snippet demonstrates how to query all post IDs from the backend using GraphQL syntax within the GraphiQL Playground. No external dependencies are required beyond the running RedwoodJS and GraphQL Yoga setup. The query retrieves 'id' fields for all posts, forming the basis for more complex data retrieval operations. Inputs: none; Outputs: JSON list of 'id' values for each post in the database. The snippet is to be entered in the Playground UI.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_6\n\nLANGUAGE: GraphQL\nCODE:\n```\n{\n  posts {\n    id\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Display of Picker and Uploaded Image in RedwoodJS Form (JavaScript)\nDESCRIPTION: This snippet demonstrates conditional rendering in a RedwoodJS image form: the PickerInline uploader is hidden once an image is uploaded (url exists) and the uploaded image is shown immediately. The style property toggles the uploader's display based on url state. Inputs are the image URL state and PickerInline uploader; outputs are the conditional UI elements for improved user experience. Requires react, filestack-react, and appropriate styling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {5,8} title=\\\"web/src/components/ImageForm/ImageForm.js\\\"\n<PickerInline\n  apikey={process.env.REDWOOD_ENV_FILESTACK_API_KEY}\n  onSuccess={onFileUpload}\n>\n  <div style={{ display: url ? 'none' : 'block', height: '500px' }}></div>\n</PickerInline>\n\n{url && <img src={url} style={{ marginTop: '2rem' }} />}\n```\n```\n\n----------------------------------------\n\nTITLE: Testing createComment() with Scenario Data - RedwoodJS (TypeScript)\nDESCRIPTION: Defines a TypeScript test suite for the comments service in RedwoodJS, integrating type-safe scenario objects and the createComment() function. Includes imports for scenario types and validates that the comment is created with expected values and post linkage. Ensures all expected outputs, including database-generated fields like createdAt, are present. Input scenarios are type-checked and linked to actual DB data. Dependencies: RedwoodJS, Prisma type definitions, and TypeScript support.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_31\n\nLANGUAGE: ts\nCODE:\n```\n// highlight-next-line\nimport { comments, createComment } from './comments'\n\n// highlight-next-line\nimport type { StandardScenario, PostOnlyScenario } from './comments.scenarios'\n\ndescribe('comments', () => {\n  scenario('returns all comments', async (scenario: StandardScenario) => {\n    const result = await comments()\n\n    expect(result.length).toEqual(Object.keys(scenario.comment).length)\n  })\n\n  // highlight-start\n  scenario(\n    'postOnly',\n    'creates a new comment',\n    async (scenario: PostOnlyScenario) => {\n      const comment = await createComment({\n        input: {\n          name: 'Billy Bob',\n          body: 'What is your favorite tree bark?',\n          post: {\n            connect: { id: scenario.post.bark.id },\n          },\n        },\n      })\n\n      expect(comment.name).toEqual('Billy Bob')\n      expect(comment.body).toEqual('What is your favorite tree bark?')\n      expect(comment.postId).toEqual(scenario.post.bark.id)\n      expect(comment.createdAt).not.toEqual(null)\n    }\n  )\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Restricting Post Queries/Mutations to Current User in RedwoodJS Services - JavaScript\nDESCRIPTION: This snippet demonstrates how to limit post retrieval, creation, and editing in a RedwoodJS service to only those posts belonging to the currently logged-in user. It uses Prisma ORM through db.post and checks context.currentUser.id for filtering. Key parameters include userId (from context), post id, and input data for mutations. Outputs are single or multiple Post records with attached user information, but update/delete are not yet restricted to user. Requires RedwoodJS, Prisma, and a context setup that exposes the current user.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const posts = () => {\n  // highlight-next-line\n  return db.post.findMany({ where: { userId: context.currentUser.id } })\n}\n\nexport const post = ({ id }) => {\n  // highlight-start\n  return db.post.findFirst({\n    where: { id, userId: context.currentUser.id },\n  })\n  // highlight-end\n}\n\nexport const createPost = ({ input }) => {\n  return db.post.create({\n    data: { ...input, userId: context.currentUser.id },\n  })\n}\n\nexport const updatePost = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deletePost = ({ id }) => {\n  return db.post.delete({\n    where: { id },\n  })\n}\n\nexport const Post = {\n  user: (_obj, { root }) =>\n    db.post.findFirst({ where: { id: root.id } }).user(),\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Audit CRUD Scaffold - Zsh Shell\nDESCRIPTION: Runs RedwoodJS's generator to scaffold CRUD UI and backend for the Audit model, similar to the User scaffolding. Prerequisites: Audit model in schema.prisma, Prisma migration applied. Output: Pages/components and API handlers for Audit logs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_5\n\nLANGUAGE: zsh\nCODE:\n```\nyarn rw g scaffold Audit\n```\n\n----------------------------------------\n\nTITLE: Accessing Post Author in GraphQL Query (GraphQL)\nDESCRIPTION: A sample GraphQL query for retrieving a Post and its associated User (the author) with selected fields. Demonstrates how, once the relationship and resolver are in place, the client can query for Post and related User data in a single request. No dependencies except a properly configured GraphQL API with resolvers for user in Post. Inputs are GraphQL query parameters, output is combined Post and User data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\npost {\n  id\n  title\n  body\n  createdAt\n  user {\n    name\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building RedwoodJS for Vercel Deployment\nDESCRIPTION: This command prepares a RedwoodJS application for deployment on Vercel. Similar to Netlify, it typically builds the project, applies Prisma migrations, and runs data migrations. Options control these steps. Requires `yarn` and RedwoodJS CLI.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_24\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood deploy vercel\n```\n\n----------------------------------------\n\nTITLE: Building/Starting RedwoodJS for Render Deployment\nDESCRIPTION: This command builds the web side or starts the api side for deployment on Render. Requires specifying the `side` argument ('api' or 'web'). Options control Prisma migrations, data migrations, and running the API server. Requires `yarn` and RedwoodJS CLI.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood deploy render <side>\n```\n\n----------------------------------------\n\nTITLE: Using Directives in a GraphQL Query to Test Max Directive Limit (GraphQL, TypeScript Syntax)\nDESCRIPTION: Shows a GraphQL query applying @include and @skip directives across multiple id and title fields to test directive count limits. Demonstrates how requests with numerous directives can impact computation. Used to validate or tune maxDirectives security setting behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_69\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  posts {\n    id @include(if:true)\n    id @include(if:false)\n    id @include(if:false)\n    id @skip(if:true)\n    id @skip(if:true)\n    id @skip(if:true))\n    title @include(if:true)\n    title @include(if:false)\n    title @include(if:false)\n    title @skip(if:true)\n    title @skip(if:true)\n    title @skip(if:true)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a RedwoodJS Page Containing a Cell (JavaScript/JSX)\nDESCRIPTION: This test file renders the `ProductPage` component with different `status` props. When the page renders the `ProductsCell`, RedwoodJS intercepts the cell's GraphQL query and automatically uses the `standard` mock from `ProductCell.mock.js`, passing the `status` prop as a variable. The tests verify that the page renders the correct heading based on the status.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_42\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ProductPage/ProductPage.test.js\"\nimport { render, screen } from '@redwoodjs/testing/web'\nimport ArticleCell from 'src/components/ArticleCell'\n\ndescribe('ProductPage', () => {\n  it('renders in stock products', () => {\n    render(<ProductPage status='instock' />)\n\n    expect(screen.getByText('In Stock')).toBeInTheDocument()\n  })\n\n  it('renders out of stock products', async () => {\n    render(<ProductPage status='outofstock' />)\n\n    expect(screen.getByText('Out of Stock')).toBeInTheDocument()\n  })\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Styling Input Fields on Error in RedwoodJS Form (TSX)\nDESCRIPTION: This TSX snippet shows how to apply the `errorClassName=\"error\"` prop to input components (`<TextField>`, `<TextAreaField>`) within a typed RedwoodJS form. This allows styling the input fields themselves (e.g., adding a red border) when their corresponding validation fails.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_26\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <label htmlFor=\"email\">Email</label>\n        <TextField\n          name=\"email\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Routes Using Redwood Router - JavaScript\nDESCRIPTION: Illustrates how to define and export routes in a RedwoodJS application using JavaScript. Imports requisite components from '@redwoodjs/router', sets up the main Router with two Route elements (one for the homepage and one for a fallback NotFoundPage), and exports the Routes function. The component requires HomePage and NotFoundPage to be present. Expected to be placed in 'web/src/Routes.jsx', takes no props, and maps / and unmatched paths to their respective pages.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/first-page.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route } from '@redwoodjs/router'\n\nconst Routes = () => {\n  return (\n    <Router>\n      // highlight-next-line\n      <Route path=\"/\" page={HomePage} name=\"home\" />\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Cell using CLI (Bash)\nDESCRIPTION: This command uses the RedwoodJS CLI (`yarn rw g cell`) to generate the necessary files for an \"Articles\" cell component. Cells are used in RedwoodJS to encapsulate data fetching logic and manage different loading/error/empty/success states.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g cell Articles\n```\n\n----------------------------------------\n\nTITLE: Running RedwoodJS Tests via Yarn\nDESCRIPTION: This command uses Yarn to execute the RedwoodJS test suite. It invokes the `rw test` command, which typically runs Jest tests configured for the RedwoodJS project. This might be necessary to pick up changes in the database schema (`schema.prisma`) or other configuration files that the test runner might not detect automatically during watch mode.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn rw test\n```\n```\n\n----------------------------------------\n\nTITLE: Cleaning Untracked Files in Git Repository\nDESCRIPTION: This Git command is used to remove all untracked files (`-f` for force), including untracked directories (`-d`), and even files typically ignored by Git (`-x`). It helps reset the working directory to a clean state, which can be necessary before changing branches or troubleshooting build problems. Note that this command permanently deletes files, including potentially important ones like `.env` unless explicitly excluded.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/contributing-walkthrough.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ngit clean -fxd\n```\n\n----------------------------------------\n\nTITLE: Updating Navigation in BlogLayout with RedwoodJS (JavaScript)\nDESCRIPTION: This snippet shows how to add a 'Contact' link to the BlogLayout component in RedwoodJS using JavaScript and JSX. It imports routing helpers and defines a layout which now includes the new Contact link. Dependencies include '@redwoodjs/router'. Key parameters: 'children' for rendered page content. Input is via the children ReactNode; output is the complete layout wrapping the blog content. Maintain consistent navigation in the header.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n\nconst BlogLayout = ({ children }) => {\n  return (\n    <>\n      <header>\n        <h1>\n          <Link to={routes.home()}>Redwood Blog</Link>\n        </h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n            // highlight-start\n            <li>\n              <Link to={routes.contact()}>Contact</Link>\n            </li>\n            // highlight-end\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Configuring Auth Handler CORS and Cookie in RedwoodJS dbAuth (JavaScript/TypeScript)\nDESCRIPTION: This snippet shows how to configure CORS and cookie options in the dbAuth authentication handler for RedwoodJS applications using cookie-based authentication. The 'cors' setting enables cross-origin requests from a specified domain and allows cookies to be sent. The 'cookie' object further configures properties such as HttpOnly, Path, SameSite, and Secure for enhanced security. This setup is needed for sessions to persist between domains and for client login/logout. Prerequisites: dbAuth enabled, RedwoodJS API functions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cors.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\nconst authHandler = new DbAuthHandler(event, context, {\\n  db: db,\\n  authModelAccessor: 'user',\\n  authFields: {\\n    id: 'id',\\n    username: 'email',\\n    hashedPassword: 'hashedPassword',\\n    salt: 'salt',\\n    resetToken: 'resetToken',\\n    resetTokenExpiresAt: 'resetTokenExpiresAt',\\n  },\\n+ cors: {\\n+   origin: 'https://www.example.com', // <-- web side domain\\n+   credentials: true,\\n+ },\\n  cookie: {\\n    HttpOnly: true,\\n    Path: '/',\\n    SameSite: 'Lax',\\n    Secure: true,\\n  },\\n  forgotPassword: forgotPasswordOptions,\\n  login: loginOptions,\\n  resetPassword: resetPasswordOptions,\\n  signup: signupOptions,\\n})\n```\n\nLANGUAGE: jsx\nCODE:\n```\n  cookie: {\\n    HttpOnly: true,\\n    Path: '/',\\n    SameSite: 'None',\\n    Secure: true,\\n  },\n```\n\n----------------------------------------\n\nTITLE: Updating RedwoodJS Routes for Admin Section (JavaScript)\nDESCRIPTION: This JSX code defines the application routes using RedwoodJS Router in a JavaScript file (`Routes.jsx`). It modifies the paths for post management routes (new, edit, view, list) to be nested under `/admin/posts`. It uses `Set` to group routes and apply layouts (`ScaffoldLayout` for admin, `BlogLayout` for public pages). Dependencies include `@redwoodjs/router` and the defined Page components.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/Routes.jsx\"\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n        // highlight-start\n        <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n        <Route path=\"/admin/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n        <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n        <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\n        // highlight-end\n      </Set>\n      <Set wrap={BlogLayout}>\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n```\n\n----------------------------------------\n\nTITLE: Recreating and Applying PostgreSQL Migrations with RedwoodJS CLI in Bash\nDESCRIPTION: Executes the RedwoodJS command to generate new database migrations compatible with PostgreSQL after switching providers and deleting previous SQLite migrations (`api/db/migrations`). It applies the new schema changes to the configured remote database (e.g., on Railway) specified by the `DATABASE_URL` environment variable in the `.env` file, prompting for a migration name.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/deployment.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Component using Yarn CLI\nDESCRIPTION: This command uses the RedwoodJS CLI via Yarn to scaffold a new React component named 'Article'. It creates the necessary files (e.g., `web/src/components/Article/Article.jsx` or `.tsx`, test file, etc.) with boilerplate code within the `web/src/components` directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g component Article\n```\n\n----------------------------------------\n\nTITLE: Chaining Multiple Transformer Directives in RedwoodJS GraphQL SDL\nDESCRIPTION: This GraphQL SDL snippet demonstrates chaining multiple custom transformer directives (`@localTimezone` and `@dateFormat`) on the `createdAt` field. The `@localTimezone` directive would first convert the `DateTime` value based on request context (e.g., headers), and then the `@dateFormat` directive would format the resulting timestamp, potentially removing the time portion.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_17\n\nLANGUAGE: graphql\nCODE:\n```\n  type User {\n    id: Int!\n    name: String!\n    email: String!\n    createdAt: DateTime! @localTimezone @dateFormat\n  }\n```\n\n----------------------------------------\n\nTITLE: Applying Error Styles to Inputs with errorClassName (TypeScript)\nDESCRIPTION: Illustrates using the `errorClassName` prop on RedwoodJS form input components (`<TextField>`, `<TextAreaField>`) within a TypeScript context. The specified CSS class (`error`) is applied to the input element when a validation error exists for that field, enhancing the user experience by highlighting the problematic input.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_26\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <label htmlFor=\"email\">Email</label>\n        <TextField\n          name=\"email\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: User Component with Email Button and Mutations - Redwood/React TSX\nDESCRIPTION: Implements a User detail React component in TSX that fetches a user's data, provides 'Edit', 'Delete', and 'Send email' buttons, and uses RedwoodJS GraphQL mutations to manage email sending and deletion. Uses @redwoodjs/web hooks for GraphQL and toast notifications, as well as navigation utilities. Key parameters: user object; handles ID, email, name, CRUD operations. Dependencies: RedwoodJS app, GraphQL backend with matching mutations. Inputs: Provided user data; Outputs: UI interactions and triggered mutations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useMutation } from '@redwoodjs/web'\nimport { toast } from '@redwoodjs/web/toast'\nimport { Link, routes, navigate } from '@redwoodjs/router'\n\nconst DELETE_USER_MUTATION = gql`\n  mutation DeleteUserMutation($id: String!) {\n    deleteUser(id: $id) {\n      id\n    }\n  }\n`\n\nconst EMAIL_USER_MUTATION = gql`\n  mutation EmailUserMutation($id: String!) {\n    emailUser(id: $id) {\n      id\n    }\n  }\n`\n\nconst timeTag = (datetime) => {\n  return (\n    <time dateTime={datetime} title={datetime}>\n      {new Date(datetime).toUTCString()}\n    </time>\n  )\n}\n\nconst User = ({ user }) => {\n  const [deleteUser] = useMutation(DELETE_USER_MUTATION, {\n    onCompleted: () => {\n      toast.success('User deleted')\n      navigate(routes.users())\n    },\n    onError: (error) => {\n      toast.error(error.message)\n    },\n  })\n\n  const [emailUser] = useMutation(EMAIL_USER_MUTATION, {\n    onCompleted: () => {\n      toast.success('Email sent')\n    },\n    onError: (error) => {\n      toast.error(error.message)\n    },\n  })\n\n  const onDeleteClick = (id) => {\n    if (confirm('Are you sure you want to delete user ' + id + '?')) {\n      deleteUser({ variables: { id } })\n    }\n  }\n\n  const onEmailClick = (user) => {\n    if (confirm(`Are you sure you want to send an email to ${user.name}?`)) {\n      emailUser({ variables: { id: user.id } })\n    }\n  }\n\n  return (\n    <>\n      <div className=\"rw-segment\">\n        <header className=\"rw-segment-header\">\n          <h2 className=\"rw-heading rw-heading-secondary\">\n            User {user.id} Detail\n          </h2>\n        </header>\n        <table className=\"rw-table\">\n          <tbody>\n            <tr>\n              <th>Id</th>\n              <td>{user.id}</td>\n            </tr>\n            <tr>\n              <th>Created at</th>\n              <td>{timeTag(user.createdAt)}</td>\n            </tr>\n            <tr>\n              <th>Updated at</th>\n              <td>{timeTag(user.updatedAt)}</td>\n            </tr>\n            <tr>\n              <th>Email</th>\n              <td>{user.email}</td>\n            </tr>\n            <tr>\n              <th>Name</th>\n              <td>{user.name}</td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n      <nav className=\"rw-button-group\">\n        <Link\n          to={routes.editUser({ id: user.id })}\n          className=\"rw-button rw-button-blue\"\n        >\n          Edit\n        </Link>\n        <button\n          type=\"button\"\n          className=\"rw-button rw-button-red\"\n          onClick={() => onDeleteClick(user.id)}\n        >\n          Delete\n        </button>\n        <button\n          type=\"button\"\n          className=\"rw-button rw-button-blue\"\n          onClick={() => onEmailClick(user)}\n        >\n          Send email\n        </button>\n      </nav>\n    </>\n  )\n}\n\nexport default User\n```\n\n----------------------------------------\n\nTITLE: Expose User Roles in Authentication Logic - TypeScript\nDESCRIPTION: Adjusts the getCurrentUser function for TypeScript to return user id, email, and roles. Ensures type safety and supports RBAC workflows in strict typed environments. Uses Prisma client and expects a session with a valid user id.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport const getCurrentUser = async (session) => {\n  return await db.user.findUnique({\n    where: { id: session.id },\n    // highlight-next-line\n    select: { id: true, email: true, roles: true },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using RedwoodJS Logger (TypeScript)\nDESCRIPTION: Demonstrates how to import and create a logger using RedwoodJS's API, and how to use various logging levels in application code. Depends on '@redwoodjs/api/logger' and assumes presence of a RedwoodJS API project environment. Key parameters include the configuration object for createLogger (options and destination). Input: log messages and optional context objects. Output: formatted log entries to stdout or a specified destination. Intended for API-side usage where you need to log events with varying severity. Limitations: Only functional on the API side; does not affect web/browser-side logging.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createLogger } from '@redwoodjs/api/logger'\n\n/**\n * Creates a logger. Options define how to log. Destination defines where to log.\n * If no destination, std out.\n */\nexport const logger = createLogger({})\n\n// then, in your api service, lib, or function\nimport { logger } from 'src/lib/logger'\n\n//...\n\nlogger.trace(`>> items service -> About to save item ${item.name}`)\nlogger.info(`Saving item ${item.name}`)\nlogger.debug({ item }, `Item ${item.name} detail`)\nlogger.warn(item, `Item ${item.id} is missing a name`)\nlogger.warn(\n  { missing: { name: item.name } },\n  `Item ${item.id} is missing values`\n)\nlogger.error(error, `Failed to save item`)\n```\n\n----------------------------------------\n\nTITLE: Using RedwoodJS Scenarios in Tests\nDESCRIPTION: These snippets demonstrate how to use a defined scenario within RedwoodJS tests. The standard `it()` test function is replaced with `scenario()`. The scenario data, including database-assigned IDs, is passed as an argument to the test function, allowing access to specific seeded records (e.g., `scenario.user.dom`) for assertions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_54\n\nLANGUAGE: javascript\nCODE:\n```\nscenario('retrieves all users', async (scenario) => {\n  const list = await users()\n\n  expect(list.length).toEqual(Object.keys(scenario.user).length)\n})\n\nscenario('retrieves a single user', async (scenario) => {\n  const record = await user({ id: scenario.user.dom.id })\n\n  expect(record.id).toEqual(scenario.user.dom.id)\n})\n```\n\n----------------------------------------\n\nTITLE: Allowing Uploaded Image Replacement in RedwoodJS Image Form (JavaScript)\nDESCRIPTION: This snippet adds a 'Replace Image' button below the uploaded image, allowing users to clear the current image from state (setUrl(null)) and re-show the uploader. This conditional rendering supports better UX for replacing or correcting uploaded files. Dependencies are react, filestack-react, and styling for buttons. Outputs new UI options to revert or change images during form editing or creation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {8-18} title=\\\"web/src/components/ImageForm/ImageForm.js\\\"\n<PickerInline\n  apikey={process.env.REDWOOD_ENV_FILESTACK_API_KEY}\n  onSuccess={onFileUpload}\n>\n  <div style={{ display: url ? 'none' : 'block', height: '500px' }}></div>\n</PickerInline>\n\n{url && (\n  <div>\n    <img src={url} style={{ display: 'block', margin: '2rem 0' }} />\n    <button\n      onClick={() => setUrl(null)}\n      className=\"rw-button rw-button-blue\"\n    >\n      Replace Image\n    </button>\n  </div>\n)}\n```\n```\n\n----------------------------------------\n\nTITLE: Destroying Generated RedwoodJS Artifacts\nDESCRIPTION: This command rolls back changes made by the `yarn redwood generate` command. It removes the specified type of generated artifact (e.g., cell, component, page, service). Requires `yarn`, RedwoodJS CLI, and specifying the artifact `type`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_26\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood destroy <type>\n```\n\n----------------------------------------\n\nTITLE: Building a Validated Zip Code Form with RedwoodJS Forms - JSX\nDESCRIPTION: Implements a homepage component in RedwoodJS with a form that accepts and validates a US zip code. Requires @redwoodjs/forms package as a dependency. The form checks for required input and a five-digit pattern, then logs the submitted zip code to the console. Passes form data as an object to the onSubmit callback; no API calls are made yet. Output is conditional on user input and validation, resulting in zip code appearing in the console.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, Submit } from '@redwoodjs/forms'\n\nconst HomePage = () => {\n  const onSubmit = (data) => {\n    console.info(data)\n  }\n\n  return (\n    <Form onSubmit={onSubmit} style={{fontSize: '2rem'}}>\n      <TextField\n        name=\"zip\"\n        placeholder=\"Zip code\"\n        maxLength=\"5\"\n        validation={{ required: true, pattern: /^\\d{5}$/ }}\n      />\n      <Submit>Go</Submit>\n    </Form>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Instantiating MemcachedClient with Redwood Logger - JavaScript\nDESCRIPTION: Shows how to initialize a `MemcachedClient` instance with dynamic server address from an environment variable and pass a formatted logger for error reporting. This pattern supports scalable, environment-specific cache server configuration and integrates customized error logging.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_67\n\nLANGUAGE: js\nCODE:\n```\nclient = new MemcachedClient(process.env.CACHE_SERVER, {\\n  logger: memJsFormattedLogger,\\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Nhost Backend URL Environment Variable - Bash (.env format)\nDESCRIPTION: Defines an environment variable, 'NHOST_BACKEND_URL', in the project's .env file to store the backend API endpoint for the Nhost service. This value must be securely obtained from the Nhost dashboard and should match the API URL for your application instance. The variable is later referenced by the client initialization code for authentication operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nNHOST_BACKEND_URL=\"...\"\n```\n\n----------------------------------------\n\nTITLE: Importing KpiCard Component and Type to Dashboard (tsx)\nDESCRIPTION: These two import statements bring the KpiCard component and its associated Kpi type from their defined location in the RedwoodJS project. They enable type-safe usage of metrics cards within the DashboardPage component. Must be located at the top of web/src/pages/DashboardPage.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport KpiCard from 'src/components/KpiCard/KpiCard' // 👉 Import the KpiCard component\nimport type { Kpi } from 'src/components/KpiCard/KpiCard' // 👉 Import the Kpi type\n```\n\n----------------------------------------\n\nTITLE: Extending GraphQL Query Fields in RedwoodJS Cell (JavaScript)\nDESCRIPTION: Modifies the `QUERY` constant within `ArticlesCell.jsx`. It adds the `title`, `body`, and `createdAt` fields to the selection set for the `articles` (aliased `posts`) query, alongside the existing `id`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nexport const QUERY = gql`\n  query ArticlesQuery {\n    articles: posts {\n      id\n      // highlight-start\n      title\n      body\n      createdAt\n      // highlight-end\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Development Server\nDESCRIPTION: This sequence of commands first changes the current directory to the newly created 'redwoodblog' project folder. Then, it installs all necessary project dependencies using Yarn. Finally, it starts the RedwoodJS development server, which typically becomes accessible at http://localhost:8910.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/installation.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd redwoodblog\nyarn install\nyarn redwood dev\n```\n\n----------------------------------------\n\nTITLE: Using Named Route Functions with Parameters - RedwoodJS - JSX\nDESCRIPTION: Demonstrates generating links using named route functions with object arguments for route parameters. Shows that extra parameters not defined in the route are appended as search params. Dependencies: RedwoodJS routes helper. Inputs: object mapping parameter names to values. Outputs: URL with parameter values substituted and extra keys expressed as query parameters.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\n<Link to={routes.user({ id: 7 })}>...</Link>\n```\n\nLANGUAGE: jsx\nCODE:\n```\n<Link to={routes.users({ sort: 'desc', filter: 'all' })}>...</Link>\n// => \"/users?sort=desc&filter=all\"\n```\n\n----------------------------------------\n\nTITLE: Integrating useAuth Hook for Signup with GoTrue-JS in JavaScript\nDESCRIPTION: This snippet connects the SignupPage to RedwoodJS's authentication context using the useAuth hook, making the GoTrue-JS client accessible. It sets up the form for implementing signup via client.signup. Requires '@redwoodjs/auth' and proper configuration of AuthProvider higher in the component tree. Domains where email/password authentication is set up and GoTrue-JS client is available are prerequisites.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from '@redwoodjs/auth'\n\nconst SignupPage = () => {\n  const { client } = useAuth()\n\n  const onSubmit = (data) => {\n    // do something here\n  }\n\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form onSubmit={onSubmit}>\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Connecting to Supabase PostgreSQL with and without Pooling\nDESCRIPTION: Provides example connection strings for connecting to a Supabase PostgreSQL database. The first example shows a direct, non-pooled connection (typically on port 5432), while the second shows a pooled connection using PgBouncer (typically on port 6543) with the required `sslmode=require` and `pgbouncer=true` parameters. Using the pooled connection is recommended for serverless applications.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/connection-pooling.md#_snippet_1\n\nLANGUAGE: uri\nCODE:\n```\n// not pooled typically uses port 5432\npostgresql://postgres:mydb.supabase.co:5432/postgres?sslmode=require\n// pooled typically uses port 6543\npostgresql://postgres:mydb.supabase.co:6543/postgres?sslmode=require&pgbouncer=true\n```\n\n----------------------------------------\n\nTITLE: Configuring Browser Behavior in redwood.toml - TOML\nDESCRIPTION: Sets browser.open to true in the [browser] section of redwood.toml, so the local development server will open the default browser automatically at server startup. This can be toggled or removed to suppress browser auto-launch. No dependencies, but requires compatible OS/browser.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[browser]\n  open = true\n```\n\n----------------------------------------\n\nTITLE: Sample Dev Server Launch with GraphQL Schema Verification Failure - Bash\nDESCRIPTION: This terminal/message output displays what happens when the RedwoodJS dev server starts and schema directive verification fails. It shows build progress, followed by a fatal error and a message listing each query or mutation missing required auth or custom directives, helping maintain API security. Inputs are attempts to start the dev server with the dev command, and outputs are error messages. There are no dependencies beyond the RedwoodJS dev environment and server files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ngen | Generating TypeScript definitions and GraphQL schemas...\ngen | 37 files generated\napi | Building... Took 444 ms\napi | Starting API Server... Took 2 ms\napi | Listening on http://localhost:8911/\napi | Importing Server Functions...\nweb | ...\napi | FATAL [2021-09-24 18:41:49.700 +0000]:\napi | ⚠️ GraphQL server crashed\napi \\\n  | api | Error: You must specify one of @requireAuth, @skipAuth or a custom directive for\napi | - contacts Query\napi | - posts Query\napi | - post Query\napi | - createContact Mutation\napi | - createPost Mutation\napi | - updatePost Mutation\napi | - deletePost Mutation\n```\n\n----------------------------------------\n\nTITLE: Defining Typed Success Component Signature with Aliased Prop (TypeScript)\nDESCRIPTION: Exports a TypeScript React functional component named `Success`. It destructures the `articles` prop and uses RedwoodJS's `CellSuccessProps` utility type along with generated query types (`ArticlesQuery`, `ArticlesQueryVariables`) for type safety.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_19\n\nLANGUAGE: ts\nCODE:\n```\nexport const Success = ({ articles }: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => { ... }\n```\n\n----------------------------------------\n\nTITLE: Exposing User Relationship in the Posts SDL (JavaScript)\nDESCRIPTION: Updates the posts GraphQL SDL to expose the user relationship on the Post type. This change makes the associated User available as a non-nullable field on Post for all GraphQL queries. Requires RedwoodJS GraphQL SDL conventions and assumes a corresponding relation resolver is implemented. Inputs are Post records, output includes nested User data as resolved by the GraphQL API.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n    // highlight-next-line\n    user: User!\n  }\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Development Server (Bash)\nDESCRIPTION: This command uses the RedwoodJS CLI (`rw`) to start the development server. It bundles assets, starts the API server, and watches for file changes, enabling local development and testing of the RedwoodJS application.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/06_intermission.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw dev\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Named RedwoodJS Scenarios\nDESCRIPTION: This code shows how to define multiple, named scenarios within a single `scenarios.js` file. In addition to the default 'standard' scenario, an 'incomplete' scenario is defined, each containing different sets of user data tailored for specific test cases. Both scenarios are exported.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_55\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = defineScenario({\n  user: {\n    anthony: {\n      data: {\n        name: 'Anthony Campolo',\n        email: 'anthony@redwoodjs.com',\n      },\n    },\n    dom: {\n      data: {\n        name: 'Dom Saadi',\n        email: 'dom@redwoodjs.com',\n      },\n    },\n  },\n})\n\nexport const incomplete = defineScenario({\n  user: {\n    david: {\n      data: {\n        name: 'David Thyresson',\n        email: 'dt@redwoodjs.com',\n      },\n    },\n    forrest: {\n      data: {\n        name: '',\n        email: 'forrest@redwoodjs.com',\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Generating Navigation Component with RedwoodJS CLI (bash)\nDESCRIPTION: This command uses the RedwoodJS CLI to generate a Navigation component scaffold. It is a prerequisite step that creates the boilerplate for implementing authentication-aware navigation in your application. Requires an existing RedwoodJS project setup with yarn.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate component Navigation\n```\n\n----------------------------------------\n\nTITLE: Running RedwoodJS Tests After Scaffolding (Shell)\nDESCRIPTION: Runs the RedwoodJS test suite (`yarn rw test`) again after generating the `UserExample` scaffold. This verifies that the tests included with the scaffold pass correctly, including service tests that interact with the test database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nyarn rw test\n```\n\n----------------------------------------\n\nTITLE: Stopping Background Workers (Production) using Bash\nDESCRIPTION: This command sends a signal to gracefully stop the background job worker processes previously started with `yarn rw jobs start`. Workers will attempt to finish their current task before exiting.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs stop\n```\n\n----------------------------------------\n\nTITLE: Defining ArticleCell Query and States (TypeScript)\nDESCRIPTION: Defines the GraphQL query (`FindArticleQuery`) within the `ArticleCell` (TypeScript version) using `TypedDocumentNode` for type safety. It fetches specific fields of a post by its `$id`, aliasing `post` to `article`. Typed versions of the standard RedwoodJS Cell state components (`Loading`, `Empty`, `Failure`, `Success`) are defined, using imported GraphQL types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { FindArticleQuery, FindArticleQueryVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypedDocumentNode,\n} from '@redwoodjs/web'\n\nexport const QUERY: TypedDocumentNode<\n  FindArticleQuery,\n  FindArticleQueryVariables\n> = gql`\n  query FindArticleQuery($id: Int!) {\n    // highlight-next-line\n    article: post(id: $id) {\n      id\n      // highlight-start\n      title\n      body\n      createdAt\n      // highlight-end\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<FindArticleQueryVariables>) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  article,\n}: CellSuccessProps<FindArticleQuery, FindArticleQueryVariables>) => {\n  return <div>{JSON.stringify(article)}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Cell with Manual Query Handling in React (JavaScript/JSX)\nDESCRIPTION: This advanced example gives a complete manual implementation of a RedwoodJS-like Cell. It defines all relevant UI states ('Loading', 'Empty', 'Failure', 'Success'), a query, and a Cell component that manages state based on the GraphQL response. Imperatively checks for loading, error, empty, and success using auxiliary methods. Requires React, a Query component (e.g., from Apollo), GraphQL client, and helper functions isDataNull/isDataEmptyArray. Inputs: Query and data from server; Outputs: conditionally rendered UI. Robust, but encourages using Redwood's automation for simplicity and maintainability.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nconst QUERY = gql`\n  query {\n    posts {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nconst Loading = () => <div>Loading...</div>\n\nconst Empty = () => <div>No posts yet!</div>\n\nconst Failure = ({ error }) => (\n  <div>Error loading posts: {error.message}</div>\n)\n\nconst Success = ({ posts }) => {\n  return posts.map((post) => (\n    <article>\n      <h2>{post.title}</h2>\n      <div>{post.body}</div>\n    </article>\n  ))\n}\n\nconst isEmpty = (data) => {\n  return isDataNull(data) || isDataEmptyArray(data)\n}\n\nexport const Cell = () => {\n  return (\n    <Query query={QUERY}>\n      {({ error, loading, data }) => {\n        if (error) {\n          if (Failure) {\n            return <Failure error={error} />\n          } else {\n            console.error(error)\n          }\n        } else if (loading) {\n          return <Loading />\n        } else if (data) {\n          if (typeof Empty !== 'undefined' && isEmpty(data)) {\n            return <Empty />\n          } else {\n            return <Success {...data} />\n          }\n        } else {\n          throw 'Cannot render Cell: graphQL success but `data` is null'\n        }\n      }}\n    </Query>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Blog Layout with RedwoodJS in JavaScript\nDESCRIPTION: This React component defines a layout with a header containing site title/logo and navigation links using RedwoodJS's Link and routes helpers. It receives children elements to render as page content. Dependencies include @redwoodjs/router for routing. The inputs are React children, and the outputs are a composed JSX structure with consistent navigation, focusing on DRY header implementation. Ensure @redwoodjs/router is installed and properly configured; highlight comments are for illustrative and not functional purposes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n\nconst BlogLayout = ({ children }) => {\n  return (\n    <>\n      <header>\n        // highlight-start\n        <h1>\n          <Link to={routes.home()}>Redwood Blog</Link>\n        </h1>\n        // highlight-end\n        <nav>\n          <ul>\n            // highlight-start\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            // highlight-end\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Listing Available Styling UI Setup Options (Shell)\nDESCRIPTION: This command shows available UI styling libraries that can be set up in the current Redwood project using the 'rw setup ui' command. Developers can use it to integrate styling solutions such as Tailwind, Chakra, or others. No required parameters, outputs help and usage details.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup ui --help\n```\n\n----------------------------------------\n\nTITLE: Defining and Using GraphQL Unions in Schema and Queries (TypeScript/GraphQL)\nDESCRIPTION: Shows declaration of a GraphQL union type in SDL and how to query it with inline fragments to fetch variant subfields. Useful when a field can return different object types. All union members must be object types, and the GraphQL client should support detecting and handling their possible types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_30\n\nLANGUAGE: TSX\nCODE:\n```\ntype Query {\n  searchTrees: [FavoriteTree] // This list can include Redwood, Gingko or Oak objects\n}\n```\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery GetFavoriteTrees {\n  __typename // typename is helpful when querying a field that returns one of multiple types\n  searchTrees {\n    ... on Redwood {\n      name\n      height\n    }\n    ... on Ginkgo {\n      name\n      medicalUse\n    }\n    ... on Oak {\n      name\n      acornType\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Article Comment Rendering with RedwoodJS (JavaScript)\nDESCRIPTION: This test suite validates the Article component in RedwoodJS using JavaScript. It ensures an article renders correctly, with separate tests for displaying the full post and summary, and checks that comments are only shown with the full rendering. Dependencies include the RedwoodJS testing library, React, and mock data from CommentsCell.mock. Key parameters include the article object and the summary flag. The suite leverages waitFor() for asynchronous state handling and provides a robust check against incorrectly rendered comments. Inputs are the article object and summary mode flag; expected outputs are correct DOM render states. Requires a valid RedwoodJS project setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_15\n\nLANGUAGE: JavaScript\nCODE:\n```\n// highlight-start\\nimport { render, screen, waitFor } from '@redwoodjs/testing'\\n\\nimport { standard } from 'src/components/CommentsCell/CommentsCell.mock'\\n// highlight-end\\n\\nimport Article from './Article'\\n\\nconst ARTICLE = {\\n  id: 1,\\n  title: 'First post',\\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\\n  createdAt: new Date().toISOString(),\\n}\\n\\ndescribe('Article', () => {\\n  it('renders a blog post', () => {\\n    render(<Article article={ARTICLE} />)\\n\\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\\n    expect(screen.getByText(ARTICLE.body)).toBeInTheDocument()\\n  })\\n\\n  // highlight-start\\n  it('renders comments when displaying a full blog post', async () => {\\n    const comment = standard().comments[0]\\n    render(<Article article={ARTICLE} />)\\n\\n    await waitFor(() =>\\n      expect(screen.getByText(comment.body)).toBeInTheDocument()\\n    )\\n  })\\n  // highlight-end\\n\\n  it('renders a summary of a blog post', () => {\\n    render(<Article article={ARTICLE} summary={true} />)\\n\\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\\n    expect(\\n      screen.getByText(\\n        'Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Str...'\\n      )\\n    ).toBeInTheDocument()\\n  })\\n\\n  // highlight-start\\n  it('does not render comments when displaying a summary', async () => {\\n    const comment = standard().comments[0]\\n    render(<Article article={ARTICLE} summary={true} />)\\n\\n    await waitFor(() =>\\n      expect(screen.queryByText(comment.body)).not.toBeInTheDocument()\\n    )\\n  })\\n  // highlight-end\\n})\\n\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Storybook using CLI (Bash)\nDESCRIPTION: This command uses the RedwoodJS CLI (`rw`) via Yarn to start the Storybook development server. Storybook allows for developing and testing UI components in isolation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw storybook\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Test Scenario Data for Comments - JavaScript\nDESCRIPTION: This scenario defines standard test data for the Comments tests in JavaScript. It sets up two comments, each associated with a different post, specifying sample user names, bodies, and post details. These entries are used to seed the database during testing for validating queries by postId.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_28\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const standard = defineScenario({\\n  comment: {\\n    jane: {\\n      data: {\\n        name: 'Jane Doe',\\n        body: 'I like trees',\\n        post: {\\n          create: {\\n            title: 'Redwood Leaves',\\n            body: 'The quick brown fox jumped over the lazy dog.',\\n          },\\n        },\\n      },\\n    },\\n    john: {\\n      data: {\\n        name: 'John Doe',\\n        body: 'Hug a tree today',\\n        post: {\\n          create: {\\n            title: 'Root Systems',\\n            body: 'The five boxing wizards jump quickly.',\\n          },\\n        },\\n      },\\n    },\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing JWT Verification in authDecoder using jose\nDESCRIPTION: This snippet shows the complete implementation of the `authDecoder` function. It imports `jwtVerify` from 'jose', retrieves the Nhost JWT secret from environment variables (encoding it using `TextEncoder`), and then uses `jwtVerify` to asynchronously verify and decode the provided token against the secret. The decoded payload is returned upon successful verification.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_13\n\nLANGUAGE: ts\nCODE:\n```\nimport { jwtVerify } from 'jose'\n\nexport const authDecoder = async (token: string, type: string) => {\n  if (type !== 'custom-auth') {\n    return null\n  }\n\n  const secret = new TextEncoder().encode(process.env.NHOST_JWT_SECRET)\n\n  const decoded = await jwtVerify(token, secret)\n\n  return decoded\n}\n```\n\n----------------------------------------\n\nTITLE: Hiding Sensitive Fields in User GraphQL SDL (TS)\nDESCRIPTION: Modifies the TypeScript GraphQL SDL file (`users.sdl.ts`) for the `User` type. Similar to the JavaScript version, it comments out sensitive fields (`hashedPassword`, `salt`, `resetToken`, `resetTokenExpiresAt`) to prevent their exposure via the GraphQL API.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n  type User {\n    ...\n    # hashedPassword: String!\n    # salt: String!\n    # resetToken: String\n    # resetTokenExpiresAt: DateTime\n  }\n```\n\n----------------------------------------\n\nTITLE: Subsequent Application Deployments - RedwoodJS - Bash\nDESCRIPTION: This snippet shows the standard redeploy command for pushing further changes after initial deployment. It uses the Serverless deploy provider integration in RedwoodJS and re-uses existing configuration. Requires all environment variables and resources to already be set up from a previous deploy.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/serverless.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy serverless\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Sign In Form with RedwoodJS Forms in JSX\nDESCRIPTION: This React component provides a sign in form using RedwoodJS form components. It defines local state for error messages, renders input fields for 'email' and 'password', and a submit button. The 'onSubmit' handler is a placeholder to be filled in later. The component depends on '@redwoodjs/forms' and assumes React is available in scope. It expects form submission data as input and will need further logic to complete authentication functionality.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\n\nconst SigninPage = () => {\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = (data) => {\n    // do sign in here\n  }\n\n  return (\n    <>\n      <h1>Sign In</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign In</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SigninPage\n```\n\n----------------------------------------\n\nTITLE: Defining a RedwoodJS Scenario with Realistic Data\nDESCRIPTION: This example updates the default 'standard' scenario with more specific data for the 'user' model. It uses descriptive keys ('anthony', 'dom') instead of generic ones and provides actual names and email addresses. This demonstrates how to structure scenario data using objects passed to Prisma's create function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_53\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = defineScenario({\n  user: {\n    anthony: {\n      data: {\n        name: 'Anthony Campolo',\n        email: 'anthony@redwoodjs.com',\n      },\n    },\n    dom: {\n      data: {\n        name: 'Dom Saadi',\n        email: 'dom@redwoodjs.com',\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Passing Additional Props to RedwoodJS Cell (JavaScript)\nDESCRIPTION: Illustrates passing an extra prop (`rand`) along with the required `id` prop to `ArticleCell` in JavaScript. RedwoodJS automatically passes props matching GraphQL variables (`id`) to the query, while making all passed props (`id`, `rand`) available within the Cell's rendering components like `Success`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\n<ArticleCell id={id} rand={Math.random()} />\n```\n\n----------------------------------------\n\nTITLE: Finding Multiple Records with `where()` (JavaScript/JSX)\nDESCRIPTION: JavaScript/JSX examples showcasing the asynchronous `where()` static method on a RedwoodRecord model (`User`) to query for multiple records. It demonstrates finding all records (no arguments), finding records matching specific attributes (e.g., `emailPreference: 'weekly'`), and applying additional Prisma `findMany` options like `orderBy` within the optional second argument.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nawait User.where() // would return all records\nawait User.where({ emailPreference: 'weekly' })\nawait User.where({ theme: 'dark' }, { orderBy: { createdAt: 'desc' } })\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS SDL for a Model with Relations\nDESCRIPTION: This command uses the RedwoodJS CLI (`rw g sdl`) to generate the GraphQL SDL and associated service files for the `Book` model. Running this before generating the SDL for the related `Shelf` model can lead to errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/schema-relations.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g sdl Book\n```\n\n----------------------------------------\n\nTITLE: Setting Page Title Template Using RedwoodProvider - JSX\nDESCRIPTION: This code demonstrates how to apply a consistent page title template across all pages by passing a 'titleTemplate' prop to the <RedwoodProvider> component in RedwoodJS. The template can include placeholders such as %PageTitle and %AppTitle to format titles dynamically. Requires RedwoodJS and use of <RedwoodProvider> in the main app file. Inputs are template strings; the output is dynamic title formatting for each rendered page.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n-  <RedwoodProvider>\n+  <RedwoodProvider titleTemplate=\"%PageTitle | %AppTitle\">\n    /* ... */\n  <RedwoodProvider />\n\n```\n\n----------------------------------------\n\nTITLE: Importing and Using useAuth Hook in RedwoodJS BlogLayout (TypeScript)\nDESCRIPTION: This snippet demonstrates importing the `useAuth` hook from `src/auth` in a TypeScript-based RedwoodJS `BlogLayout` component. It defines a `BlogLayoutProps` type and destructures `isAuthenticated`, `currentUser`, and `logOut` from the hook to access authentication state and functions within the component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/layouts/BlogLayout/BlogLayout.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-next-line\nimport { useAuth } from 'src/auth'\n\ntype BlogLayoutProps = {\n  children?: React.ReactNode\n}\n\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\n  // highlight-next-line\n  const { isAuthenticated, currentUser, logOut } = useAuth()\n\n  return (\n    <>\n      <header>\n        <h1>\n          <Link to={routes.home()}>Redwood Blog</Link>\n        </h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n            <li>\n              <Link to={routes.contact()}>Contact</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n```\n\n----------------------------------------\n\nTITLE: Executing a Prisma Database Migration - Bash\nDESCRIPTION: Runs a migration to snapshot and apply schema changes using RedwoodJS's Prisma CLI integration. The command 'yarn rw prisma migrate dev' initializes a new migration based on the current Prisma schema, executing the resulting SQL against the connected database. Requires Prisma to be installed and a configured database. Prompts for a migration name and results in the creation of corresponding migration files under 'api/db/migrations'. Input is CLI; output includes migration directory and SQL file creation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/getting-dynamic.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested One-to-Many Related Records in JSX\nDESCRIPTION: This example shows accessing records across multiple levels of one-to-many relationships. First, a user is fetched, then their first post is fetched via the `user.posts` proxy, and finally, the comments belonging to that post are fetched via the `post.comments` proxy.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_29\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = await User.find(123)\nconst post = await user.posts.first()\nconst comments = await post.comments.all()\n```\n\n----------------------------------------\n\nTITLE: Fetching Comments and Related Post in RedwoodJS Service (TypeScript)\nDESCRIPTION: Provides typed implementations within 'api/src/services/comments/comments.ts' for retrieving all comments (`db.comment.findMany()`) and a single comment by ID (`db.comment.findUnique()`) using Prisma. Includes a typed resolver `Comment.post` for fetching the related post. Uses types like `QueryResolvers` and `CommentRelationResolvers` from RedwoodJS and Prisma.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/services/comments/comments.ts\"\nimport type { Prisma } from '@prisma/client'\nimport type { ResolverArgs } from '@redwoodjs/graphql-server'\n\nimport { db } from 'src/lib/db'\n\nexport const comments = () => {\n  return db.comment.findMany()\n}\n\nexport const comment = ({ id }: QueryResolvers['comment'] => {\n  return db.comment.findUnique({\n    where: { id },\n  })\n}\n\nexport const Comment: CommentRelationResolvers = {\n  post: (_obj, { root }) => {\n    return db.comment.findUnique({ where: { id: root?.id } }).post()\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Importing useAuth for SigninPage in JSX\nDESCRIPTION: This snippet updates the `SigninPage` component to import the `useAuth` hook from `@redwoodjs/auth`. It destructures the `logIn` function from the hook, preparing it for use in the sign-in process. The `onSubmit` function is also updated to clear any previous errors by calling `setError(null)`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {2,5} title=\"web/src/pages/SigninPage/SigninPage.js\"\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from '@redwoodjs/auth'\n\nconst SigninPage = () => {\n  const { logIn } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = (data) => {\n    setError(null)\n    // do sign in here\n  }\n\n  return (\n    <>\n      <h1>Sign In</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign In</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SigninPage\n```\n```\n\n----------------------------------------\n\nTITLE: Full Routes File with Layouts and Named Params (RedwoodJS, JavaScript)\nDESCRIPTION: This is the complete JavaScript routes configuration for the application's main router, featuring two layout sets and multiple parameterized routes. It includes article, post, home, and about routes, using RedwoodJS's Set wrappers for layout control. Dependencies include all layout and page components. It demonstrates advanced routing patterns, nested layouts, and both static and dynamic routing for resource navigation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route, Set } from '@redwoodjs/router'\\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\\nimport BlogLayout from 'src/layouts/BlogLayout'\\n\\nconst Routes = () => {\\n  return (\\n    <Router>\\n      <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\\n        <Route path=\"/posts/new\" page={PostNewPostPage} name=\"newPost\" />\\n        <Route path=\"/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\\n        <Route path=\"/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\\n        <Route path=\"/posts\" page={PostPostsPage} name=\"posts\" />\\n      </Set>\\n      <Set wrap={BlogLayout}>\\n        // highlight-next-line\\n        <Route path=\"/article/{id}\" page={ArticlePage} name=\"article\" />\\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\\n        <Route path=\"/\" page={HomePage} name=\"home\" />\\n      </Set>\\n      <Route notfound page={NotFoundPage} />\\n    </Router>\\n  )\\n}\\n\\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Setting up RedwoodJS Database Authentication\nDESCRIPTION: This bash command uses the RedwoodJS CLI (`rw`) to set up the built-in database authentication (`dbAuth`). It generates necessary backend files and provides post-install instructions for integrating dbAuth into the application. This command requires the RedwoodJS CLI to be installed (`yarn rw`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn rw setup auth dbAuth\n```\n```\n\n----------------------------------------\n\nTITLE: Styling Input Fields on Error in RedwoodJS Form (JSX)\nDESCRIPTION: This JSX snippet demonstrates using the `errorClassName=\"error\"` prop on RedwoodJS form input components (`<TextField>`, `<TextAreaField>`). This prop applies the specified CSS class (e.g., `.error`) directly to the input element itself when a validation error associated with that field occurs, providing visual indication on the input.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <label htmlFor=\"email\">Email</label>\n        <TextField\n          name=\"email\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Mutation Button with Apollo useMutation Hook - React JSX - jsx\nDESCRIPTION: This React code demonstrates using the useMutation hook from RedwoodJS's web package, allowing components to perform GraphQL mutations on user interaction. The required dependency is @redwoodjs/web, and the code expects a defined MUTATION query or template. Inputs include the mutation definition and optional payload fields provided when the button is clicked, with the output being a promise from Apollo's mutation execution.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useMutation } from '@redwoodjs/web'\n\nconst MUTATION = gql`\n  # your mutation...\n`\n\nconst MutateButton = () => {\n  const [mutate] = useMutation(MUTATION)\n\n  return (\n    <button onClick={() => mutate({ ... })}>\n      Click to mutate\n    </button>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Validating RedwoodJS Contact Form Fields in TypeScript\nDESCRIPTION: Implements a contact page in RedwoodJS, defining name, email, and message fields with associated labels and error components. Uses built-in RedwoodJS form components with client-side required validation, providing instant error feedback as users fill out the inputs. Depends on '@redwoodjs/web' and '@redwoodjs/forms', and expects collected input to conform to the FormValues interface. Input is typically user-typed strings for each field; output is validation and onSubmit processing of values. Constraints include required fields for all three values and real-time error handling via 'errorClassName'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_29\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  // highlight-next-line\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-start\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n        // highlight-start\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"email\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n        // highlight-start\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        // highlight-end\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Accessing Data from Multiple Models in RedwoodJS Tests\nDESCRIPTION: This snippet shows the syntax used within a test to access data seeded across multiple models in a scenario. The `scenario` object passed to the test function provides access to each model's data via `scenario.modelName.recordName` (e.g., `scenario.product.shirt`, `scenario.order.first`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_58\n\nLANGUAGE: javascript\nCODE:\n```\nscenario.product.shirt\nscenario.order.first\nscenario.paymentMethod.credit\n```\n\n----------------------------------------\n\nTITLE: Declaring a RedwoodJS Directive with Arguments on a Field (GraphQL)\nDESCRIPTION: Illustrates how to pass arguments (e.g., `roles: [\"ADMIN\"]`) to a custom directive `@myDirective` when applied to a field `field` within a GraphQL type `Bar`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\ntype Bar {\n  field: String! @myDirective(roles: [\"ADMIN\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Example Baremetal Deployment Configuration (TOML)\nDESCRIPTION: This `deploy.toml` file example defines the configuration for a 'production' deployment environment. It specifies server connection details (host, username, agentForward), which sides to deploy, commands for package management and monitoring (yarn, pm2), the application path on the server, PM2 process names to manage, the Git repository, branch, and the number of releases to keep.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[[production.servers]]\nhost = \"server.com\"\nusername = \"user\"\nagentForward = true\nsides = [\"api\",\"web\"]\npackageManagerCommand = \"yarn\"\nmonitorCommand = \"pm2\"\npath = \"/var/www/app\"\nprocessNames = [\"serve\"]\nrepo = \"git@github.com:myorg/myapp.git\"\nbranch = \"main\"\nkeepReleases = 5\n```\n\n----------------------------------------\n\nTITLE: Implementing a Countdown Subscription Example in GraphQL\nDESCRIPTION: This GraphQL subscription query demonstrates listening for countdown events, emitting numbers from a starting value at regular intervals. It accepts 'from' (start value) and 'interval' (step) parameters. It is intended for example purposes to show a subscription yielding streaming numeric responses. Ensure the underlying resolver and event publisher are implemented.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nsubscription CountdownFromInterval {\n  countdown(from: 100, interval: 10)\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Acceptance Validator with `in` Option in JSX\nDESCRIPTION: Shows the `acceptance` validator configured with the `in` option. This allows an array of values (e.g., `true`, `'true'`, `1`, `'1'`) to be considered as 'accepted', providing flexibility for how truthiness is represented.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.terms, 'Terms of Service', {\n  acceptance: { in: [true, 'true', 1, '1'] },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Related Records in an Implicit Many-to-Many Relationship in JSX\nDESCRIPTION: For implicit many-to-many relationships (managed by Prisma), accessing related records is similar to one-to-many. After fetching one record (e.g., `Product`), related records on the other side (e.g., `categories`) can be accessed via a relation proxy (`product.categories`) using finder methods like `all()`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_32\n\nLANGUAGE: jsx\nCODE:\n```\nconst product = await Product.find(123)\nconst categories = await product.categories.all()\n```\n\n----------------------------------------\n\nTITLE: Example Response for Completed Deferred Query - JSON\nDESCRIPTION: JSON response showing the final delivery where both `fastField` and `slowField` are present, after deferred field resolves. Output from a previously deferred GraphQL query. Contains both fields in `data` object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\": {\n    \"fastField\": \"I am speedy\",\n    \"slowField\": \"I am slow\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Redwood Cell for GraphQL Data Fetching (JavaScript)\nDESCRIPTION: This snippet defines a Redwood Cell, encapsulating fetch logic and UI states for retrieving and displaying testimonials via GraphQL. The file must be suffixed with 'Cell' and exports several named components: QUERY (declaring the GraphQL query), Loading, Failure, and Success. Dependencies include Redwood's GraphQL setup, presence of gql tag, and appropriate data-fetching environment. The Success component receives testimonial data and renders it; if an error occurs, Failure is shown; and on loading, Loading is displayed. Not exporting an Empty state skips its rendering if data is absent.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/02_chapter0/what-is-redwood.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nexport const QUERY = gql`\n  query GetTestimonials {\n    testimonials {\n      id\n      author\n      quote\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Failure = ({ error }) => <div>An error occured! {error.message}</div>\n\nexport const Success = ({ testimonials }) => {\n  return (\n    <ul>\n      {testimonials.map((test) => {\n        <li key={test.id}>{test.quote} — {test.author}</li>\n      })}\n    </ul>\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with `greaterThanOrEqual` Option in JSX\nDESCRIPTION: Illustrates the `numericality` validator using the `greaterThanOrEqual` option to require the input number to be greater than or equal to the specified value.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_34\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.temp, 'Temperature', {\n  numericality: { greaterThanOrEqual: 32 },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Using Partial Matching for RedwoodJS Cache Testing (TypeScript)\nDESCRIPTION: Demonstrates using the `partialMatch` helper from `@redwoodjs/testing/cache` for more flexible cache assertions. It shows how to use `partialMatch` with `toHaveCached` (requiring a key or regex) and with `testCacheClient.contents` to check for partial object or array matches within the cache, ignoring fields like auto-generated IDs or timestamps.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_76\n\nLANGUAGE: ts\nCODE:\n```\n// highlight-next-line\nimport { partialMatch } from '@redwoodjs/testing/cache'\n\nscenario('returns all products', async (scenario: StandardScenario) => {\n  await products()\n\n  // Partial match using the toHaveCached, if you supply a key\n  expect(testCacheClient).toHaveCached(\n    /cached-products.*/,\n    // highlight-next-line\n    partialMatch([{ name: 'LS50', brand: 'KEF' }])\n  )\n\n  // Or you can use the .contents getter\n  expect(testCacheClient.contents).toContainEqual(\n    // check that an array contains an object matching\n    // highlight-next-line\n    partialMatch([{ name: 'LS50', brand: 'KEF' }])\n  )\n}\n\nscenario('finds a single product', () = {\n  await product({id: 5})\n\n  // You can also check for a partial match of an object\n  expect(testCacheClient).toHaveCached(\n    /cached-.*/,\n    // highlight-start\n    partialMatch({\n      name: 'LS50',\n      brand: 'KEF'\n    })\n  )\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Seeding Database with Formatted Logging Output (Bash)\nDESCRIPTION: Demonstrates how to pipe the standard output of the `yarn rw prisma db seed` command to Redwood's log formatter utility (`yarn rw-log-formatter`). This produces prettified log output if the seed script uses the Redwood Logger with structured data (e.g., `logger.debug({ data: ... })`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_102\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma db seed | yarn rw-log-formatter\n```\n\n----------------------------------------\n\nTITLE: Copying Generator Templates for Customization (Bash)\nDESCRIPTION: Runs the `setup generator` command using the Redwood CLI alias `rw`. This copies the template files for a specified generator `<name>` (e.g., `page`, `cell`, `scaffold`) to the local project, allowing for customization. The next time the generator is run, it will use the customized template. The optional `--force` or `-f` flag overwrites existing copied template files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_110\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup generator <name>\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Development Server (Shell)\nDESCRIPTION: Shell commands used to start the RedwoodJS development environment. Running these commands initiates both the web frontend and the API backend processes, including the GraphQL server and the GraphQL Playground accessible at `http://localhost:8911/graphql`. `yarn rw dev` is a common shorthand.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw dev\n```\n\n----------------------------------------\n\nTITLE: Destroying a Page with RedwoodJS CLI - Bash\nDESCRIPTION: This command-line snippet demonstrates how to remove a generated page and its updates from the RedwoodJS project. It expects the page 'name' and optional 'path'. Rolling back removes files and reverts route modifications. Requires an existing RedwoodJS project and the yarn CLI.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_57\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood destroy page <name> [path]\n```\n\n----------------------------------------\n\nTITLE: Adding a Parameterized Route - RedwoodJS - JavaScript (JSX)\nDESCRIPTION: This snippet shows the route configuration for a page with a route parameter. The '/quote/{id}' path is mapped to QuotePage in Routes.js, with a notfound route fallback. Components must match import statements in the application. No direct inputs, but depends on the presence of the QuotePage export.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_63\n\nLANGUAGE: jsx\nCODE:\n```\nconst Routes = () => {\n  return (\n    <Router>\n      <Route path=\"/quote/{id}\" page={QuotePage} name=\"quote\" />\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Article Component with Redwood CLI (Bash)\nDESCRIPTION: Uses the RedwoodJS CLI command `yarn rw g component Article` to scaffold a new React component named `Article`. This command automatically creates the necessary files, including the component file (`Article.jsx` or `Article.tsx`), a test file, and potentially others.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g component Article\n```\n\n----------------------------------------\n\nTITLE: Creating a Type Alias for Scenario Data with ScenarioData in TypeScript\nDESCRIPTION: Demonstrates creating a reusable type alias (e.g., `StandardScenario`) using the `ScenarioData` utility type. This type takes generics for the Prisma model (`Post`) and the model name (`'post'`) to represent the structure of data created by a specific scenario, simplifying type annotations in tests. Depends on `@prisma/client` types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Post } from '@prisma/client'\n\n//...\n\nexport type StandardScenario = ScenarioData<Post, 'post'>\n```\n\n----------------------------------------\n\nTITLE: SSH Password Prompt - Shell\nDESCRIPTION: This shell output snippet indicates the password prompt encountered after initiating an SSH connection to a server using username/password authentication. The SSH client will prompt the user for the password, with keystrokes hidden. Dependency is just the standard SSH client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nroot@192.168.0.122's password:\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Many-to-Many Relation in Prisma Schema\nDESCRIPTION: This Prisma schema snippet defines an implicit many-to-many relationship between `Product` and `Tag` models. Prisma automatically creates a hidden join table. This implicit structure lacks a single `@id` field on the join table, making it incompatible with RedwoodJS CRUD generators.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/schema-relations.md#_snippet_0\n\nLANGUAGE: prisma\nCODE:\n```\nmodel Product {\n  id       Int    @id @default(autoincrement())\n  title    String\n  desc     String\n  tags     Tag[]\n}\n\nmodel Tag {\n  id       Int     @id @default(autoincrement())\n  name     String\n  products Product[]\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking GraphQL Comment Mutation in Storybook (TypeScript)\nDESCRIPTION: Implements TypeScript type-safe mocking for the CreateCommentMutation within a Storybook story. By specifying the mutation and variable types in 'mockGraphQLMutation', it ensures responses align with GraphQL expectations, simulates a delay, and constructs a mock comment response. This setup relies on type exports from 'types/graphql' and can verify UI behavior for asynchronous submissions, disabled states, and error handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport CommentForm from './CommentForm'\n\n// highlight-start\nimport type {\n  CreateCommentMutation,\n  CreateCommentMutationVariables,\n} from 'types/graphql'\n// highlight-end\n\nexport const generated = () => {\n  // highlight-start\n  mockGraphQLMutation<CreateCommentMutation, CreateCommentMutationVariables>(\n    'CreateCommentMutation',\n    (variables, { ctx }) => {\n      const id = Math.floor(Math.random() * 1000)\n      ctx.delay(1000)\n\n      return {\n        createComment: {\n          id,\n          name: variables.input.name,\n          body: variables.input.body,\n          createdAt: new Date().toISOString(),\n        },\n      }\n    }\n  )\n  // highlight-end\n\n  return <CommentForm />\n}\n\nexport default { title: 'Components/CommentForm' }\n```\n\n----------------------------------------\n\nTITLE: Importing a RedwoodRecord Model in Console (JavaScript/JSX)\nDESCRIPTION: JavaScript/JSX code snippet demonstrating how to import the `User` model (and potentially others exported from `api/src/models/index.js`) within the RedwoodJS console for interaction. Requires the model definition and the index file generated by `yarn rw record init`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nconst { User } = require('./api/src/models')\n```\n\n----------------------------------------\n\nTITLE: Deploying to a Custom Stage/Environment - RedwoodJS - Bash\nDESCRIPTION: This command deploys a RedwoodJS app to a custom stage (such as `qa` or `staging`) rather than the production default, using Serverless Framework's stage parameter. An appropriate stage-specific configuration and any necessary environment variables must be present for the deploy to succeed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/serverless.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy serverless --stage qa\n```\n\n----------------------------------------\n\nTITLE: Disabling Submit Button During Mutation Loading in TSX\nDESCRIPTION: This TSX snippet shows how to disable the RedwoodJS `Submit` button based on the `loading` state variable (obtained from `useMutation`). The `disabled` prop is set dynamically, preventing multiple submissions while the mutation is processing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nreturn (\n  // ...\n  // highlight-next-line\n  <Submit disabled={loading}>Save</Submit>\n  // ...\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Exporting and Using a Standard GraphQL Query Mock - RedwoodJS Cell - JavaScript\nDESCRIPTION: This snippet demonstrates how to define a GraphQL query for a RedwoodJS Cell and provide a corresponding mock-data export named `standard` in the `.mock.js` file. By exporting the `standard` mock, Storybook integrates the mock with the queried data automatically; modifying the query requires you to update the mock-data. Dependencies include RedwoodJS Cells and that the Storybook environment is running. Inputs are the query/mutation along with expected fields; outputs are the mocked data returned to the Cell during Storybook previews.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/mocking-graphql-in-storybook.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query UserProfileQuery {\n    userProfile {\n      id\n    }\n  }\n`\n\n// UserProfileCell/UserProfileCell.mock.js\nexport const standard = {\n  userProfile: {\n    id: 42,\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Component (Shell)\nDESCRIPTION: Command to generate a standard RedwoodJS function component. Requires a unique `<name>` for the component. Options allow forcing overwrites, specifying TypeScript, and controlling test/story generation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate component <name>\n```\n\n----------------------------------------\n\nTITLE: Typing Prisma Seed Data in TypeScript (TypeScript)\nDESCRIPTION: Demonstrates how to correctly type seed data arrays in a TypeScript RedwoodJS project. It imports the Prisma types and uses `Prisma.UserCreateArgs['data'][]` to define the type for an array of user data intended for `createMany`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/database-seeds.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// title=\"scripts/seed.ts\"\nimport { db } from 'api/src/lib/db'\n// highlight-next-line\nimport type { Prisma } from '@prisma/client'\n\nexport default async () => {\n  try {\n    // highlight-next-line\n    const users: Prisma.UserCreateArgs['data'][] = [\n      { name: 'Alice', email: 'alice@redwoodjs.com },\n      { name: 'Bob', email: 'bob@redwoodjs.com },\n    ]\n\n    await db.user.createMany({ data: users })\n  } catch (error) {\n    console.error(error)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using GraphQL Directives on Schema Types and Fields (TypeScript)\nDESCRIPTION: Demonstrates application of custom GraphQL directives (e.g., @myDirective) to type fields, queries, and mutations in the schema. Directives enable middleware-like control over access or behaviors during GraphQL execution. Proper directive definitions must be registered in the system prior to use.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_29\n\nLANGUAGE: TSX\nCODE:\n```\ntype Bar {\n  name: String! @myDirective\n}\n```\n\nLANGUAGE: TSX\nCODE:\n```\ntype Query {\n  bars: [Bar!]! @myDirective\n}\n\ntype Mutation {\n  createBar(input: CreateBarInput!): Bar! @myDirective\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Delete Comment Mutation to GraphQL Schema (TypeScript SDL)\nDESCRIPTION: Extends the `Mutation` type in 'api/src/graphql/comments.sdl.ts'. Similar to the JavaScript version, it adds the `deleteComment` mutation requiring an `id` (Int!) and returning the deleted `Comment!`. The `@requireAuth` directive restricts access to authenticated users.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_21\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.ts\"\ntype Mutation {\n  createComment(input: CreateCommentInput!): Comment! @skipAuth\n  // highlight-next-line\n  deleteComment(id: Int!): Comment! @requireAuth\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic RedwoodJS Function Handler in JavaScript\nDESCRIPTION: Presents the initial implementation of the `serverTime` function handler located in `api/src/functions/serverTime.js`. This simple handler returns an HTTP 200 status code and the current server time (as a `Date` object) directly in the response body. This version doesn't explicitly format the response as JSON.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nexport const handler = async (event, context) => {\n  return {\n    statusCode: 200,\n    body: new Date(),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Custom Global Commands (Array Syntax) in TOML\nDESCRIPTION: Teaches how to run a sequence of custom commands before a lifecycle event by specifying an array in the 'deploy.toml' global hooks. This is useful for setting up logs, backups, or other preparatory steps that must occur before the main install. Each array element is a string shell command.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_25\n\nLANGUAGE: toml\nCODE:\n```\n[before]\ninstall = [\"echo 'started at $(date)' > install.lock\", \"cp -R . ../backup\"]\n\n[[production.servers]]\nhost = 'server.com'\n# ...\n```\n\n----------------------------------------\n\nTITLE: Customizing Context with a ContextFunction in createGraphQLHandler - RedwoodJS - JSX\nDESCRIPTION: Shows how to add a custom attribute (ipAddress) to the GraphQL context via a ContextFunction inside createGraphQLHandler. Combines event parsing with context mutation. Requires Redwood's createGraphQLHandler API and a logger; important for per-request context enrichment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n// ...\\n\\nconst ipAddress = ({ event }) => {\\n  return (\\n    event?.headers?.['client-ip'] ||\\n    event?.requestContext?.identity?.sourceIp ||\\n    'localhost'\\n  )\\n}\\n\\nconst setIpAddress = async ({ event, context }) => {\\n  context.ipAddress = ipAddress({ event })\\n}\\n\\nexport const handler = createGraphQLHandler({\\n  getCurrentUser,\\n  loggerConfig: {\\n    logger,\\n    options: { operationName: true, tracing: true },\\n  },\\n  schema: makeMergedSchema({\\n    schemas,\\n    services,\\n  }),\\n  context: setIpAddress,\\n  onException: () => {\\n    // Disconnect from your database with an unhandled exception.\\n    db.$disconnect()\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Realistic Prisma Scenario Data for Redwood Services - JavaScript\nDESCRIPTION: Provides a more realistic scenario setup for comments, with author names and meaningful post data, suitable for application-level tests in JavaScript. Uses defineScenario to seed comments by Jane and John Doe, each related to distinct posts. Requires RedwoodJS, Prisma, and the defineScenario helper. Parameters: real-looking string values for fields; post association via inline create. Inputs: none; Outputs: enriched scenario data for use in RedwoodJS service tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = defineScenario({\\n  comment: {\\n    // highlight-start\\n    jane: {\\n      data: {\\n        name: 'Jane Doe',\\n        body: 'I like trees',\\n        post: {\\n          create: {\\n            title: 'Redwood Leaves',\\n            body: 'The quick brown fox jumped over the lazy dog.',\\n          },\\n        },\\n      },\\n    },\\n    john: {\\n      data: {\\n        name: 'John Doe',\\n        body: 'Hug a tree today',\\n        post: {\\n          create: {\\n            title: 'Root Systems',\\n            body: 'The five boxing wizards jump quickly.',\\n          },\\n        },\\n      },\\n    },\\n    // highlight-end\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Enforcing Moderator Role in Comment Deletion Service - RedwoodJS - JavaScript\nDESCRIPTION: This code implements the deleteComment service in a RedwoodJS backend using JavaScript, explicitly calling requireAuth({ roles: 'moderator' }) before executing the delete operation. It ensures that only users with the moderator role can delete comments at the service level, adding an additional security layer beyond the GraphQL directive. Dependencies include the requireAuth function from src/lib/auth and db from src/lib/db. Accepts an object with an id, deletes the comment with that id, and returns the deleted record.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_30\n\nLANGUAGE: javascript\nCODE:\n```\n// highlight-next-line\nimport { requireAuth } from 'src/lib/auth'\nimport { db } from 'src/lib/db'\n\n// ...\n\nexport const deleteComment = ({ id }) => {\n  // highlight-next-line\n  requireAuth({ roles: 'moderator' })\n  return db.comment.delete({\n    where: { id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Field Validation with Throwing Function using JavaScript/JSX\nDESCRIPTION: Runs a user-provided custom validation function under the custom:with option. If the function throws an error, the message is used as the field's validation message. This enables custom logic not covered by default validators, e.g., cross-field or domain-specific rules. Relies on validate() accepting a custom: { with: () => {...} } definition, and on the function throwing Error instances as needed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_47\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.value, 'Value', {\n  custom: {\n    with: () => {\n      if (isInvalid) {\n        throw new Error('Value is invalid')\n      }\n    },\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Using <BrowserOnly> Component for Client-Side Only Rendering (JavaScript/JSX)\nDESCRIPTION: Shows how to use RedwoodJS's BrowserOnly component to wrap UI that should only appear in the browser context during runtime. Prevents server/prerender logic from executing non-universal client-only code such as window API usage. Requires importing BrowserOnly from '@redwoodjs/prerender/browserUtils'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { BrowserOnly } from '@redwoodjs/prerender/browserUtils'\n\nconst MyFancyComponent = () => {\n  <h2>👋🏾 I render on both the server and the browser</h2>\n  <BrowserOnly>\n    <h2>🙋‍♀️ I only render on the browser</h2>\n  </BrowserOnly>\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing the Registered Fragment - RedwoodJS Apollo - TypeScript/JavaScript\nDESCRIPTION: Imports the 'fragment' utility from '@redwoodjs/web/apollo', allowing direct access to any previously registered GraphQL fragment. Useful when advanced operations or manual fragment manipulation is required. No setup needed beyond prior fragment registration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { fragment } from '@redwoodjs/web/apollo'\\n\n```\n\n----------------------------------------\n\nTITLE: Setting Up Realtime GraphQL Support in RedwoodJS - Bash\nDESCRIPTION: This command enables support for GraphQL live queries and subscriptions within a RedwoodJS project. It installs necessary dependencies, adds the realtime API library, and can include example implementations for countdowns, messages, and auctions. The command may also set up the RedwoodJS Server file if not present. Input is just the CLI command; outputs are new files, updated configuration, and type generation. Run this after initializing the project and dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_125\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup realtime\n```\n\n----------------------------------------\n\nTITLE: Implementing Sign Up on HomePage with useAuth Hook\nDESCRIPTION: This TSX snippet shows how to use the `useAuth` hook (imported from `src/auth`) within a React component (`HomePage`) on the web side. It destructures `isAuthenticated` and `signUp` from the hook. A button is provided that, when clicked, calls the `signUp` function (with placeholder credentials commented out) to initiate the Nhost sign-up process. The `isAuthenticated` state is displayed to reflect the authentication status.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAuth } from 'src/auth'\n\nconst HomePage = () => {\n  const { isAuthenticated, signUp } = useAuth()\n\n  return (\n    <>\n      {/* MetaTags, h1, paragraphs, etc. */}\n\n      <p>{JSON.stringify({ isAuthenticated })}</p>\n      <button\n        onClick={() =>\n          signUp({\n            // email: 'your.email@email.com',\n            // password: 'super secret password',\n          })\n        }\n      >\n        sign up\n      </button>\n    </>\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating a Home Page for Sign Up using RedwoodJS useAuth Hook - TSX\nDESCRIPTION: This TypeScript React component implements a RedwoodJS HomePage that utilizes the useAuth hook to access isAuthenticated state and the signUp function. It provides a simple UI for displaying authentication status and initiating the sign-up flow. The component depends on 'src/auth' for the hook and requires the surrounding RedwoodJS and React setup. The props and state are minimal, focusing on user onboarding and authentication status. Ensure all relevant environment vars and provider configuration are set up as shown elsewhere.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/azure.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAuth } from 'src/auth'\n\nconst HomePage = () => {\n  const { isAuthenticated, signUp } = useAuth()\n\n  return (\n    <>\n      {/* MetaTags, h1, paragraphs, etc. */}\n\n      <p>{JSON.stringify({ isAuthenticated })}</p>\n      <button onClick={signUp}>Sign Up</button>\n    </>\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Passing Options to useForm for onBlur Validation (JavaScript)\nDESCRIPTION: Demonstrates initializing useForm with configuration options (here, { mode: 'onBlur' }) to ensure validation triggers occur as expected. This is necessary when controlling useForm manually, since Redwood no longer passes config automatically. The code must be invoked inside the functional component for proper form behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_40\n\nLANGUAGE: jsx\nCODE:\n```\nconst ContactPage = () => {\n  const formMethods = useForm({ mode: 'onBlur' })\n  //...\n\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Console\nDESCRIPTION: This command launches the RedwoodJS console environment. The `c` is a shortcut for `console`. This interactive environment provides access to the application's services and database client (Prisma), allowing for direct data manipulation and function execution.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw c\n```\n\n----------------------------------------\n\nTITLE: Initializing the Node.js Base Image for Docker - Dockerfile\nDESCRIPTION: This snippet sets up the Docker build's base layer using the official Node.js 20 slim image (Debian Bookworm). Using 'FROM node:20-bookworm-slim as base' ensures compatibility with Redwood's required Node version while optimizing security and image size. No external dependencies aside from Docker and access to the Node containers are needed. The resulting image supports multi-stage builds in later steps, and is the foundation for installing further dependencies and running as a non-root user.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_0\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM node:20-bookworm-slim as base\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Logger to Output to a File\nDESCRIPTION: Demonstrates configuring the RedwoodJS logger using `createLogger` to send log output to a specified file path (`/path/to/file/api.log`) using the `destination` option. This is typically used in development or environments with filesystem write access and is not suitable for serverless platforms like Netlify/Vercel.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n/**\n * Log to a File\n */\nexport const logger = createLogger({\n  //options: {},\n  destination: '/path/to/file/api.log',\n})\n```\n\n----------------------------------------\n\nTITLE: Adding PM2 as a Dev Dependency - Yarn - Bash\nDESCRIPTION: This Bash command installs PM2 as a development dependency at the root of your project using yarn. PM2 is required as a process manager for Node.js apps in production. Command must be run from the project root and assumes yarn is already installed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/self-hosting-redwood.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add -D pm2\n```\n\n----------------------------------------\n\nTITLE: Protecting a RedwoodJS Function with requireAuth (JavaScript)\nDESCRIPTION: This snippet demonstrates protecting a serverless function handler in RedwoodJS. It uses `requireAuth` to check for the 'admin' role. A try-catch block is used to handle potential `AuthenticationError` or `ForbiddenError` exceptions thrown by `requireAuth`, returning appropriate HTTP status codes (401, 403, or 400).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nimport { requireAuth } from 'src/lib/auth'\\nimport { AuthenticationError, ForbiddenError } from '@redwoodjs/api'\\n\\nexport const handler = async (event, context) => {\\n  try {\\n    requireAuth({ roles: 'admin' })\\n\\n    return {\\n      headers: {\\n        'Content-Type': 'application/json',\\n      },\\n      statusCode: 200,\\n      body: JSON.stringify({\\n        data: 'Permitted',\\n      }),\\n    }\\n  } catch (e) {\\n    if (e instanceof AuthenticationError) {\\n      return {\\n        statusCode: 401,\\n      }\\n    } else if (e instanceof ForbiddenError) {\\n      return {\\n        statusCode: 403,\\n      }\\n    } else {\\n      return {\\n        statusCode: 400,\\n      }\\n    }\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Application Service Availability with curl and wget (Bash)\nDESCRIPTION: Uses curl and wget to test HTTP accessibility of the RedwoodJS server (default port 8910) and its GraphQL endpoint. Helpful for verifying if both the web and API sides are serving requests as expected. These commands can be executed locally on the server for diagnostic purposes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8910\n# or\nwget http://localhost:8910\n\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8910/.redwood/functions/graphql?query={redwood{version}}\n# or\nwget http://localhost:8910/.redwood/functions/graphql?query={redwood{version}}\n\n```\n\n----------------------------------------\n\nTITLE: Conditionally Parsing Base64 Encoded Request Body in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to handle request bodies that might be Base64 encoded, a scenario possible in environments like Vercel. It checks the `isBase64Encoded` property of the AWS Lambda event object. If true, it decodes the body from Base64; otherwise, it uses the body as is. This ensures the correct payload content is available for subsequent processing or verification steps.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nexport const handler = async (event: APIGatewayEvent) => {\n  const body = event.isBase64Encoded\n    ? Buffer.from(event.body, 'base64').toString('utf-8')\n    : event.body\n```\n```\n\n----------------------------------------\n\nTITLE: Writing Summary and Full Render Tests Using getByText and queryByText with RedwoodJS in JavaScript\nDESCRIPTION: This test suite validates the Article component's conditional rendering based on the summary prop. It uses getByText to assert the presence of the article title and 'Read more' link when summary is true, and queryByText to assert absence of the link when summary is false. Dependencies include '@redwoodjs/testing/web', the Article component, and a standardized article object. Input parameters cover article and summary props. Expected output is correct title/link rendering. Handles both positive and negative assertion cases.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { render, screen } from '@redwoodjs/testing/web'\nimport Article from 'src/components/Article'\n\ndescribe('Article', () => {\n  const article = { id: 1, title: 'Foobar', body: 'Lorem ipsum...' }\n\n  it('renders the title of an article', () => {\n    render(<Article article={article} />)\n\n    expect(screen.getByText('Foobar')).toBeInTheDocument()\n  })\n\n  it('renders a summary version', () => {\n    render(<Article article={article} summary={true} />)\n\n    expect(screen.getByText('Read more')).toBeInTheDocument()\n  })\n\n  it('renders a full version', () => {\n    render(<Article article={article} summary={false} />)\n\n    expect(screen.queryByText('Read more')).not.toBeInTheDocument()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Orbit Webhooks with Secret Key Verification in RedwoodJS (JSX)\nDESCRIPTION: This AWS Lambda handler function processes incoming webhooks from Orbit. It uses the `verifyEvent` function from `@redwoodjs/api/webhooks` with the 'secretKeyVerifier' method and an environment variable (`ORBIT_WEBHOOK_SECRET`) to validate the request using the signature provided in the 'X-Orbit-Signature' header. It specifically handles 'activity:created' events, parses the payload, and logs information using a custom logger. It returns appropriate HTTP status codes based on successful processing, unsupported event types, verification failure (401), or other errors (500).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\n//import type { APIGatewayEvent, Context } from 'aws-lambda'\nimport {\n  verifyEvent,\n  // VerifyOptions,\n  WebhookVerificationError,\n} from '@redwoodjs/api/webhooks'\n\nimport { deserialize } from 'deserialize-json-api'\nimport { parser, persister } from 'src/lib/orbit/loaders/activityLoader'\n\nimport { logger } from 'src/lib/logger'\n\nconst webhookDetails = (event) => {\n  const webhook = 'orbitWebhook-background'\n  const orbitEvent = event.headers['x-orbit-event'] || ''\n  const orbitEventId = event.headers['x-orbit-event-id'] || ''\n  const orbitEventType = event.headers['x-orbit-event-type'] || ''\n  const orbitUserAgent = event.headers['user-agent'] || ''\n  const orbitSignature = event.headers['x-orbit-signature'] || ''\n\n  return {\n    webhook,\n    orbitEvent,\n    orbitEventId,\n    orbitEventType,\n    orbitUserAgent,\n    orbitSignature,\n  }\n}\n\n/**\n * The handler function is your code that processes http request events.\n * You can use return and throw to send a response or error, respectively.\n *\n * Important: When deployed, a custom serverless function is an open API endpoint and\n * is your responsibility to secure appropriately.\n *\n * @see {@link https://redwoodjs.com/docs/serverless-functions#security-considerations|Serverless Function Considerations}\n * in the RedwoodJS documentation for more information.\n *\n * @typedef { import('aws-lambda').APIGatewayEvent } APIGatewayEvent\n * @typedef { import('aws-lambda').Context } Context\n * @param { APIGatewayEvent } event - an object which contains information from the invoker.\n * @param { Context } context - contains information about the invocation,\n * function, and execution environment.\n */\nexport const handler = async (event) => {\n  const orbitInfo = webhookDetails(event)\n\n  const webhookLogger = logger.child({ orbitInfo })\n\n  webhookLogger.info(`>> in webhook`)\n\n  try {\n    const options = {\n      signatureHeader: 'X-Orbit-Signature',\n    }\n    verifyEvent('secretKeyVerifier', {\n      event,\n      secret: process.env.ORBIT_WEBHOOK_SECRET,\n      options,\n    })\n\n    if (orbitInfo.orbitEventType === 'activity:created') {\n      // const parsedActivity = parseEventPayload(event) // Assuming parseEventPayload is defined elsewhere\n\n      // Safely use the validated webhook payload\n\n      return {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        statusCode: 200,\n        body: JSON.stringify({\n          data: 'orbitWebhook done',\n        }),\n      }\n    } else {\n      webhookLogger.warn(\n        `Unsupported Orbit Event Type: ${orbitInfo.orbitEventType}`\n      )\n      return {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        statusCode: 400,\n        body: JSON.stringify({\n          data: `Unsupported Orbit Event Type: ${orbitInfo.orbitEventType}`,\n        }),\n      }\n    }\n  } catch (error) {\n    if (error instanceof WebhookVerificationError) {\n      webhookLogger.warn('Unauthorized')\n      return {\n        statusCode: 401,\n      }\n    } else {\n      webhookLogger.error({ error }, error.message)\n      return {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        statusCode: 500,\n        body: JSON.stringify({\n          error: error.message,\n        }),\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining User and Audit Models in Prisma Schema - GraphQL\nDESCRIPTION: Defines Prisma ORM data models for 'User' and 'Audit' within the schema.prisma file. The User model includes fields for id, timestamps, email, name (optional), and a one-to-many relation to Audit logs. The Audit model links to a user and keeps a log string. Dependencies: Prisma, RedwoodJS, and the corresponding generated migration. Inputs: None; Outputs: Database tables/models matching these definitions. Limitations: Simplistic audit logging and minimal user detail fields; will need expansion for production.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nmodel User {\n  id        String   @id @default(uuid())\n  createdAt DateTime @default(now())\n  updatedAt DateTime @default(now()) @updatedAt\n  email     String   @unique\n  name      String?\n  audits    Audit[]\n}\n\nmodel Audit {\n  id        String   @id @default(uuid())\n  createdAt DateTime @default(now())\n  updatedAt DateTime @default(now()) @updatedAt\n  userId    String\n  user      User     @relation(fields: [userId], references: [id])\n  log       String\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Extra Props to a RedwoodJS Cell (TypeScript)\nDESCRIPTION: This TypeScript example shows passing an extra `rand` prop, generated using `Math.random()`, to the `ArticleCell` component in addition to the `id`. While `id` is used in the GraphQL query, `rand` is ignored by the query but remains accessible within the Cell's display components like `Success`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n<ArticleCell id={id} rand={Math.random()} />\n```\n```\n\n----------------------------------------\n\nTITLE: Protecting RedwoodJS Route with Custom Forbidden Page (JSX)\nDESCRIPTION: This example demonstrates protecting multiple routes (`/settings`, `/admin`) within a `PrivateSet` requiring the 'admin' role. If access is denied, the user is redirected to a custom 'forbidden' page instead of the default 'home' page, which is defined separately.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route, PrivateSet } from '@redwoodjs/router'\\n\\nconst Routes = () => {\\n  return (\\n    <Router>\\n      <PrivateSet unauthenticated=\"forbidden\" roles=\"admin\">\\n        <Route path=\"/settings\" page={SettingsPage} name=\"settings\" />\\n        <Route path=\"/admin\" page={AdminPage} name=\"sites\" />\\n      </PrivateSet>\\n\\n      <Route notfound page={NotFoundPage} />\\n      <Route path=\"/forbidden\" page={ForbiddenPage} name=\"forbidden\" />\\n    </Router>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Explaining Data Prop Origin in Success Component (TypeScript)\nDESCRIPTION: This TypeScript snippet highlights the `posts` field within the cell's GraphQL `QUERY`, which is typed using `TypedDocumentNode`. It clarifies that the name of this root query field dictates the name of the prop (`posts`) holding the fetched data within the typed `Success` component (whose props are defined via `CellSuccessProps`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_14\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> = // highlight-line\n  gql`\n    query ArticlesQuery {\n      // highlight-next-line\n      posts {\n        id\n      }\n    }\n  `\n```\n```\n\n----------------------------------------\n\nTITLE: Running Jest Tests in RedwoodJS - Bash\nDESCRIPTION: Executes Jest tests for both the 'api' and 'web' sides of a RedwoodJS project using the Redwood CLI interface. Requires that the project is set up for RedwoodJS with corresponding test suites present. Accepts parameters such as the side or file pattern to filter tests, and options like --watch, --watchAll, and --collectCoverage for controlling test execution. Outputs test results, coverage information, and may create or sync test databases as needed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_131\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood test [side..]\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Rendering Based on Authentication State in RedwoodJS Navigation\nDESCRIPTION: Updates the `Navigation` component to use the `useAuth` hook to get the `isAuthenticated` status. It then sets up a conditional (ternary) operator within the `nav` element to render different content based on whether the user is authenticated or not. Placeholders indicate where signed-in and signed-out content will go.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { useAuth } from 'src/auth'\n\nconst Navigation = () => {\n  const { isAuthenticated } = useAuth()\n  return (\n    <nav>\n      {isAuthenticated ? (\n        // signed in - show the Sign Out button\n      ) : (\n        // signed out - show the Sign Up and Sign In links\n      )}\n    </nav>\n  )\n}\n\nexport default Navigation\n```\n\n----------------------------------------\n\nTITLE: Exposing Delete Comment Mutation in GraphQL SDL (TypeScript)\nDESCRIPTION: This GraphQL SDL snippet updates the `Mutation` type within the TypeScript SDL file (`.sdl.ts`) to include the `deleteComment` mutation. It takes a required `id` of type Int, returns the `Comment` that was deleted, and is protected by the `@requireAuth` directive, restricting its use to authenticated users.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.ts\"\ntype Mutation {\n  createComment(input: CreateCommentInput!): Comment! @skipAuth\n  // highlight-next-line\n  deleteComment(id: Int!): Comment! @requireAuth\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Order Model in Prisma Schema (Prisma)\nDESCRIPTION: Defines the 'Order' model for use with Prisma ORM. The model includes auto-incrementing primary key 'id', timestamps, a unique 'trackingNumber', and order 'status' with default values. Uniqueness is enforced on the combination of 'trackingNumber' and 'status'. This schema is necessary for the database layer of the webhook handler and is referenced by test scenarios and the update function. Requires the Prisma CLI and integration into your RedwoodJS API codebase.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_17\n\nLANGUAGE: prisma\nCODE:\n```\nmodel Order {\n  id             Int      @id @default(autoincrement())\n  createdAt      DateTime @default(now())\n  updatedAt      DateTime @updatedAt\n  trackingNumber String   @unique\n  status         String   @default(\"UNKNOWN\")\n\n  @@unique([trackingNumber, status])\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Signed URLs for Profile Avatars in TypeScript\nDESCRIPTION: This TypeScript snippet, located in a RedwoodJS service file (`profiles.ts`), retrieves a user profile by ID from the database. It then utilizes the `.withSignedUrl()` helper method on the retrieved profile object to generate a temporary, signed URL for the `avatar` field. The URL is configured to expire in 2 days using `EXPIRES_IN.days(2)`. This is typically used to provide secure, time-limited access to private files stored via RedwoodJS uploads.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EXPIRES_IN } from '@redwoodjs/storage/UrlSigner'\n\nexport const profile = async ({ id }) => {\n  const profile = await db.profile.findUnique({\n    where: { id },\n  })\n\n  // Convert the avatar field to signed URLs\n  // highlight-start\n  return profile?.withSignedUrl({\n    expiresIn: EXPIRES_IN.days(2),\n  })\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating useAuth Hook with RedwoodJS Sign In Form in JSX\nDESCRIPTION: This snippet updates the SigninPage component to import and use the 'useAuth' hook from 'src/auth', destructuring the 'logIn' method. It demonstrates preparation for authentication by resetting error state on submit. '@redwoodjs/forms' and 'src/auth' must both be available, and the form fields for 'email' and 'password' remain as in the previous version. The actual logIn functionality is to be implemented by the developer.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from 'src/auth'\n\nconst SigninPage = () => {\n  const { logIn } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = (data) => {\n    setError(null)\n    // do sign in here\n  }\n\n  return (\n    <>\n      <h1>Sign In</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign In</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SigninPage\n```\n\n----------------------------------------\n\nTITLE: Testing the Comment Component in JavaScript\nDESCRIPTION: This JSX snippet shows a unit test for the 'Comment' component using Jest and React Testing Library (provided by `@redwoodjs/testing`). It renders the component with mock `comment` data and uses `screen` queries to assert that the comment's name, body, and formatted date are correctly rendered in the DOM. It also checks that the date is within a `<time>` tag with the correct `datetime` attribute.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/the-redwood-way.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { render, screen } from '@redwoodjs/testing'\n\nimport Comment from './Comment'\n\ndescribe('Comment', () => {\n  it('renders successfully', () => {\n    // highlight-start\n    const comment = {\n      name: 'John Doe',\n      body: 'This is my comment',\n      createdAt: '2020-01-02T12:34:56Z',\n    }\n    render(<Comment comment={comment} />)\n\n    expect(screen.getByText(comment.name)).toBeInTheDocument()\n    expect(screen.getByText(comment.body)).toBeInTheDocument()\n    const dateExpect = screen.getByText('2 January 2020')\n    expect(dateExpect).toBeInTheDocument()\n    expect(dateExpect.nodeName).toEqual('TIME')\n    expect(dateExpect).toHaveAttribute('datetime', comment.createdAt)\n    // highlight-end\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Resolver Arguments and Querying Related Data - RedwoodJS - JavaScript\nDESCRIPTION: Illustrates accessing resolver arguments ('args', 'gqlArgs') and querying user related to a Post. Uses Prisma's 'db.post.findUnique' to fetch user by post id, making use of Redwood's custom argument conventions. Typical use: resolve nested type relationships.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nexport const Post = {\\n  user: (args, gqlArgs) =>\\n    db.post.findUnique({ where: { id: gqlArgs?.root.id } }).user(),\\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying Redwood Project - Bash\nDESCRIPTION: Shows the Redwood command for deploying a project to various hosting targets, requiring specification of the provider and optional subcommands. Dependencies: Redwood CLI, deployment environment credentials/setup. Parameters: <target> (serverless, netlify, render, vercel, etc). Input: Command. Output: Build and deployment process triggered on selected host. Limitation: Requires target-specific configuration and permissions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood deploy <target>\n```\n\n----------------------------------------\n\nTITLE: Exposing Create Comment Mutation in GraphQL SDL (TypeScript)\nDESCRIPTION: This GraphQL schema definition (SDL) snippet, intended for a TypeScript environment (`.sdl.ts`), defines the types for the comments API. It mirrors the JavaScript version, defining the `Comment` type, a `Query` for comments (`@skipAuth`), input types (`CreateCommentInput`, `UpdateCommentInput`), and adds the `createComment` mutation. This mutation takes `CreateCommentInput` and returns a `Comment`, allowing unauthenticated access via `@skipAuth`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.ts\"\nexport const schema = gql`\n  type Comment {\n    id: Int!\n    name: String!\n    body: String!\n    post: Post!\n    postId: Int!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    comments: [Comment!]! @skipAuth\n  }\n\n  input CreateCommentInput {\n    name: String!\n    body: String!\n    postId: Int!\n  }\n\n  input UpdateCommentInput {\n    name: String\n    body: String\n    postId: Int\n  }\n\n  // highlight-start\n  type Mutation {\n    createComment(input: CreateCommentInput!): Comment! @skipAuth\n  }\n  // highlight-end\n`\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Comments by postId - GraphQL Query (JavaScript)\nDESCRIPTION: Defines a GraphQL query to retrieve comments filtered by a specific postId integer parameter. Suitable for use in RedwoodJS 'Cells' and expects that the postId variable is provided via component props. Outputs an array of comments (id, name, body, createdAt) belonging to the referenced post. Dependency: RedwoodJS GraphQL layer, Apollo Client gql. Limitation: requires postId and only fetches associated comments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_40\n\nLANGUAGE: GraphQL\nCODE:\n```\nexport const QUERY = gql`\n  // highlight-start\n  query CommentsQuery($postId: Int!) {\n    comments(postId: $postId) {\n    // highlight-end\n      id\n      name\n      body\n      createdAt\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Adding Login Token Mutation to GraphQL Schema - JavaScript\nDESCRIPTION: This GraphQL schema definition adds a UserTokenResponse type and a generateLoginToken mutation. The mutation triggers the email login flow and returns a message upon completion. Dependencies: RedwoodJS GraphQL. Key parameters: generateLoginToken(email: String!). Exposes only non-sensitive user fields, explicitly omitting loginToken for security.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nexport const schema = gql`\n  type User {\n    id: Int!\n    name: String\n    email: String!\n  }\n\n  input CreateUserInput {\n    name: String\n    email: String!\n  }\n\n  input UpdateUserInput {\n    name: String\n    email: String!\n  }\n\n  // highlight-start\n  type UserTokenResponse {\n    message: String!\n  }\n  // highlight-end\n\n  type Mutation {\n    createUser(input: CreateUserInput!): User! @requireAuth\n    updateUser(id: Int!, input: UpdateUserInput!): User! @requireAuth\n    deleteUser(id: Int!): User! @requireAuth\n    // highlight-next-line\n    generateLoginToken(email: String!): UserTokenResponse! @skipAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Implementing RedwoodJS Data Migration Logic in JavaScript\nDESCRIPTION: Illustrates the structure and implementation of a RedwoodJS data migration file (e.g., `api/db/dataMigrations/20200721123456-copy-preferences.js`). It shows the default exported async function receiving the Prisma Client instance (`db`), an example of migrating user preferences data using `db.user.findMany()` and `db.preference.create()`, and a technique for ensuring idempotency for long-term maintainability by checking for column existence (e.g., `typeof user.newsletter !== undefined`) before running the core migration logic. Includes an `asyncForEach` helper function for iterating asynchronously.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/data-migrations.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nexport default async ({ db }) => {\n  // Migration here...\n}\n```\n\nLANGUAGE: jsx\nCODE:\n```\nconst asyncForEach = async (array, callback) => {\n  for (let index = 0; index < array.length; index++) {\n    await callback(array[index], index, array)\n  }\n}\n\nexport default async ({ db }) => {\n  const users = await db.user.findMany()\n\n  asyncForEach(users, async (user) => {\n    await db.preference.create({\n      data: {\n        newsletter: user.newsletter,\n        frequency: user.frequency,\n        theme: user.theme,\n        user: { connect: { id: user.id } },\n      },\n    })\n  })\n}\n```\n\nLANGUAGE: jsx\nCODE:\n```\nexport default async ({ db }) => {\n  const users = await db.user.findMany()\n\n  if (typeof user.newsletter !== undefined) {\n    asyncForEach(users, async (user) => {\n      await db.preference.create({\n        data: {\n          newsletter: user.newsletter,\n          frequency: user.frequency,\n          theme: user.theme,\n          user: { connect: { id: user.id } },\n        },\n      })\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Comment Component with User Mocks in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript snippet provides Jest tests for the Comment component in a RedwoodJS app. It utilizes mock comment data with TypeScript typings and checks UI behavior based on mocked currentUser roles, using waitFor to correctly await asynchronous GraphQL logic. Dependencies are @redwoodjs/testing and the Comment component, requiring comment and user objects as inputs, while outputs are DOM assertions. The test verifies presence or absence of UI elements such as the delete button depending on authentication state.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_24\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\\nimport { render, screen, waitFor } from '@redwoodjs/testing'\\n\\nimport Comment from './Comment'\\n\\n// highlight-start\\nconst COMMENT = {\\n  id: 1,\\n  name: 'John Doe',\\n  body: 'This is my comment',\\n  createdAt: '2020-01-02T12:34:56Z',\\n  postId: 1,\\n}\\n// highlight-end\\n\\ndescribe('Comment', () => {\\n  it('renders successfully', () => {\\n    // highlight-next-line\\n    render(<Comment comment={COMMENT} />)\\n\\n    // highlight-start\\n    expect(screen.getByText(COMMENT.name)).toBeInTheDocument()\\n    expect(screen.getByText(COMMENT.body)).toBeInTheDocument()\\n    // highlight-end\\n    const dateExpect = screen.getByText('2 January 2020')\\n    expect(dateExpect).toBeInTheDocument()\\n    expect(dateExpect.nodeName).toEqual('TIME')\\n    // highlight-next-line\\n    expect(dateExpect).toHaveAttribute('datetime', COMMENT.createdAt)\\n  })\\n\\n  // highlight-start\\n  it('does not render a delete button if user is logged out', async () => {\\n    render(<Comment comment={COMMENT} />)\\n\\n    await waitFor(() =>\\n      expect(screen.queryByText('Delete')).not.toBeInTheDocument()\\n    )\\n  })\\n\\n  it('renders a delete button if the user is a moderator', async () => {\\n    mockCurrentUser({\\n      id: 1,\\n      email: 'moderator@moderator.com',\\n      roles: 'moderator',\\n    })\\n\\n    render(<Comment comment={COMMENT} />)\\n\\n    await waitFor(() => expect(screen.getByText('Delete')).toBeInTheDocument())\\n  })\\n  // highlight-end\\n})\n```\n\n----------------------------------------\n\nTITLE: Enforcing Role-based Access with PrivateSet in RedwoodJS Router (TSX)\nDESCRIPTION: This TSX snippet expands on authentication-based route protection by applying role-based restrictions using the 'roles' prop in the 'PrivateSet' component. Routes are accessible only if users are authenticated and assigned the required role(s), otherwise they are redirected as defined by 'unauthenticated'. Used in 'web/src/Routes.tsx', roles can be specified as a string (e.g., 'admin') or as an array (e.g., ['author', 'editor']). Dependencies include @redwoodjs/router, relevant page components, and a configured authentication provider supporting roles. Inputs are attempted navigations to protected routes; outputs are either the rendered component or a redirect. Role checks use 'any' logic—possession of at least one role grants access.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/authentication.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Router, Route, PrivateSet } from '@redwoodjs/router'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Route path=\"/\" page={HomePage} name=\"home\" />\n      <Route path=\"/login\" page={LoginPage} name=\"login\" />\n      <Route path=\"/forbidden\" page={ForbiddenPage} name=\"forbidden\" />\n      <PrivateSet unauthenticated=\"login\">\n        <Route path=\"/secret-page\" page={SecretPage} name=\"secret\" />\n      </PrivateSet>\n      // highlight-next-line\n      <PrivateSet unauthenticated=\"forbidden\" roles=\"admin\">\n        <Route path=\"/admin\" page={AdminPage} name=\"admin\" />\n      </PrivateSet>\n      // highlight-next-line\n      <PrivateSet unauthenticated=\"forbidden\" roles={['author', 'editor']}>\n        <Route path=\"/posts\" page={PostsPage} name=\"posts\" />\n      </PrivateSet>\n    </Router>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Active Links with useMatch Hook - RedwoodJS - JSX\nDESCRIPTION: Shows how to implement a custom navigation component using the useMatch hook from RedwoodJS Router for programmatically determining active state. The code retrieves match information for a route and conditionally applies an 'isActive' prop for styling. This pattern is useful for building reusable or styled navigation components. Dependencies: '@redwoodjs/router'. Inputs are route destination and current URL, outputs are custom link elements with isActive based on route match.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes, useMatch } from '@redwoodjs/router'\n\nconst CustomLink = ({ to, ...rest }) => {\n  const matchInfo = useMatch(to)\n\n  return <SomeStyledComponent as={Link} to={to} isActive={matchInfo.match} />\n}\n\nconst MainMenu = () => {\n  return <CustomLink to={routes.about()} />\n}\n```\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes, useMatch } from '@redwoodjs/router'\n\nconst CustomLink = ({ to, ...rest }) => {\n  const matchInfo = useMatch(to, { searchParams: [{ tab: 'tutorial' }, 'page'] })\n\n  return <SomeStyledComponent as={Link} to={to} isActive={matchInfo.match} />\n}\n```\n\nLANGUAGE: jsx\nCODE:\n```\nconst match = useMatch('/product/{category}/{id}', {\n  routeParams: { category: 'shirts' },\n})\n```\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/{animal}/{name}\" page={AnimalPage} name=\"animal\" />\n\nconst animalRoutePath = useRoutePath('animal')\n// => '/{animal}/{name}'\n\nconst matchOnlyDog = useMatch(animalRoutePath, { routeParams: { animal: 'dog' }})\nconst matchFullyDynamic = useMatch(animalRoutePath)\n```\n\n----------------------------------------\n\nTITLE: Including User with Post in Prisma Query - RedwoodJS - JavaScript\nDESCRIPTION: Demonstrates how to modify the post service's single-record query to always include associated user data in the result by leveraging Prisma's 'include' option. This snippet returns post objects augmented with their user, which addresses but does not fully solve the N+1 query problem in GraphQL without further batching or caching. Requires Prisma setup and that the 'user' relation exists. Outputs a post with user data included, and is limited in supporting further nested queries for related user properties.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nexport const post = ({ id }) => {\n  return db.post.findUnique({\n    where: { id },\n    include: {\n      user: true,\n    },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Fields to a RedwoodJS Form (JavaScript)\nDESCRIPTION: This snippet shows how to add multiple input fields (`TextField` for name and email, `TextAreaField` for message) to a RedwoodJS form. The `onSubmit` handler remains the same, logging the collected data from all fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField, TextAreaField, Submit } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-start\n        <TextField name=\"name\" />\n        <TextField name=\"email\" />\n        <TextAreaField name=\"message\" />\n        // highlight-end\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Protecting RedwoodJS Route for a Single Role (JSX)\nDESCRIPTION: This snippet demonstrates how to use the `PrivateSet` component from `@redwoodjs/router` to protect a route (`/admin/users`) so that it's only accessible to users with the 'admin' role. If the user is unauthenticated or doesn't have the required role, they are redirected to the 'home' page.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route, PrivateSet } from '@redwoodjs/router'\\n\\nconst Routes = () => {\\n  return (\\n    <Router>\\n      <PrivateSet unauthenticated=\"home\" roles=\"admin\">\\n        <Route path=\"/admin/users\" page={UsersPage} name=\"users\" />\\n      </PrivateSet>\\n    </Router>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Passwordless Login Form Component - JSX\nDESCRIPTION: This React component renders a form that collects an email and triggers the generateLoginToken GraphQL mutation using RedwoodJS hooks. Upon completion, it displays user notifications and advances the login flow UI. Dependencies: @redwoodjs/forms, @redwoodjs/router, @redwoodjs/web, @redwoodjs/web/toast, GraphQL schema providing generateLoginToken mutation. Inputs: Email string via form. Outputs: Triggers backend to send a login token and shows confirmation or error feedback.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, Label, TextField, Submit, FieldError } from '@redwoodjs/forms'\nimport { routes, Link } from '@redwoodjs/router'\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport { Toaster, toast } from '@redwoodjs/web/toast'\n\nconst GENERATE_LOGIN_TOKEN_MUTATION = gql`\n  mutation GenerateLoginTokenMutation($email: String!) {\n    generateLoginToken(email: $email) {\n      message\n    }\n  }\n`\n\nconst LoginPasswordlessForm = ({ setWaitingForCode, setEmail }) => {\n  const [generateLoginToken] = useMutation(GENERATE_LOGIN_TOKEN_MUTATION, {\n    onCompleted: () => {\n      toast.success('Check your email for a login link')\n      setWaitingForCode(true)\n    },\n  })\n\n  const onSubmit = async (data) => {\n    setEmail(data.email)\n\n    const response = await generateLoginToken({\n      variables: { email: data.email },\n      fetchPolicy: 'no-cache',\n    })\n\n    if (response.error) {\n      toast.error(response.error)\n    }\n  }\n\n  return (\n    <>\n      <Metadata title=\"Login\" />\n      <main className=\"rw-main\">\n        <Toaster toastOptions={{ className: 'rw-toast', duration: 6000 }} />\n        <div className=\"rw-scaffold rw-login-container\">\n          <div className=\"rw-segment\">\n            <header className=\"rw-segment-header\">\n              <h2 className=\"rw-heading rw-heading-secondary\">Login</h2>\n            </header>\n\n            <div className=\"rw-segment-main\">\n              <div className=\"rw-form-wrapper\">\n                <Form onSubmit={onSubmit} className=\"rw-form-wrapper\">\n                  <Label\n                    name=\"email\"\n                    className=\"rw-label\"\n                    errorClassName=\"rw-label rw-label-error\"\n                  >\n                    Email\n                  </Label>\n                  <TextField\n                    name=\"email\"\n                    className=\"rw-input\"\n                    errorClassName=\"rw-input rw-input-error\"\n                    validation={{\n                      required: {\n                        value: true,\n                        message: 'Email is required',\n                      },\n                    }}\n                  />\n\n                  <FieldError name=\"email\" className=\"rw-field-error\" />\n                  <div className=\"rw-button-group\">\n                    <Submit className=\"rw-button rw-button-blue\">\n                      Send Token\n                    </Submit>\n                  </div>\n                </Form>\n              </div>\n            </div>\n          </div>\n          <div className=\"rw-login-link\">\n            <span>Don&apos;t have an account?</span>{' '}\n            <Link to={routes.signup()} className=\"rw-link\">\n              Sign up!\n            </Link>\n          </div>\n        </div>\n      </main>\n    </>\n  )\n}\n\nexport default LoginPasswordlessForm\n```\n\n----------------------------------------\n\nTITLE: Defining and Validating RedwoodJS Contact Form Fields in JavaScript\nDESCRIPTION: Implements similar contact form logic as the TypeScript version in JSX syntax, creating name, email, and message fields with instant client-side validation. Utilizes RedwoodJS form components and error feedback styling to guide users interactively. Inputs are user-provided text for each field; successful validation enables form submission. Depends on RedwoodJS web/forms packages.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_30\n\nLANGUAGE: jsx\nCODE:\n```\n/>\n<FieldError name=\"email\" className=\"error\" />\n\n// highlight-start\n<Label name=\"message\" errorClassName=\"error\">\n  Message\n</Label>\n// highlight-end\n<TextAreaField\n  name=\"message\"\n  validation={{ required: true }}\n  errorClassName=\"error\"\n/>\n<FieldError name=\"message\" className=\"error\" />\n\n<Submit>Save</Submit>\n</Form>\n</>\n)\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Running Prisma Migrate Dev with Redwood CLI (Bash)\nDESCRIPTION: Executes the Prisma `migrate dev` command within a RedwoodJS project using Yarn. This command creates a new database migration based on changes in the Prisma schema, applies it to the development database, and triggers generators like Prisma Client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_104\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Generated GraphQL SDL for User Model (JSX)\nDESCRIPTION: Example content of a generated `./api/src/graphql/users.sdl.js` file. It defines the `User` type based on the Prisma model, a query `users` to fetch multiple users, input types for creation (`CreateUserInput`) and updates (`UpdateUserInput`), and corresponding mutations (`createUser`, `updateUser`, `deleteUser`). The `@requireAuth` directive is applied by default.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_80\n\nLANGUAGE: jsx\nCODE:\n```\nexport const schema = gql`\n  type User {\n    id: Int!\n    email: String!\n    name: String\n  }\n\n  type Query {\n    users: [User!]! @requireAuth\n  }\n\n  input CreateUserInput {\n    email: String!\n    name: String\n  }\n\n  input UpdateUserInput {\n    email: String\n    name: String\n  }\n\n  type Mutation {\n    createUser(input: CreateUserInput!): User! @requireAuth\n    updateUser(id: Int!, input: UpdateUserInput!): User! @requireAuth\n    deleteUser(id: Int!): User! @requireAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema for Deferred and Fast Fields - GraphQL\nDESCRIPTION: Defines GraphQL schema for two query fields: `fastField` (returns instantly) and `slowField` (returns after delay), suitable for the `@defer` directive. Uses RedwoodJS' auth-skipping via `@skipAuth`. The `slowField` has an adjustable delay parameter (`waitFor`), defaulting to 5000 ms. No additional dependencies beyond RedwoodJS and GraphQL tooling. Intended for demonstrating deferred slow and instant fast data fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\n  type Query {\n    \"\"\"\n    A field that resolves fast.\n    \"\"\"\n    fastField: String! @skipAuth\n\n    \"\"\"\n    A field that resolves slowly.\n    Maybe you want to @defer this field ;)\n    \"\"\"\n    slowField(waitFor: Int! = 5000): String @skipAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Implementing Signup Logic with client.auth.signUp (JSX)\nDESCRIPTION: This snippet implements the core sign-up functionality within the `onSubmit` handler, now marked as `async`. It makes an asynchronous call to `client.auth.signUp()`, passing an object containing the `email` and `password` collected from the form data (`data.email`, `data.password`). The response and potential errors are logged to the console using a `try...catch` block to handle the promise resolution or rejection.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from 'src/auth'\n\nconst SignupPage = () => {\n  const { client } = useAuth()\n\n  const onSubmit = async (data) => {\n    try {\n      const response = await client.auth.signUp({\n        email: data.email,\n        password: data.password\n      })\n      console.log('response: ', response)\n    } catch(error) {\n      console.log('error:  ', error)\n    }\n  }\n\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form onSubmit={onSubmit}>\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema with Role-Based Auth for deleteComment - RedwoodJS - TypeScript\nDESCRIPTION: This snippet mirrors the JavaScript GraphQL schema, but is meant for a TypeScript RedwoodJS project. It similarly uses @requireAuth on the deleteComment mutation to enforce moderator-only permissions, and supports types/interfaces compatible with TypeScript. The file sets up all input/output types and provides comments referencing important lines. Requires RedwoodJS, GraphQL, and TypeScript configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_29\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql\\`\n  type Comment {\n    id: Int!\n    name: String!\n    body: String!\n    post: Post!\n    postId: Int!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    comments(postId: Int!): [Comment!]! @skipAuth\n  }\n\n  input CreateCommentInput {\n    name: String!\n    body: String!\n    postId: Int!\n  }\n\n  input UpdateCommentInput {\n    name: String\n    body: String\n    postId: Int\n  }\n\n  type Mutation {\n    createComment(input: CreateCommentInput!): Comment! @skipAuth\n    // highlight-next-line\n    deleteComment(id: Int!): Comment! @requireAuth(roles: \"moderator\")\n  }\n\\`\n```\n\n----------------------------------------\n\nTITLE: Using Redwood Build Command - Bash\nDESCRIPTION: Demonstrates the standard way to invoke the Redwood CLI build process for specified project sides, with optional verbosity. Dependencies: Redwood CLI, Babel, Vite. Parameters: [side..] (array of 'api', 'web'), --verbose/-v (optional). Input: CLI command. Output: Both sides of project are built and output to respective 'dist' directories. Limitation: Requires appropriate project structure and installed dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood build [side..]\n```\n\n----------------------------------------\n\nTITLE: Rendering Paginated Blog Posts with RedwoodJS Cell Success (TypeScript/React)\nDESCRIPTION: This TypeScript/React functional component represents the 'Success' state of a RedwoodJS Cell. It receives successfully fetched data (`postPage` containing `posts` array and `count`) from a `BlogPostsQuery`. It iterates over the `posts` array, rendering a `BlogPost` component for each post, and also includes a `Pagination` component displaying pagination controls based on the total `count`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n}: CellSuccessProps<BlogPostsQuery, BlogPostsQueryVariables>) => {\n  return (\n    <>\n      {postPage.posts.map((post) => (\n        <BlogPost key={post.id} post={post} />\n      ))}\n\n      <Pagination count={postPage.count} />\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Refactored Article Component with Props and Types (TSX)\nDESCRIPTION: Updates the `Article.tsx` component to accept an `article` object, typed as `Post` (imported from `types/graphql`), as a prop using a `Props` interface. It imports `Link` and `routes` from `@redwoodjs/router` for navigation. The component renders the article's title (linked to its detail page), body, and creation timestamp.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_28\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-next-line\nimport type { Post } from 'types/graphql'\n\n// highlight-start\ninterface Props {\n  article: Post\n}\n// highlight-end\n\n// highlight-next-line\nconst Article = ({ article }: Props) => {\n  return (\n    // highlight-start\n    <article>\n      <header>\n        <h2>\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div>{article.body}</div>\n      <div>Posted at: {article.createdAt}</div>\n    </article>\n    // highlight-end\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Form Validation Trigger Mode in TypeScript\nDESCRIPTION: Enables field validation in a RedwoodJS form to occur whenever a field loses focus ('onBlur') in a TSX file. This setting increases user-friendliness by catching errors as soon as possible and providing immediate corrective feedback. Applicable within a Form component in any RedwoodJS TypeScript context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_34\n\nLANGUAGE: tsx\nCODE:\n```\n<Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n```\n\n----------------------------------------\n\nTITLE: Building and Deploying Redwood Application to Target Provider - Shell\nDESCRIPTION: These example shell commands utilize the Redwood CLI to build and deploy the project to specified providers. Each command must specify a valid deploy target (e.g., netlify, vercel, serverless, edgio, baremetal). Some variants include additional CLI options like '--first-run' or '--side api'. Prerequisites: Proper configuration for target, CLI installed, and a prepared RedwoodJS project. Outputs deployment-ready builds or deploys directly, depending on the provider and command used.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/introduction.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# Build command for Netlify deploy target\\nyarn rw deploy netlify\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Build command for Vercel deploy target\\nyarn rw deploy vercel\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Build command for AWS Lambdas using the https://serverless.com framework\\nyarn rw deploy serverless --side api\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Build command for Edgio deploy target\\nyarn rw deploy edgio\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Build command for baremetal deploy target\\nyarn rw deploy baremetal [--first-run]\n```\n\n----------------------------------------\n\nTITLE: Displaying Server Errors in RedwoodJS Form (TypeScript/TSX)\nDESCRIPTION: Updates the `ContactPage.tsx` component to display server-side validation errors. It imports `FormError` from `@redwoodjs/forms` and utilizes the `error` state returned by the `useMutation` hook. This `error` object is passed to the `<Form>` component and the `<FormError>` component, enabling the display of errors originating from the server-side validation logic within the form.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_26\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport { toast, Toaster } from '@redwoodjs/web/toast'\nimport {\n  FieldError,\n  Form,\n  // highlight-next-line\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\nimport {\n  CreateContactMutation,\n  CreateContactMutationVariables,\n} from 'types/graphql'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const [create, { loading, error }] = useMutation<\n    CreateContactMutation,\n    CreateContactMutationVariables\n  >(CREATE_CONTACT, {\n    onCompleted: () => {\n      toast.success('Thank you for your submission!')\n    },\n  })\n\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n      <Toaster />\n      // highlight-start\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }} error={error}>\n        <FormError error={error} wrapperClassName=\"form-error\" />\n        // highlight-end\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n        <Submit disabled={loading}>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n\n```\n\n----------------------------------------\n\nTITLE: Integrating Article Component into ArticlesCell (TSX)\nDESCRIPTION: Modifies the 'ArticlesCell' TypeScript component's (`web/src/components/ArticlesCell/ArticlesCell.tsx`) `Success` state. It imports the reusable 'Article' component and uses it within the `map` function to render each article fetched by the `ArticlesQuery`. Type safety is maintained via `CellSuccessProps` and GraphQL types. Each 'Article' component receives the corresponding article data as a prop.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_30\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { ArticlesQuery, ArticlesQueryVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypedDocumentNode,\n} from '@redwoodjs/web'\n\n// highlight-next-line\nimport Article from 'src/components/Article'\n\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\n  gql`\n    query ArticlesQuery {\n      articles: posts {\n        id\n        title\n        body\n        createdAt\n      }\n    }\n  `\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<ArticlesQueryVariables>) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  articles,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\n  return (\n    <>\n      {articles.map((article) => (\n        // highlight-next-line\n        <Article key={article.id} article={article} />\n      ))}\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Field Presence and Format using RedwoodJS validate() (JavaScript/JSX)\nDESCRIPTION: This snippet demonstrates the two forms of calling the validate() function for general data validation in RedwoodJS services. It shows both the two-argument and three-argument syntax to ensure an incoming email is present and formatted, providing either a custom or default error message. Dependencies include '@redwoodjs/api'; the function expects a value to check and validation rules, and will throw errors on failure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_3\n\nLANGUAGE: JSX\nCODE:\n```\n// Two argument form: validate(value, validations)\nvalidate(input.email, { email: { message: 'Please provide a valid email address' } })\n\n// Three argument form: validate(value, name, validations)\nvalidate(input.email, 'Email Address', { email: true }\n```\n\n----------------------------------------\n\nTITLE: Expanding CreateCommentArgs Interface to Allow Unchecked Prisma Inputs - TypeScript\nDESCRIPTION: Demonstrates how to update the CreateCommentArgs interface to accept Prisma unchecked input types, enabling both the connect syntax and direct postId assignment. This is useful when allowing greater flexibility in providing input data to the createComment service. Requires import from @prisma/client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_21\n\nLANGUAGE: ts\nCODE:\n```\ninterface CreateCommentArgs {\n  input: Prisma.CommentUncheckedCreateInput\n}\n```\n\nLANGUAGE: ts\nCODE:\n```\ninterface CreateCommentArgs {\n  input: Prisma.CommentCreateInput | Prisma.CommentUncheckedCreateInput\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Record in a One-to-Many Relationship in JSX\nDESCRIPTION: Illustrates creating a new record (`post`) associated with a parent record (`user`) in a one-to-many relationship by calling the `create` method on the relation proxy (`user.posts`). The new record is automatically linked to the parent.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_30\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = await User.find(123)\nconst post = await user.posts.create({ title: 'Related post!' })\n```\n\n----------------------------------------\n\nTITLE: Mocking a GraphQL Query with a Function Handler in JSX\nDESCRIPTION: Demonstrates using `mockGraphQLQuery` with an operation name ('OperationName') and a function as the second argument. The function receives `variables` and a context object `{ ctx, req }`. It uses `ctx.delay(1500)` to simulate a 1.5-second network delay before returning the mock data object for `userProfile`. Includes `__typename` for Apollo Client compatibility.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/mocking-graphql-requests.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nmockGraphQLQuery('OperationName', (variables, { ctx, req }) => {\n  ctx.delay(1500) // pause for 1.5 seconds\n  return {\n    userProfile: {\n      __typename: 'UserProfile' as const,\n      id: 42,\n      name: 'peterp',\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching Real Weather Data in a GraphQL Service with @whatwg-node/fetch - JavaScript\nDESCRIPTION: This snippet implements the 'getWeather' GraphQL service resolver to fetch live data from the OpenWeather API on the server side. The service uses '@whatwg-node/fetch' to make an HTTP request, then constructs a response object after converting temperature from Kelvin to Fahrenheit and formatting the icon URL. It expects 'zip' as a parameter, an API key in the request URL, and network access. Requires '@whatwg-node/fetch' as a dependency. Returns a Weather object with city name, conditions, formatted temperature, and icon URL.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { fetch } from '@whatwg-node/fetch'\n\nexport const getWeather = async ({ zip }) => {\n  const response = await fetch(\n    `http://api.openweathermap.org/data/2.5/weather?zip=${zip},US&appid=YOUR_API_KEY`\n  )\n  const json = await response.json()\n\n  return {\n    zip,\n    city: json.name,\n    conditions: json.weather[0].main,\n    temp: Math.round(((json.main.temp - 273.15) * 9) / 5 + 32),\n    icon: `http://openweathermap.org/img/wn/${json.weather[0].icon}@2x.png`,\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Apollo Cache via useCache Hook (TypeScript)\nDESCRIPTION: Shows how to destructure the cache object from the useCache hook in a functional component, providing direct access to Apollo's normalized in-memory cache. Typically used to inspect cached data or perform advanced cache operations. Requires running inside a RedwoodJS web component that uses Apollo.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_32\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst { cache } = useCache()\n```\n\n----------------------------------------\n\nTITLE: Importing useCache Hook from RedwoodJS/Apollo (TypeScript)\nDESCRIPTION: This import statement brings in the useCache hook from '@redwoodjs/web/apollo', enabling direct access to Apollo Client cache utilities in client components. The hook returns an object with methods for cache inspection and manipulation. Prerequisite: RedwoodJS web-side and Apollo Client must be installed and configured.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n```\n\n----------------------------------------\n\nTITLE: Retrieving Many-to-Many Records via Explicit Join Table (JavaScript)\nDESCRIPTION: Example JavaScript code demonstrating how to fetch related categories for a product by manually traversing through the `ProductCategory` join table model. This illustrates the current, more verbose process before planned RedwoodRecord simplification, involving finding the product, then its associated join table records, and finally mapping those to the target category records. It depends on existing `Product`, `ProductCategory`, and `Category` models.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst product = await Product.find(1)\nconst productCategories = await product.productCategories.all()\nconst categories = productCategories.map(async (pc) => await pc.categories.all()).flat()\n```\n\n----------------------------------------\n\nTITLE: Querying All Comments Using Prisma with Redwood Console in Bash\nDESCRIPTION: This command, to be executed within the Redwood console, retrieves all comment records from the database using Prisma's 'findMany' method on the 'comment' model. It returns an array of comment objects, each including 'id', 'name', 'body', 'postId', and 'createdAt'. No parameters are required, and the output is a list of all comments, regardless of association with a specific post.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ndb.comment.findMany()\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Cell via CLI - Bash\nDESCRIPTION: This command uses the RedwoodJS generator to scaffold a new cell component named 'Articles'. The generator creates multiple files, including a main component file that retrieves and displays data through GraphQL. The command requires the RedwoodJS CLI and project setup, and outputs files in the appropriate directories under /web/src/components.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g cell Articles\n```\n\n----------------------------------------\n\nTITLE: Generating the 'divide' Serverless Function - RedwoodJS CLI (Bash)\nDESCRIPTION: This command illustrates generating a new function with the name 'divide' using the RedwoodJS CLI. It scaffolds the appropriate files and directories under api/src/functions/divide for development and testing purposes. No additional dependencies are required beyond a functioning Redwood project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw generate function divide\n```\n\n----------------------------------------\n\nTITLE: Typing getCurrentUser Using AuthContextPayload (TypeScript)\nDESCRIPTION: This TypeScript example presents an alternative method for typing the `getCurrentUser` function in `api/src/lib/auth.ts` for strict mode. It uses the `AuthContextPayload` type imported from `@redwoodjs/api` to type the second and third parameters (`{ token, type }` and `{ event, context }`) while still requiring an explicit type for the `decoded` parameter.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// Example 2: Using AuthContextPayload\nexport const getCurrentUser: CurrentUserFunc = async (\n  decoded: { id: string; name: string },\n  { token, type }: AuthContextPayload[1],\n  { event, context }: AuthContextPayload[2]\n) => {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Serving the Web Application with API Proxy - RedwoodJS - Dockerfile\nDESCRIPTION: This snippet represents the web_serve stage: it starts from node:20-bookworm-slim, sets up node user and working directory, installs production web dependencies via Yarn workspaces, and copies built artifacts from web_build. It sets NODE_ENV=production and configures API_PROXY_TARGET for proxying API requests. The command runs 'rw-web-server' with API proxying enabled. Prerequisites are successful builds of earlier stages and a valid web/dist build output.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_15\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM node:20-bookworm-slim as web_serve\\n\\nRUN corepack enable\\n\\nUSER node\\nWORKDIR /home/node/app\\n\\nCOPY --chown=node:node .yarnrc.yml .\\nCOPY --chown=node:node package.json .\\nCOPY --chown=node:node web/package.json web/\\nCOPY --chown=node:node yarn.lock .\\n\\nRUN mkdir -p /home/node/.yarn/berry/index\\nRUN mkdir -p /home/node/.cache\\n\\nRUN --mount=type=cache,target=/home/node/.yarn/berry/cache,uid=1000 \\\\\\n    --mount=type=cache,target=/home/node/.cache,uid=1000 \\\\\\n    CI=1 yarn workspaces focus web --production\\n\\nCOPY --chown=node:node redwood.toml .\\nCOPY --chown=node:node graphql.config.js .\\nCOPY --chown=node:node .env.defaults .env.defaults\\n\\nCOPY --chown=node:node --from=web_build /home/node/app/web/dist /home/node/app/web/dist\\n\\nENV NODE_ENV=production \\\\\\n    API_PROXY_TARGET=http://api:8911\\n\\nCMD \"node_modules/.bin/rw-web-server\" \"--api-proxy-target\" \"$API_PROXY_TARGET\"\n```\n\n----------------------------------------\n\nTITLE: Securing Routes with Role-Based Access in RedwoodJS - JavaScript (JSX)\nDESCRIPTION: Wraps post administration routes in a <PrivateSet> component on the RedwoodJS web client, specifying that only 'admin' role users may access these routes. Redirects unauthorized users to the home page. Dependencies: RedwoodJS Router, ScaffoldLayout. All routes inside the set require 'admin' role; unauthenticated users are redirected.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\n<PrivateSet unauthenticated=\"home\" roles=\"admin\">\n  <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n    <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n    <Route path=\"/admin/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n    <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n    <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\n  </Set>\n</PrivateSet>\n```\n\n----------------------------------------\n\nTITLE: Accessing Related Records (One-to-Many) via Relation Proxy in JSX\nDESCRIPTION: This snippet demonstrates how to access related records in a one-to-many relationship. After fetching a parent record (e.g., `User`), you can access its related child records (e.g., `posts`) through a 'relation proxy' (e.g., `user.posts`). Standard finder methods like `all()` can then be called on this proxy.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = await User.find(123)\nconst posts = await user.posts.all()\n```\n\n----------------------------------------\n\nTITLE: Typing getCurrentUser Directly in Strict Mode (TypeScript)\nDESCRIPTION: This TypeScript example shows how to type the `getCurrentUser` function in `api/src/lib/auth.ts` to satisfy strict mode. It demonstrates defining an inline type for the `decoded` parameter (e.g., `{ id: string; name: string }`) based on the expected shape of the decoded authentication token.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AuthContextPayload } from '@redwoodjs/api'\n\n// Example 1: typing directly\nexport const getCurrentUser: CurrentUserFunc = async (\n  decoded: { id: string; name: string },\n  { token, type }: { token: string; type: string }\n) => {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Testing the Comment Component in TypeScript\nDESCRIPTION: This TSX snippet demonstrates a unit test for the 'Comment' component using TypeScript, Jest, and React Testing Library. It renders the component with sample `comment` data and verifies its output. Assertions check for the presence of the author's name, comment body, and the correctly formatted date. It also validates that the date is rendered within a `<time>` element having the appropriate `datetime` attribute.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/the-redwood-way.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\nimport { render, screen } from '@redwoodjs/testing'\n\nimport Comment from './Comment'\n\ndescribe('Comment', () => {\n  it('renders successfully', () => {\n    // highlight-start\n    const comment = {\n      name: 'John Doe',\n      body: 'This is my comment',\n      createdAt: '2020-01-02T12:34:56Z',\n    }\n    render(<Comment comment={comment} />)\n\n    expect(screen.getByText(comment.name)).toBeInTheDocument()\n    expect(screen.getByText(comment.body)).toBeInTheDocument()\n    const dateExpect = screen.getByText('2 January 2020')\n    expect(dateExpect).toBeInTheDocument()\n    expect(dateExpect.nodeName).toEqual('TIME')\n    expect(dateExpect).toHaveAttribute('datetime', comment.createdAt)\n    // highlight-end\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Props in RedwoodJS Cell Success Component (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how the `Success` component within a RedwoodJS Cell can access all props passed to the parent Cell instance. It destructures `article` (the GraphQL query result), `id` (passed prop used in the query), and `rand` (an extra prop not used in the query), making them all available for use within the component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nexport const Success = ({ article, id, rand }) => {\n  // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Importing useForm Hook in RedwoodJS Contact Page (TS)\nDESCRIPTION: Shows how to import the `useForm` hook alongside other form-related components from `@redwoodjs/forms` in a TypeScript (`.tsx`) file for a RedwoodJS ContactPage. This hook provides access to React Hook Form's API, necessary for manual form control like resetting fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_34\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport {\n  FieldError,\n  Form,\n  FormError,\n  Label,\n  Submit,\n  TextAreaField,\n  TextField,\n  // highlight-next-line\n  useForm,\n} from '@redwoodjs/forms'\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Comment in RedwoodJS Service (JavaScript)\nDESCRIPTION: Adds an exported `createComment` function to 'api/src/services/comments/comments.js'. This function accepts an `input` object containing comment data (name, body, postId) and uses `db.comment.create({ data: input })` to insert a new comment record into the database via the Prisma client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.js\"\nexport const createComment = ({ input }) => {\n  return db.comment.create({\n    data: input,\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Simplifying AboutPage Component in RedwoodJS (TypeScript)\nDESCRIPTION: This TSX snippet displays the TypeScript version of the simplified `AboutPage`. Like its JavaScript counterpart, it no longer contains a direct link back to the homepage, as this is now handled by the parent `BlogLayout`. It imports and uses the `Metadata` component for page title and description.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\n```jsx title=\"web/src/pages/AboutPage/AboutPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <>\n      <Metadata title=\"About\" description=\"About page\" />\n\n      <p>\n        This site was created to demonstrate my mastery of Redwood: Look on my\n        works, ye mighty, and despair!\n      </p>\n    </>\n  )\n}\n\nexport default AboutPage\n```\n```\n\n----------------------------------------\n\nTITLE: Setting up RedwoodJS Uploads Configuration\nDESCRIPTION: Shows the RedwoodJS CLI command `yarn rw setup uploads` used to initialize the file upload and storage system. Running this command generates a configuration file (`api/src/lib/uploads.ts`), configures the Prisma client with a storage extension, and generates a function for creating signed URLs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n```shell\nyarn rw setup uploads\n```\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Page Component (Bash)\nDESCRIPTION: Uses the RedwoodJS CLI command `yarn rw generate page` to create a new page component named `HomePage` located at the root URL (`/`). This command scaffolds the necessary files for a new page within the RedwoodJS project structure, setting up the foundation for the React component that will display the weather data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/disable-api-database.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw generate page home /\n```\n\n----------------------------------------\n\nTITLE: Generating a Dynamic Quote Page - RedwoodJS CLI - Bash/Plaintext\nDESCRIPTION: This plaintext snippet displays CLI output when generating a page with a route parameter (e.g., {id}). It shows steps carried out (file generation and routing updates) as processed in a RedwoodJS project using yarn. The command inputs are page name and parameterized path (such as 'quote {id}').\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_61\n\nLANGUAGE: plaintext\nCODE:\n```\n~/redwood-app$ yarn redwood generate page quote {id}\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood g page quote {id}\n  ✔ Generating page files...\n    ✔ Writing `./web/src/pages/QuotePage/QuotePage.stories.js`...\n    ✔ Writing `./web/src/pages/QuotePage/QuotePage.test.js`...\n    ✔ Writing `./web/src/pages/QuotePage/QuotePage.js`...\n  ✔ Updating routes file...\nDone in 1.02s.\n```\n\n----------------------------------------\n\nTITLE: Caveat: Extensions Not Applied on Nested Writes - RedwoodJS JavaScript\nDESCRIPTION: Explains a limitation of Prisma extensions: CRUD operation hooks (like file cleanup) are not triggered on nested create/update operations inside relation fields (e.g., `createMany` in a nested data object). This code snippet demonstrates processing a file list for inclusion in a nested creation, where failed creation will not clean up files automatically.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst savedFiles = saveFiles.inList(input.files)\n\ndb.folder.update({\n  data: {\n    ...input,\n    files: {\n      // highlight-start\n      createMany: {\n        data: savedFiles, // if the createMany fails, the saved files will _not_ be deleted\n      },\n      // highlight-end\n    },\n  },\n  where: { id },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Storybook Stories for Comment Component - React (TypeScript)\nDESCRIPTION: Defines similar defaultView and moderatorView stories as the JavaScript version, but with TypeScript syntax and file extension. The stories provide explicit structure to the comment prop required by Comment. There are no external dependencies besides the Comment component. Inputs are hardcoded comment objects, and outputs are React components displayed within Storybook.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\nimport Comment from './Comment'\\n\\n// highlight-next-line\\nexport const defaultView = () => {\\n  return (\\n    <Comment\\n      comment={{\\n        id: 1,\\n        name: 'Rob Cameron',\\n        body: 'This is the first comment!',\\n        createdAt: '2020-01-01T12:34:56Z',\\n        // highlight-next-line\\n        postId: 1,\\n      }}\\n    />\\n  )\\n}\\n\\n// highlight-start\\nexport const moderatorView = () => {\\n  return (\\n    <Comment\\n      comment={{\\n        id: 1,\\n        name: 'Rob Cameron',\\n        body: 'This is the first comment!',\\n        createdAt: '2020-01-01T12:34:56Z',\\n        postId: 1,\\n      }}\\n    />\\n  )\\n}\\n// highlight-end\\n\\nexport default { title: 'Components/Comment' }\n```\n\n----------------------------------------\n\nTITLE: Updating GraphQL Query for Refetching in RedwoodJS Cell (JSX)\nDESCRIPTION: This snippet shows the updated GraphQL query (`QUERY`) within the `CommentsCell.jsx` file. The `postId` field is added to the `comments` query selection set. This addition is necessary because the `refetchQueries` configuration in the `Comment` component requires `postId` as a variable to correctly refetch the comments for the specific post after one is deleted.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query CommentsQuery($postId: Int!) {\n    comments(postId: $postId) {\n      id\n      name\n      body\n      // highlight-next-line\n      postId\n      createdAt\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Loading Environment Variables in Redwood CLI (JSX)\nDESCRIPTION: This JavaScript snippet from the Redwood CLI source code (`index.js`) shows how environment variables are loaded into the application's environment. It uses the `dotenv-defaults` library to read variables from both `.env.defaults` (for defaults) and `.env` (for overrides/specifics) located in the project's base directory, making them available via `process.env` when running `yarn rw` commands.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/environment-variables.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"packages/cli/src/index.js\"\nimport { config } from 'dotenv-defaults'\n\nconfig({\n  path: path.join(getPaths().base, '.env'),\n  encoding: 'utf8',\n  defaults: path.join(getPaths().base, '.env.defaults'),\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Installing GraphQL Yoga Response Cache Plugin using Yarn\nDESCRIPTION: Provides the command to install the `@graphql-yoga/plugin-response-cache` package into the `api` workspace of a RedwoodJS project using the Yarn package manager. This plugin enables server-side GraphQL response caching.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/caching.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace api add @graphql-yoga/plugin-response-cache\n```\n\n----------------------------------------\n\nTITLE: Configuring Yarn Workspaces for Docusaurus Directory\nDESCRIPTION: This JSON snippet shows how to add the newly created `docs` directory to the `workspaces.packages` array within the project's root `package.json` file. This configuration allows Yarn to manage the `docs` directory as part of the monorepo.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_86\n\nLANGUAGE: json\nCODE:\n```\n  \"workspaces\": {\n    \"packages\": [\n      \"docs\",\n      \"api\",\n      \"web\",\n      \"packages/*\"\n    ]\n  },\n```\n\n----------------------------------------\n\nTITLE: Emulating Netlify Build Steps for RedwoodJS API with Bash\nDESCRIPTION: This series of Bash commands builds the RedwoodJS API, enters the API directory, and packages each lambda function using zip-it-and-ship-it into the zipballs directory. These steps simulate Netlify's serverless deployment build process locally. Dependencies required include the @netlify/zip-it-and-ship-it package (added as a dev dependency to api/), and the commands assume a typical RedwoodJS project structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/builds.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw build api\ncd api\nyarn zip-it-and-ship-it dist/functions/ zipballs/\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Component via CLI\nDESCRIPTION: Uses the RedwoodJS CLI (`rw`) command `g` (generate) to create a new component named 'Comment'. This command scaffolds the necessary files for the component, including the component file itself, a test file, and a Storybook story file.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/the-redwood-way.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g component Comment\n```\n\n----------------------------------------\n\nTITLE: Protecting RedwoodJS Page Markup for Multiple Roles (JSX)\nDESCRIPTION: This snippet shows how to protect markup within a Page component (`SettingsPage`) for multiple roles. After checking for authentication, it uses `hasRole` to render an 'Edit on Netlify' link if the user has either the 'admin' or 'userManager' role.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAuth } from \"@redwoodjs/auth\";\\nimport SidebarLayout from \"src/layouts/SidebarLayout\";\\n\\nconst SettingsPage = () => {\\n  const { isAuthenticated, userMetadata, hasRole } = useAuth();\\n\\n  return (\\n    {isAuthenticated && (\\n      <div className=\"ml-4 flex-shrink-0\">\\n        {hasRole([\"admin\", \"userManager\"]) && (\\n          <a\\n            href={`https://app.netlify.com/sites/${process.env.SITE_NAME}/identity/${userMetadata.id}`}\\n            target=\"_blank\"\\n            rel=\"noreferrer\"\\n          >\\n            Edit on Netlify\\n          </a>\\n        )}\\n      </div>\\n    )}\\n  )}\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Contact Page Route (JavaScript)\nDESCRIPTION: Modifies the `Routes.jsx` file to define the route for the `ContactPage`. The `<Route>` for `/contact` is placed within the `<Set>` component that wraps pages with the `BlogLayout`, ensuring the Contact page uses the shared blog layout.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/Routes.jsx\"\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n        <Route path=\"/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n        <Route path=\"/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n        <Route path=\"/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n        <Route path=\"/posts\" page={PostPostsPage} name=\"posts\" />\n      </Set>\n      <Set wrap={BlogLayout}>\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n        // highlight-next-line\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n```\n\n----------------------------------------\n\nTITLE: Integrating Article Component into ArticleCell (JSX)\nDESCRIPTION: Modifies the 'ArticleCell' JavaScript component's (`web/src/components/ArticleCell/ArticleCell.jsx`) `Success` state. It imports the reusable 'Article' component and renders it directly, passing the single fetched 'article' data (from the `FindArticleQuery`) as a prop. This replaces the previous display logic within the cell itself, promoting reusability.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_31\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport Article from 'src/components/Article'\n\nexport const QUERY = gql`\n  query FindArticleQuery($id: Int!) {\n    article: post(id: $id) {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({ article }) => {\n  // highlight-next-line\n  return <Article article={article} />\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring blockFieldSuggestion in RedwoodJS GraphQL Handler - TypeScript\nDESCRIPTION: This TypeScript object example enables the blockFieldSuggestion setting in the RedwoodJS GraphQL handler configuration. Activating this feature prevents field name suggestions in error messages, protecting sensitive API schema details from being unintentionally revealed during erroneous queries. Requires no extra dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  blockFieldSuggestion: {\n    enabled: true,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Identity Model in Prisma Schema\nDESCRIPTION: Defines the `Identity` model within the Prisma schema (`/api/db/schema.prisma`). This model stores details about external authentication providers for a user, including the provider name, unique user ID from the provider, associated local user ID, optional access token and scope, and timestamps. It includes unique constraints on provider/uid combination and an index on userId.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_5\n\nLANGUAGE: prisma\nCODE:\n```\nmodel Identity {\n  id                  Int       @id @default(autoincrement())\n  provider            String\n  uid                 String\n  userId              Int\n  user                User      @relation(fields: [userId], references: [id])\n  accessToken         String?\n  scope               String?\n  lastLoginAt         DateTime  @default(now())\n  createdAt           DateTime  @default(now())\n  updatedAt           DateTime  @updatedAt\n\n  @@unique([provider, uid])\n  @@index(userId)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Fonts with @font-face in CSS\nDESCRIPTION: Provides a CSS example using the `@font-face` rule to define and use a custom font (`Redwood Neue`). It references the font file located in the `web/public/fonts/` directory using an absolute path (`/fonts/RedwoodNeue.woff2`) relative to the application's root.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/assets-and-files.md#_snippet_8\n\nLANGUAGE: css\nCODE:\n```\n/* in e.g. index.css */\n@font-face {\n  font-family: 'Redwood Neue';\n  /* 👇 it's a relative path */\n  // highlight-next-line\n  src: url('/fonts/RedwoodNeue.woff2')\n    format('woff2');\n  font-weight: 300;\n  font-style: italic;\n  ascent-override: 97%;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Corepack and Checking Yarn Version using Bash\nDESCRIPTION: This sequence of bash commands first enables Corepack, a tool included with Node.js v18+ for managing package managers like Yarn. Then, it checks the version of Yarn managed by Corepack. Although it might initially report an older version like 1.22.21, Corepack will utilize the modern Yarn version specified within a Redwood project's `package.json` due to the `packageManager` field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/prerequisites.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncorepack enable\nyarn -v\n```\n\n----------------------------------------\n\nTITLE: Disabling Reset Password Feature in JavaScript Configuration\nDESCRIPTION: Configures the `resetPassword` feature within the dbAuth setup. Setting the `enabled` property to `false` prevents users from completing the password reset process using a token, effectively disabling password resets via the forgot password flow. This is typically used in conjunction with disabling `forgotPassword`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nresetPassword: {\n  enabled: false\n}\n```\n\n----------------------------------------\n\nTITLE: Presenting RedwoodJS Project Directory Structure - JavaScript - Markdown Code Block\nDESCRIPTION: This snippet represents the canonical RedwoodJS project file layout in JavaScript environments using a tree diagram within a Markdown code block. It is intended to orient new users to the major directories and files, indicating which areas handle backend (api), frontend (web), and general-purpose scripts. No code execution occurs; this is for documentation and onboarding, not runtime use.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/file-structure.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\n├── api\n│   ├── db\n│   │   └── schema.prisma\n│   └── src\n│       ├── directives\n│       │   ├── requireAuth\n│       │   └── skipAuth\n│       ├── functions\n│       │   └── graphql.js\n│       ├── graphql\n│       ├── lib\n│       │   ├── auth.js\n│       │   ├── db.js\n│       │   └── logger.js\n│       └── services\n│\n├── scripts\n│   └── seed.js\n│\n└── web\n    ├── public\n    │   ├── favicon.png\n    │   ├── README.md\n    │   └── robots.txt\n    └── src\n        ├── components\n        ├── layouts\n        ├── pages\n        │   ├── FatalErrorPage\n        │   │   └── FatalErrorPage.jsx\n        │   └── NotFoundPage\n        │       └── NotFoundPage.jsx\n        ├── App.jsx\n        ├── entry.client.jsx\n        ├── index.css\n        ├── index.html\n        └── Routes.jsx\n```\n```\n\n----------------------------------------\n\nTITLE: Writing Tests Using getByText with React Testing Library in JavaScript\nDESCRIPTION: This test verifies that the <Article> component correctly renders the provided title using the getByText query provided by React Testing Library. Dependencies include '@redwoodjs/testing/web' and the Article component. The key parameters involve passing an article prop with a title, rendering the component, and using screen.getByText to assert the title's presence in the document. The test expects the DOM to include the specified text. Components and test runner setup must be available.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { render, screen } from '@redwoodjs/testing/web'\n\ndescribe('Article', () => {\n  it('renders an article', () => {\n    render(<Article article={ title: 'Foobar' } />)\n\n    expect(screen.getByText('Foobar')).toBeInTheDocument()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS JobManager (JavaScript)\nDESCRIPTION: Displays the comprehensive configuration object passed to the `JobManager` constructor, typically in `api/src/lib/jobs.js`. It defines storage adapters (`PrismaAdapter` instance linked to `db` and `logger`), available named `queues`, a default `logger` for the job system, and detailed `workers` configuration specifying adapter usage, queue monitoring (`*` for all or specific names), concurrency (`count`), retry behavior (`maxAttempts`), timeouts (`maxRuntime`), failed job handling (`deleteFailedJobs`), and polling interval (`sleepDelay`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_20\n\nLANGUAGE: js\nCODE:\n```\nexport const jobs = new JobManager({\n  adapters: {\n    prisma: new PrismaAdapter({ db, logger }),\n  },\n  queues: ['default'],\n  logger,\n  workers: [\n    {\n      adapter: 'prisma',\n      logger,\n      queue: '*',\n      count: 1,\n      maxAttempts: 24,\n      maxRuntime: 14_400,\n      deleteFailedJobs: false,\n      sleepDelay: 5,\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Signed URL Validation Function in TypeScript\nDESCRIPTION: This TypeScript code outlines the handler function (`signedUrl.ts`) automatically generated by RedwoodJS for validating signed URLs. It imports pre-configured `urlSigner` and `fsStorage` instances. The handler receives the request event, extracts query string parameters (`s`, `path`, `expiry`), and validates them using `urlSigner.validateSignature`. If valid, it retrieves the file contents and content type using `fsStorage.read` and returns the file data in the HTTP response with appropriate headers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { SignatureValidationArgs } from '@redwoodjs/storage/UrlSigner'\n\n// The urlSigner and fsStorage instances were configured when we setup uploads\n// highlight-next-line\nimport { urlSigner, fsStorage } from 'src/lib/uploads'\n\nexport const handler = async (event) => {\n  // Validate the signature using the urlSigner instance\n  // highlight-next-line\n  const fileToReturn = urlSigner.validateSignature(\n    // Pass the params {s, path, expiry}\n    // highlight-next-line\n    event.queryStringParameters as SignatureValidationArgs\n  )\n\n  // Use the returned value to lookup the file in your storage\n  // highlight-next-line\n  const { contents, type } = await fsStorage.read(fileToReturn)\n\n  return {\n    statusCode: 200,\n    headers: {\n      // You also get the type from the read\n      'Content-Type': type,\n    },\n    // Return the contents of the file\n    body: contents,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Pattern Validation to Email Field in RedwoodJS Form (TypeScript)\nDESCRIPTION: Illustrates adding email format validation to the `TextField` component for the email field within a RedwoodJS form using TypeScript (TSX). The `validation` prop is updated to include a `pattern` object, which specifies a regular expression (`value`) to match against and a custom `message` to display if the pattern fails.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_31\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\n<TextField\n  name=\"email\"\n  validation={{\n    required: true,\n    // highlight-start\n    pattern: {\n      value: /^[^@]+@[^.]+\\..+$/,\n      message: 'Please enter a valid email address',\n    },\n    // highlight-end\n  }}\n  errorClassName=\"error\"\n/>\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Database URL in .env\nDESCRIPTION: Defines the `TEST_DATABASE_URL` environment variable within the `.env` file. This variable is required by RedwoodJS tests to connect to the test database, often mirroring the `DATABASE_URL`. This configuration is necessary to resolve Prisma schema validation errors (like P1012) during test runs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/testing.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nTEST_DATABASE_URL=<the same url as DATABASE_URL>\n```\n\n----------------------------------------\n\nTITLE: Accessing Parent Record in a Belongs-To Relationship in JSX\nDESCRIPTION: In a belongs-to relationship, the child record holds the foreign key to the parent. This snippet shows accessing the single parent record (`user`) directly from the child record (`post`) via a property named after the parent model (e.g., `post.user`). No relation proxy is needed as there is only one parent.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_31\n\nLANGUAGE: jsx\nCODE:\n```\nconst post = await Post.first()\nconst user = await post.user\n```\n\n----------------------------------------\n\nTITLE: Using Mock Data with Explicit Props in RedwoodJS Storybook Story (JSX/TSX)\nDESCRIPTION: This alternative Storybook story imports the `Success` component and the `standard` mock. It explicitly passes the `articles` data from the mock to the `Success` component's `articles` prop (`articles={standard().articles}`). This achieves the same result as the spread syntax but provides more clarity by explicitly naming the prop being passed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticlesCell/ArticlesCell.stories.jsx\"\nimport { Success } from './ArticlesCell'\nimport { standard } from './ArticlesCell.mock'\n\nexport const success = () => {\n  // highlight-next-line\n  return Success ? <Success articles={standard().articles} /> : null\n}\n\nexport default { title: 'Cells/ArticlesCell' }\n```\n```\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/ArticlesCell/ArticlesCell.stories.tsx\"\nimport { Success } from './ArticlesCell'\nimport { standard } from './ArticlesCell.mock'\n\nexport const success = () => {\n  // highlight-next-line\n  return Success ? <Success articles={standard().articles} /> : null\n}\n\nexport default { title: 'Cells/ArticlesCell' }\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up RedwoodJS Jobs - Bash\nDESCRIPTION: These shell commands set up RedwoodJS's jobs feature and prepare the database schema. The first command initializes job configuration, and the second applies Prisma migrations to create the 'BackgroundJob' table. Run these in your project directory. Outputs will include the creation of a configuration file and the necessary database structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup jobs\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Installing Framework Dependencies with Yarn\nDESCRIPTION: This command utilizes the Yarn package manager to install all necessary dependencies as defined in the `package.json` file within the RedwoodJS framework's root directory. Running `yarn` alone achieves the same result. It's a fundamental step required after cloning the framework repository or pulling new changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/contributing-walkthrough.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn install\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response from 'divide' Function - Bash (JSON Syntax for Illustration)\nDESCRIPTION: Presents a sample successful JSON response returned after dividing two numbers using the 'divide' endpoint. Intended to illustrate expected outputs for consumers or for use in test assertions. Output: message, inputs, and computed quotient.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n// response\n{\"message\":\"10 / 2 = 5\",\"dividend\":\"10\",\"divisor\":\"2\",\"quotient\":5}\n```\n\n----------------------------------------\n\nTITLE: Declaring a RedwoodJS Transformer Directive (`@maskedEmail`) with Arguments (GraphQL)\nDESCRIPTION: Defines the GraphQL schema for a transformer directive `@maskedEmail` using `gql`. It specifies that the directive takes an optional `permittedRoles` argument (a list of Strings) and can only be applied to field definitions (`FIELD_DEFINITION`). This allows controlling the transformation based on user roles.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_7\n\nLANGUAGE: graphql\nCODE:\n```\ntype user {\n  email: String! @maskedEmail(permittedRoles: [\"ADMIN\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying SSH Key Addition with ssh-add -L in Bash\nDESCRIPTION: Shows the `ssh-add -L` command being used again, this time specifically to check if a newly generated or manually added key is now recognized and listed by the `ssh-agent`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nssh-add -L\n```\n\n----------------------------------------\n\nTITLE: Implementing Auth Buttons and Links in Navigation Component (RedwoodJS, JavaScript)\nDESCRIPTION: This version completes the Navigation component by importing and using a SignoutBtn component for authenticated users, and rendering Sign Up and Sign In links for unauthenticated users. Relies on isAuthenticated from useAuth, and imports both '@redwoodjs/router' and '@redwoodjs/auth'. Assumes existence of the SignoutBtn component elsewhere in the codebase.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { useAuth } from '@redwoodjs/auth'\nimport SignoutBtn from 'src/components/SignoutBtn/SignoutBtn'\n\nconst Navigation = () => {\n  const { isAuthenticated } = useAuth()\n  return (\n    <nav>\n      {isAuthenticated ? (\n        <SignoutBtn />\n      ) : (\n        <>\n          <Link to={routes.signup()}>Sign Up</Link>\n          <Link to={routes.signin()}>Sign In</Link>\n        </>\n      )}\n    </nav>\n  )\n}\n\nexport default Navigation\n```\n\n----------------------------------------\n\nTITLE: Defining Comment GraphQL Schema with Public Access (GraphQL/JavaScript)\nDESCRIPTION: Defines the GraphQL schema for the `Comment` type and related queries/inputs within `api/src/graphql/comments.sdl.js`. It specifies the fields for the `Comment` type, includes a query `comments` to fetch all comments, and defines `CreateCommentInput` and `UpdateCommentInput` types. The `@skipAuth` directive is applied to the `comments` query to make it publicly accessible without authentication.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\n  type Comment {\n    id: Int!\n    name: String!\n    body: String!\n    post: Post!\n    postId: Int!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    // highlight-next-line\n    comments: [Comment!]! @skipAuth\n  }\n\n  input CreateCommentInput {\n    name: String!\n    body: String!\n    postId: Int!\n  }\n\n  input UpdateCommentInput {\n    name: String\n    body: String\n    postId: Int\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Destroying a RedwoodJS Service (Bash)\nDESCRIPTION: This command removes the service file and its associated test and scenario files that were previously generated for the specified service name.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_86\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood destroy service <name>\n```\n\n----------------------------------------\n\nTITLE: Simplified Many-to-Many Record Retrieval (Future RedwoodRecord) (JavaScript)\nDESCRIPTION: Hypothetical JavaScript code showing the intended simplified way to fetch related categories for a product using planned future RedwoodRecord features. This approach aims to abstract the underlying join table interaction, allowing direct access to related records. It depends on `Product` and `Category` models configured with RedwoodRecord's planned many-to-many relationship handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst product = await Product.find(1)\nconst categories = await product.categories.all()\n```\n\n----------------------------------------\n\nTITLE: Including Image URL in Form Submission Data for RedwoodJS (JavaScript)\nDESCRIPTION: This concise snippet inserts the tracked image URL into the form data before it is passed to the onSave handler. By using Object.assign to add the current URL value, it ensures the uploaded image's public URL is included with other submitted form data. Dependencies are standard built-in JavaScript methods. Inputs are the original data object and URL state. Output is the merged object, which is then saved.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {2,3} title=\\\"web/src/components/ImageForm/ImageForm.js\\\"\nconst onSubmit = (data) => {\n  const dataWithUrl = Object.assign(data, { url })\n  props.onSave(dataWithUrl, props?.image?.id)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: SSH Private Key Auth Successful Command Example - Shell\nDESCRIPTION: This snippet demonstrates the correct SSH command format for connecting to a remote server with a specific username and a private key located at a given path. The -i flag specifies the key path. The SSH client is required. Input parameters are the key file, username, and server address; successful connection depends on permissions and server configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nssh -i ~/.ssh/keyname.pem ubuntu@192.168.0.122\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Comment Service Functions in JavaScript\nDESCRIPTION: This JavaScript snippet defines the initial service functions for comments in a RedwoodJS API. It imports the Prisma client (`db`) and exports `comments` to fetch all comments using `db.comment.findMany()`, `comment` to fetch a single comment by ID using `db.comment.findUnique()`, and a `Comment` resolver object with a `post` function to fetch the associated post for a given comment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.js\"\nimport { db } from 'src/lib/db'\n\nexport const comments = () => {\n  return db.comment.findMany()\n}\n\nexport const comment = ({ id }) => {\n  return db.comment.findUnique({\n    where: { id },\n  })\n}\n\nexport const Comment = {\n  post: (_obj, { root }) =>\n    db.comment.findUnique({ where: { id: root.id } }).post(),\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a New Redwood Project with Yarn CLI (Shell)\nDESCRIPTION: This shell command initializes a new RedwoodJS project in the specified directory ('my-redwood-project'). It downloads the Redwood starter via Yarn, scaffolds the project structure, and prepares the development environment. No additional dependencies are needed beyond Node.js (v20.x) and Yarn (>=1.22.21). Expects an empty or non-existent target directory. Outputs a ready-to-use RedwoodJS application with default configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn create redwood-app my-redwood-project\n```\n\n----------------------------------------\n\nTITLE: Using AdminPost Query in EditPostCell Component - JavaScript\nDESCRIPTION: This snippet modifies the EditPostCell component GraphQL query, replacing public post fetching with the admin-only adminPost query. The argument $id identifies the Post, and the returned fields include id, title, body, createdAt. Result renaming (post: adminPost) ensures compatibility with the rest of the component. Requires GraphQL setup with adminPost endpoint and RedwoodJS gql.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nexport const QUERY = gql`\n  query EditPostById($id: Int!) {\n    // highlight-next-line\n    post: adminPost(id: $id) {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Contact Form with RedwoodJS (JSX)\nDESCRIPTION: Defines a functional React component `ContactPage` in JSX for a RedwoodJS contact form. It imports necessary components from `@redwoodjs/forms` like `Form`, `Label`, `TextField`, `TextAreaField`, `FieldError`, and `Submit`. The form includes fields for name, email, and message, with basic `required` validation applied to each. An `onSubmit` handler logs the form data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_28\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { MetaTags } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <MetaTags title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-start\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        // highlight-start\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"email\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        // highlight-start\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        // highlight-end\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Updating Comments Query in RedwoodJS Cell (JSX)\nDESCRIPTION: This snippet shows the required update to the `CommentsQuery` within the `CommentsCell.jsx` file. The `postId` field is added to the query's selection set. This is necessary because the `Comment` component uses `comment.postId` in the `variables` for the `refetchQueries` option after deleting a comment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query CommentsQuery($postId: Int!) {\n    comments(postId: $postId) {\n      id\n      name\n      body\n      // highlight-next-line\n      postId\n      createdAt\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Query Single Article Including User Name - RedwoodJS Cell - GraphQL (in JSX)\nDESCRIPTION: A frontend GraphQL query for fetching a single article (post) including the associated user's name, intended for detail view cells. Accepts a required integer id parameter, and returns the article's details with its author's name. Useful for single post pages or expanded views.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_12\n\nLANGUAGE: graphql\nCODE:\n```\nquery ArticleQuery($id: Int!) {\n  article: post(id: $id) {\n    id\n    title\n    body\n    createdAt\n    // highlight-start\n    user {\n      name\n    }\n    // highlight-end\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating TypeScript Success Component to Render Detailed Article Data (TSX)\nDESCRIPTION: This TSX snippet demonstrates updating the typed `Success` component within `ArticlesCell.tsx`. It iterates over the `articles` array using `.map()` and renders each article's details (`title`, `body`, `createdAt`), leveraging the type safety provided by `CellSuccessProps` to access these properties within structured HTML.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_24\n\nLANGUAGE: tsx\nCODE:\n```\nexport const Success = ({\n  articles,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\n  return (\n    // highlight-start\n    <>\n      {articles.map((article) => (\n        <article key={article.id}>\n          <header>\n            <h2>{article.title}</h2>\n          </header>\n          <p>{article.body}</p>\n          <div>Posted at: {article.createdAt}</div>\n        </article>\n      ))}\n    </>\n    // highlight-end\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using whileLoadingAuth for Shell Rendering During Authentication (JavaScript/JSX)\nDESCRIPTION: Details usage of the 'whileLoadingAuth' prop on a RedwoodJS Set, allowing display of skeleton loaders or placeholder UIs during auth checks. Demonstrates wrapping protected routes with a layout and showing custom UI while loading. Requires a DashboardLoader component and the relevant layout setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\n// This renders the layout with skeleton loaders in the content area\n// highlight-next-line\nconst DashboardLoader = () => <DashboardLayout skeleton />\n\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Route path=\"/\" page={HomePage} name=\"home\" prerender />\n       <Set\n        private\n        wrap={DashboardLayout}\n        unauthenticated=\"login\"\n        // 👇 tell the router to render the shell until the user has been authenticated\n        // highlight-next-line\n        whileLoadingAuth={DashboardLoader}\n        prerender\n      >\n        <Route path=\"/dashboard\" page={DashboardPage} name=\"dashboard\"/>\n      {/* ... */}\n```\n\n----------------------------------------\n\nTITLE: Initializing RedwoodRecord with Redwood CLI (Shell)\nDESCRIPTION: A shell command using the RedwoodJS CLI (`rw record init`) to initialize RedwoodRecord within the project. This command parses the Prisma schema, caches it (e.g., in `api/src/models/datamodel.js`), and generates necessary configuration files like `api/src/models/index.js`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw record init\n```\n\n----------------------------------------\n\nTITLE: Applying @skipAuth Directive for Public Access in RedwoodJS GraphQL Schema\nDESCRIPTION: Illustrates using the `@skipAuth` directive on GraphQL queries (`posts`, `post`) within a schema definition. This explicitly marks these queries as public, allowing any user, whether authenticated or not, to execute them without invoking any authentication or authorization checks.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_59\n\nLANGUAGE: ts\nCODE:\n```\ntype Post {\n  id: Int!\n  title: String!\n  body: String!\n  authorId: Int!\n  author: User!\n  createdAt: DateTime!\n}\n\ntype Query {\n  posts: [Post!]! @skipAuth\n  post(id: Int!): Post @skipAuth\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a RedwoodJS Transformer Directive (TypeScript/Jest)\nDESCRIPTION: Provides a Jest test suite for the `maskedEmail` Transformer directive using RedwoodJS testing utilities (`mockRedwoodDirective`, `getDirectiveName`). The tests verify the directive's schema definition and its transformation logic. It uses `mockRedwoodDirective` with a `mockedResolvedValue` ('foo') and asserts that the execution returns the expected transformed value ('bar'), based on the stub implementation. Tests should be updated as the `transform` logic evolves.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_31\n\nLANGUAGE: tsx\nCODE:\n```\nimport { mockRedwoodDirective, getDirectiveName } from '@redwoodjs/testing/api'\n\nimport maskedEmail from './maskedEmail'\n\ndescribe('maskedEmail directive', () => {\n  it('declares the directive sdl as schema, with the correct name', () => {\n    expect(maskedEmail.schema).toBeTruthy()\n    expect(getDirectiveName(maskedEmail.schema)).toBe('maskedEmail')\n  })\n\n  it('has a maskedEmail implementation transforms the value', () => {\n    const mockExecution = mockRedwoodDirective(maskedEmail, {\n      mockedResolvedValue: 'foo',\n    })\n\n    expect(mockExecution()).toBe('bar')\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Admin-Only GraphQL SDL for Posts with Access Control (JavaScript)\nDESCRIPTION: This snippet defines a new GraphQL SDL (Schema Definition Language) in RedwoodJS specifying queries and mutations for admin-only post operations, enforced by @requireAuth(roles: [\"admin\"]). It covers both listing and retrieving posts, and permits creating, updating, and deleting with required and optional fields. The SDL also describes mutation input types. All operations are only permitted to authenticated admin users, and require RedwoodJS’ gql helper.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nexport const schema = gql`\n  type Query {\n    adminPosts: [Post!]! @requireAuth(roles: [\"admin\"])\n    adminPost(id: Int!): Post @requireAuth(roles: [\"admin\"])\n  }\n\n  input CreatePostInput {\n    title: String!\n    body: String!\n  }\n\n  input UpdatePostInput {\n    title: String\n    body: String\n  }\n\n  type Mutation {\n    createPost(input: CreatePostInput!): Post! @requireAuth(roles: [\"admin\"])\n    updatePost(id: Int!, input: UpdatePostInput!): Post!\n      @requireAuth(roles: [\"admin\"])\n    deletePost(id: Int!): Post! @requireAuth(roles: [\"admin\"])\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Creating a Thumbnail URL with Filestack Transform in RedwoodJS (JavaScript)\nDESCRIPTION: This function adds a 'resize=width:100' transformation to a Filestack CDN image URL to ensure that thumbnails are loaded at optimized sizes for high-DPI displays. It splits and modifies the incoming URL to insert the transformation directive. Requires only standard JavaScript and expects valid Filestack CDN URLs as input. Output is a transformed CDN URL pointing to the appropriately sized thumbnail image.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\\\"web/src/components/Images/Images.js\\\"\nconst thumbnail = (url) => {\n  const parts = url.split('/')\n  parts.splice(3, 0, 'resize=width:100')\n  return parts.join('/')\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Labels to RedwoodJS Form Fields (JavaScript)\nDESCRIPTION: This snippet illustrates adding standard HTML `<label>` elements associated with each form field (`TextField`, `TextAreaField`) using the `htmlFor` attribute in a RedwoodJS form component. This improves accessibility and user experience.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport { Form, TextField, TextAreaField, Submit } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-next-line\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" />\n\n        // highlight-next-line\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" />\n\n        // highlight-next-line\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Sample KPI Data Array (tsx)\nDESCRIPTION: This code declares an array, kpis, of Kpi objects, supplying sample data to display on the dashboard. Each item includes title, metric, progress, metricTarget, delta, and deltaType. The array can be expanded for more KPIs or replaced with dynamic data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nconst kpis: Kpi[] = [\n  // 👉 Create some sample KPI data\n  {\n    title: 'Sales',\n    metric: '$ 12,699',\n    progress: 15.9,\n    metricTarget: '$ 80,000',\n    delta: '13.2%',\n    deltaType: 'moderateIncrease',\n  },\n  {\n    title: 'Profit',\n    metric: '$ 45,564',\n    progress: 36.5,\n    metricTarget: '$ 125,000',\n    delta: '23.9%',\n    deltaType: 'increase',\n  },\n  {\n    title: 'Customers',\n    metric: '1,072',\n    progress: 53.6,\n    metricTarget: '2,000',\n    delta: '10.1%',\n    deltaType: 'moderateDecrease',\n  },\n]\n```\n\n----------------------------------------\n\nTITLE: Updating RedwoodJS Routes for Admin Section in TypeScript\nDESCRIPTION: This snippet shows the TypeScript equivalent (`Routes.tsx`) for updating RedwoodJS routes. It moves the post administration routes under `/admin` using the `Router`, `Route`, and `Set` components from `@redwoodjs/router`, mirroring the JavaScript version. It requires corresponding page components and layouts.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/Routes.tsx\"\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n        // highlight-start\n        <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n        <Route path=\"/admin/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n        <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n        <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\n        // highlight-end\n      </Set>\n      <Set wrap={BlogLayout}>\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n```\n\n----------------------------------------\n\nTITLE: Starting the RedwoodJS Test Suite with Yarn\nDESCRIPTION: Executes the RedwoodJS test command using Yarn. This command starts a persistent process that watches for file changes and automatically runs tests associated with the modified files. Hitting 'a' runs all tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/testing.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test\n```\n\n----------------------------------------\n\nTITLE: Generating Login Token in Users Service - JavaScript\nDESCRIPTION: This asynchronous function generates a one-time login token for a user based on their email address. It uses the Node crypto module to generate a 6-digit value, hashes it with Redwood's hashPassword, and updates the user in the database with the new salt and token expiration (15 minutes from now). Dependencies: node:crypto, @redwoodjs/auth-dbauth-api, @redwoodjs/graphql-server, and a functional database connection. Inputs: email (string). Outputs: success message or error throw. Token is intended for single use, adding security by expiring rapidly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// add the following three imports to the top of the file\nimport crypto from 'node:crypto'\n\nimport { hashPassword } from '@redwoodjs/auth-dbauth-api'\nimport { UserInputError } from '@redwoodjs/graphql-server'\n\n// add this to the bottom of the file\nexport const generateLoginToken = async ({ email }) => {\n  try {\n    // look up if the user exists\n    const lookupUser = await db.user.findFirst({ where: { email } })\n\n    if (!lookupUser) {\n      console.debug('User not found')\n      return { message: 'Login Request received' }\n    }\n\n    // here we're going to generate a random password of 6 numbers\n    const randomNumber = crypto\n      .randomInt(0, 1_000_000)\n      .toString()\n      .padStart(6, '0')\n    console.log('OTP:', randomNumber) // email the user this number\n\n    const [loginToken, salt] = hashPassword(randomNumber)\n\n    const loginTokenExpiresAt = new Date()\n    loginTokenExpiresAt.setMinutes(loginTokenExpiresAt.getMinutes() + 15)\n\n    // now we'll update the user with the new salt and loginToken\n    await db.user.update({\n      where: { id: lookupUser.id },\n      data: {\n        salt,\n        loginToken,\n        loginTokenExpiresAt,\n      },\n    })\n\n    return { message: 'Login Request received' }\n  } catch (error) {\n    console.log({ error })\n    throw new UserInputError(error.message)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Error State Handling and Display (JSX)\nDESCRIPTION: This snippet improves user feedback by adding error handling to the sign-up process. It utilizes `React.useState` to manage an `error` state variable, initialized to `null`. The `onSubmit` function now clears previous errors using `setError(null)`, attempts the sign-up, and sets the `error` state using `setError()` if the `signUp` call returns an error object (`response?.error?.message`) or if an exception is caught (`error.message`). The error message is conditionally rendered as a paragraph (`<p>`) within the form UI using `{error && <p>{error}</p>}`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from 'src/auth'\n\nconst SignupPage = () => {\n  const { client } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = async (data) => {\n    setError(null)\n    try {\n      const response = await client.auth.signUp({\n        email: data.email,\n        password: data.password\n      })\n      console.log('response: ', response)\n      response?.error?.message && setError(response.error.message)\n    } catch(error) {\n      setError(error.message)\n    }\n  }\n\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Service (Bash)\nDESCRIPTION: This command generates the necessary files for a RedwoodJS service, which encapsulates business logic. It creates a service file, along with optional test and scenario files. Options include `--force`, `--typescript`, `--tests`, and `--rollback`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_85\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate service <name>\n```\n\n----------------------------------------\n\nTITLE: Starting the RedwoodJS Console (Shell)\nDESCRIPTION: A shell command using the RedwoodJS CLI (`rw c`) to start the interactive console (REPL). This environment preloads RedwoodJS components, allowing developers to test and interact with application parts, including RedwoodRecord models.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw c\n```\n\n----------------------------------------\n\nTITLE: Integrating Redwood Realtime with GraphQL Handler in TypeScript\nDESCRIPTION: This snippet demonstrates how to integrate RedwoodJS's realtime support into the GraphQL handler configuration file. The 'realtime' import and configuration injects realtime capabilities (such as live queries and subscriptions) into your API's GraphQL endpoint. You must have 'src/lib/realtime' implemented and ensure 'createGraphQLHandler' is accessible. The handler expects an object with a 'realtime' key, which can be customized with further options.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n+ import { realtime } from 'src/lib/realtime'\n\n  export const handler = createGraphQLHandler({\n    // ...\n+   realtime,\n  })\n```\n\n----------------------------------------\n\nTITLE: Handling Successful Comment Submission with Toast Notification in RedwoodJS (JavaScript)\nDESCRIPTION: This JavaScript code implements form submission for comments in RedwoodJS, including setting the hasPosted state and displaying a toast notification upon comment creation. The code imports react-hot-toast's toast and uses onCompleted in the useMutation hook to show a notification and hide the form with a CSS class. It requires @redwoodjs/forms, @redwoodjs/web, and @redwoodjs/web/toast, and takes postId as input. On success, the user sees a 'Thank you' toast and the form is hidden, though actual notification requires the Toaster component elsewhere in the app.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { useState } from 'react'\n\nimport {\n  Form,\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\nimport { useMutation } from '@redwoodjs/web'\n// highlight-next-line\nimport { toast } from '@redwoodjs/web/toast'\n\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n\nconst CREATE = gql`\n  mutation CreateCommentMutation($input: CreateCommentInput!) {\n    createComment(input: $input) {\n      id\n      name\n      body\n      createdAt\n    }\n  }\n`\n\nconst CommentForm = ({ postId }) => {\n  // highlight-next-line\n  const [hasPosted, setHasPosted] = useState(false)\n  const [createComment, { loading, error }] = useMutation(CREATE, {\n    // highlight-start\n    onCompleted: () => {\n      setHasPosted(true)\n      toast.success('Thank you for your comment!')\n    },\n    // highlight-end\n    refetchQueries: [{ query: CommentsQuery }],\n  })\n\n  const onSubmit = (input) => {\n    createComment({ variables: { input: { postId, ...input } } })\n  }\n\n  return (\n    // highlight-next-line\n    <div className={hasPosted ? 'hidden' : ''}>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      <Form className=\"mt-4 w-full\" onSubmit={onSubmit}>\n        <FormError\n          error={error}\n          titleClassName=\"font-semibold\"\n          wrapperClassName=\"bg-red-100 text-red-900 text-sm p-3 rounded\"\n        />\n        <Label\n          name=\"name\"\n          className=\"block text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-sm \"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-xs font-semibold text-gray-500 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-sm\"\n          validation={{ required: true }}\n        />\n\n        <Submit\n          disabled={loading}\n          className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\"\n        >\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n\n----------------------------------------\n\nTITLE: Initializing a Basic RedwoodJS Form Component (JSX)\nDESCRIPTION: This snippet shows the initial setup for a `ContactPage` component in JavaScript (JSX). It imports the `Metadata` component from `@redwoodjs/web` and the `Form` component from `@redwoodjs/forms`, rendering an empty form within the page structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      // highlight-next-line\n      <Form></Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: PM2 Startup Script System Output Example - Bash\nDESCRIPTION: This code block illustrates the expected console output when running the 'pm2 startup' command. It includes instructions to copy and execute a sudo command, which sets up PM2 to start with the system boot. Note that output values such as user paths and node versions will differ depending on your server environment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n$ pm2 startup\n[PM2] Init System found: systemd\n[PM2] To setup the Startup Script, copy/paste the following command:\n// highlight-next-line\nsudo env PATH=$PATH:/home/ubuntu/.nvm/versions/node/v16.13.2/bin /home/ubuntu/.nvm/versions/node/v16.13.2/lib/node_modules/pm2/bin/pm2 startup systemd -u ubuntu --hp /home/ubuntu\n```\n\n----------------------------------------\n\nTITLE: Using a RedwoodJS Transformer Directive (`@maskedEmail`) in SDL (GraphQL)\nDESCRIPTION: Demonstrates how to apply the custom transformer directive `@maskedEmail` to the `email` field within the `UserExample` GraphQL type definition. This will trigger the directive's transform logic to modify the resolved email value before it's returned in the GraphQL response.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_9\n\nLANGUAGE: graphql\nCODE:\n```\ntype UserExample {\n  id: Int!\n  email: String! @maskedEmail # 👈 will replace alphanumeric characters with asterisks in the response!\n  name: String\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Article Page and Route using RedwoodJS CLI (Bash)\nDESCRIPTION: This command uses the RedwoodJS CLI (`rw`) to generate a new page named 'Article'. This typically creates the page component, route definition, and potentially associated test files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g page Article\n```\n\n----------------------------------------\n\nTITLE: Expected curl Output for Restricted POST Request (Bash/HTTP Headers)\nDESCRIPTION: Shows the expected HTTP response headers when sending a POST request to the `serverTime` endpoint after implementing method restriction. The `HTTP/1.1 404 Not Found` status line confirms that the function correctly blocked the non-GET request, as intended.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nHTTP/1.1 404 Not Found\nX-Powered-By: Express\nDate: Thu, 07 May 2020 22:33:55 GMT\nConnection: keep-alive\nContent-Length: 0\n```\n\n----------------------------------------\n\nTITLE: Defining a Standard Cell Mock in RedwoodJS (JavaScript/JSX)\nDESCRIPTION: This snippet shows the basic structure of a `.mocks.js` file generated alongside a RedwoodJS Cell. It exports a `standard` function that returns the mock data intended to simulate the result of the Cell's GraphQL QUERY. This `standard` mock has special significance in testing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_37\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticleCell.mocks.js\"\nexport const standard = () => ({\n  article: {\n    __typename: 'Article',\n    id: 42,\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Background Jobs via CLI\nDESCRIPTION: This command generates files for a background job within the `api/src/jobs` directory. It requires the job's name (the 'Job' suffix is automatically added if omitted). Options include forcing overwrite (`--force`), generating TypeScript files (`--typescript`), and generating associated test files (`--tests`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_48\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate job <name>\n```\n\n----------------------------------------\n\nTITLE: Running the RedwoodJS Job Worker - Bash\nDESCRIPTION: This bash command starts RedwoodJS's job worker to process background jobs using the configuration and queue defined earlier. It finds unprocessed jobs in storage (e.g., the database), executes them, and repeats polling at intervals. The process outputs log/debug information as jobs are executed. It is intended to be run in a production or development environment where jobs are scheduled.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs work\n```\n\n----------------------------------------\n\nTITLE: Initializing a Basic RedwoodJS Form Component (TSX)\nDESCRIPTION: This snippet shows the initial setup for a `ContactPage` component in TypeScript (TSX). It imports the `Metadata` component from `@redwoodjs/web` and the `Form` component from `@redwoodjs/forms`, rendering an empty form within the page structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n      // highlight-next-line\n      <Form></Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Navigating and Running Redwood Development Server (Shell)\nDESCRIPTION: This shell sequence changes the current directory to the newly created RedwoodJS project, installs dependencies via Yarn, and then starts the Redwood development server. The development server launches the app at http://localhost:8910. Requires all project dependencies to be successfully installed. Outputs compiled assets and a live development environment with hot reloading.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd my-redwood-project\nyarn install\nyarn redwood dev\n```\n\n----------------------------------------\n\nTITLE: Declarative Page Redirection with <Redirect> Component - RedwoodJS - JavaScript/JSX\nDESCRIPTION: Shows using the <Redirect> component from '@redwoodjs/router' for in-component page redirections, including passing options to control replace behavior in the history stack. Input is the 'to' prop, output is a React component that, when rendered, triggers navigation. Can accept advanced navigation options.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_30\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Redirect, routes } from '@redwoodjs/router'\n\nconst SomePage = () => <Redirect to={routes.home()} />\n```\n\n----------------------------------------\n\nTITLE: Evicting Objects or Fields from Apollo Cache via useCache.evict (TypeScript)\nDESCRIPTION: Demonstrates usage of the evict method from useCache to remove either an entire normalized object or a specific field from the client cache. The example assumes use of the useRegisteredFragment hook to retrieve an object and passes it to evict for removal. Useful for manual cache management on entity updates or deletions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_33\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst Fruit = ({ id }: { id: FragmentIdentifier }) => {\n  const { evict } = useCache()\n  const { data: fruit, complete } = useRegisteredFragment<Fruit>(id)\n\n  evict(fruit)\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing the RedwoodJS NotFoundPage with Tailwind CSS (JSX)\nDESCRIPTION: Presents an example of a customized `NotFoundPage.jsx` styled using Tailwind CSS. This version provides a more user-friendly 404 page with clear messaging and navigation links (Home, Get Help). Requires Tailwind CSS setup in the project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_39\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/NotFoundPage/NotFoundPage.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\nexport default () => (\n  <div className=\"bg-white min-h-full px-4 py-16 sm:px-6 sm:py-24 md:grid md:place-items-center lg:px-8\">\n    <div className=\"max-w-max mx-auto\">\n      <main className=\"sm:flex\">\n        <p className=\"text-4xl font-extrabold text-red-600 sm:text-5xl\">404</p>\n        <div className=\"sm:ml-6\">\n          <div className=\"sm:border-l sm:border-gray-200 sm:pl-6\">\n            <h1 className=\"text-4xl font-extrabold text-gray-900 tracking-tight sm:text-5xl\">\n              Page not found\n            </h1>\n            <p className=\"mt-1 text-base text-gray-500\">\n              Check the URL in the address bar and please try again.\n            </p>\n          </div>\n          <div className=\"mt-10 flex space-x-3 sm:border-l sm:border-transparent sm:pl-6\">\n            <Link\n              to={routes.home()}\n              className=\"inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500\"\n            >\n              Home\n            </Link>\n            <Link\n              to={routes.support()}\n              className=\"inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-red-700 bg-red-100 hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500\"\n            >\n              Get Help\n            </Link>\n          </div>\n        </div>\n      </main>\n    </div>\n  </div>\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Navigating after Sign Out with RedwoodJS Router in JSX\nDESCRIPTION: This final snippet enhances the SignoutBtn by importing RedwoodJS router utilities ('navigate' and 'routes') and, after calling 'logOut', redirects the user to the homepage. This ensures users are not left in a restricted area following sign out. Dependencies include 'src/auth', '@redwoodjs/router', and React. The component handles its own state and does not expect any parameters.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAuth } from 'src/auth'\nimport { navigate, routes } from '@redwoodjs/router'\n\nconst SignoutBtn = () => {\n  const { logOut } = useAuth()\n\n  const onClick = async () => {\n    await logOut()\n    navigate(routes.home())\n  }\n\n  return <button onClick={() => onClick()}>Sign Out</button>\n}\n\nexport default SignoutBtn\n```\n\n----------------------------------------\n\nTITLE: Using Article Component in ArticlesCell Success State (JSX)\nDESCRIPTION: Modifies the `Success` component within `ArticlesCell.jsx` to utilize the reusable `Article` component. It imports `Article` and maps over the fetched `articles` array, rendering an `<Article>` for each item, passing the `article` data and a unique `key` as props.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_29\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport Article from 'src/components/Article'\n\nexport const QUERY = gql`\n  query ArticlesQuery {\n    articles: posts {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({ articles }) => {\n  return (\n    <>\n      {articles.map((article) => (\n        // highlight-next-line\n        <Article key={article.id} article={article} />\n      ))}\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Extending GraphQL Query Fields in Typed RedwoodJS Cell (TypeScript)\nDESCRIPTION: Modifies the typed `QUERY` constant (`TypedDocumentNode`) within `ArticlesCell.tsx`. It adds the `title`, `body`, and `createdAt` fields to the selection set for the `articles` (aliased `posts`) query, ensuring type safety is maintained.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_23\n\nLANGUAGE: tsx\nCODE:\n```\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\n  gql`\n    query ArticlesQuery {\n      articles: posts {\n        id\n        // highlight-start\n        title\n        body\n        createdAt\n        // highlight-end\n      }\n    }\n`\n```\n\n----------------------------------------\n\nTITLE: Setting up RedwoodJS dbAuth Authentication via CLI\nDESCRIPTION: This command uses the RedwoodJS CLI (`yarn rw`) to initiate the setup process for `dbAuth`, Redwood's self-hosted database authentication provider. It installs necessary backend components, generates configuration files, and may prompt for additional options like WebAuthn support.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn rw setup auth dbAuth\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Image Deletion Service in RedwoodJS with Filestack\nDESCRIPTION: Defines the `deleteImage` asynchronous function within a RedwoodJS service (`api/src/services/image/image.ts`). It takes an `id` parameter, retrieves the image record, extracts the Filestack handle from the URL, generates a short-lived security policy using the API key and secret, calls the Filestack API (`client.remove`) to delete the file, and finally removes the image record from the local database using Prisma (`db.image.delete`). Requires `filestack-js`, Prisma Client (`db`), and configured environment variables (`REDWOOD_ENV_FILESTACK_API_KEY`, `REDWOOD_ENV_FILESTACK_SECRET`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as Filestack from 'filestack-js'\n\nexport const deleteImage = async ({ id }) => {\n  const client = Filestack.init(process.env.REDWOOD_ENV_FILESTACK_API_KEY)\n\n  const image = await db.image.findUnique({ where: { id } })\n\n  // The `security.handle` is the unique part of the Filestack file's url.\n  const handle = image.url.split('/').pop()\n\n  const security = Filestack.getSecurity(\n    {\n      // We set `expiry` at `now() + 5 minutes`.\n      expiry: new Date().getTime() + 5 * 60 * 1000,\n      handle,\n      call: ['remove'],\n    },\n    process.env.REDWOOD_ENV_FILESTACK_SECRET\n  )\n\n  await client.remove(handle, security)\n\n  return db.image.delete({ where: { id } })\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Docusaurus Project using npx\nDESCRIPTION: This terminal command uses `npx` to run the `create-docusaurus` package, scaffolding a new Docusaurus project in a subdirectory named `docs` using the 'classic' template. This is the first step in setting up Docusaurus for GraphQL documentation generation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_85\n\nLANGUAGE: terminal\nCODE:\n```\nnpx create-docusaurus@latest docs classic\n```\n\n----------------------------------------\n\nTITLE: Extending User SDL with Email Mutation - TypeScript\nDESCRIPTION: Updates the GraphQL SDL (schema definition language) to include a new mutation named 'emailUser' for sending emails to users. Must be placed in the user's SDL file within the API side. Dependencies: GraphQL module for RedwoodJS; proper import and export syntax. Inputs: user ID as string; Outputs: User type.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nexport const schema = gql`\n  // ...\n\n  type Mutation {\n    // ...\n\n    emailUser(id: String!): User! @requireAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Running a Database Migration with RedwoodJS and Prisma\nDESCRIPTION: Executes a Prisma database migration in the development environment using the Redwood CLI wrapper command `yarn rw prisma migrate dev`. This command analyzes the `schema.prisma` file, compares it to the current database state, generates SQL migration files, and applies the changes. It prompts the user to enter a descriptive name for the migration (e.g., 'create posts'). `rw` is a shorthand for `redwood`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw prisma migrate dev\n\n# ...\n\n? Enter a name for the new migration: › create posts\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Handler Log Output in Bash\nDESCRIPTION: Shows sample log output captured in a Bash terminal, generated by the configured GraphQL handler logger. It includes timestamps, log levels (DEBUG), operation names (`BlogPostQuery`), query variables, and response data, demonstrating the information logged when options like `data`, `operationName`, and `query` are enabled.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_48\n\nLANGUAGE: bash\nCODE:\n```\napi | POST /graphql 200 7.754 ms - 1772\napi | DEBUG [2021-09-29 16:04:09.313 +0000] (graphql-server): GraphQL execution started: BlogPostQuery\napi |     operationName: \"BlogPostQuery\"\napi |     query: {\napi |       \"id\": 3\napi |     }\napi | DEBUG [2021-09-29 16:04:09.321 +0000] (graphql-server): GraphQL execution completed: BlogPostQuery\napi |     data: {\napi |       \"post\": {\napi |         \"id\": 3,\napi |         \"body\": \"Meh waistcoat succulents umami asymmetrical, hoodie post-ironic paleo chillwave tote bag. Trust fund kitsch waistcoat vape, cray offal gochujang food truck cloud bread enamel pin forage. Roof party chambray ugh occupy fam stumptown. Dreamcatcher tousled snackwave, typewriter lyft unicorn pabst portland blue bottle locavore squid PBR&B tattooed.\",\napi |         \"createdAt\": \"2021-09-24T16:51:06.198Z\",\napi |         \"__typename\": \"Post\"\napi |       }\napi |     }\napi |     operationName: \"BlogPostQuery\"\napi |     query: {\napi |       \"id\": 3\napi |     }\napi | POST /graphql 200 9.386 ms - 441\n```\n\n----------------------------------------\n\nTITLE: Configuring Studio GraphiQL Impersonation for DbAuth (TOML)\nDESCRIPTION: Configures RedwoodJS Studio's GraphiQL auth impersonation feature for the DbAuth provider within the `redwood.toml` file. This setup requires a `SESSION_SECRET` environment variable for cookie encryption. The settings specify the authentication provider (`dbAuth`) and the email and userId of the user to impersonate.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/studio.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[studio.graphiql.authImpersonation]\n  authProvider = \"dbAuth\"\n  email = \"user@example.com\"\n  userId = \"1\"\n```\n\n----------------------------------------\n\nTITLE: Initializing Git Repository for the RedwoodJS Project\nDESCRIPTION: These commands initialize a new Git repository in the current directory (`git init`), add all existing files and directories to the staging area (`git add .`), and then create the initial commit with the message 'First commit' (`git commit -m 'First commit'`). This establishes the baseline for version control. Requires Git to be installed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/installation.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit init\ngit add .\ngit commit -m 'First commit'\n```\n\n----------------------------------------\n\nTITLE: Example of Query Cost Calculation for Cost Limit Protection (GraphQL, TypeScript Syntax)\nDESCRIPTION: A simple GraphQL query used for evaluating cost calculation levels under the costLimit Armor plugin. Contains nested object (me) and scalar fields (id, user) inside the profile operation. Serves to demonstrate how the algorithm sums costs for objects and scalars at particular depths, and no dependencies are required beyond GraphQL execution.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_65\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  profile {\n    me {\n      id\n      user\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting API Key for Managed SuperTokens Service - Bash\nDESCRIPTION: Specifies the API key required for connecting to the managed SuperTokens service. Should only be provided when not self-hosting. Place this in the .env file or respective services. Input: API key string. Output: Auth server connects to managed SuperTokens.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supertokens.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nSUPERTOKENS_API_KEY=your-api-key # The value can be omitted when self-hosting Supertokens\n```\n\n----------------------------------------\n\nTITLE: Example Output: Generating a RedwoodJS Model via CLI\nDESCRIPTION: This snippet shows the command-line output when generating a RedwoodRecord model for the 'User' entity defined in `schema.prisma`. It confirms the creation of the model file (`./api/src/models/User.js`) and the update of the models index file (`api/src/models/index.js`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_55\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood generate model User\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood g model User\n✔ Generating model file...\n✔ Successfully wrote file $(./api/src/models/User.js)\n✔ Parsing datamodel, generating api/src/models/index.js...\n\nWrote /Users/rob/Sites/redwoodjs/redwood_record/.redwood/datamodel.json\nWrote /Users/rob/Sites/redwoodjs/redwood_record/api/src/models/index.js\n\n✨ Done in 3.74s.\n```\n\n----------------------------------------\n\nTITLE: Generated Service with Relation Resolver (JSX)\nDESCRIPTION: Shows the corresponding `./api/src/services/users/users.js` file when a relation (like `profile` on `User`) is present. In addition to the `users` query, it exports a `User` object containing a resolver function for the `profile` field. This resolver fetches the related profile for a given user using `db.user.findUnique({ where: { id: root.id } }).profile()`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_83\n\nLANGUAGE: jsx\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const users = () => {\n  return db.user.findMany()\n}\n\nexport const User = {\n  profile: (_obj, { root }) => {\n    db.user.findUnique({ where: { id: root.id } }).profile(),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Database Query for Performance Tracing in RedwoodJS TypeScript\nDESCRIPTION: Shows a typical Prisma database query using `findUnique` within a RedwoodJS service or resolver. This code snippet serves as context for the subsequent tracing log output, illustrating the kind of database operation whose performance might be measured.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_51\n\nLANGUAGE: jsx\nCODE:\n```\nreturn await db.post.findUnique({\n  where: { id },\n})\n```\n\n----------------------------------------\n\nTITLE: Expected curl Output for Allowed GET Request (JSON Response)\nDESCRIPTION: Shows the expected JSON response body when sending a GET request to the `serverTime` endpoint using curl. This output confirms that the function handler successfully processes the GET request and returns the current server time formatted as a JSON object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\"time\":\"2020-05-07T22:36:12.973Z\"}\n```\n\n----------------------------------------\n\nTITLE: Example Output of Successful RedwoodJS Webhook Tests (Bash)\nDESCRIPTION: This Bash snippet shows example console output from successfully running the `updateOrderStatus` test suite using the RedwoodJS test runner (likely Jest or Vitest). It indicates that all defined test scenarios passed, lists each scenario description, provides timing information, and confirms the overall success of the test suite.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n PASS   api  api/src/functions/updateOrderStatus/updateOrderStatus.test.ts (10.3 s)\n  updates an order via a webhook\n    ✓ with a shipped order, updates the status to DELIVERED (549 ms)\n    ✓ with an invalid signature header, the webhook is unauthorized (51 ms)\n    ✓ with the wrong webhook secret the webhook is unauthorized (44 ms)\n    ✓ when the tracking number cannot be found, returns an error (54 ms)\n    ✓ when the order has not yet shipped, returns an error (57 ms)\n    ✓ when the order has already been delivered, returns an error (73 ms)\n\nTest Suites: 1 passed, 1 total\nTests:       6 passed, 6 total\nSnapshots:   0 total\nTime:        10.694 s, estimated 36 s\nRan all test suites matching /updateOrderStatus.test.ts|updateOrderStatus.test.ts|false/i.\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring a RedwoodJS Directive on a GraphQL Field (GraphQL)\nDESCRIPTION: Shows the syntax for applying a custom directive `@myDirective` to a field `name` within a GraphQL type `Bar`. This modifies the field's behavior during GraphQL execution.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\ntype Bar {\n  name: String! @myDirective\n}\n```\n\n----------------------------------------\n\nTITLE: Setting the Test Database URL in Environment File (env)\nDESCRIPTION: Defines TEST_DATABASE_URL in the .env file for a test-specific Postgres database. This is useful for test environments, ensuring tests do not overwrite development data. Follows the same structure and conventions as the main DATABASE_URL.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_9\n\nLANGUAGE: env\nCODE:\n```\nTEST_DATABASE_URL=\"postgresql://postgres@localhost:5432/redwoodblog_test?connection_limit=1\"\n```\n\n----------------------------------------\n\nTITLE: Exposing Delete Comment Mutation in GraphQL SDL (JavaScript)\nDESCRIPTION: This GraphQL SDL snippet updates the `Mutation` type in the JavaScript SDL file (`.sdl.js`) by adding the `deleteComment` mutation. This mutation requires an `id` (Int!) as input and returns the deleted `Comment`. Crucially, it uses the `@requireAuth` directive, indicating that only authenticated users (presumably blog owners/admins) can perform this operation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_9\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.js\"\ntype Mutation {\n  createComment(input: CreateCommentInput!): Comment! @skipAuth\n  // highlight-next-line\n  deleteComment(id: Int!): Comment! @requireAuth\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Excluding .yarn Folder from VSCode File Watcher\nDESCRIPTION: This JSON snippet configures VSCode's `settings.json` to prevent the file watcher from monitoring the `.yarn` directory for changes. Using `files.watcherExclude` can help improve performance by reducing CPU usage, especially for folders with many files or frequent changes, although `.yarn` changes infrequently.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/project-configuration-dev-test-build.mdx#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n  \"files.watcherExclude\": {\n    \"**/.yarn\": true\n  }\n```\n\n----------------------------------------\n\nTITLE: Configuring SESSION_SECRET in .env file\nDESCRIPTION: This snippet shows an example entry in the `.env` file, setting the `SESSION_SECRET` variable. The value should be replaced with the actual secret generated by the `yarn rw g secret` command. This secret is used for encrypting secure cookies required by RedwoodJS's dbAuth.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/06_intermission.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nSESSION_SECRET=JV2kA48ZU4FnLHwqaydy9beJ99qy4VgWXPkvsaw3xE2LGyuSur2dVq2PsPkPfygr\n```\n\n----------------------------------------\n\nTITLE: Linking Article Titles in ArticlesCell Component (TypeScript/TSX)\nDESCRIPTION: Updates the `ArticlesCell.tsx` component to import `Link` and `routes` from `@redwoodjs/router`. It modifies the `Success` component (with TypeScript types) to wrap each article title in a `Link` component, initially pointing to the base `article` route without an ID.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/components/ArticlesCell/ArticlesCell.tsx\"\n// highlight-next-line\nimport { Link, routes } from '@redwoodjs/router'\n\n// QUERY, Loading, Empty and Failure definitions...\n\nexport const Success = ({\n  articles,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\n  return (\n    <>\n      {articles.map((article) => (\n        <article key={article.id}>\n          <header>\n            <h2>\n              // highlight-next-line\n              <Link to={routes.article()}>{article.title}</Link>\n            </h2>\n          </header>\n          <p>{article.body}</p>\n          <div>Posted at: {article.createdAt}</div>\n        </article>\n      ))}\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Prisma Post Model in schema.prisma (Prisma Schema in JavaScript Block)\nDESCRIPTION: This prisma schema block, intended for the 'api/db/schema.prisma' file, defines a 'Post' model for database use. The model includes integer ID (auto-incremented and primary key), string title, string body, and a DateTime field 'createdAt' with a default value of 'now()'. Requires Prisma and Redwood's database setup. Inputs are managed via Prisma migration and generation commands. Outputs the corresponding database table structure after migration. Limitations are that it only defines a single model and must reside in the correct Prisma schema file.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_4\n\nLANGUAGE: prisma\nCODE:\n```\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  body      String\n  createdAt DateTime @default(now())\n}\n```\n\n----------------------------------------\n\nTITLE: Updating WeatherCell GraphQL Query for Zip Lookup - RedwoodJS - JSX\nDESCRIPTION: Modifies the WeatherCell's GraphQL query to use a zip code as input and request additional weather attributes like city, conditions, temperature, and icon. The query is tailored to Redwood's schema, calling 'getWeather' and aliasing the result to 'weather'. Requires a valid GraphQL API endpoint and expects a string 'zip' variable as input, returning formatted weather details matching the API response.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query GetWeatherQuery($zip: String!) {\n    weather: getWeather(zip: $zip) {\n      zip\n      city\n      conditions\n      temp\n      icon\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Fetching a RedwoodJS Function via apiUrl in JavaScript\nDESCRIPTION: Demonstrates the correct method for fetching a custom serverless function from the RedwoodJS frontend. It utilizes the `globalThis.RWJS_API_URL` environment variable, which resolves to the configured `apiUrl`, ensuring requests are properly proxied during development and correctly routed in production, thus avoiding CORS errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst serverTime = await fetch(globalThis.RWJS_API_URL + '/serverTime')\n```\n\n----------------------------------------\n\nTITLE: Enqueueing a Faktory Job During User Signup (JavaScript)\nDESCRIPTION: This snippet demonstrates how to enqueue the 'postSignupTask' Faktory job after a user signup process, using the 'faktory-worker' Node.js client. It connects to the Faktory server, pushes the job with required task arguments, and closes the client connection. This service function expects a standard RedwoodJS service signature and requires access to Faktory connection details in environment variables. Proper error handling and closing of the client are best practices.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/background-worker.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst faktory = require('faktory-worker')\n\nexport const signUp = async ({ input }) => {\n  // Perform all the signup operations, such as creating an entry in the DB and auth provider\n  // ...\n\n  // The, send our task to the Faktory server\n  const client = await faktory.connect()\n  await client.job('postSignupTask', { ...taskArgs }).push()\n  await client.close()\n}\n```\n\n----------------------------------------\n\nTITLE: Testing ArticlesCell Summary Rendering with RedwoodJS (JavaScript)\nDESCRIPTION: This JavaScript test suite verifies the proper rendering of the ArticlesCell component within a RedwoodJS application. It uses '@redwoodjs/testing' for helper functions and mocks from 'ArticlesCell.mock'. Each individual test confirms that the component correctly handles the Loading, Empty, Failure, and Success states. The summary test loops over each article to check for presence of the title, correct truncated summary, absence of the full body, and presence of the ellipsis. Expected inputs are article objects; the output is a series of DOM assertions. Limitations include hardcoded substring truncation for demonstration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// highlight-next-line\nimport { render, screen, within } from '@redwoodjs/testing'\n\nimport { Loading, Empty, Failure, Success } from './ArticlesCell'\nimport { standard } from './ArticlesCell.mock'\n\ndescribe('ArticlesCell', () => {\n  test('Loading renders successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  test('Empty renders successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  test('Failure renders successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  test('Success renders successfully', async () => {\n    const articles = standard().articles\n    render(<Success articles={articles} />)\n\n    // highlight-start\n    articles.forEach((article) => {\n      const truncatedBody = article.body.substring(0, 10)\n      const matchedBody = screen.getByText(truncatedBody, { exact: false })\n      const ellipsis = within(matchedBody).getByText('...', { exact: false })\n\n      expect(screen.getByText(article.title)).toBeInTheDocument()\n      expect(screen.queryByText(article.body)).not.toBeInTheDocument()\n      expect(matchedBody).toBeInTheDocument()\n      expect(ellipsis).toBeInTheDocument()\n    })\n    // highlight-end\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Route Parameters with useParams - RedwoodJS React Hook - JavaScript/JSX\nDESCRIPTION: Demonstrates usage of RedwoodJS's useParams hook to access route parameters from deeply nested components in a React tree. Requires '@redwoodjs/router' as a dependency. 'id' or other route params can be destructured directly from useParams(). No props drilling is required, which simplifies state management for dynamic URL segments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useParams } from '@redwoodjs/router'\n\nconst SomeDeeplyNestedComponent = () => {\n  const { id } = useParams()\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Filestack PickerInline in RedwoodJS ImageForm - JSX\nDESCRIPTION: Implements the ImageForm component that allows users to create and edit images. Integrates Filestack's PickerInline React component, passing the Filestack API key from the environment, to enable uploading images directly from the form. Includes RedwoodJS form controls, error handling, and the file picker. Inputs are validated and form submission is handled via a callback.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\\n  Form,\\n  FormError,\\n  FieldError,\\n  Label,\\n  TextField,\\n  Submit,\\n} from '@redwoodjs/forms'\\nimport { PickerInline } from 'filestack-react'\\n\\nconst formatDatetime = (value) => {\\n  if (value) {\\n    return value.replace(/:\\\\d{2}\\\\.\\\\d{3}\\\\w/, '')\\n  }\\n}\\n\\nconst ImageForm = (props) => {\\n  const onSubmit = (data) => {\\n    props.onSave(data, props?.image?.id)\\n  }\\n\\n  return (\\n    <div className=\\\"rw-form-wrapper\\\">\\n      <Form onSubmit={onSubmit} error={props.error}>\\n        <FormError\\n          error={props.error}\\n          wrapperClassName=\\\"rw-form-error-wrapper\\\"\\n          titleClassName=\\\"rw-form-error-title\\\"\\n          listClassName=\\\"rw-form-error-list\\\"\\n        />\\n\\n        <Label\\n          name=\\\"title\\\"\\n          className=\\\"rw-label\\\"\\n          errorClassName=\\\"rw-label rw-label-error\\\"\\n        >\\n          Title\\n        </Label>\\n        <TextField\\n          name=\\\"title\\\"\\n          defaultValue={props.image?.title}\\n          className=\\\"rw-input\\\"\\n          errorClassName=\\\"rw-input rw-input-error\\\"\\n          validation={{ required: true }}\\n        />\\n\\n        <FieldError name=\\\"title\\\" className=\\\"rw-field-error\\\" />\\n\\n        <PickerInline apikey={process.env.REDWOOD_ENV_FILESTACK_API_KEY} />\\n\\n        <div className=\\\"rw-button-group\\\">\\n          <Submit disabled={props.loading} className=\\\"rw-button rw-button-blue\\\">\\n            Save\\n          </Submit>\\n        </div>\\n      </Form>\\n    </div>\\n  )\\n}\\n\\nexport default ImageForm\n```\n\n----------------------------------------\n\nTITLE: beforeQuery With No Incoming Props, Context Usage (JSX)\nDESCRIPTION: Shows a beforeQuery hook in a Cell using a value from context (e.g., useAuth) instead of component props. This is useful when variable data does not come from parent props, allowing integration with application state or context. Outputs an object with variables containing userId.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n// The Cell will take no props: <Cell />\nexport const beforeQuery = () => {\n  const { currentUser } = useAuth()\n\n  return {\n    variables: { userId: currentUser.id },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Record Attributes using `update()` in JSX\nDESCRIPTION: To update an existing record, first retrieve it (e.g., using `find()`). Then, call the `update()` instance method, passing an object with the attributes to change as the first argument. An optional second argument can forward properties to Prisma's update operation or include `{ throw: true }` to throw an error on failure. The method returns the updated record instance on success, or `false` on failure (if not throwing).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_24\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = await User.find(123)\nawait user.update({ email: 'rob.cameron@redwoodjs.com' })\n// or\nawait user.update({ email: 'rob.cameron@redwoodjs.com' }, { throw: true })\n```\n\n----------------------------------------\n\nTITLE: Signing Up Users Using GoTrue-JS Client in SignupPage - JavaScript\nDESCRIPTION: This version implements actual signup logic: when the form is submitted, client.signup is called with entered email and password. Promises are handled with then/catch; currently, responses and errors are logged to the console. This requires that '@redwoodjs/forms', '@redwoodjs/auth', and GoTrue-JS are all functional and correctly configured. Inputs are email and password, passed into client.signup; users must have a network connection to Netlify Identity backend.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from '@redwoodjs/auth'\n\nconst SignupPage = () => {\n  const { client } = useAuth()\n\n  const onSubmit = (data) => {\n    client\n      .signup(data.email, data.password)\n      .then((res) => console.log(res))\n      .catch((error) => console.log(error))\n  }\n\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form onSubmit={onSubmit}>\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Article Mocks for RedwoodJS Cells (JavaScript)\nDESCRIPTION: Defines a 'standard' mock for the ArticlesCell component, returning an object with an 'articles' array mimicking the shape returned by a GraphQL query. No external dependencies are required, and the mock should live in the component's mock file. Typically, this function is imported in stories and test files to provide predictable mock data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = () => ({\\n  articles: [\\n    {\\n      id: 1,\\n      title: 'First Post',\\n      body: `Neutra tacos hot chicken prism raw denim...`,\\n      createdAt: '2020-01-01T12:34:56Z',\\n    },\\n    {\\n      id: 2,\\n      title: 'Second Post',\\n      body: `Master cleanse gentrify irony put a bird on it...`,\\n      createdAt: '2020-01-01T12:34:56Z',\\n    },\\n  ],\\n})\n```\n\n----------------------------------------\n\nTITLE: Querying Comments with Nested Post Data using GraphQL\nDESCRIPTION: Example GraphQL query (`CommentsQuery`) showing how to fetch a list of comments, including their `id`, `name`, `body`, `createdAt`, and the nested `post` object with its fields (`id`, `title`, `body`, `createdAt`). This illustrates the usage of the `Comment.post` resolver defined in the service.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_13\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql\nquery CommentsQuery {\n  comments {\n    id\n    name\n    body\n    createdAt\n    post {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining the Image Model with Prisma - Prisma\nDESCRIPTION: Creates a Prisma data model for storing uploaded images in the application database. The model Image has an auto-incrementing id, a user-supplied title, and a URL for the uploaded asset. This schema is placed in api/db/schema.prisma and used for generating migrations and CRUD scaffolding.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_3\n\nLANGUAGE: prisma\nCODE:\n```\nmodel Image {\\n  id    Int    @id @default(autoincrement())\\n  title String\\n  url   String\\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Props in RedwoodJS Cell Success Component (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to correctly type and access props within a RedwoodJS Cell's `Success` component. It defines a `Props` interface that extends the standard `CellSuccessProps` (providing types for query results like `article`) and adds the custom `rand` prop with its type (`number`). The component then destructures these typed props for use.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_23\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\ninterface Props\n  extends CellSuccessProps<FindArticleQuery, FindArticleQueryVariables> {\n  rand: number\n}\n\nexport const Success = ({ article, id, rand }: Props) => {\n  // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Article Component with Conditional Comments in RedwoodJS (TSX)\nDESCRIPTION: This TSX code provides TypeScript unit tests for the `Article` component using `@redwoodjs/testing`. It ensures the component correctly renders the full article, a summary view, and checks the conditional display of comments based on the `summary` prop. Mock data from `CommentsCell.mock` is used, and `render`, `screen`, and `waitFor` are employed to handle rendering and asynchronous checks.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\n// title=\"web/src/components/Article/Article.test.tsx\"\n// highlight-start\nimport { render, screen, waitFor } from '@redwoodjs/testing'\n\nimport { standard } from 'src/components/CommentsCell/CommentsCell.mock'\n// highlight-end\n\nimport Article from './Article'\n\nconst ARTICLE = {\n  id: 1,\n  title: 'First post',\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\n  createdAt: new Date().toISOString(),\n}\n\ndescribe('Article', () => {\n  it('renders a blog post', () => {\n    render(<Article article={ARTICLE} />)\n\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(screen.getByText(ARTICLE.body)).toBeInTheDocument()\n  })\n\n  // highlight-start\n  it('renders comments when displaying a full blog post', async () => {\n    const comment = standard().comments[0]\n    render(<Article article={ARTICLE} />)\n\n    await waitFor(() =>\n      expect(screen.getByText(comment.body)).toBeInTheDocument()\n    )\n  })\n  // highlight-end\n\n  it('renders a summary of a blog post', () => {\n    render(<Article article={ARTICLE} summary={true} />)\n\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(\n      screen.getByText(\n        'Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Str...'\n      )\n    ).toBeInTheDocument()\n  })\n\n  // highlight-start\n  it('does not render comments when displaying a summary', async () => {\n    const comment = standard().comments[0]\n    render(<Article article={ARTICLE} summary={true} />)\n\n    await waitFor(() =>\n      expect(screen.queryByText(comment.body)).not.toBeInTheDocument()\n    )\n  })\n  // highlight-end\n})\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Applying Database Migrations with RedwoodJS CLI (Bash)\nDESCRIPTION: This command uses the RedwoodJS CLI (`rw`) to invoke Prisma Migrate. It snapshots the current state of `api/db/schema.prisma`, generates a new migration file containing the necessary SQL to update the database schema, and applies these changes to the development database. Users are prompted to provide a descriptive name for the migration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/getting-dynamic.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Protecting RedwoodJS Route for Multiple Roles (JSX)\nDESCRIPTION: This snippet shows how to use the `PrivateSet` component to protect a route (`/admin/posts/{id:Int}/edit`) for multiple roles ('admin', 'editor', 'publisher'). Users without any of these roles or who are unauthenticated will be redirected to the 'home' page.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route, PrivateSet } from '@redwoodjs/router'\\n\\nconst Routes = () => {\\n  return (\\n    <Router>\\n      <PrivateSet unauthenticated=\"home\" roles={['admin', 'editor', 'publisher']}>\\n        <Route path=\"/admin/posts/{id:Int}/edit\" page={EditPostPage} name=\"editPost\" />\\n      </PrivateSet>\\n    </Router>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Running SDL and CRUD Generators (Bash)\nDESCRIPTION: The command to generate the User SDL and service using RedwoodJS CLI (`yarn rw g sdl User --no-crud`). This prepares backend GraphQL schema files and disables default CRUD operation code generation. Required dependency: RedwoodJS CLI. Inputs are model name and arguments, outputs are created files in the API directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g sdl User --no-crud\n```\n\n----------------------------------------\n\nTITLE: Updating Routes Configuration in Routes.jsx (JavaScript/JSX)\nDESCRIPTION: Modifies the `web/src/Routes.jsx` file to place the previously defined `/article/{id}` route within a `Set` component wrapped by `BlogLayout`. This ensures the article page uses the blog layout.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/Routes.jsx\"\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n        <Route path=\"/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n        <Route path=\"/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n        <Route path=\"/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n        <Route path=\"/posts\" page={PostPostsPage} name=\"posts\" />\n      </Set>\n      <Set wrap={BlogLayout}>\n        // highlight-next-line\n        <Route path=\"/article/{id}\" page={ArticlePage} name=\"article\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Validation Rules with Custom Messages in JSX\nDESCRIPTION: Demonstrates how to apply multiple validation rules (presence, exclusion, length, format) to a single input field ('Name') using the `validate` function. It shows how to provide custom error messages for specific rules like exclusion and length, while using default messages for others by specifying the rule directly (e.g., `presence: true`). The `validate` function takes the input value, the field name, and an object containing the validation configurations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.name, 'Name', {\n  presence: true,\n  exclusion: {\n    in: ['Admin', 'Owner'],\n    message: 'Sorry that name is reserved'\n  },\n  length: {\n    min: 2,\n    max: 255,\n    message: 'Please provide a name at least two characters long, but no more than 255'\n  },\n  format: {\n    pattern: /^[A-Za-z]+$/,\n    message: 'Name can only contain letters'\n  }\n)\n\n```\n\n----------------------------------------\n\nTITLE: Implementing HomePage with SuperTokens SignUp Button - TSX\nDESCRIPTION: Provides an example React functional component (TSX) utilizing the SuperTokens useAuth hook. Demonstrates destructuring of isAuthenticated and signUp, and renders authentication state in a <p> as well as a sign up button. Dependencies: 'src/auth' hook from Redwood's SuperTokens integration. Inputs: user click events, outputs: sign up prompt/redirect and state display. Designed to be placed in web/src/pages/HomePage.tsx.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supertokens.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAuth } from 'src/auth'\n\nconst HomePage = () => {\n  const { isAuthenticated, signUp } = useAuth()\n\n  return (\n    <>\n      {/* MetaTags, h1, paragraphs, etc. */}\n\n      <p>{JSON.stringify({ isAuthenticated })}</p>\n      <button onClick={signUp}>sign up</button>\n    </>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Installing and Running RedwoodJS Data Migrations using CLI\nDESCRIPTION: Provides RedwoodJS CLI commands for installing the data migration feature (`data-migrate install`), applying the initial schema migration (`prisma migrate dev`), generating new data migration files (`generate dataMigration`), and executing pending data migrations (`data-migrate up`). These commands manage the setup and execution lifecycle of data migrations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/data-migrations.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw data-migrate install\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw generate dataMigration copyPreferences\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw data-migrate up\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw data-migrate install\nyarn rw prisma migrate dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw generate dataMigration migrationName\nyarn rw data-migrate up\n```\n\n----------------------------------------\n\nTITLE: Updating JavaScript GraphQL Schema (SDL) for Comments\nDESCRIPTION: Updates the GraphQL schema definition in a JavaScript SDL file (`comments.sdl.js`). It modifies the `comments` query definition to require a non-nullable integer argument `postId: Int!`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_27\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.js\"\ntype Query {\n  // highlight-next-line\n  comments(postId: Int!): [Comment!]! @skipAuth\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Applying TypeScript Types to mockGraphQLQuery using Imported Types\nDESCRIPTION: Demonstrates how to provide explicit TypeScript types for the query result (`UserProfileQuery`) and variables (`UserProfileQueryVariables`) when using `mockGraphQLQuery`. This enhances type safety and autocompletion. Types are imported from the generated `types/graphql`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/mocking-graphql-requests.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { UserProfileQuery, UserProfileQueryVariables } from 'types/graphql'\n\nmockGraphQLQuery<UserProfileQuery, UserProfileQueryVariables>(\n  'UserProfileQuery',\n  {\n    /*... */\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Applying Database Migrations with Prisma - Bash\nDESCRIPTION: Runs a migration to update the database schema according to the current Prisma models. Prompts for a migration name ('add image' in this instance). Requires prior setup of database connection and prisma configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Integrating CommentForm into Article Component (TypeScript)\nDESCRIPTION: This TSX snippet shows the TypeScript version of the `Article` component integrating the `CommentForm` and `CommentsCell`. It imports `CommentForm`, `CommentsCell`, and the `Post` type. The `CommentForm` is rendered conditionally within the full article view, positioned above the comments list.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/Article/Article.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-next-line\nimport CommentForm from 'src/components/CommentForm'\nimport CommentsCell from 'src/components/CommentsCell'\n\nimport type { Post } from 'types/graphql'\n\nconst truncate = (text: string, length: number) => {\n  return text.substring(0, length) + '...'\n}\n\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      {!summary && (\n        // highlight-start\n        <div className=\"mt-12\">\n          <CommentForm />\n          // highlight-end\n          <div className=\"mt-12\">\n            <CommentsCell />\n          </div>\n          // highlight-next-line\n        </div>\n      )}\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\n----------------------------------------\n\nTITLE: Aliasing GraphQL Query Field in RedwoodJS Cell\nDESCRIPTION: Defines a GraphQL query using `gql` where the `posts` field is aliased as `articles`. This allows the data to be accessed via the `articles` key in the consuming component. It fetches only the `id` field initially.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_17\n\nLANGUAGE: graphql\nCODE:\n```\n      // highlight-next-line\n      articles: posts {\n        id\n      }\n    }\n`\n```\n\n----------------------------------------\n\nTITLE: Accessing Props in RedwoodJS Cell Success Component (TypeScript)\nDESCRIPTION: Shows how the typed `Success` component of a RedwoodJS Cell (TypeScript version) can access query data (`article`) and additional props (`id`, `rand`). This requires defining a `Props` interface that extends `CellSuccessProps` to include the types for the extra props.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_23\n\nLANGUAGE: tsx\nCODE:\n```\ninterface Props\n  extends CellSuccessProps<FindArticleQuery, FindArticleQueryVariables> {\n  rand: number\n}\n\nexport const Success = ({ article, id, rand }: Props) => {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Running Prisma Migrate Dev (Bash)\nDESCRIPTION: Executes a RedwoodJS-specific Prisma migration command to update and apply schema changes to the connected Postgres database. Relies on the Prisma, RedwoodJS CLI, and a properly configured .env file. No additional parameters needed; migrations may require schema changes to be staged beforehand.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Example Output: Generating a RedwoodJS Function via CLI\nDESCRIPTION: This snippet shows the typical command-line output produced when successfully generating a RedwoodJS serverless Function named 'user'. It confirms the generation process and lists the specific file created (`./api/src/functions/user.js`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood generate function user\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood g function user\n✔ Generating function files...\n✔ Writing $(./api/src/functions/user.js)...\nDone in 16.04s.\n```\n\n----------------------------------------\n\nTITLE: Rendering a Cell with Props in a Page Component (JSX)\nDESCRIPTION: This JSX code demonstrates usage of a Cell component within a page, passing the numberToShow prop. The BlogPostsCell receives this prop, which can be used by the Cell's query. Dependencies: Cell and component imports, RedwoodJS setup; inputs: numberToShow (integer). The output is a rendered BlogPostsCell component populated with appropriate data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport BlogPostsCell from 'src/components/BlogPostsCell'\n\nconst HomePage = () => {\n  return (\n    <div>\n      <h1>Home</h1>\n      <BlogPostsCell numberToShow={3} />\n    </div>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Testing Comment Component with User Mocks in RedwoodJS (JavaScript)\nDESCRIPTION: This snippet defines Jest test cases for the Comment React component using RedwoodJS testing utilities. It mocks comment data, renders the component, and checks for correct UI output based on user role using mockCurrentUser. Dependencies include @redwoodjs/testing and the Comment component. Key parameters are the COMMENT object, user mock data, and UI text expectations. Inputs are mock comment props and user context, while outputs are assertions about render results. Asynchronous logic is handled with waitFor to address GraphQL user role bootstrapping.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\\nimport { render, screen, waitFor } from '@redwoodjs/testing'\\n\\nimport Comment from './Comment'\\n\\n// highlight-start\\nconst COMMENT = {\\n  name: 'John Doe',\\n  body: 'This is my comment',\\n  createdAt: '2020-01-02T12:34:56Z',\\n}\\n// highlight-end\\n\\ndescribe('Comment', () => {\\n  it('renders successfully', () => {\\n    // highlight-next-line\\n    render(<Comment comment={COMMENT} />)\\n\\n    // highlight-start\\n    expect(screen.getByText(COMMENT.name)).toBeInTheDocument()\\n    expect(screen.getByText(COMMENT.body)).toBeInTheDocument()\\n    // highlight-end\\n    const dateExpect = screen.getByText('2 January 2020')\\n    expect(dateExpect).toBeInTheDocument()\\n    expect(dateExpect.nodeName).toEqual('TIME')\\n    // highlight-next-line\\n    expect(dateExpect).toHaveAttribute('datetime', COMMENT.createdAt)\\n  })\\n\\n  // highlight-start\\n  it('does not render a delete button if user is logged out', async () => {\\n    render(<Comment comment={COMMENT} />)\\n\\n    await waitFor(() =>\\n      expect(screen.queryByText('Delete')).not.toBeInTheDocument()\\n    )\\n  })\\n\\n  it('renders a delete button if the user is a moderator', async () => {\\n    mockCurrentUser({\\n      id: 1,\\n      email: 'moderator@moderator.com',\\n      roles: 'moderator',\\n    })\\n    render(<Comment comment={COMMENT} />)\\n\\n    await waitFor(() => expect(screen.getByText('Delete')).toBeInTheDocument())\\n  })\\n  // highlight-end\\n})\n```\n\n----------------------------------------\n\nTITLE: Retrieve Route Path from Route Map - useRoutePaths - RedwoodJS React Hook - JavaScript/JSX\nDESCRIPTION: Shows how to use the routePaths map obtained from useRoutePaths() to access a route's literal path by name. This method circumvents the need for multiple hook invocations and is particularly helpful when working with many routes in dynamic UI components. Outputs the path for the 'about' route.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\nconst routePaths = useRoutePaths()\n// returns \"/about\"\nconst aboutPath = routePaths.about\n```\n\n----------------------------------------\n\nTITLE: Identifying Type Error in hasRole Function (TypeScript)\nDESCRIPTION: This TypeScript snippet highlights a potential type error within the `hasRole` function located in `api/src/lib/auth.ts`. After modifying the `User` model and `getCurrentUser` function, `currentUser.roles` is now definitively a string, causing TypeScript to flag the `Array.isArray(currentUserRoles)` check and subsequent `.some()` call as problematic because `.some` doesn't exist on type `string` (or `never` if the check logically excludes string types).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const hasRole = (roles: AllowedRoles): boolean => {\n\n  // ...\n\n    } else if (Array.isArray(currentUserRoles)) {\n      // 👇 TypeScript will now be telling you 'some' doesn't exist on type never:\n      // highlight-next-line\n      return currentUserRoles?.some((allowedRole) => roles === allowedRole)\n    }\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Updating Article Component with Summary Feature (JSX)\nDESCRIPTION: This snippet updates the JavaScript `Article` component. It introduces a `truncate` helper function to shorten text and adds a `summary` boolean prop. If `summary` is true, the component displays a truncated version of `article.body` (first 100 characters); otherwise, it shows the full body. The default value for `summary` is false to maintain previous behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-story.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Article/Article.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-start\nconst truncate = (text, length) => {\n  return text.substring(0, length) + '...'\n}\n// highlight-end\n\n// highlight-next-line\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article className=\"mt-10\">\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        // highlight-next-line\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\n----------------------------------------\n\nTITLE: Installing OpenSSL and Cleaning up with APT - Dockerfile\nDESCRIPTION: This instruction installs OpenSSL (required for Prisma and secure networking) via apt-get, and cleans up after installation to keep the resulting image small and secure. Additional commented lines (python3, make, gcc) are provided for developers who might need Python or build tools. This step assumes Debian-based images and network access to official Debian repositories; it does not install secrets or production configuration files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_2\n\nLANGUAGE: Dockerfile\nCODE:\n```\nRUN apt-get update && apt-get install -y \\\n    openssl \\\n    # python3 make gcc \\\n    && rm -rf /var/lib/apt/lists/*\n```\n\n----------------------------------------\n\nTITLE: Custom RedwoodJS Package Setup with NPM Tag and Force - Bash\nDESCRIPTION: This command demonstrates running a RedwoodJS setup package with a specific npm tag (e.g., beta) and the --force flag to skip compatibility checks. The process runs the setup logic for the tagged version of the package, even if it is not officially marked compatible. Requires Yarn and a RedwoodJS project. Outputs and changes depend on the setup script within the package.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_119\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn rw setup package @redwoodjs/setup-example@beta --force\n```\n\n----------------------------------------\n\nTITLE: Upgrading RedwoodJS Project Packages - Bash\nDESCRIPTION: Upgrades all @redwoodjs dependencies in a project to the latest stable or specified release via an interactive CLI. The project must use @redwoodjs packages managed by yarn. Options such as --dry-run or --tag (-t) allow for previewing upgrades or selecting release channels (canary, rc, latest, etc.). Generates updated dependencies and logs results; can be used for both minor and major version jumps.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_136\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood upgrade\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood upgrade -t canary\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood upgrade -t 0.19.3\n```\n\n----------------------------------------\n\nTITLE: Example Failing Test Output\nDESCRIPTION: Shows example output from a Jest test run indicating a failure. The test expected 1 comment but received 2, highlighting the discrepancy before the service logic is updated to filter by postId.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n FAIL   api  api/src/services/comments/comments.test.js\n  • comments › returns all comments\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: 1\n    Received: 2\n```\n```\n\n----------------------------------------\n\nTITLE: Mocking CommentsCell Data for Storybook - JavaScript\nDESCRIPTION: Provides test data to mock the results of the CommentsCell GraphQL query for use in Storybook. Reveals how the 'standard' export returns a comments array mimicking backend responses, enabling UI development in isolation. Required for visualizing states in Storybook before backend implementation exists.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = () => ({\\n  // highlight-start\\n  comments: [\\n    {\\n      id: 1,\\n      name: 'Rob Cameron',\\n      body: 'First comment',\\n      createdAt: '2020-01-02T12:34:56Z',\\n    },\\n    {\\n      id: 2,\\n      name: 'David Price',\\n      body: 'Second comment',\\n      createdAt: '2020-02-03T23:00:00Z',\\n    },\\n  ],\\n  // highlight-end\\n})\n```\n\n----------------------------------------\n\nTITLE: Preparing Contact Page Component for Mutation Call (JSX)\nDESCRIPTION: This incomplete JSX snippet shows the `ContactPage` component after defining the `CREATE_CONTACT` mutation constant and initializing the `useMutation` hook to get the `create` function. It sets the stage for modifying the `onSubmit` handler to invoke `create` with the form data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\nconst ContactPage = () => {\n  const [create] = useMutation(CREATE_CONTACT)\n\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a RedwoodJS Application using Yarn (Shell)\nDESCRIPTION: Creates a new RedwoodJS application named `rw-testing-gh-actions` using `yarn create redwood-app` and changes the current directory into the newly created project folder. Requires Yarn and the RedwoodJS CLI to be installed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn create redwood-app rw-testing-gh-actions\ncd rw-testing-gh-actions\n```\n\n----------------------------------------\n\nTITLE: Migrating Database Schema Using Prisma - Bash\nDESCRIPTION: Runs the Prisma migration command via yarn to update the database schema according to the latest schema.prisma file. Required dependency: yarn, Prisma CLI. Uses migrate dev to perform a development migration, expects the Prisma schema to be up-to-date. If there are existing users without roles, migration will fail without a default.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Redirecting to a Static Path in RedwoodJS Routes - JSX\nDESCRIPTION: This snippet illustrates how to redirect a route to a specific static path, rather than to a named route, by using the redirect prop with a concrete URL. Both the redirecting and target routes must be defined. When the old path matches (/blog/{id}), it redirects directly to the new path (/posts/{id}), automatically transferring the path parameters.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/blog/{id}\" redirect=\"/posts/{id}\" />\n<Route path=\"/posts/{id}\" page=\"PostPage\" name=\"post\" />\n```\n\n----------------------------------------\n\nTITLE: Defining the Initial Comment Component Structure in TypeScript\nDESCRIPTION: This TSX snippet defines the basic structure of the 'Comment' React component using TypeScript. It defines a temporary `Props` interface for the `comment` object (containing `name`, `createdAt`, `body` strings) and uses it to type the component's props. It renders the comment properties within basic HTML elements.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/the-redwood-way.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-start\n// Just a temporary type. We'll replace this later\ninterface Props {\n  comment: {\n    name: string\n    createdAt: string\n    body: string\n  }\n}\n// highlight-end\n\n// highlight-next-line\nconst Comment = ({ comment }: Props) => {\n  return (\n    <div>\n      // highlight-start\n      <h2>{comment.name}</h2>\n      <time dateTime={comment.createdAt}>{comment.createdAt}</time>\n      <p>{comment.body}</p>\n      // highlight-end\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Accessing File Helpers on Query Results for Direct and Relation Fields - RedwoodJS TypeScript\nDESCRIPTION: Demonstrates the correct and incorrect access of result extension helpers like `withSignedUrl()` for collections. Direct model queries provide helper methods, but related model results (e.g., accessed via chained relation resolvers) do not, limiting their applicability. Advises rewriting queries for mass processing of file access helpers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst filesViaRelation = await db.folder\n  .findUnique({ where: { id: root?.id } })\n  .files()\n\nconst filesWhereQuery = await db.file.findMany({\n  where: {\n    folderId: root?.id,\n  },\n})\n\n// 🚫 Will not work, because files accessed via relation\n// highlight-next-line\nreturn filesViaRelation.map((file) => file.withSignedUrl())\n\n// ✅ OK, because direct lookup\n// highlight-next-line\nreturn filesWhereQuery.map((file) => file.withSignedUrl())\n```\n\n----------------------------------------\n\nTITLE: Initializing Article Component Boilerplate in JSX\nDESCRIPTION: This is the default functional React component structure generated by the RedwoodJS CLI for the 'Article' component using JavaScript (JSX), located at `web/src/components/Article/Article.jsx`. It renders a simple div with a heading and a placeholder paragraph indicating its file path.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\nconst Article = () => {\n  return (\n    <div>\n      <h2>{'Article'}</h2>\n      <p>{'Find me in ./web/src/components/Article/Article.jsx'}</p>\n    </div>\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Defining Article Route with Path Parameter (RedwoodJS, JavaScript)\nDESCRIPTION: This route declaration introduces a parameterized route in RedwoodJS for articles, allowing access to individual articles via their IDs. The 'id' segment in curly braces defines the route parameter. This route should be added to the main router component to enable /article/{id} URLs. Requires all related components/pages to be implemented for ArticlePage.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/article/{id}\" page={ArticlePage} name=\"article\" />\n```\n\n----------------------------------------\n\nTITLE: Updating Routes Configuration in Routes.tsx (TypeScript/TSX)\nDESCRIPTION: Modifies the `web/src/Routes.tsx` file to place the previously defined `/article/{id}` route within a `Set` component wrapped by `BlogLayout`. This ensures the article page uses the blog layout in a TypeScript project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/Routes.tsx\"\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n        <Route path=\"/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n        <Route path=\"/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n        <Route path=\"/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n        <Route path=\"/posts\" page={PostPostsPage} name=\"posts\" />\n      </Set>\n      <Set wrap={BlogLayout}>\n        // highlight-next-line\n        <Route path=\"/article/{id}\" page={ArticlePage} name=\"article\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Using Article Summary in ArticlesCell (JSX)\nDESCRIPTION: This JavaScript (JSX) snippet updates the `ArticlesCell` component, which fetches and displays a list of articles using a GraphQL query. In the `Success` component, it now maps over the fetched `articles` and renders the `Article` component for each one, passing the `summary={true}` prop to display the truncated summary view.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-story.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticlesCell/ArticlesCell.jsx\"\nimport Article from 'src/components/Article'\n\nexport const QUERY = gql`\n  query ArticlesQuery {\n    articles: posts {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => <div>Error: {error.message}</div>\n\nexport const Success = ({ articles }) => {\n  return (\n    <div className=\"space-y-10\">\n      {articles.map((article) => (\n        // highlight-next-line\n        <Article article={article} key={article.id} summary={true} />\n      ))}\n    </div>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Disabling File Scalar in GraphQL Handler Configuration - TypeScript\nDESCRIPTION: This TypeScript snippet shows the handler configuration for excluding the File scalar from RedwoodJS's GraphQL schema. By passing includeScalars: { File: false } to the handler, the File scalar is omitted, allowing for custom scalar management. Dependencies are proper handler instantiation and related setup in the codebase. Inputs are the handler options; outputs are a GraphQL API without File scalar; constraints include aligning this setting with the one in redwood.toml.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport const handler = createGraphQLHandler({\n  authDecoder,\n  getCurrentUser,\n  loggerConfig: { logger, options: {} },\n  directives,\n  sdls,\n  services,\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n  // highlight-start\n  includeScalars: {\n    File: false,\n  },\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Blog Layout with RedwoodJS in TypeScript\nDESCRIPTION: This TypeScript layout wraps blog pages, featuring site-wide navigation and header using RedwoodJS's Link and routes. It specifies props type for children via BlogLayoutProps for typed safety. Requires @redwoodjs/router and TypeScript compatibility. Inputs are ReactNode children, and outputs are consistent navigation and header structure across pages. Highlights in comments are demonstrative only and not executed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n\ntype BlogLayoutProps = {\n  children?: React.ReactNode\n}\n\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\n  return (\n    <>\n      <header>\n        // highlight-start\n        <h1>\n          <Link to={routes.home()}>Redwood Blog</Link>\n        </h1>\n        // highlight-end\n        <nav>\n          <ul>\n            // highlight-start\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            // highlight-end\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Formatting Success State in WeatherCell - RedwoodJS - JSX\nDESCRIPTION: Customizes the display of weather results within the WeatherCell's Success component, showing city name, weather icon, temperature in Fahrenheit, and conditions. Relies on the 'weather' object returned from the GraphQL API and outputs nicely formatted content for end-users. This snippet is dependent on the preceding GraphQL query and expects the weather object to have 'city', 'icon', 'temp', and 'conditions' properties.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Success = ({ weather }) => {\n  return (\n    <section>\n      <h1>{weather.city}</h1>\n      <h2>\n        <img src={weather.icon} style={{ maxWidth: '2rem' }} />\n        <span>\n          {weather.temp}°F and {weather.conditions}\n        </span>\n      </h2>\n    </section>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Home Page in RedwoodJS\nDESCRIPTION: Uses the RedwoodJS CLI to generate a basic 'Home' page component and associated route at the root path (`/`). This page can be used to test the Clerk authentication integration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/clerk.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g page Home /\n```\n\n----------------------------------------\n\nTITLE: Configuring CI Workflow for Pull Request Events - GitHub Actions YAML\nDESCRIPTION: This YAML snippet configures a GitHub Actions workflow (ci.yml) to trigger only on pull request events targeting the 'main' branch for a RedwoodJS project. The file removes the 'push' trigger, ensuring tests are automatically executed when a PR is opened or updated. It requires no additional dependencies beyond basic GitHub Actions functionality and expects that automated test scripts are defined. Inputs and outputs are handled via the Actions workflow environment, and no confidential data is referenced directly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_9\n\nLANGUAGE: YAML\nCODE:\n```\nname: Redwood CI for Pull Requests\\n\\non:\\n  pull_request:\\n    branches: ['main']\\n\n```\n\n----------------------------------------\n\nTITLE: Verifying Post Ownership Before Update using Service Composition\nDESCRIPTION: This snippet refines the `updatePost` function by first checking if the user owns the post. It imports `ForbiddenError` from RedwoodJS and makes the function `async`. It calls the `adminPost({ id })` service function (which already includes ownership logic) to retrieve the post. If the post is found (meaning the current user owns it), it proceeds with the `db.post.update` using only the `id` in the `where` clause. Otherwise, it throws a `ForbiddenError`, preventing unauthorized updates.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\n// highlight-next-line\nimport { ForbiddenError } from '@redwoodjs/graphql-server'\n\n// highlight-start\nexport const updatePost = async ({ id, input }) => {\n  if (await adminPost({ id })) {\n    return db.post.update({\n      data: input,\n      where: { id },\n    })\n  } else {\n    throw new ForbiddenError(\"You don't have access to this post\")\n  }\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring an Alternate Homepage Route - JavaScript or TypeScript\nDESCRIPTION: Provides an example of configuring a Route in RedwoodJS to render HomePage at the '/hello' path rather than '/'. This can be adapted for JavaScript or TypeScript environments. Designed to be used in the routes file, this code snippet only covers a single Route declaration. The 'name' prop registers this route with the name 'home' and enables redirecting the homepage to another URL.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/first-page.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/hello\" page={HomePage} name=\"home\" />\n```\n\n----------------------------------------\n\nTITLE: Using Article Summary in ArticlesCell (TSX)\nDESCRIPTION: This TypeScript (TSX) snippet modifies the `ArticlesCell` component. It utilizes generated GraphQL types (`ArticlesQuery`, `ArticlesQueryVariables`) and RedwoodJS Cell types (`CellFailureProps`, `CellSuccessProps`). The key change is within the `Success` component, where it maps over the fetched `articles` and renders the imported `Article` component with the `summary={true}` prop, ensuring that article summaries are displayed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-story.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/ArticlesCell/ArticlesCell.tsx\"\nimport type { ArticlesQuery, ArticlesQueryVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypeDocumentNode,\n} from '@redwoodjs/web'\n\nimport Article from 'src/components/Article'\n\nexport const QUERY: TypeDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\n  gql`\n    query ArticlesQuery {\n      articles: posts {\n        id\n        title\n        body\n        createdAt\n      }\n    }\n  `\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<ArticlesQueryVariables>) => (\n  <div>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  articles,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\n  return (\n    <div className=\"space-y-10\">\n      {articles.map((article) => (\n        // highlight-next-line\n        <Article article={article} key={article.id} summary={true} />\n      ))}\n    </div>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Presenting RedwoodJS Project Directory Structure - TypeScript - Markdown Code Block\nDESCRIPTION: This tree diagram, formatted as a Markdown code block, outlines the RedwoodJS project structure for TypeScript setups. It details the main file differences and extensions (.ts/.tsx) compared to JavaScript, helping developers distinguish between TypeScript- and JavaScript-specific organization. The snippet serves as documentation and onboarding aid and is not intended for code execution.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/file-structure.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```\n├── api\n│   ├── db\n│   │   └── schema.prisma\n│   └── src\n│       ├── directives\n│       │   ├── requireAuth\n│       │   └── skipAuth\n│       ├── functions\n│       │   └── graphql.ts\n│       ├── graphql\n│       ├── lib\n│       │   ├── auth.ts\n│       │   ├── db.ts\n│       │   └── logger.ts\n│       └── services\n│\n├── scripts\n│   └── seed.ts\n│\n└── web\n    ├── public\n    │   ├── favicon.png\n    │   ├── README.md\n    │   └── robots.txt\n    └── src\n        ├── components\n        ├── layouts\n        ├── pages\n        │   ├── FatalErrorPage\n        │   │   └── FatalErrorPage.tsx\n        │   └── NotFoundPage\n        │       └── NotFoundPage.tsx\n        ├── App.tsx\n        ├── entry.client.tsx\n        ├── index.css\n        ├── index.html\n        └── Routes.tsx\n```\n```\n\n----------------------------------------\n\nTITLE: Running as Non-Root User for Security - Dockerfile\nDESCRIPTION: This snippet switches the container user to 'node' (UID 1000), a standard non-root user included in the official Node.js container images. Running as a non-root user is a security best practice recommended by Docker to restrict privileges of running services. No external dependencies are required, and this instruction must come after necessary system package installs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_3\n\nLANGUAGE: Dockerfile\nCODE:\n```\nUSER node\n```\n\n----------------------------------------\n\nTITLE: Installing Specific Node.js Version with nvm\nDESCRIPTION: This command instructs nvm to install a specific version of Node.js. Replace `<version number>` with the desired Node.js version string (e.g., '16.14.0', '18').\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnvm install <version number>\n```\n\n----------------------------------------\n\nTITLE: Asserting Absence of Full Article Body in React Test (JavaScript)\nDESCRIPTION: This test assertion checks that the full body text of the article does not appear in the rendered output, confirming that only the summary/truncated text is visible. It is useful in cases where sensitive or lengthy content should not be exposed. The result is a Jest assertion verifying non-presence.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nexpect(screen.queryByText(article.body)).not.toBeInTheDocument()\n\n```\n\n----------------------------------------\n\nTITLE: Mocking GraphQL Comment Mutation in Storybook (JavaScript)\nDESCRIPTION: Shows how to mock the CreateCommentMutation GraphQL call in Storybook using JavaScript. The 'mockGraphQLMutation' function intercepts the mutation, simulates a server delay, and returns a fabricated comment. This depends on Storybook's mocking utilities and provides control over mutation inputs and response attributes. Inputs are the mutation variables, and outputs are mock comment objects, allowing UI testing for loading and error states.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport CommentForm from './CommentForm'\n\nexport const generated = () => {\n  // highlight-start\n  mockGraphQLMutation('CreateCommentMutation', (variables, { ctx }) => {\n    const id = Math.floor(Math.random() * 1000)\n    ctx.delay(1000)\n\n    return {\n      createComment: {\n        id,\n        name: variables.input.name,\n        body: variables.input.body,\n        createdAt: new Date().toISOString(),\n      },\n    }\n  })\n  // highlight-end\n\n  return <CommentForm />\n}\n\nexport default { title: 'Components/CommentForm' }\n```\n\n----------------------------------------\n\nTITLE: Customizing Prisma Schema Path in redwood.toml - TOML\nDESCRIPTION: Adjusts the [api] section in redwood.toml to set a non-default directory for the Prisma schema (schemaPath). Needed when using Prisma's multi-file schema feature by moving schema.prisma into a subdirectory. Directory value must match your actual schema location.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[api]\n  port = 8911\n  schemaPath = \"./api/db/schema\"\n```\n\n----------------------------------------\n\nTITLE: Running Setup Command for Redwood Background Jobs - Bash\nDESCRIPTION: This command installs the necessary packages and configuration files to enable background jobs processing in a RedwoodJS application. Run this command in your project root after setting up RedwoodJS. Prerequisites include a working RedwoodJS project and Yarn package manager. The command may overwrite files if the --force flag is used. It adds the required configuration for job queues; the input is implicit, as it modifies project files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_115\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup jobs\n```\n\n----------------------------------------\n\nTITLE: Creating a RedwoodJS Project with TypeScript using Yarn\nDESCRIPTION: Initializes a new RedwoodJS application named 'my-redwood-project' with built-in TypeScript support using the `--typescript` flag. This sets up the project with TypeScript configurations and files from the start. Requires Node.js (=20.x) and Yarn (>=1.22.21).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn create redwood-app my-redwood-project --typescript\n```\n\n----------------------------------------\n\nTITLE: Generating a New Page with Redwood CLI (bash)\nDESCRIPTION: This code snippet demonstrates how to generate a new page named 'contact' using the RedwoodJS CLI. Run this command in your project's root directory. No arguments other than the page name are required. The command scaffolds the page component and includes required routing setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g page contact\n```\n\n----------------------------------------\n\nTITLE: Customizing GraphQL Type Generation Naming Convention (YAML)\nDESCRIPTION: This example demonstrates how to customize the behavior of GraphQL Code Generator within a RedwoodJS project by creating a `codegen.yml` file. This specific configuration changes the naming convention for generated type names to uppercase using `change-case-all#upperCase`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/generated-types.md#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nconfig:\n  namingConvention:\n    typeNames: change-case-all#upperCase\n```\n\n----------------------------------------\n\nTITLE: Making Persisted Query Request via HTTP\nDESCRIPTION: This snippet shows the structure of an HTTP request payload when using Trusted Documents (Persisted Queries). Instead of sending the full GraphQL query string, the client sends the `operationName`, `variables`, and an `extensions` object containing `persistedQuery`. This extension includes the `sha256Hash` (`76308e971322b1ece4cdff75185bb61d7139e343`) which the server uses to identify the pre-approved query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_3\n\nLANGUAGE: http\nCODE:\n```\n{\"operationName\":\"FindPosts\",\"variables\":{},\"extensions\":{\"persistedQuery\":{\"version\":1,\"sha256Hash\":\"76308e971322b1ece4cdff75185bb61d7139e343\"}}}\n```\n\n----------------------------------------\n\nTITLE: Testing Link Attributes with getByRole and toHaveAttribute in React Testing Library (JavaScript)\nDESCRIPTION: This snippet demonstrates advanced assertions by capturing the DOM element returned from screen.getByRole and checking its 'href' attribute using toHaveAttribute. The test renders a List with one user, retrieves the link with role 'link' and label matching the user's name, asserts its presence, and then checks the correct href is generated by routes.user. Dependencies include '@redwoodjs/router', '@redwoodjs/testing/web', List component, and a matching routes.user implementation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nimport { routes } from '@redwoodjs/router'\n\nit('renders a link with a name', () => {\n  render(<List data={[{ id: 1, name: 'Rob' }]} />)\n\n  const element = screen.getByRole('link', { name: data.name })\n  expect(element).toBeInTheDocument()\n  expect(element).toHaveAttribute('href', routes.user({ id: data.id }))\n})\n```\n\n----------------------------------------\n\nTITLE: Registering and Using a Fragment with useRegisteredFragment Hook - RedwoodJS with Apollo - TypeScript\nDESCRIPTION: Demonstrates registering a BookInfo fragment and extracting the useRegisteredFragment hook. Provides a complete component fetching and rendering book data by id using the Apollo Client cache. The useRegisteredFragment hook delivers live, up-to-date fragment data and a 'complete' boolean indicating availability. Requires @redwoodjs/web/apollo, GraphQL fragment declaration, and React setup. Input: book id; Output: rendered book fields if data is complete.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Book } from 'types/graphql'\\n\\nimport { registerFragment } from '@redwoodjs/web/apollo'\\n\\nconst { useRegisteredFragment } = registerFragment(\\n  gql`\\n    fragment BookInfo on Book {\\n      id\\n      title\\n      author\\n      publicationYear\\n    }\\n  `\\n)\\n\\nconst Book = ({ id }: { id: string }) => {\\n  const { data, complete } = useRegisteredFragment<Book>(id)\\n\\n  return (\\n    complete && (\\n      <div key={`book-id-${id}`}>\\n        <h3>Title: {data.title}</h3>\\n        <p>by {data.author} ({data.publicationYear})<>\\n      </div>\\n    )\\n  )\\n}\\n\\nexport default Book\\n\n```\n\n----------------------------------------\n\nTITLE: Importing useForm with RedwoodJS Forms (TypeScript)\nDESCRIPTION: Imports the useForm hook and associated RedwoodJS form components for establishing typed form state management in the ContactPage. This prepares the file to call useForm within a TypeScript environment, supporting enhanced form control and type safety. No runtime logic occurs here; it is a preparatory step for subsequent form logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_31\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  FieldError,\n  Form,\n  FormError,\n  Label,\n  Submit,\n  TextAreaField,\n  TextField,\n  // highlight-next-line\n  useForm,\n} from '@redwoodjs/forms'\n\n```\n\n----------------------------------------\n\nTITLE: Generating Pages with RedwoodJS CLI - Bash\nDESCRIPTION: This snippet shows how to generate a page component and optionally specify a path using the RedwoodJS CLI. It updates routing and creates related test and storybook files. Requires the 'yarn' package manager and a RedwoodJS project setup; supports options for TypeScript, tests, stories, and rollback. Key parameters are 'name' (page name) and 'path' (URL path, optionally with route params). The output is a set of new files, and updated routing, or overwritten files if '--force' is used.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_56\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate page < name > [path]\n```\n\n----------------------------------------\n\nTITLE: Pushing Prisma Schema Changes to Database (Bash)\nDESCRIPTION: Applies changes made in the `schema.prisma` file directly to the database schema without creating a migration file. This command is useful for prototyping and iterative development, as it also handles running `prisma generate` automatically.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_98\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood prisma db push\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Layout Components via CLI\nDESCRIPTION: This command generates a layout component within the `web/src/layouts` directory. Layouts are used to wrap page components for shared structure and styling. It requires the layout's name. Options allow forcing overwrite (`--force`), generating TypeScript (`--typescript`), generating tests (`--tests`) and Storybook files (`--stories`), adding a skip link (`--skipLink`), and rolling back on error (`--rollback`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_50\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate layout <name>\n```\n\n----------------------------------------\n\nTITLE: Implementing RedwoodJS ArticlesCell with Aliased Query (JavaScript)\nDESCRIPTION: Demonstrates the full implementation of a RedwoodJS Cell (`ArticlesCell.jsx`). It includes the `QUERY` constant with the `articles: posts` alias, standard `Loading`, `Empty`, and `Failure` states, and an updated `Success` component that receives and maps over the `articles` array to render list items.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query ArticlesQuery {\n    // highlight-next-line\n    articles: posts {\n      id\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\n// highlight-next-line\nexport const Success = ({ articles }) => {\n  return (\n    <ul>\n      // highlight-next-line\n      {articles.map((item) => {\n        return <li key={item.id}>{JSON.stringify(item)}</li>\n      })}\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Form Submission with RedwoodJS in JavaScript\nDESCRIPTION: Shows how to implement a contact form with an onSubmit handler using RedwoodJS form helpers in JavaScript. It demonstrates collecting input from a single field and printing the result to the console, requiring @redwoodjs/web and @redwoodjs/forms as dependencies. The handler receives all submitted field values as an object; output is displayed in browser developer tools upon form submission. This basic setup is extensible and intended for simple form capture.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\nimport { Form, TextField, Submit } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  // highlight-start\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n  // highlight-end\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      // highlight-next-line\n      <Form onSubmit={onSubmit}>\n        <TextField name=\"input\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Testing Moderator-Only Deletion and Auth Scenarios for Comments - RedwoodJS - JavaScript\nDESCRIPTION: This JavaScript test suite (Jest) validates authentication and role checking for the deleteComment service. It uses mockCurrentUser to simulate users with and without the moderator role, ensuring only authorized users can delete comments and that appropriate errors are thrown for invalid roles or unauthenticated users. Dependencies include RedwoodJS test libraries, AuthenticationError and ForbiddenError, and db access. The suite checks retrieval, creation, deletion, and error responses for comment operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_32\n\nLANGUAGE: javascript\nCODE:\n```\n// highlight-next-line\nimport { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\n\nimport { db } from 'src/lib/db'\n\n// highlight-next-line\nimport { comments, createComment, deleteComment } from './comments'\n\ndescribe('comments', () => {\n  scenario(\n    'returns all comments for a single post from the database',\n    async (scenario) => {\n      const result = await comments({ postId: scenario.comment.jane.postId })\n      const post = await db.post.findUnique({\n        where: { id: scenario.comment.jane.postId },\n        include: { comments: true },\n      })\n      expect(result.length).toEqual(post.comments.length)\n    }\n  )\n\n  scenario('postOnly', 'creates a new comment', async (scenario) => {\n    const comment = await createComment({\n      input: {\n        name: 'Billy Bob',\n        body: 'What is your favorite tree bark?',\n        postId: scenario.post.bark.id,\n      },\n    })\n\n    expect(comment.name).toEqual('Billy Bob')\n    expect(comment.body).toEqual('What is your favorite tree bark?')\n    expect(comment.postId).toEqual(scenario.post.bark.id)\n    expect(comment.createdAt).not.toEqual(null)\n  })\n\n  // highlight-start\n  scenario('allows a moderator to delete a comment', async (scenario) => {\n    mockCurrentUser({ roles: ['moderator'] })\n\n    const comment = await deleteComment({\n      id: scenario.comment.jane.id,\n    })\n    expect(comment.id).toEqual(scenario.comment.jane.id)\n\n    const result = await comments({ postId: scenario.comment.jane.postId })\n    expect(result.length).toEqual(0)\n  })\n\n  scenario(\n    'does not allow a non-moderator to delete a comment',\n    async (scenario) => {\n      mockCurrentUser({ roles: 'user' })\n\n      expect(() =>\n        deleteComment({\n          id: scenario.comment.jane.id,\n        })\n      ).toThrow(ForbiddenError)\n    }\n  )\n\n  scenario(\n    'does not allow a logged out user to delete a comment',\n    async (scenario) => {\n      mockCurrentUser(null)\n\n      expect(() =>\n        deleteComment({\n          id: scenario.comment.jane.id,\n        })\n      ).toThrow(AuthenticationError)\n    }\n  )\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Preemptive Validation Check with `isValid` Property (JavaScript/JSX)\nDESCRIPTION: JavaScript/JSX code showing how to use the synchronous `isValid` property on a RedwoodRecord instance (`User`) to trigger validations defined on the model *before* attempting to save. If `isValid` evaluates to false, the `errors` object will be populated with specific validation messages.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = User.build({ name: 'Rob Cameron' })\nuser.isValid // => false\nuser.errors.email // => ['must be formatted like an email address']\n```\n\n----------------------------------------\n\nTITLE: Updating RedwoodJS Routes for Admin Section in JavaScript\nDESCRIPTION: This snippet modifies the `Routes.jsx` file in a RedwoodJS application. It moves the routes for creating, editing, viewing, and listing posts under the `/admin` path prefix using a `Set` component, organizing administrative functionality. It utilizes the `Router`, `Route`, and `Set` components from `@redwoodjs/router` and assumes corresponding page components exist.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/Routes.jsx\"\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n        // highlight-start\n        <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n        <Route path=\"/admin/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n        <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n        <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\n        // highlight-end\n      </Set>\n      <Set wrap={BlogLayout}>\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n```\n\n----------------------------------------\n\nTITLE: Running Prisma Database Migrations in Redwood - Shell\nDESCRIPTION: This shell command invokes the Redwood CLI to perform database schema migrations using Prisma. It applies the most recent changes defined in the Prisma schema to the database. Dependencies: Prisma configured in the project and access to the deployment database; requires recent changes to 'schema.prisma'. Outputs migration files and updates the connected database accordingly, with no additional input parameters required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/introduction.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw prisma migrate dev # creates and applies a new Prisma DB migration\n```\n\n----------------------------------------\n\nTITLE: Grouping TypeScript Tests with Shared Scenario Setup - TypeScript\nDESCRIPTION: Demonstrates describeScenario with strong typing (StandardScenario), using beforeEach to retrieve scenario data. Each test mocks authentication and asserts permission logic in user queries. Inputs include user IDs, expected permissions, and error classes. Dependencies: Jest (it, expect), mockCurrentUser helper, user service for queries, and RedwoodJS describeScenario support.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_67\n\nLANGUAGE: ts\nCODE:\n```\n// highlight-next-line\ndescribeScenario<StandardScenario>('user query service', (getScenario) => {\n  let scenario: StandardScenario\n\n  beforeEach(() => {\n    // Grab the scenario before each test\n    // highlight-next-line\n    scenario = getScenario()\n  })\n\n  it('retrieves a single user for a validated user', async () => {\n    mockCurrentUser({ id: 123, name: 'Admin' })\n\n    const record = await user({ id: scenario.user.dom.id })\n\n    expect(record.id).toEqual(scenario.user.dom.id)\n  })\n\n  it('throws an error upon an invalid user id', async () => {\n    mockCurrentUser({ id: 123, name: 'Admin' })\n\n    const fcn = async () => await user({ id: null as unknown as number })\n\n    await expect(fcn).rejects.toThrow()\n  })\n\n  it('throws an error if not authenticated', async () => {\n    const fcn = async () => await user({ id: scenario.user.dom.id })\n\n    await expect(fcn).rejects.toThrow(AuthenticationError)\n  })\n\n  it('throws an error if the user is not authorized to query the user', async () => {\n    mockCurrentUser({ id: 999, name: 'BaseLevelUser' })\n\n    const fcn = async () => await user({ id: scenario.user.dom.id })\n\n    await expect(fcn).rejects.toThrow(ForbiddenError)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Wrapping Routes with BlogLayout in RedwoodJS (JavaScript)\nDESCRIPTION: Configures RedwoodJS routing in JavaScript to use BlogLayout for multiple pages by wrapping them in a Set with the wrap prop. The routes file imports Router, Route, Set from @redwoodjs/router and BlogLayout from the src alias, simplifying imports. Routes for /about and / are wrapped with BlogLayout to apply shared UI. Requires @redwoodjs/router and correct file paths for layout and pages.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-start\\nimport { Router, Route, Set } from '@redwoodjs/router'\\nimport BlogLayout from 'src/layouts/BlogLayout'\\n// highlight-end\\n\\nconst Routes = () => {\\n  return (\\n    <Router>\\n      // highlight-start\\n      <Set wrap={BlogLayout}>\\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\\n        <Route path=\"/\" page={HomePage} name=\"home\" />\\n      </Set>\\n      // highlight-end\\n      <Route notfound page={NotFoundPage} />\\n    </Router>\\n  )\\n}\\n\\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Running Initial RedwoodJS Database Migration (Bash)\nDESCRIPTION: This command executes the initial database migration using the RedwoodJS CLI and Prisma. Seeds are automatically run the first time this command is executed against a database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/database-seeds.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Generating Signin Page with Redwood CLI - Bash\nDESCRIPTION: This command uses the RedwoodJS CLI to scaffold a Signin page component, creating necessary files and adding the route. It extends the routes file and creates a new page for user sign in interface. Requires RedwoodJS CLI and project context; outputs newly generated components and route changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate page Signin\n```\n\n----------------------------------------\n\nTITLE: Setting Up UI Library Configuration for RedwoodJS - Bash\nDESCRIPTION: This command scaffolds the necessary configuration files for a supported UI library (TailwindCSS, Chakra UI, or Mantine UI) in a RedwoodJS project. The user provides the library choice as a command argument. The process handles dependency installation and sets up or updates configuration files, with the option to force overwrites. Prerequisites are a working RedwoodJS project and package manager.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_129\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup ui <library>\n```\n\n----------------------------------------\n\nTITLE: Initializing useForm in RedwoodJS Component (JS)\nDESCRIPTION: Demonstrates calling the imported `useForm` hook inside the `ContactPage` functional component in JavaScript (`.jsx`). This initializes React Hook Form and returns the `formMethods` object, which contains functions (like `reset`) and state for managing the form.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_35\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nconst ContactPage = () => {\n  // highlight-next-line\n  const formMethods = useForm()\n  //...\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Global Layout with RedwoodJS CLI (bash)\nDESCRIPTION: This bash command uses the RedwoodJS CLI to scaffold a Global layout component intended for consistent application structure. It should be executed inside a RedwoodJS project and prepares for layout components that can wrap other page content.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate layout Global\n```\n\n----------------------------------------\n\nTITLE: Defining Database Schema with Prisma - Prisma\nDESCRIPTION: This snippet outlines a Prisma schema file that defines a PostgreSQL datasource and a Prisma client generator, as well as a \"Testimonial\" data model. It requires installation of Prisma and a configured DATABASE_URL environment variable. The model includes fields for an auto-incremented id, a unique author, a quote, and automatic timestamps. This schema ensures that each testimonial is uniquely identified and timestamped, ready for automated migration and query via Prisma Client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/02_chapter0/what-is-redwood.md#_snippet_2\n\nLANGUAGE: prisma\nCODE:\n```\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = \"native\"\n}\n\nmodel Testimonial {\n  id        Int       @id @default(autoincrement())\n  author    String    @unique\n  quote     String\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n}\n\n```\n\n----------------------------------------\n\nTITLE: Fetch Route Parameters from Database for Prerendering (JavaScript with Prisma)\nDESCRIPTION: Exports an async routeParameters function that queries the database for blog post IDs via Prisma ORM, enabling prerender generation for the first N posts. Requires access to the API database instance (import { db } from '$api/src/lib/db'). The function returns an array of parameter objects for each post to prerender.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_8\n\nLANGUAGE: js\nCODE:\n```\nimport { db } from '$api/src/lib/db'\n\nexport async function routeParameters() {\n  return (await db.post.findMany({ take: 7 })).map((post) => ({ id: post.id }))\n}\n```\n\n----------------------------------------\n\nTITLE: Seeding User and Role Data for Database RBAC in RedwoodJS (JavaScript)\nDESCRIPTION: Provides an example script using Prisma Client (`db`) to seed the database with user and role information. It first creates a `User` record using a `uuid` (typically obtained from an identity provider) and then creates a `UserRole` record (e.g., 'editor'), connecting it to the newly created user via their `uuid`. This populates the database for role retrieval.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst uuid = '1683d760-5b4d-2ced-a078-23fdfebe2e19'\n\nconst newUser = await db.user.create({\n  data: { uuid },\n})\n\nconst userRole = await db.userRole.create({\n  data: {\n    name: 'editor',\n    user: {\n      connect: { uuid },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Up TypeScript in an Existing RedwoodJS Project - Shell\nDESCRIPTION: This shell command adds TypeScript configuration files to an existing RedwoodJS project. By running 'yarn rw setup tsconfig', relevant tsconfig.json files are created in the API and web sides of the project, enabling TypeScript support. No parameters are required; after completion, you may remove any old jsconfig.json files. This step is part of incrementally migrating from JavaScript to TypeScript.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/introduction.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup tsconfig\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Mode in tsconfig.json (JSON)\nDESCRIPTION: This JSON snippet shows how to enable TypeScript's strict mode by setting the `strict` compiler option to `true` within the `compilerOptions` section of `web/tsconfig.json`, `api/tsconfig.json`, and potentially `scripts/tsconfig.json` in a RedwoodJS project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"noEmit\": true,\n    \"allowJs\": true,\n    // highlight-next-line\n    \"strict\": true\n    // ...\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ArticlesCell Component with Aliased Query in JavaScript (JSX)\nDESCRIPTION: This JSX snippet shows the complete definition of the `ArticlesCell.jsx` component. It includes the GraphQL `QUERY` with the 'posts' field aliased to 'articles', standard RedwoodJS Cell exports for Loading, Empty, and Failure states, and a Success component that receives and maps over the `articles` prop to render a list.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query ArticlesQuery {\n    // highlight-next-line\n    articles: posts {\n      id\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\n// highlight-next-line\nexport const Success = ({ articles }) => {\n  return (\n    <ul>\n      // highlight-next-line\n      {articles.map((item) => {\n        return <li key={item.id}>{JSON.stringify(item)}</li>\n      })}\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Importing useForm with RedwoodJS Forms (JavaScript)\nDESCRIPTION: Imports the useForm hook along with other RedwoodJS form components for use within the ContactPage component. This setup is a prerequisite for manually initializing form state and enables programmatic control over form operations like resetting. No parameters or configuration are set at this step; the import simply allows later code to reference useForm.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_30\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  FieldError,\n  Form,\n  FormError,\n  Label,\n  Submit,\n  TextAreaField,\n  TextField,\n  // highlight-next-line\n  useForm,\n} from '@redwoodjs/forms'\n\n```\n\n----------------------------------------\n\nTITLE: Example Output for Setting Up Realtime Features in RedwoodJS - Bash\nDESCRIPTION: This output details the sequence of tasks completed by the realtime setup, confirming environment checks, package additions, creation of the API library, and generation of example code. It also indicates generation of TypeScript types if relevant. Presented to the user after running the realtime setup command.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_126\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn rw setup realtime\\n\\u2714 Checking for realtime environment prerequisites ...\\n\\u2714 Adding required api packages...\\n\\u2714 Adding the realtime api lib ...\\n\\u2714 Adding Countdown example subscription ...\\n\\u2714 Adding NewMessage example subscription ...\\n\\u2714 Adding Auctions example live query ...\\n\\u2714 Generating types ...\n```\n\n----------------------------------------\n\nTITLE: Initializing RedwoodJS Project (JavaScript) with Yarn\nDESCRIPTION: This command uses Yarn's 'create' command to scaffold a new RedwoodJS application named 'redwoodblog' in the current directory, configured for JavaScript. It requires Yarn to be installed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/installation.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn create redwood-app ./redwoodblog\n```\n\n----------------------------------------\n\nTITLE: Handling Async Authentication in Sign In Form with RedwoodJS Auth in JSX\nDESCRIPTION: This upgrade to the SigninPage's 'onSubmit' handler implements asynchronous sign in using the 'logIn' method from RedwoodJS Auth. On submit, it awaits 'logIn' with an object containing 'email' and 'password'. On error, it sets the error message in state. Dependencies include '@redwoodjs/forms', 'src/auth', and React. Inputs come from the form fields, and successful login handling is left to the developer.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from 'src/auth'\n\nconst SigninPage = () => {\n  const { logIn } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = async (data) => {\n    setError(null)\n    try {\n      const response = await logIn({ email: data.email, password: data.password })\n      // do something\n    } catch(error) {\n      setError(error.message)\n    }\n  }\n\n  return (\n    <>\n      <h1>Sign In</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign In</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SigninPage\n```\n\n----------------------------------------\n\nTITLE: Redirecting Routes While Passing Parameters in RedwoodJS - JSX\nDESCRIPTION: This snippet shows how to define a redirect route in RedwoodJS by mapping an old URL pattern to a new page route. The first Route redirects requests matching '/blog/{id}' to a route named 'post', while the second Route provides the actual page component and name mapping. Both dynamic path parameters and page rendering are handled automatically. Requires two routes: one with redirect prop and one with page prop and name.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/blog/{id}\" redirect=\"post\" />\n<Route path=\"/posts/{id}\" page=\"PostPage\" name=\"post\" />\n```\n\n----------------------------------------\n\nTITLE: Fetching Authenticated GitHub User Details (JavaScript)\nDESCRIPTION: Extends the callback to fetch user information from the GitHub API using the OAuth access token. Utilizes a helper (getProviderUser) that sends an authenticated GET request to https://api.github.com/user, parsing and returning user info. Performs error handling, returning a 500 error and message if the user fetch fails. Inputs are query string “code” and ENV credentials; outputs are full GitHub user profile in JSON or an error message.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst callback = async (event) => {\n  const { code } = event.queryStringParameters\n\n  const response = await fetch(`https://github.com/login/oauth/access_token`, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      client_id: process.env.GITHUB_OAUTH_CLIENT_ID,\n      client_secret: process.env.GITHUB_OAUTH_CLIENT_SECRET,\n      redirect_uri: process.env.GITHUB_OAUTH_REDIRECT_URI,\n      code,\n    }),\n  })\n\n  const { access_token, scope, error } = JSON.parse(await response.text())\n\n  if (error) {\n    return { statuscode: 400, body: error }\n  }\n\n  // highlight-start\n  try {\n    const providerUser = await getProviderUser(access_token)\n    return {\n      body: JSON.stringify(providerUser),\n    }\n  } catch (e) {\n    return { statuscode: 500, body: e.message }\n  }\n  // highlight-end\n}\n\n// highlight-start\nconst getProviderUser = async (token) => {\n  const response = await fetch('https://api.github.com/user', {\n    headers: { Authorization: `Bearer ${token}` },\n  })\n  const body = JSON.parse(await response.text())\n\n  return body\n}\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Dynamically Mocking Data Based on GraphQL Query Variables - RedwoodJS Storybook - JavaScript\nDESCRIPTION: This snippet shows how to mock a Cell query response dynamically by exporting a function for `standard` that receives the query variables as the first argument. The returned mock-data incorporates the variable (e.g., `size`) into the mocked profile image URL. Dependencies: Storybook, RedwoodJS Cells. Inputs: query variables; outputs: customized mock response per variables.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/mocking-graphql-in-storybook.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nexport const standard = (variables) => {\n  return {\n    userProfile: {\n      id: 42,\n      name: 'peterp',\n      profileImage: `https://example.com/profile.png?size=${variables.size}`,\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Redwood Dev Server with Forwarded Force Flag - Shell\nDESCRIPTION: This shell command starts the RedwoodJS development server while forwarding the `--force` flag to Vite via the `--fwd` option. This causes Vite to re-optimize dependencies. It is useful for debugging or updating the dependency graph. Input is the specified `--fwd` argument, output is a dev server instance with forced optimization.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/vite-configuration.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nyarn rw dev --fwd=\"--force\"\n```\n\n----------------------------------------\n\nTITLE: Generating Title Tags with Metadata Component in JSX\nDESCRIPTION: Demonstrates how providing a `title` prop to the `<Metadata>` component automatically generates both an HTML `<title>` tag and a `<meta name=\"title\">` tag with the specified content.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata title=\"My Website\" />\n// generates\n<title>My Website</title>\n<meta name=\"title\" content=\"My Website\" />\n```\n\n----------------------------------------\n\nTITLE: Setting Up Netlify Deploy Configuration for RedwoodJS - Bash\nDESCRIPTION: Executes the RedwoodJS setup command to create a Netlify deployment configuration (netlify.toml) in the project root. This command prepares the project for Netlify's CI/CD pipeline, adding configuration files and scaffolding necessary for serverless deployment. Must be run from the project's root directory and requires Yarn to be installed. Produces configuration files for Netlify; doesn't modify app logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/deployment.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup deploy netlify\n```\n\n----------------------------------------\n\nTITLE: Updating TypeScript Test Assertion for Filtered Comments\nDESCRIPTION: Updates a TypeScript Jest test (`comments.test.ts`) to assert the correct number of comments when filtering by `postId`. It imports the Prisma client (`db`) and the scenario type, fetches the post and its comments via Prisma, and expects the service result length to match the actual comment count on the post.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"api/src/services/comments/comments.test.ts\"\nimport { comments, createComment } from './comments'\n// highlight-next-line\nimport { db } from 'src/lib/db'\n\nimport type { StandardScenario } from './comments.scenarios'\n\ndescribe('comments', () => {\n  scenario('returns all comments', async (scenario) => {\n    const result = await comments({ postId: scenario.comment.jane.postId })\n    // highlight-start\n    const post = await db.post.findUnique({\n      where: { id: scenario.comment.jane.postId },\n      include: { comments: true },\n    })\n    expect(result.length).toEqual(post.comments.length)\n    // highlight-end\n  })\n\n  // ...\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Example Output for Setting Up GraphQL Fragments - Bash\nDESCRIPTION: This output demonstrates the series of steps and successful updates performed by running the GraphQL Fragments setup command in RedwoodJS. It lists configuration updates and file generation results, confirming project state changes for easier developer review. Inputs are the running process, and outputs are shown in terminal.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_121\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn rw setup graphql fragments\\n\\u2714 Update Redwood Project Configuration to enable GraphQL Fragments\\n\\u2714 Generate possibleTypes.ts\\n\\u2714 Import possibleTypes in App.tsx\\n\\u2714 Add possibleTypes to the GraphQL cache config\n```\n\n----------------------------------------\n\nTITLE: Overriding apiGraphQLUrl in redwood.toml - TOML (diff format)\nDESCRIPTION: Illustrates updating the [web] section in redwood.toml to specify a custom GraphQL endpoint independently of apiUrl, using the diff format to show the config change. The apiGraphQLUrl parameter should point to an externally hosted or proxied GraphQL service. Typically used for advanced deployments where GraphQL is not co-located with other API handlers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n [web]\n   apiUrl = \"/.redwood/functions\"\n+  apiGraphQLUrl = \"https://api.coolredwoodapp.com/graphql\"\n```\n\n----------------------------------------\n\nTITLE: Adding jose Dependency with Yarn\nDESCRIPTION: This shell command adds the 'jose' npm package as a dependency to the API workspace. The 'jose' library is required for performing JSON Web Token (JWT) verification within the `authDecoder` function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nyarn workspace api add jose\n```\n\n----------------------------------------\n\nTITLE: Excluding Specific GraphQL Operations from Logging in TypeScript\nDESCRIPTION: Demonstrates using the `excludeOperations` array within `loggerConfig.options` in `createGraphQLHandler` to prevent specific GraphQL operations, identified by their names (e.g., 'IntrospectionQuery'), from being logged. This is useful for filtering noise like schema introspection requests from GraphQL playgrounds. Requires a `logger` instance.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_43\n\nLANGUAGE: jsx\nCODE:\n```\nexport const handler = createGraphQLHandler({\n  loggerConfig: {\n    logger,\n    options: { excludeOperations: ['IntrospectionQuery'] },\n  },\n  directives,\n  sdls,\n  services,\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Regenerating RedwoodJS SDL without Overwriting Tests (Bash)\nDESCRIPTION: This command regenerates the GraphQL SDL file for a given model, overwriting the existing SDL file using `--force`. Crucially, it uses `--no-tests` to prevent overwriting and potentially losing custom logic within the associated test and scenario files, which is useful when iterating on the data model.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_76\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood g sdl <model> --force --no-tests\n```\n\n----------------------------------------\n\nTITLE: Viewing RedwoodJS Experimental Features Help\nDESCRIPTION: This command displays help information about the available experimental features in RedwoodJS that can be set up or managed using the `experimental` command group. Requires `yarn` and RedwoodJS CLI.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_28\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood experimental --help\n```\n\n----------------------------------------\n\nTITLE: Updating JavaScript Comments Service Test with postId\nDESCRIPTION: Updates a Jest test scenario in JavaScript for the comments service. It modifies the call to the `comments` function to include the `postId` argument, retrieving it from the test scenario data. This change prepares the test for verifying filtered comments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.test.js\"\nscenario('returns all comments', async (scenario) => {\n  // highlight-next-line\n  const result = await comments({ postId: scenario.comment.jane.postId })\n  expect(result.length).toEqual(Object.keys(scenario.comment).length)\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Restoring Public Post Service Implementation for Unrestricted Access (JavaScript)\nDESCRIPTION: This snippet adjusts the posts service to once again return all posts for public queries, removing userId scoping. CRUD functions for create, update, and delete are omitted, and the Post.user relation resolver remains to link each post to its user. These changes associate the service with the public-facing posts SDL, and the exposed queries permit anyone to view posts or a post by id.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const posts = () => {\n  return db.post.findMany()\n}\n\nexport const post = ({ id }) => {\n  return db.post.findUnique({ where: { id } })\n}\n\nexport const Post = {\n  user: (_obj, { root }) =>\n    db.post.findFirst({ where: { id: root.id } }).user(),\n}\n\n```\n\n----------------------------------------\n\nTITLE: Exposing Local RedwoodJS Development Sides via ngrok (Bash)\nDESCRIPTION: These bash commands leverage ngrok to tunnel local RedwoodJS web and api servers to public internet domains. The commands run two ngrok HTTP services: one for port 8910 (web) and another for 8911 (api), providing externally accessible HTTPS endpoints. The responses include ngrok status/info, confirming the public URLs assigned. Prerequisites: a running local server on the referenced ports and a valid ngrok install/account.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cors.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n> ngrok http 8910\\n\\nSession Status  online\\nAccount         Your Name (Plan: Pro)\\nVersion         2.3.40\\nRegion          United States (us)\\nWeb Interface   http://127.0.0.1:4040\\nForwarding      http://3c9913de0c00.ngrok.io -> http://localhost:8910\\nForwarding      https://3c9913de0c00.ngrok.io -> http://localhost:8910\n```\n\nLANGUAGE: bash\nCODE:\n```\n> ngrok http 8911\\n\\nSession Status  online\\nAccount         Your Name (Plan: Pro)\\nVersion         2.3.40\\nRegion          United States (us)\\nWeb Interface   http://127.0.0.1:4040\\nForwarding      http://fb6d701c44b5.ngrok.io -> http://localhost:8911\\nForwarding      https://fb6d701c44b5.ngrok.io -> http://localhost:8911\n```\n\n----------------------------------------\n\nTITLE: Placeholder Auth Provider Client for Custom Integration - TypeScript\nDESCRIPTION: Defines a mock authentication client object for use during initial integration with RedwoodJS. This object includes methods for user login, signup, logout, token retrieval, and metadata fetching, all returning static mock values. Intended as a starting point to be replaced by a real provider SDK. Suitable for prototyping only; should not be used in production, as it lacks any real authentication or error handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAuthentication } from '@redwoodjs/auth'\n\n// ...\n\n// Replace this with the auth service provider client sdk\nconst client = {\n  login: () => ({\n    id: 'unique-user-id',\n    email: 'email@example.com',\n    roles: [],\n  }),\n  signup: () => ({\n    id: 'unique-user-id',\n    email: 'email@example.com',\n    roles: [],\n  }),\n  logout: () => {},\n  getToken: () => 'super-secret-short-lived-token',\n  getUserMetadata: () => ({\n    id: 'unique-user-id',\n    email: 'email@example.com',\n    roles: [],\n  }),\n}\n```\n\n----------------------------------------\n\nTITLE: Destroying RedwoodJS SDL and Service Files (Bash)\nDESCRIPTION: This command removes the GraphQL SDL file and the associated service files (including tests and scenarios) that were previously generated for a specific model.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_78\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood destroy sdl <model>\n```\n\n----------------------------------------\n\nTITLE: Updating Post with Explicit Ownership Verification using Service Function (JavaScript)\nDESCRIPTION: This snippet demonstrates a revised approach for updating a post. It first calls the `adminPost` service function (asynchronously) to retrieve the post, implicitly verifying ownership based on `context.currentUser.id` within `adminPost`. If the post is found (meaning the user owns it), it proceeds with the Prisma `update` using only the `id`. Otherwise, it throws a `ForbiddenError`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/adminPosts/adminPosts.js\"\n// highlight-next-line\nimport { ForbiddenError } from '@redwoodjs/graphql-server'\n\n// highlight-start\nexport const updatePost = async ({ id, input }) => {\n  if (await adminPost({ id })) {\n    return db.post.update({\n      data: input,\n      where: { id },\n    })\n  } else {\n    throw new ForbiddenError(\"You don't have access to this post\")\n  }\n  // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Remove Maintenance Mode After Deploy - Bash\nDESCRIPTION: Restores normal user access by removing the maintenance page and restarting previously stopped services. Typically run after a deployment is complete or as an automatic part of the process.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy baremetal production --maintenance down\n```\n\n----------------------------------------\n\nTITLE: Creating Storybook Stories for Article Component (JSX)\nDESCRIPTION: This snippet defines Storybook stories for the updated JavaScript `Article` component. It creates a constant `ARTICLE` with sample data. Two named exports, `full` and `summary`, render the `Article` component: `full` shows the complete article body (default behavior), and `summary` passes `summary={true}` to display the truncated version.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-story.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/components/Article/Article.stories.jsx\"\nimport Article from './Article'\n\n// highlight-start\nconst ARTICLE = {\n  id: 1,\n  title: 'First Post',\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\n}\n// highlight-end\n\n// highlight-start\nexport const full = () => {\n  return <Article article={ARTICLE} />\n}\n// highlight-end\n\n// highlight-start\nexport const summary = () => {\n  return <Article article={ARTICLE} summary={true} />\n}\n// highlight-end\n\nexport default { title: 'Components/Article' }\n```\n```\n\n----------------------------------------\n\nTITLE: Running Redwood Development Servers - Bash\nDESCRIPTION: Shows the command to start development servers for one or both sides of a Redwood project, with support for forwarding config options to Vite. Dependencies: Redwood CLI, Vite. Parameters: [side..] (optional: ‘api’, ‘web’), --forward/--fwd (Vite config string). Input: Command. Output: Development servers with hot reload, accessible at designated ports. Limitation: Project must be set up for relevant sides.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood dev [side..]\n```\n\n----------------------------------------\n\nTITLE: Displaying an AreaChart on the Dashboard Page (jsx)\nDESCRIPTION: This component renders a basic DashboardPage displaying a responsive area chart with two data series using Tremor and RedwoodJS. It demonstrates importing Tremor UI components, preparing static chart data, formatting values, and arranging layout via Grid and Card components. Dependencies: @tremor/react, @redwoodjs/web, TailwindCSS. Expects chartdata in specified format, no external API integration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Grid, Col, Card, Title, AreaChart } from '@tremor/react'\n\nimport { MetaTags } from '@redwoodjs/web'\n\nconst DashboardPage = () => {\n  const chartdata = [\n    {\n      date: 'Jan 22',\n      SemiAnalysis: 2890,\n      'The Pragmatic Engineer': 2338,\n    },\n    {\n      date: 'Feb 22',\n      SemiAnalysis: 2756,\n      'The Pragmatic Engineer': 2103,\n    },\n    {\n      date: 'Mar 22',\n      SemiAnalysis: 3322,\n      'The Pragmatic Engineer': 2194,\n    },\n    {\n      date: 'Apr 22',\n      SemiAnalysis: 3470,\n      'The Pragmatic Engineer': 2108,\n    },\n    {\n      date: 'May 22',\n      SemiAnalysis: 3475,\n      'The Pragmatic Engineer': 1812,\n    },\n    {\n      date: 'Jun 22',\n      SemiAnalysis: 3129,\n      'The Pragmatic Engineer': 1726,\n    },\n  ]\n\n  const dataFormatter = (number: number) => {\n    return '$ ' + Intl.NumberFormat('us').format(number).toString()\n  }\n\n  return (\n    <div className=\"m-12\">\n      <MetaTags title=\"Dashboard\" description=\"Dashboard page\" />\n\n      <h1 className=\"text-2xl mb-12\">Dashboard</h1>\n\n      <Grid numCols={1} numColsSm={2} numColsLg={3} className=\"my-8 gap-6\">\n        <Col numColSpan={1} numColSpanLg={3}>\n          <Card>\n            <Title>Newsletter revenue over time (USD)</Title>\n            <AreaChart\n              className=\"h-72 mt-4\"\n              data={chartdata}\n              index=\"date\"\n              categories={['SemiAnalysis', 'The Pragmatic Engineer']}\n              colors={['indigo', 'green']}\n              valueFormatter={dataFormatter}\n            />\n          </Card>\n        </Col>\n      </Grid>\n    </div>\n  )\n}\n\nexport default DashboardPage\n```\n\n----------------------------------------\n\nTITLE: Conditionally Rendering Login/Logout UI in RedwoodJS BlogLayout (TypeScript)\nDESCRIPTION: This TypeScript snippet updates the `BlogLayout` component to conditionally render UI elements based on the authentication status obtained from `useAuth`. If `isAuthenticated` is true, it displays the user's email (`currentUser.email`) and a logout button that triggers the `logOut` function. Otherwise, it shows a link to the login route. It includes type definitions for props.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/layouts/BlogLayout/BlogLayout.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\nimport { useAuth } from 'src/auth'\n\ntype BlogLayoutProps = {\n  children?: React.ReactNode\n}\n\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\n  const { isAuthenticated, currentUser, logOut } = useAuth()\n\n  return (\n    <>\n      <header>\n        // highlight-next-line\n        <div className=\"flex-between\">\n          <h1>\n            <Link to={routes.home()}>Redwood Blog</Link>\n          </h1>\n          // highlight-start\n          {isAuthenticated ? (\n            <div>\n              <span>Logged in as {currentUser.email}</span>{' '}\n              <button type=\"button\" onClick={logOut}>\n                Logout\n              </button>\n            </div>\n          ) : (\n            <Link to={routes.login()}>Login</Link>\n          )}\n        </div>\n        // highlight-end\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n            <li>\n              <Link to={routes.contact()}>Contact</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n```\n\n----------------------------------------\n\nTITLE: Using useAuth Hook for Clerk Sign Up in React\nDESCRIPTION: Demonstrates how to use the `useAuth` hook (imported from `src/auth`) within a React component (`HomePage`) to access Clerk authentication functions (`signUp`) and state (`isAuthenticated`). Clicking the button triggers the Clerk sign-up modal.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/clerk.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAuth } from 'src/auth'\n\nconst HomePage = () => {\n  const { isAuthenticated, signUp } = useAuth()\n\n  return (\n    <>\n      {/* MetaTags, h1, paragraphs, etc. */}\n\n      <p>{JSON.stringify({ isAuthenticated })}</p>\n      <button onClick={signUp}>sign up</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Article Component Story - Storybook - JavaScript (JSX)\nDESCRIPTION: This snippet is a Storybook story definition for the Article component using JavaScript and JSX syntax. It imports the Article component and exports a named story 'generated', which renders the component with sample blog post data passed via the article prop. The default export sets the title path for Storybook's hierarchy. No external dependencies besides the local Article component and Storybook itself; the sample data is hardcoded for isolated UI testing in Storybook.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/storybook.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport Article from './Article'\n\nexport const generated = () => {\n  return (\n    <Article\n      article={{\n        id: 1,\n        title: 'First Post',\n        body: `Neutra tacos hot chicken prism raw denim, put\n              a bird on it enamel pin post-ironic vape cred\n              DIY. Street art next level umami squid.\n              Hammock hexagon glossier 8-bit banjo. Neutra\n              la croix mixtape echo park four loko semiotics\n              kitsch forage chambray. Semiotics salvia\n              selfies jianbing hella shaman. Letterpress\n              helvetica vaporware cronut, shaman butcher\n              YOLO poke fixie hoodie gentrify woke\n              heirloom.`,\n        createdAt: '2020-01-01T12:34:45Z'\n      }}\n    />\n  )\n}\n\nexport default { title: 'Components/Article' }\n```\n\n----------------------------------------\n\nTITLE: Testing ArticlesCell Summary Rendering with RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript test suite mirrors the JavaScript version for validating ArticlesCell rendering in RedwoodJS, but provides static type-checking for stricter code and editor support. It imports the same testing helpers, components, and mocks and asserts loading, empty, failure, and success UI states. The success test verifies each article's summary truncation, ensuring the ellipsis appears and the full body is not present. Dependencies include RedwoodJS and DOM Testing Library. Inputs are article mocks, outputs are assertion results; the approach is black box, relying on the rendered UI only.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// highlight-next-line\nimport { render, screen, within } from '@redwoodjs/testing'\n\nimport { Loading, Empty, Failure, Success } from './ArticlesCell'\nimport { standard } from './ArticlesCell.mock'\n\ndescribe('ArticlesCell', () => {\n  test('Loading renders successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  test('Empty renders successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  test('Failure renders successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  test('Success renders successfully', async () => {\n    const articles = standard().articles\n    render(<Success articles={articles} />)\n\n    // highlight-start\n    articles.forEach((article) => {\n      const truncatedBody = article.body.substring(0, 10)\n      const matchedBody = screen.getByText(truncatedBody, { exact: false })\n      const ellipsis = within(matchedBody).getByText('...', { exact: false })\n\n      expect(screen.getByText(article.title)).toBeInTheDocument()\n      expect(screen.queryByText(article.body)).not.toBeInTheDocument()\n      expect(matchedBody).toBeInTheDocument()\n      expect(ellipsis).toBeInTheDocument()\n    })\n    // highlight-end\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Redirection on Successful Signup (JSX)\nDESCRIPTION: This final snippet adds navigation logic to the `SignupPage`. It imports `routes` and `navigate` from `@redwoodjs/router`. The `onSubmit` function is updated: after calling `client.auth.signUp`, it checks if `response.error.message` exists. If it does, the error state is set. If it doesn't (indicating success), it uses `navigate(routes.home())` to redirect the user to the application's home page, identified by the named route `routes.home()`. Error handling for caught exceptions remains.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from 'src/auth'\nimport { routes, navigate } from '@redwoodjs/router'\n\nconst SignupPage = () => {\n  const { client } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = async (data) => {\n    setError(null)\n    try {\n      const response = await client.auth.signUp({\n        email: data.email,\n        password: data.password\n      })\n      response?.error?.message ? setError(response.error.message) : navigate(routes.home())\n    } catch(error) {\n      setError(error.message)\n    }\n  }\n\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Adding Navigation to AboutPage Component (TypeScript/JSX)\nDESCRIPTION: This snippet updates the AboutPage functional component in TypeScript (`.tsx`). It adds the same header structure as the HomePage for consistency and includes a paragraph of content. It adds a `<Link>` component using the named route function `routes.home()` for navigation back to the Home page. It also retains the link to the About page itself within the header navigation. This version is functionally identical to the JavaScript example but resides in a `.tsx` file.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/second-page.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <>\n      <Metadata title=\"About\" description=\"About page\" />\n\n      // highlight-start\n      <header>\n        <h1>Redwood Blog</h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>\n        <p>\n          This site was created to demonstrate my mastery of Redwood: Look on my\n          works, ye mighty, and despair!\n        </p>\n        <Link to={routes.home()}>Return home</Link>\n      </main>\n      // highlight-end\n    </>\n  )\n}\n\nexport default AboutPage\n```\n\n----------------------------------------\n\nTITLE: Setting NODE_ENV for Production in Bash\nDESCRIPTION: Demonstrates setting the NODE_ENV environment variable to \\\"production\\\" in a shell or within a .env file. This is necessary for differentiating between development, test, and production environments when running job workers. Used as a shell statement or within deployment scripts or environment files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_37\n\nLANGUAGE: bash\nCODE:\n```\nNODE_ENV=production\n```\n\n----------------------------------------\n\nTITLE: Starting Storybook with Redwood CLI - Shell\nDESCRIPTION: This snippet demonstrates how to launch Storybook in a RedwoodJS project using the designated CLI command. Executing this command will trigger automatic installation of Storybook, the required framework package, and related dependencies if they are not already present. It also sets up necessary configuration files for Storybook integration. The command must be run from the project root. Output will be served locally, typically on port 7910.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/storybook.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw storybook\n```\n\n----------------------------------------\n\nTITLE: Resetting Redwood Form After Mutation Completion (JavaScript)\nDESCRIPTION: Employs formMethods.reset() in the onCompleted callback of the useMutation hook to clear the form after a successful contact mutation. This ensures the form fields are emptied and user feedback is displayed via toast.success. Dependencies include RedwoodJS web toast and forms, and useMutation from the RedwoodJS web module.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_36\n\nLANGUAGE: jsx\nCODE:\n```\n// ...\n\nconst [create, { loading, error }] = useMutation(CREATE_CONTACT, {\n  onCompleted: () => {\n    toast.success('Thank you for your submission!')\n    // highlight-next-line\n    formMethods.reset()\n  },\n})\n\n// ...\n\n```\n\n----------------------------------------\n\nTITLE: Importing and Assigning Generated Possible Types for Apollo Client - RedwoodJS - TypeScript/JSX\nDESCRIPTION: Illustrates how to import auto-generated possibleTypes configuration from the RedwoodJS codegen process and apply it to the Apollo provider config. This supports union/interface fragment use. Requires enabling fragments in project config and running codegen. Inputs: generated possibleTypes module.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\n// web/src/App.tsx\\n\\nimport possibleTypes from 'src/graphql/possibleTypes'\\n\\n// ...\\n\\nconst graphQLClientConfig = {\\n  cacheConfig: {\\n    ...possibleTypes,\\n  },\\n}\\n\\n<RedwoodApolloProvider graphQLClientConfig={graphQLClientConfig}>\\n\n```\n\n----------------------------------------\n\nTITLE: Initializing a New Redwood App via Yarn in Terminal\nDESCRIPTION: Uses the Yarn package manager to execute the `create-redwood-app` scaffolding tool, creating a new RedwoodJS project structure in a directory named `<your-app-name>`. This is the primary command to start a new Redwood project. Requires Node.js and Yarn to be installed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/create-redwood-app.md#_snippet_0\n\nLANGUAGE: terminal\nCODE:\n```\nyarn create redwood-app <your-app-name>\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Route in Routes.jsx (JavaScript/JSX)\nDESCRIPTION: Defines a route for individual articles in `web/src/Routes.jsx`. The path `/article/{id}` includes a route parameter `{id}`, which captures the value from the URL segment. This route maps to the `ArticlePage` component and is named 'article'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/Routes.jsx\"\n<Route path=\"/article/{id}\" page={ArticlePage} name=\"article\" />\n```\n\n----------------------------------------\n\nTITLE: Testing Business Rule: Updating Already Delivered Order in RedwoodJS Webhook (JSX)\nDESCRIPTION: This JSX test scenario verifies a business rule within a RedwoodJS webhook handler: an order that is already 'DELIVERED' cannot be updated to 'DELIVERED' again. It uses scenario data for a delivered order, mocks a signed webhook event attempting the redundant update, invokes the handler, and asserts a 500 status code, the presence of an 'error' property in the response body, and a specific error message. This snippet also closes the `describe` block for the test suite.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\n  scenario('when the order has already been delivered, returns an error',\n            async (scenario) => {\n    const order = scenario.order.delivered\n\n    const payload = { trackingNumber: order.trackingNumber,\n                      status: 'DELIVERED'}\n    const event = mockSignedWebhook({payload,\n                      signatureType: 'sha256Verifier',\n                      signatureHeader: 'X-Webhook-Signature',\n                      secret: 'MY-VOICE-IS-MY-PASSPORT-VERIFY-ME' })\n\n    const result = await handler(event)\n\n    const body = JSON.parse(result.body)\n\n    expect(result.statusCode).toBe(500)\n    expect(body).toHaveProperty('error')\n    expect(body.message).toEqual('Unable to update the order status')\n  })\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Zip Codes in Weather Service - RedwoodJS - JavaScript\nDESCRIPTION: Implements error handling in the getWeather service for API responses indicating an invalid zip code. Checks for 'cod' === '404' in the JSON response, throws a UserInputError with a user-friendly message, and otherwise processes and transforms the weather data for the frontend. Requires '@whatwg-node/fetch', '@redwoodjs/graphql-server', and a valid OpenWeather API key; expects an object with 'zip' as input, outputs formatted weather or throws an error for bad zip inputs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nimport { fetch } from '@whatwg-node/fetch'\nimport { UserInputError } from '@redwoodjs/graphql-server'\n\nexport const getWeather = async ({ zip }) => {\n  const response = await fetch(\n    `http://api.openweathermap.org/data/2.5/weather?zip=${zip},US&appid=YOUR_API_KEY`\n  )\n  const json = await response.json()\n\n  if (json.cod === '404') {\n    throw new UserInputError(\n      `${zip} isn't a valid US zip code, please try again`\n    )\n  }\n\n  return {\n    zip,\n    city: json.name,\n    conditions: json.weather[0].main,\n    temp: Math.round(((json.main.temp - 273.15) * 9) / 5 + 32),\n    icon: `http://openweathermap.org/img/wn/${json.weather[0].icon}@2x.png`,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a Comment in RedwoodJS Service (JavaScript)\nDESCRIPTION: Adds an exported `deleteComment` function to 'api/src/services/comments/comments.js'. This function takes an object containing the `id` of the comment to be deleted and uses `db.comment.delete({ where: { id } })` to remove the corresponding record from the database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.js\"\nexport const deleteComment = ({ id }) => {\n  return db.comment.delete({\n    where: { id },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Custom beforeQuery with Polling and No Cache (JSX)\nDESCRIPTION: This example demonstrates customizing the beforeQuery hook to enable polling (pollInterval: 2500 ms) and disable caching (fetchPolicy: 'no-cache'). Inputs: props (arbitrary); used to modify Apollo Client's query behavior. Useful for scenarios needing live or real-time data updates.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nexport const beforeQuery = (props) => {\n  return { variables: props, fetchPolicy: 'no-cache', pollInterval: 2500 }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing RedwoodJS App and Generating Home Page - Bash\nDESCRIPTION: Shows how to bootstrap a new RedwoodJS app called weatherstation, launch the development server, and scaffold a homepage. Dependencies include Node.js, Yarn, and the redwood-app generator. Each command initializes project structure, runs the dev server at a local port, and generates a new page at the root path. Inputs are commands in the shell, outputs are project files and running local server.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn create redwood-app weatherstation\ncd weatherstation\nyarn rw dev\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw generate page home /\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Project for Netlify Deployment in Bash\nDESCRIPTION: Runs the RedwoodJS setup command to automatically generate the `netlify.toml` configuration file. This file contains build settings, plugin configurations, and redirect rules optimized for deploying a RedwoodJS application on Netlify.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/deployment.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup deploy netlify\n```\n\n----------------------------------------\n\nTITLE: Seeding UserExample Data using Prisma Client (TypeScript)\nDESCRIPTION: Updates the `scripts/seed.ts` file to seed the database with predefined `UserExample` data. It defines an array of user objects and uses Prisma Client's `createMany` method within a `Promise.all` call to efficiently insert multiple records, ensuring duplicate emails are skipped. Requires Prisma Client (`db`) instance and types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n    ...\n\n    const data: Prisma.UserExampleCreateArgs['data'][] = [\n      // To try this example data with the UserExample model in schema.prisma,\n      // uncomment the lines below and run 'yarn rw prisma migrate dev'\n      //\n      { name: 'alice', email: 'alice@example.com' },\n      { name: 'mark', email: 'mark@example.com' },\n      { name: 'jackie', email: 'jackie@example.com' },\n      { name: 'bob', email: 'bob@example.com' },\n    ]\n    console.log(\n      \"\\nUsing the default './scripts/seed.{js,ts}' template\\nEdit the file to add seed data\\n\"\n    )\n\n    // Note: if using PostgreSQL, using `createMany` to insert multiple records is much faster\n    // @see: https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#createmany\n    Promise.all(\n      //\n      // Change to match your data model and seeding needs\n      //\n      data.map(async (data: Prisma.UserExampleCreateArgs['data']) => {\n        const record = await db.userExample.createMany({\n          data,\n          skipDuplicates: true,\n        })\n        console.log(record)\n      })\n    )\n\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing useAuth logOut in Sign Out Button with RedwoodJS in JSX\nDESCRIPTION: This version of SignoutBtn imports and uses 'useAuth' from 'src/auth', destructuring the 'logOut' method. Pressing the button will trigger the logOut call to sign the user out. The only dependencies are 'src/auth' and React. No parameters are required, but navigation away from restricted pages is not yet implemented.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAuth } from 'src/auth'\n\nconst SignoutBtn = () => {\n  const { logOut } = useAuth()\n\n  const onClick = () => {\n    logOut()\n  }\n  return <button onClick={() => onClick()}>Sign Out</button>\n}\n\nexport default SignoutBtn\n```\n\n----------------------------------------\n\nTITLE: Defining a File Path Field in Prisma Schema for RedwoodJS Uploads\nDESCRIPTION: Illustrates how to configure a Prisma model (`Profile`) to store a reference to an uploaded file. Since Prisma does not have a native `File` type, a `String` field (`avatar`) is used to store the file path or URL generated by the storage mechanism. The `?` makes the field optional.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_4\n\nLANGUAGE: prisma\nCODE:\n```\n```prisma title=\"api/db/schema.prisma\"\nmodel Profile {\n  id: Int\n  // ... other fields\n  // highlight-next-line\n  avatar String?\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Generated Service for User Model (JSX)\nDESCRIPTION: Example content of a generated `./api/src/services/users/users.js` file when using `generate sdl`. This service implements the `users` query defined in the SDL, using Prisma Client (`db`) to fetch all user records from the database via `db.user.findMany()`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_81\n\nLANGUAGE: jsx\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const users = () => {\n  return db.user.findMany()\n}\n```\n\n----------------------------------------\n\nTITLE: Running Prisma Migrate Deploy with Redwood CLI (Bash)\nDESCRIPTION: Executes the Prisma `migrate deploy` command within a RedwoodJS project using Yarn. This command applies pending database migrations to update the database schema, typically used in production or staging environments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_105\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood prisma migrate deploy\n```\n\n----------------------------------------\n\nTITLE: Mocking User Roles with mockCurrentUser in RedwoodJS Tests (JSX/JS)\nDESCRIPTION: These lines demonstrate how to use the `mockCurrentUser` function, likely provided by RedwoodJS testing utilities, to simulate different user states for testing purposes. The first call mocks a user with the 'admin' role, while the second mocks a user with no roles, allowing tests for both scenarios in role-checking components.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_29\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\nmockCurrentUser({ roles: ['admin'] })\nmockCurrentUser({ roles: [] })\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Scenario Data for Comment Service - RedwoodJS (TypeScript)\nDESCRIPTION: Defines scenario data for comment service API tests using RedwoodJS in TypeScript. Employs static typing with Prisma models to ensure scenarios match expected shapes and links scenario objects to TypeScript types for strong typing. Both 'standard' and 'postOnly' scenarios are provided, along with type exports for use in tests. Inputs are static scenario definitions; outputs are scenario objects inserted into the database and their respective types. Dependencies: RedwoodJS, Prisma, and appropriate type definitions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_29\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Prisma } from '@prisma/client'\n\nexport const standard = defineScenario<Prisma.CommentCreateArgs>({\n  // ...\n})\n\n// highlight-start\nexport const postOnly = defineScenario<Prisma.PostCreateArgs>({\n  post: {\n    bark: {\n      data: {\n        title: 'Bark',\n        body: \"A tree's bark is worse than its bite\",\n      },\n    },\n  },\n})\n// highlight-end\n\nexport type StandardScenario = typeof standard\n// highlight-next-line\nexport type PostOnlyScenario = typeof postOnly\n```\n\n----------------------------------------\n\nTITLE: Creating a RedwoodJS Project - Zsh Shell\nDESCRIPTION: This shell command initializes a new RedwoodJS project named 'email' using TypeScript. Requires Node.js, Yarn, and RedwoodJS CLI installed globally. Input: command run in terminal; Output: project folder with RedwoodJS boilerplate files and TypeScript configuration. No parameters are required beyond the app name.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_0\n\nLANGUAGE: zsh\nCODE:\n```\nyarn create redwood-app --typescript email\n```\n\n----------------------------------------\n\nTITLE: Checking for Errors After `save()` Failure (JavaScript/JSX)\nDESCRIPTION: JavaScript/JSX code illustrating how to handle potential errors after calling the asynchronous `save()` method on a RedwoodRecord instance. It shows checking the boolean return value of `save()`, using the `hasError()` method, and accessing the `errors` object which contains validation or database error messages keyed by attribute name (or `base` for record-level errors).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = User.build({ name: 'Rob Cameron' })\nawait user.save() // => false\nuser.hasError() // => true\nuser.errors // => { base: [], email: ['must not be null'] }\nuser.errors.email // => ['must not be null']\n```\n\n----------------------------------------\n\nTITLE: Manually Generating TypeScript Types in RedwoodJS (Bash)\nDESCRIPTION: This command (`yarn rw g types`) manually triggers the TypeScript type generation process in a RedwoodJS project. This is useful after modifying GraphQL elements like queries in Cells or SDL files to ensure the TypeScript types used throughout the application (e.g., in Cell props) are accurate and reflect the latest schema and operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g types\n```\n\n----------------------------------------\n\nTITLE: Updating Article Component with Summary Feature (TSX)\nDESCRIPTION: This snippet updates the TypeScript `Article` component. It defines a typed `truncate` function and adds an optional `summary` boolean prop to the `Props` interface. The component conditionally renders either the truncated (first 100 characters) or the full `article.body` based on the `summary` prop, defaulting to `false`. It uses the `Post` type from GraphQL types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-story.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/Article/Article.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\nimport type { Post } from 'types/graphql'\n\n// highlight-start\nconst truncate = (text: string, length: number) => {\n  return text.substring(0, length) + '...'\n}\n// highlight-end\n\ninterface Props {\n  // highlight-start\n  article: Omit<Post, 'createdAt'>\n  summary?: boolean\n  // highlight-end\n}\n\n// highlight-next-line\nconst Article = ({ article, summary = false }: Props) => {\n  return (\n    <article className=\"mt-10\">\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        // highlight-next-line\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\n----------------------------------------\n\nTITLE: Updating GraphQL Query for Admin Post List Cell (JSX)\nDESCRIPTION: This snippet updates the PostsCell component to query for adminPosts (renamed via alias to posts) rather than the public posts endpoint, ensuring the admin scaffold lists only the currently logged in user's posts. The query fetches primary fields for display in the post list (id, title, body, createdAt). It uses RedwoodJS GQL and expects no input variables.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_24\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query POSTS {\n    // highlight-next-line\n    posts: adminPosts {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Refactoring RedwoodJS HomePage Component (JavaScript/JSX)\nDESCRIPTION: Presents the refactored `HomePage` component in JavaScript (JSX). After moving the header and main structure to the `BlogLayout`, this page component is significantly simplified, containing only its unique content ('Home' text) and the `Metadata` component. Imports for `Link` and `routes` are removed as they are now handled by the layout.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n\nconst HomePage = () => {\n  return (\n    <>\n      <Metadata title=\"Home\" description=\"Home page\" />\n      Home\n    </>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Launching Prisma Studio for Database Inspection - Bash\nDESCRIPTION: Opens Prisma Studio, a web-based database interface, using the command 'yarn rw prisma studio'. Requires a functioning Prisma setup and a database to connect. This command starts a local web server (default at http://localhost:5555) to visually browse and manage database contents, especially useful for development and debugging. Invoked from the CLI; output is an interactive browser UI.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/getting-dynamic.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nyarn rw prisma studio\n```\n\n----------------------------------------\n\nTITLE: Defining a New Message Subscription with GraphQL in RedwoodJS\nDESCRIPTION: This GraphQL schema defines a subscription type for real-time chat, allowing clients to listen for 'newMessage' events scoped to a chat room. The 'roomId' argument targets the room, and the schema is protected with the '@requireAuth' directive. It expects a 'Message' response type. Dependencies include a properly configured Message type and authorization decorators.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\ntype Subscription {\n  newMessage(roomId: ID!): Message! @requireAuth\n}\n```\n\n----------------------------------------\n\nTITLE: Testing RedwoodJS Cell States (ArticleCell) with Jest in JSX\nDESCRIPTION: This JSX snippet contains a Jest test suite for the `ArticleCell` component defined previously. It uses the `render` function from `@redwoodjs/testing/web` to test each exported state component (`Loading`, `Empty`, `Failure`, `Success`). The tests primarily assert that each component renders without throwing an error, using mock data (`standard`) for the `Success` state and a mock error for the `Failure` state.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_36\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticleCell/ArticleCell.test.js\"\nimport { render, screen } from '@redwoodjs/testing/web'\nimport { Loading, Empty, Failure, Success } from './ArticleCell'\nimport { standard } from './ArticleCell.mock'\n\ndescribe('ArticleCell', () => {\n  it('renders Loading successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  it('renders Empty successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  it('renders Failure successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  it('renders Success successfully', async () => {\n    expect(() => {\n      render(<Success article={standard().article} />)\n    }).not.toThrow()\n  })\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Dynamically Loading External Libraries with useIsBrowser in RedwoodJS (JSX)\nDESCRIPTION: Demonstrates dynamic loading of large third-party libraries in a component using the useIsBrowser utility from @redwoodjs/prerender/browserUtils. Ensures heavy dependencies are only loaded in the browser, not during SSR/prerender. Key parameter: browser (boolean indicating if client environment); loads libraries only when true. Input: runtime environment; Output: library loaded or skipped.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useIsBrowser } from '@redwoodjs/prerender/browserUtils'\n\nconst ComponentUsingAnExternalLibrary = () => {\n  const browser = useIsBrowser()\n\n  // if `browser` evaluates to false, this won't be included\n  if (browser) {\n    loadMyLargeExternalLibrary()\n  }\n\n  return (\n    // ...\n  )\n```\n\n----------------------------------------\n\nTITLE: Executing Redwood Data Migrations - Bash\nDESCRIPTION: Presents the command to execute outstanding data migration scripts, matching unrecorded scripts to be applied. Dependencies: Redwood CLI, DataMigration model in db. Input: Command. Output: Migrations applied; errors reported if scripts fail. Limitation: If script fails, remaining not executed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood data-migrate up\n```\n\n----------------------------------------\n\nTITLE: Composing a Full Featured Dashboard Page (tsx)\nDESCRIPTION: This code defines the complete DashboardPage component, featuring a grid combining multiple KPI cards and an area chart. It imports Tremor visualization components, custom KpiCard, and types, constructs sample datasets, and organizes layout for clear, actionable visualization. Dependencies: @tremor/react, TailwindCSS, KpiCard component. Inputs: static chart and KPIs; extensible for dynamic data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Grid, Col, Card, Title, AreaChart } from '@tremor/react'\n\nimport { MetaTags } from '@redwoodjs/web'\n\nimport KpiCard from 'src/components/KpiCard/KpiCard' // 👉 Import the KpiCard component\nimport type { Kpi } from 'src/components/KpiCard/KpiCard' // 👉 Import the Kpi type\n\nconst DashboardPage = () => {\n  const chartdata = [\n    {\n      date: 'Jan 22',\n      SemiAnalysis: 2890,\n      'The Pragmatic Engineer': 2338,\n    },\n    {\n      date: 'Feb 22',\n      SemiAnalysis: 2756,\n      'The Pragmatic Engineer': 2103,\n    },\n    {\n      date: 'Mar 22',\n      SemiAnalysis: 3322,\n      'The Pragmatic Engineer': 2194,\n    },\n    {\n      date: 'Apr 22',\n      SemiAnalysis: 3470,\n      'The Pragmatic Engineer': 2108,\n    },\n    {\n      date: 'May 22',\n      SemiAnalysis: 3475,\n      'The Pragmatic Engineer': 1812,\n    },\n    {\n      date: 'Jun 22',\n      SemiAnalysis: 3129,\n      'The Pragmatic Engineer': 1726,\n    },\n  ]\n\n  const kpis: Kpi[] = [\n    // 👉 Create some sample KPI data\n    {\n      title: 'Sales',\n      metric: '$ 12,699',\n      progress: 15.9,\n      metricTarget: '$ 80,000',\n      delta: '13.2%',\n      deltaType: 'moderateIncrease',\n    },\n    {\n      title: 'Profit',\n      metric: '$ 45,564',\n      progress: 36.5,\n      metricTarget: '$ 125,000',\n      delta: '23.9%',\n      deltaType: 'increase',\n    },\n    {\n      title: 'Customers',\n      metric: '1,072',\n      progress: 53.6,\n      metricTarget: '2,000',\n      delta: '10.1%',\n      deltaType: 'moderateDecrease',\n    },\n  ]\n\n  const dataFormatter = (number: number) => {\n    return '$ ' + Intl.NumberFormat('us').format(number).toString()\n  }\n\n  return (\n    <div className=\"m-12\">\n      <MetaTags title=\"Dashboard\" description=\"Dashboard page\" />\n\n      <h1 className=\"mb-12 text-2xl\">Dashboard</h1>\n\n      <Grid numCols={1} numColsSm={2} numColsLg={3} className=\"my-8 gap-6\">\n        {kpis.map((kpi, i) => (\n          <Col key={i} numColSpan={1}>\n            <KpiCard kpi={kpi} />\n          </Col>\n        ))}\n        <Col numColSpan={1} numColSpanLg={3}>\n          <Card>\n            <Title>Newsletter revenue over time (USD)</Title>\n            <AreaChart\n              className=\"mt-4 h-72\"\n              data={chartdata}\n              index=\"date\"\n              categories={['SemiAnalysis', 'The Pragmatic Engineer']}\n              colors={['indigo', 'green']}\n              valueFormatter={dataFormatter}\n            />\n          </Card>\n        </Col>\n      </Grid>\n    </div>\n  )\n}\n\nexport default DashboardPage\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL SDL for Testimonials Query - JavaScript\nDESCRIPTION: Declares the GraphQL SDL (Schema Definition Language) mapping for the Testimonial type and its associated 'testimonials' query. The schema defines required fields that mirror the Prisma model and connects the 'testimonials' query in GraphQL to the service resolver by naming convention. This SDL is used by RedwoodJS to associate incoming GraphQL queries with backend services, and requires the GraphQL tag and Redwood environment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter0/what-is-redwood.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nexport const schema = gql`\n  type Testimonial {\n    id: Int!\n    author: String!\n    quote: String!\n    createdAt: DateTime!\n    updatedAt: DateTime!\n  }\n\n  type Query {\n    testimonials: [Testimonial!] @skipAuth\n  }\n`\n\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Image CRUD Screens in RedwoodJS - Bash\nDESCRIPTION: Generates RedwoodJS CRUD scaffolding for the Image model, creating pages and forms for create/read/update/delete operations automatically. This increases development speed and provides a base for further customization.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw generate scaffold image\n```\n\n----------------------------------------\n\nTITLE: Querying Allowed Fields with Field-Level Authorization (GraphQL)\nDESCRIPTION: This GraphQL query demonstrates a valid request for a user who is authenticated but does *not* have the 'ADMIN' role, according to the schema defined with field-level `@requireAuth(role: \"ADMIN\")` on the `email` field. Since the `email` field is omitted, the query is permitted.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_14\n\nLANGUAGE: graphql\nCODE:\n```\nquery user(id: 1) {\n  id\n  name\n  createdAt\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Default Value to 'roles' Field in Prisma Schema\nDESCRIPTION: This updated Prisma schema snippet modifies the `roles` field in the `User` model to include a default value of \"moderator\". This ensures that new users automatically get a default role and allows the database migration to succeed for existing users by assigning them this default role.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_3\n\nLANGUAGE: prisma\nCODE:\n```\nmodel User {\n  id                  Int @id @default(autoincrement())\n  name                String?\n  email               String @unique\n  hashedPassword      String\n  salt                String\n  resetToken          String?\n  resetTokenExpiresAt DateTime?\n  // highlight-next-line\n  roles               String @default(\"moderator\")\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Comments by postId with GraphQL in RedwoodJS (JavaScript)\nDESCRIPTION: This GraphQL query fetches comments for a specific post via the postId variable, as used in the CommentsCell React component. It's designed for use with RedwoodJS Cells and Apollo Client, where the postId is passed as a prop and auto-injected as a GraphQL query variable. Inputs include postId (Int); outputs are a comments list with id, name, body, and createdAt. Dependencies include gql-tag and backend GraphQL schema exposing comments(postId: Int!).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_32\n\nLANGUAGE: graphql\nCODE:\n```\nexport const QUERY = gql`\\n  // highlight-start\\n  query CommentsQuery($postId: Int!) {\\n    comments(postId: $postId) {\\n    // highlight-end\\n      id\\n      name\\n      body\\n      createdAt\\n    }\\n  }\\n`\n```\n\n----------------------------------------\n\nTITLE: Asserting Full Body Absence (JavaScript)\nDESCRIPTION: Uses `screen.queryByText` to attempt to find an element containing the full `article.body`. `queryByText` returns `null` if not found (unlike `getByText` which throws). The assertion `expect(...).not.toBeInTheDocument()` verifies that the full body text is indeed absent.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nexpect(screen.queryByText(article.body)).not.toBeInTheDocument()\n```\n\n----------------------------------------\n\nTITLE: Associating a Mock with a GraphQL Mutation Operation Name in JSX\nDESCRIPTION: Shows how the first argument ('SetUserProfile') provided to `mockGraphQLMutation` corresponds to the operation name defined in the GraphQL mutation string.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/mocking-graphql-requests.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nmutation SetUserProfile { /*...*/ }\nmockGraphQLMutation('SetUserProfile', { /*... */ })\n```\n\n----------------------------------------\n\nTITLE: Configuring Web Environment Variables in redwood.toml (TOML)\nDESCRIPTION: This TOML snippet demonstrates configuring the `[web]` section of `redwood.toml` to explicitly include environment variables (e.g., `SECRET_API_KEY`, `ANOTHER_ONE`) for the Web side in production. Redwood replaces references like `process.env.SECRET_API_KEY` with their actual values during the build, making them accessible in the browser. This is the recommended method.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/environment-variables.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n```toml title=\"redwood.toml\"\n[web]\n  includeEnvironmentVariables = ['SECRET_API_KEY', 'ANOTHER_ONE']\n```\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Response Output for Directive-Limited Posts Query (JSON, TypeScript Syntax)\nDESCRIPTION: Presents an example JSON response from a GraphQL posts query with directive usage. Demonstrates the trimmed (filtered) results, showing only a single id and title per post in the data field. Useful for illustrating impact of directives, expected outputs, and testing endpoint security constraints.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_70\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  \"data\": {\n    \"posts\": [\n      {\n        \"id\": 1,\n        \"title\": \"A little more about RedwoodJS\"\n      },\n      {\n        \"id\": 2,\n        \"title\": \"What is GraphQL?\"\n      },\n      {\n        \"id\": 3,\n        \"title\": \"Welcome to the RedwoodJS Community!\"\n      },\n      {\n        \"id\": 4,\n        \"title\": \"10 ways to secure your GraphQL endpoint\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Prerender Prop to a Route in RedwoodJS (JavaScript/JSX)\nDESCRIPTION: Illustrates how to enable prerendering on a specific RedwoodJS route by setting the 'prerender' property on a Route component. No additional dependencies are needed beyond RedwoodJS core. The key parameters here are 'path', 'page', 'name', and the 'prerender' boolean. Accepts standard route configuration and will output statically-generated HTML upon build.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/\" page={HomePage} name=\"home\" prerender/>\n```\n\n----------------------------------------\n\nTITLE: Updating Empty State Component in CommentsCell (React/JSX)\nDESCRIPTION: Modifies the `Empty` functional component within `web/src/components/CommentsCell/CommentsCell.jsx`. This component is rendered by the RedwoodJS Cell when the associated GraphQL query returns no data. It now returns a styled `div` element displaying the user-friendly message \"No comments yet\". Styling is applied using Tailwind CSS classes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Empty = () => {\n  // highlight-next-line\n  return <div className=\"text-center text-gray-500\">No comments yet</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Comment Component with Redwood CLI - Bash\nDESCRIPTION: This Bash code snippet demonstrates how to generate a new React component named 'Comment' using the RedwoodJS CLI. Running this command sets up boilerplate files for the component, stories, and tests, accelerating development speed. It requires an existing RedwoodJS project and the 'yarn' package manager, and produces several files scaffolded under the web/src/components/Comment directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/the-redwood-way.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nyarn rw g component Comment\n```\n\n----------------------------------------\n\nTITLE: Destroying RedwoodJS Directives via CLI\nDESCRIPTION: This command removes a previously generated RedwoodJS directive and its associated files. It requires the name of the directive to be destroyed as an argument. This effectively reverses the `generate directive` command.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_41\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood destroy directive <name>\n```\n\n----------------------------------------\n\nTITLE: Removing Deployed Resources from AWS - RedwoodJS - Bash\nDESCRIPTION: This snippet shows how to remove deployed services for both API and Web sides using the Serverless CLI. The `remove` command will entirely delete provisioned AWS resources for the specified stage. It must be run separately in both `api` and `web` directories and may take several minutes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/serverless.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn serverless remove --stage production\n```\n\n----------------------------------------\n\nTITLE: Creating New User/Identity in findOrCreateUser (JavaScript)\nDESCRIPTION: This part of the `findOrCreateUser` function executes if no existing identity is found. It uses `db.$transaction` to ensure that both the user and identity records are created atomically. Inside the transaction, it first creates a new `User` record using data (email, name) from the `providerUser` object. Then, it creates a new `Identity` record, linking it to the newly created user via `userId` and storing the provider ('github') and provider's user ID (`providerUser.id`, converted to string). Finally, it returns the newly created user and identity objects.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nconst findOrCreateUser = async (providerUser) => {\n  // ...\n\n  return await db.$transaction(async (tx) => {\n    const user = await tx.user.create({\n      data: {\n        email: providerUser.email,\n        fullName: providerUser.name,\n      },\n    })\n\n    const identity = await tx.identity.create({\n      data: {\n        userId: user.id,\n        provider: 'github',\n        uid: providerUser.id.toString()\n      }\n    })\n\n    return { user, identity }\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Setting the Test Database URL Environment Variable\nDESCRIPTION: Specifies the line to add to the `.env` file to resolve the 'Schema Parsing P1012' error encountered during testing. This environment variable provides the necessary database connection string for the test environment. Replace `<the same url as DATABASE_URL>` with the actual URL used for the development database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/testing.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nTEST_DATABASE_URL=<the same url as DATABASE_URL>\n```\n\n----------------------------------------\n\nTITLE: Creating Storybook Stories for Article Component (TSX)\nDESCRIPTION: This TypeScript (TSX) snippet configures Storybook stories for the `Article` component. A constant `ARTICLE` holds sample data. Two named exports define the stories: `full` displays the complete article, while `summary` passes `summary={true}` to the `Article` component to display the truncated version. This allows testing both component states in isolation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-story.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/components/Article/Article.stories.tsx\"\nimport Article from './Article'\n\n// highlight-start\nconst ARTICLE = {\n  id: 1,\n  title: 'First Post',\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\n}\n// highlight-end\n\n// highlight-start\nexport const full = () => {\n  return <Article article={ARTICLE} />\n}\n// highlight-end\n\n// highlight-start\nexport const summary = () => {\n  return <Article article={ARTICLE} summary={true} />\n}\n// highlight-end\n\nexport default { title: 'Components/Article' }\n```\n```\n\n----------------------------------------\n\nTITLE: Updating Netlify Redirects for Prerendered notFoundPage (Diff)\nDESCRIPTION: Shows a TOML diff for removing the catch-all redirect to index in netlify.toml when prerendering all routes including notFoundPage. No dependencies; operation is editing deployment configuration. Changing the redirect logic ensures browsers receive proper 404 HTTP statuses. Input: original netlify.toml; Output: modified netlify.toml without index fallback redirect.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_18\n\nLANGUAGE: diff\nCODE:\n```\n[[redirects]]\n- from = \"/*\"\n- to = \"/index.html\"\n- status = 200\n```\n\n----------------------------------------\n\nTITLE: Generating Login Passwordless Page - RedwoodJS - Bash\nDESCRIPTION: This bash command runs the RedwoodJS CLI to create a new page component named LoginPasswordless. It sets up the file structure and base file for the page that will manage the passwordless authentication flow. Simply execute this command in the project root; no additional arguments required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g page LoginPasswordless\n```\n\n----------------------------------------\n\nTITLE: Simplifying AboutPage Component in RedwoodJS (JavaScript)\nDESCRIPTION: This JSX snippet shows a simplified `AboutPage` component in a RedwoodJS application. It removes the previously needed explicit 'Return to Home' link and its associated imports (`Link`, `routes`), relying instead on the navigation provided by the `BlogLayout`. It utilizes the `Metadata` component from `@redwoodjs/web` for setting page metadata.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/AboutPage/AboutPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <>\n      <Metadata title=\"About\" description=\"About page\" />\n\n      <p>\n        This site was created to demonstrate my mastery of Redwood: Look on my\n        works, ye mighty, and despair!\n      </p>\n    </>\n  )\n}\n\nexport default AboutPage\n```\n```\n\n----------------------------------------\n\nTITLE: Checking the Installed Node.js Version in Terminal\nDESCRIPTION: Displays the currently active Node.js version in the terminal. This command is used to verify that the installed Node.js version meets Redwood's requirement (v20 or higher).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/create-redwood-app.md#_snippet_1\n\nLANGUAGE: terminal\nCODE:\n```\nnode -v\n```\n\n----------------------------------------\n\nTITLE: Deploying RedwoodJS to Vercel with Prisma and Data Migration Disabled (shell)\nDESCRIPTION: This shell command deploys a RedwoodJS project to Vercel while disabling both Prisma integration and data migration steps. It is intended for scenarios such as using Vercel Postgres on the Hobby plan, where write and storage operations need to be limited to avoid resource constraints. Flags \\u2013prisma=false and \\u2013data-migrate=false deactivate automated schema and migration processes during the deployment step.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/vercel.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw deploy vercel --prisma=false --data-migrate=false\\n\n```\n\n----------------------------------------\n\nTITLE: Performing Health and Readiness HTTP Checks - Bash\nDESCRIPTION: This set of Bash snippets provides example curl commands for performing health and readiness checks against RedwoodJS GraphQL endpoints during local development or production use. Dependencies are a terminal with curl installed. Inputs include endpoint URLs and, in the readiness check, expected headers (x-yoga-id). Outputs are the HTTP status code and response headers/body indicating server health or readiness. Designed for manual or automated infrastructure testing and monitoring; constraints include matching the correct endpoint and header values.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ncurl \"http://localhost:8910/.redwood/functions/graphql/health\" -i\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl \"http://localhost:8911/graphql/health\" -i\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl \"http://localhost:8910/.redwood/functions/graphql/readiness\" \\\n  -H 'x-yoga-id: yoga' \\\n  -i\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl \"http://localhost:8911/graphql/readiness\" \\\n  -H 'x-yoga-id: yoga' \\\n  -i\n```\n\n----------------------------------------\n\nTITLE: Mocking a GraphQL Mutation with mockGraphQLMutation - Storybook - JavaScript\nDESCRIPTION: This snippet demonstrates how to use `mockGraphQLMutation` to mock the result of the `UpdateUserName` mutation. The mock receives arguments (destructured as `{ name }`) and returns a response shape matching the expected mutation payload. The code should be placed in a Storybook mock file. Dependencies: Storybook, RedwoodJS, `mockGraphQLMutation`. Inputs: mutation name and variables; outputs: mock payload for the mutation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/mocking-graphql-in-storybook.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nexport const standard =\n  /* ... */\n\n  mockGraphQLMutation('UpdateUserName', ({ name }) => {\n    return {\n      userProfile: {\n        id: 99,\n        name,\n      },\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Running Redwood Server with Host/Port Flags\nDESCRIPTION: This shell command demonstrates running the built server file while specifying the host and port using the `--apiHost` and `--apiPort` command-line flags. These flags take the highest precedence in determining where the server listens.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nyarn node api/dist/server.js --apiHost 0.0.0.0 --apiPort 8913\n```\n\n----------------------------------------\n\nTITLE: Initializing and Renaming PM2 Config - Yarn/Bash - Bash\nDESCRIPTION: These Bash commands initialize a default ecosystem configuration for PM2 and then rename it for clarity. The pm2 config initialization prepares the project for process management. Assumes PM2 is installed globally or as a project dependency and the working directory is the app root.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/self-hosting-redwood.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn pm2 init\nmv ecosystem.config.js pm2.config.js\n```\n\n----------------------------------------\n\nTITLE: Generating a Sign In Page using RedwoodJS CLI in Bash\nDESCRIPTION: This snippet shows how to use the RedwoodJS CLI 'generate' command to scaffold a new 'signin' page. This command creates the necessary files and boilerplate needed for a sign in page in the RedwoodJS project's web/src/pages directory. No additional dependencies are required other than a configured RedwoodJS project; the command expects that 'yarn' and 'redwood' are installed. No arguments besides the page name ('signin') are required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate page signin\n```\n\n----------------------------------------\n\nTITLE: Updating Docker CMD for Redwood Server File\nDESCRIPTION: This diff snippet illustrates the necessary change in a Dockerfile when using the server file. The `CMD` instruction must be updated to execute the built server file (`api/dist/server.js`) directly with Node.js, instead of using the old `rw-server` binary. Failing to update this can lead to incomplete server configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n  ENV NODE_ENV=production\n\n- CMD [ \"node_modules/.bin/rw-server\", \"api\" ]\n+ CMD [ \"api/dist/server.js\" ]\n```\n\n----------------------------------------\n\nTITLE: Installing Filestack JS Library in RedwoodJS API Workspace\nDESCRIPTION: Uses the Yarn package manager to add the `filestack-js` library specifically to the `api` workspace of a RedwoodJS project. This installation makes the Filestack JavaScript SDK available for use in backend service functions, enabling server-side interactions with the Filestack API.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\nyarn workspace api add filestack-js\n```\n\n----------------------------------------\n\nTITLE: Using useMutation Hook to Prepare GraphQL Contact Mutation (JavaScript, JSX)\nDESCRIPTION: This snippet illustrates how to use the useMutation hook from RedwoodJS's web package to prepare for invoking the GraphQL mutation. It sets up the create function by calling useMutation with CREATE_CONTACT, which can then be called for executing mutations triggered by form submission. Prerequisites: RedwoodJS, Apollo Client, a backend GraphQL mutation endpoint. Inputs expected are field values for a new contact; output upon mutation is the created contact's id.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { Metadata, useMutation } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\nconst ContactPage = () => {\n  // highlight-next-line\n  const [create] = useMutation(CREATE_CONTACT)\n\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Clearing the Job Queue using Bash\nDESCRIPTION: This command uses the RedwoodJS CLI to remove all jobs (pending, failed, successful) from the configured storage (e.g., the Prisma database).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs clear\n```\n\n----------------------------------------\n\nTITLE: Generating an ED25519 SSH Keypair using ssh-keygen in Bash\nDESCRIPTION: Demonstrates the command `ssh-keygen -t ed25519` used to generate a new SSH public/private keypair. The `-t ed25519` flag specifies the use of the modern and secure ED25519 algorithm.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nssh-keygen -t ed25519\n```\n\n----------------------------------------\n\nTITLE: Running Custom RedwoodJS Package Setup - Example - Bash\nDESCRIPTION: This command provides an example CLI invocation to run a made-up redwoodjs/setup-example package using Redwood's setup command. This operation downloads, checks compatibility, and executes the package's setup routine in the project context. The user must ensure package trust, as arbitrary code will be executed. No additional files are required; the invocation occurs in the project directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_118\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn rw setup package @redwoodjs/setup-example\n```\n\n----------------------------------------\n\nTITLE: Querying Related Post from Comment using Prisma Client (JavaScript)\nDESCRIPTION: Demonstrates querying the related `Post` object for a specific `Comment` using the Prisma Client API. It uses `db.comment.findUnique` to find the comment by its ID and then chains `.post()` to access the associated post data, leveraging the relation defined in the Prisma schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ndb.comment.findUnique({ where: { id: 1 } }).post()\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies in Project Root with Yarn - Bash\nDESCRIPTION: Installs all required packages and dependencies for the project as specified in package.json and yarn.lock using 'yarn install'. This command should be run from the project's root directory. It sets up node_modules and ensures consistent dependency installation across environments. No additional flags are required unless specifying production or offline modes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-yarn.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Excluding .yarn Folder from VSCode File Browser and Search\nDESCRIPTION: This JSON snippet for VSCode's `settings.json` uses the `files.exclude` setting to hide the `.yarn` directory from the file explorer panel. This setting also implicitly excludes the folder from search results.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/project-configuration-dev-test-build.mdx#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n  \"files.exclude\": {\n    \"**/.yarn\": true\n  }\n```\n\n----------------------------------------\n\nTITLE: Testing Initial CommentsCell States in RedwoodJS (TSX)\nDESCRIPTION: This TSX code snippet shows the default Jest tests for a RedwoodJS `CommentsCell` component using TypeScript, located in `web/src/components/CommentsCell/CommentsCell.test.tsx`. It imports `render` from `@redwoodjs/testing/web`, the component's states (`Loading`, `Empty`, `Failure`, `Success`), and mock data (`standard`). The tests ensure that each state renders successfully without throwing errors by using `render` and `expect().not.toThrow()`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { render } from '@redwoodjs/testing/web'\n\nimport { Loading, Empty, Failure, Success } from './CommentsCell'\nimport { standard } from './CommentsCell.mock'\n\ndescribe('CommentsCell', () => {\n  it('renders Loading successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  it('renders Empty successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  it('renders Failure successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  it('renders Success successfully', async () => {\n    expect(() => {\n      render(<Success comments={standard().comments} />)\n    }).not.toThrow()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Test Scenario Data for Comments - TypeScript\nDESCRIPTION: This TypeScript snippet defines standard scenario data for comment-related tests, mirroring the JavaScript version. It creates two comments with distinct posts and attributes, meant for seeding test databases. The code structure ensures compatibility with Redwood's test scenario features.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_29\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const standard = defineScenario({\\n  comment: {\\n    jane: {\\n      data: {\\n        name: 'Jane Doe',\\n        body: 'I like trees',\\n        post: {\\n          create: {\\n            title: 'Redwood Leaves',\\n            body: 'The quick brown fox jumped over the lazy dog.',\\n          },\\n        },\\n      },\\n    },\\n    john: {\\n      data: {\\n        name: 'John Doe',\\n        body: 'Hug a tree today',\\n        post: {\\n          create: {\\n            title: 'Root Systems',\\n            body: 'The five boxing wizards jump quickly.',\\n          },\\n        },\\n      },\\n    },\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Testing the Comment Component with RedwoodJS Testing - JavaScript\nDESCRIPTION: This JavaScript test uses RedwoodJS\\'s testing utilities to verify that the Comment component renders without errors and properly outputs the comment\\'s name, body, and formatted date. It also asserts that the formatted date\\'s element is a <time> tag with the correct 'datetime' attribute, ensuring semantic correctness. Dependencies include @redwoodjs/testing and React Testing Library; the test expects the date formatting implementation to output '2 January 2020' for the given input.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/the-redwood-way.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n// highlight-next-line\nimport { render, screen } from '@redwoodjs/testing'\n\nimport Comment from './Comment'\n\ndescribe('Comment', () => {\n  it('renders successfully', () => {\n    // highlight-start\n    const comment = {\n      name: 'John Doe',\n      body: 'This is my comment',\n      createdAt: '2020-01-02T12:34:56Z',\n    }\n    render(<Comment comment={comment} />)\n\n    expect(screen.getByText(comment.name)).toBeInTheDocument()\n    expect(screen.getByText(comment.body)).toBeInTheDocument()\n    const dateExpect = screen.getByText('2 January 2020')\n    expect(dateExpect).toBeInTheDocument()\n    expect(dateExpect.nodeName).toEqual('TIME')\n    expect(dateExpect).toHaveAttribute('datetime', comment.createdAt)\n    // highlight-end\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Test Scenarios for Order Statuses (TypeScript/TSX)\nDESCRIPTION: Seed scenario data for automated tests of the 'updateOrderStatus' webhook. Uses RedwoodJS's 'defineScenario' function to create three test orders, each with a distinct tracking number and order status: PLACED, SHIPPED, and DELIVERED. This setup enables tests to reference known records to cover all expected webhook behaviors. Requires integration with RedwoodJS testing framework and the Prisma Order model.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\nexport const standard = defineScenario({\n  order: {\n    placed: {\n      data: { trackingNumber: '1ZP1LC3D0Rd3R000001', status: 'PLACED' },\n    },\n    shipped: {\n      data: { trackingNumber: '1ZSH1PP3D000002', status: 'SHIPPED' },\n    },\n    delivered: {\n      data: { trackingNumber: '1ZD31IV3R3D000003', status: 'DELIVERED' },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Car with Service Validations - TypeScript\nDESCRIPTION: Implements type-safe car creation by validating input fields with the same logic as the JavaScript version but using TypeScript's typing for additional compile-time safety. Depends on validate and db modules or equivalents and requires a Car type definition. Accepts a Car-typed input object and inserts the validated car into db.car.create.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const createCar = ({ input }: Car) => {\n  validate(input.make, 'make', {\n    inclusion: ['Audi', 'BMW', 'Ferrari', 'Lexus', 'Tesla'],\n  })\n  validate(input.color, 'color', {\n    exclusion: { in: ['Beige', 'Mauve'], message: 'No one wants that color' },\n  })\n  validate(input.hasDamage, 'hasDamage', {\n    absence: true,\n  })\n  validate(input.vin, 'vin', {\n    format: /[A-Z0-9]+/,\n    length: { equal: 17 },\n  })\n  validate(input.odometer, 'odometer', {\n    numericality: { positive: true, lessThanOrEqual: 10000 },\n  })\n\n  return db.car.create({ data: input })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RedwoodJS Scenarios with Includes for Relationships\nDESCRIPTION: This snippet shows how to use Prisma's `include` option within a RedwoodJS scenario definition. By adding `include: { post: true }`, the scenario will not only create the comment but also ensure the related post data is fetched and available on the `scenario` object within tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_61\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = defineScenario({\n  comment: {\n    first: {\n      data: {\n        name: 'Rob',\n        body: 'Something really interesting'\n        post: {\n          create: {\n            title: 'Brand new post',\n            body: 'Introducing dbAuth'\n          }\n        }\n      },\n      include: {\n        post: true\n      }\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Comment Service Functions in TypeScript\nDESCRIPTION: This TypeScript snippet defines the initial service functions for comments with types. It imports Prisma types, `ResolverArgs`, and the Prisma client (`db`). It exports `comments` (fetch all), `comment` (fetch one by ID with typed arguments `QueryResolvers['comment']`), and a typed `Comment` resolver (`CommentRelationResolvers`) with a `post` function to fetch the associated post.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/services/comments/comments.ts\"\nimport type { Prisma } from '@prisma/client'\nimport type { ResolverArgs } from '@redwoodjs/graphql-server'\n\nimport { db } from 'src/lib/db'\n\nexport const comments = () => {\n  return db.comment.findMany()\n}\n\nexport const comment = ({ id }: QueryResolvers['comment'] => {\n  return db.comment.findUnique({\n    where: { id },\n  })\n}\n\nexport const Comment: CommentRelationResolvers = {\n  post: (_obj, { root }) => {\n    return db.comment.findUnique({ where: { id: root?.id } }).post()\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up Deployment via Serverless - RedwoodJS - Bash\nDESCRIPTION: This snippet runs the initial setup command, installing dependencies and generating the required Serverless configuration files for RedwoodJS deployment. The command should be run from the project root. Requires `yarn`, Redwood CLI installed in the project, and an initialized Redwood app. No parameters are needed beyond those inferred by Redwood CLI context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/serverless.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup deploy serverless\n```\n\n----------------------------------------\n\nTITLE: Creating a TypeScript-Enabled Redwood Project (Shell)\nDESCRIPTION: This command initializes a new RedwoodJS project with TypeScript support by including the '--typescript' flag. It ensures that the generated project uses TypeScript configuration and templates. Requires supported versions of Node.js and Yarn. Produces a project initialized in a new directory ('my-redwood-project') with all files ready for TypeScript development.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn create redwood-app my-redwood-project --typescript\n```\n\n----------------------------------------\n\nTITLE: Invalidating Live Query Store for Auctions - TypeScript\nDESCRIPTION: Demonstrates how to invalidate a live query cache/store for a given auction in RedwoodJS after a bid. It forms a cache key using the auction's ID and calls `context.liveQueryStore.invalidate` to trigger client-side update. Used to broadcast live data refreshes for all clients querying a specific auction. Input: auction ID.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst key = `Auction:${auctionId}`\ncontext.liveQueryStore.invalidate(key)\n```\n\n----------------------------------------\n\nTITLE: Testing Comments Service Query by postId - TypeScript\nDESCRIPTION: This TypeScript test case verifies that querying comments with a specific postId returns all relevant comments. It uses the StandardScenario type for better typing, and expects result length to match the number of entries in the scenario data. It serves as a test for the postId query parameter in the Comments service.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\nscenario('returns all comments', async (scenario: StandardScenario) => {\\n  // highlight-next-line\\n  const result = await comments({ postId: scenario.comment.jane.postId })\\n  expect(result.length).toEqual(Object.keys(scenario.comment).length)\\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Uploads and Storage Adapters\nDESCRIPTION: Details the structure and key components of the `api/src/lib/uploads.ts` configuration file generated by `yarn rw setup uploads`. It covers: (1) Defining which Prisma models and fields handle uploads using `createUploadsConfig`. (2) Instantiating a storage adapter, here `FileSystemStorage`, specifying the base directory for saved files. (3) Optionally setting up a `UrlSigner` for generating secure, time-limited URLs, requiring a secret key. (4) Using `setupStorage` to combine the configuration, adapter, and signer, exporting utility functions (`saveFiles`) and the `storagePrismaExtension` for database integration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/lib/uploads.ts\"\nimport { createUploadsConfig, setupStorage } from '@redwoodjs/storage'\nimport { FileSystemStorage } from '@redwoodjs/storage/FileSystemStorage'\nimport { UrlSigner } from '@redwoodjs/storage/signedUrl'\n\n// ⭐ (1)\nconst uploadConfig = createUploadsConfig({\n  profile: {\n    fields: ['avatar'], // 👈 the fields that will contain your `File`s\n  },\n})\n\n// ⭐ (2)\nexport const fsStorage = new FileSystemStorage({\n  baseDir: './uploads',\n})\n\n// ⭐ (3) Optional\nexport const urlSigner = new UrlSigner({\n  secret: process.env.UPLOADS_SECRET,\n  endpoint: '/signedUrl',\n})\n\n// ⭐ (4)\nconst { saveFiles, storagePrismaExtension } = setupStorage({\n  uploadsConfig,\n  storageAdapter: fsStorage,\n  urlSigner,\n})\n\nexport { saveFiles, storagePrismaExtension }\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Auth0 Environment Variables (.env)\nDESCRIPTION: Defines the necessary environment variables in the project's `.env` file. These variables (`AUTH0_DOMAIN`, `AUTH0_CLIENT_ID`, `AUTH0_REDIRECT_URI`, `AUTH0_AUDIENCE`) hold credentials and configuration details obtained from the Auth0 application settings dashboard and are required for the application to communicate with Auth0.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/auth0.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nAUTH0_DOMAIN=\"...\"\nAUTH0_CLIENT_ID=\"...\"\nAUTH0_REDIRECT_URI=\"http://localhost:8910\"\nAUTH0_AUDIENCE=\"...\"\n```\n\n----------------------------------------\n\nTITLE: Common Shell Configuration Files for Prompt Customization (Text)\nDESCRIPTION: Lists the standard configuration files for Bash (`.bashrc`, `.bash_profile`) and Zsh (`.zshrc`, `.zprofile`) shells. The shell prompt variable (`PS1`) is typically defined within one of these files, which need to be edited for customization.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_27\n\nLANGUAGE: text\nCODE:\n```\n~/.bashrc\n~/.bash_profile\n~/.zshrc\n~/.zprofile\n```\n\n----------------------------------------\n\nTITLE: Using RedwoodJS Validation Prop for Required Fields (JavaScript)\nDESCRIPTION: This partial snippet shows how to use RedwoodJS's built-in `validation` prop on form fields (`TextField`, `TextAreaField`) instead of the plain HTML `required` attribute. It passes an object `{ required: true }` to enforce the field requirement, enabling more customizable validation feedback.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nreturn (\n  <Form onSubmit={onSubmit}>\n    <label htmlFor=\"name\">Name</label>\n    // highlight-next-line\n    <TextField name=\"name\" validation={{ required: true }} />\n\n    <label htmlFor=\"email\">Email</label>\n    // highlight-next-line\n    <TextField name=\"email\" validation={{ required: true }} />\n\n    <label htmlFor=\"message\">Message</label>\n    // highlight-next-line\n    <TextAreaField name=\"message\" validation={{ required: true }} />\n\n    <Submit>Save</Submit>\n  </Form>\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up Auth Provider with GoTrue in RedwoodJS (JavaScript/JSX)\nDESCRIPTION: This snippet shows how to configure RedwoodJS authentication using GoTrue-JS by initializing the GoTrue client with your Netlify Identity endpoint and wiring it to the AuthProvider. It imports necessary modules and passes the GoTrue instance as the client. All required dependencies must be installed via yarn (including '@redwoodjs/auth', 'gotrue-js', and Redwood core packages). The APIUrl string must be customized to your deployment's Netlify identity URL, and the setCookie flag should be set appropriately for browser sessions. Inputs are the GoTrue API endpoint and configuration flags; output is a React application with authentication wired up.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { AuthProvider } from '@redwoodjs/auth'\nimport GoTrue from 'gotrue-js'\nimport { FatalErrorBoundary } from '@redwoodjs/web'\nimport { RedwoodApolloProvider } from '@redwoodjs/web/apollo'\n\nimport FatalErrorPage from 'src/pages/FatalErrorPage'\nimport Routes from 'src/Routes'\n\nimport './index.css'\n\nconst goTrueClient = new GoTrue({\n  APIUrl: 'https://MYAPP.netlify.app/.netlify/identity',\n  setCookie: true,\n})\n\nconst App = () => (\n  <FatalErrorBoundary page={FatalErrorPage}>\n    <AuthProvider client={goTrueClient} type=\"goTrue\">\n      <RedwoodApolloProvider>\n        <Routes />\n      </RedwoodApolloProvider>\n    </AuthProvider>\n  </FatalErrorBoundary>\n)\n\nexport default App\n```\n\n----------------------------------------\n\nTITLE: Passing formMethods to RedwoodJS Form Component (TypeScript)\nDESCRIPTION: Supplies the formMethods object returned from useForm directly to the Form component in TypeScript, maintaining type safety and supporting validation. This allows advanced form behaviors such as reset on completion to be implemented while preserving expected RedwoodJS form behavior. The snippet demonstrates Form setup, including configuration and error propagation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_35\n\nLANGUAGE: tsx\nCODE:\n```\nreturn (\n  <>\n    <Toaster />\n    <Form\n      onSubmit={onSubmit}\n      config={{ mode: 'onBlur' }}\n      error={error}\n      // highlight-next-line\n      formMethods={formMethods}\n    >\n    // ...\n\n```\n\n----------------------------------------\n\nTITLE: Creating Stylable SVG React Components (TSX)\nDESCRIPTION: Demonstrates converting an SVG's XML content into a functional React component (using TSX syntax) to enable direct styling via props or CSS classes (e.g., Tailwind). It accepts standard `SVGProps` and shows how attributes like `className` or `stroke` can be applied dynamically.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/assets-and-files.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { SVGProps } from \"react\"\n\nexport const CarIcon = (props: SVGProps) => {\n  return (\n    // 👇 content of your SVG file\n    <svg\n      // highlight-next-line\n      className=\"fill-blue-500\" // 👈 you can use classes, like with tailwind\n      // highlight-next-line\n      stroke={props.strokeColor} // or adjust properties directly\n    // ...\n    </svg>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Success Component Signature with Aliased Prop (JavaScript)\nDESCRIPTION: Exports a JavaScript React functional component named `Success`. It destructures the `articles` prop, which corresponds to the aliased data fetched by the GraphQL query in the RedwoodJS Cell.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nexport const Success = ({ articles }) => { ... }\n```\n\n----------------------------------------\n\nTITLE: Setting the PROJECT Database URL in Environment File (env)\nDESCRIPTION: Defines DATABASE_URL in the .env file, specifying the local Postgres connection string. Sets user as 'postgres', database as 'redwoodblog_dev', and applies a connection limit recommended for serverless environments. This variable is required for Prisma and application database connectivity.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_8\n\nLANGUAGE: env\nCODE:\n```\nDATABASE_URL=\"postgresql://postgres@localhost:5432/redwoodblog_dev?connection_limit=1\"\n```\n\n----------------------------------------\n\nTITLE: Running Specific RedwoodJS API Tests via CLI (Bash)\nDESCRIPTION: This Bash command demonstrates how to run unit tests for a specific function within the API side of a RedwoodJS project using the Yarn package manager and the RedwoodJS CLI (`rw test`). It targets the `updateOrderStatus` function's test file.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn rw test api updateOrderStatus\n```\n```\n\n----------------------------------------\n\nTITLE: Updating Test Scenarios with Realistic Data (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates updating the default `standard` scenario data in `comments.scenarios.js` with more realistic values. It replaces generic 'String' placeholders and default keys (`one`, `two`) with meaningful names (`jane`, `john`) and representative content for comment and post fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.scenarios.js\"\nexport const standard = defineScenario({\n  comment: {\n    // highlight-start\n    jane: {\n      data: {\n        name: 'Jane Doe',\n        body: 'I like trees',\n        post: {\n          create: {\n            title: 'Redwood Leaves',\n            body: 'The quick brown fox jumped over the lazy dog.',\n          },\n        },\n      },\n    },\n    john: {\n      data: {\n        name: 'John Doe',\n        body: 'Hug a tree today',\n        post: {\n          create: {\n            title: 'Root Systems',\n            body: 'The five boxing wizards jump quickly.',\n          },\n        },\n      },\n    },\n    // highlight-end\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Using Self-Closing Label Tag in RedwoodJS Form (HTML)\nDESCRIPTION: Illustrates usage of a self-closing <label> in HTML, utilizing 'name', 'className', and 'errorClassName' props. When rendered by Redwood's forms system, this expands to an accessible label linked to a form field by the 'for' attribute and classed appropriately. Useful in Redwood projects for associating labels to inputs while handling conditional error styling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<label name=\"name\" className=\"input\" errorClassName=\"input error\" />\n\n<!-- Renders: <label for=\"name\" class=\"input\">name</label> -->\n```\n\n----------------------------------------\n\nTITLE: Configuring Production Environment and API Server Command - RedwoodJS - Dockerfile\nDESCRIPTION: This snippet sets NODE_ENV to production and defines the container's default command to launch the API server using the 'rw-server' binary from @redwoodjs/api-server. Comments provide guidance for custom server files and GraphQL Realtime; users may override CMD for alternate launch behaviors. No additional dependencies are required beyond those already installed; relies on node_modules/.bin from prior steps.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_12\n\nLANGUAGE: Dockerfile\nCODE:\n```\nENV NODE_ENV=production\\n\\n# default api serve command\\n# ---------\\n# If you are using a custom server file, you must use the following\\n# command to launch your server instead of the default api-server below.\\n# This is important if you intend to configure GraphQL to use Realtime.\\n#\\n# CMD [ \"./api/dist/server.js\" ]\\nCMD [ \"node_modules/.bin/rw-server\", \"api\" ]\n```\n\n----------------------------------------\n\nTITLE: Streaming Alphabet Data with Repeater - TypeScript\nDESCRIPTION: Provides an async streaming resolver for the alphabet, emitting one letter at a time with one-second delay using Repeater, compatible with RedwoodJS. Employs `@redwoodjs/realtime` Repeater, logs each pushed value, and auto-stops after all values. Handles disposal on cancellation, clearing intervals and logging. Inputs: none; outputs: stream of letters. Dependencies: '@redwoodjs/realtime', 'src/lib/logger'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Repeater } from '@redwoodjs/realtime'\n\nimport { logger } from 'src/lib/logger'\n\nexport const alphabet = async () => {\n  return new Repeater<string>(async (push, stop) => {\n    const values = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n    const publish = () => {\n      const value = values.shift()\n\n      if (value) {\n        logger.debug({ value }, 'publishing')\n\n        push(value)\n      }\n\n      if (values.length === 0) {\n        stop()\n      }\n    }\n\n    const interval = setInterval(publish, 1000)\n\n    stop.then(() => {\n      logger.debug('cancel')\n      clearInterval(interval)\n    })\n\n    publish()\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing useForm for Manual Form Management (TypeScript)\nDESCRIPTION: Calls useForm inside the ContactPage component in TypeScript to get the formMethods object for managing form state. This facilitates operations such as resetting fields and preserving type safety. The result is critical for bridging custom form state handling with Redwood form logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_33\n\nLANGUAGE: tsx\nCODE:\n```\nconst ContactPage = () => {\n  // highlight-next-line\n  const formMethods = useForm()\n  //...\n\n```\n\n----------------------------------------\n\nTITLE: Granting Public Access to Single and Multiple Post Queries in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript version of the GraphQL schema configures both the 'posts' and 'post' queries to use @skipAuth, making them publicly accessible, while keeping all mutations secured with @requireAuth. The schema is suitable for use in RedwoodJS API logic where public content display and secure mutation are both required. Ensure minimal sensitive data is exposed in public queries.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\\n  type Post {\\n    id: Int!\\n    title: String!\\n    body: String!\\n    createdAt: DateTime!\\n  }\\n\\n  type Query {\\n    posts: [Post!]! @skipAuth\\n    // highlight-next-line\\n    post(id: Int!): Post @skipAuth\\n  }\\n\\n  input CreatePostInput {\\n    title: String!\\n    body: String!\\n  }\\n\\n  input UpdatePostInput {\\n    title: String\\n    body: String\\n  }\\n\\n  type Mutation {\\n    createPost(input: CreatePostInput!): Post! @requireAuth\\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\\n    deletePost(id: Int!): Post! @requireAuth\\n  }\\n`\n```\n\n----------------------------------------\n\nTITLE: Constructing AboutPage in RedwoodJS (TypeScript)\nDESCRIPTION: Creates the AboutPage component in TypeScript, leveraging imports from @redwoodjs/router for navigation and @redwoodjs/web for setting document metadata. This version uses JSX with type checking, providing a paragraph about the site and a navigation link. No props are required, and parameters are not expected. Outputs a fragment for rendering. Dependencies: @redwoodjs/router, @redwoodjs/web.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\\nimport { Metadata } from '@redwoodjs/web'\\n\\nconst AboutPage = () => {\\n  return (\\n    <>\\n      <Metadata title=\"About\" description=\"About page\" />\\n\\n      <p>\\n        This site was created to demonstrate my mastery of Redwood: Look on my\\n        works, ye mighty, and despair!\\n      </p>\\n      <Link to={routes.home()}>Return home</Link>\\n    </>\\n  )\\n}\\n\\nexport default AboutPage\n```\n\n----------------------------------------\n\nTITLE: Initializing Edgio Deployment Setup in RedwoodJS (Shell)\nDESCRIPTION: This command initializes the Edgio deployment configuration within a RedwoodJS project. It modifies project files to prepare for deployment to the Edgio platform. Run this command in the project's root directory as the first step.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/edgio.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup deploy edgio\n```\n\n----------------------------------------\n\nTITLE: Launching Prisma Studio with RedwoodJS CLI (Bash)\nDESCRIPTION: This command utilizes the RedwoodJS CLI (`rw`) to start Prisma Studio. Prisma Studio provides a web-based graphical interface for browsing and manipulating data in the database defined by the `schema.prisma` file, useful for development and debugging purposes. It typically opens at http://localhost:5555.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/getting-dynamic.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma studio\n```\n\n----------------------------------------\n\nTITLE: Defining Default and Moderator Comment Stories in Storybook (TSX)\nDESCRIPTION: This TSX snippet defines two Storybook stories for the `Comment` component using TypeScript: `defaultView` and `moderatorView`. Both stories render the `Comment` component with the same initial comment data, providing a typed baseline structure before introducing user role mocking. It imports the `Comment` component and exports named functions representing the stories.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/Comment/Comment.stories.ts\"\nimport Comment from './Comment'\n\n// highlight-next-line\nexport const defaultView = () => {\n  return (\n    <Comment\n      comment={{\n        id: 1,\n        name: 'Rob Cameron',\n        body: 'This is the first comment!',\n        createdAt: '2020-01-01T12:34:56Z',\n        // highlight-next-line\n        postId: 1,\n      }}\n    />\n  )\n}\n\n// highlight-start\nexport const moderatorView = () => {\n  return (\n    <Comment\n      comment={{\n        id: 1,\n        name: 'Rob Cameron',\n        body: 'This is the first comment!',\n        createdAt: '2020-01-01T12:34:56Z',\n        postId: 1,\n      }}\n    />\n  )\n}\n// highlight-end\n\nexport default { title: 'Components/Comment' }\n```\n```\n\n----------------------------------------\n\nTITLE: Rendering ContactPage Form with Server Error Display in RedwoodJS - TypeScript (TSX)\nDESCRIPTION: This snippet offers a TypeScript (TSX) implementation of the ContactPage component with server error handling in a RedwoodJS web application. It includes form setup with type annotations, GraphQL mutation typing, and displays server errors using FormError. Essential dependencies are @redwoodjs/web, @redwoodjs/web/toast, @redwoodjs/forms, and generated GraphQL typings. The onSubmit method leverages type-safe data posting, and error is provided contextually to both Form and FormError for improved error reporting.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_28\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata, useMutation } from '@redwoodjs/web'\\nimport { toast, Toaster } from '@redwoodjs/web/toast'\\nimport {\\n  FieldError,\\n  Form,\\n  // highlight-next-line\\n  FormError,\\n  Label,\\n  TextField,\\n  TextAreaField,\\n  Submit,\\n  SubmitHandler,\\n} from '@redwoodjs/forms'\\n\\nimport {\\n  CreateContactMutation,\\n  CreateContactMutationVariables,\\n} from 'types/graphql'\\n\\nconst CREATE_CONTACT = gql`\\n  mutation CreateContactMutation($input: CreateContactInput!) {\\n    createContact(input: $input) {\\n      id\\n    }\\n  }\\n`\\n\\ninterface FormValues {\\n  name: string\\n  email: string\\n  message: string\\n}\\n\\nconst ContactPage = () => {\\n  const [create, { loading, error }] = useMutation<\\n    CreateContactMutation,\\n    CreateContactMutationVariables\\n  >(CREATE_CONTACT, {\\n    onCompleted: () => {\\n      toast.success('Thank you for your submission!')\\n    },\\n  })\\n\\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\\n    create({ variables: { input: data } })\\n  }\\n\\n  return (\\n    <>\\n      <Metadata title=\"Contact\" description=\"Contact page\" />\\n      <Toaster />\\n      // highlight-start\\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }} error={error}>\\n        <FormError error={error} wrapperClassName=\"form-error\" />\\n        // highlight-end\\n        <Label name=\"name\" errorClassName=\"error\">\\n          Name\\n        </Label>\\n        <TextField\\n          name=\"name\"\\n          validation={{ required: true }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"name\" className=\"error\" />\\n        <Label name=\"email\" errorClassName=\"error\">\\n          Email\\n        </Label>\\n        <TextField\\n          name=\"email\"\\n          validation={{\\n            required: true,\\n          }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"email\" className=\"error\" />\\n        <Label name=\"message\" errorClassName=\"error\">\\n          Message\\n        </Label>\\n        <TextAreaField\\n          name=\"message\"\\n          validation={{ required: true }}\\n          errorClassName=\"error\"\\n        />\\n        <FieldError name=\"message\" className=\"error\" />\\n        <Submit disabled={loading}>Save</Submit>\\n      </Form>\\n    </>\\n  )\\n}\\n\\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Removing Client-Side Email Validation for Testing (TypeScript)\nDESCRIPTION: Modifies the `ContactPage.tsx` component by removing the client-side email `pattern` validation rule from the `<TextField>` for the email field. This alteration is done specifically to test the effectiveness of the server-side validation implemented in the service.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_24\n\nLANGUAGE: diff\nCODE:\n```\n <TextField\n   name=\"email\"\n   validation={{\n     required: true,\n-    pattern: {\n-      value: /^[^@]+@[^.]+\\..+$/,\n-      message: 'Please enter a valid email address',\n-    },\n   }}\n   errorClassName=\"error\"\n />\n\n```\n\n----------------------------------------\n\nTITLE: Handling Required Relation Resolvers with Type Casting (TypeScript)\nDESCRIPTION: This TypeScript snippet shows one option for implementing a resolver for a required relation (`Post.author`) in strict mode. It uses type casting (`as Promise<Author>`) on the result of `db.post.findUnique({ where: { id: root?.id } }).author()`. This approach assumes the related author will always be found because the parent post (`root`) already exists, satisfying the non-nullable requirement.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Option 1: Override the type\n// The typecasting here is OK. `root` is the post that was _already found_\n// by the `post` function in your Services, so `findUnique` will always find it!\nexport const Post: PostRelationResolvers = {\n  author: (_obj, { root }) =>\n    db.post.findUnique({ where: { id: root?.id } }).author() as Promise<Author>, // 👈\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Prisma Schema Changes with RedwoodJS CLI (Bash)\nDESCRIPTION: Command to create and apply a database migration using the RedwoodJS CLI wrapper for Prisma. This command detects changes in the `schema.prisma` file, generates SQL migration files, and applies them to the development database. It prompts the user for a migration name (e.g., \"create identity\").\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Finding Existing User/Identity in findOrCreateUser (JavaScript)\nDESCRIPTION: This part of the `findOrCreateUser` function attempts to locate an existing identity record using `db.identity.findFirst`. It searches based on the provider ('github') and the unique user ID from the provider (`providerUser.id`, converted to string). If an identity is found, it retrieves the associated user record using `db.user.findUnique` based on the `userId` stored in the identity, and returns both the user and identity objects.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst findOrCreateUser = async (providerUser) => {\n  const identity = await db.identity.findFirst({\n    where: { provider: 'github', uid: providerUser.id.toString() },\n  })\n\n  if (identity) {\n    const user = await db.user.findUnique({ where: { id: identity.userId } })\n    return { user, identity }\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Example Fastify Error for Unsupported Content Type\nDESCRIPTION: This JSON snippet shows a sample error response (HTTP 400 Bad Request) from Fastify. This error (`FST_ERR_CTP_INVALID_CONTENT_LENGTH`) typically occurs when trying to POST content with a MIME type that Fastify doesn't support natively or hasn't been configured to handle via a content type parser.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"statusCode\": 400,\n  \"code\": \"FST_ERR_CTP_INVALID_CONTENT_LENGTH\",\n  \"error\": \"Bad Request\",\n  \"message\": \"Request body size did not match Content-Length\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Redwood Root Schema in GraphQL SDL\nDESCRIPTION: This GraphQL Schema Definition Language (SDL) snippet defines the entry point `Query.redwood` to fetch the `Redwood` type. The `Redwood` type contains information about the current user, Prisma version, and Redwood version. It also declares several custom scalar types used within the RedwoodJS framework.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_84\n\nLANGUAGE: graphql\nCODE:\n```\ntype Query {\n  \"Fetches the Redwood root schema.\"\n  redwood: Redwood\n}\n\n\"\"\"\nThe Redwood Root Schema\n\nDefines details about Redwood such as the current user and version information.\n\"\"\"\ntype Redwood {\n  \"The current user.\"\n  currentUser: JSON\n\n  \"The version of Prisma.\"\n  prismaVersion: String\n\n  \"The version of Redwood.\"\n  version: String\n}\n\nscalar BigInt\nscalar Date\nscalar DateTime\nscalar JSON\nscalar JSONObject\nscalar Time\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic RedwoodRecord Model (JavaScript/JSX)\nDESCRIPTION: A minimal JavaScript/JSX example showing how to define a `User` model in `api/src/models/User.js` by extending the base `RedwoodRecord` class imported from `@redwoodjs/record`. This establishes the connection between the model and the corresponding database table.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { RedwoodRecord } from '@redwoodjs/record'\n\nexport default class User extends RedwoodRecord {}\n```\n\n----------------------------------------\n\nTITLE: Customizing Resource Limits for Vercel API Functions in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript snippet exports a config object setting maxDuration and memory usage for a specific serverless API function in a RedwoodJS project deployed to Vercel. The handler function responds to HTTP API calls, logs method and path information using a logger utility, and returns a JSON response. Dependencies include aws-lambda types for event/context and the local Redwood logger; required context is that this code be placed in an API route file within the RedwoodJS api directory. Inputs include standard event/context, and the output is an HTTP JSON response. The config object must be exported at the top level; maxDuration and memory are set in seconds and megabytes respectively.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/vercel.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { APIGatewayEvent, Context } from 'aws-lambda'\\n\\nimport { logger } from 'src/lib/logger'\\n\\nexport const config = {\\n  maxDuration: 30,\\n  memory: 512,\\n}\\n\\nexport const handler = async (event: APIGatewayEvent, _context: Context) => {\\n  logger.info(`\\${event.httpMethod} \\${event.path}: vercel function`)\\n\\n  return {\\n    statusCode: 200,\\n    headers: {\\n      'Content-Type': 'application/json',\\n    },\\n    body: JSON.stringify({\\n      data: 'vercel function',\\n    }),\\n  }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Generating a Weather Cell Component - RedwoodJS - Bash\nDESCRIPTION: Uses the RedwoodJS CLI to generate the boilerplate for a new Cell component named 'weather'. This command sets up standard files for a Redwood Cell, which simplifies GraphQL data fetching and UI state management. No input required, just run inside a RedwoodJS project; after execution, a new folder for WeatherCell with the necessary template is created.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw generate cell weather\n```\n\n----------------------------------------\n\nTITLE: Refactoring RedwoodJS AboutPage Component (TypeScript/TSX)\nDESCRIPTION: Shows the simplified `AboutPage` component in TypeScript (TSX) after extracting shared elements to the `BlogLayout`. The component focuses solely on rendering the 'About' page content, a paragraph, a link, and the `Metadata` component. It imports `Link` and `routes` for navigation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <>\n      <Metadata title=\"About\" description=\"About page\" />\n\n      <p>\n        This site was created to demonstrate my mastery of Redwood: Look on my\n        works, ye mighty, and despair!\n      </p>\n      <Link to={routes.home()}>Return home</Link>\n    </>\n  )\n}\n\nexport default AboutPage\n```\n\n----------------------------------------\n\nTITLE: Adding a Package to the API Workspace - Bash\nDESCRIPTION: Installs a new package in the 'api' (backend) workspace using 'yarn workspace api add package-name'. This confines the new dependency to the backend side, following RedwoodJS workspace conventions. Ensure that 'package-name' is replaced with the package to be installed and that workspaces are correctly configured. Dependencies are available only in the 'api' subdirectory after installation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-yarn.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace api add package-name\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of RedwoodJS Directives on Input Types (GraphQL)\nDESCRIPTION: Shows an incorrect example of attempting to apply directives (`@maskedEmail`, `@requireAuth`) to fields within a GraphQL `Input` type (`UserExampleInput`). RedwoodJS directives can only be declared on `FIELD_DEFINITION` locations (like fields on Types, Queries, or Mutations), not on `INPUT_FIELD_DEFINITION` locations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_11\n\nLANGUAGE: graphql\nCODE:\n```\ninput UserExampleInput {\n  email: String! @maskedEmail # 👈 🙅 not allowed on an input\n  name: String! @requireAuth # 👈 🙅 also not allowed on an input\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a RedwoodJS Blog Layout Component (TypeScript/TSX)\nDESCRIPTION: Defines the `BlogLayout` functional component in TypeScript (TSX). It includes type definitions for its props (`BlogLayoutProps`). Similar to the JavaScript version, it imports `Link` and `routes` for navigation, provides a shared `<header>`, and renders page-specific content passed via the `children` prop within the `<main>` tag.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-next-line\nimport { Link, routes } from '@redwoodjs/router'\n\ntype BlogLayoutProps = {\n  children?: React.ReactNode\n}\n\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\n  return (\n    // highlight-start\n    <>\n      <header>\n        <h1>Redwood Blog</h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n    // highlight-end\n  )\n}\n\nexport default BlogLayout\n```\n\n----------------------------------------\n\nTITLE: Implementing the Comment Form Component (TSX)\nDESCRIPTION: This snippet shows the TypeScript (TSX) implementation of the `CommentForm` React component. It's functionally identical to the JSX version, using RedwoodJS form helpers (`Form`, `Label`, `TextField`, `TextAreaField`, `Submit`) for the 'Name' and 'Comment' fields, Tailwind CSS for styling, and basic `required` validation. This version benefits from TypeScript's static typing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/CommentForm/CommentForm.tsx\"\nimport { Form, Label, TextField, TextAreaField, Submit } from '@redwoodjs/forms'\n\nconst CommentForm = () => {\n  return (\n    <div>\n      <h3 className=\"font-light text-lg text-gray-600\">Leave a Comment</h3>\n      <Form className=\"mt-4 w-full\">\n        <Label name=\"name\" className=\"block text-sm text-gray-600 uppercase\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          className=\"block w-full p-1 border rounded text-xs\"\n          validation={{ required: true }}\n        />\n\n        <Label\n          name=\"body\"\n          className=\"block mt-4 text-sm text-gray-600 uppercase\"\n        >\n          Comment\n        </Label>\n        <TextAreaField\n          name=\"body\"\n          className=\"block w-full p-1 border rounded h-24 text-xs\"\n          validation={{ required: true }}\n        />\n\n        <Submit className=\"block mt-4 bg-blue-500 text-white text-xs font-semibold uppercase tracking-wide rounded px-3 py-2 disabled:opacity-50\">\n          Submit\n        </Submit>\n      </Form>\n    </div>\n  )\n}\n\nexport default CommentForm\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Storybook Stories for Comment Component - React (JavaScript)\nDESCRIPTION: Defines two stories, defaultView and moderatorView, for rendering the Comment component in Storybook using JavaScript. The stories supply hardcoded comment data to simulate different UI states. There are no external dependencies except for Comment itself, and the default export registers the stories under 'Components/Comment'. Each story expects comment data as input and renders the corresponding React element.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\nimport Comment from './Comment'\\n\\n// highlight-next-line\\nexport const defaultView = () => {\\n  return (\\n    <Comment\\n      comment={{\\n        id: 1,\\n        name: 'Rob Cameron',\\n        body: 'This is the first comment!',\\n        createdAt: '2020-01-01T12:34:56Z',\\n        // highlight-next-line\\n        postId: 1\\n      }}\\n    />\\n  )\\n}\\n\\n// highlight-start\\nexport const moderatorView = () => {\\n  return (\\n    <Comment\\n      comment={{\\n        id: 1,\\n        name: 'Rob Cameron',\\n        body: 'This is the first comment!',\\n        createdAt: '2020-01-01T12:34:56Z',\\n        postId: 1,\\n      }}\\n    />\\n  )\\n}\\n// highlight-end\\n\\nexport default { title: 'Components/Comment' }\n```\n\n----------------------------------------\n\nTITLE: Aliasing GraphQL Query Results in Cell (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to alias a GraphQL query result within the cell's `QUERY` using `articles: posts`. This means the data fetched via the `posts` field in the schema will be accessible as the `articles` prop within the `Success` component. The associated TypeScript types (`ArticlesQuery`, `CellSuccessProps`) would need to reflect this aliased structure, typically handled by type generation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> = // highlight-line\n  gql`\n    query ArticlesQuery {\n      // highlight-next-line\n      articles: posts {\n        id\n      }\n    }\n  `\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring Environment Variables in .env - Text\nDESCRIPTION: Defines an environment variable named PUBLIC_KEY in a .env file. This key can subsequently be included in redwood.toml via the includeEnvironmentVariables setting. No external dependencies, but do not store secrets if you plan to expose them client-side.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nPUBLIC_KEY=...\n```\n\n----------------------------------------\n\nTITLE: Initializing useForm for Manual Form Management (JavaScript)\nDESCRIPTION: Invokes the useForm hook within the ContactPage component to obtain formMethods, which manages form state manually. This enables explicit control over the form, including resetting fields after submission. The returned formMethods object should be passed to the Form component to ensure validation and state synchronization.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_32\n\nLANGUAGE: jsx\nCODE:\n```\nconst ContactPage = () => {\n  // highlight-next-line\n  const formMethods = useForm()\n  //...\n\n```\n\n----------------------------------------\n\nTITLE: Handling Basic Form Submission in RedwoodJS (JavaScript)\nDESCRIPTION: This snippet demonstrates how to define an `onSubmit` function in a React component using RedwoodJS. The function receives the form data as an object and logs it to the console. The `<Form>` component from `@redwoodjs/forms` is configured to use this handler.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport { Form, TextField, Submit } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  // highlight-start\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n  // highlight-end\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      // highlight-next-line\n      <Form onSubmit={onSubmit}>\n        <TextField name=\"input\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Self-Relation in Prisma Schema\nDESCRIPTION: This Prisma schema snippet defines a self-referencing relationship within the `Employee` model to represent an organizational hierarchy (OrgChart). It uses optional fields (`?`) for `reportsToId`, `reportsTo`, and `directReports` to indicate that an employee may not have a direct report or someone they report to (e.g., the President). Making these fields optional is crucial for compatibility with RedwoodJS generators.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/schema-relations.md#_snippet_9\n\nLANGUAGE: prisma\nCODE:\n```\nmodel Employee {\n  id            Int       @id @default(autoincrement())\n  name          String\n  jobTitle      String\n  // highlight-start\n  reportsToId   Int?      @unique\n  reportsTo     Employee? @relation(\"OrgChart\", fields: [reportsToId], references: [id])\n  directReports Employee? @relation(\"OrgChart\")\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Using Child Loggers to Add Contextual Information (JavaScript)\nDESCRIPTION: Illustrates how to create and use logger.child to inject request-specific details into every log line, especially in GraphQL resolvers. Child loggers can carry metadata, such as GraphQL path or parameters, supporting better traceability and structured logging. Returns query results from Prisma client and demonstrates advanced log usage.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_30\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\nimport { logger } from 'src/lib/logger'\n\nexport const userExamples = ({}, { info }) => {\n  // Adds path to the log\n  const childLogger = logger.child({ path: info.fieldName })\n  childLogger.trace('I am in find many user examples resolver')\n  return db.userExample.findMany()\n}\n\nexport const userExample = async ({ id }, { info }) => {\n  // Adds id and the path to the log\n  const childLogger = logger.child({ id, path: info.fieldName })\n  childLogger.trace('I am in the find a user example by id resolver')\n  const result = await db.userExample.findUnique({\n    where: { id },\n  })\n\n  // Since this is the child logger, here id and path will be included as well\n  childLogger.debug({ ...result }, 'This is the detail for the user')\n\n  return result\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Comments Service: Match Comment Count with DB by postId - TypeScript (TSX test)\nDESCRIPTION: In this TypeScript unit test, the service's comments query with a specific postId is validated against the actual comment count in the database, using Prisma's client. It imports type definitions and ensures the returned array's length matches the stored comments for the correct post in a StandardScenario setup. Dependencies include Prisma and correct TypeScript types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { comments, createComment } from './comments'\\n// highlight-next-line\\nimport { db } from 'src/lib/db'\\n\\nimport type { StandardScenario } from './comments.scenarios'\\n\\ndescribe('comments', () => {\\n  scenario('returns all comments', async (scenario) => {\\n    const result = await comments({ postId: scenario.comment.jane.postId })\\n    // highlight-start\\n    const post = await db.post.findUnique({\\n      where: { id: scenario.comment.jane.postId },\\n      include: { comments: true },\\n    })\\n    expect(result.length).toEqual(post.comments.length)\\n    // highlight-end\\n  })\\n\\n  // ...\\n})\n```\n\n----------------------------------------\n\nTITLE: Deploying RedwoodJS to Serverless (AWS)\nDESCRIPTION: This command deploys a RedwoodJS application to AWS CloudFront and Lambda using the Serverless framework. It requires `yarn` and the RedwoodJS CLI. Options allow specifying sides (api/web), deployment stage, packaging only, and configuring the first run.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood deploy serverless\n```\n\n----------------------------------------\n\nTITLE: Initial WeatherCell Component with Basic GraphQL Query - RedwoodJS - JSX\nDESCRIPTION: Defines the structure of the WeatherCell component, including its GraphQL query, and components for loading, empty, failure, and success states. It declares the base query to fetch weather by ID, uses Redwood Cell conventions, and includes basic UI for each state. Requires RedwoodJS, GraphQL setup, and the appropriate 'gql' tag; expects a weather 'id' as input and returns a weather object or error, displaying state accordingly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query FindWeatherQuery($id: Int!) {\n    weather: weather(id: $id) {\n      id\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({ weather }) => {\n  return <div>{JSON.stringify(weather)}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Running RedwoodJS Auth0 Setup Command (Bash)\nDESCRIPTION: Executes the RedwoodJS CLI command to automatically set up Auth0 authentication. This command installs required packages, generates necessary files, and modifies existing code to integrate Auth0.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/auth0.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup auth auth0\n```\n\n----------------------------------------\n\nTITLE: Validating Email Format in RedwoodJS Forms using Pattern Matching in JavaScript\nDESCRIPTION: Adds email format validation to the contact form's email field in RedwoodJS by specifying a regex pattern requirement and associated error message. Relies on the 'pattern' property within Field validation, enforcing that the user inputs a valid-like email. Depends on prior form setup. The 'pattern' parameter is a regular expression; the message parameter customizes the UI string shown on validation error. Required for client-side correctness but not a substitute for full backend email validation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_31\n\nLANGUAGE: jsx\nCODE:\n```\n<TextField\n  name=\"email\"\n  validation={{\n    required: true,\n    // highlight-start\n    pattern: {\n      value: /^[^@]+@[^.]+\\..+$/,\n      message: 'Please enter a valid email address',\n    },\n    // highlight-end\n  }}\n  errorClassName=\"error\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Testing with Data Included via RedwoodJS Scenarios\nDESCRIPTION: This test snippet demonstrates accessing related data that was loaded using the `include` option in the scenario definition. It retrieves a comment using `commentWithPost` (assuming this function fetches the comment with its post) and then directly accesses and asserts against properties of the included post (`scenario.comment.first.post.title`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_62\n\nLANGUAGE: javascript\nCODE:\n```\nscenario('retrieves a comment with post', async (scenario) => {\n  const comment = await commentWithPost({ id: scenario.comment.first.id })\n\n  expect(comment.post.title).toEqual(scenario.comment.first.post.title)\n})\n```\n\n----------------------------------------\n\nTITLE: Usage of Custom Error Class in RedwoodJS Service - TypeScript/TSX\nDESCRIPTION: This TSX code defines and uses a custom error class (WeatherError) extending RedwoodError. The getWeather service function demonstrates throwing contextual errors for both specific (rate limits) and generic failures using WeatherError, with user-friendly messages. Dependencies include RedwoodError and a weatherClient. Inputs include an input object with zipCode property.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_81\n\nLANGUAGE: typescript\nCODE:\n```\nexport class WeatherError extends RedwoodError {\n  constructor(message: string, extensions?: Record<string, any>) {\n    super(message, extensions)\n  }\n}\n\nexport const getWeather = async ({ input }: WeatherInput) {\n  try {\n    const weather = weatherClient.get(input.zipCode)\n  } catch(error) {\n    // rate limit issue\n    if (error.statusCode = 429) {\n      throw new WeatherError('Unable to get the latest weather updates at the moment. Please try again shortly.')\n    }\n\n    // other error\n    throw new WeatherError(`We could not get the weather for ${input.zipCode}.`)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying TypeScript Types to mockGraphQLQuery using Inline Types\nDESCRIPTION: Shows an alternative way to provide TypeScript types to `mockGraphQLQuery` by defining the expected result structure inline using generic type parameters. This avoids the need for separate type imports if the structure is simple or specific to the mock.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/mocking-graphql-requests.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nmockGraphQLQuery <\n  {\n    userProfile: {\n      __typename: 'UserProfile' as const,\n      id: number,\n      name: string,\n    },\n  } >\n  ('UserProfileQuery',\n  {\n    /*... */\n  })\n```\n\n----------------------------------------\n\nTITLE: Typing Basic Validator Directive Function with ValidatorDirectiveFunc (TypeScript)\nDESCRIPTION: Illustrates applying the `ValidatorDirectiveFunc` type to the `validate` function when creating a custom Redwood validator directive using `createValidatorDirective`. This ensures that the function's arguments, specifically `context` and `directiveArgs`, are correctly typed based on the GraphQL execution context and the arguments defined in the directive's SDL. Depends on `@redwoodjs/graphql-server`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nexport const schema = gql`\n  directive @myValidator on FIELD_DEFINITION\n`\n// 👇 makes sure \"context\" and directive args are typed\n// highlight-next-line\nconst validate: ValidatorDirectiveFunc = ({ context, directiveArgs }) => {\n```\n\n----------------------------------------\n\nTITLE: Resetting RedwoodJS Database (Bash)\nDESCRIPTION: This command resets the database using the RedwoodJS CLI and Prisma. Database seeds are run every time the database is reset with this command.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/database-seeds.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate reset\n```\n\n----------------------------------------\n\nTITLE: Defining Default Test Scenarios for Comments (TypeScript)\nDESCRIPTION: This TypeScript snippet shows the default scenario definition for the `comments` service, typically in `comments.scenarios.ts`. It utilizes Redwood's `defineScenario` with Prisma type imports (`Prisma.CommentCreateArgs`) for type safety. It exports a `standard` scenario with seed data for `comment` and related `post` models, intended for use in service tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/services/comments.scenarios.ts\"\nimport type { Prisma } from '@prisma/client'\n\nexport const standard = defineScenario<Prisma.CommentCreateArgs>({\n  comment: {\n    one: {\n      data: {\n        name: 'String',\n        body: 'String',\n        post: { create: { title: 'String', body: 'String' } },\n      },\n    },\n    two: {\n      data: {\n        name: 'String',\n        body: 'String',\n        post: { create: { title: 'String', body: 'String' } },\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Invoking RedwoodJS Functions Locally with Netlify CLI (Bash)\nDESCRIPTION: These shell commands outline the process for testing RedwoodJS serverless functions (like Netlify Identity triggers) locally during development. It involves installing the Netlify CLI globally, rebuilding the API side of the Redwood app after changes, and then using `netlify functions:invoke` to trigger a specific function, pointing it to the running development server port (usually 8910).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n# Install the cli\\nyarn add netlify-cli -g\\n\\n# Rebuild api after any changes to /functions\\nyarn rw build api\\n\\n# Invoke your function with the CLI, pointing it to the rw dev port\\nnetlify functions:invoke 8910 < function-name > --port\n```\n\n----------------------------------------\n\nTITLE: User Model with Default Role in Prisma Schema - JavaScript\nDESCRIPTION: Updates the Prisma schema's User model to provide a default role of 'moderator'. This ensures that all users have a role assigned upon creation and allows safe schema migrations even with pre-existing users. Dependencies: Prisma. The roles field is a string defaulted to 'moderator', which limits privileges by default and avoids null field issues.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nmodel User {\n  id                  Int @id @default(autoincrement())\n  name                String?\n  email               String @unique\n  hashedPassword      String\n  salt                String\n  resetToken          String?\n  resetTokenExpiresAt DateTime?\n  // highlight-next-line\n  roles               String @default(\"moderator\")\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating WebAuthnClient in RedwoodJS Web App (JSX)\nDESCRIPTION: This snippet demonstrates how to integrate the `WebAuthnClient` into the main `App.js` component of a RedwoodJS web application (`web/src/App.js`). It involves importing `WebAuthnClient` from `@redwoodjs/auth-dbauth-web/webAuthn` and passing it as the `client` prop to the `<AuthProvider>` component, alongside specifying the `type` as `\"dbAuth\"`. This step makes WebAuthn client-side functionality available throughout the application, enabling interactions like device registration and authentication prompts. Dependencies include `@redwoodjs/auth` and `@redwoodjs/auth-dbauth-web/webAuthn`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/App.js\"\nimport { AuthProvider } from '@redwoodjs/auth'\n// highlight-start\nimport WebAuthnClient from '@redwoodjs/auth-dbauth-web/webAuthn'\n// highlight-end\nimport { FatalErrorBoundary, RedwoodProvider } from '@redwoodjs/web'\nimport { RedwoodApolloProvider } from '@redwoodjs/web/apollo'\n\nimport FatalErrorPage from 'src/pages/FatalErrorPage'\nimport Routes from 'src/Routes'\n\nimport './scaffold.css'\nimport './index.css'\n\nconst App = () => (\n  <FatalErrorBoundary page={FatalErrorPage}>\n    <RedwoodProvider titleTemplate=\"%PageTitle | %AppTitle\">\n      // highlight-start\n      <AuthProvider type=\"dbAuth\" client={WebAuthnClient}>\n      // highlight-end\n        <RedwoodApolloProvider>\n          <Routes />\n        </RedwoodApolloProvider>\n      </AuthProvider>\n    </RedwoodProvider>\n  </FatalErrorBoundary>\n)\n\nexport default App\n```\n```\n\n----------------------------------------\n\nTITLE: Passing formMethods to RedwoodJS Form Component (JavaScript)\nDESCRIPTION: Renders the Form component with the formMethods prop supplied, thus connecting the manually initialized useForm context to the form. This integration is essential to maintain full functionality, including validation and state management, when handling the form lifecycle outside Redwood's default setup. The code snippet shows Form setup with configuration for 'onBlur' mode and error handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_34\n\nLANGUAGE: jsx\nCODE:\n```\nreturn (\n  <>\n    <Toaster />\n    <Form\n      onSubmit={onSubmit}\n      config={{ mode: 'onBlur' }}\n      error={error}\n      // highlight-next-line\n      formMethods={formMethods}\n    >\n    // ...\n\n```\n\n----------------------------------------\n\nTITLE: Building the Web Side with Prerender, Based on api_build - RedwoodJS - Dockerfile\nDESCRIPTION: This snippet defines a multi-stage Docker build for the web_prerender_build stage by using the api_build image as its base. It copies the web directory and builds the web side with full prerendering enabled using 'yarn rw build web'. This is required for SSR or SSG features that fetch data from the API during build time. It assumes the api_build stage was built and has all required server assets and dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_14\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM api_build as web_build_with_prerender\\n\\nCOPY --chown=node:node web web\\nRUN yarn rw build web\n```\n\n----------------------------------------\n\nTITLE: Testing a Custom Hook with renderHook and Jest in RedwoodJS (JS)\nDESCRIPTION: This snippet presents a Jest test suite for the `useAccumulator` custom hook using `renderHook` from `@redwoodjs/testing/web`. It includes tests for verifying the initial state, testing the `add` function's effect on the state, handling multiple additions, and testing the hook's behavior when re-rendered with different initial props using the `rerender` function returned by `renderHook`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_34\n\nLANGUAGE: js\nCODE:\n```\n```js title=\"web/src/hooks/useAccumulator/useAccumulator.test.js\"\nimport { renderHook } from '@redwoodjs/testing/web'\nimport { useAccumulator } from './useAccumulator'\n\ndescribe('useAccumulator hook example in docs', () => {\n  it('has the correct initial state', () => {\n    const { result } = renderHook(() => useAccumulator(42))\n    expect(result.current.total).toBe(42)\n  })\n\n  it('adds a value', () => {\n    const { result } = renderHook(() => useAccumulator(1))\n    result.current.add(5)\n    expect(result.current.total).toBe(6)\n  })\n\n  it('adds multiple values', () => {\n    const { result } = renderHook(() => useAccumulator(0))\n    result.current.add(5)\n    result.current.add(10)\n    expect(result.current.total).toBe(15)\n  })\n\n  it('re-initializes the accumulator if passed a new initializing value', () => {\n    const { result, rerender } = renderHook(\n      (initialValue) => useAccumulator(initialValue),\n      {\n        initialProps: 0,\n      }\n    )\n    result.current.add(5)\n    rerender(99)\n    expect(result.current.total).toBe(99)\n  })\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up GraphQL Fragments in RedwoodJS - Bash\nDESCRIPTION: This setup command initializes support for GraphQL Fragments within a RedwoodJS application, updating configuration and generating required files like possibleTypes.ts. Precondition is a functioning RedwoodJS project infrastructure. The command installs packages, updates project configurations, and creates example code if appropriate. Overwrites are possible with --force; input is implicit. The operation is designed to streamline GraphQL fragment usage in the app.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_120\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup graphql fragments\n```\n\n----------------------------------------\n\nTITLE: Logging a Custom Object Payload with RedwoodJS Logger in TSX\nDESCRIPTION: Shows how to log a structured custom object containing specific fields (title, commentCount) from a `post` object using the `logger.debug` method in RedwoodJS. Assumes `logger` and `post` (with `title`, `commentCount`) exist.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nlogger.debug(\n  {\n    custom: {\n      title: post.title,\n      comments: post.commentCount,\n    },\n  },\n  'Post with count of comments'\n)\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Development Server (bash)\nDESCRIPTION: This snippet starts the RedwoodJS development server, launching both the API and web sides for local development. The application becomes accessible at the designated local port, typically http://localhost:8910.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw dev\n```\n\n----------------------------------------\n\nTITLE: Spacing CommentsCell with Tailwind in Article Component - TypeScript\nDESCRIPTION: This is the TypeScript version for adding vertical space between the article body and CommentsCell using a “mt-12” Tailwind class in the Article component. It expects props matching the previous TypeScript samples, and is aimed at improving UI spacing. Type imports and Tailwind CSS are necessary dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nconst Article = ({ article, summary = false }: Props) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      // highlight-start\n      {!summary && (\n        <div className=\"mt-12\">\n          <CommentsCell />\n        </div>\n      )}\n      // highlight-end\n    </article>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a RedwoodJS Layout to Routes using Set (JavaScript/JSX)\nDESCRIPTION: Demonstrates configuring routes in `web/src/Routes.jsx` to use the `BlogLayout`. It imports the `Set` component from `@redwoodjs/router` and the `BlogLayout`. The `<Set>` component wraps the `Route` definitions for `HomePage` and `AboutPage`, applying the `BlogLayout` to both via the `wrap` prop.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-start\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport BlogLayout from 'src/layouts/BlogLayout'\n// highlight-end\n\nconst Routes = () => {\n  return (\n    <Router>\n      // highlight-start\n      <Set wrap={BlogLayout}>\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      // highlight-end\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Generating GraphQL Document AST with Hash in TypeScript\nDESCRIPTION: This snippet from `web/src/graphql/graphql.ts` displays the generated Abstract Syntax Tree (AST) for the `FindPosts` query (`FindPostsDocument`). Crucially, it includes a `__meta__` property containing the SHA-256 hash (`76308e971322b1ece4cdff75185bb61d7139e343`) associated with this specific query. This generated code allows the GraphQL client to reference the query and retrieve its hash for persisted query requests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n// ...\nexport const FindPostsDocument = {\n  __meta__: { hash: '76308e971322b1ece4cdff75185bb61d7139e343' },\n  kind: 'Document',\n  definitions: [\n    {\n      kind: 'OperationDefinition',\n      operation: 'query',\n      name: { kind: 'Name', value: 'FindPosts' },\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: [\n          { kind: 'Field', name: { kind: 'Name', value: '__typename' } },\n          {\n            kind: 'Field',\n            name: { kind: 'Name', value: 'posts' },\n            selectionSet: {\n              kind: 'SelectionSet',\n              selections: [\n                { kind: 'Field', name: { kind: 'Name', value: '__typename' } },\n                { kind: 'Field', name: { kind: 'Name', value: 'id' } },\n                { kind: 'Field', name: { kind: 'Name', value: 'title' } },\n                { kind: 'Field', name: { kind: 'Name', value: 'body' } },\n                { kind: 'Field', name: { kind: 'Name', value: 'authorId' } },\n                { kind: 'Field', name: { kind: 'Name', value: 'createdAt' } },\n              ],\n            },\n          },\n        ],\n      },\n    },\n  ],\n} as unknown as DocumentNode<FindPostsQuery, FindPostsQueryVariables>\n// ...\n```\n\n----------------------------------------\n\nTITLE: Installing Yarn Globally via npm - Bash\nDESCRIPTION: This command uses npm to globally install the Yarn package manager, which is required for RedwoodJS projects. It assumes npm is installed and available in PATH, usually after following the Node.js setup steps in this guide. No parameters are needed. After completion, the global 'yarn' command will be available in the environment; a successful installation prints version details or a 'success' message.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/windows-development-setup.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -g yarn\n```\n\n----------------------------------------\n\nTITLE: Defining armorConfig for maxTokens Limitation - TypeScript\nDESCRIPTION: This TypeScript object configures a GraphQL security setting to limit the number of tokens permitted in a query. The maxTokens.n attribute specifies the maximum allowed tokens and can be adjusted to enforce stricter limits, triggering an error upon excess. The snippet is typically passed to the handler factory for API protection.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\nconst armorConfig = {\n  maxTokens: { n: 2 },\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Home Page Component - RedwoodJS - JavaScript (JSX)\nDESCRIPTION: This is a RedwoodJS page component generated by the CLI, displaying a simple heading and a message indicating the file's location. No dependencies aside from standard RedwoodJS project structure. The component takes no parameters and outputs a React JSX component. Exported as default.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_59\n\nLANGUAGE: jsx\nCODE:\n```\nconst HomePage = () => {\n  return (\n    <div>\n      <h1>HomePage</h1>\n      <p>Find me in ./web/src/pages/HomePage/HomePage.js</p>\n    </div>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Passing formMethods to RedwoodJS <Form> Component (TS)\nDESCRIPTION: Illustrates how to pass the `formMethods` object (obtained from `useForm`) to the `formMethods` prop of the RedwoodJS `<Form>` component in TypeScript (`.tsx`). This connects the manually invoked hook with the form component, ensuring validation and other functionalities work correctly while allowing access to extended methods.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_38\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nreturn (\n  <>\n    <Toaster />\n    <Form\n      onSubmit={onSubmit}\n      config={{ mode: 'onBlur' }}\n      error={error}\n      // highlight-next-line\n      formMethods={formMethods}\n    >\n    // ...\n```\n```\n\n----------------------------------------\n\nTITLE: Displaying Toast Notification on Mutation Completion in RedwoodJS (JavaScript)\nDESCRIPTION: This JSX snippet shows how to implement a success notification using `react-hot-toast` in a RedwoodJS contact page after a GraphQL mutation (`CREATE_CONTACT`) completes. It imports `toast` and `Toaster` from `@redwoodjs/web/toast`, adds an `onCompleted` callback to the `useMutation` hook to invoke `toast.success()`, and includes the `<Toaster>` component in the render output to display notifications.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata, useMutation } from '@redwoodjs/web'\n// highlight-next-line\nimport { toast, Toaster } from '@redwoodjs/web/toast'\nimport {\n  FieldError,\n  Form,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst CREATE_CONTACT = gql`\n  mutation CreateContactMutation($input: CreateContactInput!) {\n    createContact(input: $input) {\n      id\n    }\n  }\n`\n\nconst ContactPage = () => {\n  // highlight-start\n  const [create, { loading, error }] = useMutation(CREATE_CONTACT, {\n    onCompleted: () => {\n      toast.success('Thank you for your submission!')\n    },\n  })\n  // highlight-end\n\n  const onSubmit = (data) => {\n    create({ variables: { input: data } })\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      // highlight-next-line\n      <Toaster />\n      <Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        <TextField\n          name=\"email\"\n          validation={{\n            required: true,\n            pattern: {\n              value: /^[^@]+@[^.]+\\..+$/,\n              message: 'Please enter a valid email address',\n            },\n          }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <Label name=\"message\" errorClassName=\"error\">\n          Message\n        </Label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit disabled={loading}>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Page using CLI (Bash)\nDESCRIPTION: Uses the RedwoodJS CLI command `generate page` (aliased as `g page`) to create a new page component named 'HomePage' accessible at the root route ('/'). This serves as a location to test the Auth0 integration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/auth0.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g page home /\n```\n\n----------------------------------------\n\nTITLE: Defining getUser Helper Function (JavaScript)\nDESCRIPTION: The `getUser` asynchronous helper function receives the provider user details, access token, and scope. It calls `findOrCreateUser` to get the local user and identity records. Regardless of whether the user was found or created, it updates the corresponding identity record with the latest access token, scope, and sets the `lastLoginAt` timestamp using `db.identity.update`. Finally, it returns the user object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst getUser = async ({ providerUser, accessToken, scope }) => {\n  const { user, identity } = await getOrCreateUser(providerUser)\n\n  await db.identity.update({\n    where: { id: identity.id },\n    data: { accessToken, scope, lastLoginAt: new Date() },\n  })\n\n  return user\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Heroicons v1.0.6 to RedwoodJS Web Workspace (bash)\nDESCRIPTION: This snippet installs @heroicons/react version 1.0.6 into the web workspace using Yarn workspaces. It provides access to scalable vector icons for use within the project's UI components.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace web add @heroicons/react@1.0.6\n```\n\n----------------------------------------\n\nTITLE: Defining Mock Comments Data for CommentsCell in RedwoodJS (JavaScript)\nDESCRIPTION: This snippet defines the standard mock data provider function for CommentsCell unit tests in JavaScript. It exports a function returning an array of comment objects, each containing required fields such as id, name, body, postId, and createdAt. The data aligns with the GraphQL query schema, and is critical for proper operation of the CommentsCell component in test environments. Intended as mock data only, it does not require post sub-objects or additional context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = () => ({\\n  comments: [\\n    {\\n      id: 1,\\n      name: 'Rob Cameron',\\n      body: 'First comment',\\n      // highlight-next-line\\n      postId: 1,\\n      createdAt: '2020-01-02T12:34:56Z',\\n    },\\n    {\\n      id: 2,\\n      name: 'David Price',\\n      body: 'Second comment',\\n      // highlight-next-line\\n      postId: 2,\\n      createdAt: '2020-02-03T23:00:00Z',\\n    },\\n  ],\\n})\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Development Server - Bash\nDESCRIPTION: Starts the RedwoodJS development server for local development and testing. Runs the web and API sides together. Requires the project to be set up as per previous steps.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw dev\n```\n\n----------------------------------------\n\nTITLE: Adding a File Input Field to a RedwoodJS Form\nDESCRIPTION: Demonstrates incorporating a file input into a RedwoodJS form component (`ProfileForm`) using the `FileField` component from `@redwoodjs/forms`. This component renders an HTML `<input type=\"file\">` element that is integrated with the form's state management, making it easier to capture and submit file data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/ProfileForm.tsx\"\n// highlight-next-line\nimport { FileField, TextField, FieldError } from '@redwoodjs/forms'\n\nexport const ProfileForm = ({ onSubmit }) => {\n  return {\n    <Form onSubmit={onSubmit}>\n      <Label name=\"firstName\" /*...*/ >\n        First name\n      </Label>\n      <TextField name=\"firstName\" /*...*/ />\n      <FieldError name=\"firstName\"  />\n\n      <Label name=\"lastName\" /*...*/ >\n        Last name\n      </Label>\n      <TextField name=\"lastName\" /*...*/ />\n      <FieldError name=\"lastName\"  />\n\n      // highlight-next-line\n      <FileField name=\"avatar\" /*...*/ />\n    </Form>\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Sample Output: Redwood API Dev Server Launch - Bash\nDESCRIPTION: Exemplifies the startup sequence for the API development server, listing port, local path, and successful launch messages. Dependencies: Correctly configured Redwood project. Inputs: Command invocation. Output: URLs and server status. Limitation: Output may vary depending on configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood dev api\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood dev api\n$ /redwood-app/node_modules/.bin/dev-server\n15:04:51 api | Listening on http://localhost:8911\n15:04:51 api | Watching /home/dominic/projects/redwood/redwood-app/api\n15:04:51 api \\\n  | 15:04:51 api | Now serving\n15:04:51 api \\\n  | 15:04:51 api | ► http://localhost:8911/graphql/\n```\n\n----------------------------------------\n\nTITLE: Creating Application Directory and Setting Permissions (Bash)\nDESCRIPTION: Shows commands to create a deployment directory ('/var/www/myapp') and change its ownership to the deployment user ('deploy'), crucial for write/read/execute access during deployments. These commands require sudo permissions and are typically run on the deployment server.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nsudo mkdir -p /var/www/myapp\nsudo chown deploy:deploy /var/www/myapp\n\n```\n\n----------------------------------------\n\nTITLE: Installing pino-logflare in RedwoodJS (bash)\nDESCRIPTION: Demonstrates the installation of the pino-logflare package in the 'api' workspace of a RedwoodJS project using Yarn. Required before importing and configuring the logger transport. This is a setup command for dependency management, not a runnable script within the application code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace api add pino-logflare\n```\n\n----------------------------------------\n\nTITLE: Logging an Entire Object as Custom Payload with RedwoodJS Logger in TSX\nDESCRIPTION: Example of logging the complete `post` object under the `custom` key using `logger.debug` in RedwoodJS. This provides full context but might log sensitive data if not redacted. Assumes `logger` and `post` exist.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nlogger.debug(\n  {\n    custom: post,\n  },\n  'Post details'\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Routes to Include the Contact Page (JavaScript)\nDESCRIPTION: This code snippet shows how to register the new 'contact' route in the Routes file using JavaScript. It demonstrates grouping routes by common layout (ScaffoldLayout for posts, BlogLayout for the public blog) and explicitly assigns the ContactPage component to the '/contact' path. Dependencies include '@redwoodjs/router'. Input: None; Output: Route definitions for the SPA. Ensure ContactPage appears within the correct layout context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n        <Route path=\"/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n        <Route path=\"/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n        <Route path=\"/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n        <Route path=\"/posts\" page={PostPostsPage} name=\"posts\" />\n      </Set>\n      <Set wrap={BlogLayout}>\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n        // highlight-next-line\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Defining Default and Moderator Comment Stories in Storybook (JSX)\nDESCRIPTION: This JSX snippet defines two Storybook stories for the `Comment` component: `defaultView` and `moderatorView`. Both stories render the `Comment` component with the same initial comment data, providing a baseline structure before introducing user role mocking. It imports the `Comment` component and exports named functions representing the stories.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Comment/Comment.stories.jsx\"\nimport Comment from './Comment'\n\n// highlight-next-line\nexport const defaultView = () => {\n  return (\n    <Comment\n      comment={{\n        id: 1,\n        name: 'Rob Cameron',\n        body: 'This is the first comment!',\n        createdAt: '2020-01-01T12:34:56Z',\n        // highlight-next-line\n        postId: 1\n      }}\n    />\n  )\n}\n\n// highlight-start\nexport const moderatorView = () => {\n  return (\n    <Comment\n      comment={{\n        id: 1,\n        name: 'Rob Cameron',\n        body: 'This is the first comment!',\n        createdAt: '2020-01-01T12:34:56Z',\n        postId: 1,\n      }}\n    />\n  )\n}\n// highlight-end\n\nexport default { title: 'Components/Comment' }\n```\n```\n\n----------------------------------------\n\nTITLE: Redwood 'dist' Directory File Structure - Plaintext\nDESCRIPTION: Outlines the directory structure showing the locations where Redwood builds the output for both API and web sides, with an emphasis on the 'dist' directories. No dependencies. Inputs: Result of build process. Outputs: Expected directory/file layout. Limitations: Structure may differ with customizations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n├── api\n│   ├── dist\n│   ├── prisma\n│   └── src\n└── web\n    ├── dist\n    ├── public\n    └── src\n```\n\n----------------------------------------\n\nTITLE: Removing Unused Link from ArticlePage Boilerplate (RedwoodJS, TypeScript, diff format)\nDESCRIPTION: This TypeScript diff-format snippet shows removing the unnecessary Link and routes import from ArticlePage after route parameterization is adopted. This prevents runtime and type errors that result from missing required parameters in the new routing setup. All other imports and the usage of RedwoodJS's Metadata remain intact for SEO and page info.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\n- import { Link, routes } from '@redwoodjs/router'\\n  import { Metadata } from '@redwoodjs/web'\\n\\n  const ArticlePage = () => {\\n    return (\\n      <>\\n        <Metadata title=\"Article\" description=\"Article page\" />\\n\\n        <h1>ArticlePage</h1>\\n        <p>\\n          Find me in <code>./web/src/pages/ArticlePage/ArticlePage.tsx</code>\\n        </p>\\n        {/*\\n          My default route is named <code>article</code>, link to me with `\\n          <Link to={routes.article()}>Article</Link>`\\n        */}\\n      </>\\n    )\\n  }\\n\\n  export default ArticlePage\n```\n\n----------------------------------------\n\nTITLE: Rollback Multiple Deploy Releases - Bash\nDESCRIPTION: Extends the basic rollback operation by specifying how to revert multiple previous releases at once, using a numeric argument. Assumes sufficient previous releases exist, as controlled by the 'keepReleases' deploy option.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy baremetal production --rollback 3\n```\n\n----------------------------------------\n\nTITLE: Updating a User with $self Skipping Self Uniqueness Conflict in JavaScript/JSX\nDESCRIPTION: Handles user updates by ensuring the unique fields (like email) ignore the current record during uniqueness checks using $self. Without $self, an update would falsely fail if the record already exists. The validateUniqueness call receives the id in $self to bypass the user's own record. Requires validateUniqueness() and db.user.create().\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_56\n\nLANGUAGE: jsx\nCODE:\n```\nconst updateUser = (id, input) => {\n  return validateUniqueness('user', {\n    email: input.email,\n    $self: { id }\n  }, (db) => db.user.create({ data: input })\n}\n\n```\n\n----------------------------------------\n\nTITLE: Dynamic Weather API Fetch using Submitted Zip Code - JSX\nDESCRIPTION: Enhances the previous Fetch API example to dynamically use the zip code from the user input form. The onSubmit handler constructs the weather API URL using a template string and the submitted zip code, then parses the JSON response and logs it to the console. Dependencies are as above with @redwoodjs/forms for form handling. Inputs are the object with 'zip' property; output is the fetched weather JSON logged upon submission. Suitable for use in RedwoodJS React components on the client-side.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst onSubmit = (data) => {\n  fetch(\n    `https://api.openweathermap.org/data/2.5/weather?zip=${data.zip},us&appid=YOUR_API_KEY`\n  )\n    .then((response) => response.json())\n    .then((json) => console.info(json))\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Navigation and Content to AboutPage in JSX (JS/TS)\nDESCRIPTION: Updates the AboutPage component to include the same header structure as HomePage (with links to 'About') and adds main content including a paragraph and a link back to the Home page using the named route `routes.home()`. It utilizes `<Link>` and `routes` from `@redwoodjs/router` for navigation and `<Metadata>` from `@redwoodjs/web`. Both JavaScript (.jsx) and TypeScript (.tsx) versions are shown.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/second-page.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/pages/AboutPage/AboutPage.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <>\n      <Metadata title=\"About\" description=\"About page\" />\n\n      // highlight-start\n      <header>\n        <h1>Redwood Blog</h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>\n        <p>\n          This site was created to demonstrate my mastery of Redwood: Look on my\n          works, ye mighty, and despair!\n        </p>\n        <Link to={routes.home()}>Return home</Link>\n      </main>\n      // highlight-end\n    </>\n  )\n}\n\nexport default AboutPage\n```\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/pages/AboutPage/AboutPage.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <>\n      <Metadata title=\"About\" description=\"About page\" />\n\n      // highlight-start\n      <header>\n        <h1>Redwood Blog</h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>\n        <p>\n          This site was created to demonstrate my mastery of Redwood: Look on my\n          works, ye mighty, and despair!\n        </p>\n        <Link to={routes.home()}>Return home</Link>\n      </main>\n      // highlight-end\n    </>\n  )\n}\n\nexport default AboutPage\n```\n\n----------------------------------------\n\nTITLE: Displaying Help for RedwoodJS UI Setup Command\nDESCRIPTION: Executes the RedwoodJS CLI `setup ui` command with the `--help` flag. This displays usage information and options for the command, which helps integrate and configure various CSS frameworks or styling libraries (like Tailwind CSS, Chakra UI, etc.) into the RedwoodJS project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup ui --help\n```\n\n----------------------------------------\n\nTITLE: Passing formMethods to RedwoodJS <Form> Component (JS)\nDESCRIPTION: Illustrates how to pass the `formMethods` object (obtained from `useForm`) to the `formMethods` prop of the RedwoodJS `<Form>` component in JavaScript (`.jsx`). This connects the manually invoked hook with the form component, ensuring validation and other functionalities work correctly while allowing access to extended methods.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_37\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nreturn (\n  <>\n    <Toaster />\n    <Form\n      onSubmit={onSubmit}\n      config={{ mode: 'onBlur' }}\n      error={error}\n      // highlight-next-line\n      formMethods={formMethods}\n    >\n    // ...\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Book Details with a Fragment in RedwoodJS (TypeScript)\nDESCRIPTION: This snippet shows a RedwoodJS component that defines a GraphQL query which incorporates a previously registered fragment. It demonstrates importing query types, using the useQuery hook from '@redwoodjs/web', and combining custom fragments within a GraphQL document. The key dependency is the registered BookInfo fragment. The query expects a bookId as input and returns both the fragment's fields and additional book fields (like description). Required: RedwoodJS, Apollo Client, existing BookInfo fragment, and appropriate GraphQL schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { GetBookDetails } from 'types/graphql'\n\nimport { useQuery } from '@redwoodjs/web'\n\nimport BookInfo from 'src/components/BookInfo'\n\nconst GET_BOOK_DETAILS = gql`\n  query GetBookDetails($bookId: ID!) {\n    book(id: $bookId) {\n      ...BookInfo\n      description\n      # Include other fields specific to this query\n    }\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Handling Signup Response in a React Component using JSX\nDESCRIPTION: Demonstrates handling the response from the `signUp` function (provided by `useAuth`) within a React component's form submission handler. If the response contains a `message` property, it indicates the user was created but not logged in (e.g., display an error toast). Otherwise, the user was created and logged in successfully (e.g., show a welcome toast and navigate). Requires `useAuth` hook, a notification library (`toast`), and routing (`navigate`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nconst { signUp } = useAuth()\n\nconst onSubmit = async (data) => {\n  const response = await signUp({ ...data })\n\n  if (response.message) {\n    toast.error(response.message) // user created, but not logged in\n  } else {\n    toast.success('Welcome!') // user created and logged in\n    navigate(routes.dashboard())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Custom Validation with validateWith() in JavaScript/JSX\nDESCRIPTION: This snippet uses validateWith for asynchronous validation, awaiting completion of logic that may involve database or network access. Here, the number of products is checked against a threshold, and an error is thrown if the limit is reached. This function should be awaited, and it will safely propagate the error message. Requires validateWith() accepting async logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_50\n\nLANGUAGE: jsx\nCODE:\n```\nawait validateWith(async () => {\n  if ((await db.products.count()) >= 100) {\n    throw 'There can only be a maximum of 100 products in your store'\n  }\n})\n\n```\n\n----------------------------------------\n\nTITLE: Exposing Clerk Publishable Key in redwood.toml\nDESCRIPTION: Configures the `redwood.toml` file to make the `CLERK_PUBLISHABLE_KEY` environment variable accessible to the web (frontend) side of the RedwoodJS application. This is required for the Clerk client-side SDK.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/clerk.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n  # ...\n  includeEnvironmentVariables = [\n    \"CLERK_PUBLISHABLE_KEY\",\n  ]\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query Fetching Post with User Name\nDESCRIPTION: Provides an example GraphQL query structure for fetching details of a `post`. It includes standard fields like `id`, `title`, `body`, and `createdAt`, and importantly, navigates the new relationship to fetch the `name` of the associated `user`. This query relies on the corresponding SDL and service resolver updates.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_8\n\nLANGUAGE: graphql\nCODE:\n```\npost {\n  id\n  title\n  body\n  createdAt\n  user {\n    name\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Test Scenarios with Realistic Data (TypeScript)\nDESCRIPTION: This TypeScript snippet shows updating the `standard` scenario in `comments.scenarios.ts` with realistic data, mirroring the JavaScript example. It uses meaningful keys (`jane`, `john`) and replaces placeholder strings with representative content for testing purposes, while maintaining type safety via `defineScenario<Prisma.CommentCreateArgs>`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/services/comments/comments.scenarios.ts\"\nimport type { Prisma } from '@prisma/client'\n\nexport const standard = defineScenario<Prisma.CommentCreateArgs>({\n  comment: {\n    // highlight-start\n    jane: {\n      data: {\n        name: 'Jane Doe',\n        body: 'I like trees',\n        post: {\n          create: {\n            title: 'Redwood Leaves',\n            body: 'The quick brown fox jumped over the lazy dog.',\n          },\n        },\n      },\n    },\n    john: {\n      data: {\n        name: 'John Doe',\n        body: 'Hug a tree today',\n        post: {\n          create: {\n            title: 'Root Systems',\n            body: 'The five boxing wizards jump quickly.',\n          },\n        },\n      },\n    },\n    // highlight-end\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Generating a Specific Transformer Directive in RedwoodJS (Bash)\nDESCRIPTION: Provides the specific RedwoodJS CLI command `yarn rw g directive maskedEmail --type transformer` used to generate a Transformer directive named `maskedEmail`. This command sets up the files required for implementing logic that modifies field values after they are resolved.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g directive maskedEmail --type transformer\n```\n\n----------------------------------------\n\nTITLE: Adding Post-Logout Navigation in SignoutBtn using JSX\nDESCRIPTION: This snippet enhances the `SignoutBtn` component by adding navigation after logout. It imports `navigate` and `routes` from `@redwoodjs/router`. The `logOut` function call is chained with `.then()`, which executes `navigate(routes.home())` to redirect the user to the home page upon successful sign-out.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {2,8} title=\"web/src/components/SignoutBtn/SignoutBtn.js\"\nimport { useAuth } from '@redwoodjs/auth'\nimport { navigate, routes } from '@redwoodjs/router'\n\nconst SignoutBtn = () => {\n  const { logOut } = useAuth()\n\n  const onClick = () => {\n    logOut().then(() => navigate(routes.home()))\n  }\n\n  return <button onClick={() => onClick()}>Sign Out</button>\n}\n\nexport default SignoutBtn\n```\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Co-located Assets in React Components (JSX)\nDESCRIPTION: Shows how to import an image (`logo.png`) co-located with a React component (`Header.js`) using an ES module import statement and then use the imported variable as the `src` for an `<img>` tag. Vite processes this import, potentially inlining small assets or bundling larger ones.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/assets-and-files.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport logo from './logo.png'\n\nconst Header = () => {\n  return (\n    <header>\n      {/* ... */}\n      // highlight-next-line\n      <img src={logo} alt=\"Logo\" />\n    </header>\n  )\n}\n\nexport default Header\n```\n\n----------------------------------------\n\nTITLE: Example: Generating a RedwoodJS Background Job via CLI\nDESCRIPTION: This snippet provides simple examples of how to invoke the RedwoodJS background job generator for a job named 'WelcomeEmail'. Both the full command (`yarn redwood generate`) and its shorthand (`yarn rw g`) are shown. The generator will create `api/src/jobs/WelcomeEmailJob/WelcomeEmailJob.{js|ts}`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_49\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate job WelcomeEmail\n# or\nyarn rw g job WelcomeEmail\n```\n\n----------------------------------------\n\nTITLE: Updating RedwoodJS Routes for Admin Section (TypeScript)\nDESCRIPTION: This JSX code defines the application routes using RedwoodJS Router in a TypeScript file (`Routes.tsx`). It mirrors the JavaScript version, modifying paths for post management routes to be nested under `/admin/posts`. It utilizes `Set` for route grouping and layout application (`ScaffoldLayout` and `BlogLayout`). Dependencies include `@redwoodjs/router` and the defined Page components.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/Routes.tsx\"\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={ScaffoldLayout} title=\"Posts\" titleTo=\"posts\" buttonLabel=\"New Post\" buttonTo=\"newPost\">\n        // highlight-start\n        <Route path=\"/admin/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n        <Route path=\"/admin/posts/{id:Int}/edit\" page={PostEditPostPage} name=\"editPost\" />\n        <Route path=\"/admin/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n        <Route path=\"/admin/posts\" page={PostPostsPage} name=\"posts\" />\n        // highlight-end\n      </Set>\n      <Set wrap={BlogLayout}>\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n```\n\n----------------------------------------\n\nTITLE: Rendering Article Component with CommentsCell and CommentForm - React (TypeScript)\nDESCRIPTION: This TypeScript version of the Article component is functionally identical to its JavaScript counterpart, using typed props for improved type safety. It passes postId to both CommentForm and CommentsCell for blog post-specific comment management. Requires RedwoodJS routing and utility imports. The output is the typed JSX layout for an article with interactive comment support, ensuring comments are fetched and applied per post.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_39\n\nLANGUAGE: TSX\nCODE:\n```\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      {!summary && (\n        <div className=\"mt-12\">\n          <CommentForm postId={article.id} />\n          <div className=\"mt-12\">\n            // highlight-next-line\n            <CommentsCell postId={article.id} />\n          </div>\n        </div>\n      )}\n    </article>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Nginx Proxy for Custom RedwoodJS API Path\nDESCRIPTION: This updated Nginx configuration (`nginx.conf`) reflects the change to a custom API path (`/api`) as defined in `redwood.toml`. The `location` block previously matching `/.redwood/functions` is modified to match and rewrite requests for `/api(.*)`, ensuring that Nginx correctly proxies these requests to the backend Redwood API server.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_40\n\nLANGUAGE: nginx\nCODE:\n```\nupstream redwood_server {\n  server 127.0.0.1:8911 fail_timeout=0;\n}\n\nserver {\n  root /var/www/myapp/current/web/dist;\n  server_name myapp.com;\n  index index.html;\n\n  gzip on;\n  gzip_min_length 1000;\n  gzip_types application/json text/css application/javascript application/x-javascript;\n\n  sendfile on;\n\n  keepalive_timeout 65;\n\n  error_page 404 /404.html;\n  error_page 500 /500.html;\n\n  location / {\n    try_files $uri /200.html =404;\n  }\n\n  location ^~ /static/ {\n    gzip_static on;\n    expires max;\n    add_header Cache-Control public;\n  }\n\n// highlight-next-line\n  location ~ /api(.*) {\n// highlight-next-line\n    rewrite ^/api(.*) $1 break;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_pass http://redwood_server;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing logIn Functionality in SigninPage using JSX\nDESCRIPTION: This snippet further enhances the `SigninPage` component by implementing the sign-in logic within the `onSubmit` function. It calls the `logIn` function obtained from `useAuth`, passing an object containing the user's email, password, and a 'remember me' flag. It uses promise chaining (`.then`, `.catch`) to handle the asynchronous response, with a placeholder for success and setting the error state on failure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {10-14} title=\"web/src/pages/SigninPage/SigninPage.js\"\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from '@redwoodjs/auth'\n\nconst SigninPage = () => {\n  const { logIn } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = (data) => {\n    setError(null)\n    logIn({ email: data.email, password: data.password, remember: true })\n      .then(() => {\n        // do something\n      })\n      .catch((error) => setError(error.message))\n  }\n\n  return (\n    <>\n      <h1>Sign In</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign In</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SigninPage\n```\n```\n\n----------------------------------------\n\nTITLE: Using Named Scenarios in describeScenario - JavaScript\nDESCRIPTION: Example of describeScenario used with a named data scenario block, enabling the test suite to specify which scenario to use for database seeding during a test run. Facilitates targeted and context-specific testing in RedwoodJS. This API accommodates multi-scenario test files and custom test descriptions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_68\n\nLANGUAGE: js\nCODE:\n```\n// If we have a paymentDeclined scenario defined in the .scenario.{js,ts} file\n// The second parameter is the name of the \"describe\" block\ndescribeScenario('paymentDeclined', 'Retrieving details', () => {\n  // ....\n})\n```\n\n----------------------------------------\n\nTITLE: Including SuperTokens Variables in Redwood TOML - TOML\nDESCRIPTION: Updates the RedwoodJS configuration file to make required SuperTokens environment variables accessible to the web side of the app. This modification ensures variables are injected during the build and runtime. Must be added to redwood.toml and 'includeEnvironmentVariables' updated accordingly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supertokens.md#_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n...\nincludeEnvironmentVariables = [\n  'SUPERTOKENS_WEBSITE_DOMAIN',\n  'SUPERTOKENS_API_DOMAIN',\n  'SUPERTOKENS_API_GATEWAY_PATH',\n  'SUPERTOKENS_APP_NAME'\n]\n```\n\n----------------------------------------\n\nTITLE: Example Output: Generating User Service (Bash)\nDESCRIPTION: Shows the console output after successfully running `yarn redwood generate service user`. It confirms the creation of the service file (`users.js`), the scenarios file (`users.scenarios.js`), and the test file (`users.test.js`) within the appropriate service directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_87\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood generate service user\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood g service user\n✔ Generating service files...\n✔ Writing $(./api/src/services/users/users.scenarios.js)...\n✔ Writing $(./api/src/services/users/users.test.js)...\n✔ Writing $(./api/src/services/users/users.js)...\nDone in 1.02s.\n```\n\n----------------------------------------\n\nTITLE: Displaying Field Validation Errors with React FieldError (HTML/JSX)\nDESCRIPTION: This example shows the usage of the <FieldError> component to render a span with a validation error message tied to a form field. If the referenced field has an error, the message is displayed inside a span with the class error-message. Otherwise, nothing is rendered. Requires a form system that associates validation errors with field names.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_15\n\nLANGUAGE: html\nCODE:\n```\n<FieldError name=\\\"name\\\" className=\\\"error-message\\\">\\n  <!-- Renders: <span class=\\\"error-message\\\">name is required</span> --></FieldError\\n>\\n\n```\n\n----------------------------------------\n\nTITLE: Global Pre/Post Deploy Commands in TOML\nDESCRIPTION: Provides syntax for specifying global 'before' and 'after' hook commands in a 'deploy.toml' configuration file for Redwood deployments. These hooks allow running custom shell commands before and after specific deploy lifecycle events globally across all environments and servers. Hooked command examples include touching/removing lock files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_22\n\nLANGUAGE: toml\nCODE:\n```\n[before]\ninstall = \"touch install.lock\"\n\n[after]\ninstall = \"rm install.lock\"\n\n[[production.servers]]\nhost = 'server.com'\n# ...\n```\n\n----------------------------------------\n\nTITLE: Running RedwoodJS Test Suites with yarn (Bash)\nDESCRIPTION: These bash snippets show how to use the yarn rw test command to execute RedwoodJS project's test suites. Default runs all tests in watch mode, but command-line flags allow disabling watch mode, running only web/api side tests, or filtering tests by filename or pattern. Prerequisite: a RedwoodJS project setup. Inputs are CLI arguments; outputs are the command-line results of Jest running the filtered or complete set of tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test --no-watch\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test web\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test api\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test CommentForm\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test api Comment\n```\n\n----------------------------------------\n\nTITLE: Displaying Python-Related Node-Gyp Build Error - Shell - Markdown\nDESCRIPTION: This snippet shows the error output encountered during a `yarn install` run in a Node.js Docker build when Python is missing. It demonstrates the error logs produced by node-gyp, including recommendations and hints for the user to resolve the missing Python dependency. The output is typical when building native modules like bufferutil on Linux-based Node images.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_18\n\nLANGUAGE: Shell\nCODE:\n```\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python Python is not set from command line or npm configuration\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python Python is not set from environment variable PYTHON\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python checking if \"python3\" can be used\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python - executable path is \"\"\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python - \"\" could not be run\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python checking if \"python\" can be used\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python - executable path is \"\"\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python - \"\" could not be run\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python **********************************************************\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python You need to install the latest version of Python.\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python Node-gyp should be able to find and use Python. If not,\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python you can try one of the following options:\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python - Use the switch --python=\"/path/to/pythonexecutable\"\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python (accepted by both node-gyp and npm)\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python - Set the environment variable PYTHON\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python - Set the npm configuration variable python:\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python npm config set python \"/path/to/pythonexecutable\"\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python For more information consult the documentation at:\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python https://github.com/nodejs/node-gyp#installation\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python **********************************************************\n➤ YN0000: │ bufferutil@npm:4.0.8 STDERR gyp ERR! find Python\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL Database Connection Strings (Bash/Env)\nDESCRIPTION: Defines the necessary database connection strings in the `.env` file for a RedwoodJS application using PostgreSQL. `DATABASE_URL` is used for development, and `TEST_DATABASE_URL` is used specifically for running tests, both pointing to `postgres://postgres:postgres@localhost:54322/postgres`. This file should not be committed to version control.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nDATABASE_URL=postgres://postgres:postgres@localhost:54322/postgres\nTEST_DATABASE_URL=postgres://postgres:postgres@localhost:54322/postgres\n```\n\n----------------------------------------\n\nTITLE: Listing Known SSH Keys with ssh-add in Bash\nDESCRIPTION: Shows the command `ssh-add -L` used to list the public keys corresponding to identities currently managed by the `ssh-agent`. This helps verify which keys the SSH client might attempt to use for authentication.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nssh-add -L\n```\n\n----------------------------------------\n\nTITLE: Adding Form Submission Handler in SignupPage - JavaScript\nDESCRIPTION: This revision introduces an onSubmit function inside SignupPage and connects it to RedwoodJS's Form. It prepares for form processing by capturing submitted data, though sign-up logic is not yet implemented. This step requires no additional dependencies but expects later wiring to authentication logic. Data from the form is available as the argument to onSubmit when the form is submitted.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n// imports...\n\nconst SignupPage = () => {\n  const onSubmit = (data) => {\n    // do something here\n  }\n\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form onSubmit={onSubmit}>\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\n//...\n```\n\n----------------------------------------\n\nTITLE: Conditionally Rendering Auth Links in Navigation (RedwoodJS, JavaScript)\nDESCRIPTION: This snippet extends the Navigation component to use the isAuthenticated property from the useAuth hook. It conditionally displays different navigation options based on authentication: placeholders are included for sign-out (if logged in) and sign-up/sign-in (if logged out). Dependencies include '@redwoodjs/router' and '@redwoodjs/auth', with isAuthenticated driving the branching.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_22\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { useAuth } from '@redwoodjs/auth'\n\nconst Navigation = () => {\n  const { isAuthenticated } = useAuth()\n  return (\n    <nav>\n      {isAuthenticated ? (\n        // signed in - show the Sign Out button\n      ) : (\n        // signed out - show the Sign Up and Sign In links\n      )}\n    </nav>\n  )\n}\n\nexport default Navigation\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Test Scenario in JavaScript\nDESCRIPTION: Defines a standard test scenario using RedwoodJS's `defineScenario`. This JavaScript snippet sets up initial database state for comment tests, creating two comments each associated with a different post. This data is used by tests to verify service logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.scenarios.js\"\nexport const standard = defineScenario({\n  comment: {\n    jane: {\n      data: {\n        name: 'Jane Doe',\n        body: 'I like trees',\n        post: {\n          create: {\n            title: 'Redwood Leaves',\n            body: 'The quick brown fox jumped over the lazy dog.',\n          },\n        },\n      },\n    },\n    john: {\n      data: {\n        name: 'John Doe',\n        body: 'Hug a tree today',\n        post: {\n          create: {\n            title: 'Root Systems',\n            body: 'The five boxing wizards jump quickly.',\n          },\n        },\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Signing Up with Metadata using RedwoodJS `useAuth` Hook (TypeScript)\nDESCRIPTION: Shows how to create a new user while also providing additional user metadata (like first name and age) using the `signUp` method from the RedwoodJS `useAuth` hook and the nested `options.data` object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst { signUp } = useAuth()\n\nawait signUp({\n  email: 'example@email.com',\n  password: 'example-password',\n  options: {\n    data: {\n      first_name: 'John',\n      age: 27,\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using the Glob Core Parameter Type for Path Matching - RedwoodJS - JSX\nDESCRIPTION: Demonstrates defining glob-type route parameters to capture multiple or slash-containing segments as a single string. Useful for file paths or range specifications within route URLs. Inputs: URLs with variable-length segments; outputs: captured segments as string in the page component's props. Works only if there are clear static boundaries between globs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/file/{filePath...}\" page={FilePage} name=\"file\" />\n```\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/from/{fromDate...}/to/{toDate...}\" page={DatePage} name=\"dateRange\" />\n```\n\n----------------------------------------\n\nTITLE: Importing Modules and Reusing Code in RedwoodJS Serverless Functions - JavaScript (JSX Syntax)\nDESCRIPTION: These import statements illustrate how to use shared modules, services, or libraries within serverless functions. The snippet emphasizes code reuse and modularity by importing database connections, services, or utilities from the API layer. Dependencies: files present in src/lib or src/services. Inputs: N/A. Outputs: N/A. These patterns facilitate separation of concerns and code DRYness in RedwoodJS projects.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n// importing `db` directly\nimport { db } from 'src/lib/db'\n\n// importing services\nimport { update } from 'src/services/subscriptions'\n\n// importing a custom shared library\nimport { reportError } from 'src/lib/errorHandling'\n```\n\n----------------------------------------\n\nTITLE: Creating and Validating Car Submissions - RedwoodJS Service - TypeScript\nDESCRIPTION: This TypeScript version of createCar adds a Car type annotation for the input parameter to enforce stronger typing. As in the JavaScript variant, it applies several validate calls to enforce inclusion, exclusion, absence, format, and numericality rules before persisting car data. Dependencies are the validate function, db object, and a Car type providing structure for the input. The function expects a Car-shaped argument with an input property and returns the result from db.car.create(). Validation errors will be thrown if input values violate any rules.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const createCar = ({ input }: Car) => {\n  validate(input.make, 'make', {\n    inclusion: ['Audi', 'BMW', 'Ferrari', 'Lexus', 'Tesla'],\n  })\n  validate(input.color, 'color', {\n    exclusion: { in: ['Beige', 'Mauve'], message: 'No one wants that color' },\n  })\n  validate(input.hasDamage, 'hasDamage', {\n    absence: true,\n  })\n  validate(input.vin, 'vin', {\n    format: /[A-Z0-9]+/,\n    length: { equal: 17 },\n  })\n  validate(input.odometer, 'odometer', {\n    numericality: { positive: true, lessThanOrEqual: 10000 },\n  })\n\n  return db.car.create({ data: input })\n}\n```\n\n----------------------------------------\n\nTITLE: Running Successful Prisma Database Migration\nDESCRIPTION: This command runs the RedwoodJS Prisma migration tool again. With the default value added to the `roles` field in the schema, this migration should now apply successfully, adding the new column and setting the default value for existing rows.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Defining a Redwood Cell with GraphQL Query\nDESCRIPTION: This snippet illustrates the structure of a Redwood Cell, a component responsible for its own data fetching and display states. It exports a `QUERY` constant containing a GraphQL query (using `gql` tag) to fetch testimonials. It also exports standard components: `Loading` (displayed during data fetch), `Failure` (displayed on error, receiving the error object), and `Success` (displayed on successful data retrieval, receiving the fetched data as props). The `Success` component maps over the `testimonials` data to render a list. An `Empty` component is optionally exportable for cases where the query returns no data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter0/what-is-redwood.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const QUERY = gql`\n  query GetTestimonials {\n    testimonials {\n      id\n      author\n      quote\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Failure = ({ error }) => <div>An error occured! {error.message}</div>\n\nexport const Success = ({ testimonials }) => {\n  return (\n    <ul>\n      {testimonials.map((test) => {\n        <li key={test.id}>{test.quote} — {test.author}</li>\n      })}\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Basic Redwood Form Test with Jest - JavaScript\nDESCRIPTION: This code snippet demonstrates how to initialize a simple test for a RedwoodJS form component using Jest. It imports utilities from Redwood's testing library and @testing-library/user-event for simulating user interactions. The test checks if the NameForm component can render with an onSubmit handler without throwing, ensuring basic component integration. Dependencies required are @redwoodjs/testing/web for rendering and jest for assertions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_47\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { render, screen, waitFor } from '@redwoodjs/testing/web'\nimport userEvent from '@testing-library/user-event'\n\nimport NameForm from './NameForm'\n\ndescribe('NameForm', () => {\n  it('renders successfully', () => {\n    expect(() => {\n      const onSubmit = jest.fn()\n\n      render(<NameForm onSubmit={onSubmit} />)\n    }).not.toThrow()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Tracking Uploaded Image URL with useState in RedwoodJS (JavaScript)\nDESCRIPTION: This snippet shows how to use useState to track the URL of an uploaded image. The URL is initially set to a pre-existing image (if present) for edit flows. The onFileUpload handler updates the state when a new file is uploaded. This ensures that editing existing images preserves their URLs. Requires react, filestack-react, and @redwoodjs/forms as dependencies. The component stores and updates the image URL dynamically as part of the form's state, enabling seamless create/edit operations for images.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {10,19,26} title=\\\"web/src/components/ImageForm/ImageForm.js\\\"\nimport {\n  Form,\n  FormError,\n  FieldError,\n  Label,\n  TextField,\n  Submit,\n} from '@redwoodjs/forms'\nimport { PickerInline } from 'filestack-react'\nimport { useState } from 'react'\n\nconst formatDatetime = (value) => {\n  if (value) {\n    return value.replace(/:\\\\d{2}\\\\.\\\\d{3}\\\\w/, '')\n  }\n}\n\nconst ImageForm = (props) => {\n  const [url, setUrl] = useState(props?.image?.url)\n\n  const onSubmit = (data) => {\n    props.onSave(data, props?.image?.id)\n  }\n\n  const onFileUpload = (response) => {\n    setUrl(response.filesUploaded[0].url)\n  }\n\n  return (\n    // component stuff...\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a RedwoodJS Validator Directive (`@isSubscriber`) (TypeScript)\nDESCRIPTION: Provides the TypeScript implementation for a validator directive `@isSubscriber`. It defines the schema using `gql` and implements a `validate` function that checks if the `currentUser` exists and has the 'SUBSCRIBER' role, throwing `AuthenticationError` or `ForbiddenError` if checks fail. Uses `createValidatorDirective` from `@redwoodjs/graphql-server`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  AuthenticationError,\n  ForbiddenError,\n  createValidatorDirective,\n  ValidatorDirectiveFunc,\n} from '@redwoodjs/graphql-server'\nimport { hasRole } from 'src/lib/auth'\n\nexport const schema = gql`\n  directive @isSubscriber on FIELD_DEFINITION\n`\n\nconst validate: ValidatorDirectiveFunc = ({ context }) => {\n  if (!context.currentUser) {\n    throw new AuthenticationError(\"You don't have permission to do that.\")\n  }\n\n  if (!context.currentUser.roles?.includes('SUBSCRIBER')) {\n    throw new ForbiddenError(\"You don't have access to do that.\")\n  }\n}\n\nconst isSubscriber = createValidatorDirective(schema, validate)\n\nexport default isSubscriber\n```\n\n----------------------------------------\n\nTITLE: Customizing Logger Redaction Paths (TypeScript)\nDESCRIPTION: Demonstrates extending RedwoodJS's default list of sensitive key paths for redacting log fields, using the 'redact' option. Requires '@redwoodjs/api/logger' for redactionsList and logger creation. Input: an options object with 'redact' property set to an augmented list of sensitive keys (as string or array). Output: logger instance that suppresses those keys' values in all log output. Ensures secrets like SSNs and credit card numbers are safely redacted. Only affects log output; does not prevent sensitive data from being present in runtime objects.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Custom redaction list\n */\nimport { redactionsList } from '@redwoodjs/api/logger'\n\n//...\n\nexport const logger = createLogger({\n  options: { redact: [...redactionsList, 'ssn,credit_card_number'] },\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Supabase Auth Client in Redwood (JSX)\nDESCRIPTION: Displays the content of the generated `web/src/auth.[js/tsx]` file. This file initializes the Supabase JavaScript client (`supabaseClient`) using environment variables (`SUPABASE_URL`, `SUPABASE_KEY`). It then uses Redwood's `createAuth` function, passing the `supabaseClient`, to generate the `AuthProvider` component and the `useAuth` hook, which are exported for use throughout the web side.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createClient } from '@supabase/supabase-js'\n\nimport { createAuth } from '@redwoodjs/auth-supabase-web'\n\nconst supabaseClient = createClient(\n  process.env.SUPABASE_URL || '',\n  process.env.SUPABASE_KEY || ''\n)\n\nexport const { AuthProvider, useAuth } = createAuth(supabaseClient)\n```\n\n----------------------------------------\n\nTITLE: Generating a Navigation Component using Redwood CLI\nDESCRIPTION: Uses the RedwoodJS CLI command `yarn redwood generate component navigation` to create the basic structure for a `Navigation` component in the `web/src/components/` directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate component navigation\n```\n\n----------------------------------------\n\nTITLE: Defining an Article Component Story - Storybook - TypeScript (TSX)\nDESCRIPTION: This snippet provides a Storybook story definition for the Article component, written using TypeScript and TSX. It closely follows the JavaScript example but includes possible type safety for the Article props. The 'generated' story passes hardcoded example data directly to the Article component for isolated rendering in Storybook UI. Essential dependencies are the local Article component and Storybook's expected story exports.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/storybook.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport Article from './Article'\n\nexport const generated = () => {\n  return (\n    <Article\n      article={{\n        id: 1,\n        title: 'First Post',\n        body: `Neutra tacos hot chicken prism raw denim, put\n              a bird on it enamel pin post-ironic vape cred\n              DIY. Street art next level umami squid.\n              Hammock hexagon glossier 8-bit banjo. Neutra\n              la croix mixtape echo park four loko semiotics\n              kitsch forage chambray. Semiotics salvia\n              selfies jianbing hella shaman. Letterpress\n              helvetica vaporware cronut, shaman butcher\n              YOLO poke fixie hoodie gentrify woke\n              heirloom.`,\n        createdAt: '2020-01-01T12:34:45Z',\n      }}\n    />\n  )\n}\n\nexport default { title: 'Components/Article' }\n```\n\n----------------------------------------\n\nTITLE: Displaying OAuth Login Errors in the UI using RedwoodJS Toasts (JSX)\nDESCRIPTION: This JSX snippet demonstrates how to capture and display error messages from OAuth flow by extracting query parameters (such as 'error') from the URL using 'useParams()', and showing notifications with RedwoodJS's toast system. This is intended for use in a login page component to improve user feedback following OAuth login failures. Ensure that '@redwoodjs/router' and '@redwoodjs/web/toast' are installed as dependencies. No inputs are required other than standard router/query params; error messages are shown via toast effects.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_16\n\nLANGUAGE: JSX\nCODE:\n```\nimport { useParams } from '@redwoodjs/router'\nimport { toast, Toaster } from '@redwoodjs/web/toast'\n\nconst LoginPage = () => {\n  const params = useParams()\n\n  useEffect(() => {\n    if (params.error) {\n      toast.error(params.error)\n    }\n  }, [params.error])\n\n  return (\n    <>\n      <Toaster />\n      // ...\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Signature Header in RedwoodJS Webhook (JSX)\nDESCRIPTION: This JSX snippet defines a test scenario within a RedwoodJS webhook test suite. It tests the authorization failure when a webhook event is received with an invalid signature header name ('X-Webhook-Signature-Invalid'). The test uses `mockSignedWebhook` to simulate the event and asserts that the handler returns a 401 Unauthorized status code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_22\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\nscenario(\n  'with an invalid signature header, the webhook is unauthorized',\n  async (scenario) => {\n    const order = scenario.order.placed\n\n    const payload = {\n      trackingNumber: order.trackingNumber,\n      status: 'DELIVERED',\n    }\n    const event = mockSignedWebhook({\n      payload,\n      signatureType: 'sha256Verifier',\n      signatureHeader: 'X-Webhook-Signature-Invalid',\n      secret: 'MY-VOICE-IS-MY-PASSPORT-VERIFY-ME',\n    })\n\n    const result = await handler(event)\n\n    expect(result.statusCode).toBe(401)\n  }\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Importing and Using the useCache Hook in TypeScript\nDESCRIPTION: Demonstrates how to import the `useCache` hook from `@redwoodjs/web/apollo` within a React component. It destructures the hook to access the `cache` object and helper methods like `evict`, `extract`, `identify`, `modify`, `resetStore`, and `clearStore` for interacting with the Apollo Client cache.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/caching.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst CacheExample = () => {\n  const { cache, evict, extract, identify, modify, resetStore, clearStore } =\n    useCache()\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Enhancing Comment Component with Styling and Date Formatting in TypeScript\nDESCRIPTION: This TSX snippet enhances the 'Comment' component using TypeScript. It adds Tailwind CSS classes for styling and includes a typed `formattedDate` helper function. The function accepts a date string (compatible with the `Date` constructor), parses it, and returns a human-readable format. The component's rendering logic is updated to incorporate the styles and formatted date.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/the-redwood-way.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-start\nconst formattedDate = (datetime: ConstructorParameters<typeof Date>[0]) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n// highlight-end\n\n// Just a temporary type. We'll replace this later\ninterface Props {\n  comment: {\n    name: string\n    createdAt: string\n    body: string\n  }\n}\n\nconst Comment = ({ comment }: Props) => {\n  return (\n    // highlight-start\n    <div className=\"bg-gray-200 p-8 rounded-lg\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n    </div>\n    // highlight-end\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodApolloProvider to Include Credentials in GraphQL XHR Requests (JSX/JavaScript)\nDESCRIPTION: This snippet configures the Apollo GraphQL client in RedwoodJS to send browser credentials, such as cookies, with every request by setting 'credentials: include' on the 'httpLinkConfig' property. It is placed inside the main App component, nested under the Redwood provider structure. The change ensures session cookies are sent to the backend during API requests. The key parameter is 'httpLinkConfig.credentials'. Input is a config object; output is credentialed network traffic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cors.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { AuthProvider, useAuth } from 'src/auth'\\n\\nconst App = () => (\\n  <FatalErrorBoundary page={FatalErrorPage}>\\n    <RedwoodProvider titleTemplate=\"%PageTitle | %AppTitle\">\\n      <AuthProvider type=\"dbAuth\">\\n        <RedwoodApolloProvider\\n          useAuth={useAuth}\\n          graphQLClientConfig={{\\n            httpLinkConfig: { credentials: 'include' },\\n          }}\\n        >\\n          <Routes />\\n        </RedwoodApolloProvider>\\n      </AuthProvider>\\n    </RedwoodProvider>\\n  </FatalErrorBoundary>\\n)\n```\n\n----------------------------------------\n\nTITLE: Using a Named RedwoodJS Scenario in a Test\nDESCRIPTION: This snippet demonstrates how to specify a named scenario (e.g., 'incomplete') for a particular test. The name of the desired scenario is passed as the first argument to the `scenario()` function. This ensures that only the data defined in the 'incomplete' scenario is present in the database when this specific test runs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_56\n\nLANGUAGE: javascript\nCODE:\n```\nscenario('incomplete', 'retrieves only incomplete users', async (scenario) => {\n  const list = await users({ complete: false })\n  expect(list).toMatchObject([scenario.user.forrest])\n})\n```\n\n----------------------------------------\n\nTITLE: Generating a Specific Validator Directive in RedwoodJS (Bash)\nDESCRIPTION: Provides the specific RedwoodJS CLI command `yarn rw g directive isSubscriber --type validator` used to generate a Validator directive named `isSubscriber`. This command scaffolds the necessary files for implementing subscription validation logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g directive isSubscriber --type validator\n```\n\n----------------------------------------\n\nTITLE: Creating and Saving a New Record using `create()` in JSX\nDESCRIPTION: The static `create()` method initializes and saves a new record to the database in a single step. The first argument contains the data for the new record, corresponding to Prisma's `create()` data input. An optional second argument allows passing additional Prisma options (like `select`). It returns the newly created record instance on success, or `false` if the save operation fails.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_22\n\nLANGUAGE: jsx\nCODE:\n```\nawait User.create({ name: 'Tom Preston-Werner' })\nawait User.create(\n  { firstName: 'Rob', email: 'rob@redwoodjs.com' },\n  { select: ['email'] }\n)\n```\n\n----------------------------------------\n\nTITLE: Updating Records by Modifying Attributes and Calling `save()` in JSX\nDESCRIPTION: This demonstrates updating a record by first fetching it, then directly modifying its attributes (e.g., `user.email = ...`), and finally calling the `save()` instance method to persist the changes. The `save()` method can optionally accept an argument to forward properties to Prisma or include `{ throw: true }` to throw an error on failure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = await User.find(123)\nuser.email = 'rob.cameron@redwoodjs.com'\nawait user.save()\n// or\nawait user.save({ throw: true })\n```\n\n----------------------------------------\n\nTITLE: Configuring Code Generation in redwood.toml - TOML\nDESCRIPTION: Enables automatic Jest test and Storybook story file generation by setting tests and stories to true under [generate] in redwood.toml. Disabling these (by setting to false) reduces generated files for users not needing those features. Requires relevant dependencies if you use Jest or Storybook.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[generate]\n  tests = true\n  stories = true\n```\n\n----------------------------------------\n\nTITLE: Defining Modified Contact GraphQL Schema (GraphQL)\nDESCRIPTION: This modified GraphQL schema for the Contact model removes the `updateContact` and `deleteContact` mutations as they are not needed for the public contact form. It also changes the `createContact` mutation's directive from `@requireAuth` to `@skipAuth`, allowing unauthenticated users to submit contact messages. The queries retain `@requireAuth`. This example shows both JS and TS file variants.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/contacts.sdl.js\"\nexport const schema = gql`\n  type Contact {\n    id: Int!\n    name: String!\n    email: String!\n    message: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    contacts: [Contact!]! @requireAuth\n    contact(id: Int!): Contact @requireAuth\n  }\n\n  input CreateContactInput {\n    name: String!\n    email: String!\n    message: String!\n  }\n\n  // highlight-start\n  type Mutation {\n    createContact(input: CreateContactInput!): Contact! @skipAuth\n  }\n  // highlight-end\n`\n```\n```\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/contacts.sdl.ts\"\nexport const schema = gql`\n  type Contact {\n    id: Int!\n    name: String!\n    email: String!\n    message: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    contacts: [Contact!]! @requireAuth\n    contact(id: Int!): Contact @requireAuth\n  }\n\n  input CreateContactInput {\n    name: String!\n    email: String!\n    message: String!\n  }\n\n  // highlight-start\n  type Mutation {\n    createContact(input: CreateContactInput!): Contact! @skipAuth\n  }\n  // highlight-end\n`\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Session Secret for dbAuth - Env Configuration\nDESCRIPTION: Establishes an environment variable 'SESSION_SECRET' needed for encrypted cookies with dbAuth in RedwoodJS. The secret string is auto-generated (substitute your own value as necessary) and must be placed in the root-level .env file for authentication to function securely. Prerequisite: .env support in Node.js environment. Output: securely configured authentication layer.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/intermission.md#_snippet_3\n\nLANGUAGE: dotenv\nCODE:\n```\nSESSION_SECRET=JV2kA48ZU4FnLHwqaydy9beJ99qy4VgWXPkvsaw3xE2LGyuSur2dVq2PsPkPfygr\n```\n\n----------------------------------------\n\nTITLE: Handling Required Relation Resolvers with Null Check (TypeScript)\nDESCRIPTION: This TypeScript snippet presents an alternative for implementing a required relation resolver (`Post.author`) in strict mode. It explicitly checks if the result of awaiting `db.post.findUnique(...).author()` is null. If it is null, it throws an error, otherwise, it returns the non-null author, satisfying strict null checks.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Option 2: Check for null\nexport const Post: PostRelationResolvers = {\n  author: async (_obj, { root }) => {\n    // Here, `findUnique` can return `null`, so we have to handle it:\n    const maybeAuthor = await db.post\n      .findUnique({ where: { id: root?.id } })\n      .author()\n\n    // highlight-start\n    if (!maybeAuthor) {\n      throw new Error('Could not resolve author')\n    }\n    // highlight-end\n\n    return maybeAuthor\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Using RedwoodJS Label Component with Error Styling (JavaScript)\nDESCRIPTION: Shows how to replace standard HTML `<label>` elements with the RedwoodJS `<Label>` component. This requires importing `Label` from `@redwoodjs/forms`. The `<Label>` component accepts an `errorClassName` prop, which applies the specified CSS class (`error`) to the label itself when the associated input field (linked by the `name` prop) has a validation error. Note: The provided code snippet is incomplete.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  // highlight-next-line\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-start\n        <Label name=\"name\" errorClassName=\"error\">\n          Name\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        // highlight-start\n        <Label name=\"email\" errorClassName=\"error\">\n          Email\n        </Label>\n        // highlight-end\n        <TextField\n          name=\"email\"\n          validation={{ required: true }}\n          errorClassName=\"error\"\n```\n```\n\n----------------------------------------\n\nTITLE: Defining the Initial Comment Component Structure in JavaScript\nDESCRIPTION: This JSX snippet defines the basic structure of the 'Comment' React component. It accepts a single prop `comment` (an object expected to contain `name`, `createdAt`, and `body`) and renders these properties within basic HTML elements (h2, time, p). This is the initial version before styling or date formatting.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/the-redwood-way.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nconst Comment = ({ comment }) => {\n  return (\n    <div>\n      // highlight-start\n      <h2>{comment.name}</h2>\n      <time dateTime={comment.createdAt}>{comment.createdAt}</time>\n      <p>{comment.body}</p>\n      // highlight-end\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Creating Storybook Stories for Article Component (TSX)\nDESCRIPTION: This snippet defines Storybook stories for the updated TypeScript `Article` component. Similar to the JSX version, it defines sample `ARTICLE` data and exports two stories: `full` (renders the component without the summary prop) and `summary` (renders the component with `summary={true}`), allowing testing of both display modes in Storybook.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-story.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/components/Article/Article.stories.tsx\"\nimport Article from './Article'\n\n// highlight-start\nconst ARTICLE = {\n  id: 1,\n  title: 'First Post',\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\n}\n// highlight-end\n\n// highlight-start\nexport const full = () => {\n  return <Article article={ARTICLE} />\n}\n// highlight-end\n\n// highlight-start\nexport const summary = () => {\n  return <Article article={ARTICLE} summary={true} />\n}\n// highlight-end\n\nexport default { title: 'Components/Article' }\n```\n```\n\n----------------------------------------\n\nTITLE: Example ssh-keygen Key Generation Prompt Interaction\nDESCRIPTION: Shows the interactive prompts displayed by the `ssh-keygen` command after initiation. It asks the user where to save the key (defaulting to `~/.ssh/id_ed25519`) and requests an optional passphrase for added security on the private key.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_14\n\nLANGUAGE: text\nCODE:\n```\nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/Users/rob/.ssh/id_ed25519):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\n```\n\n----------------------------------------\n\nTITLE: Manually Installing Project Dependencies with Yarn in Terminal\nDESCRIPTION: Changes into the Redwood app's directory (`<your-app-name>`) and runs `yarn install` to download and install all project dependencies defined in `package.json`. This step is necessary if the automatic dependency installation was skipped during the `create-redwood-app` setup (specifically when using Yarn v1).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/create-redwood-app.md#_snippet_4\n\nLANGUAGE: terminal\nCODE:\n```\ncd <your-app-name>\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Disabling Submit Button During Loading State - RedwoodJS - JavaScript\nDESCRIPTION: This short JSX snippet shows how to disable the Submit button in the contact form while a mutation is in progress (loading=true). By binding the disabled attribute of the Submit component to loading, it prevents the user from sending multiple requests. The key dependency is the loading boolean from useMutation, and the limitation is that this only works as intended if loading state is managed properly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nreturn (\n  // ...\n  // highlight-next-line\n  <Submit disabled={loading}>Save</Submit>\n  // ...\n)\n```\n\n----------------------------------------\n\nTITLE: Adding a Submit Button to a RedwoodJS Form - JavaScript\nDESCRIPTION: This JavaScript snippet adds a <Submit> button to a RedwoodJS form that contains a <TextField> for user input. The Submit button enables form submission, although no submission handler logic is shown. Dependencies are '@redwoodjs/web' and '@redwoodjs/forms'. Input is user-provided text, the output is form submission (currently without feedback). Constraints: submit action is assumed to invoke default form behaviors, with no custom processing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField, Submit } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form>\n        <TextField name=\"input\" />\n        // highlight-next-line\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic Seed Execution in package.json (JSON)\nDESCRIPTION: Shows the configuration block in `package.json` that enables automatic seed execution with Prisma migrate commands in RedwoodJS. Removing this block prevents the `yarn rw exec seed` command (which runs the seed script) from being triggered automatically during migrations or resets.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/database-seeds.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n\"prisma\": {\n  \"seed\": \"yarn rw exec seed\"\n},\n```\n\n----------------------------------------\n\nTITLE: Running RedwoodJS Setup Command (Bash)\nDESCRIPTION: Executes the RedwoodJS `setup` command using Yarn to initialize project configuration or integrate third-party libraries. Replace `<category>` with a specific setup type (e.g., `auth`, `cache`, `deploy`, `i18n`, `ui`) as detailed in the accompanying documentation table.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_107\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup <category>\n```\n\n----------------------------------------\n\nTITLE: Adding a Submit Button to a RedwoodJS Form (JSX)\nDESCRIPTION: This snippet shows how to add a submit button to the `ContactPage` form using the `Submit` component from `@redwoodjs/forms`. The button displays the text \"Save\".\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField, Submit } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form>\n        <TextField name=\"input\" />\n        // highlight-next-line\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Production Servers for RedwoodJS with TOML\nDESCRIPTION: Defines multiple server configurations for the 'production' environment in a deploy.toml file. Each server block specifies connection details, deployment path, roles (api/web), and process names. The presence of 'migrate = false' ensures that database migrations are only run on the API server and not redundantly on the web server. This setup requires no external dependencies within the TOML itself, but expects RedwoodJS and deployment scripts to consume this structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[[production.servers]]\nhost = \"api.server.com\"\nusername = \"user\"\nagentForward = true\nsides = [\"api\"]\npath = \"/var/www/app\"\nprocessNames = [\"api\"]\n\n[[production.servers]]\nhost = \"web.server.com\"\nusername = \"user\"\nagentForward = true\nsides = [\"web\"]\npath = \"/var/www/app\"\nmigrate = false\nprocessNames = [\"web\"]\n\n```\n\n----------------------------------------\n\nTITLE: Resetting Development Database with RedwoodJS Prisma\nDESCRIPTION: Executes the RedwoodJS CLI command (`yarn rw prisma migrate reset`) to completely reset the development database. This involves dropping the database, recreating it based on the migration history, and running the seed script (`scripts/seed.js`). This is useful during development to recover from migration issues or to start with a clean slate, but it deletes all existing data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate reset\n```\n\n----------------------------------------\n\nTITLE: Abbreviating Serverless CLI with 'sls' Alias - RedwoodJS - Bash\nDESCRIPTION: This note demonstrates support for the `sls` alias, which can be used instead of `serverless` for shorter deploy commands. The functionality remains identical; only the CLI invocation changes. No additional configuration is required to use the alias in RedwoodJS projects.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/serverless.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy sls\n```\n\n----------------------------------------\n\nTITLE: Specifying Test Database Strategy in Redwood - Env Config\nDESCRIPTION: This snippet sets an environment variable to instruct RedwoodJS test runner to use the 'reset' strategy for test database migrations, ensuring all migrations are run sequentially via 'yarn rw prisma migrate reset'. This is necessary when migration SQL contains essential configuration not represented in the schema snapshot. Place this in your .env file to change test database setup behavior, at the cost of increased test startup times depending on migration count.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_49\n\nLANGUAGE: env\nCODE:\n```\nTEST_DATABASE_STRATEGY=reset\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Component using CLI (Bash)\nDESCRIPTION: This command uses the RedwoodJS CLI (`rw`) via Yarn to generate a new React component named `CommentForm`. It scaffolds the necessary files (component, test, story) in the appropriate directory structure within the RedwoodJS project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g component CommentForm\n```\n\n----------------------------------------\n\nTITLE: Additional Setup for RedwoodJS Server When Trusted Documents Not Ready - Bash\nDESCRIPTION: This example output covers the case where the experimental server file and supporting project infrastructure are not yet set up. The CLI adds config to redwood.toml, server file, and API packages accordingly. This ensures that all prerequisites for trusted documents support are fulfilled if missing. No input arguments needed; automated as part of trusted-documents setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_124\n\nLANGUAGE: bash\nCODE:\n```\n\\u2714 Adding the experimental server file...\\n\\u2714 Adding config to redwood.toml...\\n\\u2714 Adding required api packages...\n```\n\n----------------------------------------\n\nTITLE: Adding Navigation to HomePage Component (JavaScript/JSX)\nDESCRIPTION: This snippet shows the HomePage functional component in JavaScript (`.jsx`). It imports `Link` and `routes` from `@redwoodjs/router`. A header containing the blog title and a navigation list is added. The navigation includes a `<Link>` component that uses the named route function `routes.about()` to link to the About page. The `Metadata` component is used for setting page title and description.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/second-page.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\n\nconst HomePage = () => {\n  return (\n    <>\n      <Metadata title=\"Home\" description=\"Home page\" />\n\n      // highlight-start\n      <header>\n        <h1>Redwood Blog</h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>Home</main>\n      // highlight-end\n    </>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Setting Up Netlify Deployment Configuration - Bash\nDESCRIPTION: This command sets up deployment configuration for Netlify in a RedwoodJS project, preparing default configurations needed by Netlify for proper deployment. Requires a RedwoodJS project directory as context and Yarn installed. This command should be run after initializing git and pushing the codebase to a remote repository. The affected files will be committed to the repository for Netlify's build system to pick up.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/netlify.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup deploy netlify\n```\n\n----------------------------------------\n\nTITLE: Regenerating RedwoodJS Types (Shell)\nDESCRIPTION: This shell command uses the RedwoodJS CLI (`rw`) to regenerate project types. This step is necessary after enabling strict mode, as the type generation process behaves differently when strict mode is active.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw g types\n```\n\n----------------------------------------\n\nTITLE: Initial Baremetal Deployment Command (Bash)\nDESCRIPTION: This command initiates the first-time deployment of a RedwoodJS application to the 'production' baremetal environment. The `--first-run` flag triggers specific setup actions like starting services with PM2 and saving the configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy baremetal production --first-run\n```\n\n----------------------------------------\n\nTITLE: Passing ID Prop to ArticleCell in ArticlePage (JavaScript)\nDESCRIPTION: Updates the `ArticlePage` component (JavaScript version) to accept the `id` prop, automatically provided by the RedwoodJS router from the corresponding route parameter (`{id}`). This `id` is then explicitly passed as a prop to the `ArticleCell`, making it available for the cell's GraphQL query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\nimport ArticleCell from 'src/components/ArticleCell'\n\n// highlight-next-line\nconst ArticlePage = ({ id }) => {\n  return (\n    <>\n      <Metadata title=\"Article\" description=\"Article page\" />\n\n      // highlight-next-line\n      <ArticleCell id={id} />\n    </>\n  )\n}\n\nexport default ArticlePage\n```\n\n----------------------------------------\n\nTITLE: Accessing Query Data Directly via Destructuring Props in Success Component (JavaScript/JSX)\nDESCRIPTION: This alternative Success component illustrates Redwood's feature of spreading query results directly onto the component's props, allowing destructuring of posts and authors as top-level props. Useful for simplifying code and type inference. Requires Redwood Cell infrastructure, React, and a query returning 'posts' and 'authors'. Expects props matching GraphQL result keys.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Success = ({ posts, authors }) => {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Testing an Asynchronous RedwoodJS Validator Directive (TypeScript/Jest)\nDESCRIPTION: Demonstrates how to adapt a Jest test for an asynchronous RedwoodJS Validator directive. By marking the test function `async` and using `await expect(mockExecution()).rejects.toThrowError(...)`, it correctly handles promises returned by async `validate` functions and asserts that they reject with the expected error when validation fails.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_28\n\nLANGUAGE: ts\nCODE:\n```\ndescribe('isSubscriber directive', () => {\n  it('has a isSubscriber throws an error if validation does not pass', async () => {\n    const mockExecution = mockRedwoodDirective(isSubscriber, {})\n    await expect(mockExecution()).rejects.toThrowError(\n      'Implementation missing for isSubscriber'\n    )\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Defining Initial authDecoder Function in TypeScript\nDESCRIPTION: This snippet shows the initial definition of the `authDecoder` function within `api/src/lib/auth.ts`. This asynchronous function is intended to be passed to RedwoodJS's `createGraphQLHandler` and will be responsible for verifying and decoding authentication tokens. It accepts the token string and the authentication type string as arguments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nexport const authDecoder = async (token: string, type: string) => {\n  // decode token...\n}\n```\n\n----------------------------------------\n\nTITLE: Launching Prisma Studio with RedwoodJS CLI (Bash)\nDESCRIPTION: Command to start Prisma Studio, a GUI tool for viewing and manipulating data in the database. It is run using the RedwoodJS CLI wrapper command `yarn rw prisma studio`. This allows developers to easily inspect the database records, such as the newly created `User` and `Identity` entries after a successful OAuth login.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma studio\n```\n\n----------------------------------------\n\nTITLE: Deleting All Prisma Migrations (Windows - Bash)\nDESCRIPTION: Removes the entire migrations directory in Windows environments using rmdir with /s switch. Facilitates resetting database schema state for Prisma during transitions between database engines. This operation is destructive and should be used with caution.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nrmdir /s api\\db\\migrations\n```\n\n----------------------------------------\n\nTITLE: Installing nvm via Homebrew on Mac\nDESCRIPTION: This command uses Homebrew (`brew`) to install Node Version Manager (nvm) on a macOS system. Nvm allows users to manage multiple installations of Node.js.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbrew install nvm\n```\n\n----------------------------------------\n\nTITLE: Creating an SSH Connection Alias (Shell)\nDESCRIPTION: This shell command defines an alias named `ruby-prod1`. When typed in the shell, this alias will be replaced by the command `ssh root@192.168.0.122`, providing a shortcut for connecting to the specified remote server via SSH. This line should be added to the user's local shell configuration file (e.g., `.bashrc`, `.zshrc`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_31\n\nLANGUAGE: shell\nCODE:\n```\nalias ruby-prod1='ssh root@192.168.0.122'\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Signout Button Component using Bash\nDESCRIPTION: This snippet shows the command to generate a new component named 'SignoutBtn' using the RedwoodJS CLI. This component will encapsulate the sign-out functionality.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn redwood generate component SignoutBtn\n```\n```\n\n----------------------------------------\n\nTITLE: Skipping Migration Step During Redwood Deploy - Bash\nDESCRIPTION: Demonstrates how to invoke the Redwood deployment command with the '--no-migrate' flag to skip running database migrations, potentially speeding up the deploy process. Assumes 'yarn' and Redwood CLI are installed. The command targets the 'baremetal' deploy provider for a 'production' environment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy baremetal production --no-migrate\n```\n\n----------------------------------------\n\nTITLE: Generating and Appending Secret Key to .env (Bash)\nDESCRIPTION: These commands generate a cryptographically secure secret key using `yarn redwood generate secret` with the `--raw` option (which prints only the key). The output is then appended to the `.env` file as the value for the `SESSION_SECRET` variable. Examples are provided for both Yarn v1 (`--silent`) and Yarn v3.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_84\n\nLANGUAGE: bash\nCODE:\n```\n# yarn v1\necho \"SESSION_SECRET=$(yarn --silent rw g secret --raw)\" >> .env\n\n# yarn v3\necho \"SESSION_SECRET=$(yarn rw g secret --raw)\" >> .env\n```\n\n----------------------------------------\n\nTITLE: Default Generated RedwoodJS Layout Component Code (JSX)\nDESCRIPTION: This code shows the default structure of a generated RedwoodJS Layout component (e.g., `UserLayout.js`). It's a simple React functional component that accepts `children` as a prop and renders them, typically within a shared page structure (though the default is just a fragment).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_53\n\nLANGUAGE: jsx\nCODE:\n```\n// title=\"./web/src/layouts/UserLayout/UserLayout.test.js\"\nconst UserLayout = ({ children }) => {\n  return <>{children}</>\n}\n\nexport default UserLayout\n```\n\n----------------------------------------\n\nTITLE: Defining a Storybook Story for a React Component (JSX/TSX)\nDESCRIPTION: This file defines a Storybook story for the `Article` React component, typically located in `web/src/components/Article/`. It imports the component and exports a named function (`generated`) which renders the `Article` component with inline mock data provided as props. This specific instance, named 'generated', appears under 'Components/Article' in the Storybook UI, as defined by the default export. This setup enables isolated development and testing of the component's appearance and behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/storybook.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Article/Article.stories.jsx\"\nimport Article from './Article'\n\nexport const generated = () => {\n  return (\n    <Article\n      article={{\n        id: 1,\n        title: 'First Post',\n        body: `Neutra tacos hot chicken prism raw denim, put\n              a bird on it enamel pin post-ironic vape cred\n              DIY. Street art next level umami squid.\n              Hammock hexagon glossier 8-bit banjo. Neutra\n              la croix mixtape echo park four loko semiotics\n              kitsch forage chambray. Semiotics salvia\n              selfies jianbing hella shaman. Letterpress\n              helvetica vaporware cronut, shaman butcher\n              YOLO poke fixie hoodie gentrify woke\n              heirloom.`,\n        createdAt: '2020-01-01T12:34:45Z'\n      }}\n    />\n  )\n}\n\nexport default { title: 'Components/Article' }\n```\n```\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/Article/Article.stories.tsx\"\nimport Article from './Article'\n\nexport const generated = () => {\n  return (\n    <Article\n      article={{\n        id: 1,\n        title: 'First Post',\n        body: `Neutra tacos hot chicken prism raw denim, put\n              a bird on it enamel pin post-ironic vape cred\n              DIY. Street art next level umami squid.\n              Hammock hexagon glossier 8-bit banjo. Neutra\n              la croix mixtape echo park four loko semiotics\n              kitsch forage chambray. Semiotics salvia\n              selfies jianbing hella shaman. Letterpress\n              helvetica vaporware cronut, shaman butcher\n              YOLO poke fixie hoodie gentrify woke\n              heirloom.`,\n        createdAt: '2020-01-01T12:34:45Z',\n      }}\n    />\n  )\n}\n\nexport default { title: 'Components/Article' }\n```\n```\n\n----------------------------------------\n\nTITLE: Passing ID Prop from ArticlePage to ArticleCell (JavaScript)\nDESCRIPTION: This updated JavaScript `ArticlePage` component (`web/src/pages/ArticlePage/ArticlePage.jsx`) demonstrates receiving the `id` prop, which RedwoodJS automatically provides from the URL's route parameter. This `id` is then passed as a prop to the `ArticleCell` component. RedwoodJS implicitly uses this `id` prop to fulfill the `$id` variable requirement in the cell's GraphQL query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ArticlePage/ArticlePage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport ArticleCell from 'src/components/ArticleCell'\n\n// highlight-next-line\nconst ArticlePage = ({ id }) => {\n  return (\n    <>\n      <Metadata title=\"Article\" description=\"Article page\" />\n\n      // highlight-next-line\n      <ArticleCell id={id} />\n    </>\n  )\n}\n\nexport default ArticlePage\n```\n```\n\n----------------------------------------\n\nTITLE: Updating GraphQL Query for Admin Post Detail Cell (JSX)\nDESCRIPTION: This snippet updates the PostCell frontend component to use the adminPost query for fetching post details by id in the admin area. The adminPost result is aliased to post to maintain UI compatibility. It returns id, title, body, and createdAt for rendering. The query uses RedwoodJS and GraphQL conventions and expects an $id variable.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query FindPostById($id: Int!) {\n    // highlight-next-line\n    post: adminPost(id: $id) {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Fetching Weather Data from Client-Side using Fetch API - JSX\nDESCRIPTION: Shows how to use the Fetch API within the HomePage onSubmit handler to get current weather data for a hardcoded zip code from the OpenWeather API. No external dependencies needed besides Fetch, available in modern browsers. The result is processed as JSON and logged to the console. API response is output to the browser console upon form submission. This version uses a static zip code value.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst onSubmit = (data) => {\n  fetch(\n    'https://api.openweathermap.org/data/2.5/weather?zip=66952,us&appid=YOUR_API_KEY'\n  )\n    .then((response) => response.json())\n    .then((json) => console.info(json))\n}\n```\n\n----------------------------------------\n\nTITLE: Adding 'roles' Field to User Model in Prisma Schema\nDESCRIPTION: This Prisma schema snippet defines the `User` model and adds a new required field `roles` of type `String`. This field is intended to store the role(s) assigned to a user for implementing role-based access control.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_0\n\nLANGUAGE: prisma\nCODE:\n```\nmodel User {\n  id                  Int @id @default(autoincrement())\n  name                String?\n  email               String @unique\n  hashedPassword      String\n  salt                String\n  resetToken          String?\n  resetTokenExpiresAt DateTime?\n  // highlight-next-line\n  roles               String\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Sentry User on Web via Layout - TypeScript (React)\nDESCRIPTION: TypeScript version for setting the current user context in Sentry from a React layout. Includes type annotations for component props. Relies on React (with hooks), a typed useAuth hook, and Sentry setup. Invokes Sentry.setUser using useEffect, updating user identity each time 'currentUser' changes. Meant for 'web/src/layouts/SentryLayout/SentryLayout.tsx'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/monitoring/sentry.md#_snippet_5\n\nLANGUAGE: TSX\nCODE:\n```\nimport React, { useEffect } from 'react'\n\nimport { useAuth } from 'src/lib/auth'\nimport Sentry from 'src/lib/sentry'\n\ninterface Props {\n  children: React.ReactNode\n}\n\nconst SentryLayout = ({ children }: Props) => {\n  const { currentUser } = useAuth()\n\n  useEffect(() => Sentry.setUser(currentUser), [currentUser])\n\n  return <>{children}</>\n}\n\nexport default SentryLayout\n```\n\n----------------------------------------\n\nTITLE: Setting Up Render Deployment Configuration in RedwoodJS\nDESCRIPTION: This command utilizes the RedwoodJS CLI (`yarn rw`) to set up the necessary configuration files and settings for deploying the application to Render. It can optionally configure database integration using the `--database` flag, which accepts `postgresql`, `sqlite`, or `none` (defaults to `postgresql`). This command should be run within the RedwoodJS project directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/render.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup deploy render\n```\n\n----------------------------------------\n\nTITLE: Integrating CommentForm into Article Component (JavaScript)\nDESCRIPTION: This JSX snippet shows the `Article` component importing and rendering the `CommentForm` and `CommentsCell`. The `CommentForm` is placed above the `CommentsCell` and both are conditionally rendered only when the `summary` prop is false (i.e., on the full article view). This initial integration doesn't yet pass the required `postId`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Article/Article.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-next-line\nimport CommentForm from 'src/components/CommentForm'\nimport CommentsCell from 'src/components/CommentsCell'\n\nconst truncate = (text, length) => {\n  return text.substring(0, length) + '...'\n}\n\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      {!summary && (\n        // highlight-start\n        <div className=\"mt-12\">\n          <CommentForm />\n          // highlight-end\n          <div className=\"mt-12\">\n            <CommentsCell />\n          </div>\n        // highlight-next-line\n        </div>\n      )}\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\n----------------------------------------\n\nTITLE: Incorrect and Correct Ways to Export SVG as Component (JavaScript/JSX)\nDESCRIPTION: Compares two styles for exporting SVGs as React components: a direct export (not supported) and the recommended approach (wrap import in a function component). Ensures compatibility with RedwoodJS's handling of SVGs as modules. Use the function component version for proper SSR/prerender support.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n// ❌ due to how Redwood handles SVGs, this syntax isn't supported.\nimport Logo from './Logo.svg'\nexport default Logo\n```\n\nLANGUAGE: jsx\nCODE:\n```\n// ✅ use this instead.\nimport Logo from './Logo.svg'\n\nconst LogoComponent = () => <Logo />\n\nexport default LogoComponent\n```\n\n----------------------------------------\n\nTITLE: Stacked Deploy Commands at Global, Environment, and Server Levels in TOML\nDESCRIPTION: This snippet shows how pre-install commands from global, environment, and server sections in 'deploy.toml' can all be defined. Their command sequences are executed in order, cascading from global to environment to server. Used to exemplify and test cumulative deployment hooks.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_26\n\nLANGUAGE: toml\nCODE:\n```\n[[production.servers]]\nhost = 'server.com'\n# ...\nbefore.install = 'touch server-install.lock'\n\n[production.before]\ninstall = ['touch prod-install1.lock', 'touch prod-install2.lock']\n\n[before]\ninstall = 'touch install.lock'\n```\n\n----------------------------------------\n\nTITLE: Updating JavaScript Success Component to Render Detailed Article Data (JSX)\nDESCRIPTION: This JSX snippet demonstrates updating the `Success` component within `ArticlesCell.jsx`. It iterates over the `articles` array (which now includes 'title', 'body', 'createdAt' due to the updated query) and renders each article's details within structured HTML elements like `<article>`, `<h2>`, `<p>`, and `<div>`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Success = ({ articles }) => {\n  return (\n    // highlight-start\n    <>\n      {articles.map((article) => (\n        <article key={article.id}>\n          <header>\n            <h2>{article.title}</h2>\n          </header>\n          <p>{article.body}</p>\n          <div>Posted at: {article.createdAt}</div>\n        </article>\n      ))}\n    </>\n    // highlight-end\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Available Redwood CLI Commands (Shell)\nDESCRIPTION: This command displays all available Redwood CLI commands, flags, and usage instructions. It's useful for discovering and learning about the Redwood CLI's capabilities. Requires a properly initialized Redwood project. Outputs help documentation in the terminal.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood --help\n```\n\n----------------------------------------\n\nTITLE: Adding Audit Logging to the emailUser Mutation (TypeScript)\nDESCRIPTION: Updates the `emailUser` mutation within the `users.ts` service. After successfully sending a test email via `sendTestEmail`, it calls `createAudit` from the audits service to log the event. This demonstrates how to chain service calls to perform related actions like sending an email and logging the action.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\n\nexport const emailUser = async ({ id }: Prisma.UserWhereUniqueInput) => {\n  // ...\n\n  await sendTestEmail(user.email)\n  await createAudit({\n    input: { userId: id, log: 'Admin sent test email to user' },\n  })\n\n  // ...\n}\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Seeding the Database with Redwood Prisma (Bash)\nDESCRIPTION: Executes the database seeding script (typically `scripts/seed.js` or `scripts/seed.ts`) defined in the project. Seeding populates the database with initial or dummy data. This command is triggered by `prisma db seed` and potentially during `migrate reset` or `migrate dev` unless `--skip-seed` is used.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_99\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood prisma db seed\n```\n\n----------------------------------------\n\nTITLE: Synchronous Custom Validation with validateWithSync() in JavaScript/JSX\nDESCRIPTION: validateWithSync runs a provided synchronous function, which must throw if validation fails (string or Error object). Errors are caught and rethrown as ServiceValidationError with the provided message, ideal for RedwoodJS/GraphQL workflows to safely expose error messages. Requires validateWithSync() implementation and optionally ServiceValidationError to be available.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_49\n\nLANGUAGE: jsx\nCODE:\n```\nvalidateWithSync(() => {\n  if (input.name === 'Name') {\n    throw \"You'll have to be more creative than that\"\n  }\n})\n\n```\n\nLANGUAGE: jsx\nCODE:\n```\nvalidateWithSync(() => {\n  if (input.name === 'Name') {\n    throw new Error(\"You'll have to be more creative than that\")\n  }\n})\n\n```\n\n----------------------------------------\n\nTITLE: Updating Prisma Schema for User-Post Relationship\nDESCRIPTION: Modifies the Prisma schema (`schema.prisma`) to establish a one-to-many relationship between `User` and `Post` models. It adds a required `userId` field and a `user` relation field to the `Post` model, and a `posts` relation field (representing the list of posts by the user) to the `User` model. This change requires a subsequent database migration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  body      String\n  comments  Comment[]\n  // highlight-start\n  user      User     @relation(fields: [userId], references: [id])\n  userId    Int\n  // highlight-end\n  createdAt DateTime @default(now())\n}\n\nmodel User {\n  id                  Int @id @default(autoincrement())\n  name                String?\n  email               String @unique\n  hashedPassword      String\n  salt                String\n  resetToken          String?\n  resetTokenExpiresAt DateTime?\n  roles               String @default(\"moderator\")\n  // highlight-next-line\n  posts               Post[]\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Article Component into ArticlesCell (JSX)\nDESCRIPTION: Modifies the 'ArticlesCell' JavaScript component's (`web/src/components/ArticlesCell/ArticlesCell.jsx`) `Success` state. It imports the reusable 'Article' component and uses it within the `map` function to render each article fetched by the `ArticlesQuery`. Each 'Article' component receives the corresponding article data as a prop, replacing the previous inline rendering logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_29\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport Article from 'src/components/Article'\n\nexport const QUERY = gql`\n  query ArticlesQuery {\n    articles: posts {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({ articles }) => {\n  return (\n    <>\n      {articles.map((article) => (\n        // highlight-next-line\n        <Article key={article.id} article={article} />\n      ))}\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Running TypeScript Type Checks in RedwoodJS - Shell\nDESCRIPTION: This command performs a type check across the RedwoodJS project using the TypeScript compiler (tsc) via the Redwood CLI's 'type-check' command. It ensures that all necessary generated types are prepared before checking, providing a safeguard separate from the Babel transpilation used in Redwood. No parameters are required, and running this command helps maintain strict type safety in the codebase.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/introduction.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw type-check\n```\n\n----------------------------------------\n\nTITLE: Installing Redwood Auth with GoTrue Provider (Shell / Bash)\nDESCRIPTION: This Bash snippet demonstrates the CLI command to scaffold RedwoodJS authentication using GoTrue as the provider. Running this command installs required dependencies, creates initial configuration files, and ensures the project is set up to use Netlify's GoTrue API for authentication. It must be run from the project's root folder using a terminal. Expected input is the shell command with provider as 'goTrue', and output is an updated RedwoodJS project structure ready for further authentication development.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup auth goTrue\n```\n\n----------------------------------------\n\nTITLE: Signing In with Passwordless/OTP using RedwoodJS `useAuth` Hook (TypeScript)\nDESCRIPTION: Logs in a user via a magic link or one-time password (OTP) sent to their email or phone. Uses the `logIn` method from the RedwoodJS `useAuth` hook with `authMethod: 'otp'`, requiring either an email or phone number. An optional redirect URL can be specified.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst { logIn } = useAuth()\n\nawait logIn({\n  authMethod: 'otp',\n  email: 'example@email.com',\n  options: {\n    emailRedirectTo: 'https://example.com/welcome',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Comments GraphQL SDL to require postId argument - JavaScript\nDESCRIPTION: This GraphQL SDL modification updates the comments query to accept a required postId argument. It ensures that any query to comments must include an Int postId and labels the field with the @skipAuth directive. The definition must synchronize with the service and frontend for full-stack correctness.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_36\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Query {\\n  // highlight-next-line\\n  comments(postId: Int!): [Comment!]! @skipAuth\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Join Record for an Explicit Many-to-Many Relationship in JSX\nDESCRIPTION: To establish a link in an explicit many-to-many relationship, you need to create a record in the join table (e.g., `ProductCategory`). First, retrieve or create the records on both sides of the relationship (e.g., `Product` and `Category`). Then, use the `create` method on the join table model, providing the foreign keys (`productId`, `categoryId`) of the records to link.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_34\n\nLANGUAGE: jsx\nCODE:\n```\nconst product = await Product.find(123)\nconst category = await Category.find(234)\nawait ProductCategory.create({ productId: product.id, categoryId: category.id })\n```\n\n----------------------------------------\n\nTITLE: Setting Sentry User Identity on API - TypeScript\nDESCRIPTION: Provides a TypeScript implementation for setting the current user context in Sentry on the API side. The snippet is similar to the JavaScript version but uses '.ts' conventions for type safety. Requires the local Sentry integration and access to a typed user from the database. File location is 'api/src/lib/auth.ts'. Sentry.setUser is used to provide additional context in error reporting.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/monitoring/sentry.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport Sentry from 'src/lib/sentry'\n\nexport const getCurrentUser = async (...) => {\n  const user = await db.user.findUnique(...)\n\n  Sentry.setUser(user)\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Prisma Schema Provider to PostgreSQL in JavaScript\nDESCRIPTION: Modifies the `schema.prisma` file to specify PostgreSQL as the database provider within the `datasource` block. This change is required for deploying to environments like Netlify that do not support SQLite's file-based storage, ensuring Prisma generates compatible migrations and clients for PostgreSQL.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/deployment.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nprovider = 'postgresql'\n```\n\n----------------------------------------\n\nTITLE: Filtering Requests by HTTP Method in RedwoodJS Function Handler (JavaScript)\nDESCRIPTION: Updates the `serverTime` function handler (`api/src/functions/serverTime.js`) to restrict access based on the HTTP request method. It inspects the `event.httpMethod` property and returns a 404 Not Found status code if the method is not 'GET', ensuring the endpoint adheres more closely to REST principles for retrieving data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nexport const handler = async (event, context) => {\n  if (event.httpMethod !== 'GET') {\n    return { statusCode: 404 }\n  }\n\n  return {\n    statusCode: 200,\n    headers: { 'Content-Type': 'application/json ' },\n    body: JSON.stringify({ time: new Date() }),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Existing Scenario Records in RedwoodJS - JSX\nDESCRIPTION: Demonstrates accessing previously created scenario records via function syntax to reference their IDs for relationships. By defining scenario keys as functions that receive a scenario context, you enable dynamic assignment of foreign keys, ensuring authors and comments are correctly connected to the intended users. This is vital for creating realistic test data with accurate relationships and is supported for sequence order dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_64\n\nLANGUAGE: jsx\nCODE:\n```\nexport const standard = defineScenario({\n  author: {\n    kris: {\n      data: { name: 'Kris' }\n    }\n    rob: {\n      data: { name: 'rob' }\n    }\n  },\n  post: {\n    first: (scenario) => ({\n     data: {\n        name: 'First Post',\n        authorId: scenario.author.kris.id,\n        comments: {\n          create: [\n            {\n              name: 'First Comment',\n              body: 'String',\n              authorId: scenario.author.rob.id,\n            },\n            {\n              name: 'First Comment Response',\n              body: 'String',\n              authorId: scenario.author.kris.id,\n            },\n          ],\n        },\n      }\n    }),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Up GraphQL Trusted Documents in RedwoodJS - Bash\nDESCRIPTION: This setup command prepares the RedwoodJS project to use GraphQL trusted documents, updating configuration and optionally creating required files like an experimental server file if it does not exist. Inputs include only the command and optional flags. Outputs are configuration updates, new files, and enhanced security for the API layer. Prerequisite is a functional RedwoodJS environment; use with --force to overwrite files as needed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_122\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup graphql trusted-documents\n```\n\n----------------------------------------\n\nTITLE: Chaining Validator and Transformer Directives in RedwoodJS GraphQL SDL\nDESCRIPTION: This GraphQL SDL snippet shows chaining a validator (`@requireAuth`) and a transformer (`@maskedEmail`) directive on the `email` field within the `User` type. This ensures that only authenticated users can request the email field, and for those authenticated users, the `@maskedEmail` transformation logic will then be applied.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_16\n\nLANGUAGE: graphql\nCODE:\n```\n  type User {\n    id: Int!\n    name: String!\n    email: String! @requireAuth @maskedEmail\n    createdAt: DateTime!\n  }\n```\n\n----------------------------------------\n\nTITLE: Calling User Retrieval/Creation Logic (JavaScript)\nDESCRIPTION: Snippet showing the specific lines within the `callback` function where the external provider user information (`providerUser`) is obtained (via `getProviderUser`) and then passed to the `getUser` function along with the access token and scope to either retrieve or create the local user and update identity details. The resulting user object is then returned in the response.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst providerUser = await getProviderUser(access_token)\n// highlight-next-line\nconst user = await getUser({ providerUser, accessToken: access_token, scope })\nreturn {\n  body: JSON.stringify(user),\n}\n```\n\n----------------------------------------\n\nTITLE: Running Redwood's Integrated Test Suite with Jest (Shell)\nDESCRIPTION: This command runs the complete test suite for the Redwood project using Jest, covering both frontend and backend code. Requires test files to be present alongside Redwood components and services. This will execute unit, integration, and scenario tests, displaying pass/fail results in the terminal.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw test\n```\n\n----------------------------------------\n\nTITLE: Processing Existing Jobs and Exiting (Dev Mode) using Bash\nDESCRIPTION: This command runs the job workers to process all currently available jobs in the queue. Once the queue is empty or only contains jobs scheduled for the future, the process automatically exits. Useful for clearing a backlog during development.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs workoff\n```\n\n----------------------------------------\n\nTITLE: Running RedwoodJS Tests with yarn (Bash)\nDESCRIPTION: This bash command starts the RedwoodJS test runner. It is a required step before running any test cases in a RedwoodJS project, allowing real-time monitoring of test suites. No parameters are needed; outputs are shown in the terminal and failures are displayed inline.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test\n\n```\n\n----------------------------------------\n\nTITLE: Defining ArticleCell Query and States (JavaScript)\nDESCRIPTION: Defines the GraphQL query (`FindArticleQuery`) within the `ArticleCell` (JavaScript version) to fetch specific fields (`id`, `title`, `body`, `createdAt`) of a post by its `$id`. It aliases the `post` query field to `article` for use within the component. Standard RedwoodJS Cell state components (`Loading`, `Empty`, `Failure`, `Success`) are also defined.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query FindArticleQuery($id: Int!) {\n    // highlight-next-line\n    article: post(id: $id) {\n      id\n      // highlight-start\n      title\n      body\n      createdAt\n      // highlight-end\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({ article }) => {\n  return <div>{JSON.stringify(article)}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Existent Tracking Number in RedwoodJS Webhook (JSX)\nDESCRIPTION: This JSX test scenario for a RedwoodJS webhook checks the behavior when the payload contains a tracking number that does not correspond to any existing order. It uses `mockSignedWebhook` to create a validly signed event but with a non-existent `trackingNumber`. The test asserts that the handler returns a 500 status code and the response body includes an 'error' property.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_24\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\nscenario(\n  'when the tracking number cannot be found, returns an error',\n  async (scenario) => {\n    const order = scenario.order.placed\n\n    const payload = { trackingNumber: '1Z-DOES-NOT-EXIST', status: 'DELIVERED' }\n    const event = mockSignedWebhook({\n      payload,\n      signatureType: 'sha256Verifier',\n      signatureHeader: 'X-Webhook-Signature',\n      secret: 'MY-VOICE-IS-MY-PASSPORT-VERIFY-ME',\n    })\n\n    const result = await handler(event)\n\n    const body = JSON.parse(result.body)\n\n    expect(result.statusCode).toBe(500)\n    expect(body).toHaveProperty('error')\n  }\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring DbAuthHandler for WebAuthn in RedwoodJS API (JavaScript)\nDESCRIPTION: This snippet configures the `DbAuthHandler` in the `api/src/functions/auth.js` file to enable and customize WebAuthn authentication. It specifies the `credentialModelAccessor` for the WebAuthn credential model and the `challenge` field within `authFields`. The `webAuthn` object contains detailed settings like enabling the feature, session expiry, application name, domain/origin details, allowed authenticator types (`platform`, `cross-platform`, `any`), request timeout, and mappings for credential fields in the database model. Dependencies include `@redwoodjs/api` and the application's database connection (`src/lib/db`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/functions/auth.js\"\nimport { db } from 'src/lib/db'\nimport { DbAuthHandler } from '@redwoodjs/api'\n\nexport const handler = async (event, context) => {\n  // assorted handler config here...\n\n  const authHandler = new DbAuthHandler(event, context, {\n    db: db,\n    authModelAccessor: 'user',\n    // highlight-start\n    credentialModelAccessor: 'userCredential',\n    // highlight-end\n    authFields: {\n      id: 'id',\n      username: 'email',\n      hashedPassword: 'hashedPassword',\n      salt: 'salt',\n      resetToken: 'resetToken',\n      resetTokenExpiresAt: 'resetTokenExpiresAt',\n      // highlight-start\n      challenge: 'webAuthnChallenge',\n      // highlight-end\n    },\n\n    cookie: {\n      attributes: {\n        HttpOnly: true,\n        Path: '/',\n        SameSite: 'Lax',\n        Secure: process.env.NODE_ENV !== 'development' ? true : false,\n      },\n    },\n\n    forgotPassword: forgotPasswordOptions,\n    login: loginOptions,\n    resetPassword: resetPasswordOptions,\n    signup: signupOptions,\n\n    // highlight-start\n    webAuthn: {\n      enabled: true,\n      expires: 60 * 60 * 14,\n      name: 'Webauthn Test',\n      domain:\n        process.env.NODE_ENV === 'development' ? 'localhost' : 'server.com',\n      origin:\n        process.env.NODE_ENV === 'development'\n          ? 'http://localhost:8910'\n          : 'https://server.com',\n      type: 'platform',\n      timeout: 60000,\n      credentialFields: {\n        id: 'id',\n        userId: 'userId',\n        publicKey: 'publicKey',\n        transports: 'transports',\n        counter: 'counter',\n      },\n    },\n    // highlight-end\n  })\n\n  return await authHandler.invoke()\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a Validator Directive Stub in RedwoodJS (TypeScript)\nDESCRIPTION: Presents the boilerplate `validate` function signature (`ValidatorDirectiveFunc`) for a generated RedwoodJS Validator directive. It demonstrates how to access the GraphQL `context` and `directiveArgs` (arguments passed to the directive in the SDL, e.g., `roles` in `@requireAuth(roles: \"ADMIN\")`). The example includes logging `directiveArgs` and throwing a placeholder error, indicating where custom validation logic should be implemented. Validator functions run before field resolution and should throw errors to halt execution if validation fails.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_25\n\nLANGUAGE: tsx\nCODE:\n```\nconst validate: ValidatorDirectiveFunc = ({ context, directiveArgs }) => {\n  // You can also modify your directive to take arguments\n  // and use the directiveArgs object provided to this function to get values\n  logger.debug(directiveArgs, 'directiveArgs in isSubscriber directive')\n\n  throw new Error('Implementation missing for isSubscriber')\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Article Component for Summary View (JSX)\nDESCRIPTION: This JavaScript (JSX) snippet modifies the `Article` component to include a `truncate` helper function and a `summary` boolean prop. If `summary` is true, the `article.body` is truncated to 100 characters; otherwise, the full body is displayed. The component uses `Link` and `routes` from `@redwoodjs/router` for navigation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-story.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Article/Article.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-start\nconst truncate = (text, length) => {\n  return text.substring(0, length) + '...'\n}\n// highlight-end\n\n// highlight-next-line\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article className=\"mt-10\">\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        // highlight-next-line\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Cell Mock Data with Query Changes\nDESCRIPTION: Shows the required synchronization between a Cell's `QUERY` and its mock data (`standard` export in `.mock.js`). When a field (like `name`) is added to the `QUERY`, the corresponding field must also be added to the `standard` mock object to ensure the mock provides the expected data structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/mocking-graphql-requests.md#_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\n  export const QUERY = gql`\n    query UserProfileQuery {\n      userProfile {\n         id\n+       name\n      }\n    }\n  `\n \n  // UserProfileCell/UserProfileCell.mock.js\n  export const standard = {\n    userProfile: {\n      __typename: 'UserProfile' as const,\n      id: 42,\n+     name: 'peterp',\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Configuring Redwood Realtime Options with In-Memory or Redis Store in TypeScript\nDESCRIPTION: This TypeScript code sets up RedwoodJS's realtime options for subscriptions and live queries within 'api/lib/realtime.ts'. It allows developers to select between an in-memory store (recommended for development/testing) and a Redis-backed store (for production) for real-time PubSub data. To enable Redis, import 'ioredis' and instantiate publish/subscribe clients. 'enableDeferStream' can be toggled to support defer/stream directives; these are false by default. Requires '@redwoodjs/realtime', optional 'ioredis', and the 'subscriptions' modules.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RedwoodRealtimeOptions } from '@redwoodjs/realtime'\n\nimport subscriptions from 'src/subscriptions/**/*.{js,ts}'\n\n// if using a Redis store\n// import { Redis } from 'ioredis'\n// const publishClient = new Redis()\n// const subscribeClient = new Redis()\n\n/**\n * Configure RedwoodJS Realtime\n *\n * See https://redwoodjs.com/docs/realtime\n *\n * Realtime supports Live Queries and Subscriptions over GraphQL SSE.\n *\n * Live Queries are GraphQL queries that are automatically re-run when the data they depend on changes.\n *\n * Subscriptions are GraphQL queries that are run when a client subscribes to a channel.\n *\n * Redwood Realtime\n *  - uses a publish/subscribe model to broadcast data to clients.\n *  - uses a store to persist Live Query and Subscription data.\n *\n * Redwood Realtime supports in-memory and Redis stores:\n * - In-memory stores are useful for development and testing.\n * - Redis stores are useful for production.\n */\nexport const realtime: RedwoodRealtimeOptions = {\n  subscriptions: {\n    subscriptions,\n    store: 'in-memory',\n    // if using a Redis store\n    // store: { redis: { publishClient, subscribeClient } },\n  },\n  liveQueries: {\n    store: 'in-memory',\n    // if using a Redis store\n    // store: { redis: { publishClient, subscribeClient } },\n  },\n  // To enable defer and streaming, set to true.\n  // enableDeferStream: true,\n}\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query Response - API Output - json\nDESCRIPTION: This JSON snippet represents the typical response format from the 'GetProject' GraphQL query, including the shape of returned data and error handling. The response shows the project root node with nested objects for the owner and tags, and an explicit 'errors' property. Consumers should expect the response to maintain key-field symmetry with the original GraphQL query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\": {\n    \"project\": {\n      \"id\": 1,\n      \"title\": \"My Project\",\n      \"description\": \"Lorem ipsum...\",\n      \"owner\": {\n        \"id\": 11,\n        \"username\": \"Redwood\"\n      },\n      \"tags\": [{ \"id\": 22, \"name\": \"graphql\" }]\n    }\n  },\n  \"errors\": null\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Multi-Select Dropdown with React SelectField (JSX)\nDESCRIPTION: This snippet demonstrates how to render a multi-select dropdown component using <SelectField> with multiple options in React JSX. It shows how the multiple prop returns an array of selected values and illustrates the shape of the submitted form data. No external dependencies are required beyond the form library providing <SelectField>, and the snippet expects user-selected values as input, returning them as an ordered array in the result.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/forms.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\n<SelectField name=\\\"toppings\\\" multiple={true}>\n  <option>'lettuce'</option>\n  <option>'tomato'</option>\n  <option>'pickle'</option>\n  <option>'cheese'</option>\n</SelectField>\n\n// If the user chooses lettuce, tomato, and cheese,\n// the onSubmit handler receives:\n//\n// { toppings: [\\\"lettuce\\\", \\\"tomato\\\", \\\"cheese\\\"] }\n//\n\n```\n\n----------------------------------------\n\nTITLE: Configuring CD Workflow for Database Deployment and Testing - GitHub Actions YAML\nDESCRIPTION: This YAML snippet defines a complete GitHub Actions workflow (cd.yml) to automate deployment tasks for a RedwoodJS project when code is pushed to the 'main' branch. It sets environment variables for both the production and test databases, uses a Postgres container as a service, and runs a matrix build for Node.js 20.x. It sequentially installs dependencies, builds the Redwood app, runs API and web tests, applies database migrations, and seeds the database. Dependencies include GitHub-hosted runners, Node.js, Yarn, and a Docker-based Postgres service. The workflow expects valid connection strings and database migrations/scripts to be defined.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_10\n\nLANGUAGE: YAML\nCODE:\n```\nname: Redwood CD for database deployment\\n\\non:\\n  push:\\n    branches: ['main']\\n\\nenv:\\n  DATABASE_URL: postgres://postgres:postgres@localhost:5432/postgres\\n  TEST_DATABASE_URL: postgres://postgres:postgres@localhost:5432/postgres\\n\\njobs:\\n  build:\\n    runs-on: ubuntu-latest\\n\\n    strategy:\\n      matrix:\\n        node-version: [20.x]\\n        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/\\n\\n    services:\\n      # Label used to access the service container\\n      postgres:\\n        # Docker Hub image\\n        image: postgres\\n        # Provide the password for postgres\\n        env:\\n          POSTGRES_PASSWORD: postgres\\n        # Set health checks to wait until postgres has started\\n        options: >-\\n          --health-cmd pg_isready\\n          --health-interval 10s\\n          --health-timeout 5s\\n          --health-retries 5\\n        ports:\\n          # Maps tcp port 5432 on service container to the host\\n          - 5432:5432\\n\\n    steps:\\n      - uses: actions/checkout@v4\\n      - name: Use Node.js ${{ matrix.node-version }}\\n        uses: actions/setup-node@v4\\n        with:\\n          node-version: ${{ matrix.node-version }}\\n      - run: corepack enable\\n      # install all the dependencies\\n      - run: yarn install\\n      # build the redwood app\\n      - run: yarn rw build\\n      # run the api tests\\n      - run: yarn rw test api --no-watch\\n      # run the web tests\\n      - run: yarn rw test web --no-watch\\n      # run migrations on the actual database\\n      - run: yarn rw prisma migrate deploy\\n      # run seed script in the actual db\\n      - run: yarn rw prisma db seed\\n\n```\n\n----------------------------------------\n\nTITLE: Acquiring Additional Tokens with Custom Scopes - JS\nDESCRIPTION: This example fetches a token for additional API access by customizing the scopes in a getToken call (assumed to be provided by RedwoodJS or a related auth context). It requests the 'Mail.Read' scope, which is appended to the default scopes ('openid', 'profile', and any logged-in user scopes). Use this when you need incremental consent for higher-privileged API permissions post-login. The code is asynchronous and expects an authorized auth context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/azure.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nawait getToken({\n  scopes: ['Mail.Read'], // becomes ['openid', 'profile', 'User.Read.All', 'Mail.Read']\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Comments GraphQL SDL to require postId argument - TypeScript\nDESCRIPTION: Similar to the JavaScript SDL, this GraphQL snippet (likely in a TypeScript codebase) updates the comments query to take a required postId argument of type Int. It aligns with both the service implementation and frontend query requirements, enhancing query type safety and backend enforcement.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_37\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Query {\\n  // highlight-next-line\\n  comments(postId: Int!): [Comment!]! @skipAuth\\n}\n```\n\n----------------------------------------\n\nTITLE: Running RedwoodJS Tests using Yarn (Shell)\nDESCRIPTION: Executes the RedwoodJS test runner (`yarn rw test`) within the project directory to run the initial set of tests included with a new Redwood app. This verifies the basic test setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn rw test\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Scaffold for UserExample Model (Shell)\nDESCRIPTION: Executes the RedwoodJS scaffold generator (`yarn rw g scaffold UserExample`) to automatically create the necessary frontend pages/components and backend SDL/services for CRUD operations on the `UserExample` model defined in the Prisma schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nyarn rw g scaffold UserExample\n```\n\n----------------------------------------\n\nTITLE: Manually Overriding a GraphQL Query Mock with mockGraphQLQuery - Storybook - JavaScript\nDESCRIPTION: This snippet uses the `mockGraphQLQuery` utility in a Storybook story to provide a custom mock for the `UserProfileQuery`. It overwrites any global mock by returning a different mock object during the test. The pattern allows for per-story customization of mocked query data. Prerequisites: Storybook with RedwoodJS; dependencies: `mockGraphQLQuery`. Inputs: query name, custom callback; outputs: mocked GraphQL response.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/mocking-graphql-in-storybook.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nexport const withReallyLongName = () => {\n  mockGraphQLQuery('UserProfileQuery', () => {\n    return {\n      userProfile: {\n        id: 99,\n        name: 'Hubert Blaine Wolfeschlegelsteinhausenbergerdorff Sr.'\n      }\n    }\n  })\n  return <Header />\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Test Email Function in Users Service (TypeScript)\nDESCRIPTION: Creates a helper function `sendTestEmail` within the `users.ts` service. This function takes an email address, constructs predefined subject, text, and HTML content for a test email, and then invokes the imported `sendEmail` function to dispatch the email.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\n\nfunction sendTestEmail(emailAddress: string) {\n  const subject = 'Test Email'\n  const text =\n    'This is a manually triggered test email.\\n\\n' +\n    'It was sent from a RedwoodJS application.'\n  const html =\n    'This is a manually triggered test email.<br><br>' +\n    'It was sent from a RedwoodJS application.'\n  return sendEmail({ to: emailAddress, subject, text, html })\n}\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Installing Honeybadger Client using Yarn Workspaces\nDESCRIPTION: Shell command using Yarn Workspaces to install the official Honeybadger JavaScript client (`@honeybadger-io/js`) into the `api` workspace of a RedwoodJS project. This package is needed to send logs or errors to Honeybadger.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\nyarn workspace api add @honeybadger-io/js\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Set Prop Forwarding to Wrapper Components - RedwoodJS - JSX\nDESCRIPTION: This snippet shows how the Set component in RedwoodJS forwards all props (except for 'wrap') to its wrapper components. By specifying additional props on Set (like theme), they are passed to the layout or context wrapper. This enables easy customization and parameterization of layout components for grouped routes. Example demonstrates wrapping the home route in MainLayout with a 'dark' theme prop.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<Set wrap={MainLayout} theme=\"dark\">\n  <Route path=\"/\" page={HomePage} name=\"home\" />\n</Set>\n```\n\n----------------------------------------\n\nTITLE: Configuring Separate Worker Groups for Multiple Queues with RedwoodJS JobManager in JavaScript\nDESCRIPTION: Demonstrates a JobManager setup with separate worker configurations for different queues (\\\"default\\\" and \\\"email\\\") using the PrismaAdapter. Each worker group has individualized parameters like queue name, concurrency, maxAttempts, and behavior for failed jobs. This configuration allows for assigning distinct workloads and retry strategies per queue. Dependencies: JobManager, PrismaAdapter, db, logger. Key parameters include adapter, queue, count, maxAttempts, maxRuntime, and deleteFailedJobs. Returns a JobManager instance supporting multiple queues and custom worker behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_33\n\nLANGUAGE: js\nCODE:\n```\nexport const jobs = new JobManager({\n  adapters: {\n    prisma: new PrismaAdapter({ db, logger }),\n  },\n  queues: ['default'],\n  logger,\n  workers: [\n    {\n      adapter: 'prisma',\n      logger,\n      // highlight-start\n      queue: 'default',\n      // highlight-end\n      count: 1,\n      maxAttempts: 24,\n      maxRuntime: 14_400,\n      deleteFailedJobs: false,\n      sleepDelay: 5,\n    },\n    {\n      adapter: 'prisma',\n      logger,\n      // highlight-start\n      queue: 'email',\n      count: 1,\n      maxAttempts: 1,\n      maxRuntime: 30,\n      deleteFailedJobs: true,\n      // highlight-end\n      sleepDelay: 5,\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Combined Nested Objects and Arrays in OpenGraph Metadata - JSX\nDESCRIPTION: This advanced <Metadata> usage demonstrates composing arrays and nested objects in props to define complex OpenGraph meta structures, including property extensions like width and height alongside image URLs. Requires careful object/array assembly as shown. Inputs are an 'og' object with nested arrays/objects; output is a flat list of precise meta tags as per OpenGraph spec.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata\n  og={{\n    image: [\n      'http://host.test/image1.jpg',\n      { width: 320, height: 240 },\n      'http://host.test/image2.jpg',\n      'http://host.test/image3.jpg',\n      { width: 1024 },\n      { height: 768 },\n    ],\n  }}\n/>\n// generates\n<meta property=\"og:image\" content=\"http://host.test/image1.jpg\" />\n<meta property=\"og:image:width\" content=\"320\" />\n<meta property=\"og:image:height\" content=\"240\" />\n<meta property=\"og:image\" content=\"http://host.test/image2.jpg\" />\n<meta property=\"og:image\" content=\"http://host.test/image3.jpg\" />\n<meta property=\"og:image:width\" content=\"1024\" />\n<meta property=\"og:image:height\" content=\"768\" />\n\n```\n\n----------------------------------------\n\nTITLE: Defining Prisma User Model for Passwordless Auth - JSX\nDESCRIPTION: This Prisma schema snippet defines a User model, including fields for id, name, email, loginToken, loginTokenExpiresAt, and salt. The loginToken and expiration fields are essential for implementing passwordless authentication. Dependencies: Prisma ORM, a configured database. Key parameters: email (unique identifier), loginToken (for temporary authentication), and loginTokenExpiresAt (for token expiration). No support for password-based logins in this configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nmodel User {\n  id                  Int       @id @default(autoincrement())\n  name                String?\n  email               String    @unique\n  loginToken          String\n  loginTokenExpiresAt DateTime?\n  salt                String?\n}\n```\n\n----------------------------------------\n\nTITLE: Example JSON Error for Exceeding Request Body Size Limit\nDESCRIPTION: This JSON object represents a typical error response from the RedwoodJS API server (powered by Fastify) when an incoming request's body size exceeds the configured limit. The `code` \"FST_ERR_CTP_BODY_TOO_LARGE\" and the \"Payload Too Large\" message indicate that the uploaded file(s) are larger than allowed by the server's `bodyLimit` setting.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_23\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"code\": \"FST_ERR_CTP_BODY_TOO_LARGE\",\n  \"error\": \"Payload Too Large\",\n  \"message\": \"Request body is too large\"\n}\n```\n\n----------------------------------------\n\nTITLE: Using useIsBrowser Hook for Runtime Context Checks (JavaScript/JSX)\nDESCRIPTION: Demonstrates the use of the useIsBrowser React hook to check if code is executing in the browser context or during prerender/SSR. This enables conditional logic based on environment. Requires importing useIsBrowser from '@redwoodjs/prerender/browserUtils'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useIsBrowser } from '@redwoodjs/prerender/browserUtils'\n\nconst MySpecialComponent = () => {\n  const browser = useIsBrowser()\n\n  return (\n    <div className=\"my-4 p-5 rounded-lg border-gray-200 border\">\n      <h1 className=\"text-xl font-bold\">Render info:</h1>\n\n      {browser ? <h2 className=\"text-green-500\">Browser</h2> : <h2 className=\"text-red-500\">Prerendered</h2>}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Authentication Cookie Attributes in JavaScript\nDESCRIPTION: Defines settings for the session cookie used by dbAuth. The `attributes` object controls browser cookie behavior, including `HttpOnly` (prevents client-side script access), `Path` (scope of the cookie), `SameSite` ('Lax' by default, controls cross-site request behavior), `Secure` (requires HTTPS), and optionally `Domain`. The `name` of the cookie can also be customized.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\ncookie: {\n  attributes: {\n    HttpOnly: true,\n    Path: '/',\n    SameSite: 'Lax',\n    Secure: true,\n    // Domain: 'example.com',\n  },\n  // name: 'session_%port%',\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Article with Author Name - RedwoodJS - JSX\nDESCRIPTION: This React component renders an article and its author's name using data fetched from GraphQL. It uses RedwoodJS routing and expects an 'article' prop with properties id, title, body, and user (containing name). Dependencies are '@redwoodjs/router' and correct GraphQL query structure. Input is the article object, and outputs a styled article element with clickable title and byline. Constraints: 'article.user' must exist for the author's name to display.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n\nconst Article = ({ article }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n          // highlight-start\n          <span className=\"ml-2 text-gray-400 font-normal\">\n            by {article.user.name}\n          </span>\n          // highlight-end\n        </h2>\n      </header>\n\n      <div className=\"mt-2 text-gray-900 font-light\">{article.body}</div>\n    </article>\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Refetching Comments After Creating a Comment - React Mutation Hook (JavaScript)\nDESCRIPTION: This hook snippet demonstrates how to use the useMutation hook in RedwoodJS to create a comment and ensure the relevant comments query is refetched with the appropriate postId variable. This guarantees that after a comment is posted, the UI updates to display the latest comments. Dependencies include Apollo Client's useMutation, the CREATE mutation, and CommentsQuery. Inputs: postId as a variable; outputs: triggers query refetch and toast notification. Requires useMutation context and proper GraphQL definitions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_42\n\nLANGUAGE: JSX\nCODE:\n```\nconst [createComment, { loading, error }] = useMutation(CREATE, {\n  onCompleted: () => {\n    setHasPosted(true)\n    toast.success('Thank you for your comment!')\n  },\n  // highlight-next-line\n  refetchQueries: [{ query: CommentsQuery, variables: { postId } }],\n})\n```\n\n----------------------------------------\n\nTITLE: Listening to Auth Events using Supabase Client in RedwoodJS (TypeScript)\nDESCRIPTION: Shows how to subscribe to Supabase authentication state changes (e.g., `SIGNED_IN`, `SIGNED_OUT`) using the `onAuthStateChange` method on the Supabase client obtained via `useAuth().client`. The subscription should be set up in a `useEffect` hook and cleaned up on component unmount.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst { client } = useAuth()\n\nuseEffect(() => {\n  const {\n    data: { subscription },\n  } = client.onAuthStateChange((event, session) => {\n    console.log(event, session)\n  })\n\n  return () => {\n    subscription.unsubscribe()\n  }\n}, [client])\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Signup Page Component Structure (JSX)\nDESCRIPTION: This snippet shows the initial implementation of the `SignupPage` functional component in React/RedwoodJS. It imports `Form`, `TextField`, `PasswordField`, and `Submit` from `@redwoodjs/forms` to construct a basic user interface for signing up. The form includes fields for email and password, along with a submit button.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\n\nconst SignupPage = () => {\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form>\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Defining a Storybook Story for the Comment Component - RedwoodJS TypeScript\nDESCRIPTION: This TypeScript snippet provides a Storybook story setup for the Comment component. It uses a sample comment prop to display the UI state in Storybook, helpful for both development and documentation. The sample comment and expected prop types are consistent with the component, and no additional dependencies are required beyond RedwoodJS and Storybook.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/the-redwood-way.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport Comment from './Comment'\n\nexport const generated = () => {\n  // highlight-start\n  return (\n    <Comment\n      comment={{\n        name: 'Rob Cameron',\n        body: 'This is the first comment!',\n        createdAt: '2020-01-01T12:34:56Z',\n      }}\n    />\n  )\n  // highlight-end\n}\n\nexport default {\n  title: 'Components/Comment',\n  component: Comment,\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of Conditional Cache Key Logic with findFirst and cache() - JavaScript\nDESCRIPTION: Contains a manual sequence obtaining the most recently updated record, then constructing a cache key based on that record's id and update timestamp. This mirrors the internal pattern of `cacheFindMany()`, providing more explicit control over the cache key derived from query results.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_73\n\nLANGUAGE: js\nCODE:\n```\nconst latest = await db.user.findFirst({\\n  where: { roles: 'admin' } },\\n  orderBy: { updatedAt: 'desc' },\\n  select: { id: true, updatedAt: true }\\n})\\n\\nreturn cache(`posts-${latest.id}-${latest.updatedAt.getTime()}`, () => {\\n  return db.post.findMany({ where: { roles: 'admin' } })\\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Email Mutation Resolver in User Service - TypeScript\nDESCRIPTION: Implements a new service method 'emailUser' in the users service, which fetches a user by ID and logs a message as a placeholder for future email logic. Dependencies: Prisma client, db helper, RedwoodJS service infrastructure. Input: Prisma.UserWhereUniqueInput (expects id); Output: User object or null. No actual emailing yet; replace console.log with real send logic in production.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\n// ...\n\nimport type { Prisma } from '@prisma/client'\n\n// ...\n\nexport const emailUser = async ({ id }: Prisma.UserWhereUniqueInput) => {\n  const user = await db.user.findUnique({\n    where: { id },\n  })\n\n  console.log('Sending email to', user)\n\n  return user\n}\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Customizing Block Field Suggestions Mask - TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to customize the suggestion mask string using the blockFieldSuggestion.mask property in the RedwoodJS GraphQL handler configuration. By setting mask to a custom string (e.g., '<REDACTED>'), all suggestion outputs for invalid fields will display the masked text instead of revealing actual field suggestions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\n{\n\n  blockFieldSuggestion: {\n    mask: '<REDACTED>'\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Component Rendering with Conditional Summary in RedwoodJS using JavaScript\nDESCRIPTION: Defines the Article component which displays the article title and, depending on the 'summary' prop, shows either the first 100 characters of the body with an ellipsis or the full article body. When summary is true, a 'Read more' link is included. Dependencies are React, '@redwoodjs/router' (for Link and routes), and an article prop with title, body, and id fields. Inputs include the article object and the summary flag; output is rendered JSX HTML. Proper handling of summary ensures correct text and optional link rendering.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n\nconst Article = ({ article, summary }) => {\n  return (\n    <article>\n      <h1>{article.title}</h1>\n      <div>\n        {summary ? article.body.substring(0, 100) + '...' : article.body}\n        {summary && <Link to={routes.article(article.id)}>Read more</Link>}\n      </div>\n    </article>\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Running Clerk Auth Setup Command in RedwoodJS\nDESCRIPTION: Executes the RedwoodJS CLI command to automatically set up Clerk authentication. This command installs necessary packages, creates configuration files, and modifies existing code to integrate Clerk.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/clerk.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nyarn rw setup auth clerk\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Deletion Mutation in RedwoodJS Component (TSX)\nDESCRIPTION: This updated TypeScript React component (`Comment.tsx`) implements comment deletion with type safety. It imports types (`IComment`, `DeleteCommentMutation`, etc.) and `TypedDocumentNode`. It defines the `DELETE` mutation using `gql` and types it. The `useMutation` hook is used similarly to the JS version, with `refetchQueries`. The component props interface `Props` is updated to include necessary fields like `postId` and `id` from the imported `IComment` type.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-start\nimport type {\n  Comment as IComment,\n  DeleteCommentMutation,\n  DeleteCommentMutationVariables,\n} from 'types/graphql'\n\nimport type { TypedDocumentNode } from '@redwoodjs/web'\nimport { useMutation } from '@redwoodjs/web'\n\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n// highlight-end\nimport { useAuth } from 'src/auth'\n\n// highlight-start\nconst DELETE: TypedDocumentNode<\n  DeleteCommentMutation,\n  DeleteCommentMutationVariables\n> = gql`\n  mutation DeleteCommentMutation($id: Int!) {\n    deleteComment(id: $id) {\n      postId\n    }\n  }\n`\n// highlight-end\n\nconst formattedDate = (datetime: ConstructorParameters<typeof Date>[0]) => {\n  const parsedDate = new Date(datetime)\n  const month = parsedDate.toLocaleString('default', { month: 'long' })\n  return `${parsedDate.getDate()} ${month} ${parsedDate.getFullYear()}`\n}\n\ninterface Props {\n  // highlight-next-line\n  comment: Pick<IComment, 'postId' | 'id' | 'name' | 'createdAt' | 'body'>\n}\n\nconst Comment = ({ comment }: Props) => {\n  const { hasRole } = useAuth()\n  // highlight-start\n  const [deleteComment] = useMutation(DELETE, {\n    refetchQueries: [\n      {\n        query: CommentsQuery,\n        variables: { postId: comment.postId },\n      },\n    ],\n  })\n  // highlight-end\n\n  const moderate = () => {\n    if (confirm('Are you sure?')) {\n      // highlight-start\n      deleteComment({\n        variables: { id: comment.id },\n      })\n      // highlight-end\n    }\n  }\n\n  return (\n    <div className=\"bg-gray-200 p-8 rounded-lg relative\">\n      <header className=\"flex justify-between\">\n        <h2 className=\"font-semibold text-gray-700\">{comment.name}</h2>\n        <time className=\"text-xs text-gray-500\" dateTime={comment.createdAt}>\n          {formattedDate(comment.createdAt)}\n        </time>\n      </header>\n      <p className=\"text-sm mt-2\">{comment.body}</p>\n      {hasRole('moderator') && (\n        <button\n          type=\"button\"\n          onClick={moderate}\n          className=\"absolute bottom-2 right-2 bg-red-500 text-xs rounded text-white px-2 py-1\"\n        >\n          Delete\n        </button>\n      )}\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Setting Up Redirect URIs for Azure AD Auth - Bash\nDESCRIPTION: This .env file example shows how to assign the necessary environment variables for Azure AD authentication Redirect URIs in a RedwoodJS application. The AZURE_ACTIVE_DIRECTORY_CLIENT_ID and AZURE_ACTIVE_DIRECTORY_AUTHORITY must be set as previously described, and new variables for REDIRECT_URI and LOGOUT_REDIRECT_URI are added. These are used when MSAL.js authenticates or logs out a user, and typically point to local development endpoints. All values must be referenced in your redwood.toml for web environment inclusion.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/azure.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nAZURE_ACTIVE_DIRECTORY_CLIENT_ID=\"...\"\n# Where `tenantId` is your app's \"Directory (tenant) ID\"\nAZURE_ACTIVE_DIRECTORY_AUTHORITY=\"https://login.microsoftonline.com/${tenantId}\"\nAZURE_ACTIVE_DIRECTORY_REDIRECT_URI=\"http://localhost:8910\"\nAZURE_ACTIVE_DIRECTORY_LOGOUT_REDIRECT_URI=\"http://localhost:8910/login\"\n```\n\n----------------------------------------\n\nTITLE: Installing GraphQL Documentation Dependencies for Docusaurus\nDESCRIPTION: This command uses Yarn workspaces to install the necessary dependencies (`@graphql-markdown/docusaurus`, `graphql`, `@graphql-tools/graphql-file-loader`) into the `docs` workspace. These packages are required for generating GraphQL documentation within Docusaurus.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_88\n\nLANGUAGE: terminal\nCODE:\n```\nyarn workspace docs add @graphql-markdown/docusaurus graphql @graphql-tools/graphql-file-loader\n```\n\n----------------------------------------\n\nTITLE: Testing GitHub SSH Connection via Agent Forwarding (Shell)\nDESCRIPTION: This command attempts an SSH connection to GitHub using the `git` user to test authentication. It's used to verify if SSH agent forwarding is correctly configured, allowing the remote server to use the local machine's SSH keys. A successful authentication message indicates forwarding is working; a permission denied error indicates it's not.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_24\n\nLANGUAGE: shell\nCODE:\n```\nssh -T git@github.com\n```\n\n----------------------------------------\n\nTITLE: Setting Default Mailer Options in Configuration (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to add a `defaults` property to the Mailer configuration in `api/src/lib/mailer.ts`. This allows setting default send options, such as `replyTo`, which will be applied to all emails sent via the mailer unless overridden in the specific `mailer.send()` call. This avoids repetitive configuration in service files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/mailer.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n```ts title=api/src/lib/mailer.ts\ndefaults: {\n  replyTo: 'no-reply@example.com',\n},\n```\n```\n\n----------------------------------------\n\nTITLE: Fetching Directly from Backend Port (Illustrates CORS Issue) in JavaScript\nDESCRIPTION: Shows an example `fetch` call attempting to access the `serverTime` function directly via its development server port (`localhost:8911`). This code snippet illustrates a common scenario that results in a Cross-Origin Resource Sharing (CORS) error because the browser blocks requests from one origin (`localhost:8910`) to a different origin (`localhost:8911`) by default.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// the `http://` is important!\nconst serverTime = await fetch('http://localhost:8911/serverTime')\n```\n\n----------------------------------------\n\nTITLE: Example ssh-keygen Success Output with Randomart\nDESCRIPTION: Displays the confirmation messages shown after `ssh-keygen` successfully generates a keypair without a passphrase. It indicates the location of the saved private (`identification`) and public keys, the key's fingerprint (SHA256 hash), and the key's randomart image, a visual representation sometimes used for easier comparison.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\nYour identification has been saved in id_ed25519\nYour public key has been saved in id_ed25519.pub\nThe key fingerprint is:\nSHA256:6Qg7RQRGp1AtfVIOucEt1HtZWkYMU1LZYBVwBsXwTWQ rob@computer.local\nThe key's randomart image is:\n+--[ED25519 256]--+\n| .B&@O+   .E  +==|\n|  o=*= .** . o .o|\n|  .   o   . . . .|\n|    .o   o . o ..|\n|    o . A * +   .|\n|     = + = +     |\n|    o . * .      |\n|     . o         |\n|                 |\n+----[SHA256]-----+\n```\n\n----------------------------------------\n\nTITLE: Associating a Mock with a GraphQL Query Operation Name in JSX\nDESCRIPTION: Shows how the first argument ('UserProfileQuery') provided to `mockGraphQLQuery` corresponds to the operation name defined in the GraphQL query string.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/mocking-graphql-requests.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nquery UserProfileQuery { /*...*/ }\nmockGraphQLQuery('UserProfileQuery', { /*... */ })\n```\n\n----------------------------------------\n\nTITLE: Producing Error Responses in GraphQL Mock Handlers with ctx - Storybook - JavaScript\nDESCRIPTION: This snippet shows how to simulate error responses when mocking GraphQL queries by leveraging the `ctx` utility in the callback. It demonstrates returning a forbidden status (HTTP 403) in a `mockGraphQLQuery` handler, enabling the simulation of authentication or access-related errors. Dependencies: Storybook, RedwoodJS, `mockGraphQLQuery`, and the `ctx` object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/mocking-graphql-in-storybook.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nmockGraphQLQuery('UserProfileQuery', (_vars, { ctx }) => {\n  // Forbidden\n  ctx.status(403)\n})\n```\n\n----------------------------------------\n\nTITLE: Preparing Query Variables for Pagination - RedwoodJS Cell beforeQuery - JavaScript\nDESCRIPTION: Implements the 'beforeQuery' function in a RedwoodJS Cell to convert the incoming 'page' prop from string to integer before passing it as a variable for the GraphQL query. Ensures the page variable is always a number, defaulting to 1 if undefined. This approach prevents type mismatches when dealing with URL query parameters.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nexport const beforeQuery = ({ page }) => {\n  page = page ? parseInt(page, 10) : 1\n\n  return { variables: { page } }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Transformer Directive Stub in RedwoodJS (TypeScript)\nDESCRIPTION: Presents the boilerplate `transform` function signature (`TransformerDirectiveFunc`) for a generated RedwoodJS Transformer directive. It demonstrates access to the GraphQL `context` and the `resolvedValue` (the value of the field the directive is applied to, *after* it has been resolved). The example shows a simple transformation (replacing 'foo' with 'bar'). Transformer functions **must** be synchronous and return a value of the same type as the `resolvedValue`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_30\n\nLANGUAGE: tsx\nCODE:\n```\nconst transform: TransformerDirectiveFunc = ({ context, resolvedValue }) => {\n  return resolvedValue.replace('foo', 'bar')\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Field Validation with Custom Message using JavaScript/JSX\nDESCRIPTION: Configures a custom validation function and a separate custom error message. If the inline validator throws an error, the message 'Please specify a different value' is presented. You must supply both an error-throwing with function and the message property. This can be used to decouple error details from the thrown exception for improved user experience or translation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_48\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.value, 'Value', {\n  custom: {\n    with: () => {\n      if (isInvalid) {\n        throw new Error('Value is invalid')\n      }\n    },\n    message: 'Please specify a different value',\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Applying Error Styles to Inputs with errorClassName (JavaScript)\nDESCRIPTION: Illustrates using the `errorClassName` prop on RedwoodJS form input components (`<TextField>`, `<TextAreaField>`). When a validation error occurs for a field, the specified CSS class (`error` in this case) is applied directly to the input element itself, providing visual feedback like a red border.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField\n          name=\"name\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"name\" className=\"error\" />\n\n        <label htmlFor=\"email\">Email</label>\n        <TextField\n          name=\"email\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"email\" className=\"error\" />\n\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField\n          name=\"message\"\n          validation={{ required: true }}\n          // highlight-next-line\n          errorClassName=\"error\"\n        />\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring a RedwoodJS Directive on GraphQL Queries and Mutations (GraphQL)\nDESCRIPTION: Demonstrates applying a custom directive `@myDirective` to both a GraphQL Query (`bars`) and a Mutation (`createBar`), enabling middleware-like functionality for these operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\ntype Query {\n  bars: [Bar!]! @myDirective\n}\n\ntype Mutation {\n  createBar(input: CreateBarInput!): Bar! @myDirective\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Supabase Environment Variables (Bash)\nDESCRIPTION: Defines the required environment variables for Supabase integration within the project's `.env` file. `SUPABASE_URL` is the project URL, `SUPABASE_KEY` is the public API key (anon key), and `SUPABASE_JWT_SECRET` is the JWT secret found in project settings.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nSUPABASE_URL=\"...\"\nSUPABASE_KEY=\"...\"\nSUPABASE_JWT_SECRET=\"...\"\n```\n\n----------------------------------------\n\nTITLE: Restarting RedwoodJS Job Workers after Deployment using Yarn CLI in Bash\nDESCRIPTION: Provides the command to restart all background job worker processes. Using \\\"yarn rw jobs restart\\\" ensures that workers reload the latest code after deployment. This is crucial for production environments where updated job logic must be picked up. Prerequisites: Yarn CLI and jobs setup. The command will restart all active job runners.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs restart\n```\n\n----------------------------------------\n\nTITLE: Resetting Redwood Form After Mutation Completion (TypeScript)\nDESCRIPTION: Utilizes formMethods.reset() in the onCompleted handler of useMutation to clear the form post-submission in a type-safe way. The mutation is typed with CreateContactMutation and CreateContactMutationVariables, and toast.success informs the user of successful submission. All required modules and type definitions must be imported for correct runtime and compile-time operation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_37\n\nLANGUAGE: tsx\nCODE:\n```\n// ...\n\nconst [create, { loading, error }] = useMutation<\n  CreateContactMutation,\n  CreateContactMutationVariables\n>(CREATE_CONTACT, {\n  onCompleted: () => {\n    toast.success('Thank you for your submission!')\n    // highlight-next-line\n    formMethods.reset()\n  },\n})\n\n// ...\n\n```\n\n----------------------------------------\n\nTITLE: Updating ArticlesCell to Display Summaries (TSX)\nDESCRIPTION: This snippet updates the TypeScript `ArticlesCell` component. It includes type definitions for the GraphQL query and cell props. In the `Success` component, it maps over the fetched `articles` and renders the `Article` component for each, explicitly passing `summary={true}`. This integrates the article summary feature into the list display managed by the cell.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-story.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/ArticlesCell/ArticlesCell.tsx\"\nimport type { ArticlesQuery, ArticlesQueryVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypeDocumentNode,\n} from '@redwoodjs/web'\n\nimport Article from 'src/components/Article'\n\nexport const QUERY: TypeDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\n  gql`\n    query ArticlesQuery {\n      articles: posts {\n        id\n        title\n        body\n        createdAt\n      }\n    }\n  `\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<ArticlesQueryVariables>) => (\n  <div>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  articles,\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\n  return (\n    <div className=\"space-y-10\">\n      {articles.map((article) => (\n        // highlight-next-line\n        <Article article={article} key={article.id} summary={true} />\n      ))}\n    </div>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Validating Presence with Custom Error Message using JavaScript/JSX\nDESCRIPTION: This demonstrates adding a custom message to the presence validation rule for a lastName field. If the validation fails (e.g., lastName is empty), the supplied message will be shown to the user. This pattern is useful for providing user-friendly feedback in forms. Requires a validate() utility that recognizes a message property in options.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_46\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.lastName, {\n  presence: { allowEmptyString: false, message: \"Can't leave last name empty\" },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Establishing Application Working Directory and Copying Dependency Files - Dockerfile\nDESCRIPTION: This section sets the working directory to the application root, and copies key configuration and dependency management files into the container. The files include .yarnrc.yml, package.json, api/package.json, web/package.json, and yarn.lock, each with the node user's ownership. These files are all required before running 'yarn install'; the COPY sequence is ordered to optimize Docker layer caching and minimize unnecessary rebuilds.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_4\n\nLANGUAGE: Dockerfile\nCODE:\n```\nWORKDIR /home/node/app\n\nCOPY --chown=node:node .yarnrc.yml .\nCOPY --chown=node:node package.json .\nCOPY --chown=node:node api/package.json api/\nCOPY --chown=node:node web/package.json web/\nCOPY --chown=node:node yarn.lock .\n```\n\n----------------------------------------\n\nTITLE: Generating Users Service - Bash\nDESCRIPTION: This command generates a Users service using Redwood's scaffolding tools, creating the necessary boilerplate file to later hold the generateToken function. Requires a working RedwoodJS project. No input parameters. Outputs a new service file structure for user operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g service users\n```\n\n----------------------------------------\n\nTITLE: Setting Up TypeScript Configuration in RedwoodJS - Bash\nDESCRIPTION: This command creates a tsconfig.json configuration file on both API and web sides of a RedwoodJS project to enable TypeScript support. Prerequisites are a valid project setup and Yarn installed. The --force flag overwrites any existing TypeScript configuration. Input is implicit (project root); output is newly generated or updated tsconfig.json files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_128\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup tsconfig\n```\n\n----------------------------------------\n\nTITLE: Modifying Cached Data using useCache in TypeScript\nDESCRIPTION: Shows how to use the `modify` method from the `useCache` hook to update fields of a cached object. It requires the object's cache ID (obtained via `identify`) and an object mapping field names to their new values or modifier functions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/caching.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst CacheExample = () => {\n  const { modify } = useCache()\n\n  const id = identify({ __typename: 'User', id: 1 })\n\n  modify(id, {\n    name: 'David',\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking useParams in RedwoodJS Component Tests (JSX)\nDESCRIPTION: This code demonstrates mocking of the useParams hook in RedwoodJS tests by providing a ParamsProvider with allParams. Inputs are a params object matching expected route/query parameters. Prerequisites: RedwoodJS and @redwoodjs/router. Output: predictable test scope where components receive fake but controlled parameter values via context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { ParamsProvider } from '@redwoodjs/router';\\n\\nrender(\\n  <ParamsProvider allParams={{ param1: 'val1', param2: 'val2' }}>\\n    <Component />\\n  </ParamsProvider>\\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Private Key Permissions for SSH - Shell\nDESCRIPTION: Shows how to correct the file permissions of a private key file using chmod 600, making it readable and writable only by the owner. This is necessary before using the key with SSH. The chmod utility is the dependency. Input is the private key path; output is the file permission update.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nchmod 600 ~/.ssh/keyname.pem\n```\n\n----------------------------------------\n\nTITLE: Configuring Prisma Database Provider - JavaScript\nDESCRIPTION: Updates the database provider to PostgreSQL in the Prisma schema configuration. This change is required for RedwoodJS projects deploying to environments that do not support file-based SQLite, such as Netlify. No additional dependencies are required beyond Prisma and a compatible Postgres database. Updating this value ensures Prisma generates migrations and clients for the correct database backend.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/deployment.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nprovider = 'postgresql'\n```\n\n----------------------------------------\n\nTITLE: Including Environment Variables in redwood.toml - TOML\nDESCRIPTION: This redwood.toml fragment shows how to include the relevant Azure AD authentication environment variables for usage on the RedwoodJS web side. The includeEnvironmentVariables array lists all environment variable names that need to be injected into the frontend application's process.env. Ensure that every variable used in your authentication client setup is present here. The rest of the [web] config is omitted for clarity.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/azure.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n  # ...\n  includeEnvironmentVariables = [\n    \"AZURE_ACTIVE_DIRECTORY_CLIENT_ID\",\n    \"AZURE_ACTIVE_DIRECTORY_AUTHORITY\",\n    \"AZURE_ACTIVE_DIRECTORY_REDIRECT_URI\",\n    \"AZURE_ACTIVE_DIRECTORY_LOGOUT_REDIRECT_URI\",\n  ]\n```\n\n----------------------------------------\n\nTITLE: Listing Redwood Deploy Targets and Setup Options (Shell)\nDESCRIPTION: This command displays all available setup instructions and help info for deploying Redwood applications to various serverless and serverful environments (e.g., Netlify, Vercel, AWS, Render). Requires an active Redwood project. Outputs CLI options and configuration help for deployment targets.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup deploy --help\n```\n\n----------------------------------------\n\nTITLE: Sample Output: Redwood Project Diagnostics - Bash\nDESCRIPTION: Presents the output from running the diagnostics command, showing example errors regarding routes and paths in the project's source files. No dependencies; for user information. Inputs: None. Outputs: Error messages pinpointing issues. Limitations: Sample output only; actual run output may differ.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood check\nyarn run v1.22.4\nweb/src/Routes.js:14:5: error: You must specify a 'notfound' page\nweb/src/Routes.js:14:19: error: Duplicate Path\nweb/src/Routes.js:15:19: error: Duplicate Path\nweb/src/Routes.js:17:40: error: Page component not found\nweb/src/Routes.js:17:19: error (INVALID_ROUTE_PATH_SYNTAX): Error: Route path contains duplicate parameter: \"/{id}/{id}\"\n```\n\n----------------------------------------\n\nTITLE: Enhanced Error Display in Failure Component - WeatherCell - RedwoodJS - JSX\nDESCRIPTION: Improves the user experience by customizing the Failure component in WeatherCell to display error messages with styled formatting. Uses a 'span' element with red-themed background and text color for better visibility. Depends on error object passed into the component and is intended to replace the default error rendering when an invalid zip code is submitted.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Failure = ({ error }) => (\n  <span\n    style={{\n      backgroundColor: '#ffdfdf',\n      color: '#990000',\n      padding: '0.5rem',\n      display: 'inline-block',\n    }}\n  >\n    {error.message}\n  </span>\n)\n```\n\n----------------------------------------\n\nTITLE: Example CORS Error Message when Fetching Function Directly\nDESCRIPTION: Displays the typical Cross-Origin Resource Sharing (CORS) error message encountered in the browser's console when attempting to fetch a resource from a different origin (e.g., backend port 8911) than the requesting page (e.g., frontend port 8910) without proper CORS headers configured on the server.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nAccess to fetch at 'http://localhost:8911/serverTime' from origin 'http://localhost:8910' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.\n```\n\n----------------------------------------\n\nTITLE: Mocking Authenticated Moderator User in Storybook - React (TypeScript)\nDESCRIPTION: Shows how to mock an authenticated moderator user for the moderatorView story of the Comment component in Storybook with TypeScript. Utilizes the Storybook global mockCurrentUser function, passing a user object with id, email, and roles (must include 'roles' for proper hasRole checks). No explicit imports required for mockCurrentUser. Outputs a React functional component configured for moderator testing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\nexport const moderatorView = () => {\\n  // highlight-start\\n  mockCurrentUser({\\n    id: 1,\\n    email: 'moderator@moderator.com',\\n    roles: 'moderator',\\n  })\\n  // highlight-end\\n\\n  return (\\n    <Comment\\n      comment={{\\n        id: 1,\\n        name: 'Rob Cameron',\\n        body: 'This is the first comment!',\\n        createdAt: '2020-01-01T12:34:56Z',\\n        postId: 1,\\n      }}\\n    />\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating Chat Message Publishing - Bash\nDESCRIPTION: Shell script usage guide for simulating chat traffic in chat rooms. Supports selecting a room and specifying the number of messages. Intended for CLI-based integration testing and simulations of subscription interactions in RedwoodJS real-time chat environments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/simulate_chat.sh -h\nUsage: ./scripts/simulate_chat.sh -r [roomId] -n [num_messages]\n       ./scripts/simulate_chat.sh -h\n\nOptions:\n  -r roomId       Specify the room ID (1-4) for sending chat messages.\n  -n num_messages Specify the number of chat messages to send. If not provided, the script will run with a random number of messages.\n```\n\n----------------------------------------\n\nTITLE: Displaying SSH Public Key Content using cat in Bash\nDESCRIPTION: Uses the `cat` command to output the contents of the specified SSH public key file (`~/.ssh/id_ed25519.pub`) directly to the standard output (the terminal screen). This is commonly done to easily copy the public key.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\ncat ~/.ssh/id_ed25519.pub\n```\n\n----------------------------------------\n\nTITLE: Testing Article Component Rendering and Summary in TypeScript (TSX)\nDESCRIPTION: This TypeScript test suite uses `@redwoodjs/testing` (`render`, `screen`) to verify the rendering behavior of the `Article` component. It defines a constant `ARTICLE` containing sample blog post data. The first test case (`renders a blog post`) checks if the component renders the full article title and body when no `summary` prop is provided. The second test case (`renders a summary of a blog post`) asserts that the component renders the title and a specific truncated version of the body when the `summary={true}` prop is passed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Article/Article.test.tsx\"\nimport { render, screen } from '@redwoodjs/testing'\n\nimport Article from './Article'\n\n// highlight-start\nconst ARTICLE = {\n  id: 1,\n  title: 'First post',\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\n  createdAt: new Date().toISOString(),\n}\n// highlight-end\n\ndescribe('Article', () => {\n  it('renders a blog post', () => {\n    // highlight-next-line\n    render(<Article article={ARTICLE} />)\n\n    // highlight-start\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(screen.getByText(ARTICLE.body)).toBeInTheDocument()\n    // highlight-end\n  })\n\n  // highlight-start\n  it('renders a summary of a blog post', () => {\n    render(<Article article={ARTICLE} summary={true} />)\n\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(\n      screen.getByText(\n        'Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Str...'\n      )\n    ).toBeInTheDocument()\n  })\n  // highlight-end\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Testing CommentsCell Rendering States with RedwoodJS in JavaScript\nDESCRIPTION: This snippet tests the CommentsCell React component in JavaScript by verifying that all rendering states (loading, empty, failure, and success) do not throw errors. Using RedwoodJS testing utilities, each state is rendered, and the test asserts that no exceptions are raised. Dependencies include @redwoodjs/testing/web, CommentsCell components, and mock data from CommentsCell.mock. Inputs are simulated states or props for CommentsCell. Outputs are error-free component renders, with no specific constraints beyond correct imports.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { render } from '@redwoodjs/testing/web'\n\nimport { Loading, Empty, Failure, Success } from './CommentsCell'\nimport { standard } from './CommentsCell.mock'\n\ndescribe('CommentsCell', () => {\n  it('renders Loading successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  it('renders Empty successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  it('renders Failure successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  it('renders Success successfully', async () => {\n    expect(() => {\n      render(<Success comments={standard().comments} />)\n    }).not.toThrow()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Rendering Article List Cell and Linking to Detail Page (RedwoodJS, JavaScript)\nDESCRIPTION: This JavaScript component renders a list of article summaries and uses RedwoodJS's Link component to create a navigable link for each article title, pointing to the detail route. Dependencies include `@redwoodjs/router` for routing and expect a prop named `articles`. Each article is displayed with its title (as a link), body, and creation timestamp. The route does not yet pass a specific article ID, so the link leads to the base article page.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\\nimport { Link, routes } from '@redwoodjs/router'\\n\\n// QUERY, Loading, Empty and Failure definitions...\\n\\nexport const Success = ({ articles }) => {\\n  return (\\n    <>\\n      {articles.map((article) => (\\n        <article key={article.id}>\\n          <header>\\n            <h2>\\n              // highlight-next-line\\n              <Link to={routes.article()}>{article.title}</Link>\\n            </h2>\\n          </header>\\n          <p>{article.body}</p>\\n          <div>Posted at: {article.createdAt}</div>\\n        </article>\\n      ))}\\n    </>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Looping Tests for Dynamic Link Rendering Using getByRole with React Testing Library in JavaScript\nDESCRIPTION: Shows how to programmatically check multiple dynamic links by looping through a data array and asserting each user's link is present. Uses data.forEach for iteration. The test renders List with test data and uses screen.getByRole for each name. Dependencies include List component and '@redwoodjs/testing/web'. Useful for scaling tests with variable data. Ensures accessibility roles are applied per-item.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nit('renders a link with a name', () => {\n  const data = [{ name: 'Rob' }, { name: 'Tom' }]\n\n  render(<List data={data} />)\n\n  data.forEach((datum) => {\n    expect(screen.getByRole('link', { name: datum.name })).toBeInTheDocument()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up SuperTokens Auth Providers - Bash\nDESCRIPTION: Runs the RedwoodJS CLI setup command to scaffold SuperTokens authentication. This command installs the necessary dependencies, performs code modifications, and prepares the project for authentication integration. Requires prior installation of Yarn and RedwoodJS CLI. Input: None. Output: Project files and configurations updated for SuperTokens.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supertokens.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup auth supertokens\n```\n\n----------------------------------------\n\nTITLE: VerifyOptions Interface for Webhook Verification - TypeScript\nDESCRIPTION: This TypeScript interface defines the VerifyOptions structure used when verifying incoming webhook signatures in RedwoodJS. It outlines a set of optional parameters such as signatureHeader, signatureTransformer, currentTimestampOverride, eventTimestamp, tolerance, and issuer, enabling precise and flexible configuration for signature verification routines. This interface is leveraged by verifiers to ensure correct header extraction, signature transformation, and validation of timing and issuer details for extra security. It is a key component for supporting a variety of third-party webhook protocols with differing requirements.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * VerifyOptions\n *\n * Used when verifying a signature based on the verifier's requirements\n *\n * @param {string} signatureHeader - Optional Header that contains the signature\n * to verify. Will default to DEFAULT_WEBHOOK_SIGNATURE_HEADER\n * @param {(signature: string) => string} signatureTransformer - Optional\n * function that receives the signature from the headers and returns a new\n * signature to use in the Verifier\n * @param {number} currentTimestampOverride - Optional timestamp to use as the\n * \"current\" timestamp, in msec\n * @param {number} eventTimestamp - Optional timestamp to use as the event\n * timestamp, in msec. If this is provided the webhook verification will fail\n * if the eventTimestamp is too far from the current time (or the time passed\n * as the `currentTimestampOverride` option)\n * @param {number} tolerance - Optional tolerance in msec\n * @param {string} issuer - Options JWT issuer for JWTVerifier\n */\nexport interface VerifyOptions {\n  signatureHeader?: string\n  signatureTransformer?: (signature: string) => string\n  currentTimestampOverride?: number\n  eventTimestamp?: number\n  tolerance?: number\n  issuer?: string\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring dbAuth Client to Include Credentials in Auth XHR Requests (JavaScript)\nDESCRIPTION: This snippet sets up a dbAuth client in RedwoodJS to include credentials (such as session cookies) with authentication-related XHR requests by adding 'fetchConfig: { credentials: \"include\" }' when calling 'createDbAuthClient'. This ensures stateful sessions when requests come from a different origin. Dependencies: '@redwoodjs/auth-dbauth-web'. The result is persistent login/logout and cookie handling in cross-origin situations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cors.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createDbAuthClient, createAuth } from '@redwoodjs/auth-dbauth-web'\\n\\nconst dbAuthClient = createDbAuthClient({\\n  fetchConfig: { credentials: 'include' },\\n})\\n\\nexport const { AuthProvider, useAuth } = createAuth(dbAuthClient)\n```\n\n----------------------------------------\n\nTITLE: Customizing GoTrue Client API Endpoint (JavaScript/JSX)\nDESCRIPTION: This snippet demonstrates how to customize the GoTrue client configuration by supplying your unique Netlify Identity API endpoint in the APIUrl field. This step is required after enabling Identity on your Netlify project, and ensures authentication requests target the correct backend instance. Developers must manually enter their endpoint URL, which is copied from the Netlify admin panel. Inputs are the API endpoint string and the setCookie flag; output is a correctly configured GoTrue client for further use in authentication flows.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// imports...\n\nconst goTrueClient = new GoTrue({\n  APIUrl: 'https://gotrue-recipe.netlify.app/.netlify/identity',\n  setCookie: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up dbAuth with Redwood CLI - Bash\nDESCRIPTION: Runs the Redwood CLI command to scaffold all necessary files for dbAuth authentication, excluding the actual login/signup page content. This command initializes configuration and environment settings that must be further customized as described in post-install instructions. Requires the yarn CLI installed, a Redwood project, and executes from the project root. Outputs changes to relevant files and may prompt for additional options (e.g., WebAuthn).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup auth dbAuth\n```\n\n----------------------------------------\n\nTITLE: Checking Node.js and Yarn Versions using Bash\nDESCRIPTION: These bash commands check the currently installed versions of Node.js and Yarn on the system. RedwoodJS requires specific minimum versions (Node \"=20.x\", Yarn \">=1.22.21\") for its installation process to succeed, and these commands verify if the system meets those requirements.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/prerequisites.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode --version\nyarn --version\n```\n\n----------------------------------------\n\nTITLE: Allowing All Hosts on Redwood Vite Dev Server - Bash\nDESCRIPTION: Shows the invocation for allowing all hosts via the dev server by forwarding the proper Vite CLI flag. Useful for accessing from other hosts or devices. Dependencies: Redwood CLI, Vite. Parameters: --fwd. Input: Command. Output: Dev server started with modified host header allowance. Limitation: Should be used cautiously for security.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood dev --fwd=\"--allowed-hosts all\"\n```\n\n----------------------------------------\n\nTITLE: Connecting via SSH Using Public Key Authentication in Bash\nDESCRIPTION: Demonstrates the simplified SSH command (`ssh root@192.168.0.122`) used after configuring public key authentication. By omitting the password prompt or the `-i` flag for a specific private key, SSH relies on the `ssh-agent` to provide the appropriate key, which the server then verifies against its `authorized_keys` file.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\nssh root@192.168.0.122\n```\n\n----------------------------------------\n\nTITLE: Generated GraphQL SDL with Relation (JSX)\nDESCRIPTION: Shows an updated `./api/src/graphql/users.sdl.js` file where the `User` type now includes a `profile` field, representing a relation to a `Profile` model. This demonstrates how the SDL generator handles relations defined in the Prisma schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_82\n\nLANGUAGE: jsx\nCODE:\n```\nexport const schema = gql`\n  type User {\n    id: Int!\n    email: String!\n    name: String\n    profile: Profile\n  }\n\n  type Query {\n    users: [User!]! @requireAuth\n  }\n\n  input CreateUserInput {\n    email: String!\n    name: String\n  }\n\n  input UpdateUserInput {\n    email: String\n    name: String\n  }\n\n  type Mutation {\n    createUser(input: CreateUserInput!): User! @requireAuth\n    updateUser(id: Int!, input: UpdateUserInput!): User! @requireAuth\n    deleteUser(id: Int!): User! @requireAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Using a React Component with Props in an Application (JSX/TSX)\nDESCRIPTION: This snippet illustrates how the `Article` component would typically be used within a live React application, as opposed to its use in a Storybook story. The component receives its data dynamically through the `article` prop, where `article` is a variable holding the actual article data, likely fetched from an API or passed down from a parent component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/storybook.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\n<Article article={article} />\n```\n```\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n<Article article={article} />\n```\n```\n\n----------------------------------------\n\nTITLE: Integrating CommentsCell in Article Page - JavaScript (JSX)\nDESCRIPTION: Shows how to embed the CommentsCell in an article display component, ensuring comments are displayed only when not in summary view. Imports RedwoodJS router tools and the CommentsCell, using conditional rendering to customize full and summary article views. Inputs include article object and summary flag; uses CommentsCell as a child.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\\n// highlight-next-line\\nimport CommentsCell from 'src/components/CommentsCell'\\n\\nconst truncate = (text, length) => {\\n  return text.substring(0, length) + '...'\\n}\\n\\nconst Article = ({ article, summary = false }) => {\\n  return (\\n    <article>\\n      <header>\\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\\n        </h2>\\n      </header>\\n      <div className=\"mt-2 text-gray-900 font-light\">\\n        {summary ? truncate(article.body, 100) : article.body}\\n      </div>\\n      // highlight-next-line\\n      {!summary && <CommentsCell />}\\n    </article>\\n  )\\n}\\n\\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Configuring PM2 for RedwoodJS API Process Management\nDESCRIPTION: This PM2 `ecosystem.config.js` file defines how to manage the RedwoodJS API server process. It specifies the application name ('api'), working directory ('current'), the script to run (`node_modules/.bin/rw`), arguments (`serve api`), enables clustering for better performance (`instances: 'max', exec_mode: 'cluster'`), and sets up readiness checks and timeouts.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_38\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  apps: [\n    {\n      name: 'api',\n      cwd: 'current',\n      script: 'node_modules/.bin/rw',\n      args: 'serve api',\n      instances: 'max',\n      exec_mode: 'cluster',\n      wait_ready: true,\n      listen_timeout: 10000,\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Functionality with RedwoodJS Scenario Relationships\nDESCRIPTION: This test snippet uses a scenario where a comment and its related post were created. It accesses the foreign key (`scenario.comment.jane.postId`) generated during scenario creation to test adding a second comment to the same post. The assertion dynamically checks the count based on the initial scenario state plus the added record.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_60\n\nLANGUAGE: javascript\nCODE:\n```\nscenario('creates a second comment', async (scenario) => {\n  const comment = await createComment({\n    input: {\n      name: 'Billy Bob',\n      body: \"A tree's bark is worse than its bite\",\n      postId: scenario.comment.jane.postId,\n    },\n  })\n\n  const list = await comments({ postId: scenario.comment.jane.postId })\n\n  expect(list.length).toEqual(Object.keys(scenario.comment).length + 1)\n})\n```\n\n----------------------------------------\n\nTITLE: Refactoring RedwoodJS HomePage Component (TypeScript/TSX)\nDESCRIPTION: Presents the refactored `HomePage` component in TypeScript (TSX). Similar to the JavaScript version, it's simplified by removing the header and main wrapper, leaving only the 'Home' text and the `Metadata` component. Imports for `Link` and `routes` are no longer needed here.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n\nconst HomePage = () => {\n  return (\n    <>\n      <Metadata title=\"Home\" description=\"Home page\" />\n      Home\n    </>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Starting Storybook Server - Bash\nDESCRIPTION: This snippet shows the command required to launch the Storybook development server for a RedwoodJS project. Requires Node.js and yarn to be installed, and should be run in the root directory of a RedwoodJS project. The Storybook server will compile the project and, upon success, be accessible via the specified localhost port. There are no arguments or options required for basic usage.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/storybook.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw storybook\n```\n\n----------------------------------------\n\nTITLE: Configuring Contact Page Route (TypeScript)\nDESCRIPTION: Modifies the `Routes.tsx` file (TypeScript version) to define the route for the `ContactPage`. The `<Route>` for `/contact` is nested within the `<Set>` component that applies the `BlogLayout`, ensuring the Contact page inherits the correct layout structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/Routes.tsx\"\nimport { Router, Route, Set } from '@redwoodjs/router'\nimport ScaffoldLayout from 'src/layouts/ScaffoldLayout'\nimport BlogLayout from 'src/layouts/BlogLayout'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Set\n        wrap={ScaffoldLayout}\n        title=\"Posts\"\n        titleTo=\"posts\"\n        buttonLabel=\"New Post\"\n        buttonTo=\"newPost\"\n      >\n        <Route path=\"/posts/new\" page={PostNewPostPage} name=\"newPost\" />\n        <Route\n          path=\"/posts/{id:Int}/edit\"\n          page={PostEditPostPage}\n          name=\"editPost\"\n        />\n        <Route path=\"/posts/{id:Int}\" page={PostPostPage} name=\"post\" />\n        <Route path=\"/posts\" page={PostPostsPage} name=\"posts\" />\n      </Set>\n      <Set wrap={BlogLayout}>\n        <Route path=\"/article/{id:Int}\" page={ArticlePage} name=\"article\" />\n        // highlight-next-line\n        <Route path=\"/contact\" page={ContactPage} name=\"contact\" />\n        <Route path=\"/about\" page={AboutPage} name=\"about\" />\n        <Route path=\"/\" page={HomePage} name=\"home\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n```\n\n----------------------------------------\n\nTITLE: Preparing Cache, Running Yarn Install with Cache Mounts - Dockerfile\nDESCRIPTION: This compound snippet creates necessary cache and Yarn directories, then installs dependencies via 'yarn install' with Docker cache mounts to persist and accelerate dependency fetches between builds. The cache mounts are UID 1000, providing correct permissions for the node user; 'CI=1' ensures Yarn runs in CI mode for immutable installs and proper logging. This approach provides reproducible installs and improves performance in CI/CD environments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_5\n\nLANGUAGE: Dockerfile\nCODE:\n```\nRUN mkdir -p /home/node/.yarn/berry/index\nRUN mkdir -p /home/node/.cache\n\nRUN --mount=type=cache,target=/home/node/.yarn/berry/cache,uid=1000 \\\n    --mount=type=cache,target=/home/node/.cache,uid=1000 \\\n    CI=1 yarn install\n```\n\n----------------------------------------\n\nTITLE: Registering and Running a Faktory Worker with Redwood (JavaScript)\nDESCRIPTION: This snippet registers a background task called 'postSignupTask' in a Faktory worker script. It utilizes the 'faktory-worker' Node.js package and integrates Redwood's logger for monitoring. The worker is initiated to listen for jobs on the server described by FAKTORY_URL, logging errors if startup or job processing fails. Required dependencies: 'faktory-worker' package, Redwood's logger, and the postSignupTask exported from '$api/src/lib/tasks'. The worker expects an async task function and reads server connection details from environment variables.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/background-worker.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { postSignupTask } from '$api/src/lib/tasks'\nimport { logger } from '$api/src/lib/logger'\n\nimport faktory from 'faktory-worker'\n\nfaktory.register('postSignupTask', async (taskArgs) => {\n  logger.info(\"running postSignupTask in background worker\")\n\n  await postSignupTask(taskArgs)\n})\n\nexport default async ({ _args }) => {\n  const worker = await faktory\n    .work({\n      url: process.env.FAKTORY_URL,\n    })\n    .catch((error) => {\n      logger.error(`worker failed to start: ${error}`)\n      process.exit(1)\n    })\n\n  worker.on('fail', ({ _job, error }) => {\n    logger.error(`worker failed to start: ${error}`)\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Success Component with Typed Articles Prop (TypeScript/TSX)\nDESCRIPTION: Implements the Success component in TypeScript/TSX, typing the 'articles' prop via CellSuccessProps to enforce type safety. Maps over the articles array and renders an Article component for each element, expecting the prop structure to match the query data. Used for strongly-typed tests and stories.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nexport const Success = ({\\n  // highlight-next-line\\n  articles,\\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\\n  return\\n  {\\n    articles.map((article) => <Article article={article} />)\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Redwood Cell Component for Storybook (Shell)\nDESCRIPTION: This Redwood CLI command generates an example Cell (data-fetching abstraction) named 'examplePosts', along with an associated Storybook story file. Requires an existing Redwood project. Useful for creating story files ('*.stories.{tsx,jsx}') needed by Storybook. Results in new files under the project's Cell components directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw generate cell examplePosts\n```\n\n----------------------------------------\n\nTITLE: Setting Default Node.js Version with nvm\nDESCRIPTION: This command sets a specific, locally installed Node.js version as the default version to be used when opening a new shell session. Replace `<<version number>>` with the desired version string (e.g., '18.12.0').\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnvm alias default <<version number>>\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Job Scheduler (JavaScript)\nDESCRIPTION: Snippet shows the export of the `later` object from the jobs configuration file (typically `api/src/lib/jobs.js`). This object is responsible for scheduling jobs and is initialized using `jobs.createScheduler`, specifying the `prisma` adapter for storing job scheduling information in the database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_10\n\nLANGUAGE: js\nCODE:\n```\nexport const later = jobs.createScheduler({\n  adapter: 'prisma',\n})\n```\n\n----------------------------------------\n\nTITLE: Building a Simple Form Component in RedwoodJS (JavaScript/JSX)\nDESCRIPTION: This snippet defines a React component `NameForm` using RedwoodJS form helpers (`Form`, `Submit`, `TextField`). It includes fields for 'name' (required) and 'nickname' (optional) and accepts an `onSubmit` prop function to handle form submission.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_46\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"NameForm.js\"\nimport { Form, Submit, TextField } from '@redwoodjs/forms'\n\nconst NameForm = ({ onSubmit }) => {\n  return (\n    <Form onSubmit={onSubmit}>\n      <TextField\n        name=\"name\"\n        placeholder=\"Name\"\n        validation={{\n          required: true,\n        }}\n      />\n      <TextField\n        name=\"nickname\"\n        placeholder=\"Nickname\"\n        validation={{\n          required: false,\n        }}\n      />\n      <Submit>Submit</Submit>\n    </Form>\n  )\n}\n\nexport default NameForm\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Test Scenario in TypeScript\nDESCRIPTION: Defines a standard test scenario using RedwoodJS's `defineScenario` within a TypeScript file (`comments.scenarios.ts`). Although the code block is tagged as JavaScript, it represents the TypeScript version for setting up initial database state for comment tests, creating two comments linked to distinct posts.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.scenarios.ts\"\nexport const standard = defineScenario({\n  comment: {\n    jane: {\n      data: {\n        name: 'Jane Doe',\n        body: 'I like trees',\n        post: {\n          create: {\n            title: 'Redwood Leaves',\n            body: 'The quick brown fox jumped over the lazy dog.',\n          },\n        },\n      },\n    },\n    john: {\n      data: {\n        name: 'John Doe',\n        body: 'Hug a tree today',\n        post: {\n          create: {\n            title: 'Root Systems',\n            body: 'The five boxing wizards jump quickly.',\n          },\n        },\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic RedwoodJS Scenario\nDESCRIPTION: This snippet shows the initial structure of a `scenarios.js` file generated by RedwoodJS. It defines a default 'standard' scenario using `defineScenario`, seeding the 'user' model with two records containing placeholder 'String' data. The keys 'one' and 'two' are friendly identifiers used to reference these records within tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_52\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = defineScenario({\n  user: {\n    one: {\n      data: {\n        name: 'String',\n      },\n    },\n    two: {\n      data: {\n        name: 'String',\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Providing Possible Types for Unions and Interfaces in Apollo Client Cache - RedwoodJS - TypeScript/JSX\nDESCRIPTION: This snippet configures the RedwoodApolloProvider with a cacheConfig containing explicit possibleTypes mapping, allowing Apollo Client to differentiate between union/interface types during fragment resolution. This is essential for proper fragment use on unions or interfaces. Inputs: possibleTypes object; Output: provider ready for complex fragments. No codegen is shown here.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\n/// web/src/App.tsx\\n\\n<RedwoodApolloProvider graphQLClientConfig={{\\n  cacheConfig: {\\n    possibleTypes: {\\n      Character: [\\\"Jedi\\\", \\\"Droid\\\"],\\n      Test: [\\\"PassingTest\\\", \\\"FailingTest\\\", \\\"SkippedTest\\\"],\\n      Snake: [\\\"Viper\\\", \\\"Python\\\"],\\n      Groceries: ['Fruit', 'Vegetable'],\\n    },\\n  },\\n}} />\\n\n```\n\n----------------------------------------\n\nTITLE: Setting up Netlify Authentication with RedwoodJS - Bash\nDESCRIPTION: This snippet shows the command to set up Netlify authentication integration in a RedwoodJS application. It installs all dependencies and applies code and config changes necessary to enable Netlify Identity authentication. Prerequisite: a working RedwoodJS project and Yarn installed. Input is the command itself; output is an updated project with Netlify Identity authentication scaffolding.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/netlify.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup auth netlify\n```\n\n----------------------------------------\n\nTITLE: beforeQuery With Typed Props (JSX/TypeScript Syntax)\nDESCRIPTION: This snippet defines a beforeQuery for a Cell that accepts a single prop, word (string), and maps it to a GraphQL variable named magicWord. This enables strong typing and prop-to-variable mapping, useful when using TypeScript for prop type enforcement.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n// The cell will take 1 prop named \"word\" that is a string: <Cell word=\"abc\">\nexport const beforeQuery = ({ word }: { word: string }) => {\n  return {\n    variables: { magicWord: word }\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Aliasing Fields in GraphQL Query (RedwoodJS Cell)\nDESCRIPTION: This GraphQL query snippet demonstrates aliasing the 'posts' field to 'articles'. When this query is executed within a RedwoodJS Cell, the data resolved for 'posts' will be accessible under the key 'articles' in the Success component's props.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_16\n\nLANGUAGE: graphql\nCODE:\n```\n      // highlight-next-line\n      articles: posts {\n        id\n      }\n    }\n`\n```\n\n----------------------------------------\n\nTITLE: Starting the Redwood API Server using the start Method\nDESCRIPTION: This TypeScript code calls the `server.start()` method on the server instance created by `createServer`. This method is a wrapper around Fastify's `listen` and intelligently determines the host and port based on command-line flags, environment variables, or `redwood.toml` settings.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nawait server.start()\n```\n\n----------------------------------------\n\nTITLE: Applying Redwood Directives to GraphQL Query and Type Field (Masking)\nDESCRIPTION: This GraphQL SDL snippet demonstrates combining directives in RedwoodJS. The `@requireAuth` directive on the `user` query ensures only logged-in users can execute it. The custom `@maskedEmail(role: \"ADMIN\")` directive on the `email` field within the `User` type transforms the email value (e.g., masks it) unless the authenticated user has the 'ADMIN' role.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_12\n\nLANGUAGE: graphql\nCODE:\n```\n  type User {\n    id: Int!\n    name: String!\n    email: String! @maskedEmail(role: \"ADMIN\")\n    createdAt: DateTime!\n  }\n\n  type Query {\n    user(id: Int!): User @requireAuth\n  }\n```\n\n----------------------------------------\n\nTITLE: Asserting Ellipsis Presence in Article Summary (JavaScript)\nDESCRIPTION: This assertion validates that an ellipsis string ('...') is present in the truncated article body, confirming truncation logic. Used in test suites for UIs that summarize or limit content length. It requires prior acquisition of an element containing the summary.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nexpect(ellipsis).toBeInTheDocument()\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Mock HTTP Event Fixture for Missing Divisor - React/JSX/TypeScript\nDESCRIPTION: This code defines a fixture in TypeScript that produces a mock HTTP event missing the 'divisor' parameter. The exported 'missingDivisor' function can be reused across test cases to consistently inject this specific edge case. Requires '@redwoodjs/testing/api' for creating the mock event.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport { mockHttpEvent } from '@redwoodjs/testing/api'\n\nexport const missingDivisor = () =>\n  mockHttpEvent({\n    queryStringParameters: {\n      dividend: '20',\n    },\n  })\n\n```\n\n----------------------------------------\n\nTITLE: Testing Article Summary Rendering with RedwoodJS Test Utilities in TypeScript\nDESCRIPTION: This TypeScript-based snippet implements similar tests as the JavaScript example, verifying the correct rendering of both full and truncated article body within the Article component using RedwoodJS utilities. It demonstrates typing flexibility, but otherwise shares the same input structure, props, and expected outputs as the JavaScript tests. Dependencies are @redwoodjs/testing and the Article component; parameters center around the article object and optional summary prop, with outputs validated via DOM assertions and limitations as described previously.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { render, screen } from '@redwoodjs/testing'\n\nimport Article from './Article'\n\n// highlight-start\nconst ARTICLE = {\n  id: 1,\n  title: 'First post',\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\n  createdAt: new Date().toISOString(),\n}\n// highlight-end\n\ndescribe('Article', () => {\n  it('renders a blog post', () => {\n    // highlight-next-line\n    render(<Article article={ARTICLE} />)\n\n    // highlight-start\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(screen.getByText(ARTICLE.body)).toBeInTheDocument()\n    // highlight-end\n  })\n\n  // highlight-start\n  it('renders a summary of a blog post', () => {\n    render(<Article article={ARTICLE} summary={true} />)\n\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(\n      screen.getByText(\n        'Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Str...'\n      )\n    ).toBeInTheDocument()\n  })\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Including Environment Variables in redwood.toml - TOML\nDESCRIPTION: Configures redwood.toml to expose selected environment variables from the [web] section via includeEnvironmentVariables, enabling those env vars on the client-side during build and dev. Only keys in this array (e.g., PUBLIC_KEY) will be available in the web environment. Caution: do not include secrets since they will become publicly accessible.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n  includeEnvironmentVariables = [\"PUBLIC_KEY\"]\n```\n\n----------------------------------------\n\nTITLE: GraphQL Result Alias Usage in RedwoodJS Cells - JavaScript\nDESCRIPTION: By adding an alias ('articles: posts') in the GraphQL query, this snippet demonstrates how to rename the prop received in the Success state to 'articles' even when fetching 'posts' from the backend. This pattern is useful when a front-end component expects a differently named prop than the underlying data model.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nexport const QUERY = gql`\\n  query ArticlesQuery {\\n    // highlight-next-line\\n    articles: posts {\\n      id\\n    }\\n  }\\n`\\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Article Component With Prop - TypeScript (TSX)\nDESCRIPTION: This snippet shows usage of the Article component with the article prop in TypeScript/TSX syntax. The example assumes that a properly typed article object is available in scope. This is intended for use in the main application, not in Storybook stories.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/storybook.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n<Article article={article} />\n```\n\n----------------------------------------\n\nTITLE: Adjusting hasRole for String Roles in Strict Mode (Diff)\nDESCRIPTION: This diff snippet shows modifications to the `hasRole` function in `api/src/lib/auth.ts` to make it compatible with strict mode when the `currentUser.roles` property is expected to be a single string. It removes checks related to arrays and simplifies the logic for string comparison.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\nexport const hasRole = (roles: AllowedRoles): boolean => {\n  if (!isAuthenticated()) {\n    return false\n  }\n\n  const currentUserRoles = context.currentUser?.roles\n\n  if (typeof roles === 'string') {\n-    if (typeof currentUserRoles === 'string') {\n      return currentUserRoles === roles\n-    }\n  }\n\n  if (Array.isArray(roles)) {\n-    if (Array.isArray(currentUserRoles)) {\n-      return currentUserRoles?.some((allowedRole) =>\n-        roles.includes(allowedRole)\n-      )\n-    } else if (typeof currentUserRoles === 'string') {\n      // roles to check is an array, currentUser.roles is a string\n      return roles.some((allowedRole) => currentUserRoles === allowedRole)\n-    }\n  }\n\n  // roles not found\n  return false\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Metadata with Messages using RedwoodJS Logger in JSX\nDESCRIPTION: Shows different ways to include metadata (like an `item` object or specific properties) directly or within an object when logging messages at various levels (`debug`, `warn`, `error`) using the RedwoodJS logger. Requires `logger`, `item`, and `error` objects.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nlogger.debug({ item }, `Item ${item.name} detail`)\nlogger.warn(item, `Item ${item.id} is missing a name`)\nlogger.warn(\n  { missing: { name: item.name } },\n  `Item ${item.id} is missing values`\n)\nlogger.error(error, `Failed to save item`)\n```\n\n----------------------------------------\n\nTITLE: Explaining Data Prop Origin in Success Component (JavaScript)\nDESCRIPTION: This JavaScript snippet highlights the `posts` field within the cell's GraphQL `QUERY`. It explains that the name of the root query field defined in the `QUERY` constant (`posts` in this case) directly determines the name of the prop that will contain the fetched data passed to the `Success` component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nexport const QUERY = gql`\n  query ArticlesQuery {\n    // highlight-next-line\n    posts {\n      id\n    }\n  }\n`\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Related Records in RedwoodJS Scenarios - JSX\nDESCRIPTION: Defines a scenario with related models, illustrating how to nest creates and refer to related authors and comments. Designed for RedwoodJS testing environments, this construct relies on defineScenario and hierarchical object notation to create and associate posts, authors, and comments. However, assigning authorId directly is not possible using only object notation; this limitation highlights the need to access previously created scenario data for cross-referencing IDs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_63\n\nLANGUAGE: jsx\nCODE:\n```\nexport const standard = defineScenario({\n  post: {\n    first: {\n      data: {\n        name: 'First Post',\n        author: { create: { name: 'Kris' }},\n        comments: {\n          create: [\n            {\n              name: 'First Comment',\n              body: 'String',\n              authorId: // Here we want a different author...\n            },\n            {\n              name: 'First Comment Response',\n              body: 'String',\n              authorId: // But here we want the same author as the post...\n            },\n          ],\n        },\n      }\n    }),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Job Worker in Development (Bash)\nDESCRIPTION: Command to start the RedwoodJS background job worker process in development mode. `yarn rw jobs work` initiates the job runner, which polls for pending jobs based on the configuration and executes them using spawned workers, displaying status updates directly in the terminal.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs work\n```\n\n----------------------------------------\n\nTITLE: Customizing Route Path for HomePage in RedwoodJS - TypeScript\nDESCRIPTION: This TypeScript snippet is equivalent to the JavaScript version, changing the HomePage route to '/hello' in a TypeScript context. Ensure HomePage and Route are properly typed and imported. This is used for customizing accessible URLs for components. Requires correct type annotations and RedwoodJS typing support in the project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/first-page.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/hello\" page={HomePage} name=\"home\" />\n```\n\n----------------------------------------\n\nTITLE: Custom Wrapping of RedwoodJS Components with Multiple Providers (JSX)\nDESCRIPTION: This snippet shows how to render a component for testing with additional providers by customizing the wrapper argument. Using @redwoodjs/testing/web's MockProviders and a custom provider, it demonstrates advanced integration for components relying on multiple context layers. Prerequisites: RedwoodJS, MockProviders, and any additional providers. Inputs include the component and its props; the output is a rendered component tree for use in assertions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { render, MockProviders } from '@redwoodjs/testing/web'\\n\\n// ...\\n\\nrender(<Article article={ title: 'Foobar' } />, {\\n  wrapper: ({ children }) => (\\n    <MockProviders>\\n      <MyCustomProvider>{children}</MyCustomProvider>\\n    </MockProviders>\\n  )\\n})\n```\n\n----------------------------------------\n\nTITLE: Migrating Database Schema with RedwoodJS CLI\nDESCRIPTION: This command uses the RedwoodJS CLI (`yarn rw prisma migrate dev`) to apply the changes made to the Prisma schema (specifically, adding the `User` model) to the development database. It creates and executes a new database migration, prompting for a migration name.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn rw prisma migrate dev\n```\n```\n\n----------------------------------------\n\nTITLE: Sample OpenWeather API Forecast Data (JSON)\nDESCRIPTION: Provides sample JSON data representing a 7-day weather forecast for Moscow (Jan 30, 2017 week), intended to be saved locally as `web/public/forecast.json`. This data structure, originating from the OpenWeather API, includes city details and a list of daily forecast entries containing temperature (in Kelvin), pressure, humidity, weather description, wind speed, etc.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/disable-api-database.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"cod\": \"200\",\n  \"message\": 0,\n  \"city\": {\n    \"geoname_id\": 524901,\n    \"name\": \"Moscow\",\n    \"lat\": 55.7522,\n    \"lon\": 37.6156,\n    \"country\": \"RU\",\n    \"iso2\": \"RU\",\n    \"type\": \"city\",\n    \"population\": 0\n  },\n  \"cnt\": 7,\n  \"list\": [\n    {\n      \"dt\": 1485766800,\n      \"temp\": {\n        \"day\": 262.65,\n        \"min\": 261.41,\n        \"max\": 262.65,\n        \"night\": 261.41,\n        \"eve\": 262.65,\n        \"morn\": 262.65\n      },\n      \"pressure\": 1024.53,\n      \"humidity\": 76,\n      \"weather\": [\n        {\n          \"id\": 800,\n          \"main\": \"Clear\",\n          \"description\": \"sky is clear\",\n          \"icon\": \"01d\"\n        }\n      ],\n      \"speed\": 4.57,\n      \"deg\": 225,\n      \"clouds\": 0,\n      \"snow\": 0.01\n    },\n    {\n      \"dt\": 1485853200,\n      \"temp\": {\n        \"day\": 262.31,\n        \"min\": 260.98,\n        \"max\": 265.44,\n        \"night\": 265.44,\n        \"eve\": 264.18,\n        \"morn\": 261.46\n      },\n      \"pressure\": 1018.1,\n      \"humidity\": 91,\n      \"weather\": [\n        {\n          \"id\": 600,\n          \"main\": \"Snow\",\n          \"description\": \"light snow\",\n          \"icon\": \"13d\"\n        }\n      ],\n      \"speed\": 4.1,\n      \"deg\": 249,\n      \"clouds\": 88,\n      \"snow\": 1.44\n    },\n    {\n      \"dt\": 1485939600,\n      \"temp\": {\n        \"day\": 270.27,\n        \"min\": 266.9,\n        \"max\": 270.59,\n        \"night\": 268.06,\n        \"eve\": 269.66,\n        \"morn\": 266.9\n      },\n      \"pressure\": 1010.85,\n      \"humidity\": 92,\n      \"weather\": [\n        {\n          \"id\": 600,\n          \"main\": \"Snow\",\n          \"description\": \"light snow\",\n          \"icon\": \"13d\"\n        }\n      ],\n      \"speed\": 4.53,\n      \"deg\": 298,\n      \"clouds\": 64,\n      \"snow\": 0.92\n    },\n    {\n      \"dt\": 1486026000,\n      \"temp\": {\n        \"day\": 263.46,\n        \"min\": 255.19,\n        \"max\": 264.02,\n        \"night\": 255.59,\n        \"eve\": 259.68,\n        \"morn\": 263.38\n      },\n      \"pressure\": 1019.32,\n      \"humidity\": 84,\n      \"weather\": [\n        {\n          \"id\": 800,\n          \"main\": \"Clear\",\n          \"description\": \"sky is clear\",\n          \"icon\": \"01d\"\n        }\n      ],\n      \"speed\": 3.06,\n      \"deg\": 344,\n      \"clouds\": 0\n    },\n    {\n      \"dt\": 1486112400,\n      \"temp\": {\n        \"day\": 265.69,\n        \"min\": 256.55,\n        \"max\": 266,\n        \"night\": 256.55,\n        \"eve\": 260.09,\n        \"morn\": 266\n      },\n      \"pressure\": 1012.2,\n      \"humidity\": 0,\n      \"weather\": [\n        {\n          \"id\": 600,\n          \"main\": \"Snow\",\n          \"description\": \"light snow\",\n          \"icon\": \"13d\"\n        }\n      ],\n      \"speed\": 7.35,\n      \"deg\": 24,\n      \"clouds\": 45,\n      \"snow\": 0.21\n    },\n    {\n      \"dt\": 1486198800,\n      \"temp\": {\n        \"day\": 259.95,\n        \"min\": 254.73,\n        \"max\": 259.95,\n        \"night\": 257.13,\n        \"eve\": 254.73,\n        \"morn\": 257.02\n      },\n      \"pressure\": 1029.5,\n      \"humidity\": 0,\n      \"weather\": [\n        {\n          \"id\": 800,\n          \"main\": \"Clear\",\n          \"description\": \"sky is clear\",\n          \"icon\": \"01d\"\n        }\n      ],\n      \"speed\": 2.6,\n      \"deg\": 331,\n      \"clouds\": 29\n    },\n    {\n      \"dt\": 1486285200,\n      \"temp\": {\n        \"day\": 263.13,\n        \"min\": 259.11,\n        \"max\": 263.13,\n        \"night\": 262.01,\n        \"eve\": 261.32,\n        \"morn\": 259.11\n      },\n      \"pressure\": 1023.21,\n      \"humidity\": 0,\n      \"weather\": [\n        {\n          \"id\": 600,\n          \"main\": \"Snow\",\n          \"description\": \"light snow\",\n          \"icon\": \"13d\"\n        }\n      ],\n      \"speed\": 5.33,\n      \"deg\": 234,\n      \"clouds\": 46,\n      \"snow\": 0.04\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scenario Data for Comments with RedwoodJS - TypeScript\nDESCRIPTION: Defines test data scenarios with full Prisma typing for more type safety in RedwoodJS tests. The 'postOnly' scenario specifies a single post using Prisma.PostCreateArgs, and type aliases StandardScenario/PostOnlyScenario expose scenario types for stronger test inference. Requires '@prisma/client' types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_18\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Prisma } from '@prisma/client'\n\nexport const standard = defineScenario<Prisma.CommentCreateArgs>({\n  // ...\n})\n\n// highlight-start\nexport const postOnly = defineScenario<Prisma.PostCreateArgs>({\n  post: {\n    bark: {\n      data: {\n        title: 'Bark',\n        body: \"A tree's bark is worse than its bite\",\n      },\n    },\n  },\n})\n// highlight-end\n\nexport type StandardScenario = typeof standard\n// highlight-next-line\nexport type PostOnlyScenario = typeof postOnly\n```\n\n----------------------------------------\n\nTITLE: Rendering Comments with Tailwind Gap Styling - JavaScript (JSX)\nDESCRIPTION: Refactors the CommentsCell 'Success' component to wrap comments in a div with Tailwind CSS's 'space-y-8' class. This visually separates each Comment component by a margin, improving readability. Relies on CSS utility classes from Tailwind and a comments array as input.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Success = ({ comments }) => {\\n  return (\\n    // highlight-next-line\\n    <div className=\"space-y-8\">\\n      {comments.map((comment) => (\\n        <Comment comment={comment} key={comment.id} />\\n      ))}\\n    // highlight-next-line\\n    </div>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Database to Add Foreign Key (Bash)\nDESCRIPTION: Command sequence for applying or resetting Prisma migrations and reseeding the database in RedwoodJS. Used to apply schema changes and ensure that the new userId field is available and that the seed script can succeed. Dependencies include Prisma CLI and RedwoodJS conventions. Inputs are schema migration state, output is an updated, seeded database schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate reset\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma db seed\n```\n\n----------------------------------------\n\nTITLE: Finding Element with Partial Text Match (JavaScript)\nDESCRIPTION: Uses the testing library's `screen.getByText` function to find an element containing the `truncatedBody` string. The `{ exact: false }` option allows for partial matches, meaning the element can contain additional text.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst matchedBody = screen.getByText(truncatedBody, { exact: false })\n```\n\n----------------------------------------\n\nTITLE: Implementing a RedwoodJS Transformer Directive (`@maskedEmail`) (JavaScript)\nDESCRIPTION: Provides the JavaScript implementation for the `@maskedEmail` transformer directive using `createTransformerDirective` from `@redwoodjs/graphql-server`. It defines a `transform` function that takes the `resolvedValue` (the original field value) and replaces all alphanumeric characters with asterisks ('*'), effectively masking the data. This implementation does not use the `permittedRoles` argument shown in its schema definition.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createTransformerDirective, TransformerDirectiveFunc } from '@redwoodjs/graphql-server'\n\nexport const schema = gql`\n  directive @maskedEmail(permittedRoles: [String]) on FIELD_DEFINITION\n`\n\nconst transform: TransformerDirectiveFunc = ({ context, resolvedValue }) => {\n  return resolvedValue.replace(/[a-zA-Z0-9]/i, '*')\n}\n\nconst maskedEmail = createTransformerDirective(schema, transform)\n\nexport default maskedEmail\n```\n\n----------------------------------------\n\nTITLE: Renamed Comments Service Test to reflect post-specific query - JavaScript\nDESCRIPTION: This JavaScript snippet renames the scenario test to emphasize that it's checking all comments for a single post from the database. The test structure remains the same: it queries by postId, fetches the target post and its comments, and asserts that the counts match. This is part of a TDD workflow for more accurate test descriptions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_32\n\nLANGUAGE: JavaScript\nCODE:\n```\n// highlight-start\\nscenario(\\n  'returns all comments for a single post from the database',\\n  // highlight-end\\n  async (scenario) => {\\n    const result = await comments({ postId: scenario.comment.jane.postId })\\n    const post = await db.post.findUnique({\\n      where: { id: scenario.comment.jane.postId },\\n      include: { comments: true },\\n    })\\n    expect(result.length).toEqual(post.comments.length)\\n  }\\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Up TailwindCSS for UI Styling - RedwoodJS - Bash\nDESCRIPTION: Installs the TailwindCSS UI setup for RedwoodJS using the project's CLI, ensuring the CSS classes used in further examples are available. Prerequisites: an existing RedwoodJS project with Yarn installed. The command modifies project configuration to use Tailwind. No parameters required; output is the configured TailwindCSS ready for use.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/intermission.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup ui tailwindcss\n```\n\n----------------------------------------\n\nTITLE: Setting Up Firebase Authentication with RedwoodJS - Bash\nDESCRIPTION: This snippet shows the Bash command needed to set up Firebase Authentication in a RedwoodJS project. It installs all necessary packages and automatically makes the required code modifications for Firebase authentication. No additional parameters are required except having Yarn and RedwoodJS CLI available, and the command must be run from the root of your RedwoodJS project. The setup will affect both the API and web sides of the project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/firebase.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup auth firebase\n```\n\n----------------------------------------\n\nTITLE: Importing the Audit Creation Function into Users Service (TypeScript)\nDESCRIPTION: Imports the `createAudit` function from the `audits` service located at `../audits/audits`. This enables the `users` service to interact with the `audits` service and create audit log entries, demonstrating RedwoodJS inter-service communication.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\n\nimport { createAudit } from '../audits/audits'\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Integrating ArticlesCell into HomePage (JavaScript/JSX)\nDESCRIPTION: This snippet shows how to use the created `ArticlesCell` within a RedwoodJS Page component (`HomePage.jsx`). It imports the `ArticlesCell` and renders it (`<ArticlesCell />`) within the `HomePage`'s JSX structure. This integrates the data fetching and display logic encapsulated by the cell into the page.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/HomePage/HomePage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\n\n// highlight-next-line\nimport ArticlesCell from 'src/components/ArticlesCell'\n\nconst HomePage = () => {\n  return (\n    <>\n      <Metadata title=\"Home\" description=\"Home page\" />\n      // highlight-next-line\n      <ArticlesCell />\n    </>\n  )\n}\n\nexport default HomePage\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing apiUrl in redwood.toml - TOML\nDESCRIPTION: Shows how to override the apiUrl parameter in redwood.toml's [web] section so that api endpoints (such as GraphQL) resolve at a different root URL. Useful when the API is hosted separately from the default location. Update the URL according to your actual external API endpoint; this does not require further dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n  apiUrl = \"https://api.coolredwoodapp.com\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Emotion Plugin in web/babel.config.js\nDESCRIPTION: This JSX (JavaScript) snippet shows the content of `web/babel.config.js` required to enable the Emotion styling library. It adds the `@emotion` plugin to the `plugins` array. Redwood automatically merges this custom configuration with its base Babel setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/project-configuration-dev-test-build.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nmodule.exports = {\n  plugins: ['@emotion'], // 👈 add the emotion plugin\n}\n\n// ℹ️ Notice how we don't need the `extends` property\n```\n\n----------------------------------------\n\nTITLE: Declaring a RedwoodJS Directive on a GraphQL Relation Field (GraphQL)\nDESCRIPTION: Example of applying a custom directive `@myDirective` to a relation field `bazzes` (which returns a list of `Baz` types) within a GraphQL type `Bar`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\ntype Baz {\n  name: String!\n}\n\ntype Bar {\n  name: String!\n  bazzes: [Baz]! @myDirective\n}\n```\n\n----------------------------------------\n\nTITLE: Installing pino-papertrail in RedwoodJS (bash)\nDESCRIPTION: Presents the Yarn installation command for adding the pino-papertrail logger transport in the 'api' workspace. This command must be executed before configuration and usage of the Papertrail logger in application code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace api add pino-papertrail\n```\n\n----------------------------------------\n\nTITLE: RedwoodJS Server Startup Error for Missing Auth Directives Bash\nDESCRIPTION: Displays an error message encountered during RedwoodJS API server startup. The `[GQL Server Error] - Schema validation failed` indicates that queries or mutations (like `posts`, `createPost`) lack the required `@requireAuth` or `@skipAuth` directives, preventing the server from starting successfully.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_54\n\nLANGUAGE: bash\nCODE:\n```\ngen | Generating TypeScript definitions and GraphQL schemas...\ngen | 47 files generated\napi | Building... Took 593 ms\napi | [GQL Server Error] - Schema validation failed\napi | ----------------------------------------\napi | You must specify one of @requireAuth, @skipAuth or a custom directive for\napi | - posts Query\napi | - createPost Mutation\napi | - updatePost Mutation\napi | - deletePost Mutation\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies using Yarn in GitPod Shell\nDESCRIPTION: Runs the `yarn install` command within the GitPod terminal to install all necessary project dependencies defined in the `package.json` file. This step is required when setting up an existing project in a new GitPod workspace after launching it.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-gitpod.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Verifying Discourse/GitHub Webhooks with SHA256 in RedwoodJS (TSX)\nDESCRIPTION: This AWS Lambda handler demonstrates verifying SHA256 HMAC signatures for webhooks, commonly used by services like Discourse and GitHub, within a RedwoodJS application. It utilizes the `verifyEvent` function from `@redwoodjs/api/webhooks` configured with the `sha256Verifier`. The handler expects the signature in the `X-Discourse-Event-Signature` header (configurable via `options`) and retrieves the shared secret from the `DISCOURSE_WEBHOOK_SECRET` environment variable. It includes logging and specific error handling for `WebhookVerificationError`, returning a 401 status if verification fails.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n```jsx\nimport type { APIGatewayEvent } from 'aws-lambda'\nimport {\n  verifyEvent,\n  VerifyOptions,\n  WebhookVerificationError,\n} from '@redwoodjs/api/webhooks'\n\nimport { logger } from 'src/lib/logger'\n\nexport const handler = async (event: APIGatewayEvent) => {\n  const discourseInfo = { webhook: 'discourse' }\n  const webhookLogger = logger.child({ discourseInfo })\n\n  webhookLogger.trace('Invoked discourseWebhook function')\n\n  try {\n    const options = {\n      signatureHeader: 'X-Discourse-Event-Signature',\n    } as VerifyOptions\n\n    verifyEvent('sha256Verifier', {\n      event,\n      secret: process.env.DISCOURSE_WEBHOOK_SECRET,\n      options,\n    })\n\n    webhookLogger.debug({ headers: event.headers }, 'Headers')\n\n    const payload = JSON.parse(event.body)\n\n    webhookLogger.debug({ payload }, 'Body payload')\n\n    // Safely use the validated webhook payload\n\n    return {\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      statusCode: 200,\n      body: JSON.stringify({\n        data: payload,\n      }),\n    }\n  } catch (error) {\n    if (error instanceof WebhookVerificationError) {\n      webhookLogger.warn('Unauthorized')\n\n      return {\n        statusCode: 401,\n      }\n    } else {\n      webhookLogger.error({ error }, error.message)\n\n      return {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        statusCode: 500,\n        body: JSON.stringify({\n          error: error.message,\n        }),\n      }\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Comment Creation API Service with Scenario Data - JavaScript\nDESCRIPTION: Implements integration tests using RedwoodJS testing utilities for the comments service. The scenario('postOnly') test checks that createComment creates and returns new comment records correctly, linking them to the specified post and verifying all fields. Assumes comments and createComment are imported from the same module.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comments-schema.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\n// highlight-next-line\nimport { comments, createComment } from './comments'\n\ndescribe('comments', () => {\n  scenario('returns all comments', async (scenario) => {\n    const result = await comments()\n\n    expect(result.length).toEqual(Object.keys(scenario.comment).length)\n  })\n\n  // highlight-start\n  scenario('postOnly', 'creates a new comment', async (scenario) => {\n    const comment = await createComment({\n      input: {\n        name: 'Billy Bob',\n        body: 'What is your favorite tree bark?',\n        post: {\n          connect: { id: scenario.post.bark.id },\n        },\n      },\n    })\n\n    expect(comment.name).toEqual('Billy Bob')\n    expect(comment.body).toEqual('What is your favorite tree bark?')\n    expect(comment.postId).toEqual(scenario.post.bark.id)\n    expect(comment.createdAt).not.toEqual(null)\n  })\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Typing DbAuth Handler Options with DbAuthHandlerOptions in TypeScript\nDESCRIPTION: Demonstrates using the `DbAuthHandlerOptions` utility type from `@redwoodjs/api` to configure and type options for DbAuth actions (e.g., `forgotPassword`) within the authentication handler function (`api/src/functions/auth.ts`). It takes the Prisma User model type as a generic (`<PrismaUser>`) to correctly type the `user` object passed to nested handlers. Depends on `@prisma/client`, `@redwoodjs/api`, and AWS Lambda types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nimport type { User as PrismaUser } from '@prisma/client'\n\nimport type { DbAuthHandlerOptions } from '@redwoodjs/api'\n\nexport const handler = async (\n  event: APIGatewayProxyEvent,\n  context: Context\n) => {\n  // Pass in the generic to the type here 👇\n  const forgotPasswordOptions: DbAuthHandlerOptions<PrismaUser>['forgotPassword'] =\n    {\n      // ...\n\n      // Now in the handler function, `user` will be typed\n      handler: (user) => {\n        return user\n      },\n\n      // ...\n    }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving Aliased Data in JavaScript Success Component (RedwoodJS Cell)\nDESCRIPTION: This JavaScript snippet shows the signature of a RedwoodJS Cell's Success component. It receives the 'articles' prop, which contains the data fetched by the GraphQL query where the 'posts' field was aliased to 'articles'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nexport const Success = ({ articles }) => { ... }\n```\n\n----------------------------------------\n\nTITLE: Conditionally Allowing Arbitrary GraphQL Operations via Request Header (TypeScript)\nDESCRIPTION: Implement a function for the `allowArbitraryOperations` option to permit non-persisted GraphQL queries. This function checks the incoming `request` object for a specific header (`x-allow-arbitrary-operations`) and returns `true` if the header value is 'true', enabling arbitrary operations for that specific request. This feature is often used for development or debugging but should be enabled cautiously in production environments. The `redwood.currentUser` query is implicitly allowed even when this option is configured.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nallowArbitraryOperations: (request) => {\n  return request.headers.get('x-allow-arbitrary-operations') === 'true'\n}\n```\n\n----------------------------------------\n\nTITLE: User Creation with Custom PrismaClient using validateUniqueness in JavaScript/JSX\nDESCRIPTION: This demonstrates using a custom PrismaClient instance in uniqueness validation, particularly useful if .env configurations differ or when special transaction options are set. The instance is imported and passed through the options object. validateUniqueness ensures the email is unique using the specified db connection before user creation. Requires db from src/lib/db and validateUniqueness().\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_55\n\nLANGUAGE: jsx\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nconst createUser = (input) => {\n  return validateUniqueness('user', { email: input.email }, { db }, (db) =>\n    db.user.create({ data: input })\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding a Submit Button to a RedwoodJS Form - TypeScript\nDESCRIPTION: This TypeScript snippet adds a <Submit> button labeled 'Save' to a RedwoodJS form with a <TextField> field, illustrating complete form setup within a typed React functional component. It depends on '@redwoodjs/web' and '@redwoodjs/forms'. Expected input is user text; output is form submission, with further logic not yet implemented. This demonstrates full form scaffolding using RedwoodJS and TypeScript best practices.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField, Submit } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form>\n        <TextField name=\"input\" />\n        // highlight-next-line\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Exporting Redwood Service Caching Utilities - JavaScript\nDESCRIPTION: Details the export statement for RedwoodJS cache utilities, injecting the cache client and configuration such as logger and timeout. This enables reuse of initialized cache helpers (cache, cacheFindMany) throughout the service codebase, with logging and optional expiration control.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_68\n\nLANGUAGE: js\nCODE:\n```\nexport const { cache, cacheFindMany } = createCache(client, {\\n  logger,\\n  timeout: 500,\\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Fields to a RedwoodJS Form (TypeScript)\nDESCRIPTION: This snippet demonstrates adding multiple typed input fields (`TextField`, `TextAreaField`) to a RedwoodJS form in TypeScript. It updates the `FormValues` interface to include types for the new fields (`name`, `email`, `message`) and imports the necessary `TextAreaField` component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\n// highlight-start\nimport {\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n// highlight-end\n\ninterface FormValues {\n  // highlight-start\n  name: string\n  email: string\n  message: string\n  // highlight-end\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-start\n        <TextField name=\"name\" />\n        <TextField name=\"email\" />\n        <TextAreaField name=\"message\" />\n        // highlight-end\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Form Validation Trigger Mode in JavaScript\nDESCRIPTION: Configures a RedwoodJS form to trigger validation on blur events—i.e., when users leave an input field—rather than just on submit. By setting the config 'mode' to 'onBlur', validation and error messages update more responsively as users proceed through fields. Prerequisite is an existing form using Redwood's Form component; requires React and RedwoodJS dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_33\n\nLANGUAGE: jsx\nCODE:\n```\n<Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n```\n\n----------------------------------------\n\nTITLE: Configuring Directives in RedwoodJS GraphQL Handler (TypeScript)\nDESCRIPTION: This TypeScript snippet shows the setup for the RedwoodJS GraphQL handler (`api/src/functions/graphql.ts`). It imports directives located in `src/directives` and passes them to the `createGraphQLHandler` function via the `directives` property in the configuration object. This automatically integrates the defined directives into the GraphQL schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createGraphQLHandler } from '@redwoodjs/graphql-server'\n\nimport directives from 'src/directives/**/*.{js,ts}' // 👈 directives live here\nimport sdls from 'src/graphql/**/*.sdl.{js,ts}'\nimport services from 'src/services/**/*.{js,ts}'\n\nimport { db } from 'src/lib/db'\nimport { logger } from 'src/lib/logger'\n\nexport const handler = createGraphQLHandler({\n  loggerConfig: { logger, options: {} },\n  directives, //  👈 directives are added to the schema here\n  sdls,\n  services,\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Querying Scheduled Jobs via RedwoodJS Console (JavaScript)\nDESCRIPTION: Shows how to inspect scheduled background jobs stored in the database (when using the PrismaAdapter) using the RedwoodJS console. The command `db.backgroundJob.findMany()` within the console (`yarn rw console`) retrieves and displays all entries from the `BackgroundJob` table, showing job details like handler, arguments, queue, priority, and run time.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_14\n\nLANGUAGE: js\nCODE:\n```\n% yarn rw console\n> db.backgroundJob.findMany()\n[\n  {\n    id: 1,\n    attempts: 0,\n    handler: '{\"name\":\"SendWelcomeEmailJob\",path:\"SendWelcomeEmailJob/SendWelcomeEmailJob\",\"args\":[335]}',\n    queue: 'default',\n    priority: 50,\n    runAt: 2024-07-12T22:27:51.085Z,\n    lockedAt: null,\n    lockedBy: null,\n    lastError: null,\n    failedAt: null,\n    createdAt: 2024-07-12T22:27:51.125Z,\n    updatedAt: 2024-07-12T22:27:51.125Z\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Updating TypeScript GraphQL Schema (SDL) for Comments\nDESCRIPTION: Updates the GraphQL schema definition in a TypeScript SDL file (`comments.sdl.ts`). It modifies the `comments` query definition within the `Query` type to mandate a `postId` argument of type `Int!`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_28\n\nLANGUAGE: graphql\nCODE:\n```\n```graphql title=\"api/src/graphql/comments.sdl.ts\"\ntype Query {\n  // highlight-next-line\n  comments(postId: Int!): [Comment!]! @skipAuth\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Destructuring Auth Values from useAuth in React - JavaScript\nDESCRIPTION: This snippet demonstrates how to destructure the isAuthenticated status, the WebAuthn client object, and the logIn method from the useAuth hook in a React application. The client object provides access to WebAuthn-related functions (isSupported, isEnabled, register, authenticate), facilitating biometric authentication integrations. It assumes that the project is using a custom authentication context which provides useAuth, and that React and the necessary AuthProvider context are set up.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nconst { isAuthenticated, client, logIn } = useAuth()\n```\n\n----------------------------------------\n\nTITLE: Using ScenarioData Type Alias in Redwood Service Tests (TypeScript)\nDESCRIPTION: Illustrates how to import and use a `ScenarioData`-based type alias (like `StandardScenario` from `./posts.scenarios`) to type the `scenario` object within a Redwood service test. This provides strong typing and autocompletion when accessing data created by the scenario (e.g., `scenario.post.one.id`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport type { StandardScenario } from './posts.scenarios'\n\nscenario('returns a single post', async (scenario: StandardScenario) => {\n  const result = await post({ id: scenario.post.one.id })\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating ArticleCell into ArticlePage (TypeScript)\nDESCRIPTION: This snippet presents the initial TypeScript version of the `ArticlePage` component located at `web/src/pages/ArticlePage/ArticlePage.tsx`. It imports and renders the `ArticleCell` component, similar to the JavaScript version, preparing for data display but not yet passing the required ID.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\n```jsx title=\"web/src/pages/ArticlePage/ArticlePage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport ArticleCell from 'src/components/ArticleCell'\n\nconst ArticlePage = () => {\n  return (\n    <>\n      <Metadata title=\"Article\" description=\"Article page\" />\n\n      // highlight-next-line\n      <ArticleCell />\n    </>\n  )\n}\n\nexport default ArticlePage\n```\n```\n\n----------------------------------------\n\nTITLE: Updating CommentsCell Mock Data in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates updating the mock data file (`CommentsCell.mock.ts`) for the `CommentsCell` component. The `postId` field is added to each comment object in the `standard` mock export function. This correction ensures the mock data matches the fields requested by the `CommentsCell`'s GraphQL query, preventing 'Missing field' errors during testing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_27\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"web/src/components/CommentsCell/CommentsCell.mock.ts\"\nexport const standard = () => ({\n  comments: [\n    {\n      id: 1,\n      name: 'Rob Cameron',\n      body: 'First comment',\n      // highlight-next-line\n      postId: 1,\n      createdAt: '2020-01-02T12:34:56Z',\n    },\n    {\n      id: 2,\n      name: 'David Price',\n      body: 'Second comment',\n      // highlight-next-line\n      postId: 2,\n      createdAt: '2020-02-03T23:00:00Z',\n    },\n  ],\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Performing Strict Cache Matching in RedwoodJS Tests (TypeScript)\nDESCRIPTION: Illustrates how to perform strict cache value comparisons using the `testCacheClient.contents` getter. Unlike `toHaveCached`, `.contents` does not automatically serialize the expected value, requiring manual handling (e.g., converting Date objects to ISO strings) to match the serialized data in the cache. It also shows accessing the raw cache storage via `testCacheClient.storage`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_78\n\nLANGUAGE: ts\nCODE:\n```\nconst expectedValue = {\n  // Note that this is a date 👇\n  publishDate: new Date('12/10/1988'),\n  title: 'A book from the eighties',\n  id: 1988,\n}\n\n// ✅ will pass, because we will serialize the publishedDate for you\nexpect(testCacheClient).toHaveCached(expectedValue)\n\n// 🛑 won't pass, because publishDate in cache is a string, but you supplied a Date object\nexpect(testCacheClient.contents).toContainEqual(expectedValue)\n\n// ✅ will pass, because you serialized the date\nexpect(testCacheClient.contents).toContainEqual({\n  ...expectedValue,\n  publishDate: expectedValue.publishDate.toISOString(),\n})\n\n// And if you wanted to view the raw contents of the cache\nconsole.log(testCacheClient.storage)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Firebase Sign Up with useAuth Hook in RedwoodJS - TSX\nDESCRIPTION: This React (TSX) snippet provides an example of signing up a user with Firebase Authentication in a RedwoodJS home page component. The useAuth hook is imported from 'src/auth', and its isAuthenticated status and signUp function are extracted. The page displays the authentication state and includes a 'sign up' button that triggers the signUp function (with email and password hardcoded as comments for demonstration). Required dependencies are RedwoodJS Auth and React; the component expects that Firebase has been set up as per prior steps and that email/password auth is enabled in Firebase. The example is for demonstration and omits a production-ready form.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/firebase.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAuth } from 'src/auth'\n\nconst HomePage = () => {\n  const { isAuthenticated, signUp } = useAuth()\n\n  return (\n    <>\n      {/* MetaTags, h1, paragraphs, etc. */}\n\n      <p>{JSON.stringify({ isAuthenticated })}</p>\n      <button\n        onClick={() =>\n          signUp({\n            // email: 'your.email@email.com',\n            // password: 'super secret password',\n          })\n        }\n      >\n        sign up\n      </button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx for RedwoodJS Web and API Proxy\nDESCRIPTION: This Nginx configuration file (`nginx.conf`) sets up Nginx to serve the static web files for a RedwoodJS application located in `/var/www/myapp/current/web/dist`. It also acts as a reverse proxy, forwarding requests made to `/.redwood/functions` to the backend Redwood API server running on `127.0.0.1:8911`. Includes configurations for gzip compression, static file caching, custom error pages, and keepalive timeout.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_35\n\nLANGUAGE: nginx\nCODE:\n```\nupstream redwood_server {\n  server 127.0.0.1:8911 fail_timeout=0;\n}\n\nserver {\n  root /var/www/myapp/current/web/dist;\n  server_name myapp.com;\n  index index.html;\n\n  gzip on;\n  gzip_min_length 1000;\n  gzip_types application/json text/css application/javascript application/x-javascript;\n\n  sendfile on;\n\n  keepalive_timeout 65;\n\n  error_page 404 /404.html;\n  error_page 500 /500.html;\n\n  location / {\n    try_files $uri /200.html =404;\n  }\n\n  location ^~ /static/ {\n    gzip_static on;\n    expires max;\n    add_header Cache-Control public;\n  }\n\n  location ~ /.redwood/functions(.*) {\n    rewrite ^/.redwood/functions(.*) $1 break;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_pass http://redwood_server;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Serving RedwoodJS App with Yarn - Shell\nDESCRIPTION: Runs a compound command using Yarn to build the RedwoodJS application and then serve it locally. The command is 'yarn rw build && yarn rw serve', which first compiles the project and, if successful, starts the server. This process is required after every code change because the dev server does not support React Server Components yet. Dependencies include the RedwoodJS CLI and local project configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw build && yarn rw serve\n```\n\n----------------------------------------\n\nTITLE: Building for Vercel without Data Migration (Example)\nDESCRIPTION: An example showing how to use the Vercel deploy command to build the project and apply Prisma database migrations, while skipping the data migration step using the `--no-data-migrate` flag.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_25\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood deploy vercel --no-data-migrate\n```\n\n----------------------------------------\n\nTITLE: Displaying Redwood Project Environment Info (Bash)\nDESCRIPTION: This command prints system and Redwood project environment information, such as OS, Node/Yarn versions, browsers, and installed Redwood packages. It's primarily used for debugging purposes when seeking help.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_91\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood info\n```\n\n----------------------------------------\n\nTITLE: Generating a New SESSION_SECRET for dbAuth - Bash\nDESCRIPTION: Invokes the RedwoodJS command to generate a cryptographically secure SESSION_SECRET for encrypting session cookies when using dbAuth. This secret should be copied into the appropriate environment variable (SESSION_SECRET) in your hosting provider (e.g., Netlify). It requires no arguments, produces a unique alphanumeric string on each run, and should never be shared publicly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/deployment.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g secret\n```\n\n----------------------------------------\n\nTITLE: Resetting Form Fields using formMethods.reset() in RedwoodJS (JS)\nDESCRIPTION: Shows how to call the `reset()` method on the `formMethods` object within the `onCompleted` callback of the `useMutation` hook in JavaScript (`.jsx`). This action clears the form fields after a successful mutation (e.g., contact form submission) and typically follows a success notification.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_39\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\n// ...\n\nconst [create, { loading, error }] = useMutation(CREATE_CONTACT, {\n  onCompleted: () => {\n    toast.success('Thank you for your submission!')\n    // highlight-next-line\n    formMethods.reset()\n  },\n})\n\n// ...\n```\n```\n\n----------------------------------------\n\nTITLE: Refetching GraphQL Queries with Mutations in RedwoodJS (TypeScript)\nDESCRIPTION: This TypeScript snippet mirrors the JavaScript example but leverages TypeScript typings for safety and autocompletion. The useMutation hook for CREATE is typed, and the CommentsQuery is imported to ensure that the correct query is refetched after creating a comment. Dependencies include @redwoodjs/forms, @redwoodjs/web, TypeScript GraphQL types, as well as the CREATE mutation document. The function's input is a typed Props object with postId; outputs involve automatic data refresh via Apollo.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Form,\n  FormError,\n  Label,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\nimport { useMutation } from '@redwoodjs/web'\n\n// highlight-next-line\nimport { QUERY as CommentsQuery } from 'src/components/CommentsCell'\n\n// ...\n\nconst CommentForm = ({ postId }: Props) => {\n  // highlight-start\n  const [createComment, { loading, error }] = useMutation(CREATE, {\n    refetchQueries: [{ query: CommentsQuery }],\n  })\n  // highlight-end\n\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Authenticated Moderator User in Storybook - React (JavaScript)\nDESCRIPTION: Demonstrates how to use the global mockCurrentUser function in Storybook to set the current user as a moderator for testing the moderatorView of the Comment component. Takes an object representing the mocked user, including id, email, and a roles string or array. The snippet is useful for testing authentication states and requires Storybook's global mockCurrentUser and the Comment component. Outputs a React element with the authenticated context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\nexport const moderatorView = () => {\\n  // highlight-start\\n  mockCurrentUser({\\n    id: 1,\\n    email: 'moderator@moderator.com',\\n    roles: 'moderator',\\n  })\\n  // highlight-end\\n\\n  return (\\n    <Comment\\n      comment={{\\n        id: 1,\\n        name: 'Rob Cameron',\\n        body: 'This is the first comment!',\\n        createdAt: '2020-01-01T12:34:56Z',\\n        postId: 1,\\n      }}\\n    />\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Highlighting Default GraphQL Query in ArticlesCell (TypeScript/TSX)\nDESCRIPTION: This snippet highlights the default typed GraphQL query generated within the `ArticlesCell.tsx`. RedwoodJS assumes a query root field `articles` based on the cell name and generates corresponding TypeScript types (`ArticlesQuery`, `ArticlesQueryVariables`). This query initially fetches only the `id` field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/components/ArticlesCell/ArticlesCell.tsx\"\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> = // highlight-line\n  gql`\n    query ArticlesQuery {\n      // highlight-next-line\n      articles {\n        id\n      }\n    }\n  `\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Base CSS Styles for RedwoodJS Web Application - CSS\nDESCRIPTION: This CSS snippet provides a base stylesheet located in 'web/src/index.css', setting fonts, margin, error styles, form layouts, and flex container behavior. It assumes the stylesheet is imported into the main entry point of the application. Classes such as .error and .form-error standardize error displays. Inputs are HTML elements; output is improved UI fidelity. Some selectors use specificity for accessibility and consistent appearance.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/first-page.md#_snippet_5\n\nLANGUAGE: css\nCODE:\n```\nbody {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica,\n    Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';\n}\nul {\n  list-style-type: none;\n  margin: 1rem 0;\n  padding: 0;\n}\nli {\n  display: inline-block;\n  margin: 0 1rem 0 0;\n}\nh1 > a {\n  text-decoration: none;\n  color: black;\n}\nbutton,\ninput,\nlabel,\ntextarea {\n  display: block;\n  outline: none;\n}\nlabel {\n  margin-top: 1rem;\n}\n.error {\n  color: red;\n}\ninput.error,\ntextarea.error {\n  border: 1px solid red;\n}\n.form-error {\n  color: red;\n  background-color: lavenderblush;\n  padding: 1rem;\n  display: inline-block;\n}\n.form-error ul {\n  list-style-type: disc;\n  margin: 1rem;\n  padding: 1rem;\n}\n.form-error li {\n  display: list-item;\n}\n.flex-between {\n  display: flex;\n  justify-content: space-between;\n}\n.flex-between button {\n  display: inline;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Scaffold Nesting for Destruction in redwood.toml (TOML)\nDESCRIPTION: TOML configuration snippet for `redwood.toml` used when destroying scaffolds. The `destroy` command respects the `nestScaffoldByModel` setting, so it might need to be temporarily set to `false` (as shown) to correctly remove scaffolds that were generated without model-based nesting.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_73\n\nLANGUAGE: toml\nCODE:\n```\n[generate]\n  nestScaffoldByModel = false\n```\n\n----------------------------------------\n\nTITLE: Expanding Set Wrapping to JSX Layouts - RedwoodJS - JSX\nDESCRIPTION: This snippet expands on how Set wrapping works, showing the equivalent JSX for the previous Set example. It demonstrates how non-'wrap' props (like theme) are passed directly to the wrapper component, preserving the structure and behavior of the grouped routes. This clarifies the internal expansion of Set to scaffolding with parameterized layouts.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n<MainLayout theme=\"dark\">\n  <Route path=\"/\" page={HomePage} name=\"home\" />\n</MainLayout>\n```\n\n----------------------------------------\n\nTITLE: Attaching Prisma Storage Extension - RedwoodJS TypeScript\nDESCRIPTION: This snippet shows how to initialize and export a Prisma client extended with a storage-related extension in RedwoodJS. The code imports logging helpers, applies the storage extension via `$extends`, and exports the extended client as `db` for use throughout the application. Dependencies include `@prisma/client`, RedwoodJS logging utilities, and a pre-configured `storagePrismaExtension` from a local uploads library.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { PrismaClient } from '@prisma/client'\n\nimport { emitLogLevels, handlePrismaLogging } from '@redwoodjs/api/logger'\n\nimport { logger } from './logger'\n// highlight-next-line\nimport { storagePrismaExtension } from './uploads'\n\n// 👇 Notice here we create prisma client, but don't export it yet\nconst prismaClient = new PrismaClient({\n  log: emitLogLevels(['info', 'warn', 'error']),\n})\n\nhandlePrismaLogging({\n  db: prismaClient,\n  logger,\n  logLevels: ['info', 'warn', 'error'],\n})\n\n// 👇 Export db after adding uploads extension\n// highlight-next-line\nexport const db = prismaClient.$extends(storagePrismaExtension)\n```\n\n----------------------------------------\n\nTITLE: Disconnecting from an SSH Session using Bash\nDESCRIPTION: Demonstrates how to disconnect from an active SSH session using the `exit` command entered at the remote server's prompt. The output shows the command being entered and the confirmation message that the connection has been closed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nroot@remote-server:~# exit\n\nConnection to 192.168.0.122 closed.\n```\n\n----------------------------------------\n\nTITLE: Installing 'stream' Package using Yarn Workspaces\nDESCRIPTION: Shell command using Yarn Workspaces to add the Node.js `stream` package as a dependency to the `api` workspace in a RedwoodJS project. This is a prerequisite for creating custom writable streams for logging transports.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\nyarn workspace api add stream\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Job with CLI (Bash)\nDESCRIPTION: Demonstrates using the `yarn rw g job` command to create a new background job file named `SendWelcomeEmail.js` in the `api/src/jobs` directory. This command scaffolds the necessary structure for a job within the RedwoodJS project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g job SendWelcomeEmail\n```\n\n----------------------------------------\n\nTITLE: Configuring TailwindCSS to Include Tremor Modules (js)\nDESCRIPTION: This code represents the tailwind.config.js file, extended to include the @tremor module for purging unused styles. It ensures Tailwind processes both local and third-party Tremor component classes. The content paths are relative to the placement of the web workspace.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\n    'src/**/*.{js,jsx,ts,tsx}',\n    '../node_modules/@tremor/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Initial CommentsCell States in RedwoodJS (JSX)\nDESCRIPTION: This JSX code snippet shows the default Jest tests for a RedwoodJS `CommentsCell` component located in `web/src/components/CommentsCell/CommentsCell.test.jsx`. It imports `render` from `@redwoodjs/testing/web`, the component's states (`Loading`, `Empty`, `Failure`, `Success`), and mock data (`standard`). The tests verify that each state (`Loading`, `Empty`, `Failure`, `Success`) renders without throwing errors using basic `expect().not.toThrow()` assertions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { render } from '@redwoodjs/testing/web'\n\nimport { Loading, Empty, Failure, Success } from './CommentsCell'\nimport { standard } from './CommentsCell.mock'\n\ndescribe('CommentsCell', () => {\n  it('renders Loading successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  it('renders Empty successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  it('renders Failure successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  it('renders Success successfully', async () => {\n    expect(() => {\n      render(<Success comments={standard().comments} />)\n    }).not.toThrow()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Fast and Slow Resolvers for Defer Demo - TypeScript\nDESCRIPTION: Implements RedwoodJS service resolvers returning fast and slow responses for demonstration with the `@defer` directive in GraphQL. The `fastField` function resolves immediately with a string; `slowField` waits for `waitFor` ms before returning, and logs process timing using a logger. Requires `src/lib/logger` and optionally depends on Redwood's environment. Inputs: optional wait time for `slowField`. Outputs: strings for each field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { logger } from 'src/lib/logger'\n\nconst wait = (time: number) =>\n  new Promise((resolve) => setTimeout(resolve, time))\n\nexport const fastField = async () => {\n  return 'I am speedy'\n}\n\nexport const slowField = async (_, { waitFor = 5000 }) => {\n  logger.debug('deferring slowField until ...')\n  await wait(waitFor)\n  logger.debug('now!')\n\n  return 'I am slow'\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering a Basic Comment Component - RedwoodJS TypeScript\nDESCRIPTION: This snippet implements a TypeScript version of the Comment component for RedwoodJS, ensuring type safety with a temporary Props type. It receives a 'comment' object containing 'name', 'createdAt', and 'body' fields and renders them in structured HTML. The use of TypeScript enforces expected prop shapes, increasing reliability during development and integration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/the-redwood-way.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// highlight-start\n// Just a temporary type. We'll replace this later\ninterface Props {\n  comment: {\n    name: string\n    createdAt: string\n    body: string\n  }\n}\n// highlight-end\n\n// highlight-next-line\nconst Comment = ({ comment }: Props) => {\n  return (\n    <div>\n      // highlight-start\n      <h2>{comment.name}</h2>\n      <time dateTime={comment.createdAt}>{comment.createdAt}</time>\n      <p>{comment.body}</p>\n      // highlight-end\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Evicting Data from Apollo Cache using useCache in TypeScript\nDESCRIPTION: Shows how to use the `evict` method, obtained from the `useCache` hook, to remove data from the Apollo Client cache. It demonstrates removing a complete normalized object by its ID (`Post:123`) and removing a specific field (`title`) from a cached object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/caching.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst CacheExample = () => {\n  const { evict } = useCache()\n\n  // You can remove any normalized object from the cache using the evict method:\n  evict({ id: 'Post:123' })\n\n  // You can also remove a single field from a cached object by providing the name of the field to remove\n  evict({ id: 'Post:123', fieldName: 'title' })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Upload Savers for Multiple Models - RedwoodJS TypeScript\nDESCRIPTION: Illustrates the setup of upload savers for multiple models via `createUploadsConfig` and `setupStorage`. Each model receives corresponding saver methods (e.g., `saveFiles.forProfile`, `saveFiles.forAnotherModel`). Configuration specifies which model fields should accept file uploads. The special `inList` method is shown for cases not directly linked to a Prisma model.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst uploadConfig = createUploadsConfig({\n  profile: {\n    fields: ['avatar'],\n  },\n  anotherModel: {\n    fields: ['document'],\n  },\n})\n\nconst { saveFiles } = setupStorage(uploadConfig)\n\n// Available methods 👇\nsaveFiles.forProfile(profileGqlInput)\nsaveFiles.forAnotherModel(anotherModelGqlInput)\n\n// Special case - not mapped to prisma model\nsaveFiles.inList(arrayOfFiles)\n```\n\n----------------------------------------\n\nTITLE: Updating GraphQL Query for Admin Post Edit Cell (JavaScript)\nDESCRIPTION: This snippet shows the frontend GraphQL query for the EditPostCell component, adapted to use the adminPost query rather than the previous post query. It fetches a post by id for editing, expecting fields id, title, body, and createdAt via the admin resolver. Dependencies include RedwoodJS GQL and GraphQL tagging, and the $id parameter is supplied when the cell is rendered.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nexport const QUERY = gql`\n  query EditPostById($id: Int!) {\n    // highlight-next-line\n    post: adminPost(id: $id) {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Handling Filestack Upload Completion in RedwoodJS Forms (JavaScript)\nDESCRIPTION: This snippet integrates the Filestack PickerInline component into a RedwoodJS form and demonstrates how to handle successful file uploads using the onSuccess prop. When a file upload completes, the onFileUpload function logs the response, which includes the uploaded files array. Dependencies include filestack-react and RedwoodJS, and apikey must be set from environment variables. Expected output is the file upload response object, including accessible image URLs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {8-10,16} title=\\\"web/src/components/ImageForm/ImageForm.js\\\"\n// imports and stuff...\n\nconst ImageForm = (props) => {\n  const onSubmit = (data) => {\n    props.onSave(data, props?.image?.id)\n  }\n\n  const onFileUpload = (response) => {\n    console.info(response)\n  }\n\n  // form stuff...\n\n  <PickerInline\n    apikey={process.env.REDWOOD_ENV_FILESTACK_API_KEY}\n    onSuccess={onFileUpload}\n  />\n```\n```\n\n----------------------------------------\n\nTITLE: Scheduling a Job with Options in JavaScript\nDESCRIPTION: This example illustrates scheduling a job (`SampleJob`) using a scheduler instance (`later`). It passes arguments (`[user.id]`) to the job's `perform` method and includes an options object (`{ wait: 300 }`) to specify a delay of 300 seconds before the job runs. Alternatively, `waitUntil` with a Date object could be used.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nlater(SampleJob, [user.id], { wait: 300 })\n```\n\n----------------------------------------\n\nTITLE: Passing Post ID to CommentForm in Article Component (JSX/TSX)\nDESCRIPTION: This snippet demonstrates passing the `article.id` as a `postId` prop to the `CommentForm` component within the `Article` component. This is necessary to associate the new comment with the correct blog post when submitting the form. The change is shown for both JavaScript (JSX) and TypeScript (TSX) versions of the `Article` component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/Article/Article.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\nimport CommentsCell from 'src/components/CommentsCell'\nimport CommentForm from 'src/components/CommentForm'\n\nconst truncate = (text, length) => {\n  return text.substring(0, length) + '...'\n}\n\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      {!summary && (\n        <div className=\"mt-12\">\n          // highlight-next-line\n          <CommentForm postId={article.id} />\n          <div className=\"mt-12\">\n            <CommentsCell />\n          </div>\n        </div>\n      )}\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\nLANGUAGE: tsx\nCODE:\n```\n```jsx title=\"web/src/components/Article/Article.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\nimport CommentsCell from 'src/components/CommentsCell'\nimport CommentForm from 'src/components/CommentForm'\n\nconst truncate = (text: string, length: number) => {\n  return text.substring(0, length) + '...'\n}\n\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      {!summary && (\n        <div className=\"mt-12\">\n          // highlight-next-line\n          <CommentForm postId={article.id} />\n          <div className=\"mt-12\">\n            <CommentsCell />\n          </div>\n        </div>\n      )}\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\n----------------------------------------\n\nTITLE: Launching Redwood Console in Bash\nDESCRIPTION: This bash command starts the RedwoodJS interactive console, which preloads the Redwood environment and Prisma database client. It allows evaluation and experimentation with database queries, such as reading and writing models, ideal for rapid backend prototyping. There are no required input parameters; running this command launches a Node.js shell with extended RedwoodJS context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw console\n```\n\n----------------------------------------\n\nTITLE: Integrating CommentsCell into Article Component - TypeScript\nDESCRIPTION: The TypeScript version of the Article component imports CommentsCell, types, and uses interfaces for strong typing, including conditional comments display. It supports summary mode, ensures correct prop shapes, and provides a helper to truncate article text. All dependencies should be installed (RedwoodJS, type imports), and it enhances maintainability for large codebases.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n// highlight-next-line\nimport CommentsCell from 'src/components/CommentsCell'\n\nimport type { Post } from 'types/graphql'\n\nconst truncate = (text: string, length: number) => {\n  return text.substring(0, length) + '...'\n}\n\ninterface Props {\n  article: Omit<Post, 'createdAt'>\n  summary?: boolean\n}\n\nconst Article = ({ article, summary = false }: Props) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      // highlight-next-line\n      {!summary && <CommentsCell />}\n    </article>\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Defining Supported Webhook Signature Verifiers - TypeScript\nDESCRIPTION: This TypeScript type definition enumerates all of the supported signature verification strategies that the RedwoodJS webhooks package can use, including strategies like SkipVerifier, SecretKeyVerifier, Sha1Verifier, Sha256Verifier, Base64Sha1Verifier, Base64Sha256Verifier, TimestampSchemeVerifier, and JwtVerifier. It enables developers to type-check which verification strategies are supported throughout RedwoodJS when signing or verifying webhook payloads. No external dependencies beyond the RedwoodJS webhooks package are required. This union type does not handle behavior directly; rather, it facilitates type safety and clarity in code utilizing these verifiers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport type SupportedVerifiers =\n  | SkipVerifier\n  | SecretKeyVerifier\n  | Sha1Verifier\n  | Sha256Verifier\n  | Base64Sha1Verifier\n  | Base64Sha256Verifier\n  | TimestampSchemeVerifier\n  | JwtVerifier\n```\n\n----------------------------------------\n\nTITLE: Verifying Vercel Webhooks (using SHA256) in RedwoodJS (TSX)\nDESCRIPTION: This AWS Lambda handler demonstrates verifying webhooks, intended for Vercel, within a RedwoodJS application. The code uses the `sha256Verifier` with `verifyEvent` and expects the signature in the `x-vercel-signature` header, using the `DISCOURSE_WEBHOOK_SECRET` environment variable. Note that the accompanying text suggests Vercel uses SHA1 and Base64 encodes the event; RedwoodJS's `verifyEvent` handles automatic Base64 body decoding if `event.isBase64Encoded` is true, but this code explicitly uses SHA256 for verification, which might differ from Vercel's standard. The handler includes logging and error handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n```jsx\nimport type { APIGatewayEvent } from 'aws-lambda'\nimport {\n  verifyEvent,\n  VerifyOptions,\n  WebhookVerificationError,\n} from '@redwoodjs/api/webhooks'\n\nimport { logger } from 'src/lib/logger'\n\nexport const handler = async (event: APIGatewayEvent) => {\n  const vercelInfo = { webhook: 'vercel' }\n  const webhookLogger = logger.child({ vercelInfo })\n\n  webhookLogger.trace('Invoked vercelWebhook function')\n\n  try {\n    const options = {\n      signatureHeader: 'x-vercel-signature',\n    } as VerifyOptions\n\n    verifyEvent('sha256Verifier', {\n      event,\n      secret: process.env.DISCOURSE_WEBHOOK_SECRET,\n      options,\n    })\n\n    webhookLogger.debug({ headers: event.headers }, 'Headers')\n\n    const payload = JSON.parse(event.body)\n\n    webhookLogger.debug({ payload }, 'Body payload')\n\n    // Safely use the validated webhook payload\n\n    return {\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      statusCode: 200,\n      body: JSON.stringify({\n        data: payload,\n      }),\n    }\n  } catch (error) {\n    if (error instanceof WebhookVerificationError) {\n      webhookLogger.warn('Unauthorized')\n\n      return {\n        statusCode: 401,\n      }\n    } else {\n      webhookLogger.error({ error }, error.message)\n\n      return {\n        headers: {\n         'Content-Type': 'application/json',\n        },\n        statusCode: 500,\n        body: JSON.stringify({\n          error: error.message,\n        }),\n      }\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining the Base Storage Adapter Interface in TypeScript\nDESCRIPTION: This TypeScript code defines the `BaseStorageAdapter` abstract class, which serves as the blueprint for all storage adapters within the RedwoodJS upload system. It includes a constructor for adapter options, helper methods, and mandates the implementation of core functionalities: `save` (to store a file), `remove` (to delete a file), and `read` (to retrieve file contents and type). Concrete adapters must extend this class and provide implementations for the abstract methods.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport abstract class BaseStorageAdapter {\n  adapterOpts: AdapterOptions\n  constructor(adapterOpts: AdapterOptions) {\n    this.adapterOpts = adapterOpts\n  }\n\n  getAdapterOptions() {\n    return this.adapterOpts\n  }\n\n  generateFileNameWithExtension(\n    saveOpts: SaveOptionsOverride | undefined,\n    file: File\n  ) {\n    /** We give you an easy way to generate file names **/\n  }\n\n  abstract save(\n    file: File,\n    saveOpts?: SaveOptionsOverride\n  ): Promise<AdapterResult>\n\n  abstract remove(fileLocation: AdapterResult['location']): Promise<void>\n\n  abstract read(fileLocation: AdapterResult['location']): Promise<{\n    contents: Buffer | string\n    type: ReturnType<typeof mime.lookup>\n  }>\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Length Validator with `between` Option in JSX\nDESCRIPTION: Demonstrates the `length` validator using the `between` option, which is a shorthand for defining both `min` and `max` length constraints using a two-element array `[min, max]`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.title, 'Title', {\n  length: { between: [2, 255] },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Forcing Regeneration of GraphQL Documentation in Docusaurus\nDESCRIPTION: This command is similar to the previous generation command but includes the `--force` flag (`yarn docusaurus graphql-to-doc --force`). This option forces the `graphql-markdown` plugin to overwrite any existing documentation files, bypassing the default diff mechanism.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_92\n\nLANGUAGE: terminal\nCODE:\n```\nyarn docusaurus graphql-to-doc --force\n```\n\n----------------------------------------\n\nTITLE: Setting up RedwoodJS Mailer via CLI (Bash)\nDESCRIPTION: This Bash command uses the RedwoodJS CLI (`yarn rw`) to set up the Mailer feature. Running `yarn rw setup mailer` installs necessary dependencies and generates the required configuration files, such as `api/src/lib/mailer.ts`, preparing the project to use the Mailer.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/mailer.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n```bash title=\"RedwoodJS CLI\"\nyarn rw setup mailer\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Handler with Trusted Documents Store (TypeScript)\nDESCRIPTION: This code snippet from `api/src/functions/graphql.ts` shows how to configure the RedwoodJS GraphQL handler to use Trusted Documents on the server side. It imports the generated `store` from `src/lib/trustedDocumentsStore` and passes it to the `createGraphQLHandler` function within the `trustedDocuments` configuration object. This enables the server to look up and execute queries based on the received hash.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { createGraphQLHandler } from '@redwoodjs/graphql-server'\n\n// ...\nimport { store } from 'src/lib/trustedDocumentsStore'\n\nexport const handler = createGraphQLHandler({\n  getCurrentUser,\n  loggerConfig: { logger, options: {} },\n  directives,\n  sdls,\n  services,\n  trustedDocuments: { store },\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing SigninPage Component Structure in JSX\nDESCRIPTION: This snippet sets up the basic structure for a `SigninPage` component in a RedwoodJS application. It includes importing necessary form components from `@redwoodjs/forms`, initializing a state variable for error handling using `React.useState`, defining a placeholder `onSubmit` function, and rendering a form with email and password fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/SigninPage/SigninPage.js\"\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\n\nconst SigninPage = () => {\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = (data) => {\n    // do sign in here\n  }\n\n  return (\n    <>\n      <h1>Sign In</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign In</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SigninPage\n```\n```\n\n----------------------------------------\n\nTITLE: Modified PM2 Ecosystem Configuration for API Only (JavaScript/JSX)\nDESCRIPTION: An alternative `ecosystem.config.js` configuration for PM2. This setup is suitable when using a separate web server like nginx to serve the web side. It configures PM2 to only run the API side of the RedwoodJS application using `yarn rw serve api`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nmodule.exports = {\n  apps: [\n    {\n      name: 'api',\n      cwd: 'current',\n      script: 'node_modules/.bin/rw',\n      args: 'serve api',\n      instances: 'max',\n      exec_mode: 'cluster',\n      wait_ready: true,\n      listen_timeout: 10000,\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: SSH Username/Password Authentication - Shell\nDESCRIPTION: Demonstrates using the SSH utility to connect to a remote server with username and password authentication. The first command is generic, requiring a user and server address; the second is an explicit example connecting as 'root' to a specific IP address. The snippet expects the user to provide a password interactively after running the command. The SSH client is required as a dependency.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nssh user@server.com\n```\n\nLANGUAGE: shell\nCODE:\n```\nssh root@192.168.0.122\n```\n\n----------------------------------------\n\nTITLE: Generic Postgres Connection String Format (Bash/URL)\nDESCRIPTION: Presents the template structure for a PostgreSQL connection string. Placeholders (USER, PASSWORD, HOST, PORT, DATABASE) indicate values to be substituted when configuring database URLs. Essential for any application or .env files referencing Postgres. Intended as a reference, not an executable command.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\n----------------------------------------\n\nTITLE: Handling SSH First Connection Host Verification - Shell\nDESCRIPTION: This shell snippet shows the expected host verification and key fingerprint prompt from the SSH client when connecting to a remote host for the first time. It informs the user about the server's authenticity and requests confirmation before adding the host to the known_hosts file. No dependencies are required aside from a standard SSH client. Input is the server address, and user confirmation is required; output is the update to the known_hosts file. The main limitation is that this is an interactive prompt and not a script.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nThe authenticity of host '192.168.0.122 (192.168.0.122)' can't be established.\\nED25519 key fingerprint is SHA256:FHQDzxsqA68c+BhLPUkyN8aAVrznDtekhPg/99JXk8Q.\\nThis key is not known by any other names\\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n```\n\n----------------------------------------\n\nTITLE: Initializing SignoutBtn Component Structure in JSX\nDESCRIPTION: This snippet shows the initial structure of the `SignoutBtn` component. It renders a simple HTML button with an `onClick` handler pointing to a placeholder `onClick` function where the sign-out logic will be implemented.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/SignoutBtn/SignoutBtn.js\"\nconst SignoutBtn = () => {\n  const onClick = () => {\n    // do sign out here.\n  }\n  return <button onClick={() => onClick()}>Sign Out</button>\n}\n\nexport default SignoutBtn\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Database Schema with Prisma ORM - Prisma Schema\nDESCRIPTION: Defines a PostgreSQL datasource and sets up Prisma's JavaScript client generator. Declares a 'Testimonial' model with fields for id (auto-increment), author (unique), quote, and timestamps, configuring default and updated values. This schema is required by Prisma to generate migrations, manage database structure, and enable type-safe access in JavaScript code. Ensure 'DATABASE_URL' is set in environment variables for database connectivity.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter0/what-is-redwood.md#_snippet_2\n\nLANGUAGE: prisma\nCODE:\n```\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = \"native\"\n}\n\nmodel Testimonial {\n  id        Int       @id @default(autoincrement())\n  author    String    @unique\n  quote     String\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating a Sign Out Button Component with RedwoodJS CLI in Bash\nDESCRIPTION: This snippet demonstrates how to generate a new component named 'signoutBtn' using the RedwoodJS CLI. The created component will reside in the web/src/components/SignoutBtn directory. The command requires that 'yarn' and the 'redwood' CLI are installed and run in a RedwoodJS project. No additional parameters are needed besides the component name.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate component signoutBtn\n```\n\n----------------------------------------\n\nTITLE: Typing Cell Failure Props with CellFailureProps in TypeScript\nDESCRIPTION: Illustrates using the `CellFailureProps` utility type to type the props of a Cell's `Failure` component. It accepts an optional generic (`TVariables`) for the query variables type, allowing access to typed variables within the component, useful for displaying context-specific error messages.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport type { FindBlogPostQuery, FindBlogPostQueryVariables } from 'types/graphql'\n\n// highlight-next-line\nimport type { CellFailureProps } from '@redwoodjs/web'\n\n// ...\n\nexport const Failure = ({\n  error,\n  variables // 👈 Variables is typed based on the generic\n  // highlight-next-line\n}: CellFailureProps<FindBlogPostQueryVariables>) => (\n  // ...\n)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Redwood Prisma Command Execution (Shell)\nDESCRIPTION: Shows the output when running a Redwood Prisma command (e.g., `migrate dev`). It demonstrates that `yarn redwood prisma` proxies the command to the actual Prisma CLI (`yarn prisma`) while automatically passing the correct schema path flag.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_95\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn redwood prisma migrate dev\nyarn run v1.22.10\n$ ~/redwood-app/node_modules/.bin/redwood prisma migrate dev\nRunning prisma cli:\nyarn prisma migrate dev --schema \"~/redwood-app/api/db/schema.prisma\"\n...\n```\n\n----------------------------------------\n\nTITLE: Generated Nested Routes for Namespaced Scaffold (JSX)\nDESCRIPTION: JSX code snippet from `./web/src/Routes.js` showing the generated routes for a namespaced scaffold (`admin/user`). It demonstrates how the routes are nested under the specified path (`/admin/users`) and wrapped in a `Set` component using the corresponding generated layout (`UsersLayout`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_71\n\nLANGUAGE: jsx\nCODE:\n```\nconst Routes = () => {\n  return (\n    <Router>\n      <Set wrap={UsersLayout}>\n        <Route path=\"/admin/users/new\" page={AdminUserNewUserPage} name=\"adminNewUser\" />\n        <Route path=\"/admin/users/{id:Int}/edit\" page={AdminUserEditUserPage} name=\"adminEditUser\" />\n        <Route path=\"/admin/users/{id:Int}\" page={AdminUserUserPage} name=\"adminUser\" />\n        <Route path=\"/admin/users\" page={AdminUserUsersPage} name=\"adminUsers\" />\n      </Set>\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Navigation Header to HomePage in JSX (JS/TS)\nDESCRIPTION: Updates the HomePage component to include a header with the site title and a navigation list containing a link to the 'About' page. It imports the `<Link>` component and `routes` object from `@redwoodjs/router` to create navigation using named routes (`routes.about()`) and the `<Metadata>` component from `@redwoodjs/web` for page metadata. Both JavaScript (.jsx) and TypeScript (.tsx) versions are provided.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/second-page.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/pages/HomePage/HomePage.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\n\nconst HomePage = () => {\n  return (\n    <>\n      <Metadata title=\"Home\" description=\"Home page\" />\n\n      // highlight-start\n      <header>\n        <h1>Redwood Blog</h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>Home</main>\n      // highlight-end\n    </>\n  )\n}\n\nexport default HomePage\n```\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/pages/HomePage/HomePage.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\nimport { Metadata } from '@redwoodjs/web'\n\nconst HomePage = () => {\n  return (\n    <>\n      <Metadata title=\"Home\" description=\"Home page\" />\n\n      // highlight-start\n      <header>\n        <h1>Redwood Blog</h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n          </ul>\n        </nav>\n      </header>\n      <main>Home</main>\n      // highlight-end\n    </>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Setting Up RedwoodJS Cache Testing with InMemoryClient (TypeScript)\nDESCRIPTION: Illustrates the setup for testing RedwoodJS caching. It imports the `InMemoryClient` type and the shared `client` instance, then uses Jest's `afterEach` hook to call `testCacheClient.clear()`, ensuring a fresh cache state for each test.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_72\n\nLANGUAGE: ts\nCODE:\n```\nimport type { InMemoryClient } from '@redwoodjs/api/cache'\nimport { client } from 'src/lib/cache'\n\n// For TypeScript users\nconst testCacheClient = client as InMemoryClient\n\ndescribe('products', () => {\n  // highlight-start\n  afterEach(() => {\n    testCacheClient.clear()\n  })\n  // highlight-end\n  //....\n})\n```\n\n----------------------------------------\n\nTITLE: Rendering Blog Posts and Pagination - RedwoodJS Cell Success - JavaScript\nDESCRIPTION: Updates the 'Success' component of BlogPostsCell in JavaScript to render both blog post entries and the Pagination component. Imports the Pagination component and feeds it postPage.count, placing the pagination UI after the post list. This enables interactive page navigation from the posts view.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/pagination.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nimport Pagination from 'src/components/Pagination'\n\n// ...\n\nexport const Success = ({ postPage }) => {\n  return (\n    <>\n      {postPage.posts.map((post) => (\n        <BlogPost key={post.id} post={post} />\n      ))}\n\n      <Pagination count={postPage.count} />\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Modules with Path Aliases in RedwoodJS - TypeScript\nDESCRIPTION: This TypeScript snippet illustrates importing a CustomModal component using both the default long absolute path and a cleaner alias-based path after configuring tsconfig.json. The technique improves readability and ease of refactoring by allowing module import statements to use a logical alias ('@adminUI/CustomModal'), assuming the alias is configured and recognized by both TypeScript and supporting tools.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/introduction.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// this really long path\nimport { CustomModal } from 'src/components/modules/admin/common/ui/CustomModal'\n\n// to this nicer one!\nimport { CustomModal } from '@adminUI/CustomModal'\n```\n\n----------------------------------------\n\nTITLE: Using the toHaveCached Matcher in RedwoodJS Tests (TypeScript)\nDESCRIPTION: Demonstrates the three primary ways to use the `toHaveCached` Jest matcher in a RedwoodJS test scenario. It shows checking for data existence regardless of key, checking for data at a specific key, and checking for data in a key matching a regular expression.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_74\n\nLANGUAGE: ts\nCODE:\n```\nscenario('returns a single product', async (scenario: StandardScenario) => {\n  await product({ id: scenario.product.three.id })\n\n// Pattern 1: Only check that the data is present in the cache\n  expect(testCacheClient).toHaveCached(scenario.product.three)\n\n// Pattern 2: Check that data is cached, at a specific key\n  expect(testCacheClient).toHaveCached(\n    `cached-product-${scenario.product.three.id}`,\n    scenario.product.three\n  )\n\n// Pattern 3: Check that data is cached, in a key matching the regex\n  expect(testCacheClient).toHaveCached(\n    /cached-.*/,\n    scenario.product.three\n  )\n```\n```\n\n----------------------------------------\n\nTITLE: Defining HomePage in RedwoodJS (JavaScript)\nDESCRIPTION: Sets up a minimal HomePage component in JavaScript, using @redwoodjs/web to inject page metadata. This component renders a simple string ('Home') and expects no props or parameters. The Metadata component defines the page's title and description for SEO. Dependencies: @redwoodjs/web.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/layouts.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\\n\\nconst HomePage = () => {\\n  return (\\n    <>\\n      <Metadata title=\"Home\" description=\"Home page\" />\\n      Home\\n    </>\\n  )\\n}\\n\\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Passing Mocked Articles Explicitly as Props in Storybook (TypeScript/TSX)\nDESCRIPTION: Demonstrates passing the 'articles' property from the standard mock explicitly as a prop to the Success component in a TypeScript/TSX Storybook story. This method aids in clarity for type inference and maintains type safety for the Success component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Success } from './ArticlesCell'\\nimport { standard } from './ArticlesCell.mock'\\n\\nexport const success = () => {\\n  // highlight-next-line\\n  return Success ? <Success articles={standard().articles} /> : null\\n}\\n\\nexport default { title: 'Cells/ArticlesCell' }\n```\n\n----------------------------------------\n\nTITLE: Persisting Apollo Cache using apollo3-cache-persist in JavaScript/JSX\nDESCRIPTION: Shows how to persist the Apollo Client cache using the `persistCache` function from `apollo3-cache-persist`. It requires the `cache` object obtained from `useCache` and a storage provider, such as `LocalStorageWrapper` configured with `window.localStorage`. The operation is asynchronous.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/caching.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { persistCache, LocalStorageWrapper } from 'apollo3-cache-persist'\n\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst PersistCacheExample = async () => {\n  const { cache } = useCache()\n\n  await persistCache({\n    cache,\n    storage: new LocalStorageWrapper(window.localStorage),\n  })\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Truncated Body Presence (JavaScript)\nDESCRIPTION: Asserts that the element found earlier (containing the truncated body) is actually present in the document using `expect(matchedBody).toBeInTheDocument()`. This confirms the partial body text was rendered.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nexpect(matchedBody).toBeInTheDocument()\n```\n\n----------------------------------------\n\nTITLE: Styling Comments List in Success State with Tailwind - TypeScript\nDESCRIPTION: This TypeScript Success cell function wraps Comment components with a div using the Tailwind “space-y-8” class for spacing, enhancing readability when rendering multiple comments. It is used within a RedwoodJS Cell, expects a comments prop of the correct type, and is suitable for typed projects. Integration with Tailwind CSS and type imports from RedwoodJS are required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nexport const Success = ({\n  comments,\n}: CellSuccessProps<CommentsQuery, CommentsQueryVariables>) => {\n  return (\n    // highlight-next-line\n    <div className=\"space-y-8\">\n      {comments.map((comment) => (\n        <Comment comment={comment} key={comment.id} />\n      ))}\n      // highlight-next-line\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Web-Side Jest Settings\nDESCRIPTION: This JSX (JavaScript) snippet shows the typical content of `./web/jest.config.js`. It sets the root directory relative to the web folder and uses the Redwood-provided Jest preset (`@redwoodjs/testing/config/jest/web`) which includes necessary configurations for testing React components, mocking Cells, handling JSX/Babel, and mocking the Router/GraphQL client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/project-configuration-dev-test-build.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst config = {\n  rootDir: '../',\n  preset: '@redwoodjs/testing/config/jest/web',\n  // ☝️ load the built-in Redwood Jest configuration\n}\n\nmodule.exports = config\n```\n\n----------------------------------------\n\nTITLE: Typing Directive Arguments with ValidatorDirectiveFunc Generics (TypeScript)\nDESCRIPTION: Demonstrates using the generic parameter of `ValidatorDirectiveFunc` to specify the type of the arguments passed to the directive in the SDL (e.g., `roles`). By defining a type alias like `ValidatorDirectiveFunc<{ roles?: string[] }>`, the `directiveArgs` object within the `validate` function becomes strongly typed, allowing safe access like `directiveArgs.roles`. Depends on `@redwoodjs/graphql-server`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_12\n\nLANGUAGE: ts\nCODE:\n```\n// highlight-next-line\ntype RequireAuthValidate = ValidatorDirectiveFunc<{ roles?: string[] }>\n\nconst validate: RequireAuthValidate = ({ directiveArgs }) => {\n  // roles 👇 will be typed correctly as string[] | undefined\n  // highlight-next-line\n  const { roles } = directiveArgs\n  // ....\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WebAuthn User and Credential Models with Prisma in JavaScript\nDESCRIPTION: This JavaScript code snippet updates the Prisma schema to support WebAuthn. It adds required fields to the 'User' model, including a unique nullable 'webAuthnChallenge' and a relationship to a new 'UserCredential' model. The 'UserCredential' model stores device credentials for passwordless login. Dependencies include Prisma and SQLite (or configured DB), and the setup assumes use in a RedwoodJS API service. Required parameters are user ID and device publicKey; expected input is standard Prisma migration output and usage. Limit access to 'UserCredential' due to sensitive data; do not expose it via GraphQL SDL.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = \"native\"\n}\n\nmodel User {\n  id                  Int @id @default(autoincrement())\n  email               String  @unique\n  hashedPassword      String\n  salt                String\n  resetToken          String?\n  resetTokenExpiresAt DateTime?\n  // highlight-start\n  webAuthnChallenge   String? @unique\n  credentials         UserCredential[]\n  // highlight-end\n}\n\n// highlight-start\nmodel UserCredential {\n  id         String @id\n  userId     Int\n  user       User   @relation(fields: [userId], references: [id])\n  publicKey  Bytes\n  transports String?\n  counter    BigInt\n}\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Handling Livestorm Webhooks with Skip Verification in RedwoodJS (TypeScript/JSX)\nDESCRIPTION: This AWS Lambda handler function processes incoming webhooks from Livestorm, which doesn't sign its payloads. It uses the `verifyEvent` function from `@redwoodjs/api/webhooks` with the 'skipVerifier' method to bypass signature validation. The function logs information, parses the JSON payload from the event body, and returns appropriate HTTP responses. It handles potential `WebhookVerificationError` (though unlikely with 'skipVerifier') and other general errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { APIGatewayEvent } from 'aws-lambda'\nimport { verifyEvent, WebhookVerificationError } from '@redwoodjs/api/webhooks'\n\nimport { logger } from 'src/lib/logger'\n\n/**\n * The handler function is your code that processes http request events.\n * You can use return and throw to send a response or error, respectively.\n *\n * @typedef { import('aws-lambda').APIGatewayEvent } APIGatewayEvent\n * @typedef { import('aws-lambda').Context } Context\n * @param { APIGatewayEvent } event - an object which contains information from the invoker.\n * @param { Context } context - contains information about the invocation,\n * function, and execution environment.\n */\nexport const handler = async (event: APIGatewayEvent) => {\n  const livestormInfo = { webhook: 'livestorm' }\n  const webhookLogger = logger.child({ livestormInfo })\n\n  webhookLogger.trace('Livestorm')\n\n  webhookLogger.debug({ event: event }, 'The Livestorm event')\n\n  // Use the webhook payload\n  // Note: since the payload is not signed, you may want to validate other header info\n\n  try {\n    verifyEvent('skipVerifier', { event })\n\n    const data = JSON.parse(event.body)\n\n    webhookLogger.debug({ payload: data }, 'Data from Livestorm')\n\n    return {\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      statusCode: 200,\n      body: JSON.stringify({\n        data,\n      }),\n    }\n  } catch (error) {\n    if (error instanceof WebhookVerificationError) {\n      webhookLogger.warn('Unauthorized')\n\n      return {\n        statusCode: 401,\n      }\n    } else {\n      webhookLogger.error({ error }, error.message)\n\n      return {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        statusCode: 500,\n        body: JSON.stringify({\n          error: error.message,\n        }),\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Signing and Sending an Outgoing Webhook Payload in RedwoodJS (JSX)\nDESCRIPTION: This function demonstrates how to sign a payload before sending it as an outgoing webhook. It uses the `signPayload` function from `@redwoodjs/api/webhooks` with a specified verification method ('timestampSchemeVerifier') and a secret to generate a signature. The generated signature is then included in a custom header (`YOUR_WEBHOOK_SIGNATURE`) of a POST request sent using the `got` library to the destination URL.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/webhooks.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nimport got from 'got'\nimport { signPayload } from '@redwoodjs/api/webhooks'\n\nconst YOUR_OUTGOING_WEBHOOK_DESTINATION_URL = 'https://example.com/receive'\n// Assuming 'secret' is defined or imported\nconst YOUR_WEBHOOK_SIGNATURE = process.env.WEBHOOK_SIGNATURE // Example header name\n\nexport const sendOutGoingWebhooks = async ({ payload }) => {\n  const secret = process.env.YOUR_SIGNING_SECRET; // Example: Define or retrieve your secret\n  const signature = signPayload('timestampSchemeVerifier', {\n    payload,\n    secret,\n  })\n\n  await got.post(YOUR_OUTGOING_WEBHOOK_DESTINATION_URL, {\n    responseType: 'json',\n\n    json: {\n      payload,\n    },\n    headers: {\n      [YOUR_WEBHOOK_SIGNATURE]: signature, // Use dynamic header name\n    },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Restart PM2-Managed Service After Configuration Change - Bash\nDESCRIPTION: Restarts the specified PM2-managed process ('serve' in this example) so configuration changes (such as port updates) can take effect. Ensure the targeted process name matches your PM2 configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\npm2 restart serve\n```\n\n----------------------------------------\n\nTITLE: Launching Interactive Redwood Console - Bash\nDESCRIPTION: Reveals the command to enter the Redwood interactive shell, enabling direct interaction with the project's database using Prisma. Dependencies: Redwood CLI, generated Prisma Client. Input: Command. Output: Interactive shell session. Limitation: Experimental; not tested on Windows; requires Prisma Client to be generated prior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood console\n```\n\n----------------------------------------\n\nTITLE: Generating an Executable Script with Redwood CLI (Shell)\nDESCRIPTION: Shell command `yarn rw g script syncStripeProducts` demonstrating the usage of the Redwood CLI to generate a new executable script file (`./scripts/syncStripeProducts.ts`). The output confirms the file creation and provides instructions on how to run the script using `yarn rw exec`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_74\n\nLANGUAGE: bash\nCODE:\n```\n❯ yarn rw g script syncStripeProducts\n\n  ✔ Generating script file...\n    ✔ Successfully wrote file `./scripts/syncStripeProducts.ts`\n  ✔ Next steps...\n\n    After modifying your script, you can invoke it like:\n\n      yarn rw exec syncStripeProducts\n\n      yarn rw exec syncStripeProducts --param1 true\n```\n\n----------------------------------------\n\nTITLE: Prisma Migration Error Output\nDESCRIPTION: This text output shows the error message generated by Prisma Migrate when attempting to add a required `roles` column to the `User` table which already contains data. The error occurs because no default value was provided for the new non-nullable column.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n• Step 0 Added the required column `role` to the `User` table without a default value. There are 1 rows in this table, it is not possible to execute this step.\n```\n\n----------------------------------------\n\nTITLE: Configuring Public File Serving with Fastify Static in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to configure the RedwoodJS API server (`api/server.js`) to serve files from a specific directory publicly. It utilizes the `@fastify/static` plugin, registering it with the server instance. The configuration maps the local directory `uploads/public_profile_photos` to the URL prefix `/public_uploads`, allowing direct browser access to files within that directory via the API server URL.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nimport path from 'path'\n// highlight-next-line\nimport fastifyStatic from '@fastify/static'\n\nimport { createServer } from '@redwoodjs/api-server'\nimport { logger } from 'src/lib/logger'\n\nasync function main() {\n  const server = await createServer({\n    logger,\n  })\n\n  // highlight-start\n  server.register(fastifyStatic, {\n    root: path.join(process.cwd() + '/uploads/public_profile_photos'),\n    prefix: '/public_uploads',\n  })\n  // highlight-end\n\n  await server.start()\n}\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic FieldError in RedwoodJS Form (JavaScript)\nDESCRIPTION: Introduces the `<FieldError>` component from `@redwoodjs/forms`. This snippet shows how to import `FieldError` and place it below corresponding input fields (`TextField`, `TextAreaField`) within a RedwoodJS `<Form>`. The `name` prop on `<FieldError>` links it to the input field with the same name to display validation errors when the `required: true` validation fails.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  // highlight-next-line\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"name\" />\n\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"email\" />\n\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"message\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Prisma Seeding in `package.json` (JSON)\nDESCRIPTION: Shows the `prisma` section within the `package.json` file, specifically the `seed` property. This property defines the command that Prisma executes when seeding the database, which by default in Redwood uses `yarn rw exec seed` to run the project's seed script.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_100\n\nLANGUAGE: json\nCODE:\n```\n  \"prisma\": {\n    \"seed\": \"yarn rw exec seed\"\n  },\n```\n\n----------------------------------------\n\nTITLE: Setting Up Authentication Provider with Redwood CLI (Bash)\nDESCRIPTION: Executes the RedwoodJS `setup auth` command using Yarn to integrate and configure a specified authentication provider. Replace `<provider>` with the name of the chosen provider (e.g., `auth0`, `clerk`, `dbAuth`, `netlify`). The optional `--force` or `-f` flag allows overwriting existing authentication configuration files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_108\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup auth <provider>\n```\n\n----------------------------------------\n\nTITLE: Customizing PS1 Prompt by Replacing Hostname (Bash)\nDESCRIPTION: This Bash script snippet demonstrates how to customize the shell prompt by modifying the `PS1` variable definition. Specifically, it replaces the default hostname escape sequence (`\\h`) with a static string (`ruby-prod1`) to provide a more descriptive server identifier in the prompt.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nif [ \"$color_prompt\" = yes ]; then\n    PS1='${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@ruby-prod1\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w \\$\\[\\033[00m\\] '\nelse\n    PS1='${debian_chroot:+($debian_chroot)}\\u@ruby-prod1:\\w\\$\nfi\n```\n\n----------------------------------------\n\nTITLE: Example Output of Listing SSH Keys\nDESCRIPTION: Provides an example output from the `ssh-add -L` command. It shows a public SSH key in the `ssh-ed25519` format, followed by the key data (partially redacted here), and a comment typically indicating the user and hostname where the key was generated.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_12\n\nLANGUAGE: text\nCODE:\n```\nssh-ed25519 AAAAB3NzaC1yc2EAAAADAQAB<REDACTED>CU90x/khqD1sDW= rob@computer.local\n```\n\n----------------------------------------\n\nTITLE: Updating Test for Empty State Component in CommentsCell (Jest/TSX)\nDESCRIPTION: Updates the Jest test case within `web/src/components/CommentsCell/CommentsCell.test.tsx` for the `Empty` component in a TypeScript project. It utilizes React Testing Library (`render`, `screen`) to render the component and assert that the expected text \"No comments yet\" is present in the document, ensuring the component renders correctly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nit('renders Empty successfully', async () => {\n  // highlight-start\n  render(<Empty />)\n  expect(screen.getByText('No comments yet')).toBeInTheDocument()\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Generated GraphQL Query Types in a Cell (TypeScript)\nDESCRIPTION: This snippet demonstrates importing the automatically generated TypeScript types (`FindBlogPostQuery` for the data shape and `FindBlogPostQueryVariables` for input variables) corresponding to a named GraphQL query. These types are imported from `'types/graphql'`, a mapped path pointing to the generated type definition files, allowing for strong typing within the Cell component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/generated-types.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {\n  FindBlogPostQuery,\n  FindBlogPostQueryVariables,\n} from 'types/graphql'\n```\n\n----------------------------------------\n\nTITLE: Configuring Netlify Dev for RedwoodJS - INI\nDESCRIPTION: This snippet shows a section of the netlify.toml file configuring local development for a RedwoodJS application using Netlify Dev. It sets the framework, target and local ports, and includes detailed comments explaining each field and necessary steps for developers. Required dependencies include Netlify CLI (netlify-cli) at version 3.34.0 or greater, installed globally. The configuration relies on the redwood.toml web port and should be kept in the project root. The input is the configuration file, and it affects how Netlify Dev proxies and serves the Redwood application locally. There are no advanced constraints except that the developer must maintain port consistency and link to the correct Netlify site.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_114\n\nLANGUAGE: ini\nCODE:\n```\n// See: netlify.toml\\n// ...\\n[dev]\\n  # To use [Netlify Dev](https://www.netlify.com/products/dev/),\\n  # install netlify-cli from https://docs.netlify.com/cli/get-started/#installation\\n  # and then use netlify link https://docs.netlify.com/cli/get-started/#link-and-unlink-sites\\n  # to connect your local project to a site already on Netlify\\n  # then run netlify dev and our app will be accessible on the port specified below\\n  framework = \"redwoodjs\"\\n  # Set targetPort to the [web] side port as defined in redwood.toml\\n  targetPort = 8910\\n  # Point your browser to this port to access your RedwoodJS app\\n  port = 8888\n```\n\n----------------------------------------\n\nTITLE: Stub Implementation of a Weather Query Resolver (Returns Dummy Data) - JavaScript\nDESCRIPTION: This code presents a RedwoodJS service function for the 'getWeather' GraphQL query, returning static, hardcoded Weather data. It expects a single argument (zip), and returns a placeholder city, conditions, temperature, and icon. Useful for development and playground testing before integrating the actual API. No external dependencies required for dummy data; the input is a string zip code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nexport const getWeather = ({ zip }) => {\n  return {\n    zip,\n    city: 'City',\n    conditions: 'Hot Lava',\n    temp: 1000,\n    icon: 'https://placekitten.com/100/100',\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom RedwoodError Class - TypeScript/TSX\nDESCRIPTION: This TSX snippet shows how to define a custom error class by extending RedwoodError. The constructor allows a custom message and optional extensions obj. This pattern is useful for integrating third-party API errors and controlling their propagation. Requires RedwoodError base class.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_80\n\nLANGUAGE: typescript\nCODE:\n```\nexport class MyCustomError extends RedwoodError {\n  constructor(message: string, extensions?: Record<string, any>) {\n    super(message, extensions)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Database Seeding Script using Prisma Client (JavaScript/JSX)\nDESCRIPTION: Provides an example seed script (`scripts/seed.js`) demonstrating how to use Prisma Client (`db`) to create records in the database (e.g., posts). It also shows the integration of the Redwood Logger (`logger`) for logging seeding activity.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_101\n\nLANGUAGE: jsx\nCODE:\n```\nimport { db } from 'api/src/lib/db'\nimport { logger } from 'api/src/lib/logger'\n\nexport default async () => {\n  try {\n    const posts = [\n      {\n        title: 'Welcome to the blog!',\n        body: \"I'm baby single- origin coffee kickstarter lo.\",\n      },\n      {\n        title: 'A little more about me',\n        body: 'Raclette shoreditch before they sold out lyft.',\n      },\n      {\n        title: 'What is the meaning of life?',\n        body: 'Meh waistcoat succulents umami asymmetrical, hoodie post-ironic paleo chillwave tote bag.',\n      },\n    ]\n\n    Promise.all(\n      posts.map(async (post) => {\n        const newPost = await db.post.create({\n          data: { title: post.title, body: post.body },\n        })\n\n        logger.debug({ data: newPost }, 'Added post')\n      })\n    )\n  } catch (error) {\n    logger.error(error)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: OpenGraph Helpers for Title and Description in \\u003cMetadata\\u003e - JSX\nDESCRIPTION: This snippet demonstrates automatic generation of 'og:title' and 'og:description' meta tags by specifying an 'og' prop in <Metadata>. The system copies title/description props to their OpenGraph equivalents unless explicitly set to null. Input is standard string literals or special override values; output is additional OpenGraph <meta> tags.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata title=\"My Website\" og />\n// generates\n<meta name=\"title\" content=\"My Website\" />\n<meta property=\"og:title\" content=\"My Website\" />\n\n```\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata title=\"My Website\" og={{ title: null }}/>\n// generates\n<meta name=\"title\" content=\"My Website\" />\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Prisma Client Logging with RedwoodJS Logger (JavaScript)\nDESCRIPTION: Shows how to set up a PrismaClient instance with specified emitLogLevels and connect it to RedwoodJS logger for structured log handling. Dependencies: @prisma/client and @redwoodjs/api/logger. The snippet enables detailed logging for database activity and routes logs through the application logger for consistency and further processing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_27\n\nLANGUAGE: javascript\nCODE:\n```\n/*\n * Instance of the Prisma Client\n */\nexport const db = new PrismaClient({\n  log: emitLogLevels(['info', 'warn', 'error']),\n})\n\nhandlePrismaLogging({\n  db,\n  logger,\n  logLevels: ['info', 'warn', 'error'],\n})\n```\n\n----------------------------------------\n\nTITLE: Using the Format Validator with a Custom Message in JSX\nDESCRIPTION: Illustrates providing a custom error message for the `format` validator. The message is defined using the `message` property within the nested `format` object, alongside the `pattern` regular expression.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.usPhone, {\n  format: {\n    pattern: /^[0-9-]{10,12}$/,\n    message: 'Can only contain numbers and dashes',\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Completing Conditional Auth Links in RedwoodJS Navigation Component\nDESCRIPTION: Finalizes the `Navigation` component by importing the `SignoutBtn` component. It renders the `SignoutBtn` when `isAuthenticated` is true, and renders `Link` components pointing to the `signup` and `signin` routes when `isAuthenticated` is false. This ensures the correct navigation options are displayed based on the user's login status.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_24\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { useAuth } from 'src/auth'\nimport SignoutBtn from 'src/components/SignoutBtn/SignoutBtn'\n\nconst Navigation = () => {\n  const { isAuthenticated } = useAuth()\n  return (\n    <nav>\n      {isAuthenticated ? (\n        <SignoutBtn />\n      ) : (\n        <>\n          <Link to={routes.signup()}>Sign Up</Link>\n          <Link to={routes.signin()}>Sign In</Link>\n        </>\n      )}\n    </nav>\n  )\n}\n\nexport default Navigation\n```\n\n----------------------------------------\n\nTITLE: Defining Typed Test Scenarios with defineScenario (Multiple Models) in TypeScript\nDESCRIPTION: Illustrates extending the `defineScenario` function to handle test scenarios involving multiple Prisma models. This is achieved by using TypeScript union types within the generic parameters, such as `Prisma.PostCreateArgs | Prisma.UserCreateArgs` for the data types and `'post' | 'user'` for the model names. Assumes `@prisma/client` types are available.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\ndefineScenario<Prisma.PostCreateArgs | Prisma.UserCreateArgs, 'post' | 'user'>\n```\n\n----------------------------------------\n\nTITLE: Setting Up Jest to Recognize Path Aliases in RedwoodJS - JavaScript\nDESCRIPTION: This JavaScript configuration defines Jest settings for correct resolution of custom import aliases (such as '@adminUI/*') in a RedwoodJS project's web directory. The 'moduleNameMapper' property is used to map aliases to actual filesystem paths, ensuring that unit tests can properly resolve aliased imports. The configuration assumes that '@redwoodjs/testing/config/jest/web' preset is used and should be placed in the web/jest.config.js file.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/introduction.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst config = {\n  rootDir: '../',\n  preset: '@redwoodjs/testing/config/jest/web',\n  moduleNameMapper: {\n    '^@adminUI/(.*)$':\n      '<rootDir>/web/src/components/modules/admin/common/ui/$1',\n  },\n}\n\nmodule.exports = config\n```\n\n----------------------------------------\n\nTITLE: Enabling Prisma Slow Query Logging in RedwoodJS (JavaScript)\nDESCRIPTION: Demonstrates customizing slow query logging threshold in Prisma and RedwoodJS integration. Optionally adds the 'query' level to Prisma log levels and sets 'slowQueryThreshold' in milliseconds, causing only queries slower than this value to be logged at 'warn' level. Helps in identifying and diagnosing slow database operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\nhandlePrismaLogging({\n  db,\n  logger,\n  logLevels: ['query', 'info', 'warn', 'error'],\n  slowQueryThreshold: 5_000, // in ms\n})\n```\n\n----------------------------------------\n\nTITLE: Adding a Home Page Route - RedwoodJS - JavaScript (JSX)\nDESCRIPTION: This snippet shows how the generated HomePage is automatically inserted into the 'Routes.js' file by the RedwoodJS generator. It defines routing with the Router component, a route for '/', and a default notfound route. HomePage and NotFoundPage components must be imported elsewhere.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_60\n\nLANGUAGE: jsx\nCODE:\n```\nconst Routes = () => {\n  return (\n    <Router>\n      <Route path=\"/\" page={HomePage} name=\"home\" />\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Executing RedwoodJS Job Synchronously (JavaScript)\nDESCRIPTION: Shows how to run a job's task immediately and synchronously by directly calling its `perform` method. This bypasses the background queuing and scheduling system entirely. The example `await SampleEmailJob.perform(user.id)` executes the job logic within the current process flow, useful when immediate execution and completion are required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_18\n\nLANGUAGE: js\nCODE:\n```\nawait SampleEmailJob.perform(user.id)\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Mailer Development Mode in TypeScript\nDESCRIPTION: Specifies configuration options within `api/src/lib/mailer.ts` for the RedwoodJS Mailer's development mode. The `when` property determines if development mode is active (typically when `process.env.NODE_ENV !== 'production'`). The `handler` property allows specifying a custom handler, overriding the default behavior which attempts to use `@redwoodjs/mailer-handler-studio` if available. This enables features like the local inbox and template previews in Redwood Studio during development.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/mailer.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=api/src/lib/mailer.ts\ndevelopment: {\n  when: process.env.NODE_ENV !== 'production',\n  handler: 'someOtherHandler',\n},\n```\n```\n\n----------------------------------------\n\nTITLE: Prisma Schema Documentation with Triple-Slash Comments - Prisma\nDESCRIPTION: This Prisma schema excerpt demonstrates documenting models and enums using triple-slash (///) comments. Comments provide in-editor tooltips and are used by the RedwoodJS SDL generator for auto-documentation. Each model and field can be preceded by descriptive comments. No dependencies beyond Prisma schema language.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_82\n\nLANGUAGE: prisma\nCODE:\n```\n/// A blog post.\nmodel Post {\n  /// The unique identifier of a post.\n  id        Int      @id @default(autoincrement())\n  /// The title of a post.\n  title     String\n  /// The content of a post.\n  body      String\n  /// When the post was created.\n  createdAt DateTime @default(now())\n}\n\n/// A list of allowed colors.\nenum Color {\n  RED\n  GREEN\n  BLUE\n}\n```\n\n----------------------------------------\n\nTITLE: Go Back in History with back Function - RedwoodJS Router API - JavaScript/JSX\nDESCRIPTION: Shows how to use the back() function from '@redwoodjs/router' to move the user's browser history backward. Used within event handlers for navigation workflows. Requires importing from RedwoodJS router. Input is a function call, which outputs a browser history state change.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_28\n\nLANGUAGE: jsx\nCODE:\n```\nimport { back } from '@redwoodjs/router'\n\nconst SomePage = () => {\n  const onSomeAction = () => {\n    back()\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Running the RedwoodJS Test Suite\nDESCRIPTION: Executes the RedwoodJS test suite using Yarn. This command starts a persistent process that watches for file changes and automatically reruns tests for the modified files. Initially, or by pressing 'a', it can run all tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/testing.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test\n```\n\n----------------------------------------\n\nTITLE: Generating Title and Open Graph Tags with Metadata Component in JSX\nDESCRIPTION: Illustrates the combined output when using both the `title` and `og` props. It generates the `<title>` tag, the corresponding `<meta name=\"title\">` tag, the `<meta property=\"og:title\">` tag, and automatically includes a default `<meta property=\"og:type\" content=\"website\">` tag.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata title=\"My Website\" og />\n// generates\n<title>My Website</title>\n<meta name=\"title\" content=\"My Website\" />\n<meta property=\"og:title\" content=\"My Website\" />\n<meta property=\"og:type\" content=\"website\" />\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Dev Server with Allowed Hosts Option (Bash)\nDESCRIPTION: This bash command runs the RedwoodJS development server with the '--allowed-hosts all' flag forwarded via yarn. This option enables the dev server to accept HTTP requests from any host (not just localhost), which is necessary when exposing your server to the internet via tools like ngrok. The command assumes a 'package.json' script called 'dev'. Output: the Redwood app listens externally on configured ports.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cors.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nrw > yarn dev --fwd=\"--allowed-hosts all\"\n```\n\n----------------------------------------\n\nTITLE: Passing Options to useForm for onBlur Validation (TypeScript)\nDESCRIPTION: Calls useForm with a configuration argument ({ mode: 'onBlur' }) to synchronize validation timing with form requirements in TypeScript. Essential when manually invoking useForm, as Redwood will not handle options automatically. The option ensures form validation occurs as expected on field blur.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_41\n\nLANGUAGE: tsx\nCODE:\n```\nconst ContactPage = () => {\n  const formMethods = useForm({ mode: 'onBlur' })\n  //...\n\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Project Types (Bash)\nDESCRIPTION: This command triggers the generation of various type definition files (`.d.ts`) and other supplementary code within the `.redwood` directory and other parts of the project (like `api/types` and `web/types`). These types enhance developer experience, particularly in TypeScript projects, by providing type safety for routes, GraphQL operations, Cells, context, etc.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_89\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate types\n```\n\n----------------------------------------\n\nTITLE: Configuration Object for GraphQL Query Cost Limiting (GraphQL Armor, TypeScript)\nDESCRIPTION: Shows a configuration object for the costLimit plugin in GraphQL Armor, setting limits for object and scalar field costs, maximum cumulative cost, and depth cost multiplier. To be supplied via the armorConfig parameter in createGraphQLHandler. Adjust values to tune allowed query complexity and cost tolerance. Primarily for GraphQL server configuration, not execution.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_66\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  costLimit: {\n    enabled: true,\n    maxCost: 5000, // maximum cost of a request before it is rejected\n    objectCost: 2, // cost of retrieving an object\n    scalarCost: 1, // cost of retrieving a scalar\n    depthCostFactor: 1.5, // multiplicative cost of depth\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing RedwoodRecord Configuration (Bash)\nDESCRIPTION: Runs the `record init` command using the Redwood CLI alias `rw`. This experimental command parses the `schema.prisma` file, caches the data model as JSON, reads model relationships, and adds related configuration to `api/src/models/index.js`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_106\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw record init\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS dbAuth Authentication Scaffolding (Bash)\nDESCRIPTION: This command uses the Yarn package manager to execute the RedwoodJS CLI (`rw`) command for generating (`g`) the database authentication (`dbAuth`) scaffolding. Running this command creates several files, including pages and components for login, signup, and forgot password flows within the RedwoodJS application. It typically prompts for configuration choices during execution.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g dbAuth\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Addition Function in JavaScript\nDESCRIPTION: This snippet defines a basic JavaScript arrow function named `add` that takes two arguments, `a` and `b`, and returns their sum. It serves as the initial 'unit' of code to be tested in the subsequent examples.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst add = (a, b) => {\n  return a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Copying Build Artifacts and Prisma Client from api_build Stage - RedwoodJS - Dockerfile\nDESCRIPTION: This Dockerfile snippet copies configuration and environment files, then securely copies the built API server distribution, database, and compiled Prisma client artifacts from the api_build stage. This leverages Docker multi-stage builds for image minimization, transferring only production-ready assets. It assumes that api_build stage has already produced the necessary files and preserves proper file ownership in the container.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_11\n\nLANGUAGE: Dockerfile\nCODE:\n```\nCOPY --chown=node:node redwood.toml .\\nCOPY --chown=node:node graphql.config.js .\\nCOPY --chown=node:node .env.defaults .env.defaults\\n\\nCOPY --chown=node:node --from=api_build /home/node/app/api/dist /home/node/app/api/dist\\nCOPY --chown=node:node --from=api_build /home/node/app/api/db /home/node/app/api/db\\nCOPY --chown=node:node --from=api_build /home/node/app/node_modules/.prisma /home/node/app/node_modules/.prisma\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Mailer Test Mode in TypeScript\nDESCRIPTION: Defines configuration options within `api/src/lib/mailer.ts` to control the RedwoodJS Mailer's test mode. The `when` property, which can be a boolean or a function returning a boolean, determines if test mode activates (typically based on `process.env.NODE_ENV === 'test'`). The `handler` property specifies a custom handler to use during testing, overriding the default behavior which looks for `@redwoodjs/mailer-handler-in-memory`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/mailer.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=api/src/lib/mailer.ts\ntest: {\n  when: process.env.NODE_ENV === 'test',\n  handler: 'someOtherHandler',\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Redwood Prisma Scenario Data with defineScenario - JavaScript\nDESCRIPTION: Illustrates basic scenario data definition for the comments model using RedwoodJS's defineScenario helper in JavaScript. This scenario seeds the test database with two comment entries, each referencing a post created inline. Used for initializing the database state before running tests. Dependencies: RedwoodJS services, Prisma, defineScenario utility. Key parameters: static string values for name/body/post, no id/createdAt as defaults are auto-assigned. Inputs: none—exports scenario data; Outputs: scenario data consumable by RedwoodJS tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = defineScenario({\\n  comment: {\\n    one: {\\n      data: {\\n        name: 'String',\\n        body: 'String',\\n        post: { create: { title: 'String', body: 'String' } },\\n      },\\n    },\\n    two: {\\n      data: {\\n        name: 'String',\\n        body: 'String',\\n        post: { create: { title: 'String', body: 'String' } },\\n      },\\n    },\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Using React Testing Library renderHook with RedwoodJS MockProviders in JSX\nDESCRIPTION: This example demonstrates how to use the standard `renderHook` function from React Testing Library within a RedwoodJS application context. It requires explicitly wrapping the hook call with Redwood's `MockProviders` and any other necessary custom providers (`MyCustomProvider`) using the `wrapper` option to ensure the hook has access to required contexts like auth, GraphQL client, and router mocks.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_31\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx\nimport { renderHook, MockProviders } from '@redwoodjs/testing/web'\n\n// ...\n\nrenderHook(() => myCustomHook(), {\n  wrapper: ({ children }) => (\n    <MockProviders>\n      <MyCustomProvider>{children}</MyCustomProvider>\n    </MockProviders>\n  )\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing Page Head with \\u003cHead\\u003e Component - JSX\nDESCRIPTION: This snippet shows how to use RedwoodJS's built-in <Head> component to set the page title and add elements to the HTML <head> on a per-page basis in a React/JSX file. It demonstrates importing the Head component and using it within a page component to override the default title. Requires '@redwoodjs/web' and React; inputs are child nodes for <Head>; output is injected head tags for that page only.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n+import { Head } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <div>\n      <h2>AboutPage</h2>\n+     <Head>\n+       <title>About the team</title>\n+     </Head>\n\n```\n\n----------------------------------------\n\nTITLE: Retrieve Current Route Name and URL - useRouteName and routes - RedwoodJS React Hook - JavaScript/JSX\nDESCRIPTION: Demonstrates the use of the useRouteName() hook to obtain the name of the current route and then dynamically access its URL via the global routes object. Useful when conditional logic or dynamic navigation is based on the current active page. Outputs the current route's URL or undefined.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_26\n\nLANGUAGE: jsx\nCODE:\n```\nconst routeName = useRouteName()\nconst routeUrl = routeName ? routes[routeName]() : undefined\n```\n\n----------------------------------------\n\nTITLE: Integrating Article Component into ArticleCell (TSX)\nDESCRIPTION: Modifies the 'ArticleCell' TypeScript component's (`web/src/components/ArticleCell/ArticleCell.tsx`) `Success` state. It imports the reusable 'Article' component and renders it directly, passing the single fetched 'article' data (typed via `CellSuccessProps` and `FindArticleQuery`) as a prop. This leverages the reusable component for displaying a single article detail.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_32\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { FindArticleQuery, FindArticleQueryVariables } from 'types/graphql'\n\nimport type {\n  CellFailureProps,\n  CellSuccessProps,\n  TypedDocumentNode,\n} from '@redwoodjs/web'\n\n// highlight-next-line\nimport Article from 'src/components/Article'\n\nexport const QUERY: TypedDocumentNode<\n  FindArticleQuery,\n  FindArticleQueryVariables\n> = gql`\n  query FindArticleQuery($id: Int!) {\n    article: post(id: $id) {\n      id\n      title\n      body\n      createdAt\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({\n  error,\n}: CellFailureProps<FindArticleQueryVariables>) => (\n  <div style={{ color: 'red' }}>Error: {error.message}</div>\n)\n\nexport const Success = ({\n  article,\n}: CellSuccessProps<FindArticleQuery, FindArticleQueryVariables>) => {\n  // highlight-next-line\n  return <Article article={article} />\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with `positive` Option in JSX\nDESCRIPTION: Demonstrates the `numericality` validator using the `positive` option set to `true` to ensure the input number is greater than 0.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_39\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.balance, 'Balance', {\n  numericality: { positive: true },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Disabling Submit Button During Mutation Loading in JSX\nDESCRIPTION: This JSX snippet demonstrates how to disable the RedwoodJS `Submit` button while a mutation is in progress. The `disabled` prop of the `Submit` component is bound to the `loading` state variable obtained from the `useMutation` hook, preventing multiple submissions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nreturn (\n  // ...\n  // highlight-next-line\n  <Submit disabled={loading}>Save</Submit>\n  // ...\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Renamed Comments Service Test to reflect post-specific query - TypeScript\nDESCRIPTION: This TypeScript test changes the scenario description to clarify that it checks only comments for a particular post, helping ensure test accuracy. The body verifies through Prisma that the number of comments returned matches the count in the database for the provided postId. Utilizes type StandardScenario for strict typing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_33\n\nLANGUAGE: JavaScript\nCODE:\n```\n// highlight-start\\nscenario(\\n  'returns all comments for a single post from the database',\\n  // highlight-end\\n  async (scenario: StandardScenario) => {\\n    const result = await comments({ postId: scenario.comment.jane.postId })\\n    const post = await db.post.findUnique({\\n      where: { id: scenario.comment.jane.postId },\\n      include: { comments: true },\\n    })\\n    expect(result.length).toEqual(post.comments.length)\\n  }\\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Sentry User Identity on API - JavaScript\nDESCRIPTION: This snippet illustrates associating API-side Sentry events with a specific user by calling Sentry.setUser within the getCurrentUser function. Requires the Sentry library import ('src/lib/sentry') and access to a user object (typically from Prisma). The function expects the database to return a user; that user is passed to Sentry, enriching error and performance reports with user context. Place this logic in 'api/src/lib/auth.js'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/monitoring/sentry.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport Sentry from 'src/lib/sentry'\n\nexport const getCurrentUser = async (...) => {\n  const user = await db.user.findUnique(...)\n\n  Sentry.setUser(user)\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Data Using Apollo Client Hook in React (JavaScript/JSX)\nDESCRIPTION: This snippet demonstrates manual data fetching in a React component using Redwood's useApolloClient hook. The client.query method executes a GraphQL query. Requires Apollo Client and the gql function; 'query' property expects a valid GraphQL query. Inputs: GraphQL query; Outputs: Promise resolving with the query result. Useful for one-off or custom queries outside of Cell logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n// In a react component...\n\nclient = useApolloClient()\n\nclient.query({\n  query: gql`\n    ...\n  `,\n})\n```\n\n----------------------------------------\n\nTITLE: Using the Absence Validator with a Custom Message in JSX\nDESCRIPTION: Shows how to provide a custom error message for the `absence` validator. The message is specified using the `message` property within the nested `absence` object in the validation configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.value, {\n  absence: { message: 'Value must be absent' },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Building for Netlify without Data Migration (Example)\nDESCRIPTION: An example showing how to use the Netlify deploy command to build the project and apply Prisma database migrations, but explicitly skip the data migration step using the `--no-data-migrate` flag.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood deploy netlify --no-data-migrate\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with `otherThan` Option in JSX\nDESCRIPTION: Demonstrates the `numericality` validator using the `otherThan` option to require the input number to be any value *except* the specified value.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_36\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.floor, 'Floor', {\n  numericality: { otherThan: 13 },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Configuring onBlur Validation for RedwoodJS Form (JSX)\nDESCRIPTION: Shows how to configure a RedwoodJS `Form` component in JSX to trigger validation when a user navigates away from a field (onBlur event). This is achieved by adding the `config` prop to the `Form` component and setting its value to `{ mode: 'onBlur' }`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_32\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\n<Form onSubmit={onSubmit} config={{ mode: 'onBlur' }}>\n```\n```\n\n----------------------------------------\n\nTITLE: Installing PostgreSQL with Homebrew on Mac (Bash)\nDESCRIPTION: This Bash snippet installs PostgreSQL version 14 using Homebrew on macOS. Requires Homebrew to be installed. Ensures a recent version of Postgres is available locally for development purposes. No parameters required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install postgresql@14\n```\n\n----------------------------------------\n\nTITLE: Testing Auction Live Query and Bid Mutation - TypeScript\nDESCRIPTION: Shows how to test live queries and mutating bids in RedwoodJS with GraphQL Playground via a multiline TypeScript comment. First code subscribes to live query updates; the second posts new bids. Supports manual or automated integration testing. Provides parameterization for auction ID and bid amount.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * To test this live query, run the following in the GraphQL Playground:\n *\n * query GetCurrentAuctionBids @live {\n *  auction(id: \"1\") {\n *    bids {\n *      amount\n *    }\n *    highestBid {\n *      amount\n *    }\n *    id\n *    title\n *   }\n * }\n *\n * And then make a bid with the following mutation:\n *\n * mutation MakeBid {\n *   bid(input: {auctionId: \"1\", amount: 10}) {\n *     amount\n *   }\n * }\n */\n```\n\n----------------------------------------\n\nTITLE: Setting HTTP Status Code in Mock Response using ctx.status in JSX\nDESCRIPTION: Demonstrates using the `ctx.status()` method within a mock function handler to set the HTTP status code of the mocked GraphQL response. In this case, it sets the status to 404 Not Found.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/mocking-graphql-requests.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nmockGraphQLQuery('OperationName', (_variables, { ctx }) => {\n  ctx.status(404)\n})\n```\n\n----------------------------------------\n\nTITLE: Generated Boilerplate Cell Query Structure - JavaScript (React JSX)\nDESCRIPTION: This code shows the default structure of a GraphQL query in a generated RedwoodJS Cell for JavaScript/JSX. The query fetches 'articles' with only an 'id' field by default, and serves as the starting point before any necessary customization. Requires RedwoodJS setup, and is part of the /ArticlesCell component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\\n  query ArticlesQuery {\\n    // highlight-next-line\\n    articles {\\n      id\\n    }\\n  }\\n`\\n\n```\n\n----------------------------------------\n\nTITLE: Using the Inclusion Validator with `in` Option in JSX\nDESCRIPTION: Demonstrates the `inclusion` validator using the nested object syntax with the `in` option. This explicitly defines the list of allowed values. The `caseSensitive` option (defaulting to `true`) can also be set here.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.role, 'Role', {\n  inclusion: { in: ['Guest', 'Member', 'Manager'] },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Deploying RedwoodJS Application to Baremetal Environment with Yarn (Bash)\nDESCRIPTION: Executes a baremetal deployment for a given environment using the RedwoodJS CLI via Yarn. The '--first-run' flag is used for an initial deployment, while specifying the environment (e.g., 'staging' or 'production') triggers corresponding configuration. This command requires dependencies: Yarn, a valid RedwoodJS setup, network access to the servers defined in deploy.toml, and necessary credentials.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy baremetal staging\n\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy baremetal production --first-run\n\n```\n\n----------------------------------------\n\nTITLE: Disabling User Signup with dbAuth Config - JavaScript\nDESCRIPTION: Illustrates setting the signup.enabled property to false in dbAuth's configuration to prevent new user registrations. This change disables the signup endpoint, blocking the user creation flow until explicitly re-enabled. Should be set inside the dbAuth config object in the API function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nsignup: {\n  enabled: false\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Global Toaster for Notifications in RedwoodJS Layout (JavaScript)\nDESCRIPTION: Injects the Toaster component from react-hot-toast into the root layout file, ensuring toast notifications are globally available throughout the app. Used so that notifications triggered by CommentForm or other components are visible, regardless of which page or component is rendered. Dependencies: @redwoodjs/web/toast. Callers must ensure Toaster is only rendered once (typically in a top-level layout like BlogLayout).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\n// highlight-next-line\nimport { Toaster } from '@redwoodjs/web/toast'\n\nimport { useAuth } from 'src/auth'\n\nconst BlogLayout = ({ children }) => {\n  const { logOut, isAuthenticated, currentUser } = useAuth()\n\n  return (\n    <>\n      // highlight-next-line\n      <Toaster />\n      <header className=\"relative flex justify-between items-center py-4 px-8 bg-blue-700 text-white\">\n        <h1 className=\"text-5xl font-semibold tracking-tight\">\n          <Link\n            className=\"text-blue-400 hover:text-blue-100 transition duration-100\"\n            to={routes.home()}\n          >\n            Redwood Blog\n          </Link>\n        </h1>\n        <nav>\n          <ul className=\"relative flex items-center font-light\">\n            <li>\n              <Link\n```\n\n----------------------------------------\n\nTITLE: Configuring ESLint for Automatic Service Type Annotation (JSON/diff)\nDESCRIPTION: This diff shows how to modify the `eslintConfig` in `package.json` to enable an ESLint rule (`@redwoodjs/service-type-annotations`). When paired with the experimental SDL code generator, this rule can automatically apply the generated types to resolvers in TypeScript service files (`api/src/services/**/*.ts`) upon linting with auto-fix enabled.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/generated-types.md#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\n   \"eslintConfig\": {\n     \"extends\": \"@redwoodjs/eslint-config\",\n     \"root\": true,\n     \"parserOptions\": {\n       \"warnOnUnsupportedTypeScriptVersion\": false\n     },\n+    \"overrides\": [\n+      {\n+        \"files\": [\n+          \"api/src/services/**/*.ts\"\n+        ],\n+        \"rules\": {\n+          \"@redwoodjs/service-type-annotations\": \"error\"\n+        }\n+      }\n     ]\n   },\n```\n\n----------------------------------------\n\nTITLE: Setting Cookie Domain for Cross-Domain Authentication in JavaScript\nDESCRIPTION: Provides an example configuration within `api/src/functions/auth.js` demonstrating how to explicitly set the `Domain` attribute for the session cookie. This is crucial when the API and web front-end reside on different subdomains (e.g., `api.example.com` and `example.com`) to ensure the cookie is accessible to both. The `Secure` attribute is conditionally set based on the `NODE_ENV` environment variable.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\n// title=\"api/src/functions/auth.js\"\ncookie: {\n  attributes: {\n    HttpOnly: true,\n    Path: '/',\n    SameSite: 'Lax',\n    Secure: process.env.NODE_ENV !== 'development' ? true : false,\n    // highlight-next-line\n    Domain: 'example.com'\n  },\n  // name: 'session_%port%'\n}\n```\n\n----------------------------------------\n\nTITLE: Hashing Schema Columns for Cache Keys in Node.js (JavaScript)\nDESCRIPTION: This snippet generates a cache key by hashing the names of all columns of a product database object, ensuring that schema changes are reflected in the cache key. It uses 'Object.keys' to list all fields, applies MD5 hashing (from 'blueimp-md5'), and integrates the hash into a versioned cache key string. Dependencies: a database access function 'db.product.findUnique', the 'md5' library, and inclusion of id and updatedAt for uniqueness. This approach makes the cache automatically expire if the table schema changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_61\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst product = db.product.findUnique({ where: { id } })\nconst columns = Object.keys(product) // ['id', 'name', 'sku', ...]\nconst hash = md5(columns.join(',')) // \"e4d7f1b4ed2e42d15898f4b27b019da4\"\n\ncache(`v1-product-${hash}-${id}-${updatedAt}`, () => {\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Pulling Database Schema into Prisma Schema (Bash)\nDESCRIPTION: Uses the `db pull` command (formerly `introspect`) to connect to the existing database and update the `api/db/schema.prisma` file to reflect the current database structure. Warning: This overwrites the existing schema file, potentially losing manual changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_97\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood prisma db pull\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite with RedwoodJS Plugin - JavaScript\nDESCRIPTION: This code snippet demonstrates how to configure Vite in a RedwoodJS project by importing the Redwood Vite plugin and defining custom plugins and options. The code uses Node.js's DNS module to set the default result order and then exports the finalized Vite configuration using `defineConfig`. Required dependencies include Node.js, Vite, and the `@redwoodjs/vite` package. Inputs to the config object include any additional plugins or overrides for Vite's built-in options. The output is a properly configured Vite instance for use in the RedwoodJS web side.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/vite-configuration.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport dns from 'dns'\nimport { defineConfig } from 'vite'\nimport redwood from '@redwoodjs/vite'\n\ndns.setDefaultResultOrder('verbatim')\n\nconst viteConfig = {\n  plugins: [\n    // 👉 this is the RedwoodJS Vite plugin, that houses all the default configuration\n    redwood(),\n    // ... add any custom Vite plugins you would like here\n  ],\n  // You can override built in configuration like server, optimizeDeps, etc. here\n}\nexport default defineConfig(viteConfig)\n```\n\n----------------------------------------\n\nTITLE: Implementing a RedwoodJS Page Component Using a Cell (JavaScript/JSX)\nDESCRIPTION: This snippet shows a RedwoodJS Page component (`ProductPage`) that renders a Cell (`ProductsCell`). It passes a `status` prop down to the Cell, which will be used as a variable in the Cell's GraphQL query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_41\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ProductPage/ProductPage.js\"\nimport ProductCell from 'src/components/ProductCell'\n\nconst ProductPage = ({ status }) => {\n  return {\n    <div>\n      <h1>{ status === 'instock' ? 'In Stock' : 'Out of Stock' }</h1>\n      <ProductsCell status={status} />\n    </div>\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Sync Example: Changing Directory and Running rwfw Sync - Shell\nDESCRIPTION: This snippet combines changing into the Redwood test project directory with syncing the local framework using rwfw and the RWFW_PATH env var. The usage example is particularly useful when running step-by-step CLI commands while integrating a local framework for project development. Make sure to replace '~/redwood' with the path to your local framework clone.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/contributing-walkthrough.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ncd redwood-project\nRWFW_PATH=~/redwood yarn rwfw project:sync\n```\n\n----------------------------------------\n\nTITLE: Testing createComment() with Scenario Data - RedwoodJS (JavaScript)\nDESCRIPTION: Implements a test suite for the comments service in RedwoodJS, specifically focusing on the createComment() function using the postOnly scenario. Tests that a comment can be created and all expected fields are properly set in the database, verifying linkage by post ID and correct field values. Requires scenario loader and database access, and is intended for API-side integration testing. Scenario argument is passed by name and resolves real DB entries for test input.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_30\n\nLANGUAGE: javascript\nCODE:\n```\n// highlight-next-line\nimport { comments, createComment } from './comments'\n\ndescribe('comments', () => {\n  scenario('returns all comments', async (scenario) => {\n    const result = await comments()\n\n    expect(result.length).toEqual(Object.keys(scenario.comment).length)\n  })\n\n  // highlight-start\n  scenario('postOnly', 'creates a new comment', async (scenario) => {\n    const comment = await createComment({\n      input: {\n        name: 'Billy Bob',\n        body: 'What is your favorite tree bark?',\n        post: {\n          connect: { id: scenario.post.bark.id },\n        },\n      },\n    })\n\n    expect(comment.name).toEqual('Billy Bob')\n    expect(comment.body).toEqual('What is your favorite tree bark?')\n    expect(comment.postId).toEqual(scenario.post.bark.id)\n    expect(comment.createdAt).not.toEqual(null)\n  })\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a User with Hashed Password in RedwoodJS Console - JavaScript\nDESCRIPTION: This snippet demonstrates how to manually create a new user from the RedwoodJS console by hashing a password with CryptoJS and PBKDF2, generating a unique salt, and inserting the user into the database. Dependencies required include the 'crypto-js' library for password hashing and the 'db' object representing the database ORM. Key parameters include the plaintext password, salt, email, and hashedPassword; the expected input is your chosen password and email, and the function outputs a new User record in the database with securely stored credentials. This snippet should be run within the RedwoodJS console with access to the 'db' and 'crypto-js' modules.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst CryptoJS = require('crypto-js')\\nconst salt = CryptoJS.lib.WordArray.random(128 / 8).toString()\\nconst hashedPassword = CryptoJS.PBKDF2('password', salt, {\\n  keySize: 256 / 32,\\n}).toString()\\ndb.user.create({\\n  data: { email: 'moderator@moderator.com', hashedPassword, salt },\\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring SendInBlue SMTP Key in .env\nDESCRIPTION: Shows how to store the SendInBlue SMTP API key as an environment variable (`SEND_IN_BLUE_KEY`) in the `.env` file. This variable is used by the application to authenticate with the SendInBlue SMTP server. The key must be obtained from the SendInBlue dashboard.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\nSEND_IN_BLUE_KEY=xsmtpsib-7fa6eb37c244429933ea870185063c493ba1c820f826c5f620877dd815392602-rZgB6GUV1CF2NLAK\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Layout via CLI (Bash)\nDESCRIPTION: Uses the RedwoodJS CLI command `yarn redwood g layout` (short for `generate`) to create the necessary files for a new layout named 'blog'. This scaffolds `BlogLayout.{jsx,tsx}`, associated test files, and story files within the `web/src/layouts/` directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood g layout blog\n```\n\n----------------------------------------\n\nTITLE: Identifying Strict Mode Error in hasRole Function (TypeScript)\nDESCRIPTION: This TypeScript snippet highlights a potential error (ts(2339)) that can occur in the standard RedwoodJS `hasRole` authentication function when strict mode is enabled. The error arises because `context.currentUser` might not have a `roles` property, violating strict null/property checks.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport const hasRole = (roles: AllowedRoles): boolean => {\n  if (!isAuthenticated()) {\n    return false\n  }\n\n  // highlight-next-line\n  const currentUserRoles = context.currentUser?.roles\n  // Error: Property 'roles' does not exist on type '{ id: number; }'.ts(2339)\n\n```\n\n----------------------------------------\n\nTITLE: Testing Successful Webhook Order Update in RedwoodJS (TSX)\nDESCRIPTION: This TSX snippet sets up a Jest/Vitest test suite for a RedwoodJS webhook function (`updateOrderStatus`). It imports necessary testing utilities (`mockSignedWebhook`) and the handler function. The first scenario tests the successful update of an order's status to 'DELIVERED' by mocking a valid signed webhook event with the correct signature details and asserting the expected 200 status code and response body contents.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"api/src/functions/updateOrderStatus/updateOrderStatus.test.ts\"\nimport { mockSignedWebhook } from '@redwoodjs/testing/api'\nimport { handler } from './updateOrderStatus'\n\ndescribe('updates an order via a webhook', () => {\n  scenario('with a shipped order, updates the status to DELIVERED',\n            async (scenario) => {\n\n    const order = scenario.order.shipped\n\n    const payload = { trackingNumber: order.trackingNumber,\n                      status: 'DELIVERED' }\n\n    const event = mockSignedWebhook({ payload,\n                      signatureType: 'sha256Verifier',\n                      signatureHeader: 'X-Webhook-Signature',\n                      secret: 'MY-VOICE-IS-MY-PASSPORT-VERIFY-ME' })\n\n    const result = await handler(event)\n\n    const body = JSON.parse(result.body)\n\n    expect(result.statusCode).toBe(200)\n    expect(body.message).toContain(`Updated order ${order.id}`)\n    expect(body.message).toContain(`to ${payload.status}`)\n    expect(body.order.id).toEqual(order.id)\n    expect(body.order.status).toEqual(payload.status)\n  })\n```\n```\n\n----------------------------------------\n\nTITLE: Enable Maintenance Mode for Deploy - Bash\nDESCRIPTION: Activates maintenance mode for a Redwood app deployment, replacing the main frontend entry point with a maintenance page and stopping configured services. Intended for use before potentially disruptive code or database changes to temporarily block user access.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy baremetal production --maintenance up\n```\n\n----------------------------------------\n\nTITLE: Removing Unused Link from ArticlePage Boilerplate (RedwoodJS, JavaScript, diff format)\nDESCRIPTION: This diff-format snippet guides removing an outdated Link and routes import from the ArticlePage boilerplate. The adjustment resolves errors due to missing parameters now required by the route. It is essential for cleaning up the starter page after route parameterization. The snippet relies on proper React and RedwoodJS metadata components but otherwise has no runtime dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_9\n\nLANGUAGE: diff\nCODE:\n```\n- import { Link, routes } from '@redwoodjs/router'\\n  import { Metadata } from '@redwoodjs/web'\\n\\n  const ArticlePage = () => {\\n    return (\\n      <>\\n        <Metadata title=\"Article\" description=\"Article page\" />\\n\\n        <h1>ArticlePage</h1>\\n        <p>\\n          Find me in <code>./web/src/pages/ArticlePage/ArticlePage.js</code>\\n        </p>\\n        {/*\\n          My default route is named <code>article</code>, link to me with `\\n          <Link to={routes.article()}>Article</Link>`\\n        */}\\n      </>\\n    )\\n  }\\n\\n  export default ArticlePage\n```\n\n----------------------------------------\n\nTITLE: Using the Exclusion Validator (Basic) in JSX\nDESCRIPTION: Shows the basic usage of the `exclusion` validator. It requires that the input value does *not* match any of the values provided in the array (e.g., reserved names). Case sensitivity is true by default.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.name, 'Name', {\n  exclusion: ['Admin', 'Owner'],\n})\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Log Redaction List in RedwoodJS Logger\nDESCRIPTION: Illustrates how to customize the list of keys whose values should be redacted in logs. It imports the default `redactionsList` from RedwoodJS and appends a custom key (`my_secret_key`) using the spread syntax within the `redact` option of `createLogger`. Requires `@redwoodjs/api/logger`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n/**\n * Customize a redactions list to add `my_secret_key`\n */\nimport { redactionsList } from '@redwoodjs/api/logger'\n\nexport const logger = createLogger({\n  options: { redact: [...redactionsList, 'my_secret_key'] },\n})\n```\n\n----------------------------------------\n\nTITLE: Updating a Cell Query and Adjusting the Standard Mock - RedwoodJS - JavaScript (Diff Example)\nDESCRIPTION: This snippet illustrates how to update both a RedwoodJS Cell GraphQL query and its associated mock to add a new field (`name`) to the response. By using diff syntax, it highlights the requirement to synchronize mock-data shape with the query structure. Inputs are changes to the GraphQL query; output is the updated mock to match the changed API.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/mocking-graphql-in-storybook.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\nexport const QUERY = gql`\n  query UserProfileQuery {\n    userProfile {\n       id\n+       name\n    }\n  }\n`\n\n// UserProfileCell/UserProfileCell.mock.js\nexport const standard = {\n  userProfile: {\n    id: 42,\n+    name: 'peterp',\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Record In-Memory with `build()` (JavaScript/JSX)\nDESCRIPTION: JavaScript/JSX code demonstrating the use of the synchronous `build()` class method on a RedwoodRecord model (`User`) to instantiate a new record with initial attributes in memory. This record is not persisted to the database until the asynchronous `save()` method is called.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nconst user = User.build({ firstName: 'David', lastName: 'Price' })\n```\n\n----------------------------------------\n\nTITLE: Running Redwood Dev Server on Custom Port without Browser Open - Shell\nDESCRIPTION: This shell command launches the RedwoodJS development server, forwarding custom Vite flags to specify the server port as 1234 and suppress automatic browser opening. The `--forward` option passes these flags to Vite, overriding default settings in `redwood.toml` for this run. Use this to customize local server behavior temporally.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/vite-configuration.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nyarn rw dev --forward=\"--port 1234 --no-open\"\n```\n\n----------------------------------------\n\nTITLE: Importing RedwoodJS Auth0 Auth Decoder (TypeScript)\nDESCRIPTION: This code imports the authDecoder function from the @redwoodjs/auth-auth0-api package, which enables verification and decoding of Auth0 JWT tokens as part of a RedwoodJS authentication setup. Prerequisites include installing the RedwoodJS Auth0 integration. The imported authDecoder is typically passed to createGraphQLHandler to validate Authorization headers in incoming GraphQL requests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/authentication.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { authDecoder } from '@redwoodjs/auth-auth0-api'\n```\n\n----------------------------------------\n\nTITLE: Customizing Announcement Visibility with RouteAnnouncement.visuallyHidden - RedwoodJS - JavaScript/React\nDESCRIPTION: Shows the use of RouteAnnouncement with the visuallyHidden prop to make the announcement content accessible to screen readers while visually hiding it from users. This pattern is useful for cases where announcements should not disrupt the visual layout. Requires '@redwoodjs/router'. The AboutPage component renders both visible and hidden announcements. Ensure visuallyHidden is only used when parity between visual and audio presentation is not necessary.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/a11y.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { RouteAnnouncement } from '@redwoodjs/router'\n\nconst AboutPage = () => {\n  return (\n    <h1>Welcome to my site!</h1>\n    // This won't be visible\n    // highlight-start\n    <RouteAnnouncement visuallyHidden>\n      All about me\n    </RouteAnnouncement>\n    // highlight-end\n  )\n}\n\nexport default AboutPage\n```\n\n----------------------------------------\n\nTITLE: Identifying Cache IDs using useCache in TypeScript\nDESCRIPTION: Demonstrates using the `identify` method from the `useCache` hook to compute the unique cache ID for an object based on its `__typename` and identifier field(s) (e.g., `id`). This avoids needing to manually construct cache IDs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/caching.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst CacheExample = () => {\n  const { identify } = useCache()\n\n  const id = identify({ __typename: 'User', id: 1 })\n\n  console.log(id)\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Inclusion Validator (Basic) in JSX\nDESCRIPTION: Shows the basic usage of the `inclusion` validator. It requires that the input value *must* match one of the values provided in the array (e.g., allowed roles). Case sensitivity is true by default.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.role, 'Role', {\n  inclusion: ['Guest', 'Member', 'Manager'],\n})\n\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with `lessThanOrEqual` Option in JSX\nDESCRIPTION: Shows the `numericality` validator using the `lessThanOrEqual` option to require the input number to be less than or equal to the specified value.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_32\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.temp, 'Temperature', {\n  numericality: { lessThanOrEqual: 100 },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Plain Key/Value Props with \\u003cMetadata\\u003e - JSX\nDESCRIPTION: These JSX examples show how passing string props to the <Metadata> component generates corresponding <meta> tags with 'name' and 'content' attributes. Child nodes are added directly to the output. No external dependencies beyond RedwoodJS are required. Input is prop key-value pairs; output is meta tag HTML.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata description=\"Lorem ipsum dolar sit amet...\" />\n// generates\n<meta name=\"description\" content=\"Lorem ipsum dolar sit amet...\" />\n\n```\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata description=\"Lorem ipsum dolar sit amet...\">\n  <meta httpEquiv=\"refresh\" content=\"30\" />\n</Metadata>\n// generates\n<meta name=\"description\" content=\"Lorem ipsum dolar sit amet...\" />\n<meta http-equiv=\"refresh\" content=\"30\" />\n\n```\n\n----------------------------------------\n\nTITLE: Adding HTML Required Attribute for Validation to RedwoodJS Contact Form in JavaScript\nDESCRIPTION: Introduces frontend HTML validation by adding the required attribute to each field in the JavaScript contact form version. The form now prevents submission if any field is missing a value, but browser-generated error messages are not customizable. RedwoodJS core form helpers are used; no new dependencies are needed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nreturn (\n  <Form onSubmit={onSubmit}>\n    <label htmlFor=\"name\">Name</label>\n    // highlight-next-line\n    <TextField name=\"name\" required />\n\n    <label htmlFor=\"email\">Email</label>\n    // highlight-next-line\n    <TextField name=\"email\" required />\n\n    <label htmlFor=\"message\">Message</label>\n    // highlight-next-line\n    <TextAreaField name=\"message\" required />\n\n    <Submit>Save</Submit>\n  </Form>\n)\n```\n\n----------------------------------------\n\nTITLE: Generating User SDL with RedwoodJS CLI\nDESCRIPTION: Executes a RedwoodJS CLI command (`yarn rw g sdl`) to generate the GraphQL Schema Definition Language (SDL) file for the `User` model. The `--no-crud` flag prevents the automatic generation of standard CRUD (Create, Read, Update, Delete) mutations and queries, allowing for more customized definitions. This is needed if not starting from the example repo.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g sdl User --no-crud\n```\n\n----------------------------------------\n\nTITLE: Redirecting After Successful Signup Using Redwood Router in JavaScript\nDESCRIPTION: This final step integrates RedwoodJS router navigation so that on successful signup, users are automatically redirected to the signin page. It imports routes and navigate from '@redwoodjs/router' and triggers a navigation after client.signup resolves. Requires properly configured routes/signin and router. On error, the error message is still displayed inline. Input/output remains as before; success now yields a navigation side-effect.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\nimport { useAuth } from '@redwoodjs/auth'\nimport { routes, navigate } from '@redwoodjs/router'\n\nconst SignupPage = () => {\n  const { client } = useAuth()\n  const [error, setError] = React.useState(null)\n\n  const onSubmit = (data) => {\n    setError(null)\n    client\n      .signup(data.email, data.password)\n      .then(() => navigate(routes.signin()))\n      .catch((error) => setError(error.message))\n  }\n\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form onSubmit={onSubmit}>\n        {error && <p>{error}</p>}\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Custom Car Submission Validation Logic - RedwoodJS - JavaScript\nDESCRIPTION: This code demonstrates adding custom validation logic to a service using the validateWith callback. It checks whether input.lastCarWashDate is at least one week ago and throws an error if it is not, ensuring only clean cars are accepted. This approach complements built-in validators for scenarios where additional checks are required. The snippet relies on the presence of input in scope and is expected to throw an Error if the date check fails. There are no required outputs except for mutation of process flow via error throwing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_29\n\nLANGUAGE: JavaScript\nCODE:\n```\nvalidateWith(() => {\n  const oneWeekAgo = new Date()\n  oneWeekAgo.setDate(oneWeekAgo.getDate() - 7)\n\n  if (input.lastCarWashDate < oneWeekAgo) {\n    throw new Error(\"We don't accept dirty cars\")\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Robots.txt User-Agent Access - Plain Text\nDESCRIPTION: Specifies robots.txt rules granting all user-agents permission to crawl every path of the website. The directive 'User-agent: *' applies to all bots, and an empty 'Disallow' means no paths are blocked. No external dependencies or prerequisites are required. Expected input and output: bots interpret this as universal access; constraints: provides no restrictions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/web/public/robots.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nUser-agent: *\nDisallow:\n```\n\n----------------------------------------\n\nTITLE: Passing Route Parameter to Link in ArticlesCell.jsx (JavaScript/JSX)\nDESCRIPTION: Updates the `Link` component within `ArticlesCell.jsx`. It now uses the named route function `routes.article()` and passes an object `{ id: article.id }` as an argument. This constructs the correct URL like `/article/1` for each article.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\ntitle=\"web/src/components/ArticlesCell/ArticlesCell.jsx\"\n<h2>\n  <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n</h2>\n```\n\n----------------------------------------\n\nTITLE: Using the Exclusion Validator with `in` Option in JSX\nDESCRIPTION: Demonstrates the `exclusion` validator using the nested object syntax with the `in` option. This explicitly defines the list of forbidden values. The `caseSensitive` option (defaulting to `true`) can also be set here.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.name, 'Name', {\n  exclusion: { in: ['Admin', 'Owner'] },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Adding Packages to RedwoodJS Workspaces using Yarn\nDESCRIPTION: Demonstrates how to add npm packages specifically to either the `web` or `api` workspace in a RedwoodJS project using `yarn workspace`. The examples show adding `marked` to the `web` side and `better-fs` to the `api` side. These commands illustrate the need to specify the target workspace due to Redwood's monorepo structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/file-structure.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace web add marked\nyarn workspace api add better-fs\n```\n\n----------------------------------------\n\nTITLE: Generated Basic Service File (JSX)\nDESCRIPTION: Example content of a `./api/src/services/users/users.js` file generated by the `generate service user` command. By default, it includes a basic function (named after the service, pluralized) that uses Prisma Client (`db`) to fetch multiple records of the corresponding model (`db.user.findMany()`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_88\n\nLANGUAGE: jsx\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const users = () => {\n  return db.user.findMany()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Contact Service Resolvers (JavaScript/TypeScript)\nDESCRIPTION: This code shows the generated service implementation for the Contact model in both JavaScript and TypeScript. It defines resolver functions (`contacts`, `contact`, `createContact`, `updateContact`, `deleteContact`) that map to the GraphQL queries and mutations defined in the SDL file. These functions use the Prisma client (`db`) imported from `src/lib/db` to interact with the database. The TypeScript version includes type annotations imported from `types/graphql`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/saving-data.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n```js title=\"api/src/services/contacts/contacts.js\"\nimport { db } from 'src/lib/db'\n\nexport const contacts = () => {\n  return db.contact.findMany()\n}\n\nexport const contact = ({ id }) => {\n  return db.contact.findUnique({\n    where: { id },\n  })\n}\n\nexport const createContact = ({ input }) => {\n  return db.contact.create({\n    data: input,\n  })\n}\n\nexport const updateContact = ({ id, input }) => {\n  return db.contact.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deleteContact = ({ id }) => {\n  return db.contact.delete({\n    where: { id },\n  })\n}\n```\n```\n\nLANGUAGE: javascript\nCODE:\n```\n```js title=\"api/src/services/contacts/contacts.ts\"\nimport type { QueryResolvers, MutationResolvers } from 'types/graphql'\n\nimport { db } from 'src/lib/db'\n\nexport const contacts: QueryResolvers['contacts'] = () => {\n  return db.contact.findMany()\n}\n\nexport const contact: QueryResolvers['contact'] = ({ id }) => {\n  return db.contact.findUnique({\n    where: { id },\n  })\n}\n\nexport const createContact: MutationResolvers['createContact'] = ({ input }) => {\n  return db.contact.create({\n    data: input,\n  })\n}\n\nexport const updateContact: MutationResolvers['updateContact'] = ({ id, input }) => {\n  return db.contact.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deleteContact: MutationResolvers['deleteContact'] = ({ id }) => {\n  return db.contact.delete({\n    where: { id },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Validating Presence with allowUndefined Option using JavaScript/JSX\nDESCRIPTION: This example demonstrates allowing undefined values to count as present during validation by setting the allowUndefined option to true. The validate function will consider empty strings and undefined as present, but null will fail. Useful for forms where uninitialized fields should not trigger errors. Assumes access to a validate() function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_44\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.value, 'Value', {\n  presence: { allowUndefined: true },\n})\n// `null` fails\n// `undefined` passes\n// \"\" passes\n\n```\n\n----------------------------------------\n\nTITLE: Logging a Nested Custom Object Payload with RedwoodJS Logger in TSX\nDESCRIPTION: Illustrates logging a more complex, nested custom object containing post title and detailed information (id, description, comments) using `logger.debug` in RedwoodJS. Requires `logger` and a `post` object with `id`, `title`, `description`, and `commentCount`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nlogger.debug(\n  {\n    custom: {\n      title: post.title,\n      details: {\n        id: post.id,\n        description: post.description,\n        comments: post.commentCount,\n      },\n    },\n  },\n  'Post details'\n)\n```\n\n----------------------------------------\n\nTITLE: Altering CreateCommentArgs Interface to Allow Unchecked Prisma Input - TypeScript\nDESCRIPTION: Demonstrates how to alter the CreateCommentArgs interface in TypeScript to accept either Prisma's CommentUncheckedCreateInput or a union of checked/unchecked input types. This enables use of direct postId assignment for comment creation, bypassing the Prisma connect syntax. Dependency: Prisma ORM. Key input is the interface definition; output is updated type safety for service argument structures.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_32\n\nLANGUAGE: ts\nCODE:\n```\ninterface CreateCommentArgs {\n  input: Prisma.CommentUncheckedCreateInput\n}\n```\n\nLANGUAGE: ts\nCODE:\n```\ninterface CreateCommentArgs {\n  input: Prisma.CommentCreateInput | Prisma.CommentUncheckedCreateInput\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Email Validator (Basic) in JSX\nDESCRIPTION: Shows the basic usage of the `email` validator. It checks if the input value matches a simple, non-strict regular expression (`/^[^@\\s]+@[^.\\s]+\\.[^\\s]+$/`) for email format. Use the `format` validator for custom regex patterns.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.email, 'Email', {\n  email: true,\n})\n\n```\n\n----------------------------------------\n\nTITLE: Starting Redwood API Server using Fastify's listen Method\nDESCRIPTION: This TypeScript snippet shows how to bypass Redwood's `start` method logic and use Fastify's native `listen` method directly. This allows explicit specification of the `host` and `port` inline, ignoring flags, environment variables, and `redwood.toml` settings for host/port.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nawait server.listen({\n  host: '0.0.0.0',\n  port: 8913,\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Divide Function Using Fixture for Missing Divisor - React/JSX/TypeScript\nDESCRIPTION: This test script imports the 'missingDivisor' fixture and passes it to the handler to verify correct error handling when the divisor is missing. It checks for a 400 status and expected message, demonstrating the benefits of using reusable test fixtures. Dependencies include the previously defined fixture and the function handler.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nimport { missingDivisor } from './divide.fixtures'\n\ndescribe('divide serverless function', () => {\n  // ... other test cases\n\n  it('requires a divisor', async () => {\n    const result = await handler(missingDivisor())\n\n    const body = result.body\n\n    expect(result.statusCode).toBe(400)\n    expect(body.message).toContain('Please specify both')\n    expect(body.quotient).toBeUndefined\n  })\n\n  // ...\n})\n\n```\n\n----------------------------------------\n\nTITLE: Generating a Serverless Function with RedwoodJS CLI - Bash\nDESCRIPTION: This snippet shows how to generate a new serverless function stub using the RedwoodJS CLI utility. The command produces scaffolded files for the handler, its test, and scenarios in the API functions directory, where <name> should be replaced with your function's name. No special prerequisites except a configured RedwoodJS project and Node environment are required. Input: function name. Output: generated serverless function boilerplate.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g function <name>\n```\n\n----------------------------------------\n\nTITLE: Querying Rendered Truncated Article Text with Testing Library (JavaScript)\nDESCRIPTION: This code locates the rendered HTML element matching the truncated body substring using screen.getByText with the exact: false option. It is used in UI tests to account for partial or truncated text matches in React components. It expects a rendered DOM containing the text.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst matchedBody = screen.getByText(truncatedBody, { exact: false })\n\n```\n\n----------------------------------------\n\nTITLE: Manually Passing Variables to Standard Mock in Cell Tests (JavaScript/JSX)\nDESCRIPTION: This test snippet shows how to explicitly pass variables when calling the `standard` mock function directly within a Cell's own test file. This is necessary if the `standard` mock function relies on variables (like `status`) that are normally passed automatically during GraphQL interception but not when calling the mock directly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_43\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx {8} title=\"web/src/components/ArticleCell/ArticleCell.test.js\"\ndescribe('ArticleCell', () => {\n  /// other tests...\n  test('Success renders successfully', async () => {\n    expect(() => {\n      render(<Success article={standard({ status: 'instock' }).article} />)\n    }).not.toThrow()\n  })\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Extracting Client IP Address from Lambda Event - JSX\nDESCRIPTION: Implements a utility function to extract the client IP address from an incoming event in a serverless function context. It checks for common locations of client IP, including custom headers and AWS Lambda's requestContext structure, defaulting to 'localhost' if none are found. This function can be integrated for whitelisting, logging, or rate limiting. Its input is an event object; its output is a string representing the resolved client IP address.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_30\n\nLANGUAGE: jsx\nCODE:\n```\nconst ipAddress = ({ event }) => {\n  return (\n    event?.headers?.['client-ip'] ||\n    event?.requestContext?.identity?.sourceIp ||\n    'localhost'\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Setting CORS Headers in GraphQL Handler - TypeScript (TSX Syntax)\nDESCRIPTION: This TypeScript (TSX) example configures CORS headers within a RedwoodJS GraphQL handler function. It demonstrates how to set the allowed origin and credentials for cross-domain requests by specifying the origin and credentials fields in the cors option. Requires RedwoodJS's createGraphQLHandler, and proper imports and declarations for logger, directives, sdls, services, and database disconnect logic. Inputs are handler options; outputs are a server with the specified CORS policy; constraints include its application within the api/src/functions/graphql.{js|ts} server file.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nexport const handler = createGraphQLHandler({\n  loggerConfig: { logger, options: {} },\n  directives,\n  sdls,\n  services,\n  cors: {\n    // 👈 setup your CORS configuration options\n    origin: '*',\n    credentials: true,\n  },\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Clearing Apollo Cache Store via useCache.clearStore (TypeScript)\nDESCRIPTION: Invokes clearStore from useCache to reset the cache contents without refetching active queries, e.g., on logout or when only local cached data should be removed. Often used to invalidate cache while maintaining network states for current queries. Should be run client-side within a RedwoodJS web component.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_37\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst Fruit = ({ id }: { id: FragmentIdentifier }) => {\n  const { clearStore } = useCache()\n\n  clearStore()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Standard and Custom Cell Mocks in RedwoodJS (JavaScript/JSX)\nDESCRIPTION: This snippet demonstrates defining multiple mocks within a `.mocks.js` file. It includes the default `standard` function mock and an additional named export `missingBody`, which is a plain object mock. This allows testing different data states, like an article missing its body content.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_38\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticleCell.mocks.js\"\nexport const standard = () => ({\n  article: {\n    __typename: 'Article',\n    id: 1,\n    title: 'Foobar',\n    body: 'Lorem ipsum...',\n  },\n})\n\nexport const missingBody = {\n  article: {\n    __typename: 'Article',\n    id: 2,\n    title: 'Barbaz',\n    body: null,\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Updating TypeScript Comments Service Test with postId\nDESCRIPTION: Updates a Jest test scenario in TypeScript for the comments service. It modifies the call to the `comments` function to pass the `postId` argument, obtained from the typed `StandardScenario` data. This aligns the test with the requirement to fetch comments for a specific post.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"api/src/services/comments/comments.test.ts\"\nscenario('returns all comments', async (scenario: StandardScenario) => {\n  // highlight-next-line\n  const result = await comments({ postId: scenario.comment.jane.postId })\n  expect(result.length).toEqual(Object.keys(scenario.comment).length)\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling GraphQL Fragments in redwood.toml - TOML\nDESCRIPTION: Modifies the redwood.toml configuration file to enable code generation for GraphQL fragments. Setting 'fragments = true' under the [graphql] section instructs RedwoodJS tooling to include fragment-related types and possibleTypes generation for Apollo cache. Required for automated possibleTypes imports.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/fragments.md#_snippet_12\n\nLANGUAGE: toml\nCODE:\n```\n[graphql]\\n  fragments = true\\n\n```\n\n----------------------------------------\n\nTITLE: Adding onSubmit Handler to Signup Form (JSX)\nDESCRIPTION: This snippet enhances the `SignupPage` component by adding an `onSubmit` function stub. This function receives the form data (`data`) as an argument when the form is submitted. The `onSubmit` function is passed as a prop to the `<Form>` component to handle form submissions. The function body is initially a placeholder comment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n// ...\n\nconst SignupPage = () => {\n  const onSubmit = (data) => {\n    // do something here\n  }\n\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form onSubmit={onSubmit}>\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\n\n//...\n```\n\n----------------------------------------\n\nTITLE: First-Time Application Deployment - RedwoodJS - Bash\nDESCRIPTION: This command deploys a RedwoodJS app to AWS via the Serverless provider, using the special `--first-run` flag required for initial setup. It orchestrates deploying the API, collects the deployed API_URL, and updates production environment variable files. Requires prior setup and valid AWS credentials. Outputs deployed API and web URLs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/serverless.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy serverless --first-run\n```\n\n----------------------------------------\n\nTITLE: Updating User Roles Directly in Redwood Console - Bash\nDESCRIPTION: Executes a direct Prisma client update to set the roles for a specific user in the RedwoodJS console. Requires knowledge of the user's id and the new role string. Used for administrative updates/managing individual users during development or migration testing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n> db.user.update({ where: { id: 1 } , data: { roles: 'admin' } })\n```\n\n----------------------------------------\n\nTITLE: Rendering a Basic Comment Component - RedwoodJS JavaScript\nDESCRIPTION: This snippet defines a simple Comment component in JavaScript for RedwoodJS that displays a commenter\\'s name, the date, and the body of the comment. It expects a 'comment' prop object with 'name', 'createdAt', and 'body' properties, and maps these to semantic elements. No external dependencies apart from Redwood\\'s React setup are required. The output consists of a header with the name, an ISO date/time label, and the comment\\'s text content.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/the-redwood-way.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// highlight-next-line\nconst Comment = ({ comment }) => {\n  return (\n    <div>\n      // highlight-start\n      <h2>{comment.name}</h2>\n      <time dateTime={comment.createdAt}>{comment.createdAt}</time>\n      <p>{comment.body}</p>\n      // highlight-end\n    </div>\n  )\n}\n\nexport default Comment\n```\n\n----------------------------------------\n\nTITLE: Example: Copying Page Generator Templates (Bash)\nDESCRIPTION: An example usage of the `setup generator` command using the Redwood CLI alias `rw`. This specific command copies the templates for the `page` generator (page, storybook, test) to the `web/generators/page` directory, enabling customization of generated pages.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_111\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup generator page\n```\n\n----------------------------------------\n\nTITLE: Signing In with Password using Supabase JS SDK (TypeScript)\nDESCRIPTION: Illustrates the standard method for signing in with email and password using the native Supabase JavaScript SDK's `auth.signInWithPassword` function. This is provided for reference comparison with the RedwoodJS approach.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data, error } = await supabase.auth.signInWithPassword({\n  email: 'example@email.com',\n  password: 'example-password',\n})\n```\n\n----------------------------------------\n\nTITLE: Applying Database Migration with Prisma Migrate - Bash\nDESCRIPTION: This snippet runs the Prisma migration command in a Yarn-based Node.js project to apply schema changes defined in schema.prisma files. The command yarn rw prisma migrate dev triggers the Prisma migration workflow, which generates SQL migration files and updates the connected SQLite database. Prerequisites include a valid Prisma schema, Yarn, RedwoodJS CLI (rw), and proper environment variable configuration. Its single optional parameter is a migration name prompt during execution; output includes new migration files and updated database schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Rendering Multiple KPI Cards in a Grid (tsx)\nDESCRIPTION: This snippet maps through the kpis array, creating a Col with a KpiCard for each KPI entry. Used inside a Tremor Grid, it produces a responsive row of stat cards. Key prop ensures each card is uniquely identified.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\n{\n  kpis.map((kpi, i) => (\n    <Col key={i} numColSpan={1}>\n      <KpiCard kpi={kpi} />\n    </Col>\n  ))\n}\n```\n\n----------------------------------------\n\nTITLE: Styling FieldError Component with className (TypeScript)\nDESCRIPTION: Demonstrates how to apply CSS styling to the `<FieldError>` component in a RedwoodJS TypeScript form using the `className` prop. This example adds `className=\"error\"` to each `<FieldError>`, which applies styles defined by the `.error` CSS class to the error messages for better visual indication.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_24\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"name\" className=\"error\" />\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"email\" className=\"error\" />\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"message\" className=\"error\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Base Styles for Redwood App - CSS\nDESCRIPTION: Defines a base stylesheet for a Redwood application to provide consistent typography, layout, and form styling. The stylesheet sets body font-family, removes default list styles, standardizes form control appearance, and highlights error states. Designed for 'web/src/index.css', requires no dependencies, and applies globally as long as imported at the application entry.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/first-page.md#_snippet_4\n\nLANGUAGE: css\nCODE:\n```\nbody {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica,\n    Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';\n}\nul {\n  list-style-type: none;\n  margin: 1rem 0;\n  padding: 0;\n}\nli {\n  display: inline-block;\n  margin: 0 1rem 0 0;\n}\nh1 > a {\n  text-decoration: none;\n  color: black;\n}\nbutton,\ninput,\nlabel,\ntextarea {\n  display: block;\n  outline: none;\n}\nlabel {\n  margin-top: 1rem;\n}\n.error {\n  color: red;\n}\ninput.error,\ntextarea.error {\n  border: 1px solid red;\n}\n.form-error {\n  color: red;\n  background-color: lavenderblush;\n  padding: 1rem;\n  display: inline-block;\n}\n.form-error ul {\n  list-style-type: disc;\n  margin: 1rem;\n  padding: 1rem;\n}\n.form-error li {\n  display: list-item;\n}\n.flex-between {\n  display: flex;\n  justify-content: space-between;\n}\n.flex-between button {\n  display: inline;\n}\n```\n\n----------------------------------------\n\nTITLE: Using postId Prop in CommentForm Submission (JavaScript)\nDESCRIPTION: This JSX snippet modifies the `CommentForm` component to accept the `postId` prop. It then includes this `postId` in the `input` object passed to the `createComment` mutation within the `onSubmit` handler. This ensures the backend receives the necessary post association.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/CommentForm/CommentForm.jsx\"\n// highlight-next-line\nconst CommentForm = ({ postId }) => {\n  const [createComment, { loading, error }] = useMutation(CREATE)\n\n  const onSubmit = (input) => {\n    // highlight-next-line\n    createComment({ variables: { input: { postId, ...input } } })\n  }\n\n  return (\n    //...\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Running RedwoodJS Tests via CLI\nDESCRIPTION: Uses the RedwoodJS CLI command `test` (aliased as `t`) to execute the project's test suite. This command typically runs Jest in watch mode, finding and running all `.test.js` or `.test.tsx` files within the specified RedwoodJS sides (e.g., 'web', 'api').\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/the-redwood-way.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test\n```\n\n----------------------------------------\n\nTITLE: Updating Empty State Component in CommentsCell (React/TSX)\nDESCRIPTION: Modifies the `Empty` functional component within `web/src/components/CommentsCell/CommentsCell.tsx` for a TypeScript project. Similar to the JSX version, this component is displayed by the RedwoodJS Cell when there are no comments. It returns a `div` with the text \"No comments yet\", styled using Tailwind CSS.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nexport const Empty = () => {\n  // highlight-next-line\n  return <div className=\"text-center text-gray-500\">No comments yet</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Logging the Event Object in RedwoodJS Function Handler (JavaScript)\nDESCRIPTION: Demonstrates how to inspect the `event` object within a RedwoodJS function handler (`api/src/functions/serverTime.js`) by logging it to the console. This allows developers to examine incoming request details such as HTTP method, headers, path, query parameters, and body, which is useful for debugging and implementing logic based on request properties.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nexport const handler = async (event, context) => {\n  console.log(event)\n  return {\n    statusCode: 200,\n    headers: { 'Content-Type': 'application/json ' },\n    body: JSON.stringify({ time: new Date() }),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Prisma Client Version via Child Logger (JavaScript)\nDESCRIPTION: Demonstrates how to use RedwoodJS logger's child logger to inject the Prisma Client version into every emitted log. Ensures logs are tagged with Prisma client metadata for debugging and auditing. The db object must expose _clientVersion.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_31\n\nLANGUAGE: javascript\nCODE:\n```\nlogger.child({\n  prisma: { clientVersion: db['_clientVersion'] },\n})\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages to a Chat Room Channel - TypeScript\nDESCRIPTION: Publishes a new chat message to a chat room via the context's pubSub system. Utilizes `context.pubSub.publish` with the topic 'newMessage', roomId as the channel, and message fields. Used for propaganda of new messages in RedwoodJS-based subscriptions. Inputs: roomId, sender info (`from`), and message body.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ncontext.pubSub.publish('newMessage', roomId, { from, body })\n```\n\n----------------------------------------\n\nTITLE: Preventing Code Splitting for HomePage in Routes Configuration (JSX)\nDESCRIPTION: Illustrates how to prevent dynamic code splitting for the HomePage by explicitly importing it in Routes.js in a RedwoodJS project. Uses imports from @redwoodjs/router and includes HomePage as a direct import, ensuring it is bundled and reducing load-time flash. Key dependencies: '@redwoodjs/router', imported pages; works by mapping routes and disables lazy-loading for specified pages. Input: routes setup; Output: statically bundled pages.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Router, Route } from '@redwoodjs/router'\n// We don't want HomePage to be dynamically loaded\n// highlight-next-line\nimport HomePage from 'src/pages/HomePage'\n\nconst Routes = () => {\n  return (\n    <Router>\n      <Route path=\"/\" page={HomePage} name=\"hello\" prerender />\n      <Route path=\"/about\" page={AboutPage} name=\"hello\" />\n      <Route notfound page={NotFoundPage} />\n    </Router>\n  )\n}\n\nexport default Routes\n```\n\n----------------------------------------\n\nTITLE: Upgrading Yarn to Latest Stable via Corepack - Bash\nDESCRIPTION: Upgrades Yarn to the stable channel and activates it using the 'corepack prepare yarn@stable --activate' command. This ensures compatibility with current project and RedwoodJS requirements. This command needs prior Corepack enablement, and may require elevated permissions. It fetches and activates the latest stable Yarn version system-wide.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-yarn.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncorepack prepare yarn@stable --activate\n```\n\n----------------------------------------\n\nTITLE: Defining a GraphQL Query with an Operation Name in JavaScript\nDESCRIPTION: Provides an example of a JavaScript template literal defining a GraphQL query named `FilteredQuery`. This illustrates the concept of an operation name, which can be used in logger configurations (like `excludeOperations`) to identify and filter specific GraphQL requests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_44\n\nLANGUAGE: js\nCODE:\n```\nexport const filteredQuery = `\n  query FilteredQuery {\n    me {\n      id\n      name\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Configuring Supabase Environment Variables (Bash/env)\nDESCRIPTION: Provides an example `.env` file structure located in the project root directory. It demonstrates the required environment variables: `SUPABASE_URL` (your Supabase project URL), `SUPABASE_KEY` (your Supabase project's public anon key), and `SUPABASE_JWT_SECRET` (your Supabase project's JWT secret). These values are obtained from the Supabase project settings (API section) and are crucial for connecting the Redwood application to the Supabase backend.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# .env (in your root project directory)\n\nSUPABASE_URL=https://replacewithyoursupabaseurl.supabase.co\nSUPABASE_KEY=eyJhb_replace_VCJ9.eyJy_with_your_wfQ.0Abb_anon_key_teLJs\nSUPABASE_JWT_SECRET=eyJh_replace_CJ9.eyJy_with_your_NTQwOTB9.MGNZN_JWT_secret_JgErqxj4\n```\n\n----------------------------------------\n\nTITLE: Using a Function Handler for Mock Data in JSX\nDESCRIPTION: Illustrates defining mock data using a function passed as the second argument to `mockGraphQLQuery`. This function receives `variables` and the context object `{ ctx }`, allowing dynamic response generation or side effects like delays. The example shows using `ctx.delay`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/mocking-graphql-requests.md#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nmockGraphQLQuery('OperationName', (variables, { ctx }) => {\n  ctx.delay(1500) // pause for 1.5 seconds\n  return {\n    userProfile: {\n      __typename: 'UserProfile' as const,\n      id: 42,\n      name: 'peterp',\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Testing a RedwoodJS Validator Directive (TypeScript/Jest)\nDESCRIPTION: Provides a Jest test suite for the `isSubscriber` Validator directive using RedwoodJS testing utilities (`mockRedwoodDirective`, `getDirectiveName`). The tests verify that the directive's schema (`isSubscriber.schema`) is correctly defined and that the initial stub implementation throws the expected 'Implementation missing' error when executed via `mockRedwoodDirective`. These tests serve as a starting point and need updates as the directive logic is implemented.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_27\n\nLANGUAGE: tsx\nCODE:\n```\nimport { mockRedwoodDirective, getDirectiveName } from '@redwoodjs/testing/api'\n\nimport isSubscriber from './isSubscriber'\n\ndescribe('isSubscriber directive', () => {\n  it('declares the directive sdl as schema, with the correct name', () => {\n    expect(isSubscriber.schema).toBeTruthy()\n    expect(getDirectiveName(isSubscriber.schema)).toBe('isSubscriber')\n  })\n\n  it('has a isSubscriber throws an error if validation does not pass', () => {\n    const mockExecution = mockRedwoodDirective(isSubscriber, {})\n\n    expect(mockExecution).toThrowError(\n      'Implementation missing for isSubscriber'\n    )\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Updating Test for Empty State Component in CommentsCell (Jest/JSX)\nDESCRIPTION: Updates the Jest test case within `web/src/components/CommentsCell/CommentsCell.test.jsx` for the `Empty` component. It uses React Testing Library's `render` function to render the component and `screen.getByText` along with `toBeInTheDocument` matcher to verify that the updated text \"No comments yet\" is correctly displayed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comments-schema.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nit('renders Empty successfully', async () => {\n  // highlight-start\n  render(<Empty />)\n  expect(screen.getByText('No comments yet')).toBeInTheDocument()\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Using the Acceptance Validator with a Custom Message in JSX\nDESCRIPTION: Illustrates how to specify a custom error message for the `acceptance` validator using the `message` property within the nested `acceptance` object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.terms, {\n  acceptance: { message: 'Please accept the Terms of Service' },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Generating a List Cell with --list Option (Bash)\nDESCRIPTION: This Bash command uses the --list flag to explicitly create a Cell for resources with indistinguishable singular or plural forms. For instance, for data types like 'equipment', it ensures a list-style Cell is generated. Dependency: RedwoodJS CLI; run this to scaffold a list Cell in the components directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw generate cell equipment --list\n```\n\n----------------------------------------\n\nTITLE: Passing Mocked Articles Explicitly as Props in Storybook (JavaScript/JSX)\nDESCRIPTION: Provides an alternative to spread syntax by explicitly accessing the 'articles' property of the mock and passing it as a prop to the Success component in a JavaScript/JSX Storybook story. This makes the prop passing clearer to those familiar with explicit assignment and ensures the component receives the correct data shape.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Success } from './ArticlesCell'\\nimport { standard } from './ArticlesCell.mock'\\n\\nexport const success = () => {\\n  // highlight-next-line\\n  return Success ? <Success articles={standard().articles} /> : null\\n}\\n\\nexport default { title: 'Cells/ArticlesCell' }\n```\n\n----------------------------------------\n\nTITLE: Generating Login Token Form Component - RedwoodJS - Bash\nDESCRIPTION: This bash command uses the RedwoodJS CLI to generate a new component named LoginPasswordlessTokenForm. The component will be placed in the appropriate directory structure and set up boilerplate for the passwordless login token form. No additional parameters are required; simply run this command from your RedwoodJS project root.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g component LoginPasswordlessTokenForm\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Honeybadger Log Transport Stream in RedwoodJS\nDESCRIPTION: Provides a complete example (`api/src/lib/logger.ts`) of creating a custom Pino transport stream for Honeybadger. It imports `Writable` from `stream`, configures the Honeybadger client, defines a `HoneybadgerStream` class to send log chunks, and configures the RedwoodJS logger using `createLogger` with this custom stream as `destination`. Requires `stream`, `@honeybadger-io/js` packages and `HONEYBADGER_API_KEY` environment variable.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createLogger } from '@redwoodjs/api/logger'\nimport { Writable } from 'stream'\n\nconst Honeybadger = require('@honeybadger-io/js')\n\nHoneybadger.configure({\n  apiKey: process.env.HONEYBADGER_API_KEY,\n})\n\nconst HoneybadgerStream = () => {\n  const stream = new Writable({\n    write(chunk: any, encoding: BufferEncoding, fnOnFlush: (error?: Error | null) => void) {\n      Honeybadger.notify(chunk.toString())\n      fnOnFlush()\n    },\n  })\n\n  return stream\n}\n\n/**\n * Creates a logger. Options define how to log. Destination defines where to log.\n * If no destination, std out.\n */\nexport const logger = createLogger({\n  options: { level: 'debug' },\n  destination: HoneybadgerStream(),\n})\n```\n\n----------------------------------------\n\nTITLE: Typing Cell Loading Props with CellLoadingProps in TypeScript\nDESCRIPTION: Shows the usage of the `CellLoadingProps` utility type for typing the props of a Cell's `Loading` component. Similar to `CellFailureProps`, it takes an optional generic (`TVariables`) for the query variables type.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport type { FindBlogPostQuery, FindBlogPostQueryVariables } from 'types/graphql'\n\n// highlight-next-line\nimport type { CellLoadingProps } from '@redwoodjs/web'\n\n// ...\n\n// highlight-next-line\nexport const Loading = (props: CellLoadingProps<FindBlogPostQueryVariables>) => (\n  <div>Loading...</div>\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Admin-Scoped GraphQL Schema with @requireAuth - JavaScript\nDESCRIPTION: This schema definition creates a new SDL for admin access, with queries and mutations guarded by @requireAuth(roles: [\"admin\"]). It supports adminPosts and adminPost queries, along with create, update, and delete Post mutations intended only for admin users. Uses RedwoodJS GraphQL SDL/gql API, shares input types with the public SDL, and depends on proper roles/auth implementation in the backend.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nexport const schema = gql`\n  type Query {\n    adminPosts: [Post!]! @requireAuth(roles: [\"admin\"])\n    adminPost(id: Int!): Post @requireAuth(roles: [\"admin\"])\n  }\n\n  input CreatePostInput {\n    title: String!\n    body: String!\n  }\n\n  input UpdatePostInput {\n    title: String\n    body: String\n  }\n\n  type Mutation {\n    createPost(input: CreatePostInput!): Post! @requireAuth(roles: [\"admin\"])\n    updatePost(id: Int!, input: UpdatePostInput!): Post!\n      @requireAuth(roles: [\"admin\"])\n    deletePost(id: Int!): Post! @requireAuth(roles: [\"admin\"])\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Cleaning up Boilerplate Code in ArticlePage.js (JavaScript/Diff)\nDESCRIPTION: Shows the removal of the unused import for `Link` and `routes`, and the commented-out boilerplate `Link` component from the generated `ArticlePage.js`. This is necessary because the boilerplate link does not include the required `id` parameter, causing an error.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_9\n\nLANGUAGE: diff\nCODE:\n```\ntitle=\"web/src/pages/ArticlePage.js\"\n- import { Link, routes } from '@redwoodjs/router'\n  import { Metadata } from '@redwoodjs/web'\n\n  const ArticlePage = () => {\n    return (\n      <>\n        <Metadata title=\"Article\" description=\"Article page\" />\n\n        <h1>ArticlePage</h1>\n        <p>\n          Find me in <code>./web/src/pages/ArticlePage/ArticlePage.js</code>\n        </p>\n        {/*\n          My default route is named <code>article</code>, link to me with `\n          <Link to={routes.article()}>Article</Link>`\n        */}\n      </>\n    )\n  }\n\n  export default ArticlePage\n```\n\n----------------------------------------\n\nTITLE: Starting PostgreSQL Service with Homebrew (Bash)\nDESCRIPTION: Starts the PostgreSQL service via Homebrew on macOS. Ensures that Postgres is running in the background as a service. Requires Homebrew and a valid Postgres installation. No parameters required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbrew services start postgresql\n```\n\n----------------------------------------\n\nTITLE: Sanitizing User Type in Users SDL (JavaScript)\nDESCRIPTION: Defines the GraphQL User type for use in the users.sdl.js file, with sensitive authentication fields commented out to ensure no sensitive data is exposed via the GraphQL API. This promotes security by limiting access to hashedPassword, salt, resetToken, and resetTokenExpiresAt via comments. To be included in an SDL file within RedwoodJS API, JavaScript version.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n  type User {\n    ...\n    # hashedPassword: String!\n    # salt: String!\n    # resetToken: String\n    # resetTokenExpiresAt: DateTime\n  }\n```\n\n----------------------------------------\n\nTITLE: Configuring Case-Insensitive Username Matching for Signup in JavaScript\nDESCRIPTION: Sets the username matching behavior for the signup process within the dbAuth configuration. By assigning `'insensitive'` to the `usernameMatch` property, dbAuth will perform case-insensitive checks when verifying if a username already exists. Support and specific implementation depend on the underlying database.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nsignup: {\n  usernameMatch: 'insensitive'\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing File Name and Path in Upload Savers - RedwoodJS TypeScript\nDESCRIPTION: Shows how to override the file name and save path when using a saver utility for file uploads. By passing an options object with the desired `fileName` and/or `path`, files can be programmatically named (e.g., per-user) or routed to specific folders. The extension supports customizing output location and file naming scheme for each upload operation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait saveFiles.forProfile(data, {\n  // highlight-next-line\n  fileName: 'profilePhoto-' + context.currentUser.id,\n})\n\n// Will save files to\n// /base_path/profilePhoto-58xx4ruv41f8eit0y25.png\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait saveFiles.forProfile(data, {\n  fileName: 'profilePhoto-' + context.currentUser.id,\n  // highlight-next-line\n  path: '/public_avatar',\n})\n\n// Will save files to\n// /public_avatar/profilePhoto-58xx4ruv41f8eit0y25.png\n```\n\n----------------------------------------\n\nTITLE: Implementing Recurring RedwoodJS Job (JavaScript)\nDESCRIPTION: Example of a self-rescheduling job (`NightlyReportJob`) to achieve recurrence before native support. The job's `perform` method executes its primary task (`DailyUsageReport.run()`) and then uses the `later` function to schedule the same `NightlyReportJob` to run again after a calculated interval (daily, using `new Date().getTime() + 86_400 * 1000`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_19\n\nLANGUAGE: js\nCODE:\n```\nimport { later, jobs } from 'src/lib/jobs'\n\nexport const NightlyReportJob = jobs.createJob({\n  queue: 'default',\n  perform: async () => {\n    await DailyUsageReport.run()\n    // highlight-start\n    await later(NightlyReportJob, [], {\n      wait: new Date(new Date().getTime() + 86_400 * 1000),\n    })\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Cyclical Nested Query Example for Depth Limiting (GraphQL, JSX Syntax with Comments)\nDESCRIPTION: Illustrates a deeply nested cyclical GraphQL query (depth 8+) to demonstrate the necessity of maxDepth protection. Comments indicate the query structure and purpose. Useful as a test case for validating depth-based protections. Query cycles between author and posts fields repeatedly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_67\n\nLANGUAGE: JSX\nCODE:\n```\n// cyclical query example\n// depth: 8+\nquery cyclical {\n  author(id: 'jules-verne') {\n    posts {\n      author {\n        posts {\n          author {\n            posts {\n              author {\n                ... {\n                  ... # more deep nesting!\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Content Type Parser in Redwood Server File\nDESCRIPTION: This TypeScript snippet illustrates how to handle non-standard content types (like images) in Fastify. Using the `configureApiServer` option, Fastify's `addContentTypeParser` method is called with a regular expression (`/^image\\/.*/`) to match image MIME types. This allows the server to accept these types, making the content available on `event.body` within Redwood functions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = await createServer({\n  logger,\n  configureApiServer(server) {\n    server.addContentTypeParser(/^image\\/.*/, (_req, payload, done) => {\n      payload.on('end', () => {\n        done()\n      })\n    })\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Customizing Request Body Size Limit in Server Configuration (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to customize the RedwoodJS API server (`api/server.js`) to increase the maximum allowed request body size. By passing a `fastifyServerOptions` object to the `createServer` function with a `bodyLimit` property set to a desired value (e.g., 500MB), developers can accommodate larger file uploads and prevent \"Payload Too Large\" errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createServer } from '@redwoodjs/api-server'\n\nimport { logger } from 'src/lib/logger'\n\nasync function main() {\n  const server = await createServer({\n    logger,\n    fastifyServerOptions: {\n      // highlight-next-line\n      bodyLimit: 1024 * 1024 * 500, // 500MB\n    },\n  })\n\n  await server.start()\n}\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Sample Nginx Configuration for Redwood-PM2 App - Nginx - Nginx\nDESCRIPTION: This Nginx server block configures the Redwood PM2 app for domains, static file serving, and API reverse-proxying. The first location serves static assets and HTML from the app's dist folder. The /api route passes requests to the local Redwood API server, forwarding headers as required by WebSockets and cache control. The trailing slash in proxy_pass is crucial for correct routing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/self-hosting-redwood.md#_snippet_4\n\nLANGUAGE: nginx\nCODE:\n```\nserver {\n  server_name redwood-pm2.example.com;\n  listen 80;\n\n  location / {\n    root /home/deploy/redwood-pm2/current/web/dist;\n    try_files $uri /index.html;\n  }\n\n  location /api/ {\n    proxy_pass http://localhost:8911/;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection 'upgrade';\n    proxy_set_header Host $host;\n    proxy_cache_bypass $http_upgrade;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Scalar with createGraphQLHandler in RedwoodJS (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import a custom scalar's definition and resolver from 'graphql-scalars', then registers them within RedwoodJS's createGraphQLHandler via the schemaOptions property. Intended for use in api/src/functions/graphql.ts, it requires both dependency packages and existing handler setup within your RedwoodJS project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_27\n\nLANGUAGE: TSX\nCODE:\n```\nimport { CurrencyDefinition, CurrencyResolver } from 'graphql-scalars'\n\n// ...\n\nexport const handler = createGraphQLHandler({\n  loggerConfig: { logger, options: {} },\n  directives,\n  sdls,\n  services,\n  schemaOptions: {\n    typeDefs: [CurrencyDefinition],\n    resolvers: { Currency: CurrencyResolver },\n  },\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Dynamic Cell Mocks Using Variables in RedwoodJS (JavaScript/JSX)\nDESCRIPTION: This `standard` mock function demonstrates accessing the `variables` argument, which is implicitly passed when the mock is used during GraphQL query interception. It uses `variables.status` to conditionally determine the `inventory` value in the returned mock data, allowing the mock to adapt based on query inputs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_40\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ProductCell/ProductCell.mock.js\"\nexport const standard = (variables) => {\n  return {\n    products: [\n      {\n        __typename: 'Product',\n        id: variables.id,\n        name: 'T-shirt',\n        inventory: variables.status === 'instock' ? 100 : 0\n      }\n    ]\n  }\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Redwood API Server in TypeScript\nDESCRIPTION: This TypeScript snippet shows the default content of `api/src/server.ts` generated by the setup command. It imports `createServer` from RedwoodJS and a logger, then defines an async `main` function that creates and starts the server instance using the imported logger.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer } from '@redwoodjs/api-server'\n\nimport { logger } from 'src/lib/logger'\n\nasync function main() {\n  const server = await createServer({\n    logger,\n  })\n\n  await server.start()\n}\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Using the Absence Validator (Basic) in JSX\nDESCRIPTION: Shows the basic usage of the `absence` validator with the `validate` function. This rule requires that the input field's value must be `null` or `undefined`. It's configured by setting `absence: true` in the validation options object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.value, 'Value', {\n  absence: true,\n})\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Firebase Environment Variables for RedwoodJS - Bash\nDESCRIPTION: This snippet shows the entries to add to the project's .env file. It records the Firebase project's apiKey, authDomain, and projectId needed for authentication. These values link the RedwoodJS app to the appropriate Firebase project. Developers should replace the ellipsis with actual values from the Firebase console; all three variables are required for auth functionality.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/firebase.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nFIREBASE_API_KEY=\"...\"\nFIREBASE_AUTH_DOMAIN=\"...\"\nFIREBASE_PROJECT_ID=\"...\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Trailing Slash Matching on Router - RedwoodJS - JSX\nDESCRIPTION: This snippet shows how to set the trailingSlashes prop on the RedwoodJS Router to control whether slashes are preserved, stripped, or enforced. Demonstrates that when using trailingSlashes='preserve', /about/ does not match /about route and will lead to the NotFoundPage. Inputs: navigation URLs, outputs: actual route matching and rendering, with notfound fallback if slashes do not match.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\n<Router trailingSlashes={'preserve'}>\n  <Route path=\"/\" page={HomePage} name=\"home\" />\n  <Route path=\"/about\" page={AboutPage} name=\"about\" />\n  <Route notfound page={NotFoundPage} />\n</Router>\n```\n\n----------------------------------------\n\nTITLE: Adding Labels to RedwoodJS Contact Form Fields in JavaScript\nDESCRIPTION: Enhances the JavaScript form to include HTML <label> elements associated with each field, improving accessibility and usability. Each field ('name', 'email', 'message') is now labeled using htmlFor. Requires no new dependencies beyond RedwoodJS form helpers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\nimport { Form, TextField, TextAreaField, Submit } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-next-line\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" />\n\n        // highlight-next-line\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" />\n\n        // highlight-next-line\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with `equal` Option in JSX\nDESCRIPTION: Shows the `numericality` validator using the `equal` option to require the input number to be exactly equal to the specified value.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_35\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.guess, 'Guess', {\n  numericality: { equal: 6 },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Defining Alphabet Stream Query Schema - GraphQL\nDESCRIPTION: GraphQL schema defining a query to return an array of alphabet letters, suitable for streaming via `@stream`. Uses `@skipAuth` for public access. No extra dependencies. For use with backend resolvers that stream data gradually.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\n  type Query {\n    alphabet: [String!]! @skipAuth\n`\n\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Access Control for Posts (TypeScript)\nDESCRIPTION: This TypeScript code defines a RedwoodJS GraphQL schema, granting unauthenticated access to the 'posts' query via @skipAuth and protecting the 'post' query and all mutations with @requireAuth. It relies on the gql tag and matches the JavaScript version, supporting robust type-checked security policies for API endpoints. Inputs/outputs follow GraphQL conventions, and this code must be placed in the RedwoodJS API side.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter4/authentication.md#_snippet_8\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\\n  type Post {\\n    id: Int!\\n    title: String!\\n    body: String!\\n    createdAt: DateTime!\\n  }\\n\\n  type Query {\\n    // highlight-next-line\\n    posts: [Post!]! @skipAuth\\n    post(id: Int!): Post @requireAuth\\n  }\\n\\n  input CreatePostInput {\\n    title: String!\\n    body: String!\\n  }\\n\\n  input UpdatePostInput {\\n    title: String\\n    body: String\\n  }\\n\\n  type Mutation {\\n    createPost(input: CreatePostInput!): Post! @requireAuth\\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\\n    deletePost(id: Int!): Post! @requireAuth\\n  }\\n`\n```\n\n----------------------------------------\n\nTITLE: Sanitizing User Type in Users SDL (TypeScript)\nDESCRIPTION: Defines the GraphQL User type for use in users.sdl.ts file (TypeScript variant), with sensitive authentication-related fields commented out for security. Ensures typesafety in TypeScript environment and prevents leakage of critical credentials through the API schema definition.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n  type User {\n    ...\n    # hashedPassword: String!\n    # salt: String!\n    # resetToken: String\n    # resetTokenExpiresAt: DateTime\n  }\n```\n\n----------------------------------------\n\nTITLE: Styling FieldError Components in RedwoodJS Form (TSX)\nDESCRIPTION: This TSX snippet enhances the typed form example by adding the `className=\"error\"` prop to each `<FieldError>` component. This enables the application of custom CSS styles (via an external `.error` class) specifically to the validation error messages when displayed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_24\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"name\" className=\"error\" />\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"email\" className=\"error\" />\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"message\" className=\"error\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Starting the Storybook Server for RedwoodJS Components\nDESCRIPTION: Runs the Storybook development server, which is integrated into the RedwoodJS project, using the `yarn rw storybook` command. Storybook allows developers to build, view, and test UI components in isolation from the main application and backend data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw storybook\n```\n\n----------------------------------------\n\nTITLE: Logging a Custom String Payload with RedwoodJS Logger in TSX\nDESCRIPTION: Demonstrates logging a simple custom string value (post title) using the `custom` key within the `logger.debug` method in a RedwoodJS application. Requires a `logger` instance and a `post` object with a `title` property.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nlogger.debug({ custom: post.title }, 'The title of a Post')\n```\n\n----------------------------------------\n\nTITLE: Listing Process Log Files in pm2 (Terminal Output)\nDESCRIPTION: Presents a sample output of a directory listing displaying various pm2 log files, which are useful for debugging application processes. These logs are located by default at '~/.pm2/logs' and are named after the process. The listing uses 'll', a common alias for detailed file listings. No dependencies beyond standard Linux filesystem tools.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_16\n\nLANGUAGE: terminal\nCODE:\n```\nubuntu@ip-123-45-67-89:~/.pm2/logs$ ll\ntotal 116\ndrwxrwxr-x 2 ubuntu ubuntu  4096 Jan 20 17:58 ./\ndrwxrwxr-x 5 ubuntu ubuntu  4096 Jan 20 17:40 ../\n-rw-rw-r-- 1 ubuntu ubuntu     0 Jan 20 17:58 api-error-0.log\n-rw-rw-r-- 1 ubuntu ubuntu     0 Jan 20 17:58 api-error-1.log\n-rw-rw-r-- 1 ubuntu ubuntu 27788 Jan 20 18:11 api-out-0.log\n-rw-rw-r-- 1 ubuntu ubuntu 21884 Jan 20 18:11 api-out-1.log\n\n```\n\n----------------------------------------\n\nTITLE: Adjusting hasRole for Array Roles in Strict Mode (Diff)\nDESCRIPTION: This diff snippet illustrates changes to the `hasRole` function in `api/src/lib/auth.ts` for strict mode compliance when `currentUser.roles` is expected to be an array of strings. It simplifies the logic by removing checks for when `currentUser.roles` might be a single string.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/strict-mode.md#_snippet_9\n\nLANGUAGE: diff\nCODE:\n```\nexport const hasRole = (roles: AllowedRoles): boolean => {\n  if (!isAuthenticated()) {\n    return false\n  }\n\n const currentUserRoles = context.currentUser?.roles\n\n  if (typeof roles === 'string') {\n-    if (typeof currentUserRoles === 'string') {\n-      return currentUserRoles === roles\n-    } else if (Array.isArray(currentUserRoles)) {\n      // roles to check is a string, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) => roles === allowedRole)\n-    }\n  }\n\n  if (Array.isArray(roles)) {\n-    if (Array.isArray(currentUserRoles)) {\n      return currentUserRoles?.some((allowedRole) =>\n        roles.includes(allowedRole)\n      )\n-    } else if (typeof currentUserRoles === 'string') {\n-      return roles.some(\n-        (allowedRole) => currentUserRoles === allowedRole\n-      )\n    }\n  }\n\n  // roles not found\n  return false\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Sass and Sass Loader Dependencies - Shell\nDESCRIPTION: This shell command installs Sass and sass-loader as development dependencies for the web workspace in a RedwoodJS project. These dependencies enable SCSS/Sass styling support in the Vite-powered frontend. No special parameters are required; simply run the command in the project root. After installation, importing `.scss` or `.sass` files in your project becomes possible.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/vite-configuration.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nyarn workspace web add -D sass sass-loader\n```\n\n----------------------------------------\n\nTITLE: Defining a Sample RedwoodJS Job - JavaScript\nDESCRIPTION: This JavaScript snippet shows a simple job definition using RedwoodJS's JobManager, with a 'perform' method that takes a 'userId' argument and logs it. It requires the jobs system to be configured in 'src/lib/jobs', and the job should be exported for use elsewhere (such as in scheduling). Input is the user ID; output is an informational log statement. No return value is required. Dependencies: '@redwoodjs/jobs' and project job manager setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { jobs } from 'src/lib/jobs'\n\nexport const SampleJob = jobs.createJob({\n  queue: 'default',\n  // highlight-start\n  perform: async (userId) => {\n    jobs.logger.info(`Received user id ${userId}`)\n  },\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Mocking CommentsCell Data for Storybook - TypeScript\nDESCRIPTION: Defines a strongly-typed Storybook mock for the CommentsCell in TypeScript. Supplies a standard list of comments with necessary fields for UI preview and development. Helps assure type correctness during UI testing using Storybook.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nexport const standard = () => ({\\n  // highlight-start\\n  comments: [\\n    {\\n      id: 1,\\n      name: 'Rob Cameron',\\n      body: 'First comment',\\n      createdAt: '2020-01-02T12:34:56Z',\\n    },\\n    {\\n      id: 2,\\n      name: 'David Price',\\n      body: 'Second comment',\\n      createdAt: '2020-02-03T23:00:00Z',\\n    },\\n  ],\\n  // highlight-end\\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Article Mocks for RedwoodJS Cells (TypeScript)\nDESCRIPTION: Implements a 'standard' mock in TypeScript for the ArticlesCell, similar to the JavaScript version. Returns an object keyed by 'articles', populated with objects imitating the expected GraphQL query response. This enables Storybook and test files to simulate realistic data without accessing the API.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = () => ({\\n  articles: [\\n    {\\n      id: 1,\\n      title: 'First Post',\\n      body: `Neutra tacos hot chicken prism raw denim...`,\\n      createdAt: '2020-01-01T12:34:56Z',\\n    },\\n    {\\n      id: 2,\\n      title: 'Second Post',\\n      body: `Master cleanse gentrify irony put a bird on it...`,\\n      createdAt: '2020-01-01T12:34:56Z',\\n    },\\n  ],\\n})\n```\n\n----------------------------------------\n\nTITLE: Invalidating Movie Mashup Live Query Key in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates invalidating an entry in a live query store using `context.liveQueryStore.invalidate`. It specifically targets a key dynamically constructed as `MovieMashup:${id}`, signaling that the data associated with this key (likely a movie mashup generated by OpenAI) has changed and needs to be updated for clients performing the live query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_23\n\nLANGUAGE: ts\nCODE:\n```\ncontext.liveQueryStore.invalidate(`MovieMashup:${id}`)\n```\n\n----------------------------------------\n\nTITLE: Default Generated RedwoodJS Function Handler Code (JavaScript)\nDESCRIPTION: This code shows the default JavaScript handler generated for a RedwoodJS Function (e.g., `user.js`). The exported `handler` function receives `event` and `context` arguments and is expected to return an object with `statusCode` and `body` properties, representing the HTTP response.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_46\n\nLANGUAGE: jsx\nCODE:\n```\n// title=\"./api/src/functions/user.js\"\nexport const handler = async (event, context) => {\n  return {\n    statusCode: 200,\n    body: `user function`,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Prisma User Model - Bash\nDESCRIPTION: After altering the Prisma schema to add fields for passwordless logins (including loginToken, loginTokenExpiresAt, and salt), this command runs a development migration so the changes take effect in the database. Requires a functional RedwoodJS project and configured Prisma schema. Accepts no parameters and applies all pending schema changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Extracting Cache Contents using useCache in TypeScript\nDESCRIPTION: Illustrates using the `extract` method from the `useCache` hook to retrieve a serialized representation of the Apollo Client cache's current contents. This is useful for debugging or inspecting the cache state.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/caching.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst CacheExample = () => {\n  const { extract } = useCache()\n\n  console.log(extract())\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Memcached/Redis Cache via Redwood CLI - Bash\nDESCRIPTION: Demonstrates the RedwoodJS CLI commands to scaffold basic cache support for Memcached or Redis. These commands create the starter file necessary for caching integration in an RW API project, generating the required client and cache initialization code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_65\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup cache memcached\\nyarn rw setup cache redis\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Mailer Handlers and Renderers in TypeScript\nDESCRIPTION: This TypeScript snippet shows the initial configuration for the RedwoodJS Mailer in `api/src/lib/mailer.ts`. It imports necessary classes, sets up a default Nodemailer handler for local development (using `localhost:4319`), a default ReactEmail renderer, and integrates the application logger. It defines handler and renderer instances within the `handling` and `rendering` objects, respectively, and specifies the default handler and renderer to use.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/mailer.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n```ts title=api/src/lib/mailer.ts\nimport { Mailer } from '@redwoodjs/mailer-core'\nimport { NodemailerMailHandler } from '@redwoodjs/mailer-handler-nodemailer'\nimport { ReactEmailRenderer } from '@redwoodjs/mailer-renderer-react-email'\n\nimport { logger } from 'src/lib/logger'\n\nexport const mailer = new Mailer({\n  handling: {\n    handlers: {\n      // TODO: Update this handler config or switch it out for a different handler completely\n      nodemailer: new NodemailerMailHandler({\n        transport: {\n          host: 'localhost',\n          port: 4319,\n          secure: false,\n        },\n      }),\n    },\n    default: 'nodemailer',\n  },\n\n  rendering: {\n    renderers: {\n      reactEmail: new ReactEmailRenderer(),\n    },\n    default: 'reactEmail',\n  },\n\n  logger,\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Testing an Asynchronous RedwoodJS Transformer Directive (TypeScript/Jest)\nDESCRIPTION: Demonstrates how to adapt a Jest test for an asynchronous RedwoodJS Transformer directive, despite the documentation suggesting transformers must be synchronous. By marking the test function `async` and using `await expect(mockExecution()).resolves.toBe(...)`, it correctly handles promises potentially returned by the `transform` function and asserts that they resolve to the expected transformed value. This pattern is useful if the transformation logic involves asynchronous operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_32\n\nLANGUAGE: ts\nCODE:\n```\nimport maskedEmail from './maskedEmail'\n\ndescribe('maskedEmail directive', () => {\n  it('has a maskedEmail implementation transforms the value', async () => {\n    const mockExecution = mockRedwoodDirective(maskedEmail, {\n      mockedResolvedValue: 'foo',\n    })\n\n    await expect(mockExecution()).resolves.toBe('bar')\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Applying Layouts to the RedwoodJS NotFoundPage (JSX)\nDESCRIPTION: Demonstrates how to incorporate a RedwoodJS Layout (e.g., `MainLayout`) into the `NotFoundPage`. This is done by importing the layout component directly into `NotFoundPage.jsx` and wrapping the page content with it, allowing the 404 page to share common UI elements like headers and footers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_40\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/NotFoundPage/NotFoundPage.jsx\"\n// highlight-next-line\nimport MainLayout from 'src/layouts/MainLayout/MainLayout'\n\nexport default () => (\n  // highlight-next-line\n  <MainLayout>\n    <main>\n      <section>\n        <h1>\n          <span>404 Page Not Found</span>\n        </h1>\n      </section>\n    </main>\n  // highlight-next-line\n  </MainLayout>\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Running ESLint on Redwood Project Files (Bash)\nDESCRIPTION: Executes ESLint to check the project files for adherence to Redwood's configured linting rules, which include ESLint recommended, React recommended, and custom rules (no semicolons, comma dangle multiline, single quotes, etc.). The optional `--fix` flag attempts to automatically correct linting errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_93\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood lint\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Directives via CLI\nDESCRIPTION: This command generates a RedwoodJS GraphQL directive, which can be either a 'validator' or a 'transformer'. It requires the directive's name as an argument. Options include forcing overwrite (`--force`), generating TypeScript files (`--typescript`), specifying the directive type (`--type`), and rolling back on error (`--rollback`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_40\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate directive <name>\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS Credentials in .env File - RedwoodJS - Bash\nDESCRIPTION: This snippet shows the key environment variables needed for AWS authentication, to be placed in the project\\'s `.env` file. These credentials are required by the Serverless Framework to deploy to AWS, and must not be committed to version control. Replace the placeholder values with your actual AWS access and secret keys.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/serverless.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# .env\n\nAWS_ACCESS_KEY_ID=<your-key-here>\nAWS_SECRET_ACCESS_KEY=<your-secret-key-here>\n```\n\n----------------------------------------\n\nTITLE: Example HTTP Request to 'divide' Function - Bash (HTTP Request Syntax)\nDESCRIPTION: The snippet demonstrates how to invoke the 'divide' serverless endpoint via HTTP by passing 'dividend' and 'divisor' as query string parameters. Useful for manual endpoint testing with browsers, curl, or testing tools. Prerequisite: server running at the default Redwood API port, and the 'divide' function implemented.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n// request\nhttp://localhost:8911/divide?dividend=10 &\ndivisor=2\n```\n\n----------------------------------------\n\nTITLE: Implementing a KPI Card with Progress and Delta (tsx)\nDESCRIPTION: This TypeScript React component defines a KpiCard presenting a metric's title, value, progress bar, target, and delta. Leveraging Tremor's Card, Flex, Metric, BadgeDelta, ProgressBar, and Text components, it uses a typed Kpi prop for robust data binding. Dependencies: @tremor/react, TailwindCSS. Expects a Kpi object; renders a compact, styled summary. Limitations: no custom event handling or async data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n// /web/src/components/KpiCard/KpiCard.tsx\n\nimport {\n  BadgeDelta,\n  DeltaType,\n  Card,\n  Flex,\n  Metric,\n  ProgressBar,\n  Text,\n} from '@tremor/react'\n\nexport type Kpi = {\n  title: string\n  metric: string\n  progress: number\n  metricTarget: string\n  delta: string\n  deltaType: DeltaType\n}\n\ninterface Props {\n  kpi: Kpi\n}\n\nconst KpiCard = ({ kpi }: Props) => {\n  return (\n    <Card className=\"max-w-lg\">\n      <Flex alignItems=\"start\">\n        <div>\n          <Text>{kpi.title}</Text>\n          <Metric>{kpi.metric}</Metric>\n        </div>\n        <BadgeDelta deltaType={kpi.deltaType}>{kpi.delta}</BadgeDelta>\n      </Flex>\n      <Flex className=\"mt-4\">\n        <Text className=\"truncate\">{`${kpi.progress}% (${kpi.metric})`}</Text>\n        <Text>{kpi.metricTarget}</Text>\n      </Flex>\n      <ProgressBar percentageValue={kpi.progress} className=\"mt-2\" />\n    </Card>\n  )\n}\n\nexport default KpiCard\n```\n\n----------------------------------------\n\nTITLE: Example Output: Generating Types (Bash)\nDESCRIPTION: Shows example console output after running `yarn redwood generate types`. It lists the various type definition files and helper files being generated or updated within the `.redwood` directory and elsewhere, including GraphQL schema types, mirrored component/layout/service types, route types, and global context types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_90\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood generate types\nyarn run v1.22.10\n$ /redwood-app/node_modules/.bin/redwood g types\n$ /redwood-app/node_modules/.bin/rw-gen\n\nGenerating...\n\n- .redwood/schema.graphql\n- .redwood/types/mirror/api/src/services/posts/index.d.ts\n- .redwood/types/mirror/web/src/components/BlogPost/index.d.ts\n- .redwood/types/mirror/web/src/layouts/BlogLayout/index.d.ts\n...\n- .redwood/types/mirror/web/src/components/Post/PostsCell/index.d.ts\n- .redwood/types/includes/web-routesPages.d.ts\n- .redwood/types/includes/all-currentUser.d.ts\n- .redwood/types/includes/web-routerRoutes.d.ts\n- .redwood/types/includes/api-globImports.d.ts\n- .redwood/types/includes/api-globalContext.d.ts\n- .redwood/types/includes/api-scenarios.d.ts\n- api/types/graphql.d.ts\n- web/types/graphql.d.ts\n\n... and done.\n```\n\n----------------------------------------\n\nTITLE: Querying Comments by postId Using Prisma with Redwood Console in Bash\nDESCRIPTION: This command, to be run inside the Redwood console, retrieves only those comments associated with a specific post, filtering by the 'postId' field. It uses Prisma's 'findMany' with a 'where' clause to select comments for a particular post. The key input is the 'postId' parameter, and the output is an array containing only comments matching that post.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\ndb.comment.findMany({ where: { postId: 1 }})\n```\n\n----------------------------------------\n\nTITLE: Adding Contact Link to Blog Layout (TypeScript)\nDESCRIPTION: Updates the `BlogLayout.tsx` React component (TypeScript version) to include a navigation link to the Contact page. It uses the `<Link>` component, `routes.contact()` helper from `@redwoodjs/router`, and defines `BlogLayoutProps` for type safety.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/layouts/BlogLayout/BlogLayout.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\ntype BlogLayoutProps = {\n  children?: React.ReactNode\n}\n\nconst BlogLayout = ({ children }: BlogLayoutProps) => {\n  return (\n    <>\n      <header>\n        <h1>\n          <Link to={routes.home()}>Redwood Blog</Link>\n        </h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n            // highlight-start\n            <li>\n              <Link to={routes.contact()}>Contact</Link>\n            </li>\n            // highlight-end\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with `lessThan` Option in JSX\nDESCRIPTION: Illustrates the `numericality` validator using the `lessThan` option to require the input number to be strictly less than the specified value.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_31\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.temp, 'Temperature', {\n  numericality: { lessThan: 100 },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Home Page for Authentication Demo - Bash\nDESCRIPTION: This snippet shows how to generate a new 'Home' page in a RedwoodJS project using Yarn's RedwoodJS generator. This page will serve as the target for implementing authentication demo code. Requires an existing RedwoodJS project with the CLI available. Input is the command, and output is the creation of a new HomePage component scaffolded in the proper location.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/netlify.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g page home /\n```\n\n----------------------------------------\n\nTITLE: Defining a Background Task for Email Sending (JavaScript)\nDESCRIPTION: This snippet defines the 'postSignupTask' async function, which sends a welcome email to a new user using a template and an external email service integration. It expects an object with 'userId' and 'emailPayload' fields. The function assumes that a helper 'sendEmailWithTemplate' is implemented and available for use. There are no return values, and errors are propagated up the call stack.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/background-worker.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const postSignupTask = async ({ userId, emailPayload }) => {\n  // Send a welcome email to new user.\n  // You'll have to have an integration with an email service for this to work.\n  await sendEmailWithTemplate({\n    ...emailPayload,\n    TemplateModel: {\n      ...emailPayload.TemplateModel,\n    },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Directory Structure for Function Fixtures - Bash\nDESCRIPTION: This bash-formatted output shows the directory organization for a RedwoodJS serverless function that includes both a test and a fixture file. It serves as a visual reference to ensure correct file placement for maximizing test maintainability using fixtures.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\napi\n├── src\n│ ├── functions\n│ │ ├── divide\n│ │ │ ├── divide.ts\n│ │ │ ├── divide.test.ts\n│ │ │ ├── divide.fixtures.ts // your fixture < --\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Trusted Documents in Redwood Configuration (TOML)\nDESCRIPTION: This snippet demonstrates how to enable the Trusted Documents feature within a RedwoodJS project's main configuration file, `redwood.toml`. Setting `trustedDocuments = true` under the `[graphql]` section instructs RedwoodJS to generate the necessary persisted document files (like `persisted-documents.json` and `trustedDocumentsStore.ts`) during build/codegen and configures the client to send document hashes instead of full queries.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n...\n[graphql]\n  trustedDocuments = true\n...\n```\n\n----------------------------------------\n\nTITLE: Configuring Vercel Deployment with RedwoodJS Using CLI (shell)\nDESCRIPTION: This shell command initializes the Vercel deployment configuration for a RedwoodJS project. It sets up the required serverless functions path (apiUrl), adjusts project configuration files such as redwood.toml, and prepares the repository for Vercel deployment. No arguments are needed for basic usage; additional parameters can be added for advanced deployment customization.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/vercel.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup deploy vercel\\n\n```\n\n----------------------------------------\n\nTITLE: Providing Default Values for Existing User Credential Fields - Prisma\nDESCRIPTION: Demonstrates updating existing user records in the Prisma schema by assigning default values to hashedPassword and salt, which is necessary for successful schema migration if a user table is already present. This prevents Prisma migration errors due to missing defaults. Insert these lines into the User model within your Prisma schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_2\n\nLANGUAGE: prisma\nCODE:\n```\n  hashedPassword String @default(\"\")\n  salt           String @default(\"\")\n```\n\n----------------------------------------\n\nTITLE: Seeding dbAuth Users with Hashed Passwords (JavaScript)\nDESCRIPTION: Demonstrates how to seed users for RedwoodJS's dbAuth authentication system. It imports the `hashPassword` function from `@redwoodjs/auth-dbauth-api` to generate the required `hashedPassword` and `salt` for each user before using `upsert` to idempotently create or update user records. This ensures passwords are stored correctly according to dbAuth's requirements.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/database-seeds.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// title=\"scripts/seed.js\"\nimport { hashPassword } from '@redwoodjs/auth-dbauth-api'\n\nexport default async () => {\n  const users = [\n    { name: 'John', email: 'john@example.com', password: 'secret1' },\n    { name: 'Jane', email: 'jane@example.com', password: 'secret2' },\n  ]\n\n  for (const user of users) {\n    const [hashedPassword, salt] = hashPassword(user.password)\n\n    await db.user.upsert({\n      where: {\n        email: user.email,\n      },\n      create: {\n        name: user.name,\n        email: user.email,\n        hashedPassword,\n        salt,\n      },\n      update: {\n        name: user.name,\n        hashedPassword,\n        salt,\n      },\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Labels to RedwoodJS Contact Form Fields in TypeScript\nDESCRIPTION: The TypeScript form version now includes styled and associated HTML labels for the 'name', 'email', and 'message' fields, improving semantic markup and user interaction. It leverages strong FormValues typing as in earlier TypeScript examples. Dependencies remain @redwoodjs/web and @redwoodjs/forms.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n  SubmitHandler,\n} from '@redwoodjs/forms'\n\ninterface FormValues {\n  name: string\n  email: string\n  message: string\n}\n\nconst ContactPage = () => {\n  const onSubmit: SubmitHandler<FormValues> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        // highlight-next-line\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" />\n        // highlight-next-line\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" />\n        // highlight-next-line\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" />\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Starting Workers in Background (Production) using Bash\nDESCRIPTION: This command starts the job workers as background processes, suitable for production environments. The number of workers and their configuration is determined by the `workers` array in the `JobManager` setup. The process detaches from the console.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs start\n```\n\n----------------------------------------\n\nTITLE: Using the Exclusion Validator with a Custom Message in JSX\nDESCRIPTION: Illustrates providing a custom error message for the `exclusion` validator. The message is defined using the `message` property within the nested `exclusion` object, alongside the `in` array.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.name, {\n  exclusion: {\n    in: ['Admin', 'Owner'],\n    message: 'That name is reserved, try another',\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Using the Format Validator with `pattern` Option in JSX\nDESCRIPTION: Demonstrates the `format` validator using the nested object syntax with the `pattern` option. This explicitly defines the regular expression to be used for validation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.usPhone, 'US Phone Number', {\n  format: { pattern: /^[0-9-]{10,12}$/ },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Production Environment in Dockerfile\nDESCRIPTION: Shows how to set the NODE_ENV environment variable to \\\"production\\\" within a Dockerfile. This ensures the application and job workers run in production mode inside Docker containers, which can affect configuration, logging, and behavior.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_38\n\nLANGUAGE: docker\nCODE:\n```\nENV NODE_ENV=\"production\"\n```\n\n----------------------------------------\n\nTITLE: Referencing Assets from web/public in React Components (JSX)\nDESCRIPTION: Demonstrates how to reference assets located in the `web/public` directory directly using root-relative paths within JSX. The example shows setting a favicon using `<link>` in the `<Head>` component and displaying an image using `<img>`, both referencing files (`favicon.png`, `img/logo.png`) served statically from the root.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/assets-and-files.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Head } from '@redwoodjs/web'\n\nconst Header = () => {\n  return (\n    <>\n      <Head>\n        // highlight-next-line\n        <link rel=\"icon\" type=\"image/png\" href=\"favicon.png\" />\n      </Head>\n      // highlight-next-line\n      <img src=\"img/logo.png\" alt=\"Logo\" />\n    </>\n  )\n}\n\nexport default Header\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Environment Servers for RedwoodJS with TOML\nDESCRIPTION: Shows how to declare different server groups for distinct environments ('production' and 'staging') in deploy.toml. Each environment block lists server hosts, deployment path, sides (api/web), and process names. The TOML structure is suitable for tools that can parse and act upon multi-environment configs. Prerequisites include RedwoodJS deployment tooling and SSH-accessible hosts with proper credentials.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\n[[production.servers]]\nhost = \"prod.server.com\"\nusername = \"user\"\nagentForward = true\nsides = [\"api\", \"web\"]\npath = \"/var/www/app\"\nprocessNames = [\"serve\"]\n\n[[staging.servers]]\nhost = \"staging.server.com\"\nusername = \"user\"\nagentForward = true\nsides = [\"api\", \"web\"]\npath = \"/var/www/app\"\nprocessNames = [\"serve\", \"stage-logging\"]\n\n```\n\n----------------------------------------\n\nTITLE: Azure Active Directory B2C Environment Configuration - Bash\nDESCRIPTION: This .env code snippet adds Azure AD B2C-specific configuration options required for hosted user flows and JWT validation. The AUTHORITY and KNOWN_AUTHORITY variables inform MSAL.js of the B2C endpoints, while JWT_ISSUER is for backend/API validation. Variables should be customized with your actual tenant name, tenant ID, and user flow ID from the Azure portal. Only expose JWT_ISSUER on the API side for security reasons.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/azure.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nAZURE_ACTIVE_DIRECTORY_AUTHORITY=https://{your-microsoft-tenant-name}.b2clogin.com/{{your-microsoft-tenant-name}}.onmicrosoft.com/{{your-microsoft-user-flow-id}}\nAZURE_ACTIVE_DIRECTORY_JWT_ISSUER=https://{{your-microsoft-tenant-name}}.b2clogin.com/{{your-microsoft-tenant-id}}/v2.0/\nAZURE_ACTIVE_DIRECTORY_KNOWN_AUTHORITY=https://{{your-microsoft-tenant-name}}.b2clogin.com\n```\n\n----------------------------------------\n\nTITLE: Adding Dependencies with Yarn Workspaces - RedwoodJS - Bash Script\nDESCRIPTION: This snippet demonstrates how to add npm dependencies to specific parts ('workspaces') of a RedwoodJS project using Yarn's workspace commands. The first command adds a dependency to the frontend ('web') workspace, while the second does so for the backend ('api'). This approach ensures that dependencies are properly scoped and install only where needed. It requires that Yarn and workspaces are properly configured in the project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/file-structure.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn workspace web add marked\nyarn workspace api add better-fs\n```\n```\n\n----------------------------------------\n\nTITLE: Importing SVG Files as Image Sources in React (JSX)\nDESCRIPTION: Shows the standard method of importing an SVG file (`mySvg.svg`) similar to other image assets and using the imported source path in the `src` attribute of an `<img>` tag within a React component. Vite handles the import.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/assets-and-files.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport svgIconSrc from '../mySvg.svg'\n\nconst Example = () => {\n  return (\n    <>\n      // highlight-next-line\n      <img src={svgIconSrc} alt=\"Logo\" />\n    </>\n  )\n}\n\nexport default Example\n```\n\n----------------------------------------\n\nTITLE: Generating dbAuth Login, Signup, and Forgot Password Pages - Bash\nDESCRIPTION: Uses the Redwood generator CLI to scaffold ready-made Login, Signup, Forgot Password, and Reset Password pages with dbAuth wiring. This is a convenience command for rapidly building frontend routes and components in a Redwood project. The generated pages can be customized and will contain required hooks for server interaction.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw generate dbAuth\n```\n\n----------------------------------------\n\nTITLE: Generating a New Dashboard Page with RedwoodJS CLI (bash)\nDESCRIPTION: This command creates a new page named 'dashboard' at the root route in a RedwoodJS app, scaffolding required files and routes. After execution, you get a DashboardPage component and updated routing. Must run inside the project root.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g page dashboard /\n```\n\n----------------------------------------\n\nTITLE: Comparing Simple and Nested Validation Object Syntax in JSX\nDESCRIPTION: Illustrates the two common syntaxes for validation rule objects within the `validate` function. A simple form (e.g., `{ email: true }` or `{ exclusion: ['Admin', 'Owner'] }`) is used when no custom message is needed. A nested object form (e.g., `{ email: { message: '...' } }` or `{ exclusion: { in: [...], message: '...' } }`) is required when specifying options like a custom error message.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n{ email: true }\n{ email: { message: 'Must provide an email' } }\n\n{ exclusion: ['Admin', 'Owner'] }\n{ exclusion: { in: ['Admin', 'Owner' ], message: 'That name is reserved' } }\n```\n\n----------------------------------------\n\nTITLE: Defining Public GraphQL Schema for Posts - JavaScript\nDESCRIPTION: This GraphQL SDL defines the Post type and exposes two queries (posts and post) to the public, with access explicitly skipped (no authentication required) via @skipAuth. The Post type includes id, title, body, createdAt, and a relation to User. It only allows querying posts, with no mutations available. Intended for open/public site usage, relies on RedwoodJS's gql API.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nexport const schema = gql`\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n    user: User!\n  }\n\n  type Query {\n    posts: [Post!]! @skipAuth\n    post(id: Int!): Post @skipAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Creating a Testimonial with Role-Based Auth in RedwoodJS - JavaScript\nDESCRIPTION: This service function implements role-based control for creating a testimonial using Prisma in a RedwoodJS backend. It uses the context object to check the logged-in user's roles and creates a testimonial only if the user is an admin, otherwise throws an AuthenticationError. Requires proper context injection and the '@redwoodjs/graphql-server' package. Parameters: 'data' is an object matching testimonial fields. Throws on unauthorized access and returns the created testimonial record on success.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/02_chapter0/what-is-redwood.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\nimport { AuthenticationError } from '@redwoodjs/graphql-server'\n\nexport const createTestimonial = ({ data }) => {\n  if (context.currentUser.roles.includes('admin')) {\n    return db.testimonial.create({ data })\n  } else {\n    throw new AuthenticationError(\n      'You are not authorized to create testimonials'\n    )\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL SDL for Testimonials - JavaScript\nDESCRIPTION: This snippet implements the Schema Definition Language (SDL) for a \"Testimonial\" type and a read-only \"testimonials\" query in JavaScript using RedwoodJS's gql template tag. It expects a corresponding service function for the query and will return fields as specified in the SDL. No authentication guard is included in this minimal version. It requires the RedwoodJS GraphQL module for parsing the gql string and should be placed where GraphQL schemas are defined.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/02_chapter0/what-is-redwood.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nexport const schema = gql`\n  type Testimonial {\n    id: Int!\n    author: String!\n    quote: String!\n    createdAt: DateTime!\n    updatedAt: DateTime!\n  }\n\n  type Query {\n    testimonials: [Testimonial!] @skipAuth\n  }\n`\n\n```\n\n----------------------------------------\n\nTITLE: Validating Email Format in RedwoodJS Forms using Pattern Matching in TypeScript\nDESCRIPTION: Implements email format validation in a TSX-based RedwoodJS form by providing a regex 'pattern' in the email field's validation object. When users input an incorrect email, a contextual error message appears. This leverages Redwood's React Hook Form abstraction to apply real-time pattern-based validation in addition to 'required'. Useful for pre-submission assurance that email input resembles expected patterns, though backend verification is still necessary.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_32\n\nLANGUAGE: tsx\nCODE:\n```\n<TextField\n  name=\"email\"\n  validation={{\n    required: true,\n    // highlight-start\n    pattern: {\n      value: /^[^@]+@[^.]+\\..+$/,\n      message: 'Please enter a valid email address',\n    },\n    // highlight-end\n  }}\n  errorClassName=\"error\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Prisma CLI Output Example After User Role Update - Bash\nDESCRIPTION: Shows the expected output after updating a user's role in the database using Prisma. Useful for verifying that the database update executed as intended. Outputs all main fields for the updated user, including id, email, hashedPassword, and new roles. For informational reference only, not intended for code execution.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/rbac.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n{\n  id: 1,\n  name: null,\n  email: 'admin@admin.com',\n  hashedPassword: 'a12f3975a3722953fd8e326dd108d5645ad9563042fe9f154419361eeeb775d8',\n  salt: '9abf4665293211adce1c99de412b219e',\n  resetToken: null,\n  resetTokenExpiresAt: null,\n  roles: 'admin'\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Login Endpoint with dbAuth Config - JavaScript\nDESCRIPTION: Shows how to explicitly disable the login handler in a Redwood dbAuth configuration by setting enabled to false. This disables the entire login flow and should be used when authentication is temporarily or permanently halted. Insert in the dbAuth config object within the API function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nlogin: {\n  enabled: false\n}\n```\n\n----------------------------------------\n\nTITLE: Running Redwood Storybook (Shell)\nDESCRIPTION: This command runs the local Storybook server for the Redwood project, allowing developers to visually test and develop React components in isolation. Requires a Redwood project initialized and compatible Storybook setup. Expected output is an interactive local server displaying Storybook UI, accessible in the browser, which hot reloads as components are developed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/quick-start.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw storybook\n```\n\n----------------------------------------\n\nTITLE: Array Prop Mapping to Multiple Meta Tags - JSX\nDESCRIPTION: This JSX example shows how passing an array as a prop (e.g., 'og={{ image: [url1, url2] }}') causes <Metadata> to generate multiple meta tags with the same property and different content. Used primarily for OpenGraph properties accepting multiple values. Input is an array of URLs; output is multiple <meta> tags with identical properties.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata og={{ image: [\"http://host.test/image1.jpg\", \"http://host.test/image2.jpg\"] }}/>\n// generates\n<meta property=\"og:image\" content=\"http://host.test/image1.jpg\" />\n<meta property=\"og:image\" content=\"http://host.test/image2.jpg\" />\n\n```\n\n----------------------------------------\n\nTITLE: Executing Prisma CLI Commands via Redwood Wrapper (Bash)\nDESCRIPTION: Runs Prisma CLI commands within the context of a Redwood project. This command acts as a lightweight wrapper around the native `prisma` CLI, automatically adding necessary flags like `--schema=api/db/schema.prisma`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_94\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood prisma\n```\n\n----------------------------------------\n\nTITLE: Customizing logIn Scopes with MSAL.js - JSX\nDESCRIPTION: This Waits for the asynchronous logIn function and demonstrates how to customize the login scopes in MSAL.js by passing an options object. Providing a scopes array extends the set of OAuth2 scopes requested for user consent. By default, MSAL's login includes 'openid', 'profile', and 'offline_access'; adding 'User.Read.All' requests permission for that Microsoft Graph scope. Use this pattern in your authentication flow to request advanced permissions. The code assumes access to a logIn function returning a Promise and that the user is ready to be redirected for login.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/azure.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nawait logIn({\n  scopes: ['User.Read.All'], // becomes ['openid', 'profile', 'offline_access', 'User.Read.All']\n})\n```\n\n----------------------------------------\n\nTITLE: Defining API-Side Variable in .env (Text)\nDESCRIPTION: This example shows how to define a custom environment variable, `HELLO_ENV`, within the `.env` file. Variables defined here are loaded into `process.env` by Redwood using `dotenv` and are primarily intended for use by the API side during development.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/environment-variables.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n```\nHELLO_ENV=hello world\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Contact Link to Blog Layout (JavaScript)\nDESCRIPTION: Updates the `BlogLayout.jsx` React component to include a navigation link to the newly created Contact page. It utilizes the `<Link>` component and `routes.contact()` helper function provided by `@redwoodjs/router` to ensure proper routing within the application.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/layouts/BlogLayout/BlogLayout.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\nconst BlogLayout = ({ children }) => {\n  return (\n    <>\n      <header>\n        <h1>\n          <Link to={routes.home()}>Redwood Blog</Link>\n        </h1>\n        <nav>\n          <ul>\n            <li>\n              <Link to={routes.home()}>Home</Link>\n            </li>\n            <li>\n              <Link to={routes.about()}>About</Link>\n            </li>\n            // highlight-start\n            <li>\n              <Link to={routes.contact()}>Contact</Link>\n            </li>\n            // highlight-end\n          </ul>\n        </nav>\n      </header>\n      <main>{children}</main>\n    </>\n  )\n}\n\nexport default BlogLayout\n```\n```\n\n----------------------------------------\n\nTITLE: Hashing Objects for Cache Keys in Node.js (JavaScript)\nDESCRIPTION: This snippet demonstrates creating a cache key by hashing a product object using the blueimp-md5 library. The function serializes the product to JSON, generates an MD5 hash, and uses this as the unique key for caching. Dependencies: 'blueimp-md5'. The 'cache' function is assumed to store results keyed by the hash. The main parameter is the serialized product, ensuring changes in any property create a new cache entry. Returns or retrieves cached content, but may incur a minor performance cost due to hashing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_59\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { md5 } from 'blueimp-md5'\n\ncache(md5(JSON.stringify(product)), () => {\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Digital Ocean Connection Pool URL for Prisma\nDESCRIPTION: Illustrates the required format for the `DATABASE_URL` environment variable when using Prisma with a Digital Ocean PostgreSQL connection pool, especially for migrations. It specifies the connection pool URL, the typical pgbouncer port (`25061`), and necessary parameters like `connection_limit`, `sslmode=require`, `pgbouncer=true`, `connect_timeout`, and `pool_timeout` to avoid migration errors and ensure successful deployment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/connection-pooling.md#_snippet_3\n\nLANGUAGE: uri\nCODE:\n```\n<YOUR_CONNECTION_POOL_URL>:25061/defaultdb?connection_limit=3&sslmode=require&pgbouncer=true&connect_timeout=10&pool_timeout=30\n```\n\n----------------------------------------\n\nTITLE: Mocking Standard Comments Data for Storybook - JavaScript\nDESCRIPTION: This code exports a mock “standard” function for use with RedwoodJS Storybook integration, returning fixed sample comments data. Intended to simulate GraphQL responses during UI development and test rendering states, it provides two example comments with typical fields. No external dependencies are required, and it enables Storybook to display the CommentsCell without backend interaction.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport const standard = () => ({\n  // highlight-start\n  comments: [\n    {\n      id: 1,\n      name: 'Rob Cameron',\n      body: 'First comment',\n      createdAt: '2020-01-02T12:34:56Z',\n    },\n    {\n      id: 2,\n      name: 'David Price',\n      body: 'Second comment',\n      createdAt: '2020-02-03T23:00:00Z',\n    },\n  ],\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Skipping Authentication for posts and post Queries in RedwoodJS GraphQL Schema (GraphQL)\nDESCRIPTION: This GraphQL schema update applies the '@skipAuth' directive to both the 'posts' query (for listing multiple posts) and the 'post(id: Int!)' query (for fetching a single post). This ensures that unauthenticated users can view both the list of posts and the detail page for individual posts publicly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_7\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    posts: [Post!]! @skipAuth\n    // highlight-next-line\n    post(id: Int!): Post @skipAuth\n  }\n\n  input CreatePostInput {\n    title: String!\n    body: String!\n  }\n\n  input UpdatePostInput {\n    title: String\n    body: String\n  }\n\n  type Mutation {\n    createPost(input: CreatePostInput!): Post! @requireAuth\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\n    deletePost(id: Int!): Post! @requireAuth\n  }\n`\n```\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    posts: [Post!]! @skipAuth\n    // highlight-next-line\n    post(id: Int!): Post @skipAuth\n  }\n\n  input CreatePostInput {\n    title: String!\n    body: String!\n  }\n\n  input UpdatePostInput {\n    title: String\n    body: String\n  }\n\n  type Mutation {\n    createPost(input: CreatePostInput!): Post! @requireAuth\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\n    deletePost(id: Int!): Post! @requireAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Skipping Authentication for posts Query in RedwoodJS GraphQL Schema (GraphQL)\nDESCRIPTION: This GraphQL schema definition demonstrates modifying the authorization directive for the 'posts' query. By changing from '@requireAuth' to '@skipAuth', this query can now be accessed by unauthenticated users, allowing public display of post lists (e.g., on a homepage) even though the admin pages are protected.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/07_chapter4/authentication.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    // highlight-next-line\n    posts: [Post!]! @skipAuth\n    post(id: Int!): Post @requireAuth\n  }\n\n  input CreatePostInput {\n    title: String!\n    body: String!\n  }\n\n  input UpdatePostInput {\n    title: String\n    body: String\n  }\n\n  type Mutation {\n    createPost(input: CreatePostInput!): Post! @requireAuth\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\n    deletePost(id: Int!): Post! @requireAuth\n  }\n`\n```\n\nLANGUAGE: graphql\nCODE:\n```\nexport const schema = gql`\n  type Post {\n    id: Int!\n    title: String!\n    body: String!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    // highlight-next-line\n    posts: [Post!]! @skipAuth\n    post(id: Int!): Post @requireAuth\n  }\n\n  input CreatePostInput {\n    title: String!\n    body: String!\n  }\n\n  input UpdatePostInput {\n    title: String\n    body: String\n  }\n\n  type Mutation {\n    createPost(input: CreatePostInput!): Post! @requireAuth\n    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth\n    deletePost(id: Int!): Post! @requireAuth\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Signup Form with RedwoodJS Forms in JavaScript\nDESCRIPTION: This snippet adds a simple unconnected signup form using RedwoodJS's built-in form components in the SignupPage component. It requires '@redwoodjs/forms' as a dependency and assumes the component is rendered within a RedwoodJS application. The form includes fields for email and password and submits via a button, but none of the inputs are connected to submit handlers yet.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Form, TextField, PasswordField, Submit } from '@redwoodjs/forms'\n\nconst SignupPage = () => {\n  return (\n    <>\n      <h1>Sign Up</h1>\n      <Form>\n        <TextField name=\"email\" placeholder=\"email\" />\n        <PasswordField name=\"password\" placeholder=\"password\" />\n        <Submit>Sign Up</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default SignupPage\n```\n\n----------------------------------------\n\nTITLE: Enabling Custom RedwoodJS Validation on Form Fields in JavaScript\nDESCRIPTION: Switches validation from HTML 'required' properties to RedwoodJS's custom \"validation\" prop for greater flexibility and styling. Each field defines validation rules as an object, such as { required: true }. This foundation enables future expansion with custom messages or validators. Dependencies: core RedwoodJS web and forms packages.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\nreturn (\n  <Form onSubmit={onSubmit}>\n    <label htmlFor=\"name\">Name</label>\n    // highlight-next-line\n    <TextField name=\"name\" validation={{ required: true }} />\n\n    <label htmlFor=\"email\">Email</label>\n    // highlight-next-line\n    <TextField name=\"email\" validation={{ required: true }} />\n\n    <label htmlFor=\"message\">Message</label>\n    // highlight-next-line\n    <TextAreaField name=\"message\" validation={{ required: true }} />\n\n    <Submit>Save</Submit>\n  </Form>\n)\n```\n\n----------------------------------------\n\nTITLE: Adding a Text Field to a RedwoodJS Form - JavaScript\nDESCRIPTION: This JavaScript snippet extends the previous example by adding a <TextField> to the RedwoodJS form, enabling user input. The TextField is given a 'name' attribute ('input'), allowing it to be referenced within the form. Required dependencies are '@redwoodjs/web' and '@redwoodjs/forms'. The input is user text, while no output handling is shown. This snippet shows the core mechanics of named form fields for basic data capture.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form>\n        // highlight-next-line\n        <TextField name=\"input\" />\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n\n----------------------------------------\n\nTITLE: Setting Up Baremetal Deployment Configuration (Bash)\nDESCRIPTION: This command initializes the baremetal deployment setup for a RedwoodJS project. It adds necessary dependencies to `package.json` and creates the `deploy.toml` and `ecosystem.config.js` configuration files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup deploy baremetal\n```\n\n----------------------------------------\n\nTITLE: Verifying OTP using Supabase Client in RedwoodJS (TypeScript)\nDESCRIPTION: Demonstrates how to verify a One-Time Password (OTP) provided by the user (e.g., via SMS). It accesses the underlying Supabase client via `useAuth().client` and calls the `verifyOtp` method within a `useEffect` hook, as the RedwoodJS `useAuth` hook doesn't directly expose `verifyOtp`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst { client } = useAuth()\n\nuseEffect(() => {\n  const { data, error } = await client.verifyOtp({ phone, token, type: 'sms' })\n}, [client])\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS SDLs Separately After Commenting Relations\nDESCRIPTION: These RedwoodJS CLI commands generate the SDLs for the `Book` and `Shelf` models separately. This should be done after commenting out the relation fields in the Prisma schema to avoid generation errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/schema-relations.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g sdl Book\n# ...\n\nyarn rw g sdl Shelf\n# ...\n```\n\n----------------------------------------\n\nTITLE: Testing Article Summary Rendering with RedwoodJS Test Utilities in JavaScript\nDESCRIPTION: This snippet tests the Article component's ability to render both the full blog post and a truncated summary using RedwoodJS utility functions in JavaScript. It defines a sample ARTICLE object and uses it to assert the presence of title, full body, or truncated summary according to the props passed. Dependencies include @redwoodjs/testing for rendering, and the Article component itself; key parameters are the article object and the summary boolean. Expected input is the ARTICLE object, with outputs being verification of rendered content as present in the DOM; limitations include tight coupling of the summary string in tests.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_18\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { render, screen } from '@redwoodjs/testing'\n\nimport Article from './Article'\n\n// highlight-start\nconst ARTICLE = {\n  id: 1,\n  title: 'First post',\n  body: `Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Street art next level umami squid. Hammock hexagon glossier 8-bit banjo. Neutra la croix mixtape echo park four loko semiotics kitsch forage chambray. Semiotics salvia selfies jianbing hella shaman. Letterpress helvetica vaporware cronut, shaman butcher YOLO poke fixie hoodie gentrify woke heirloom.`,\n  createdAt: new Date().toISOString(),\n}\n// highlight-end\n\ndescribe('Article', () => {\n  it('renders a blog post', () => {\n    // highlight-next-line\n    render(<Article article={ARTICLE} />)\n\n    // highlight-start\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(screen.getByText(ARTICLE.body)).toBeInTheDocument()\n    // highlight-end\n  })\n\n  // highlight-start\n  it('renders a summary of a blog post', () => {\n    render(<Article article={ARTICLE} summary={true} />)\n\n    expect(screen.getByText(ARTICLE.title)).toBeInTheDocument()\n    expect(\n      screen.getByText(\n        'Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Str...'\n      )\n    ).toBeInTheDocument()\n  })\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up an Official Auth Provider with RedwoodJS CLI (shell)\nDESCRIPTION: This shell command demonstrates how to initialize an official RedwoodJS auth provider (e.g., Auth0) using the CLI. It scaffolds the provider integration and sets up all required files. The command must be run within the RedwoodJS project directory and requires the proper package and provider to be specified. Needed dependencies and configuration steps are handled automatically by the CLI. Input is the CLI command; output is the generation of authentication integration files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/authentication.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup auth auth0\n```\n\n----------------------------------------\n\nTITLE: Defining transform with TransformerDirectiveFunc in TypeScript\nDESCRIPTION: This snippet demonstrates how to declare a transform function for a transformer directive by explicitly typing its arguments with TransformerDirectiveFunc. The provided context and resolvedValue parameters are typed according to the generic parameters of the function type, ensuring proper type inference and safety for the implementer. Dependencies include the TransformerDirectiveFunc type definition, and it is intended to be used within the implementation of a custom GraphQL directive.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\n// \\\\ud83d\\\\udc47 makes sure the functions' arguments are typed\\n// highlight-next-line\\nconst transform: TransformerDirectiveFunc = ({ context, resolvedValue }) => {\n```\n\n----------------------------------------\n\nTITLE: Setting Host Bindings for Web and API in redwood.toml - TOML\nDESCRIPTION: This snippet configures RedwoodJS's web and api hosts to 0.0.0.0 in redwood.toml, enabling network access for container or VM deployments. It ensures that both web and API servers accept external connections, which is essential for cloud and Dockerized environments. This setup requires no additional dependencies but should be used with care regarding exposure to public networks. Inputs are the static values provided; if REDWOOD_WEB_HOST or REDWOOD_API_HOST environment variables are set, they will override these. Defaults automatically apply in production environments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/app-configuration-redwood-toml.md#_snippet_11\n\nLANGUAGE: TOML\nCODE:\n```\n[web]\n  host = '0.0.0.0'\n[api]\n  host = '0.0.0.0'\n```\n\n----------------------------------------\n\nTITLE: Querying Forbidden Field with Field-Level Authorization (GraphQL)\nDESCRIPTION: This GraphQL query illustrates an invalid request for a user who is authenticated but does *not* have the 'ADMIN' role, based on the schema with field-level `@requireAuth(role: \"ADMIN\")` on the `email` field. Attempting to query the `email` field will result in a forbidden error.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_15\n\nLANGUAGE: graphql\nCODE:\n```\nquery user(id: 1) {\n  id\n  name\n  email\n  createdAt\n}\n```\n\n----------------------------------------\n\nTITLE: Running TypeScript Type Checks in RedwoodJS - Bash\nDESCRIPTION: Performs a TypeScript type check for the RedwoodJS project's 'api' and 'web' sides, using the yarn wrapper. Requires TypeScript and proper TS configuration files in project root(s). The 'side' argument lets the user limit checks to either 'api', 'web', or both (default). No build output is generated; this is purely a type check for static correctness.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_132\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood type-check [side]\n```\n\n----------------------------------------\n\nTITLE: Setting Up Coherence Deployment with RedwoodJS via Yarn Command - Bash\nDESCRIPTION: This snippet shows the shell command for initializing Coherence deployment configuration in a RedwoodJS project. It requires that the project is managed with Yarn and that you have properly set up GitHub and AWS/GCP accounts. The command inspects your Prisma configuration for supported databases (Postgres or MySQL) and guides you through integration with Coherence; it expects a standard RedwoodJS monorepo directory structure as its input and produces configuration files. No support for prerendered deployment is currently provided.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/coherence.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw setup deploy coherence\n```\n\n----------------------------------------\n\nTITLE: Starting RedwoodJS Development Server with Automatic Log Formatting (Bash)\nDESCRIPTION: Shows the command to start the RedwoodJS development server, which automatically invokes the log formatter. Requires a RedwoodJS project with the CLI available. Input: none. Output: development server with live, formatted logs in the terminal. This is the standard development workflow for RedwoodJS apps.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw dev\n```\n\n----------------------------------------\n\nTITLE: Finding Ellipsis Within an Element (JavaScript)\nDESCRIPTION: Uses the testing library's `within` function to scope the search to the previously found `matchedBody` element, then uses `getByText` to find the ellipsis '...' within that element, again allowing partial matches.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst ellipsis = within(matchedBody).getByText('...', { exact: false })\n```\n\n----------------------------------------\n\nTITLE: Initializing Sample Chart.js Graph in React (JSX)\nDESCRIPTION: Updates the `HomePage` component to integrate a basic Chart.js line graph. It imports `Chart` from `chart.js` and uses `useRef` to get a reference to a `<canvas>` element. A `useEffect` hook (currently dependent on `forecast` state, but uses hardcoded sample data) initializes a new `Chart` instance on the canvas's 2D context, demonstrating how to set up a simple chart structure with labels and datasets.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/disable-api-database.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useState, useEffect, useRef } from 'react'\nimport Chart from 'chart.js'\n\nconst HomePage = () => {\n  const chartRef = useRef()\n\n  const [forecast, setForecast] = useState({}) // Data fetching part remains\n\n  useEffect(() => {\n    fetch('/forecast.json')\n      .then((response) => response.json())\n      .then((json) => setForecast(json))\n  }, [])\n\n  useEffect(() => {\n    // Initialize chart when component mounts or forecast changes (but using sample data here)\n    new Chart(chartRef.current.getContext('2d'), {\n      type: 'line',\n      data: {\n        labels: ['Jan', 'Feb', 'March'], // Sample labels\n        datasets: [\n          {\n            label: 'High',\n            data: [86, 67, 91], // Sample data\n          },\n          {\n            label: 'Low',\n            data: [45, 43, 55], // Sample data\n          },\n        ],\n      },\n    })\n  }, [forecast]) // Dependency array ensures chart updates if forecast changes (though not used effectively here yet)\n\n  // Render a canvas element for the chart\n  return <canvas ref={chartRef} />\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Generating a Home Page with RedwoodJS CLI - Bash/Plaintext\nDESCRIPTION: These output snippets display example console output from generating a basic home page via RedwoodJS CLI. They help users understand the resulting feedback and file changes during execution. Dependencies are an initialized RedwoodJS project and the 'yarn' CLI. Inputs include the page name and path; the output lists file creation status and duration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_58\n\nLANGUAGE: plaintext\nCODE:\n```\n~/redwood-app$ yarn redwood generate page home /\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood g page home /\n  ✔ Generating page files...\n    ✔ Writing `./web/src/pages/HomePage/HomePage.test.js`...\n    ✔ Writing `./web/src/pages/HomePage/HomePage.js`...\n  ✔ Updating routes file...\nDone in 1.02s.\n```\n\n----------------------------------------\n\nTITLE: Nested Object Prop to Meta Tag Mapping - JSX\nDESCRIPTION: This snippet shows how passing a nested object prop (e.g., 'music={{ album: { track: 12 } }}') to the <Metadata> component results in a meta tag with a colon-delimited 'property' key for OpenGraph-style descriptors. No special dependencies are required, and the main constraint is proper object nesting. Output is a meta tag in the form 'property=\"music:album:track\"'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n<Metadata music={{ album: { track: 12 } }}/>\n// generates\n<meta property=\"music:album:track\" content=\"12\" />\n\n```\n\n----------------------------------------\n\nTITLE: Customizing the Production FatalErrorPage in RedwoodJS (JSX)\nDESCRIPTION: Provides an example of a customized `FatalErrorPage` component (`web/src/pages/FatalErrorPage/FatalErrorPage.jsx`) for production environments. This example uses Tailwind CSS for styling and includes navigation links (Home, Contact Support). It's important to keep this page simple to prevent it from causing its own errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_36\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/FatalErrorPage/FatalErrorPage.jsx\"\nimport { Link, routes } from '@redwoodjs/router'\n\n// ...\n\nexport default RedwoodDevFatalErrorPage ||\n  (() => (\n    <div className=\"bg-white min-h-full px-4 py-16 sm:px-6 sm:py-24 md:grid md:place-items-center lg:px-8\">\n      <div className=\"max-w-max mx-auto\">\n        <main className=\"sm:flex\">\n          <p className=\"text-4xl font-extrabold text-blue-600 sm:text-5xl\">\n            🤦‍♂️ Oops.\n          </p>\n          <div className=\"sm:ml-6\">\n            <div className=\"sm:border-l sm:border-gray-200 sm:pl-6\">\n              <h1 className=\"text-4xl font-extrabold text-gray-900 tracking-tight sm:text-5xl\">\n                Something went wrong\n              </h1>\n              <p className=\"mt-1 text-base text-gray-500\">\n                Sorry about that. Please contact support for help.\n              </p>\n            </div>\n            <div className=\"mt-10 flex space-x-3 sm:border-l sm:border-transparent sm:pl-6\">\n              <Link\n                to={routes.home()}\n                className=\"inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500\"\n              >\n                Home\n              </Link>\n              <Link\n                to={routes.support()}\n                className=\"inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-blue-700 bg-blue-100 hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500\"\n              >\n                Contact Support\n              </Link>\n            </div>\n          </div>\n        </main>\n      </div>\n    </div>\n  ))\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Secure Session Secret for dbAuth - Bash\nDESCRIPTION: Invokes the Redwood CLI to securely generate a random value for use as SESSION_SECRET in the .env file, which is critical for AES encryption of session cookies. This command should be run in each environment separately to maintain user logout isolation and should not be checked into source control.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g secret\n```\n\n----------------------------------------\n\nTITLE: Unix Directory Listing During Deploy - Bash\nDESCRIPTION: Shows a 'ls -l' directory listing example to illustrate where custom deploy commands execute relative to the deploy and current directories. Used for contextualizing the execution context when writing custom deployment scripts. File and directory names/timestamps are illustrative only.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ndrwxrwxr-x 5 ubuntu ubuntu 4096 May 10 18:20 ./\ndrwxr-xr-x 7 ubuntu ubuntu 4096 Apr 27 17:43 ../\ndrwxrwxr-x 2 ubuntu ubuntu 4096 May 9 22:59 20220503211428/\ndrwxrwxr-x 2 ubuntu ubuntu 4096 May 9 22:59 20220503211429/\ndrwxrwxr-x 10 ubuntu ubuntu 4096 May 10 18:18 20220510181730/ commands are run in here < --\nlrwxrwxrwx 1 ubuntu ubuntu 14 May 10 18:19 current - > 20220503211429/\n-rw-rw-r-- 1 ubuntu ubuntu 1167 Apr 22 20:49 .env\n```\n\n----------------------------------------\n\nTITLE: Example Decoded JWT with Roles in RedwoodJS (JSON)\nDESCRIPTION: Illustrates the structure of a decoded JSON Web Token (JWT) as might be issued by an identity provider like Netlify Identity. It shows standard claims like `exp` (expiration) and `sub` (subject/user ID), along with `app_metadata` which often contains user roles, and `user_metadata`. This structure is key for extracting roles in RedwoodJS authentication.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"exp\": 1598628532,\n  \"sub\": \"1d271db5-f0cg-21f4-8b43-a01ddd3be294\",\n  \"email\": \"example+author@example.com\",\n  \"app_metadata\": {\n    \"roles\": [\"author\"]\n  },\n  \"user_metadata\": {\n    \"full_name\": \"Arthur Author\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Storybook Story for the Comment Component - RedwoodJS JavaScript\nDESCRIPTION: This JavaScript snippet defines a Storybook story for the Comment component, used for visual testing and UI development. It passes a sample comment object to the component and exports the story for integration with Storybook. The sample comment uses ISO8601 format for createdAt, aligning with expected data from GraphQL APIs. No external dependencies are needed apart from RedwoodJS and Storybook integration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/the-redwood-way.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport Comment from './Comment'\n\nexport const generated = () => {\n  // highlight-start\n  return (\n    <Comment\n      comment={{\n        name: 'Rob Cameron',\n        body: 'This is the first comment!',\n        createdAt: '2020-01-01T12:34:56Z'\n      }}\n    />\n  )\n  // highlight-end\n}\n\nexport default {\n  title: 'Components/Comment',\n  component: Comment,\n}\n```\n\n----------------------------------------\n\nTITLE: Finding a Single Record by Primary Key using `find()` in JSX\nDESCRIPTION: The `find()` method searches for a single record using its primary key (defaulting to `id`, unless overridden). It expects the primary key value as an argument. If the record is not found, it throws an error, signifying an exceptional condition. Internally, it utilizes Prisma's `findFirst()` function.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_19\n\nLANGUAGE: jsx\nCODE:\n```\nawait User.find(123)\n```\n\n----------------------------------------\n\nTITLE: Initial Server Directory Setup - Bash\nDESCRIPTION: This sequence of Bash commands installs Node dependencies and sets up the deployment directory structure using PM2's deploy:setup script. Should be executed from project root with all prerequisites already in place, such as a valid pm2.config.js and scripts in package.json.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/self-hosting-redwood.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn install\nyarn deploy:setup\n```\n\n----------------------------------------\n\nTITLE: Building Redwood API with Server File using Yarn\nDESCRIPTION: This shell command triggers the build process for the RedwoodJS API side. Building is a prerequisite for running the server file directly with Node.js, as it transpiles the TypeScript code (including `server.ts`) into JavaScript located in `api/dist`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw build api\n```\n\n----------------------------------------\n\nTITLE: Mapping All Routes with useRoutePaths - RedwoodJS React Hook - JavaScript/JSX\nDESCRIPTION: Illustrates how to use useRoutePaths() to retrieve an object mapping route names to their literal path definitions from the RedwoodJS application's routing configuration. No imports shown, but assumes useRoutePaths is available from '@redwoodjs/router'. Outputs a pretty-printed JSON of the route paths, useful for debugging or introspection.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\nconst routePaths = useRoutePaths()\n\nreturn <pre><code>{JSON.stringify(routePaths, undefined, 2)}</code></pre>\n```\n\n----------------------------------------\n\nTITLE: Starting Storybook with RedwoodJS - Bash\nDESCRIPTION: Starts a local Storybook server for UI component development in isolation within a RedwoodJS project. Requires Storybook to be configured in the project as per RedwoodJS standards. No required parameters; accepts options such as --open, --build, and --port to control behavior. The command launches Storybook on the default port unless overridden and can automatically open the browser. Output is the running Storybook web application.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_130\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood storybook\n```\n\n----------------------------------------\n\nTITLE: Explicit User Field Resolver Object - RedwoodJS/GraphQL Yoga - JSX\nDESCRIPTION: Adds an explicit resolver object for User fields in RedwoodJS, mapping each field manually to its value from the root argument. Useful for customization or adding new computed fields beyond what GraphQL Yoga provides. Dependencies: Redwood service exports, compatible with GraphQL Yoga resolver signatures.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { db } from 'src/lib/db'\\n\\nexport const users = () => {\\n  return db.user.findMany()\\n}\\n\\nexport const Users = {\\n  id: (_args, { root }) => root.id,\\n  email: (_args, { root }) => root.email,\\n  name: (_args, { root }) => root.name,\\n}\n```\n\n----------------------------------------\n\nTITLE: Testing GraphQL Countdown Subscription Example Query\nDESCRIPTION: Provides a sample GraphQL subscription query (`CountdownFromInterval`) intended for testing a countdown functionality within a GraphQL Playground. It subscribes to a `countdown` field with `from` and `interval` arguments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_20\n\nLANGUAGE: ts\nCODE:\n```\n/**\n * To test this Countdown subscription, run the following in the GraphQL Playground:\n *\n * subscription CountdownFromInterval {\n *   countdown(from: 100, interval: 10)\n * }\n */\n```\n\n----------------------------------------\n\nTITLE: Exposing Supabase Environment Variables in RedwoodJS (TOML)\nDESCRIPTION: Updates the `redwood.toml` configuration file to make the `SUPABASE_URL` and `SUPABASE_KEY` environment variables accessible on the web side (frontend) of the RedwoodJS application.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supabase.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n  # ...\n  includeEnvironmentVariables = [\"SUPABASE_URL\", \"SUPABASE_KEY\"]\n```\n\n----------------------------------------\n\nTITLE: Testing Prisma Decimal Type Handling in Jest with String Comparison in JavaScript\nDESCRIPTION: Shows how Prisma Decimal type values are handled: Prisma returns decimals as strings, requiring string-based equality tests in Jest. Demonstrates expected (number) versus received (string) type, and the need to adjust assertions accordingly. No dependencies besides Jest and result.floatingNumber generation. Useful for illustrating Jest's type comparision limitations and highlighting best practices for Prisma Decimal comparisons.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\nExpected: 7420440.088194787\nReceived: '7420440.088194787'\n\nexpect(result.floatingNumber).toEqual(7420440.088194787)\n```\n\n----------------------------------------\n\nTITLE: Adding Margin Above CommentsCell in Article - JavaScript (JSX)\nDESCRIPTION: Wraps the CommentsCell in a div with 'mt-12' to provide spacing above comments in the Article component. Ensures visual separation between the article body and the comments list. Inputs are the article object and summary flag; uses styling via Tailwind CSS.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nconst Article = ({ article, summary = false }) => {\\n  return (\\n    <article>\\n      <header>\\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\\n        </h2>\\n      </header>\\n      <div className=\"mt-2 text-gray-900 font-light\">\\n        {summary ? truncate(article.body, 100) : article.body}\\n      </div>\\n      // highlight-start\\n      {!summary && (\\n        <div className=\"mt-12\">\\n          <CommentsCell />\\n        </div>\\n      )}\\n      // highlight-end\\n    </article>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Deploy Scripts to package.json - NPM Scripts - JSON\nDESCRIPTION: This JSON snippet adds deployment-related scripts to the top-level package.json. The scripts use PM2 to set up and deploy the application in a production environment. Prerequisites: PM2 and proper configuration files (pm2.config.js) must exist, and this should be added under the scripts key in package.json.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/self-hosting-redwood.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n\"scripts\": {\n  \"deploy:setup\": \"pm2 deploy pm2.config.js production setup\",\n  \"deploy\": \"pm2 deploy pm2.config.js production deploy\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Project Owner Resolver - RedwoodJS Service - typescript\nDESCRIPTION: This TypeScript resolver demonstrates how to fetch the owner of a project within the RedwoodJS service architecture. It relies on the 'db' object (typically Prisma client), assumes the presence of a 'project' table/model related to a 'user', and resolves the owner based on the parent project's id. Required dependencies are the database client and the expected RedwoodJS resolver signature, and input includes database context and the parent/root object.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport const Project = {\n  owner: (args, { root, context, info }) => {\n    return db.project.findUnique({ where: { id: root.id } }).user()\n  },\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Article Component Logic in JSX\nDESCRIPTION: Updates the JavaScript 'Article' component (`web/src/components/Article/Article.jsx`) to receive an 'article' object as a prop. It imports `Link` and `routes` from `@redwoodjs/router` to create a link to the article's detail page using its ID. The component displays the article's title (linked), body, and creation timestamp within an `<article>` tag.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_27\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\nimport { Link, routes } from '@redwoodjs/router'\n\n// highlight-next-line\nconst Article = ({ article }) => {\n  return (\n    // highlight-start\n    <article>\n      <header>\n        <h2>\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div>{article.body}</div>\n      <div>Posted at: {article.createdAt}</div>\n    </article>\n    // highlight-end\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Setting Sentry User on Web via Layout - JavaScript (React)\nDESCRIPTION: Shows how to assign the current user for Sentry performance/error monitoring on the client-side using a layout component in a React (JavaScript) application. Uses a React useEffect hook to update Sentry's user context whenever the current user changes, and wraps the application's children for global effect. Dependencies: React, useAuth hook, and Sentry setup. Expected parameters are React children; the output is a layout that sets user data for Sentry. Place in 'web/src/layouts/SentryLayout/SentryLayout.jsx'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/monitoring/sentry.md#_snippet_4\n\nLANGUAGE: JSX\nCODE:\n```\nimport { useEffect } from 'react'\n\nimport { useAuth } from 'src/lib/auth'\nimport Sentry from 'src/lib/sentry'\n\nconst SentryLayout = ({ children }) => {\n  const { currentUser } = useAuth()\n\n  useEffect(() => Sentry.setUser(currentUser), [currentUser])\n\n  return <>{children}</>\n}\n\nexport default SentryLayout\n\n```\n\n----------------------------------------\n\nTITLE: Adding a Basic Page Route in RedwoodJS Router - JSX\nDESCRIPTION: This snippet demonstrates how to define a standard route inside the RedwoodJS Router using path, page, and name props. It maps the root path '/' to a HomePage component and designates the route name as 'home' for named route function generation. Requires prior definition/import of the HomePage component and should be used inside a <Router> structure. The route receives requests, renders HomePage, and its name supports safe link generation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<Route path=\"/\" page={HomePage} name=\"home\" />\n```\n\n----------------------------------------\n\nTITLE: Deploying RedwoodJS Project to Edgio Non-Interactively (Shell)\nDESCRIPTION: This command deploys the RedwoodJS project to Edgio in a non-interactive environment, such as CI/CD. It requires a pre-generated Edgio deploy token obtained from the Edgio Developer Console, passed via the `--token` flag. Replace `XXX` with the actual deploy token.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/edgio.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw deploy edgio --token=XXX\n```\n\n----------------------------------------\n\nTITLE: Forwarding Options to Redwood Vite Dev Server - Bash\nDESCRIPTION: Demonstrates passing Vite Dev Server config options to the Redwood dev command using --fwd, customizing port and disabling browser opening. Dependencies: Redwood CLI, Vite. Parameters: --fwd. Input: Command. Output: Dev servers started with specified options. Limitation: Options must be valid Vite CLI flags.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood dev --fwd=\"--port=1234 --open=false\"\n```\n\n----------------------------------------\n\nTITLE: Installing RedwoodRecord Package using Yarn (Shell)\nDESCRIPTION: A shell command using Yarn Workspaces to add the `@redwoodjs/record` package dependency specifically to the `api` workspace of a RedwoodJS project. This is the first step in setting up RedwoodRecord.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nyarn workspace api add @redwoodjs/record\n```\n\n----------------------------------------\n\nTITLE: Declaring a RedwoodJS Directive with Arguments on a Query (GraphQL)\nDESCRIPTION: Shows how to provide arguments (e.g., `roles: [\"ADMIN\"]`) to a custom directive `@myDirective` when applied to a GraphQL Query (`bars`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\ntype Query {\n  bars: [Bar!]! @myDirective(roles: [\"ADMIN\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching All Records with Optional Sorting using `all()` in JSX\nDESCRIPTION: The `all()` method retrieves all records for a model (e.g., `User`). It acts as a synonym for `where()` but clarifies the intent to select all records. An optional object can be passed as an argument to specify additional properties like `sort` and `orderBy` (using Prisma-like syntax) for ordering the results.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nawait User.all()\nawait User.all({ orderBy: { lastName: 'asc' } })\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Handler for Introspection and Playground Access (RedwoodJS, TypeScript)\nDESCRIPTION: Demonstrates enabling GraphQL introspection and GraphiQL Playground in all environments using the createGraphQLHandler function. You must import and provide authDecoder, getCurrentUser, loggerConfig, directives, sdls, and services. Set allowIntrospection and allowGraphiQL to true for universal access, even in production. Handles database disconnection on unhandled exceptions and should be used with caution due to the increased exposure of schema and data model details.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_60\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const handler = createGraphQLHandler({\n  authDecoder,\n  getCurrentUser,\n  loggerConfig: { logger, options: {} },\n  directives,\n  sdls,\n  services,\n  allowIntrospection: true, // 👉 enable introspection in all environments\n  allowGraphiQL: true, // 👉 enable GraphiQL Playground in all environments\n  onException: () => {\n    // Disconnect from your database with an unhandled exception.\n    db.$disconnect()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Manually Running RedwoodJS Database Seeds (Bash)\nDESCRIPTION: This command allows for the manual execution of the database seed script at any time using the RedwoodJS CLI.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/database-seeds.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma db seed\n```\n\n----------------------------------------\n\nTITLE: Illustrating One-to-Many Database Relationships (Text)\nDESCRIPTION: A text diagram showing the one-to-many relationships between User, Post, and Comment tables in a blog database schema. Arrows indicate the direction, with `•` marking the 'one' side and `<` marking the 'many' side, representing foreign key connections.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n┌───────────┐       ┌────────────┐      ┌────────────┐\n│   User    │       │    Post    │      │  Comment   │\n├───────────┤       ├────────────┤      ├────────────┤\n│ id        │•──┐   │ id         │•──┐  │ id         │\n│ name      │   └──<│ userId     │   └─<│ postId     │\n│ email     │       │ title      │      │ name       │\n└───────────┘       │ body       │      │ message    │\n                    └────────────┘      └────────────┘\n```\n\n----------------------------------------\n\nTITLE: Generating OAuth Function Shell in RedwoodJS (bash)\nDESCRIPTION: Generates a RedwoodJS function scaffold named “oauth”, placing a boilerplate handler at /api/src/functions/oauth/oauth.js. Requires the RedwoodJS CLI (yarn rw) and project context. This shell serves as an entry point for implementing OAuth flows; it requires user-provided logic to complete the operation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g function oauth\n```\n\n----------------------------------------\n\nTITLE: Setting Netlify 404 Redirect When not Prerendering 404s (Diff)\nDESCRIPTION: Demonstrates the diff for updating netlify.toml to redirect all unmatched routes to /index.html with a 404 status, in the case where notFoundPage (404) is not prerendered. Requires editing deployment settings. Ensures the site properly signals 404s for non-existent pages. Input: original TOML config; Output: updated config with 'status = 404'.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_19\n\nLANGUAGE: diff\nCODE:\n```\n[[redirects]]\n  from = \"/*\"\n  to = \"/index.html\"\n- status = 200\n+ status = 404\n```\n\n----------------------------------------\n\nTITLE: Starting the RedwoodJS Development Environment\nDESCRIPTION: This sequence of commands first changes the current directory to the newly created `redwoodblog` project folder. Then, `yarn install` downloads and installs all project dependencies listed in `package.json`. Finally, `yarn redwood dev` starts the RedwoodJS development server, typically making the application accessible at `http://localhost:8910`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/installation.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd redwoodblog\nyarn install\nyarn redwood dev\n```\n\n----------------------------------------\n\nTITLE: Importing the RedwoodJS toHaveCached Jest Matcher (TypeScript)\nDESCRIPTION: Shows how to enable the custom `.toHaveCached` Jest matcher provided by RedwoodJS for cache testing. This is done by importing the `@redwoodjs/testing/cache` module at the top of the test file.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_73\n\nLANGUAGE: ts\nCODE:\n```\n// highlight-next-line\nimport '@redwoodjs/testing/cache'\n// ^^ make `.toHaveCached` available\n```\n\n----------------------------------------\n\nTITLE: Launching RedwoodJS Development Server - Zsh Shell\nDESCRIPTION: Starts the RedwoodJS development server, which hosts both web and API sides of the project. Prerequisite: Project dependencies installed and code generated. Output: Local servers for front-end and back-end, auto-opens browser by default.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_6\n\nLANGUAGE: zsh\nCODE:\n```\nyarn rw dev\n```\n\n----------------------------------------\n\nTITLE: Illustrating Asset Co-location Directory Structure (Text)\nDESCRIPTION: Demonstrates the file layout where an image asset (`logo.png`) is placed directly within the directory of the React component (`Header`) that uses it. This approach leverages Vite's asset handling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/assets-and-files.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nweb/src/components/Header/\n// highlight-next-line\n├── logo.png\n├── Header.js\n├── Header.stories.js\n└── Header.test.js\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with `greaterThan` Option in JSX\nDESCRIPTION: Demonstrates the `numericality` validator using the `greaterThan` option to require the input number to be strictly greater than the specified value.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_33\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.temp, 'Temperature', {\n  numericality: { greaterThan: 32 },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Assigning Default Roles on Signup via Netlify Identity Trigger (JavaScript)\nDESCRIPTION: This code is for a Netlify Identity trigger function (`identity-signup.js`). It intercepts the 'signup' event, parses the user's email, and assigns roles ('author', 'editor', 'publisher') based on patterns found in the email address (e.g., '+author'). The assigned roles are returned in the `app_metadata` field of the response.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nexport const handler = async (req, _context) => {\\n  const body = JSON.parse(req.body)\\n\\n  const eventType = body.event\\n  const user = body.user\\n  const email = user.email\\n\\n  let roles = []\\n\\n  if (eventType === 'signup') {\\n    if (email.includes('+author')) {\\n      roles.push('author')\\n    }\\n\\n    if (email.includes('+editor')) {\\n      roles.push('editor')\\n    }\\n\\n    if (email.includes('+publisher')) {\\n      roles.push('publisher')\\n    }\\n\\n    return {\\n      headers: {\\n        'Content-Type': 'application/json',\\n      },\\n      statusCode: 200,\\n      body: JSON.stringify({ app_metadata: { roles: roles } }),\\n    }\\n  } else {\\n    return {\\n      statusCode: 200,\\n    }\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Prisma in RedwoodJS Netlify Build (TOML)\nDESCRIPTION: This TOML snippet shows how to modify the build command within `netlify.toml` to disable Prisma functionality during deployment. The `--prisma=false` and `--dm=false` flags prevent errors related to missing Prisma schemas when deploying a RedwoodJS app without a database or API layer to Netlify. This snippet focuses specifically on the build command modification.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/disable-api-database.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[build]\n  command = \"yarn rw deploy netlify --prisma=false --dm=false\"\n```\n\n----------------------------------------\n\nTITLE: Running Setup Command for RedwoodJS Mailer - Bash\nDESCRIPTION: This command sets up the RedwoodJS mailer by adding requisite packages and initial configuration files, including an optional sample template. Prerequisites are a RedwoodJS project and Yarn. Use the --skip-examples flag to omit example templates. The command modifies project files and dependencies for email features. Output includes mailer configuration and optionally a sample mail template.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_116\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup mailer\n```\n\n----------------------------------------\n\nTITLE: Default beforeQuery Lifecycle Hook (JSX)\nDESCRIPTION: Provides the default behavior for the beforeQuery lifecycle hook in RedwoodJS Cells, injecting received props as GraphQL variables and setting fetchPolicy to 'cache-and-network'. Inputs: component props; outputs: object with variables and fetchPolicy. Can be customized for advanced use cases.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cells.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nexport const beforeQuery = (props) => {\n  return {\n    variables: props,\n    fetchPolicy: 'cache-and-network',\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Weather Forecast Data with Chart.js in React (JSX)\nDESCRIPTION: Presents the final `HomePage` component integrating data fetching, processing, and Chart.js visualization. It fetches `/forecast.json`, uses helper functions (`getDates`, `getTemps`, `kelvinToFahrenheit`) to transform the JSON data (converting dates and Kelvin temps) into the structure Chart.js requires for labels and datasets. A `useEffect` hook, dependent on the fetched `forecast` data, initializes the Chart.js line graph on a canvas element, displaying high and low temperatures.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/disable-api-database.md#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useState, useEffect, useRef } from 'react'\nimport Chart from 'chart.js'\n\nconst MONTHS = [\n  'Jan',\n  'Feb',\n  'Mar',\n  'Apr',\n  'May',\n  'Jun',\n  'Jul',\n  'Aug',\n  'Sep',\n  'Oct',\n  'Nov',\n  'Dec',\n]\n\n// Helper function to format dates from the forecast data\nconst getDates = (forecast) => {\n  return forecast.list.map((entry) => {\n    const date = new Date(0)\n    date.setUTCSeconds(entry.dt)\n    return `${MONTHS[date.getMonth()]} ${date.getDate()}`\n  })\n}\n\n// Helper function to extract and format temperature data for Chart.js datasets\nconst getTemps = (forecast) => {\n  return [\n    {\n      label: 'High',\n      data: forecast.list.map((entry) => kelvinToFahrenheit(entry.temp.max)),\n      borderColor: 'red',\n      backgroundColor: 'transparent',\n    },\n    {\n      label: 'Low',\n      data: forecast.list.map((entry) => kelvinToFahrenheit(entry.temp.min)),\n      borderColor: 'blue',\n      backgroundColor: 'transparent',\n    },\n  ]\n}\n\n// Helper function to convert Kelvin to Fahrenheit\nconst kelvinToFahrenheit = (temp) => {\n  return ((temp - 273.15) * 9) / 5 + 32\n}\n\nconst HomePage = () => {\n  const chartRef = useRef() // Ref for the canvas element\n\n  const [forecast, setForecast] = useState(null) // State to store fetched forecast data\n\n  // Effect hook to fetch data when the component mounts\n  useEffect(() => {\n    fetch('/forecast.json')\n      .then((response) => response.json())\n      .then((json) => setForecast(json))\n  }, [])\n\n  // Effect hook to create/update the chart when forecast data is available\n  useEffect(() => {\n    if (forecast) { // Only proceed if forecast data has been loaded\n      new Chart(chartRef.current.getContext('2d'), {\n        type: 'line',\n        data: {\n          labels: getDates(forecast), // Use helper to get formatted dates\n          datasets: getTemps(forecast), // Use helper to get formatted temperature datasets\n        },\n      })\n    }\n  }, [forecast]) // Dependency array ensures this runs when forecast state changes\n\n  // Render the canvas element for the chart\n  return <canvas ref={chartRef} />\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Generating a Live Query Event - RedwoodJS CLI - Bash/Plaintext\nDESCRIPTION: This output log shows the process and feedback when using the CLI to scaffold a LiveQuery event. Prompts guide the user through selection, resume, and show file creation. Dependencies: RedwoodJS with realtime features enabled, yarn, proper project setup. Inputs: event name; outputs: new files and TypeScript definitions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_65\n\nLANGUAGE: plaintext\nCODE:\n```\n~/redwood-app$ yarn rw g realtime NewLiveQuery\n? What type of realtime event would you like to create? › - Use arrow-keys. Return to submit.\n❟ Live Query\nCreate a Live Query to watch for changes in data\nSubscription\n\n✔ What type of realtime event would you like to create? › Live Query\n✔ Checking for realtime environment prerequisites ...\n✔ Adding newlivequery example live query ...\n✔ Generating types ...\n```\n\n----------------------------------------\n\nTITLE: Creating Truncated Body String (JavaScript)\nDESCRIPTION: Extracts the first 10 characters from the `article.body` string. This snippet is part of the logic within the refactored `Success` test case to prepare for checking the presence of the truncated text.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst truncatedBody = article.body.substring(0, 10)\n```\n\n----------------------------------------\n\nTITLE: Destroying RedwoodJS Layout Components via CLI\nDESCRIPTION: This command removes a previously generated RedwoodJS layout component and its associated files (component, tests, stories) from the `web/src/layouts` directory. It requires the name of the layout to destroy as an argument. This effectively reverses the `generate layout` command.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood destroy layout <name>\n```\n\n----------------------------------------\n\nTITLE: Environment-Specific Pre/Post Deploy Commands in TOML\nDESCRIPTION: Demonstrates how to define pre- and post-install commands that only run for a specific environment ('production') in your 'deploy.toml' file. These blocks let you fine-tune when hooks are triggered, supporting separation of concerns across different deployment targets. Example commands manage lock files as markers for install events.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_23\n\nLANGUAGE: toml\nCODE:\n```\n[production.before]\ninstall = \"touch prod-install.lock\"\n\n[production.after]\ninstall = \"rm prod-install.lock\"\n\n[production.servers]\nhost = 'server.com'\n# ...\n```\n\n----------------------------------------\n\nTITLE: Highlighting Default GraphQL Query in ArticlesCell (JavaScript/JSX)\nDESCRIPTION: This snippet highlights the default GraphQL query generated within the `ArticlesCell.jsx`. By default, RedwoodJS's cell generator assumes a GraphQL query root field named `articles`, matching the cell name (`ArticlesCell`). This initial query fetches only the `id` field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/components/ArticlesCell/ArticlesCell.jsx\"\nexport const QUERY = gql`\n  query ArticlesQuery {\n    // highlight-next-line\n    articles {\n      id\n    }\n  }\n`\n```\n```\n\n----------------------------------------\n\nTITLE: Sample Redwood Console Usage - Bash\nDESCRIPTION: Exhibits interaction with the Redwood console, including fetching users from the database with 'await db.user.findMany()'. Dependencies: Prisma Client. Inputs: JS command in shell. Outputs: Array of user objects. Limitation: Only Redwood database interaction supported; outputs are sample.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood console\nyarn run v1.22.4\n> await db.user.findMany()\n> [ { id: 1, email: 'tom@redwoodjs.com', name: 'Tom'  } ]\n```\n\n----------------------------------------\n\nTITLE: Initializing Navigation Component with Auth Hooks and Routing (RedwoodJS, JavaScript)\nDESCRIPTION: This snippet defines a Navigation component in RedwoodJS, importing routing helpers and the useAuth hook. It sets up the base for conditional rendering based on the authentication state but currently returns an empty navigation bar. Depends on '@redwoodjs/router' for routing and '@redwoodjs/auth' for authentication context.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_21\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Link, routes } from '@redwoodjs/router'\nimport { useAuth } from '@redwoodjs/auth'\n\nconst Navigation = () => {\n  return <nav></nav>\n}\n\nexport default Navigation\n```\n\n----------------------------------------\n\nTITLE: Cloning and Setting Up RedwoodJS Tutorial Example Repo (Bash)\nDESCRIPTION: These commands clone the RedwoodJS tutorial example repository, navigate into the project directory, install dependencies using Yarn, run database migrations using Prisma, and generate a session secret using the RedwoodJS CLI. This sequence prepares the recommended starting point for Chapter 5 of the tutorial.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/06_intermission.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/redwoodjs/redwood-tutorial\ncd redwood-tutorial\nyarn install\nyarn rw prisma migrate dev\nyarn rw g secret\n```\n\n----------------------------------------\n\nTITLE: Modifying App Title in Redwood Configuration - TOML\nDESCRIPTION: This snippet demonstrates how to update the default application title in a RedwoodJS project by editing the 'title' property in the 'redwood.toml' configuration file. The change ensures that the specified app title is used as the default across all pages unless individually overridden. No external dependencies are required beyond a standard Redwood project setup. The main parameter is the 'title' string in the '[web]' section; setting it will alter the base title tag for the web client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n[web]\n- title = \"Redwood App\"\n+ title = \"My Cool App\"\n  port = 8910\n  apiUrl = \"/.redwood/functions\"\n\n```\n\n----------------------------------------\n\nTITLE: Passing postId Prop to CommentForm in Article (TypeScript)\nDESCRIPTION: This TSX snippet updates the TypeScript version of the `Article` component. It passes the `article.id` to the `CommentForm` component via the `postId` prop. This ensures the `CommentForm` receives the necessary identifier for the post it relates to.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\n```jsx title=\"web/src/components/Article/Article.tsx\"\nimport { Link, routes } from '@redwoodjs/router'\nimport CommentsCell from 'src/components/CommentsCell'\nimport CommentForm from 'src/components/CommentForm'\n\nconst truncate = (text: string, length: number) => {\n  return text.substring(0, length) + '...'\n}\n\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      {!summary && (\n        <div className=\"mt-12\">\n          // highlight-next-line\n          <CommentForm postId={article.id} />\n          <div className=\"mt-12\">\n            <CommentsCell />\n          </div>\n        </div>\n      )}\n    </article>\n  )\n}\n\nexport default Article\n```\n```\n\n----------------------------------------\n\nTITLE: Starting API Side for Render (Example)\nDESCRIPTION: An example command illustrating how to deploy the RedwoodJS 'api' side to Render. This command applies Prisma database migrations, runs data migrations (by default), and starts the API server.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood deploy render api\n```\n\n----------------------------------------\n\nTITLE: Defining About Page with Metadata in RedwoodJS JavaScript\nDESCRIPTION: This component represents an About page that sets metadata for SEO using the Metadata component from @redwoodjs/web and displays a static informational message. No navigation links are present as those are inherited via the layout. Dependencies are @redwoodjs/web. Outputs are rendered metadata and paragraph; inputs are no props required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/layouts.md#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\n\nconst AboutPage = () => {\n  return (\n    <>\n      <Metadata title=\"About\" description=\"About page\" />\n\n      <p>\n        This site was created to demonstrate my mastery of Redwood: Look on my\n        works, ye mighty, and despair!\n      </p>\n    </>\n  )\n}\n\nexport default AboutPage\n```\n\n----------------------------------------\n\nTITLE: Streaming Alphabet Data Using GraphQL with Curl - Bash\nDESCRIPTION: Curl command POSTs a GraphQL query for the `alphabet` field using the `@stream` directive, requesting streaming multipart/mixed response from a RedwoodJS GraphQL server. Key headers `accept:multipart/mixed` and required content-type are included. Variable `-d` passes a JSON query. Endpoint defaults to localhost. For CLI-based live testing of streaming GraphQL responses.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncurl -g -X POST \\\n  -H \"accept:multipart/mixed\" \\\n  -H \"content-type: application/json\" \\\n  -d '{\"query\":\"query StreamAlphabet { alphabet @stream }\"}' \\\n  http://localhost:8911/graphql\n```\n\n----------------------------------------\n\nTITLE: Sample Output: Building Redwood Application - Bash\nDESCRIPTION: Displays the terminal output of successfully building both the API and web sides of a Redwood project. Illustrates the generation of Prisma client and build steps for each side. No dependencies (output reference). Inputs: None. Outputs: Success messages indicating completion of individual and total build processes. Limitations: Output is informational only.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood build\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood build\n✔ Generating the Prisma client...\n✔ Building \"api\"...\n✔ Building \"web\"...\nDone in 17.37s.\n```\n\n----------------------------------------\n\nTITLE: Serving Only the API Side with RedwoodJS - Bash\nDESCRIPTION: Runs a production server instance for only the 'api' side of a RedwoodJS application. Uses the 'apiUrl' as defined in 'redwood.toml'. Required before usage: successful build output for the API side of the project. Parameters include --port, --socket, and --apiRootPath. Output is a backend GraphQL/API server suitable for serverful deployment. Optional log output formatting via piping.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_134\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw serve api\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw serve api | yarn rw-log-formatter\n```\n\n----------------------------------------\n\nTITLE: Protecting RedwoodJS Component Content for a Single Role (JSX)\nDESCRIPTION: This example shows how to protect specific content within a React component (`Post`). It uses the `hasRole` function from the `useAuth` hook to conditionally render a 'Delete' button only if the authenticated user has the 'admin' role.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/role-based-access-control.md#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAuth } from '@redwoodjs/auth'\\n\\nconst Post = ({ post }) => {\\n  const { hasRole } = useAuth()\\n\\n  return (\\n    <nav className=\"rw-button-group\">\\n      {(hasRole('admin')) && (\\n          <a href=\"#\" className=\"rw-button rw-button-red\" onClick={() => onDeleteClick(post.id)}>\\n            Delete\\n          </a>\\n        ))}\\n    </nav>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Boilerplate Cell Query Structure - TypeScript (React TSX)\nDESCRIPTION: This code provides the TypeScript analog to the JavaScript cell query, using RedwoodJS and TypedDocumentNode types. It fetches the default 'articles' query as inferred from the generated cell's name, returning ids only. This is a minimal working Cell query placeholder requiring further customization for field and collection name alignment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\\n  gql`\\n    query ArticlesQuery {\\n      // highlight-next-line\\n      articles {\\n        id\\n      }\\n    }\\n  `\\n\n```\n\n----------------------------------------\n\nTITLE: Querying Testimonials with Prisma in RedwoodJS Service - JavaScript\nDESCRIPTION: Implements a RedwoodJS service function to retrieve a list of testimonials from the database using Prisma ORM. Requires the 'db' object (typically imported from 'src\\/lib\\/db') to interact with the Prisma client. Returns a promise resolving to an array of testimonial objects as defined in Prisma. This function is mapped to a GraphQL query resolver, and expects the Prisma schema\\/client to be set up.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter0/what-is-redwood.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { db } from 'src/lib/db'\n\nexport const testimonials = () => {\n  return db.testimonial.findMany()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Delaying Mock Response using ctx.delay in JSX\nDESCRIPTION: Shows how to use the `ctx.delay()` method inside a mock function handler to introduce an artificial delay (1.5 seconds) before the mock data `{ id: 42 }` is returned. This simulates network latency.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/mocking-graphql-requests.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nmockGraphQLQuery('OperationName', (_variables, { ctx }) => {\n  ctx.delay(1500) // pause for 1.5 seconds\n  return { id: 42 }\n})\n```\n\n----------------------------------------\n\nTITLE: Trigger RedwoodJS GraphQL Types Generation - Bash\nDESCRIPTION: Running this command manually generates TypeScript types based on your Cells' GraphQL queries, ensuring up-to-date types for strongly-typed cell components. Requires RedwoodJS CLI and properly defined queries. This helps resolve import errors for types such as ArticlesQuery or ArticlesQueryVariables.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g types\n```\n\n----------------------------------------\n\nTITLE: Attempting Prisma Database Migration\nDESCRIPTION: This command attempts to apply the schema changes defined in `schema.prisma` to the development database using RedwoodJS's wrapper around Prisma Migrate. It is expected to fail initially if existing users don't have a value for the new required `roles` field.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prisma migrate dev\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS dbAuth Pages via CLI\nDESCRIPTION: This command scaffolds standard authentication pages (login, signup, forgot password, reset password) for RedwoodJS applications using the dbAuth provider. Options allow customization of field labels (`--username-label`, `--password-label`) and enabling WebAuthn support (`--webAuthn`). Note that this only generates the pages; full setup requires `yarn rw setup auth dbAuth`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate dbAuth\n```\n\n----------------------------------------\n\nTITLE: Triggering Test Database Configuration Error\nDESCRIPTION: Illustrates running `yarn rw test` which can lead to a 'Schema Parsing P1012' error if the test database URL is not configured. This error occurs because the Prisma schema requires a valid database URL starting with 'postgresql://' or 'postgres://' for the datasource specified.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/testing.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test\n\nError: Get config: Schema Parsing P1012\n\nerror: Error validating datasource `db`: the URL must start with the protocol `postgresql://` or `postgres://`.\n  -->  schema.prisma:3\n   |\n 2 |   provider = \"postgresql\"\n 3 |   url      = env(\"DATABASE_URL\")\n   |\n\nValidation Error Count: 1\n\nerror Command failed with exit code 1.\n```\n\n----------------------------------------\n\nTITLE: Adding Fastify Plugins to Redwood API Workspace\nDESCRIPTION: This shell command installs Fastify plugins (`@fastify/compress` for payload compression and `@fastify/rate-limit` for rate limiting) as dependencies within the RedwoodJS API workspace using Yarn.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nyarn workspace api add @fastify/compress @fastify/rate-limit\n```\n\n----------------------------------------\n\nTITLE: Manual Deployment Steps for RedwoodJS Workflow (Bash)\nDESCRIPTION: Lists key bash/yarn commands executed during the deployment. These commands handle dependency installation, database migrations, build processes, and directory symlinking. Must be run from a shell in the deployment directory, with necessary dependencies (Yarn, RedwoodJS CLI, Prisma) installed and the proper environment variables in place.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nyarn install\nyarn rw prisma migrate deploy\nyarn rw prisma generate\nyarn rw dataMigrate up\nyarn rw build\nln -nsf \"$(pwd)\" ../current\n\n```\n\n----------------------------------------\n\nTITLE: Clearing the Apollo Cache without Refetch using useCache in TypeScript/JSX\nDESCRIPTION: Demonstrates using the `clearStore` method from the `useCache` hook within a React component. Unlike `resetStore`, this method clears the cache without automatically refetching active queries.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/caching.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst Logout = () => {\n  const { clearStore } = useCache()\n\n  return (\n    <button onClick={() => clearStore()}>\n      Log out\n    </button>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Styling Comments List in Success State with Tailwind - JavaScript\nDESCRIPTION: This React (JavaScript) snippet customizes the Success function of CommentsCell to wrap comments with a div using the Tailwind “space-y-8” class for vertical spacing. It organizes the rendered Comment components for improved visual separation. This expects a comments prop (array) and applies a layout enhancement using Tailwind CSS; no other dependencies are required beyond the previous JavaScript Cell.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nexport const Success = ({ comments }) => {\n  return (\n    // highlight-next-line\n    <div className=\"space-y-8\">\n      {comments.map((comment) => (\n        <Comment comment={comment} key={comment.id} />\n      ))}\n    // highlight-next-line\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Project Folder Structure for Logic Sharing in API Functions - Bash\nDESCRIPTION: This snippet depicts the recommended file structure for organizing functions and their shared libraries in RedwoodJS. It demonstrates best practices by placing libraries alongside function handlers for ease of import and testing. No code execution—structural guidance only. Requirements: follows RedwoodJS src/api convention. Inputs/Outputs: N/A. Fosters clean architecture.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\napi/src\n├── functions\n│   ├── graphql.ts\n│   └── helloWorld\n│   ├── helloWorld.scenarios.ts\n│   ├── helloWorld.test.ts\n│   └── helloWorld.ts    # <-- imports hellWorldLib\n│   └── helloWorldLib.ts # <-- exports can be used in the helloWorld\n```\n\n----------------------------------------\n\nTITLE: Building the Web Side from Base Stage - RedwoodJS - Dockerfile\nDESCRIPTION: This snippet defines the web_build stage, based on the base image, and copies the web/ directory into the container. It then runs 'yarn rw build web --no-prerender' to build the web frontend without prerendering (SSG). Prerequisites include a working RedwoodJS project and necessary dependencies installed in the base stage. The result is a built web application ready for further processing or deployment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_13\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM base as web_build\\n\\nCOPY --chown=node:node web web\\nRUN yarn rw build web --no-prerender\n```\n\n----------------------------------------\n\nTITLE: Updating User Role via RedwoodJS Console\nDESCRIPTION: This command is executed within the RedwoodJS console. It uses the Prisma Client JS API (`db.user.update`) to find a user with `id: 1` and update their `roles` field to 'admin'. This is a direct database modification.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n> db.user.update({ where: { id: 1 } , data: { roles: 'admin' } })\n```\n\n----------------------------------------\n\nTITLE: Displaying Help for RedwoodJS Authentication Setup Command\nDESCRIPTION: Executes the RedwoodJS CLI `setup auth` command with the `--help` flag. This displays usage information and lists supported authentication providers that can be automatically configured within the RedwoodJS application, such as dbAuth (Redwood's built-in database authentication) or third-party providers like Auth0, Firebase, etc.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup auth --help\n```\n\n----------------------------------------\n\nTITLE: Eagerly Loading Pages by Importing in Routes.js - RedwoodJS Bundling - JavaScript/JSX\nDESCRIPTION: Exemplifies explicit import of a page component in Routes.js to override RedwoodJS's default code splitting, ensuring the page is eagerly bundled. Input is a standard ES import statement. Overuse may severely impact bundle size and initial page load times.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_31\n\nLANGUAGE: jsx\nCODE:\n```\nimport HomePage from 'src/pages/HomePage'\n```\n\n----------------------------------------\n\nTITLE: Initializing Memcached Client and Service Cache in RedwoodJS - JavaScript\nDESCRIPTION: Illustrates the initialization of a Memcached client and integration with RedwoodJS's built-in cache utilities. The snippet sets up custom logging, connects to a Memcached server, configures error handling, and exports the `cache` and `cacheFindMany` utility functions. Key dependencies include `@redwoodjs/api/cache` and a Redwood project logger. Environmental configuration can be applied for server address flexibility.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_66\n\nLANGUAGE: js\nCODE:\n```\nimport { createCache, MemcachedClient } from '@redwoodjs/api/cache'\\n\\nimport { logger } from './logger'\\n\\nconst memJsFormattedLogger = {\\n  log: (msg) => logger.error(msg),\\n}\\n\\nlet client\\ntry {\\n  client = new MemcachedClient('localhost:11211', {\\n    logger: memJsFormattedLogger,\\n  })\\n} catch (e) {\\n  console.error(`Could not connect to cache: ${e.message}`)\\n}\\n\\nexport const { cache, cacheFindMany } = createCache(client, {\\n  logger,\\n  timeout: 500,\\n})\n```\n\n----------------------------------------\n\nTITLE: Uninstalling Previous Yarn Versions for Clean Upgrade - Terminal\nDESCRIPTION: Disables Corepack, uninstalls any globally installed Yarn packages using NPM with the '--force' flag, and then re-enables Corepack. This process resolves conflicts that may prevent installing or upgrading Yarn through Corepack. The commands must be run in sequence and may require administrative rights, especially the uninstall step.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-yarn.md#_snippet_3\n\nLANGUAGE: terminal\nCODE:\n```\ncorepack disable\nnpm uninstall -g yarn --force\ncorepack enable\n```\n\n----------------------------------------\n\nTITLE: Console Stage for Debugging and Ephemeral Shell - RedwoodJS - Dockerfile\nDESCRIPTION: This Dockerfile snippet defines an optional 'console' build stage that extends from the base stage. It copies the entire api, web, and scripts directories into the image, and includes instructions (commented out) for installing additional debugging packages such as curl. The stage is intended for debugging via an interactive shell, and is not optimized for image size or for serving applications.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_16\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM base as console\\n\\n# To add more packages:\\n#\\n# ```\\n# USER root\\n#\\n# RUN apt-get update && apt-get install -y \\\\\\n#     curl\\n#\\n# USER node\\n# ```\\n\\nCOPY --chown=node:node api api\\nCOPY --chown=node:node web web\\nCOPY --chown=node:node scripts scripts\n```\n\n----------------------------------------\n\nTITLE: Enabling Corepack for Yarn Management\nDESCRIPTION: This command enables Corepack, a tool included with Node.js (>=16.10) for managing package managers like Yarn and pnpm. Enabling Corepack ensures that the correct version of Yarn is used for a project, as defined in the project's `package.json`. This needs to be run for each installed Node.js version where Yarn management via Corepack is desired.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncorepack enable\n```\n\n----------------------------------------\n\nTITLE: Importing SVG as Image Component in RedwoodJS (JavaScript/JSX)\nDESCRIPTION: Demonstrates importing an SVG asset and using it as a pseudo-component within JSX (although this usage may depend on build setup). No special dependencies besides standard module imports. The 'logo' variable refers to the imported SVG and is used as a JSX element.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\nimport logo from './my-logo.svg'\n\nfunction Header() {\n  return <logo />\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Package to the Web Workspace - Bash\nDESCRIPTION: Installs a new package exclusively in the 'web' (frontend) workspace of a Redwood project using Yarn workspaces. The syntax 'yarn workspace web add package-name' ensures installation and dependency resolution happens within the specified workspace. Replace 'package-name' with the actual desired package. Requires proper workspace setup in package.json.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-yarn.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace web add package-name\n```\n\n----------------------------------------\n\nTITLE: Creating User with Hashed Password via RedwoodJS Console (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to manually create a user in a RedwoodJS application using the Redwood console. It utilizes the `crypto-js` library to generate a salt and hash a given password ('password' in the example) using the PBKDF2 algorithm. Finally, it uses the `db.user.create` method (presumably Prisma Client available as `db` in the console) to insert the new user record with the specified email, the generated hashed password, and the salt. This method is particularly useful if the standard user signup functionality has been disabled.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nconst CryptoJS = require('crypto-js')\nconst salt = CryptoJS.lib.WordArray.random(128 / 8).toString()\nconst hashedPassword = CryptoJS.PBKDF2('password', salt, {\n  keySize: 256 / 32,\n}).toString()\ndb.user.create({\n  data: { email: 'moderator@moderator.com', hashedPassword, salt },\n})\n```\n\n----------------------------------------\n\nTITLE: Running Built Redwood Server File using Node.js\nDESCRIPTION: This shell command demonstrates how to execute the compiled server file (`api/dist/server.js`) directly using Node.js. This replaces the previous method of using `rw-server api` and requires the API to be built first.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn node api/dist/server.js\n```\n\n----------------------------------------\n\nTITLE: Updating Comments Query in RedwoodJS Cell (TSX)\nDESCRIPTION: This snippet shows the TypeScript version of updating the `CommentsQuery` in `CommentsCell.tsx`. It adds the `postId` field to the GraphQL query definition, which is exported as a `TypedDocumentNode` for type safety, ensuring the fetched data structure aligns with expected types.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/rbac.md#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\n//\nexport const QUERY: TypedDocumentNode<CommentsQuery, CommentsQueryVariables> =\n  gql`\n    query CommentsQuery($postId: Int!) {\n      comments(postId: $postId) {\n        id\n        name\n        body\n        // highlight-next-line\n        postId\n        createdAt\n      }\n    }\n  `\n```\n\n----------------------------------------\n\nTITLE: Integrating ArticlesCell into HomePage - TypeScript (React TSX)\nDESCRIPTION: This TypeScript version demonstrates how to import and use the ArticlesCell component within a RedwoodJS homepage, with appropriate type inference for props. Redwood's Metadata component is used for SEO, and the ArticlesCell displays data fetched by the configured query.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Metadata } from '@redwoodjs/web'\\n\\n// highlight-next-line\\nimport ArticlesCell from 'src/components/ArticlesCell'\\n\\nconst HomePage = () => {\\n  return (\\n    <>\\n      <Metadata title=\"Home\" description=\"Home page\" />\\n      // highlight-next-line\\n      <ArticlesCell />\\n    </>\\n  )\\n}\\n\\nexport default HomePage\\n\n```\n\n----------------------------------------\n\nTITLE: Aliasing GraphQL Query Results in Cell (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates using a GraphQL alias within the cell's `QUERY`. By writing `articles: posts`, the data fetched by the `posts` query field will be made available to the `Success` component under the prop name `articles`, overriding the default behavior where the prop name matches the query field name.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nexport const QUERY = gql`\n  query ArticlesQuery {\n    // highlight-next-line\n    articles: posts {\n      id\n    }\n  }\n`\n```\n```\n\n----------------------------------------\n\nTITLE: Alternative User Field Resolver - RedwoodJS - JavaScript\nDESCRIPTION: Provides an alternative implementation for the user relation resolver in the post service, resolving the user by directly querying the user table using the userId from the post object. This method requires that the root object (post) contains a userId property. The main parameter is root, and it outputs the associated user object for the post. This change affects backend resolution of the user field on the Post GraphQL type.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter7/api-side-currentuser.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nexport const Post = {\n  user: (_obj, { root }) => db.user.findFirst({ where: { id: root.userId } }),\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring the API URL in redwood.toml\nDESCRIPTION: Demonstrates the configuration of the `apiUrl` within the `redwood.toml` file. This setting defines the base path for accessing serverless functions from the frontend, facilitating proxying during development and proper routing in deployment environments to avoid CORS issues. The default development value is typically `/.redwood/functions`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n# redwood.toml\n\n[web]\n  port = 8910\n  apiUrl = \"/.redwood/functions\"\n```\n\n----------------------------------------\n\nTITLE: Identifying Normalized Entities in Apollo Cache via useCache.identify (TypeScript)\nDESCRIPTION: Illustrates how to obtain the cache ID of a normalized object using the identify function from useCache. This is useful for referencing cache entities or when you need to manipulate them directly. The returned string includes the typename and unique ID.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_35\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst Fruit = ({ id }: { id: FragmentIdentifier }) => {\n  const { identify } = useCache()\n  const { data: fruit, complete } = useRegisteredFragment<Fruit>(id)\n\n  // Returns \"Fruit:ownpc6co8a1w5bhfmavecko9\"\n  console.log(identify(fruit))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Primary Key for a RedwoodRecord Model in JSX\nDESCRIPTION: This snippet demonstrates how to override the default primary key (`id`) for a RedwoodRecord model (`User`). By defining a static `primaryKey` property within the class definition, you can specify a different field (e.g., `ident`) to be used as the primary identifier for find operations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\nexport default class User extends RecordRecord {\n  static primaryKey = 'ident'\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Database Named After the Current User (Bash)\nDESCRIPTION: Creates a PostgreSQL database with the same name as the current Unix user, using the createdb command. Requires PostgreSQL binaries to be in PATH and running Postgres instance. No parameters required; uses $(whoami) for username.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ createdb $(whoami)\n```\n\n----------------------------------------\n\nTITLE: Generating Realtime Events (LiveQuery/Subscription) with RedwoodJS CLI - Bash\nDESCRIPTION: This Bash snippet demonstrates using the RedwoodJS CLI to scaffold a new realtime event (either a LiveQuery or Subscription). Prompts occur if type isn't specified. Dependencies: a RedwoodJS project with realtime support, yarn CLI. Takes 'name' parameter and optional type flag. Output is creation of event boilerplate and console output confirming steps taken.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_64\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate realtime <name>\n```\n\n----------------------------------------\n\nTITLE: Using the Length Validator with `min` Option in JSX\nDESCRIPTION: Demonstrates the `length` validator using only the `min` option to ensure the input string has at least a specified number of characters.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_24\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.name, 'Name', {\n  length: { min: 2 },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Adding a TextField to a RedwoodJS Form (TSX)\nDESCRIPTION: This snippet demonstrates adding a text input field to the `ContactPage` form using the `TextField` component from `@redwoodjs/forms` in TypeScript. The `TextField` is given a `name` attribute set to \"input\".\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/forms.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nimport { Metadata } from '@redwoodjs/web'\n// highlight-next-line\nimport { Form, TextField } from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form>\n        // highlight-next-line\n        <TextField name=\"input\" />\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Login Form Component - Bash\nDESCRIPTION: This command creates a new React component template for the passwordless login form within Redwood's web/src/components directory. The component collects user email addresses for initiating the login flow. No arguments required aside from the desired component name; generates both JS and TSX variants based on project configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/dbauth-passwordless.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g component LoginPasswordlessForm\n```\n\n----------------------------------------\n\nTITLE: Reloading Shell Configuration (Shell)\nDESCRIPTION: The `source` command reads and executes commands from the specified file (here, `~/.bashrc`) in the current shell environment. This is used to apply changes made to shell configuration files, such as updating the `PS1` prompt variable or adding aliases, immediately without needing to restart the shell session.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_30\n\nLANGUAGE: shell\nCODE:\n```\nsource ~/.bashrc\n```\n\n----------------------------------------\n\nTITLE: Wrapping Home Page with Global Layout (RedwoodJS, JavaScript)\nDESCRIPTION: Defines the HomePage component in RedwoodJS, wrapping page content within the GlobalLayout to ensure consistent navigation and styling. Assumes the GlobalLayout and other dependencies are already set up. Displays a static Home heading and subtitle.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_26\n\nLANGUAGE: jsx\nCODE:\n```\nimport GlobalLayout from 'src/layouts/GlobalLayout/GlobalLayout'\n\nconst HomePage = () => {\n  return (\n    <GlobalLayout>\n      <h1>Home</h1>\n      <p>My Gotrue Redwood Auth</p>\n    </GlobalLayout>\n  )\n}\n\nexport default HomePage\n```\n\n----------------------------------------\n\nTITLE: Generating a Page with Redwood CLI in Bash\nDESCRIPTION: This command utilizes the RedwoodJS CLI (`yarn redwood`) to scaffold a new page named 'about'. It automatically creates the necessary page component file (e.g., `AboutPage.jsx`/`tsx`), associated test files, and adds a corresponding route in `Routes.jsx`/`tsx`. Since no path is specified, Redwood defaults the route path to `/about`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/second-page.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate page about\n```\n\n----------------------------------------\n\nTITLE: Server-Specific Pre/Post Deploy Commands in TOML\nDESCRIPTION: Shows the syntax for setting up before and after commands at the server configuration level within 'deploy.toml'. These apply only to the specified server entry and may override or augment more general hooks. This granularity allows for server-unique pre/post tasks in the deployment lifecycle.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_24\n\nLANGUAGE: toml\nCODE:\n```\n[[production.servers]]\nhost = 'server.com'\n# ...\nbefore.install = 'touch server-install.lock'\nafter.install = 'rm server-install.lock'\n```\n\n----------------------------------------\n\nTITLE: Example Output: Running RedwoodJS API Development Server\nDESCRIPTION: This output demonstrates running the RedwoodJS API development server using `yarn redwood dev api`. It shows the server starting, listening on a specific port (8911), watching for file changes, and listing the available API endpoints, including the default GraphQL endpoint and the newly generated `/user` function endpoint.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_47\n\nLANGUAGE: plaintext\nCODE:\n```\n~/redwood-app$ yarn redwood dev api\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood dev api\n$ /redwood-app/node_modules/.bin/dev-server\n17:21:49 api | Listening on http://localhost:8911\n17:21:49 api | Watching /home/dominic/projects/redwood/redwood-app/api\n17:21:49 api |\n17:21:49 api | Now serving\n17:21:49 api |\n17:21:49 api | ► http://localhost:8911/graphql/\n17:21:49 api | ► http://localhost:8911/user/\n```\n\n----------------------------------------\n\nTITLE: Resetting the Apollo Cache using useCache in TypeScript/JSX\nDESCRIPTION: Illustrates using the `resetStore` method from the `useCache` hook within a React component, typically triggered by a button click (e.g., logout). This method completely clears the Apollo cache and refetches active queries.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/caching.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { useCache } from '@redwoodjs/web/apollo'\n\nconst Logout = () => {\n  const { resetStore } = useCache()\n\n  return (\n    <button onClick={() => resetStore()}>\n      Log out\n    </button>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Article Page with RedwoodJS CLI (Bash)\nDESCRIPTION: This snippet runs a RedwoodJS CLI command to generate a new page named Article. It sets up the starter files and boilerplate for an article detail page. Requires the RedwoodJS CLI and assumes the project is initialized and dependencies are installed. There are no parameters; output is a new page file scaffolded under the `web/src/pages/ArticlePage/` directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g page Article\n```\n\n----------------------------------------\n\nTITLE: Querying Post IDs using GraphQL\nDESCRIPTION: A basic GraphQL query designed to fetch the unique identifier (`id`) for all entries available through the `posts` query. This query is intended to be executed within the GraphQL Playground against the running RedwoodJS API to retrieve a list of post IDs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_9\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  posts {\n    id\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query and Prop Mapping with RedwoodJS Cells - TypeScript\nDESCRIPTION: This TypeScript code demonstrates how the queried field name ('posts') determines the prop name ('posts') received by the Cell Success component. The query is strongly typed using TypedDocumentNode, aligning types for safe usage in Cell components.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/cells.md#_snippet_14\n\nLANGUAGE: ts\nCODE:\n```\nexport const QUERY: TypedDocumentNode<ArticlesQuery, ArticlesQueryVariables> =\\n  gql`\\n    query ArticlesQuery {\\n      // highlight-next-line\\n      posts {\\n        id\\n      }\\n    }\\n  `\\n\n```\n\n----------------------------------------\n\nTITLE: Default PM2 Ecosystem Configuration (JavaScript/JSX)\nDESCRIPTION: This is the default `ecosystem.config.js` file generated by the setup command. It configures PM2 to run the `yarn rw serve` command, which serves both the API and web sides of the RedwoodJS application, typically on port 8910. It uses cluster mode for better performance.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nmodule.exports = {\n  apps: [\n    {\n      name: 'serve',\n      cwd: 'current',\n      script: 'node_modules/.bin/rw',\n      args: 'serve',\n      instances: 'max',\n      exec_mode: 'cluster',\n      wait_ready: true,\n      listen_timeout: 10000,\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a Global Cache Key Prefix (JavaScript)\nDESCRIPTION: This snippet demonstrates how to apply a global prefix to all cache keys during cache client initialization. Using createCache, it configures logging, timeout, and a prefix (such as 'alpha'), which will be prepended to all cache keys, enabling global cache invalidation strategies. Dependencies: 'createCache', a cache client, and logger. Parameters include client, logger, timeout, and prefix. Intended for use in service-layer initialization files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_63\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const { cache, cacheFindMany } = createCache(client, {\n  logger,\n  timeout: 500,\n  // highlight-next-line\n  prefix: 'alpha',\n})\n```\n\n----------------------------------------\n\nTITLE: Initial Update Post Attempt with User ID Check in Prisma\nDESCRIPTION: This snippet shows an initial, incorrect attempt to implement the `updatePost` service function. It tries to include `userId: context.currentUser.id` directly in the `where` clause of `db.post.update`. This approach fails because Prisma's `update` operation typically requires the `where` clause to specify fields with unique constraints (like `id`), not compound conditions involving non-unique fields like `userId` for identifying the record to update.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/10_chapter7/api-side-currentuser.md#_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nexport const updatePost = ({ id, input }) => {\n  return db.post.update({\n    data: input,\n    // highlight-next-line\n    where: { id, userId: context.currentUser.id },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Persisted Documents JSON Mapping in RedwoodJS\nDESCRIPTION: This JSON file (`web/src/graphql/persisted-documents.json`) is generated during the RedwoodJS build or type generation process when Trusted Documents are enabled. It contains a mapping between SHA-256 hashes (keys) and their corresponding full GraphQL query strings (values). This file is primarily used for reference or potentially by client-side tooling.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"4dd4c49aef34e20af52efb50a1d0ebb0b8062b6d\": \"query FindAuthorQuery($id: Int!) { __typename author: user(id: $id) { __typename email fullName } }\",\n  \"46e9823d95110ebb2ef17ef82fff5c19a468f8a6\": \"query FindBlogPostQuery($id: Int!) { __typename blogPost: post(id: $id) { __typename author { __typename email fullName } body createdAt id title } }\",\n  \"421bcffdde84d448ec1a1b30b36eaeb966f00257\": \"query BlogPostsQuery { __typename blogPosts: posts { __typename author { __typename email fullName } body createdAt id title } }\",\n  \"f6ae606548009c2cd4c69b9aecebad0a730ba23d\": \"mutation DeleteContactMutation($id: Int!) { __typename deleteContact(id: $id) { __typename id } }\",\n  \"f7d2df28fcf87b0c29d225df79363d1c69159916\": \"query FindContactById($id: Int!) { __typename contact: contact(id: $id) { __typename createdAt email id message name } }\",\n  \"7af93a7e454d9c59bbb77c14e0c78e99207fd0c6\": \"query FindContacts { __typename contacts { __typename createdAt email id message name } }\",\n  \"e01ad8e899ac908458eac2d1f989b88160a0494b\": \"query EditContactById($id: Int!) { __typename contact: contact(id: $id) { __typename createdAt email id message name } }\",\n  \"94f51784b918a52e9af64f3c1fd4356903b611f8\": \"mutation UpdateContactMutation($id: Int!, $input: UpdateContactInput!) { __typename updateContact(id: $id, input: $input) { __typename createdAt email id message name } }\",\n  \"da35778949e1e8e27b7d1bb6b2a630749c5d7060\": \"mutation CreateContactMutation($input: CreateContactInput!) { __typename createContact(input: $input) { __typename id } }\",\n  \"4f880f909a16b7fe15898fe33a2ee26933466719\": \"query EditPostById($id: Int!) { __typename post: post(id: $id) { __typename authorId body createdAt id title } }\",\n  \"32b9225df81ff7845fedfa6d5c86c5d4a76073d2\": \"mutation UpdatePostMutation($id: Int!, $input: UpdatePostInput!) { __typename updatePost(id: $id, input: $input) { __typename authorId body createdAt id title } }\",\n  \"daf229dcea085f1beff91102a63c2ba9c88e8481\": \"mutation CreatePostMutation($input: CreatePostInput!) { __typename createPost(input: $input) { __typename id } }\",\n  \"e3405f6dcb6460943dd604423f0f517bc8318aaa\": \"mutation DeletePostMutation($id: Int!) { __typename deletePost(id: $id) { __typename id } }\",\n  \"43a94ad9a150aa7a7a665c73a931a5b18b6cc28b\": \"query FindPostById($id: Int!) { __typename post: post(id: $id) { __typename authorId body createdAt id title } }\",\n  \"76308e971322b1ece4cdff75185bb61d7139e343\": \"query FindPosts { __typename posts { __typename authorId body createdAt id title } }\",\n  \"287beba179ef2c4448b4d3b150701993eddc07d6\": \"query BlogPostsQueryTrustedPage { __typename blogPosts: posts { __typename author { __typename email fullName } body createdAt id title } }\"\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Function Test Suite - Bash\nDESCRIPTION: This bash command uses Yarn with RedwoodJS CLI to execute the test suite for the 'divide' serverless function. It can be run from the project root, requires RedwoodJS CLI, and outputs test results to the terminal. No input or output parameters beyond standard CLI usage.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test api divide\n\n```\n\n----------------------------------------\n\nTITLE: Fetching Deferred Fast and Slow Fields - GraphQL Query\nDESCRIPTION: GraphQL query demonstrating use of the `@defer` directive. Requests `slowField` (deferred) and `fastField` (immediate). Requires a schema supporting those fields and `@defer`. Returns partial response for `fastField` instantly, and full data with `slowField` when available. This approach is useful for efficient partial data delivery.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_7\n\nLANGUAGE: graphql\nCODE:\n```\nquery SlowAndFastFieldWithDefer {\n  ... on Query @defer {\n    slowField\n  }\n  fastField\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating RedwoodJS Cell Naming Conventions (Bash)\nDESCRIPTION: These commands illustrate various naming conventions (snake_case, kebab-case, camelCase, PascalCase) accepted by the RedwoodJS cell generator (`yarn rw g cell`). All these examples will generate a cell component file named `web/src/components/BlogArticlesCell/BlogArticlesCell.{jsx,tsx}`. Using a single concatenated word like `blogarticles` results in a differently named component file (`web/src/components/BlogarticlesCell/BlogarticlesCell.{jsx,tsx}`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/cells.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g cell blog_articles\nyarn rw g cell blog-articles\nyarn rw g cell blogArticles\nyarn rw g cell BlogArticles\n```\n\n----------------------------------------\n\nTITLE: Verifying All Mock Comments Display in CommentsCell Success Test with RedwoodJS (JavaScript)\nDESCRIPTION: This enhanced test for CommentsCell in JavaScript ensures that, upon successful rendering, each comment body from the mock data appears in the DOM. Utilizing @redwoodjs/testing/web's render and screen tools, it loops through the comments array provided by the mock and asserts each comment's body is present. Inputs include the full list of mock comments passed as props. Outputs are tested via DOM queries to confirm each body is displayed. It requires all previously listed dependencies, including the CommentsCell component and its mocks.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\n// highlight-next-line\nimport { render, screen } from '@redwoodjs/testing/web'\n\nimport { Loading, Empty, Failure, Success } from './CommentsCell'\nimport { standard } from './CommentsCell.mock'\n\ndescribe('CommentsCell', () => {\n  it('renders Loading successfully', () => {\n    expect(() => {\n      render(<Loading />)\n    }).not.toThrow()\n  })\n\n  it('renders Empty successfully', async () => {\n    expect(() => {\n      render(<Empty />)\n    }).not.toThrow()\n  })\n\n  it('renders Failure successfully', async () => {\n    expect(() => {\n      render(<Failure error={new Error('Oh no')} />)\n    }).not.toThrow()\n  })\n\n  it('renders Success successfully', async () => {\n    // highlight-start\n    const comments = standard().comments\n    render(<Success comments={comments} />)\n\n    comments.forEach((comment) => {\n      expect(screen.getByText(comment.body)).toBeInTheDocument()\n    })\n    // highlight-end\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Home Page using Bash\nDESCRIPTION: This snippet shows the command to generate a new page named 'Home' mapped to the root path ('/') using the RedwoodJS CLI. This page is intended as the redirection target after a successful user sign-in.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/gotrue-auth.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn redwood generate page Home /\n```\n```\n\n----------------------------------------\n\nTITLE: Editing .env for Production Database - Bash (vim) and Env\nDESCRIPTION: The Bash command opens the project's .env file in vim on the server. The following env snippet sets the DATABASE_URL variable for a local Postgres instance, which is essential for application connectivity. This should be placed in /home/deploy/redwood-pm2/current/.env and tailored to your DB credentials and connection string.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/self-hosting-redwood.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nvim /home/deploy/redwood-pm2/current/.env\n```\n\nLANGUAGE: env\nCODE:\n```\nDATABASE_URL=postgres://postgres:postgres@localhost:5432/redwood-pm2\n```\n\n----------------------------------------\n\nTITLE: Serving RedwoodJS API with Log Formatting (Bash)\nDESCRIPTION: Demonstrates running a RedwoodJS server and piping its log output through the CLI formatter for enhanced readability. Assumes installed RedwoodJS CLI and presence of rw-log-formatter binary. Input: output from 'yarn rw serve' (or 'yarn rw serve api'). Output: real-time formatted logs in the terminal. Useful for seeing human-friendly logs in production-like environments or CI/CD pipelines, noting that log levels may need to be lowered from the default for full output.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw serve | yarn rw-log-formatter\nyarn rw serve api | yarn rw-log-formatter\n```\n\n----------------------------------------\n\nTITLE: Importing ValidatorDirectiveFunc for Redwood Directives in TypeScript\nDESCRIPTION: Shows the necessary import statement to bring the `ValidatorDirectiveFunc` utility type and the `createValidatorDirective` function from `@redwoodjs/graphql-server` into scope for defining custom Redwood validator directives.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/typescript/utility-types.md#_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  createValidatorDirective,\n  // highlight-next-line\n  ValidatorDirectiveFunc,\n} from '@redwoodjs/graphql-server'\n```\n\n----------------------------------------\n\nTITLE: Configuring Studio GraphiQL Impersonation for Netlify Auth (TOML)\nDESCRIPTION: Configures RedwoodJS Studio's GraphiQL auth impersonation feature for the Netlify provider within the `redwood.toml` file. Since Netlify doesn't expose the production JWT secret, a `jwtSecret` must be explicitly provided in the configuration for token encoding and decoding during impersonation. The settings specify the provider (`netlify`), user details, and the required secret.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/studio.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[studio.graphiql.authImpersonation]\n  authProvider = \"netlify\"\n  email = \"user@example.com\"\n  userId = \"1\"\n  jwtSecret = \"some-secret-setting\"\n```\n\n----------------------------------------\n\nTITLE: Initial Failing Test for ArticlesCell Success State (JSX)\nDESCRIPTION: A test case for the `Success` state of the `ArticlesCell` component using JSX. It asserts that the rendered output includes the article title and a specific hardcoded truncated string. This approach is brittle as it depends on the exact truncation output.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\ntest('Success renders successfully', async () => {\n  const articles = standard().articles\n  render(<Success articles={articles} />)\n\n  // highlight-start\n  expect(screen.getByText(articles[0].title)).toBeInTheDocument()\n  expect(\n    screen.getByText(\n      'Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Str...'\n    )\n  ).toBeInTheDocument()\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Default Structure of RedwoodJS NotFoundPage Component (JSX)\nDESCRIPTION: Illustrates the basic structure of the default `NotFoundPage.jsx` provided in a RedwoodJS project. It shows a simple functional component rendering basic HTML elements for a 404 page.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_38\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/NotFoundPage/NotFoundPage.jsx\"\nexport default () => (\n  <main>\n    // ... some custom css\n    <section>\n      <h1>\n        <span>404 Page Not Found</span>\n      </h1>\n    </section>\n  </main>\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up an NPM Package with RedwoodJS Setup Command - Bash\nDESCRIPTION: This command uses Redwood's custom setup logic to run an npm package's setup routine, automatically checking compatibility with the project's RedwoodJS version. It installs and runs the setup of the specified community or official package, handling version checks unless --force is supplied. Requires a valid RedwoodJS project root and Yarn. Inputs are the npm package name and optional flags, and outputs are determined by the executed package's bin script. Used for project scaffolding and feature extension.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_117\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood setup package <npm-package>\n```\n\n----------------------------------------\n\nTITLE: Specifying Node.js Runtime for Vercel API Function (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to explicitly set the Node.js runtime version for a Vercel serverless function (e.g., Node 20.x). Placing this export at the top level of the API function file ensures that the correct runtime environment is used during deployment and execution. No additional parameters are required, but the function file must reside within the Redwood api directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/vercel.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport const config = {\\n  runtime: 'nodejs20.x',\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Example authorized_keys File Entry with Comment\nDESCRIPTION: Provides an example format for adding a public key to the `authorized_keys` file on a server. It includes the public key itself (starting with `ssh-ed25519`...) on one line, preceded by a comment line (`#`) to help identify the key's owner and origin (e.g., user name and their machine's hostname).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_22\n\nLANGUAGE: text\nCODE:\n```\n# Rob Cameron (optimus-prime)\nssh-ed25519 AAAAB3NzaC1yc2EAAAADAQAB<REDACTED>CU90x/khqD1sDW= rob@computer.local\n```\n\n----------------------------------------\n\nTITLE: Injecting GitHub Actions Secret as Database URL - GitHub Actions YAML\nDESCRIPTION: This YAML snippet demonstrates how to securely inject the DATABASE_URL secret into a GitHub Actions workflow's environment variables. It allows the workflow to connect to an external Postgres database using a connection string stored as a repository secret. This prevents sensitive credentials from being hard-coded in workflow files. The snippet assumes the secret 'DATABASE_URL' is already configured in the repository settings and is used wherever a database connection is required in subsequent workflow steps.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/test-in-github-actions.md#_snippet_11\n\nLANGUAGE: YAML\nCODE:\n```\nenv:\\n  DATABASE_URL: ${{ secrets.DATABASE_URL }}\\n\n```\n\n----------------------------------------\n\nTITLE: Initializing logDNA Logging Stream in RedwoodJS (JavaScript)\nDESCRIPTION: Configures pino-logdna as a transport stream for Redwood's logger by supplying an ingestion key from the environment and an error handler. This code must be placed in 'api/src/lib/logger.ts' after installing the relevant package. It initializes the logger so logs are forwarded to logDNA via the created stream.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nimport pinoLogDna from 'pino-logdna'\n\nconst stream = pinoLogDna({\n  key: process.env.LOGDNA_INGESTION_KEY,\n  onError: console.error,\n})\n\n/**\n * Creates a logger with RedwoodLoggerOptions\n *\n * These extend and override default LoggerOptions,\n * can define a destination like a file or other supported pino log transport stream,\n * and sets whether or not to show the logger configuration settings (defaults to false)\n *\n * @param RedwoodLoggerOptions\n *\n * RedwoodLoggerOptions have\n * @param {options} LoggerOptions - defines how to log, such as redaction and format\n * @param {string | DestinationStream} destination - defines where to log, such as a transport stream or file\n * @param {boolean} showConfig - whether to display logger configuration on initialization\n */\nexport const logger = createLogger({\n  options: {},\n  destination: stream,\n})\n```\n\n----------------------------------------\n\nTITLE: Starting PM2 Service on System Boot - Bash\nDESCRIPTION: This snippet shows the command to generate and configure a startup script for PM2 so that managed processes are automatically booted when the server restarts. Requires PM2 to be installed globally (via npm/yarn) on the server, and sufficient user permissions. The output prompts for copying a root-level command to complete registration; actual commands may vary based on your system and PM2 version.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\npm2 startup\n```\n\n----------------------------------------\n\nTITLE: Listing Remote Node.js Versions Available via nvm\nDESCRIPTION: This command queries the nvm repository to list all Node.js versions available for installation. It helps users identify specific version numbers they might want to install.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnvm ls-remote\n```\n\n----------------------------------------\n\nTITLE: Accessing Raw Cache Client in RedwoodJS Service (JavaScript)\nDESCRIPTION: Demonstrates how to access the underlying raw cache client (e.g., Redis or Memcached) directly within a RedwoodJS service function. This allows using specific client methods, like `MSET` shown here for setting multiple key-value pairs, that might not be exposed by the standard `cache()` or `cacheFindMany()` helpers. The example updates a post in the database and then explicitly sets two related cache entries using the imported `cacheClient` after stringifying the post data.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_58\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nimport { cacheClient } from 'src/lib/cache'\n\nexport const updatePost = async ({ id, input }) => {\n  const post = await db.post.update({\n    data: input,\n    where: { id },\n  })\n  // highlight-next-line\n  await cacheClient.MSET(\n    `post-${id}`,\n    JSON.stringify(post),\n    `blogpost-${id}`,\n    JSON.stringify(post)\n  )\n\n  return post\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Installing pino-logdna in RedwoodJS (bash)\nDESCRIPTION: Supplies the Yarn command to add the pino-logdna logger transport as a dependency within the 'api' workspace. It must be executed before using the pino-logdna module in your project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace api add pino-logdna\n```\n\n----------------------------------------\n\nTITLE: Testing Function Method Restriction with curl (POST) using Bash\nDESCRIPTION: Uses the `curl` command-line tool to send an HTTP POST request (`-XPOST`) to the `serverTime` function endpoint running on the development server (`http://localhost:8911/serverTime`). The `-I` flag tells curl to fetch only the HTTP headers. This command is used to test the HTTP method filtering implemented in the function handler, expecting a 404 response.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncurl -XPOST http://localhost:8911/serverTime -I\n```\n\n----------------------------------------\n\nTITLE: Initial Failing Test for ArticlesCell Success State (TSX)\nDESCRIPTION: A test case for the `Success` state of the `ArticlesCell` component using TSX (TypeScript). It asserts that the rendered output includes the article title and a specific hardcoded truncated string. This is the TypeScript equivalent of the brittle initial test.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/first-test.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\ntest('Success renders successfully', async () => {\n  const articles = standard().articles\n  render(<Success articles={articles} />)\n\n  // highlight-start\n  expect(screen.getByText(articles[0].title)).toBeInTheDocument()\n  expect(\n    screen.getByText(\n      'Neutra tacos hot chicken prism raw denim, put a bird on it enamel pin post-ironic vape cred DIY. Str...'\n    )\n  ).toBeInTheDocument()\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring API Host/Port in redwood.toml\nDESCRIPTION: This TOML snippet shows the configuration within the `redwood.toml` file. Setting `host` and `port` under the `[api]` section provides default values for the API server's listening address if not overridden by environment variables or command-line flags.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/server-file.md#_snippet_14\n\nLANGUAGE: toml\nCODE:\n```\n[api]\n  host = '0.0.0.0'\n  port = 8913\n```\n\n----------------------------------------\n\nTITLE: Styling FieldError Components in RedwoodJS Form (JSX)\nDESCRIPTION: This JSX snippet enhances the previous example by adding the `className=\"error\"` prop to each `<FieldError>` component. This allows applying specific CSS styles (defined in an external `.error` class) to the error messages when they are displayed, improving visual feedback for validation errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_23\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport { Metadata } from '@redwoodjs/web'\nimport {\n  FieldError,\n  Form,\n  TextField,\n  TextAreaField,\n  Submit,\n} from '@redwoodjs/forms'\n\nconst ContactPage = () => {\n  const onSubmit = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <>\n      <Metadata title=\"Contact\" description=\"Contact page\" />\n\n      <Form onSubmit={onSubmit}>\n        <label htmlFor=\"name\">Name</label>\n        <TextField name=\"name\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"name\" className=\"error\" />\n\n        <label htmlFor=\"email\">Email</label>\n        <TextField name=\"email\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"email\" className=\"error\" />\n\n        <label htmlFor=\"message\">Message</label>\n        <TextAreaField name=\"message\" validation={{ required: true }} />\n        // highlight-next-line\n        <FieldError name=\"message\" className=\"error\" />\n\n        <Submit>Save</Submit>\n      </Form>\n    </>\n  )\n}\n\nexport default ContactPage\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Studio GraphiQL Impersonation for Supabase Auth (TOML)\nDESCRIPTION: Configures RedwoodJS Studio's GraphiQL auth impersonation feature for the Supabase provider within the `redwood.toml` file. This configuration requires a `SUPABASE_JWT_SECRET` environment variable to be set for proper JWT signing during impersonation. The settings specify the authentication provider (`supabase`) and the details of the user to impersonate.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/studio.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[studio.graphiql.authImpersonation]\n  authProvider = \"supabase\"\n  email = \"user@example.com\"\n  userId = \"1\"\n```\n\n----------------------------------------\n\nTITLE: Initializing Papertrail Logging Stream in RedwoodJS (JavaScript)\nDESCRIPTION: Demonstrates the initialization and configuration of pino-papertrail as the logging transport for RedwoodJS. Essential settings such as appname, host, and port must be substituted with real Papertrail credentials. Shows how to set the logger's destination for logs to be sent to Papertrail, and documents available options and expected usage.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\nimport papertrail from 'pino-papertrail'\n\nconst stream = papertrail.createWriteStream({\n  appname: 'my-app',\n  host: '*****.papertrailapp.com',\n  port: '*****',\n})\n\n/**\n * Creates a logger with RedwoodLoggerOptions\n *\n * These extend and override default LoggerOptions,\n * can define a destination like a file or other supported pino log transport stream,\n * and sets whether or not to show the logger configuration settings (defaults to false)\n *\n * @param RedwoodLoggerOptions\n *\n * RedwoodLoggerOptions have\n * @param {options} LoggerOptions - defines how to log, such as redaction and format\n * @param {string | DestinationStream} destination - defines where to log, such as a transport stream or file\n * @param {boolean} showConfig - whether to display logger configuration on initialization\n */\nexport const logger = createLogger({\n  options: {},\n  destination: stream,\n})\n```\n\n----------------------------------------\n\nTITLE: Validating Presence with allowNull Option using JavaScript/JSX\nDESCRIPTION: This snippet validates that an input value is present, allowing null values to be considered present by setting the allowNull option. The validate function is called with the value to check, a field name label, and configuration object. By default, null is not allowed unless allowNull is true. Returns a pass for null and empty string, and fails for undefined. Requires a validation library exposing validate().\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_43\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.value, 'Value', {\n  presence: { allowNull: true },\n})\n// `null` passes\n// `undefined` fails\n// \"\" passes\n\n```\n\n----------------------------------------\n\nTITLE: Asserting Article Title Presence in React Test (JavaScript)\nDESCRIPTION: This code asserts that the article title is present in the rendered output. It is part of a test suite that ensures post summaries render correctly. The input is an article title, and the output is a Jest assertion result.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nexpect(screen.getByText(article.title)).toBeInTheDocument()\n\n```\n\n----------------------------------------\n\nTITLE: Using the Length Validator with Custom Message and Interpolation in JSX\nDESCRIPTION: Illustrates providing a custom error message for the `length` validator that uses string interpolation. Placeholders like `${name}`, `${min}`, and `${max}` can be used within the message string (using single or double quotes, not backticks) to include the field name and length constraints.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_28\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.title, 'Title', {\n  length: {\n    min: 2,\n    max: 255,\n    message: '${name} must be between ${min} and ${max} characters',\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Starting the Storybook Server in RedwoodJS (Bash)\nDESCRIPTION: This command uses the RedwoodJS command-line interface (`rw`) via yarn to build and start the Storybook development server. This allows developers to view and interact with the application's UI components in isolation via a web browser, typically at http://localhost:7910.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/storybook.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn rw storybook\n```\n```\n\n----------------------------------------\n\nTITLE: Asserting Truncated Text Presence in React Test (JavaScript)\nDESCRIPTION: This assertion confirms that the UI contains the truncated article body, verifying that the summary was rendered as intended. Inputs are a reference to the matched truncated text element; output is a Jest assertion.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nexpect(matchedBody).toBeInTheDocument()\n\n```\n\n----------------------------------------\n\nTITLE: Querying Comments for a Second postId Using Prisma in Redwood Console (Bash)\nDESCRIPTION: This command retrieves all comments associated with a different post, using Prisma's 'findMany' with a 'where' clause on 'postId', for example, 'postId: 2'. It is useful for verifying comment filtering. Input is the specific 'postId'; output is an array of matching comment records for that post.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/comment-form.md#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\ndb.comment.findMany({ where: { postId: 2 }})\n```\n\n----------------------------------------\n\nTITLE: Debugging Build Artifacts with Prerender Dry-Run (Shell Bash)\nDESCRIPTION: Displays the command-line invocation to run RedwoodJS prerender build in dry-run mode. This checks which pages and assets would be prerendered without actually creating files. Accepts no arguments; just run in project root after build.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw prerender --dry-run\n```\n\n----------------------------------------\n\nTITLE: Example Structure of the RedwoodJS Function Event Object (JSON)\nDESCRIPTION: Shows the typical structure and content of the `event` object passed to a RedwoodJS serverless function handler when logged to the console. This JSON object contains details about the incoming HTTP request, including the method (`httpMethod`), headers, path, query string parameters, body, and encoding status, which can be used within the function logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"httpMethod\": \"GET\",\n  \"headers\": {\n    \"host\": \"localhost:8911\",\n    \"connection\": \"keep-alive\",\n    \"cache-control\": \"max-age=0\",\n    \"dnt\": \"1\",\n    \"upgrade-insecure-requests\": \"1\",\n    \"user-agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\",\n    \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"sec-fetch-site\": \"none\",\n    \"sec-fetch-mode\": \"navigate\",\n    \"sec-fetch-user\": \"?1\",\n    \"sec-fetch-dest\": \"document\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"path\": \"/serverTime\",\n  \"queryStringParameters\": {},\n  \"body\": \"\",\n  \"isBase64Encoded\": false\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Props in RedwoodJS Cell Success Component (JavaScript)\nDESCRIPTION: Shows how the `Success` component of a RedwoodJS Cell (JavaScript version) can access both the data fetched by the query (`article`) and any additional props (`id`, `rand`) passed to the Cell component instance.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nexport const Success = ({ article, id, rand }) => {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Using Node.js via nvm-windows - Bash\nDESCRIPTION: These commands install the latest LTS version of Node.js and the newest npm using nvm-windows in a Git Bash terminal. The first command downloads the LTS version and updates npm, while the second sets the installed version as active for the current terminal session. Prerequisites include installing nvm-windows and running Git Bash as administrator. The first command expects nvm to be in the system PATH. The installed Node version (e.g., 16.13.1) should be substituted as shown in the second command. Output includes updated Node and npm versions in your shell.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/windows-development-setup.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ nvm install lts --latest-npm\n// installs latest LTS and npm\ne.g. 16.13.1 for the following examples\n$ nvm use 16.13.1\n```\n\n----------------------------------------\n\nTITLE: Setting Base SuperTokens Environment Variables - Bash\nDESCRIPTION: Defines essential environment variables for SuperTokens in the .env file. These variables include the app name, JWKS URL, and connection URI, which are required for initializing email/password and social login flows in development. No dependencies, but must be included in the .env or hosting provider for use. Input: key-value environment variable strings. Output: Application recognizes variables at runtime.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/supertokens.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nSUPERTOKENS_APP_NAME=\"Redwoodjs App\" # this will be used in the email template for password reset or email verification emails.\nSUPERTOKENS_JWKS_URL=http://localhost:8910/.redwood/functions/auth/jwt/jwks.json\nSUPERTOKENS_CONNECTION_URI=https://try.supertokens.io # set to the correct connection uri\n```\n\n----------------------------------------\n\nTITLE: Allow Node to Bind to Lower Ports Using setcap - Bash\nDESCRIPTION: Uses 'setcap' to give the 'node' binary capability to bind to privileged ports (<1024), specifically enabling listening on port 80. Requires sudo/root access, and that 'setcap' is present on your system. Command uses 'which node' to resolve the node binary location.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\nsudo setcap CAP_NET_BIND_SERVICE=+eip $(which node)\n```\n\n----------------------------------------\n\nTITLE: Prerendering Multiple Pages in a Set with RedwoodJS (JavaScript/JSX)\nDESCRIPTION: Shows how to prerender several routes at once by wrapping them in a Set component with the 'prerender' attribute. All enclosed routes inherit the prerender configuration. All routes must be valid Page references. On build, each will generate its static HTML.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<Set prerender>\n  <Route path=\"/\" page={HomePage} name=\"home\" />\n  <Route path=\"/about\" page={AboutPage} name=\"hello\" />\n</Set>\n```\n\n----------------------------------------\n\nTITLE: Exposing Auth0 Environment Variables in redwood.toml (TOML)\nDESCRIPTION: Updates the `redwood.toml` configuration file to explicitly include the Auth0-related environment variables. This ensures that variables like `AUTH0_DOMAIN` and `AUTH0_CLIENT_ID` are accessible by the web (frontend) side of the RedwoodJS application.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/auth0.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[web]\n  # ...\n  includeEnvironmentVariables = [\n    \"AUTH0_DOMAIN\",\n    \"AUTH0_CLIENT_ID\",\n    \"AUTH0_REDIRECT_URI\",\n    \"AUTH0_AUDIENCE\",\n  ]\n```\n\n----------------------------------------\n\nTITLE: Creating a Redwood App Using Local Framework Template - Shell\nDESCRIPTION: This snippet shows how to initialize a new Redwood app using a local copy of the framework's create-redwood-app.js script via babel-node. Requires Node.js, Yarn, and a local Redwood Framework checkout. The <path/to/project> parameter should be replaced by the directory in which you want the test project to be created. This approach ensures the generated project uses your in-development framework and template changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/contributing-walkthrough.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nyarn babel-node packages/create-redwood-app/src/create-redwood-app.js <path/to/project>\n```\n\n----------------------------------------\n\nTITLE: Installing Tremor React Library in RedwoodJS Web Workspace (bash)\nDESCRIPTION: This command adds the @tremor/react package to the web workspace within a RedwoodJS monorepo, ensuring visualization components are available in the frontend. Requires Yarn, and must be run from the root of a RedwoodJS project using Yarn workspaces.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace web add @tremor/react\n```\n\n----------------------------------------\n\nTITLE: Querying Comments with Prisma in Redwood Console - Bash/Prisma\nDESCRIPTION: This series of bash code snippets demonstrates interactive querying and data creation using Prisma through the RedwoodJS console. You can retrieve all comments, filter comments by a particular postId, fetch a list of post IDs, and create new comments for a given post. These commands are executed in the `yarn rw console` environment, which automatically awaits Prisma promises. Required dependencies are RedwoodJS and Prisma, and the queries accept JavaScript objects specifying filter criteria. Outputs are JavaScript objects representing database rows, and all modifications are immediately reflected in the database. Limitations are that these are intended for manual usage in a console, not in production code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n> db.comment.findMany()\n[\n  {\n    id: 1,\n    name: 'Rob',\n    body: 'The first real comment!',\n    postId: 1,\n    createdAt: 2020-12-08T23:45:10.641Z\n  },\n  {\n    id: 2,\n    name: 'Tom',\n    body: 'Here is another comment',\n    postId: 1,\n    createdAt: 2020-12-08T23:46:10.641Z\n  }\n]\n```\n\nLANGUAGE: bash\nCODE:\n```\n> db.comment.findMany({ where: { postId: 1 }})\n[\n  {\n    id: 1,\n    name: 'Rob',\n    body: 'The first real comment!',\n    postId: 1,\n    createdAt: 2020-12-08T23:45:10.641Z\n  },\n  {\n    id: 2,\n    name: 'Tom',\n    body: 'Here is another comment',\n    postId: 1,\n    createdAt: 2020-12-08T23:46:10.641Z\n  }\n]\n```\n\nLANGUAGE: bash\nCODE:\n```\n> db.post.findMany({ select: { id: true } })\n[ { id: 1 }, { id: 2 }, { id: 3 } ]\n```\n\nLANGUAGE: bash\nCODE:\n```\n> db.comment.create({ data: { name: 'Peter', body: 'I also like leaving comments', postId: 2 } })\n{\n  id: 3,\n  name: 'Peter',\n  body: 'I also like leaving comments',\n  postId: 2,\n  createdAt: 2020-12-08T23:47:10.641Z\n}\n```\n\nLANGUAGE: bash\nCODE:\n```\n> db.comment.findMany({ where: { postId: 2 }})\n[\n  {\n    id: 3,\n    name: 'Peter',\n    body: 'I also like leaving comments',\n    postId: 2,\n    createdAt: 2020-12-08T23:45:10.641Z\n  },\n\n```\n\n----------------------------------------\n\nTITLE: Updating Redwood API Endpoint - Diff - Diff\nDESCRIPTION: This diff snippet shows how to update the API URL in the redwood.toml configuration file. Changing the apiUrl is essential for Nginx reverse proxying and ensures the app's API endpoints are accessible correctly. This update must be done to match the expected URL path with your Nginx and deployment setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/self-hosting-redwood.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n- apiUrl = \"/.redwood/functions\"\n+ apiUrl = \"/api\"\n```\n\n----------------------------------------\n\nTITLE: Creating a New RedwoodJS Project using Yarn\nDESCRIPTION: This shell command uses Yarn to execute the `create-redwood-app` package, scaffolding a new RedwoodJS application in a directory named `./render-deploy`. This is typically the initial step before configuring deployment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/render.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn create redwood-app ./render-deploy\n```\n\n----------------------------------------\n\nTITLE: Configuring graphql-markdown Plugin in Docusaurus\nDESCRIPTION: This JavaScript snippet demonstrates configuring the `@graphql-markdown/docusaurus` plugin within the `docusaurus.config.js` file. It specifies the path to the Redwood schema (`../.redwood/schema.graphql`), the root path for documentation (`./docs`), the base URL (`graphql-api`), link root, and necessary loaders. It also shows how to add an item to the navbar linking to the generated documentation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_90\n\nLANGUAGE: javascript\nCODE:\n```\n// docs/docusaurus.config.js\n// ...\n  plugins: [\n    [\n      '@graphql-markdown/docusaurus',\n      {\n        schema: '../.redwood/schema.graphql',\n        rootPath: './docs',\n        baseURL: 'graphql-api',\n        linkRoot: '../..',\n        loaders: {\n          GraphQLFileLoader: '@graphql-tools/graphql-file-loader',\n        },\n      },\n    ],\n  ],\n// ...\nthemeConfig:\n    /** @type {import('@docusaurus/preset-classic').ThemeConfig} */\n    ({\n      navbar: {\n        title: 'My Site',\n        logo: {\n          alt: 'My Site Logo',\n          src: 'img/logo.svg',\n        },\n        items: [\n          {\n            to: '/docs/graphql-api', // adjust the location depending on your baseURL (see configuration)\n            label: 'GraphQL API', // change the label with yours\n            position: 'right',\n          },\n//...\n\n```\n\n----------------------------------------\n\nTITLE: Sample GraphQL Schema Verification Failure Output - Bash\nDESCRIPTION: This Bash (terminal output) snippet shows the build error logs when RedwoodJS detects missing authentication or custom directives in the SDL for queries or mutations. It helps developers identify which operations need proper directive annotations for security. It requires running yarn rw build, and the log lists missing directives, aiding debugging and compliance. No inputs are required besides an attempt to build an improperly configured schema; outputs are shown in the error log; constraints are determined by Redwood's build-time checks.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n✔ Generating Prisma Client...\n✖ Verifying graphql schema...\n→ - deletePost Mutation\nBuilding API...\nCleaning Web...\nBuilding Web...\nPrerendering Web...\n\nYou must specify one of @requireAuth, @skipAuth or a custom directive for\n- contacts Query\n- posts Query\n- post Query\n- createContact Mutation\n- createPost Mutation\n- updatePost Mutation\n- deletePost Mutation\n```\n\n----------------------------------------\n\nTITLE: Installing @testing-library/user-event for RedwoodJS Web Side (Bash)\nDESCRIPTION: This command uses Yarn Workspaces to install the `@testing-library/user-event` package as a development dependency specifically for the `web` side of a RedwoodJS application. This library is used for simulating user interactions in tests, particularly with forms.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nyarn workspace web add -D @testing-library/user-event\n```\n```\n\n----------------------------------------\n\nTITLE: Generating GraphQL Documentation with Docusaurus CLI\nDESCRIPTION: This terminal command uses `yarn docusaurus graphql-to-doc` to invoke the documentation generation process handled by the `@graphql-markdown/docusaurus` plugin. It reads the configured GraphQL schema and outputs markdown files into the specified directory (`docs/graphql-api`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_91\n\nLANGUAGE: terminal\nCODE:\n```\nyarn docusaurus graphql-to-doc\n```\n\n----------------------------------------\n\nTITLE: Verifying nvm Installation\nDESCRIPTION: This command checks if nvm was installed correctly and displays the installed version number. Running this in the terminal should output the nvm version string (e.g., '0.39.1').\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnvm --version\n```\n\n----------------------------------------\n\nTITLE: Viewing RedwoodJS Project Structure (JavaScript)\nDESCRIPTION: Displays the standard directory layout for a RedwoodJS project configured for JavaScript. It highlights the separation into `api`, `scripts`, and `web` directories, showing key subdirectories and files like `schema.prisma`, `graphql.js`, `auth.js`, `seed.js`, `App.jsx`, and `Routes.jsx`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/file-structure.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n├── api\n│   ├── db\n│   │   └── schema.prisma\n│   └── src\n│       ├── directives\n│       │   ├── requireAuth\n│       │   └── skipAuth\n│       ├── functions\n│       │   └── graphql.js\n│       ├── graphql\n│       ├── lib\n│       │   ├── auth.js\n│       │   ├── db.js\n│       │   └── logger.js\n│       └── services\n│\n├── scripts\n│   └── seed.js\n│\n└── web\n    ├── public\n    │   ├── favicon.png\n    │   ├── README.md\n    │   └── robots.txt\n    └── src\n        ├── components\n        ├── layouts\n        ├── pages\n        │   ├── FatalErrorPage\n        │   │   └── FatalErrorPage.jsx\n        │   └── NotFoundPage\n        │       └── NotFoundPage.jsx\n        ├── App.jsx\n        ├── entry.client.jsx\n        ├── index.css\n        ├── index.html\n        └── Routes.jsx\n```\n\n----------------------------------------\n\nTITLE: Shorthand Build-and-Serve Command for RedwoodJS - Shell\nDESCRIPTION: Executes a shorthand version of the build and serve process using 'yarn bs'. This custom Yarn script encapsulates both building and serving the RedwoodJS application in a single step, speeding up the development workflow. Assumes 'bs' is defined in the project's package.json scripts.\nSOURCE: https://github.com/emelleby/docwood/blob/main/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn bs\n```\n\n----------------------------------------\n\nTITLE: Incremental Multipart/mixed Streaming Responses Example - Bash\nDESCRIPTION: Illustrates the multipart/mixed response format from a streaming GraphQL endpoint when querying `alphabet @stream`. Includes connection, headers, and sequential updates with each letter, indicating completion when `hasNext` becomes false. Used as raw CLI output for demonstration purposes. No code to run – output illustration only.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n* Connected to localhost (127.0.0.1) port 8911 (#0)\n> POST /graphql HTTP/1.1\n> Host: localhost:8911\n> User-Agent: curl/8.1.2\n> accept:multipart/mixed\n> content-type: application/json\n> Content-Length: 53\n>\n< HTTP/1.1 200 OK\n< connection: keep-alive\n< content-type: multipart/mixed; boundary=\"-\"\n< transfer-encoding: chunked\n<\n---\nContent-Type: application/json; charset=utf-8\nContent-Length: 39\n\n{\"data\":{\"alphabet\":[]},\"hasNext\":true}\n---\nContent-Type: application/json; charset=utf-8\nContent-Length: 70\n\n{\"incremental\":[{\"items\":[\"a\"],\"path\":[\"alphabet\",0]}],\"hasNext\":true}\n---\nContent-Type: application/json; charset=utf-8\nContent-Length: 70\n\n{\"incremental\":[{\"items\":[\"b\"],\"path\":[\"alphabet\",1]}],\"hasNext\":true}\n---\nContent-Type: application/json; charset=utf-8\nContent-Length: 70\n\n{\"incremental\":[{\"items\":[\"c\"],\"path\":[\"alphabet\",2]}],\"hasNext\":true}\n---\nContent-Type: application/json; charset=utf-8\nContent-Length: 70\n\n{\"incremental\":[{\"items\":[\"d\"],\"path\":[\"alphabet\",3]}],\"hasNext\":true}\n---\nContent-Type: application/json; charset=utf-8\nContent-Length: 70\n\n{\"incremental\":[{\"items\":[\"e\"],\"path\":[\"alphabet\",4]}],\"hasNext\":true}\n---\nContent-Type: application/json; charset=utf-8\nContent-Length: 70\n\n{\"incremental\":[{\"items\":[\"f\"],\"path\":[\"alphabet\",5]}],\"hasNext\":true}\n---\nContent-Type: application/json; charset=utf-8\nContent-Length: 70\n\n{\"incremental\":[{\"items\":[\"g\"],\"path\":[\"alphabet\",6]}],\"hasNext\":true}\n---\n\n---\nContent-Type: application/json; charset=utf-8\nContent-Length: 17\n\n{\"hasNext\":false}\n-----\n```\n\n----------------------------------------\n\nTITLE: Testing Function with Allowed GET Request using curl (Bash)\nDESCRIPTION: Uses the `curl` command-line tool to send an HTTP GET request (curl's default method) to the `serverTime` function endpoint (`http://localhost:8911/serverTime`). This command verifies that the endpoint remains accessible via the allowed GET method after implementing method restrictions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/custom-function.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8911/serverTime\n```\n\n----------------------------------------\n\nTITLE: Installing 'pino-datadog' Package using Yarn Workspaces\nDESCRIPTION: Bash command using Yarn Workspaces to add the `pino-datadog` package to the `api` workspace in a RedwoodJS project. This package provides a Pino transport stream for sending logs to Datadog.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace api add pino-datadog\n```\n\n----------------------------------------\n\nTITLE: Building Web Side for Render (Example)\nDESCRIPTION: An example command demonstrating how to build the RedwoodJS 'web' side specifically for static-site deployment on Render's CDN.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood deploy render web\n```\n\n----------------------------------------\n\nTITLE: Starting the Redwood Development Server in Terminal\nDESCRIPTION: Navigates into the Redwood project directory (`<your-app-name>`) and starts the Redwood development server using the `yarn rw dev` command. This command boots up both the frontend (defaulting to `http://localhost:8910`) and the API backend (defaulting to `http://localhost:8911`), including the GraphQL playground.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/create-redwood-app.md#_snippet_5\n\nLANGUAGE: terminal\nCODE:\n```\ncd <your-app-name>\nyarn rw dev\n```\n\n----------------------------------------\n\nTITLE: Installing Python and Build Tools in Node.js Dockerfile - Diff Syntax - bash\nDESCRIPTION: This snippet provides a Dockerfile diff, indicating how to add Python 3 and necessary build tools (`make`, `gcc`) to a Node.js Docker image. Applying this change ensures native dependencies required by some npm modules can be built during the yarn install step. Use in Dockerfile contexts using Debian-based images, and confirm package list contents as per runtime requirements.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nFROM node:20-bookworm-slim as base\n\nRUN apt-get update && apt-get install -y \\\n    openssl \\\n+   python3 make gcc \\\n    && rm -rf /var/lib/apt/lists/*\n```\n\n----------------------------------------\n\nTITLE: Generated RedwoodJS Cell Component Code (JavaScript/JSX)\nDESCRIPTION: Example code structure generated for a RedwoodJS Cell (`UserCell.js`). It includes exported constants for the GraphQL `QUERY` and React components representing the `Loading`, `Empty`, `Failure`, and `Success` states, forming the core logic of the cell.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_33\n\nLANGUAGE: jsx\nCODE:\n```\nexport const QUERY = gql`\n  query {\n    user {\n      id\n    }\n  }\n`\n\nexport const Loading = () => <div>Loading...</div>\n\nexport const Empty = () => <div>Empty</div>\n\nexport const Failure = ({ error }) => <div>Error: {error.message}</div>\n\nexport const Success = ({ user }) => {\n  return JSON.stringify(user)\n}\n```\n\n----------------------------------------\n\nTITLE: Scheduling RedwoodJS Job at Specific Time (JavaScript)\nDESCRIPTION: Demonstrates scheduling a RedwoodJS job (`MillenniumAnnouncementJob`) to execute at a precise future date and time. The `later` function is used with the job, its arguments, and an options object containing the `waitUntil` property set to a specific JavaScript `Date` instance (January 1, 3000).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_13\n\nLANGUAGE: js\nCODE:\n```\nlater(MillenniumAnnouncementJob, [user.id], {\n  waitUntil: new Date(3000, 0, 1, 0, 0, 0),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Filestack Secret in .env for RedwoodJS\nDESCRIPTION: Defines the `REDWOOD_ENV_FILESTACK_SECRET` environment variable in the `.env` file. This secret, obtained from the Filestack dashboard, is crucial for generating secure policy signatures required for authenticated API operations like file deletion.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/file-uploads.md#_snippet_16\n\nLANGUAGE: dotenv\nCODE:\n```\nREDWOOD_ENV_FILESTACK_SECRET= PWRWGEKFZ2HJMXWSBP3YYI5ERZ\n```\n\n----------------------------------------\n\nTITLE: Using Redwood Check Command for Diagnostics - Bash\nDESCRIPTION: Shows the invocation of the Redwood CLI for structural project diagnostics, intended to check for potential errors or misconfigurations. Dependencies: Redwood CLI. Parameters: None. Input: Command invocation. Output: Diagnostic scan with errors/warnings on project structure. Limitation: Experimental, may not cover all issues.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood check\n```\n\n----------------------------------------\n\nTITLE: Modeling User and Identity Relationship for OAuth Providers (ASCII Diagram)\nDESCRIPTION: Illustrates a relational data schema for linking local users to OAuth provider identities using two tables: User and Identity. The Identity table records provider name (e.g., 'github') and provider user ID (uid), enabling flexible association and future multi-provider support. Not executable code, but essential database modeling reference underpinning snippet integration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/oauth.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n┌───────────┐       ┌────────────┐\n│   User    │       │  Identity  │\n├───────────┤       ├────────────┤\n│ id        │•──┐   │ id         │\n│ name      │   └──<│ userId     │\n│ email     │       │ provider   │\n│ ...       │       │ uid        │\n└───────────┘       │ ...        │\n                    └────────────┘\n```\n\n----------------------------------------\n\nTITLE: Baremetal Deployment Directory Structure Example (Text)\nDESCRIPTION: Illustrates the typical directory structure created on a baremetal server after a RedwoodJS deployment. It shows the application root (`myapp`), a shared `.env` file, a `current` symlink pointing to the latest release directory within `releases`, and the codebase within the timestamped release directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n└── var\n    └── www\n        └── myapp\n            ├── .env <────────────────┐\n            ├── current ───symlink──┐ │\n            └── releases            │ │\n                └── 20220420120000 <┘ │\n                    ├── .env ─symlink─┘\n                    ├── api\n                    ├── web\n                    ├── ...\n```\n\n----------------------------------------\n\nTITLE: Disabling Scaffold Nesting in redwood.toml (TOML)\nDESCRIPTION: TOML configuration snippet for `redwood.toml` demonstrating how to disable the default nesting of generated scaffold components and pages by setting `nestScaffoldByModel` to `false` under the `[generate]` section.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_69\n\nLANGUAGE: toml\nCODE:\n```\n[generate]\n  nestScaffoldByModel = false\n```\n\n----------------------------------------\n\nTITLE: Expected GraphQL JSON Response from RedwoodJS Version Endpoint\nDESCRIPTION: Shows the expected JSON output from querying the RedwoodJS GraphQL 'version' endpoint, used to confirm that the API side is serving requests successfully. No code dependencies, but relies on the RedwoodJS GraphQL endpoint being available and configured as per documentation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\": {\n    \"redwood\": {\n      \"version\": \"1.0.0\"\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Full Sync, Build, and Serve Workflow for RedwoodJS - Shell\nDESCRIPTION: Runs a shorthand command 'yarn sbs' to synchronize documentation, build the project, and serve locally in one step. This Yarn script automates the initial setup sequence, combining syncing, building, and serving, to expedite development onboarding. Requires a corresponding 'sbs' script to be present in the project's Yarn configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nyarn sbs\n```\n\n----------------------------------------\n\nTITLE: Configuring RedwoodJS Deployment with PM2 for API Only\nDESCRIPTION: Example `deploy.toml` configuration file for deploying a RedwoodJS application. It defines server details, deployment path, repository information, and crucially specifies `processNames = [\"api\"]`, indicating that the deployment and monitoring process (using PM2 in this case) should only manage the API side of the application, complementing the Nginx setup.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_37\n\nLANGUAGE: toml\nCODE:\n```\n[[production.servers]]\nhost = \"myserver.com\"\nusername = \"ubuntu\"\nagentForward = true\nsides = [\"api\", \"web\"]\npath = \"/var/www/myapp\"\n// highlight-next-line\nprocessNames = [\"api\"]\nrepo = \"git@github.com:redwoodjs/myapp.git\"\nbranch = \"main\"\nkeepReleases = 3\npackageManagerCommand = \"yarn\"\nmonitorCommand = \"pm2\"\n```\n\n----------------------------------------\n\nTITLE: Generating RedwoodJS Cell using Yarn\nDESCRIPTION: Executes the RedwoodJS CLI command using Yarn to generate a new Cell component named 'Article'. This command scaffolds files for the cell's query, loading, empty, failure, and success states, facilitating data fetching logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g cell Article\n```\n\n----------------------------------------\n\nTITLE: Disabling Trusted Documents in GraphQL Handler (TypeScript)\nDESCRIPTION: This configuration snippet within `api/src/functions/graphql.ts` shows how to explicitly disable the Trusted Documents feature for the GraphQL handler, even if it's enabled in `redwood.toml`. Setting `disabled: true` within the `trustedDocuments` object prevents the server from enforcing the use of persisted query hashes. The `store` becomes optional in this case.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\n  trustedDocuments: {\n    disabled: true,\n  }\n```\n\n----------------------------------------\n\nTITLE: Generating a RedwoodJS Article Cell using CLI\nDESCRIPTION: This command utilizes the RedwoodJS command-line interface (`yarn rw g` or `npm run rw g`) to scaffold a new Cell component named `Article`. Cells are a RedwoodJS convention for handling data fetching, including loading, empty, failure, and success states declaratively.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g cell Article\n```\n\n----------------------------------------\n\nTITLE: Setting RedwoodJS Logger Destination to a File\nDESCRIPTION: Configures the RedwoodJS logger via `createLogger` to direct logs to a file specified by the `destination` option (`/path/to/file/api.log`). The `options` object is shown as empty, implying default options are used besides the destination. File logging requires filesystem write access.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n/**\n * Log to a File\n */\nexport const logger = createLogger({\n  options: {},\n  destination: '/path/to/file/api.log',\n})\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Log Level in RedwoodJS Logger\nDESCRIPTION: Shows how to override the default logging level using the `level` property within the `options` object passed to `createLogger`. This example sets the minimum log level to 'debug', making it suitable for development or staging environments where more verbose logging is needed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n/**\n * Override minimum log level to debug\n */\nexport const logger = createLogger({\n  options: { level: 'debug' },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Up API Serve Stage in Docker - RedwoodJS - Dockerfile\nDESCRIPTION: This snippet starts a new Docker build stage for serving the RedwoodJS GraphQL API, using the node:20-bookworm-slim base image. It enables corepack and installs the openssl system package (with commented-out optional packages for Python and GCC if needed). This establishes the foundation for a small, production-optimized Docker image for API serving. The image expects subsequent setup for user environment, dependencies, and application code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_8\n\nLANGUAGE: Dockerfile\nCODE:\n```\nFROM node:20-bookworm-slim as api_serve\\n\\nRUN corepack enable\\n\\nRUN apt-get update && apt-get install -y \\\\\\n    openssl \\\\\\n    # python3 make gcc \\\\\\n    && rm -rf /var/lib/apt/lists/*\n```\n\n----------------------------------------\n\nTITLE: Locating Ellipsis in Rendered Article Summary (JavaScript)\nDESCRIPTION: This snippet finds an element containing the ellipsis ('...') within the matched truncated body element, using DOM Testing Library's within function for scoped querying. It is a part of test routines to verify that an ellipsis is rendered at truncation. Requires a rendered DOM structure with the truncated summary and ellipsis.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst ellipsis = within(matchedBody).getByText('...', { exact: false })\n\n```\n\n----------------------------------------\n\nTITLE: Preparing User and Copying API Application Files - RedwoodJS - Dockerfile\nDESCRIPTION: This snippet establishes node as the user, sets the working directory, and carefully copies essential configuration and package files into the container with explicit ownership. The instruction layers and ordering aid Docker's cache efficiency. Prerequisites include a valid project structure with .yarnrc.yml, package.json files, and appropriate permissions. No build operations are performed at this step; it prepares the context for dependency installation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_9\n\nLANGUAGE: Dockerfile\nCODE:\n```\nUSER node\\nWORKDIR /home/node/app\\n\\nCOPY --chown=node:node .yarnrc.yml .yarnrc.yml\\nCOPY --chown=node:node package.json .\\nCOPY --chown=node:node api/package.json api/\\nCOPY --chown=node:node yarn.lock yarn.lock\n```\n\n----------------------------------------\n\nTITLE: Installing Nodemailer in RedwoodJS API Workspace - Zsh Shell\nDESCRIPTION: Installs the 'nodemailer' npm package as a dependency to the API workspace of the RedwoodJS application. Must be run from within the root or with the correct workspace context. Input: command run in terminal; Output: nodemailer added to the API workspace's package.json dependencies.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_1\n\nLANGUAGE: zsh\nCODE:\n```\nyarn workspace api add nodemailer\n```\n\n----------------------------------------\n\nTITLE: Conditional Route Parameter Generation Based on Route Metadata (JavaScript)\nDESCRIPTION: Illustrates an advanced routeParameters function that generates parameters differently depending on the current route metadata. Useful if a single Page can serve multiple routes and you want prerendered parameter sets to differ based on the route. Receives the route as input and outputs parameter arrays accordingly.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/prerender.md#_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nexport function routeParameters(route) {\n  // If we are reusing the BlogPostPage in multiple routes, e.g. /odd/{id} and\n  // /blogPost/{id} we can choose what parameters to pass to each route during\n  // prerendering\n  // highlight-next-line\n  if (route.name === 'odd') {\n    return [{ id: 1 }, { id: 3 }, { id: 5 }]\n  } else {\n    return [{ id: 2 }, { id: 4 }, { id: 6 }]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Redwood TOML Configuration for Web Port Change - Diff\nDESCRIPTION: Shows how to update the 'web' port from the default (presumably 8910) to port 80 in the 'redwood.toml' config file. This is needed for running the web frontend on the standard HTTP port, though it usually requires elevated permissions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_32\n\nLANGUAGE: diff\nCODE:\n```\n[web]\n  title = \"My Application\"\n  apiUrl = \"/.netlify/functions\"\n+ port = 80\n[api]\n  port = 8911\n[browser]\n  open = true\n```\n\n----------------------------------------\n\nTITLE: Installing Nhost JavaScript SDK in RedwoodJS Web Workspace - Bash\nDESCRIPTION: Adds the '@nhost/nhost-js' client library as a dependency to the web workspace of a RedwoodJS monorepo. This command ensures that the Nhost SDK is available for importing and instantiating the auth client within web/src/auth.ts. Requires Yarn and proper workspace configuration in the project.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/custom.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace web add @nhost/nhost-js\n```\n\n----------------------------------------\n\nTITLE: Adjusting .bashrc Script to Support Non-Interactive SSH Deployments (Diff)\nDESCRIPTION: Demonstrates how to comment out sections of the .bashrc file that prevent loading in non-interactive SSH sessions, ensuring necessary environment variables (e.g., for npm/yarn) are set. Useful for automatic deployment scripts that rely on the user's environment. This requires editing the .bashrc file for the deployment user and is presented as a 'diff' for clarity.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_12\n\nLANGUAGE: diff\nCODE:\n```\n# If not running interactively, don't do anything\n- case $- in\n-     *i*) ;;\n-       *) return;;\n- esac\n\n# If not running interactively, don't do anything\n+ # case $- in\n+ #    *i*) ;;\n+ #      *) return;;\n+ # esac\n\n```\n\nLANGUAGE: diff\nCODE:\n```\n- [ -z \"$PS1\" ] && return\n+ # [ -z \"$PS1\" ] && return\n\n```\n\n----------------------------------------\n\nTITLE: Subsequent Baremetal Deployment Command (Bash)\nDESCRIPTION: This command is used for deploying updates to an already configured RedwoodJS application on the 'production' baremetal environment. It executes the standard deployment lifecycle steps, excluding the initial setup actions triggered by `--first-run`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy baremetal production\n```\n\n----------------------------------------\n\nTITLE: Rendering Article List Cell and Linking to Detail Page (RedwoodJS, TypeScript)\nDESCRIPTION: This TypeScript component is similar to the JavaScript version but explicitly types the input props for improved type safety. Using RedwoodJS's Link and routes, each article title is rendered as a clickable link, though the route currently does not pass an ID. Dependencies include `@redwoodjs/router`, and type definitions for CellSuccessProps and related queries are expected. Outputs a list of articles with title links, body, and creation time.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n// highlight-next-line\\nimport { Link, routes } from '@redwoodjs/router'\\n\\n// QUERY, Loading, Empty and Failure definitions...\\n\\nexport const Success = ({\\n  articles,\\n}: CellSuccessProps<ArticlesQuery, ArticlesQueryVariables>) => {\\n  return (\\n    <>\\n      {articles.map((article) => (\\n        <article key={article.id}>\\n          <header>\\n            <h2>\\n              // highlight-next-line\\n              <Link to={routes.article()}>{article.title}</Link>\\n            </h2>\\n          </header>\\n          <p>{article.body}</p>\\n          <div>Posted at: {article.createdAt}</div>\\n        </article>\\n      ))}\\n    </>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Connection to New Database with psql (Bash)\nDESCRIPTION: Demonstrates a successful session starting psql after creating a user-named database. Shows the welcome message and prompt, confirming access. Output-only to illustrate command result.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ psql\npsql (13.1)\nType \"help\" for help.\n\n$(whoami)=#\n```\n\n----------------------------------------\n\nTITLE: Flushing Asynchronous Logger Buffer (JavaScript)\nDESCRIPTION: Shows how to flush the asynchronous logger's internal buffer to force all pending logs to be written immediately. Useful in scenarios where buffered log lines must be ensured to be processed before application exit or at critical checkpoints. Particularly relevant when using asynchronous transport streams.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/logger.md#_snippet_29\n\nLANGUAGE: javascript\nCODE:\n```\nlogger.flush()\n```\n\n----------------------------------------\n\nTITLE: Defining OpenAI Prompt for Generating Bedtime Stories in TypeScript\nDESCRIPTION: This TypeScript snippet defines a constant string `PROMPT` which serves as instructions for an OpenAI model. The prompt guides the AI to write a short, formatted (Markdown) children's bedtime story with specific characteristics like animal type, color, activity, a lesson, and a particular quality/style, based on provided inputs.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/realtime.md#_snippet_21\n\nLANGUAGE: ts\nCODE:\n```\nconst PROMPT = `Write a short children's bedtime story about an Animal that is a given Color and that does a given Activity.\n\nGive the animal a cute descriptive and memorable name.\n\nThe story should teach a lesson.\n\nThe story should be told in a quality, style and feeling of the given Adjective.\n\nThe story should be no longer than 3 paragraphs.\n\nFormat the story using Markdown.`\n```\n\n----------------------------------------\n\nTITLE: Example Output of Generating a RedwoodJS Cell (Shell)\nDESCRIPTION: Illustrates the console output produced when successfully generating a 'user' cell using the RedwoodJS CLI. It shows the execution steps and confirms the creation of the cell's JavaScript and test files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood generate cell user\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood g cell user\n✔ Generating cell files...\n✔ Writing $(./web/src/components/UserCell/UserCell.test.js)...\n✔ Writing $(./web/src/components/UserCell/UserCell.js)...\nDone in 1.00s.\n```\n\n----------------------------------------\n\nTITLE: Example Output of `yarn redwood info` (Bash)\nDESCRIPTION: Shows sample output generated by the `yarn redwood info` command. The output includes details about the System (OS, Shell), Binaries (Node, Yarn), Browsers, and relevant npmPackages like `@redwoodjs/core`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_92\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood info\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood info\n\n  System:\n    OS: Linux 5.4 Ubuntu 20.04 LTS (Focal Fossa)\n    Shell: 5.0.16 - /usr/bin/bash\n  Binaries:\n    Node: 13.12.0 - /tmp/yarn--1589998865777-0.9683603763419713/node\n    Yarn: 1.22.4 - /tmp/yarn--1589998865777-0.9683603763419713/yarn\n  Browsers:\n    Chrome: 78.0.3904.108\n    Firefox: 76.0.1\n  npmPackages:\n    @redwoodjs/core: ^0.7.0-rc.3 => 0.7.0-rc.3\n\nDone in 1.98s.\n```\n\n----------------------------------------\n\nTITLE: Cloning and Preparing the RedwoodJS Example Repository - Bash\nDESCRIPTION: Performs all necessary steps to clone the example RedwoodJS project repository, install dependencies, initialize the local SQLite database with default data using Prisma migrations, and generate a session secret. Dependencies: Git, Yarn, and access to the Prisma migration engine. After running, a fully-prepared boilerplate application is ready for tutorial continuation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/intermission.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/redwoodjs/redwood-tutorial\ncd redwood-tutorial\nyarn install\nyarn rw prisma migrate dev\nyarn rw g secret\n```\n\n----------------------------------------\n\nTITLE: OpenWeather API Error Response Example - JSON\nDESCRIPTION: Shows a sample JSON response from the OpenWeather API when an invalid zip code is requested. Demonstrates the structure of an error, including a 'cod' field with value '404' and an error message. This example is critical for understanding how to handle errors in the service code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"cod\": \"404\",\n  \"message\": \"city not found\"\n}\n```\n\n----------------------------------------\n\nTITLE: RedwoodJS Server Startup Failure Due to Missing Directives (Bash)\nDESCRIPTION: This console output shows an error during RedwoodJS server startup (`yarn rw dev`). The \"Schema validation failed\" message indicates that certain queries or mutations (`posts Query`, `createPost Mutation`, etc.) lack a required directive (`@requireAuth`, `@skipAuth`, or custom). This prevents the server from starting until the schema is corrected, enforcing security.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ngen | Generating TypeScript definitions and GraphQL schemas...\ngen | 47 files generated\napi | Building... Took 593 ms\napi | [GQL Server Error] - Schema validation failed\napi | ----------------------------------------\napi | You must specify one of @requireAuth, @skipAuth or a custom directive for\napi | - posts Query\napi | - createPost Mutation\napi | - updatePost Mutation\napi | - deletePost Mutation\n```\n\n----------------------------------------\n\nTITLE: Illustrating Many-to-Many Database Relationships (Text)\nDESCRIPTION: A text diagram depicting a direct many-to-many relationship between Product and Category tables, indicated by the `>─────<` connector. This represents the conceptual relationship before considering the implementation details like join tables.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n┌───────────┐       ┌────────────┐\n│  Product  │       │  Category  │\n├───────────┤       ├────────────┤\n│ id        │>─────<│ id         │\n│ name      │       │ name       │\n│ upc       │       │ shelf      │\n└───────────┘       └────────────┘\n```\n\n----------------------------------------\n\nTITLE: Example Output: Generating a RedwoodJS Layout via CLI\nDESCRIPTION: This snippet shows the typical command-line output when successfully generating a RedwoodJS layout component named 'user'. It confirms the generation process and lists the specific files created (the layout component `.js` file and its corresponding test file).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_52\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood generate layout user\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood g layout user\n✔ Generating layout files...\n✔ Writing $(./web/src/layouts/UserLayout/UserLayout.test.js)...\n✔ Writing $(./web/src/layouts/UserLayout/UserLayout.js)...\nDone in 1.00s.\n```\n\n----------------------------------------\n\nTITLE: Using Legacy Yarn Version for Redwood Project Creation - Bash\nDESCRIPTION: Illustrates creating a new Redwood project using Yarn 1 instead of Yarn 3 by specifying the --yarn1 flag. Dependencies: Yarn 1, redwood CLI. Parameters: project directory, --yarn1 (flag). Input: Command invocation. Output: Project created using Yarn 1 for compatibility. Limitation: For troubleshooting; not default recommended path.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nyarn create redwood-app my-redwood-project --yarn1\n```\n\n----------------------------------------\n\nTITLE: Additional Setup for RedwoodJS Server When Setting Up Realtime - Bash\nDESCRIPTION: This output snippet reflects fallback provisioning: if the required server files or configurations are missing, setup will automatically create them. Adds the experimental server file, required configuration, and API dependencies. Ensures project is fully ready for realtime features when not already prepared.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_127\n\nLANGUAGE: bash\nCODE:\n```\n\\u2714 Adding the experimental server file...\\n\\u2714 Adding config to redwood.toml...\\n\\u2714 Adding required api packages...\n```\n\n----------------------------------------\n\nTITLE: Serving RedwoodJS API and Web Sides - Bash\nDESCRIPTION: Serves both the 'api' and 'web' sides in a built RedwoodJS project using the Redwood CLI. Prior execution of 'yarn rw build' is required. Accepts a 'side' parameter (defaults to both) and options such as --port and --socket to control network binding. Intended for local debugging or self-hosted deployment; unifies both frontend and backend servers on a single process.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_133\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood serve [side]\n```\n\n----------------------------------------\n\nTITLE: Generating a KPI Card Component Skeleton (bash)\nDESCRIPTION: This command generates a new reusable KpiCard React component within the web workspace of a RedwoodJS app. The component file is created alongside its TypeScript types. Executed in the project root with Yarn CLI tools.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/build-dashboards-fast-with-tremor.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw g component KpiCard\n```\n\n----------------------------------------\n\nTITLE: Rollback to Previous Deploy Release - Bash\nDESCRIPTION: Illustrates the use of the Redwood CLI to rollback to the previous deploy release on a baremetal server. Assumes previous releases are available based on the 'keepReleases' option in your config. This operation does not affect the database schema, only the deployed code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw deploy baremetal production --rollback\n```\n\n----------------------------------------\n\nTITLE: Applying Basic HTML Required Validation (TypeScript)\nDESCRIPTION: This partial snippet demonstrates adding the standard HTML `required` attribute to RedwoodJS form fields (`TextField`, `TextAreaField`) in a TypeScript component's TSX return statement for basic client-side validation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title=\"web/src/pages/ContactPage/ContactPage.tsx\"\nreturn (\n  <Form onSubmit={onSubmit}>\n    <label htmlFor=\"name\">Name</label>\n    // highlight-next-line\n    <TextField name=\"name\" required />\n    <label htmlFor=\"email\">Email</label>\n    // highlight-next-line\n    <TextField name=\"email\" required />\n    <label htmlFor=\"message\">Message</label>\n    // highlight-next-line\n    <TextAreaField name=\"message\" required />\n    <Submit>Save</Submit>\n  </Form>\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Initial Article Component Structure (JSX)\nDESCRIPTION: Shows the basic functional component structure for `Article.jsx` as generated by the RedwoodJS CLI. This initial version is a simple React component rendering placeholder content. Note that `React` is implicitly imported by RedwoodJS.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter2/routing-params.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\nconst Article = () => {\n  return (\n    <div>\n      <h2>{'Article'}</h2>\n      <p>{'Find me in ./web/src/components/Article/Article.jsx'}</p>\n    </div>\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Running Workers in Foreground (Dev Mode) using Bash\nDESCRIPTION: This command uses the RedwoodJS CLI (`yarn rw`) to start the job workers in the foreground. It continuously checks for and executes jobs, logging verbosely (debug level by default). Useful for development and debugging. Pressing Ctrl-C initiates a graceful shutdown.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/background-jobs.md#_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw jobs work\n```\n\n----------------------------------------\n\nTITLE: Example Output with Data URI for Avatar Field in JavaScript\nDESCRIPTION: This JavaScript object demonstrates the typical output structure when using the `withDataUri()` method in RedwoodJS. The `avatar` field, representing an uploaded image, is transformed into a Base64 encoded Data URI string, prefixed with the appropriate MIME type (`data:image/png;base64,...`). This allows the image data to be directly embedded and rendered in HTML without requiring a separate file request.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/uploads.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  // other fields\n  id: 12355,\n  name: 'Danny'\n  email: '...'\n  // Because configured avatar as an upload field:\n  // highlight-next-line\n  avatar: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAJ/...Q0MgUHJvZmlsZQAAKJF1kL='\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Comments with Tailwind Gap Styling - TypeScript (TSX)\nDESCRIPTION: Adapts the updated comment separation UI for TypeScript, adding Tailwind's 'space-y-8' class to space out the rendered Comment components. Uses type-safe props and depends on both the comments array and Tailwind CSS.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/multiple-comments.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nexport const Success = ({\\n  comments,\\n}: CellSuccessProps<CommentsQuery, CommentsQueryVariables>) => {\\n  return (\\n    // highlight-next-line\\n    <div className=\"space-y-8\">\\n      {comments.map((comment) => (\\n        <Comment comment={comment} key={comment.id} />\\n      ))}\\n      // highlight-next-line\\n    </div>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Destroying a Redwood Scaffold (Shell)\nDESCRIPTION: Shell command `yarn redwood destroy scaffold <model>` used to remove all files previously generated by the Redwood scaffold command for a specific model. This command respects namespacing and the `nestScaffoldByModel` setting.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_72\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood destroy scaffold <model>\n```\n\n----------------------------------------\n\nTITLE: Updating JavaScript Test Assertion for Filtered Comments\nDESCRIPTION: Updates a JavaScript Jest test (`comments.test.jsx`) to correctly assert the number of comments returned when filtering by `postId`. It imports the Prisma client (`db`), fetches the specific post and its associated comments directly from the database, and compares the count with the result from the `comments` service.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_20\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"api/src/services/comments/comments.test.jsx\"\nimport { comments, createComment } from './comments'\n// highlight-next-line\nimport { db } from 'src/lib/db'\n\ndescribe('comments', () => {\n  scenario('returns all comments', async (scenario) => {\n    const result = await comments({ postId: scenario.comment.jane.postId })\n    // highlight-start\n    const post = await db.post.findUnique({\n      where: { id: scenario.comment.jane.postId },\n      include: { comments: true },\n    })\n    expect(result.length).toEqual(post.comments.length)\n    // highlight-end\n  })\n\n  // ...\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Uninstalling Specific Node.js Version with nvm\nDESCRIPTION: This command removes a specific version of Node.js that was previously installed via nvm. Replace `<<version number>>` with the version string of the Node.js installation to be removed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nnvm uninstall <<version number>>\n```\n\n----------------------------------------\n\nTITLE: Customizing Loader Delay with pageLoadingDelay Prop - RedwoodJS Router - JavaScript/JSX\nDESCRIPTION: Shows how to adjust the delay (in milliseconds) before the loading indicator is shown during code-split page transitions by setting the pageLoadingDelay prop on the Router component. Lower values show the loader sooner; useful for custom UX requirements.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/router.md#_snippet_33\n\nLANGUAGE: jsx\nCODE:\n```\n<Router pageLoadingDelay={500}>...</Router>\n```\n\n----------------------------------------\n\nTITLE: Editing the authorized_keys File on Server using nano in Bash\nDESCRIPTION: Shows the command to open the `~/.ssh/authorized_keys` file on the remote server using the `nano` text editor. This file is where public keys must be added for the server to allow key-based authentication for the user. `vi` is mentioned as an alternative editor.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nnano ~/.ssh/authorized_keys\n```\n\n----------------------------------------\n\nTITLE: Adding Chart.js Dependency via Yarn (Bash)\nDESCRIPTION: Installs the `chart.js` library into the `web` workspace of the RedwoodJS project using the `yarn workspace web add` command. This makes the Chart.js library available as a dependency for import and use within the project's React components, specifically for rendering charts.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/disable-api-database.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn workspace web add chart.js\n```\n\n----------------------------------------\n\nTITLE: Preparing Directory Structure for GraphQL Docs in Docusaurus\nDESCRIPTION: These terminal commands first change the current directory into the `docs` workspace using `cd docs`. Then, `mkdir docs/graphql-api` creates the subdirectory where the `graphql-markdown` plugin will output the generated documentation files within the Docusaurus structure.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_89\n\nLANGUAGE: terminal\nCODE:\n```\n// Change into the \"docs\" workspace\n\ncd docs\n\n// you should have the \"docs\" directory and within that a \"graphql-api\" directory\nmkdir docs/graphql-api // if needed\n```\n\n----------------------------------------\n\nTITLE: Defining Jest Test Cases for Functions (Jest, JavaScript/JSX)\nDESCRIPTION: This snippet demonstrates creating Jest test suites for a simple add() function. It uses Jest's describe and it blocks for structuring tests and leverages expect ... toEqual and expect ... toThrow for assertions. There are no external dependencies beyond Jest itself. The inputs are add() function parameters, and tests validate correct addition and error handling (with proper argument counts). Outputs are standard Jest pass/fail test results.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\ndescribe('add()', () => {\\n  it('adds two numbers', () => {\\n    expect(add(1, 1)).toEqual(2)\\n  })\\n\\n  it('throws an error for too few arguments', () => {\\n    expect(() => add(1)).toThrow('add requires 2 arguments')\\n  })\\n})\n```\n\n----------------------------------------\n\nTITLE: Error Output During RedwoodJS Type Generation Due to Missing Related Type\nDESCRIPTION: Illustrates the error message (`Unknown type: \"Shelf\"`) encountered during the type generation phase when running `yarn rw g sdl Book`. This occurs because the SDL for the related `Shelf` model has not yet been defined or generated, making the `Shelf` type unknown to the GraphQL schema.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/schema-relations.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n  ⠙ Generating types ...\nFailed to load schema\n\n# ...\n\ntype Query {\n  redwood: Redwood\n},graphql/**/*.sdl.{js,ts},directives/**/*.{js,ts}:\n\n        Unknown type: \"Shelf\".\n        Error: Unknown type: \"Shelf\".\n```\n\n----------------------------------------\n\nTITLE: Initializing Article Component Boilerplate in TSX\nDESCRIPTION: This is the default functional React component structure generated by the RedwoodJS CLI for the 'Article' component using TypeScript (TSX), located at `web/src/components/Article/Article.tsx`. It renders a simple div with a heading and a placeholder paragraph indicating its file path.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/04_chapter2/routing-params.md#_snippet_26\n\nLANGUAGE: tsx\nCODE:\n```\nconst Article = () => {\n  return (\n    <div>\n      <h2>{'Article'}</h2>\n      <p>{'Find me in ./web/src/components/Article/Article.tsx'}</p>\n    </div>\n  )\n}\n\nexport default Article\n```\n\n----------------------------------------\n\nTITLE: Troubleshooting: Missing auth.zip Error - Serverless - Terminal\nDESCRIPTION: This output sample depicts an error encountered when a required zipped function package (auth.zip) is not found during a Serverless deploy. It assists in troubleshooting deployment issues, typically resolved by ensuring the dev server is not running before deploy retry.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/serverless.md#_snippet_7\n\nLANGUAGE: terminal\nCODE:\n```\nError:\nNo auth.zip file found in the package path you provided.\n```\n\n----------------------------------------\n\nTITLE: Linking Favicon Asset - HTML\nDESCRIPTION: Demonstrates how to reference a favicon image that has been copied to the output directory by placing it in the static assets folder. This pattern is useful for static files that need to be publicly accessible without module imports. The href attribute directly points to the final build path. No special dependencies are required; the file must exist in the static folder.\nSOURCE: https://github.com/emelleby/docwood/blob/main/web/public/README.md#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<link rel=\\\"icon\\\" type=\\\"image/png\\\" href=\\\"/favicon.png\\\" />\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Sign Out Button Component in JSX\nDESCRIPTION: This basic React function component named SignoutBtn simply renders a button that, when clicked, calls a local onClick handler. The actual sign-out logic is a placeholder comment. No dependencies aside from React are explicitly required at this stage. The button is not connected to any sign out process until additional logic is added.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/supabase-auth.md#_snippet_18\n\nLANGUAGE: jsx\nCODE:\n```\nconst SignoutBtn = () => {\n  const onClick = () => {\n    // do sign out here.\n  }\n  return <button onClick={() => onClick()}>Sign Out</button>\n}\n\nexport default SignoutBtn\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Console Image for Debugging - Docker/Bash\nDESCRIPTION: This bash snippet shows commands for building the console image targeting the 'console' stage and launching an interactive ephemeral container for debugging. The image is tagged as 'console' and run with /bin/bash, giving full shell access to the application source code and dependencies. Requires Docker installed and the Dockerfile present in the working directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n# Build the console image:\\ndocker build . -t console --target console\\n# Start an ephemeral container from it:\\ndocker run --rm -it console /bin/bash\n```\n\n----------------------------------------\n\nTITLE: Initializing RedwoodJS Project (TypeScript) with Yarn\nDESCRIPTION: This command uses Yarn's 'create' command to scaffold a new RedwoodJS application named 'redwoodblog' in the current directory. The '--ts' flag specifies that the project should be configured for TypeScript. It requires Yarn to be installed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/03_chapter1/installation.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn create redwood-app --ts ./redwoodblog\n```\n\n----------------------------------------\n\nTITLE: Tailing Live Process Logs for pm2 (Bash)\nDESCRIPTION: Displays the command for tailing a live pm2 log file in the terminal. This is crucial for monitoring active application logs and debugging problems in real-time. Requires access to the server and that pm2 is configured to write output logs to the specified location.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/baremetal.md#_snippet_17\n\nLANGUAGE: terminal\nCODE:\n```\ntail -f ~/.pm2/logs/api-out-0.log\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Netlify Deployment without API Functions (TOML)\nDESCRIPTION: This TOML snippet demonstrates the necessary modifications to `netlify.toml` for deploying a RedwoodJS application without an API layer to Netlify. It involves setting the build command to disable Prisma (`--prisma=false --dm=false`) and commenting out the `functions` line to prevent Netlify from attempting to build API Lambda functions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/disable-api-database.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[build]\n  command = \"yarn rw deploy netlify --prisma=false --dm=false\"\n  publish = \"web/dist\"\n  # functions = \"api/dist/functions\"\n\n[dev]\n  command = \"yarn rw dev\"\n\n[[redirects]]\n  from = \"/*\"\n  to = \"/index.html\"\n  status = 200\n```\n\n----------------------------------------\n\nTITLE: Using the Numericality Validator with `odd` Option in JSX\nDESCRIPTION: Shows the `numericality` validator using the `odd` option set to `true` to ensure the input number is odd.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/services.md#_snippet_38\n\nLANGUAGE: jsx\nCODE:\n```\nvalidate(input.zenGarden, 'Zen Garden', {\n  numericality: { odd: true },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Docs Content with Yarn - Shell\nDESCRIPTION: Executes the 'yarn sync' command to pull down documentation files from the main RedwoodJS repository's 'docs/docs' directory. This step is a prerequisite for working with the documentation site, ensuring that the latest documentation content is available locally. The command requires Yarn to be installed and network access to the external repository.\nSOURCE: https://github.com/emelleby/docwood/blob/main/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn sync\n```\n\n----------------------------------------\n\nTITLE: Tracing Node.js Yarn Dependency Chain - Shell - Markdown\nDESCRIPTION: These code blocks illustrate using `yarn why` to trace why a specific module (like `bufferutil`) is installed in a Node.js project. Each output block shows the dependency tree, helping developers understand which top-level dependencies require a problematic native module. Requires an existing Node.js/yarn project, and command output will differ based on dependency graph.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/docker.md#_snippet_20\n\nLANGUAGE: Shell\nCODE:\n```\nyarn why bufferutil\n└─ websocket@npm:1.0.34\n   └─ bufferutil@npm:4.0.8 (via npm:^4.0.1)\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn why websocket\n└─ @supabase/realtime-js@npm:2.8.4\n   └─ websocket@npm:1.0.34 (via npm:^1.0.34)\n\nyarn why @supabase/realtime-js\n└─ @supabase/supabase-js@npm:2.38.4\n   └─ @supabase/realtime-js@npm:2.8.4 (via npm:^2.8.4)\n\nyarn why @supabase/supabase-js\n├─ api@workspace:api\n│  └─ @supabase/supabase-js@npm:2.38.4 (via npm:^2.21.0)\n│\n└─ web@workspace:web\n   └─ @supabase/supabase-js@npm:2.38.4 (via npm:^2.21.0)\n```\n\n----------------------------------------\n\nTITLE: Spacing CommentsCell with Tailwind in Article Component - JavaScript\nDESCRIPTION: This JavaScript snippet conditionally wraps CommentsCell in a div with the Tailwind class “mt-12” inside the Article component, increasing margin above the comment section. This improves layout separation between the article body and comments. Requires Tailwind CSS and works in vanilla RedwoodJS projects using JavaScript.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter6/multiple-comments.md#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nconst Article = ({ article, summary = false }) => {\n  return (\n    <article>\n      <header>\n        <h2 className=\"text-xl text-blue-700 font-semibold\">\n          <Link to={routes.article({ id: article.id })}>{article.title}</Link>\n        </h2>\n      </header>\n      <div className=\"mt-2 text-gray-900 font-light\">\n        {summary ? truncate(article.body, 100) : article.body}\n      </div>\n      // highlight-start\n      {!summary && (\n        <div className=\"mt-12\">\n          <CommentsCell />\n        </div>\n      )}\n      // highlight-end\n    </article>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Node.js and Yarn Versions using Bash\nDESCRIPTION: Provides commands to check the installed versions of Node.js and Yarn from the terminal. This is used to verify if the system meets the minimum requirements (Node.js =20.x, Yarn >=1.22.21) for RedwoodJS installation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/prerequisites.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnode --version\nyarn --version\n```\n\n----------------------------------------\n\nTITLE: Performing a Basic Assertion Test in JavaScript\nDESCRIPTION: This snippet demonstrates a fundamental test for the previously defined `add` function. It calls `add(1, 1)` and uses a simple `if/else` statement to check if the result equals the expected value `2`. It logs 'pass' if the assertion `add(1, 1) === 2` is true, and 'fail' otherwise. This illustrates the core concept of an assertion in testing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst add = (a, b) => {\n  return a + b\n}\n\nif (add(1, 1) === 2) {\n  console.log('pass')\n} else {\n  console.error('fail')\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a RedwoodJS App via Yarn - Bash\nDESCRIPTION: This command initializes a new RedwoodJS project in a folder named 'netlify-deploy' using Yarn. No additional dependencies besides Yarn itself are required. The command must be run in a terminal and the resulting folder will contain the basic RedwoodJS boilerplate with no database or custom code.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/netlify.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn create redwood-app ./netlify-deploy\n```\n\n----------------------------------------\n\nTITLE: Disabling Forgot Password Feature in JavaScript Configuration\nDESCRIPTION: Configures the `forgotPassword` feature within the dbAuth setup. Setting the `enabled` property to `false` completely disables the functionality allowing users to request a password reset link. It's recommended to also disable `resetPassword` when doing this.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/auth/dbauth.md#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nforgotPassword: {\n  enabled: false\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering Test Error with yarn rw test\nDESCRIPTION: Shows the `yarn rw test` command in the context of potentially encountering a Prisma schema validation error (P1012) if the test database URL is not configured. This specific error occurs when the `TEST_DATABASE_URL` environment variable is missing or improperly configured in the `.env` file.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter5/testing.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw test\n```\n\n----------------------------------------\n\nTITLE: Customizing Persisted Query Error Message (String) in TypeScript\nDESCRIPTION: This example demonstrates how to customize the error message returned by the GraphQL server when it receives a query that is not in the trusted documents store (i.e., an ad-hoc query when only persisted queries are allowed). Within the `trustedDocuments` configuration in `api/src/functions/graphql.ts`, the `customErrors.persistedQueryOnly` property is set to a custom string.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql/trusted-documents.md#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\n  trustedDocuments: {\n    store,\n    customErrors: {\n      persistedQueryOnly: 'This ad-hoc query is not allowed.'\n    },\n  }\n```\n\n----------------------------------------\n\nTITLE: Removing Email Pattern Validation from ContactPage Form - TypeScript\nDESCRIPTION: This diff snippet shows the removal of client-side email regex validation from the ContactPage form component written in TypeScript. It highlights adjustments to the validation object in the TextField, allowing invalid formats to reach the server for backend validation testing. Only the pattern and its message are excluded, keeping the required check in place.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_26\n\nLANGUAGE: diff\nCODE:\n```\n<TextField\\n  name=\"email\"\\n  validation={{\\n    required: true,\\n-    pattern: {\\n-      value: /^[^@]+@[^.]+\\..+$/,\\n-      message: 'Please enter a valid email address',\\n-    },\\n  }}\\n  errorClassName=\"error\"\\n/>\n```\n\n----------------------------------------\n\nTITLE: Query Using Multiple Aliases for Testing Alias Limit (GraphQL, TypeScript Syntax)\nDESCRIPTION: Demonstrates a GraphQL query that uses 11 field aliases to test and illustrate the effect of the maxAliases security setting. No dependencies are needed beyond GraphQL itself. This query renames id and title fields of posts in multiple ways for output flexibility; the pattern helps detect or test alias limits in security configurations.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_63\n\nLANGUAGE: TypeScript\nCODE:\n```\n {\n  articles: posts {\n    id\n    articleId: id\n    postId: id\n    articlePostId: id\n    postArticleId: id\n    blogId: id\n    title\n    articleTitle: title\n    postTitle: title\n    articlePostTitle: title\n    postArticleTitle: title\n    blogTitle: title\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Destroying a RedwoodJS Cell Component (Shell)\nDESCRIPTION: Command to remove a previously generated RedwoodJS Cell component and its associated files (component file, test file, stories file if applicable). Requires the `<name>` of the cell to be destroyed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_31\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood destroy cell <name>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Explicit Many-to-Many with Join Table (Text)\nDESCRIPTION: A text diagram demonstrating how a many-to-many relationship between Product and Category tables is implemented using an explicit join table named `ProductCategory`. This table contains foreign keys (`productId`, `categoryId`) referencing the primary keys of the Product and Category tables, establishing two one-to-many relationships.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n┌───────────┐      ┌───────────────────┐       ┌────────────┐\n│  Product  │      │  ProductCategory  │       │  Category  │\n├───────────┤      ├───────────────────┤       ├────────────┤\n│ id        │•────<│ productId         │   ┌──•│ id         │\n│ name      │      │ categoryId        │>──┘   │ name       │\n│ upc       │      └───────────────────┘       │ shelf      │\n└───────────┘                                  └────────────┘\n```\n\n----------------------------------------\n\nTITLE: Explaining Yargs-style Redwood CLI Syntax - Bash\nDESCRIPTION: Shows the generalized syntax for invoking a Redwood CLI command, using yargs-like conventions for required and optional arguments, and command-line options. This illustrates the basic command structure users should follow to run most Redwood CLI subcommands. This snippet is context-only and not executable; no dependencies. Parameters: <name> (required), [path] (optional), --option (flag). Input: CLI command. Output: Command runs according to user input. Limitations: Arguments must follow the prescribed format.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn redwood generate page <name> [path] --option\n```\n\n----------------------------------------\n\nTITLE: Listing Locally Installed Node.js Versions with nvm\nDESCRIPTION: This command displays all versions of Node.js that have been installed locally via nvm. It also indicates which version is currently active and which one is set as the default.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnvm ls\n```\n\n----------------------------------------\n\nTITLE: Applying Basic HTML Required Validation (JavaScript)\nDESCRIPTION: This partial snippet shows how to add basic browser-level validation by adding the standard HTML `required` attribute to RedwoodJS form fields (`TextField`, `TextAreaField`) within the JSX return statement.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter3/forms.md#_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nreturn (\n  <Form onSubmit={onSubmit}>\n    <label htmlFor=\"name\">Name</label>\n    // highlight-next-line\n    <TextField name=\"name\" required />\n\n    <label htmlFor=\"email\">Email</label>\n    // highlight-next-line\n    <TextField name=\"email\" required />\n\n    <label htmlFor=\"message\">Message</label>\n    // highlight-next-line\n    <TextAreaField name=\"message\" required />\n\n    <Submit>Save</Submit>\n  </Form>\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Switching Branches with Git Checkout\nDESCRIPTION: The `git checkout` command is a fundamental Git operation primarily used for switching the current working directory to a different branch. It can also be used to restore specific files to their last committed state. In the context of the document, it's mentioned as the command-line method for creating and switching to a new branch (often used as `git checkout -b <new-branch-name>`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/contributing-walkthrough.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ngit checkout\n```\n\n----------------------------------------\n\nTITLE: Importing the Email Sending Function into Users Service (TypeScript)\nDESCRIPTION: Demonstrates how to import the `sendEmail` function from the `src/lib/email.ts` module into the `users.ts` service file. This makes the email sending utility available within the user service's logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/sending-emails.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\n\nimport { sendEmail } from 'src/lib/email'\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Enabling Corepack and Checking Yarn Version using Bash\nDESCRIPTION: Demonstrates how to enable Corepack, a tool included with Node.js v18+, to manage package managers like Yarn. After enabling, it shows how to check the installed Yarn version. Corepack ensures the correct Yarn version is used within a Redwood project based on the package.json configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/tutorial/chapter1/prerequisites.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncorepack enable\nyarn -v\n```\n\n----------------------------------------\n\nTITLE: Running the RedwoodJS Generate Command (Shell)\nDESCRIPTION: Basic command syntax for initiating code generation in a RedwoodJS project using Yarn. Replace `<type>` with the specific type of code to generate (e.g., 'cell', 'component', 'page').\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_29\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood generate <type>\n```\n\n----------------------------------------\n\nTITLE: Generated HTML Meta Tags from \\u003cMetadata\\u003e Example - HTML\nDESCRIPTION: This block demonstrates the resulting HTML meta tags that RedwoodJS's <Metadata> component injects into the <head> for the preceding JSX configuration. The output includes standard and OpenGraph meta tags and showcases how object/array props are mapped to meta attributes. Inputs are Metadata props; output is literal HTML meta elements. Useful for verifying the component's transformation logic.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<title>About page</title>\n<meta name=\"title\" content=\"About page\" />\n<meta name=\"description\" content=\"About the awesome team\" />\n<meta name=\"robots\" content=\"nofollow\" />\n<meta property=\"og:title\" content=\"About page\" />\n<meta property=\"og:description\" content=\"About the awesome team\" />\n<meta property=\"og:image\" content=\"https://example.com/images/og.png\" />\n<meta property=\"og:url\" content=\"https://example.com/start\" />\n<meta property=\"og:type\" content=\"website\" />\n<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n\n```\n\n----------------------------------------\n\nTITLE: Copying SSH Public Key to Clipboard on macOS using Bash\nDESCRIPTION: Demonstrates a macOS-specific command pipeline. `cat ~/.ssh/id_ed25519.pub` reads the public key file, and the output is piped (`|`) to the `pbcopy` utility, which places the text directly into the system clipboard.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ncat ~/.ssh/id_ed25519.pub | pbcopy\n```\n\n----------------------------------------\n\nTITLE: Importing useForm Hook in RedwoodJS Contact Page (JS)\nDESCRIPTION: Shows how to import the `useForm` hook alongside other form-related components from `@redwoodjs/forms` in a JavaScript (`.jsx`) file for a RedwoodJS ContactPage. This hook provides access to React Hook Form's API, necessary for manual form control like resetting fields.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/05_chapter3/saving-data.md#_snippet_33\n\nLANGUAGE: jsx\nCODE:\n```\n```jsx title=\"web/src/pages/ContactPage/ContactPage.jsx\"\nimport {\n  FieldError,\n  Form,\n  FormError,\n  Label,\n  Submit,\n  TextAreaField,\n  TextField,\n  // highlight-next-line\n  useForm,\n} from '@redwoodjs/forms'\n```\n```\n\n----------------------------------------\n\nTITLE: Example Log Output with Apollo Tracing Data Bash\nDESCRIPTION: Presents sample log output from a RedwoodJS API server with GraphQL tracing enabled. It showcases the Apollo Tracing format (version 1), detailing total request duration (in nanoseconds) and timing breakdowns (startOffset, duration) for individual resolvers involved in the request.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_52\n\nLANGUAGE: bash\nCODE:\n```\npi | INFO [2021-07-09 14:25:52.452 +0000] (graphql-server): GraphQL willSendResponse\napi |     tracing: {\napi |       \"version\": 1,\napi |       \"startTime\": \"2021-07-09T14:25:51.931Z\",\napi |       \"endTime\": \"2021-07-09T14:25:52.452Z\",\napi |       \"duration\": 521131526,\napi |       \"execution\": {\napi |         \"resolvers\": [\napi |           {\napi |             \"path\": [\napi |               \"post\"\napi |             ],\napi |             \"parentType\": \"Query\",\napi |             \"fieldName\": \"post\",\napi |             \"returnType\": \"Post!\",\napi |             \"startOffset\": 1787428,\napi |             \"duration\": 519121497\napi |           },\napi |           {\napi |             \"path\": [\napi |               \"post\",\napi |               \"id\"\napi |             ],\napi |             \"parentType\": \"Post\",\napi |             \"fieldName\": \"id\",\napi |             \"returnType\": \"Int!\",\napi |             \"startOffset\": 520982888,\napi |             \"duration\": 25140\napi |           },\n... more paths follow ...\napi |         ]\napi |       }\napi |     }\n```\n\n----------------------------------------\n\nTITLE: Checking Postgres Service Status with Brew (Bash)\nDESCRIPTION: Checks the current status of services managed by Homebrew, displaying whether Postgres is running and under which user. Requires Homebrew services. Use this command to verify if PostgreSQL is active, especially after installation.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ brew services\nName       Status  User         Plist\npostgresql started $(whoami)   /Users/$(whoami)/Library/LaunchAgents/homebrew.mxcl.postgresql.plist\n```\n\n----------------------------------------\n\nTITLE: Displaying RedwoodJS CLI Help Information\nDESCRIPTION: Executes the RedwoodJS command-line interface (CLI) with the `--help` flag. This command lists all available Redwood CLI commands, their options, and provides general usage information, serving as a reference for developers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood --help\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of partialMatch with toHaveCached (TypeScript)\nDESCRIPTION: Highlights a limitation of the `partialMatch` helper: it cannot be used with `toHaveCached` unless a specific cache key or key regex is also provided. This snippet shows an example that will always fail.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_77\n\nLANGUAGE: ts\nCODE:\n```\n// 🛑 Will never pass!\nexpect(testCacheClient).toHaveCached(partialMatch({ name: 'LS50' }))\n```\n\n----------------------------------------\n\nTITLE: Syncing Local Redwood Framework with Test Project Using rwfw - Shell\nDESCRIPTION: This code demonstrates how to connect your local Redwood Framework clone with a local test Redwood project using the rwfw CLI and the RWFW_PATH environment variable. Replace <framework directory> with the path to your local framework clone. Running this command synchronizes framework code and dependencies with your project, allowing for local development and testing against your changes.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/contributing-walkthrough.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nRWFW_PATH=<framework directory> yarn rwfw project:sync\n```\n\n----------------------------------------\n\nTITLE: Example Output: Copying Cell Generator Templates (Bash)\nDESCRIPTION: Demonstrates running the `yarn rw setup generator cell` command in a terminal within a Redwood project directory (`~/redwood-app`). The output shows the command execution via Yarn, confirmation messages, the location where templates were written (`/web/generators/cell`), and the execution time.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_112\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn rw setup generator cell\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/rw setup generator cell\n✔ Copying generator templates...\n✔ Wrote templates to /web/generators/cell\n✨ Done in 2.33s.\n```\n\n----------------------------------------\n\nTITLE: Enabling Corepack via Command Line - Bash\nDESCRIPTION: Enables Corepack, a Node.js utility for managing package managers, using the 'corepack enable' command. Requires Node.js version 16.10 or later and administrative privileges as necessary. This step is typically needed before installing or activating Yarn through Corepack. The command outputs nothing if successful, and is a prerequisite for running further Yarn or Corepack commands.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-yarn.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncorepack enable\n```\n\n----------------------------------------\n\nTITLE: Temporarily Commenting Out Relations in Prisma Schema for Generation\nDESCRIPTION: Shows the `Book` and `Shelf` Prisma models with their relation fields commented out. This is a troubleshooting step to allow generating SDLs for each model individually without encountering 'Unknown type' errors.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/schema-relations.md#_snippet_6\n\nLANGUAGE: prisma\nCODE:\n```\nmodel Book {\n  id      Int    @id @default(autoincrement())\n  title   String @unique\n  // highlight-start\n  // Shelf   Shelf? @relation(fields: [shelfId], references: [id])\n  // shelfId Int?\n  // highlight-end\n}\n\nmodel Shelf {\n  id    Int    @id @default(autoincrement())\n  name  String @unique\n  // highlight-next-line\n  // books Book[]\n}\n```\n\n----------------------------------------\n\nTITLE: Destroying a RedwoodJS Component (Shell)\nDESCRIPTION: Command to remove a previously generated standard RedwoodJS component and its associated files (component file, test file, stories file if applicable). Requires the `<name>` of the component to be destroyed.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_35\n\nLANGUAGE: shell\nCODE:\n```\nyarn redwood destroy component <name>\n```\n\n----------------------------------------\n\nTITLE: Health Check Success Response Example - JSON\nDESCRIPTION: This JSON snippet illustrates the response body returned by the RedwoodJS GraphQL server when a health check at /graphql/health endpoint succeeds. No dependencies are required to use this example, and the endpoint responds with a JSON object indicating server liveliness. The input is a health check HTTP GET request, and output is a JSON message. Intended for reference or manual testing of the health check endpoint, with no constraints beyond using an appropriate HTTP client.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"message\": \"alive\"\n}\n```\n\n----------------------------------------\n\nTITLE: RedwoodJS Build Failure Due to Missing Directives (Bash)\nDESCRIPTION: This is an example output from the RedwoodJS build process, indicating a failure. The error message lists GraphQL queries and mutations (`contacts Query`, `posts Query`, etc.) that are missing a required directive like `@requireAuth`, `@skipAuth`, or a custom directive. This enforces Redwood's secure-by-default policy.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/directives.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n✖ Verifying graphql schema...\nBuilding API...\nCleaning Web...\nBuilding Web...\nPrerendering Web...\nYou must specify one of @requireAuth, @skipAuth or a custom directive for\n- contacts Query\n- posts Query\n- post Query\n- updatePost Mutation\n- deletePost Mutation\n```\n\n----------------------------------------\n\nTITLE: Checking Rendered Article Text in React Component Test (JavaScript)\nDESCRIPTION: This JavaScript snippet assigns the first 10 characters of an article body to the truncatedBody variable. It is meant for use during test routines to obtain the truncated portion of a post, validating summary logic. No dependencies are required.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/08_chapter5/first-test.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst truncatedBody = article.body.substring(0, 10)\n\n```\n\n----------------------------------------\n\nTITLE: Checking Installed Yarn Version - Bash\nDESCRIPTION: Displays the current installed Yarn version by invoking 'yarn --version'. This command helps verify if Yarn meets the minimum required version (>=1.22.21) for RedwoodJS projects. The output is the version string, and it requires Yarn to be properly installed in the system path.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-yarn.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn --version\n```\n\n----------------------------------------\n\nTITLE: Example Output of Function Test Run - Bash\nDESCRIPTION: This bash-formatted text represents the console output after running the test suite for the 'divide' function. It documents the number of tests run, test durations, and status of the test cases. No execution context; serves as an expected output reference.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n PASS   api  api/src/functions/divide/divide.test.ts (12.69 s)\n  divide serverless function\n    ✓ divides two numbers successfully (153 ms)\n    ✓ requires a dividend (48 ms)\n    ✓ requires a divisor (45 ms)\n    ✓ cannot divide by 0 (47 ms)\n\nTest Suites: 1 passed, 1 total\nTests:       4 passed, 4 total\nSnapshots:   0 total\nTime:        13.155 s\nRan all test suites matching /divide.test.ts|divide.test.ts|false/i.\n\n```\n\n----------------------------------------\n\nTITLE: Showing Asset Output in web/dist Directory (Text)\nDESCRIPTION: Illustrates the resulting structure in the `web/dist` directory after the RedwoodJS build process (`yarn rw build`). It shows how files originally placed in `web/public` (like `img/logo.png` and `favicon.png`) are copied directly into the distribution directory, alongside Vite-bundled assets in `static/`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/assets-and-files.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nweb/dist/\n├── static/\n│  ├── js/\n│  └── css/\n// highlight-start\n├── img/\n│  └── logo.png\n└── favicon.png\n// highlight-end\n```\n\n----------------------------------------\n\nTITLE: Example Output: Regenerating User SDL without Tests (Bash)\nDESCRIPTION: Shows the console output after successfully running the `yarn redwood g sdl user --force --no-tests` command. It indicates that the SDL and service files for the 'user' model were generated or overwritten, skipping the test and scenario files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_77\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood generate sdl user --force --no-tests\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood g sdl user\n✔ Generating SDL files...\n✔ Writing $(./api/src/graphql/users.sdl.js)...\n✔ Writing $(./api/src/services/users/users.js)...\nDone in 1.04s.\n```\n\n----------------------------------------\n\nTITLE: Removing the API Directory in RedwoodJS (Bash)\nDESCRIPTION: This Bash command removes the `/api` directory and all its contents recursively from a RedwoodJS project. This is the first step towards disabling the API layer for a static-only deployment.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/disable-api-database.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrm -rf api\n```\n\n----------------------------------------\n\nTITLE: Typical psql Error Output—Database Not Found (Bash)\nDESCRIPTION: Shows a typical error message returned by psql when attempting to access a non-existent user-named database. Helps users understand the cause of the error and the next steps (typically to create the database). Output-only snippet; requires psql command to produce.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npsql: error: FATAL:  database $(whoami) does not exist\n```\n\n----------------------------------------\n\nTITLE: Adding a Specific SSH Key to ssh-agent in Bash\nDESCRIPTION: Demonstrates the `ssh-add` command followed by the path to a specific private key file (`~/.ssh/id_ed25519`). This command explicitly adds the identity represented by this private key to the `ssh-agent`, making it available for SSH connections.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nssh-add ~/.ssh/id_ed25519\n```\n\n----------------------------------------\n\nTITLE: Uninstalling Node.js via Homebrew on Mac\nDESCRIPTION: This command uses Homebrew (`brew`) to forcefully uninstall Node.js from a macOS system. This is often a prerequisite before installing nvm to prevent conflicts between system-installed Node.js and nvm-managed versions.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew uninstall --force node\n```\n\n----------------------------------------\n\nTITLE: Defining an `afterCreate` Lifecycle Callback in RedwoodRecord (Future Syntax)\nDESCRIPTION: This snippet demonstrates the proposed (not yet implemented) syntax for defining an `afterCreate` lifecycle callback within a RedwoodRecord model. This static async function would be executed after a record instance (e.g., `user`) is successfully created, allowing for actions like setting up related default records (e.g., user preferences).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_35\n\nLANGUAGE: jsx\nCODE:\n```\nexport default class User extends RedwoodRecord {\n  static afterCreate = async (user) => {\n    await user.preferences.create({ email: 'weekly' })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Default PS1 Prompt Definition in Bash Configuration (Bash)\nDESCRIPTION: This Bash script snippet shows a common way the `PS1` environment variable, which defines the shell prompt, is set in configuration files like `.bashrc`. It includes conditional logic for colored prompts and uses escape sequences like `\\u` (user), `\\h` (hostname), and `\\w` (working directory). Users modify this definition to customize their prompt.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\nif [ \"$color_prompt\" = yes ]; then\n  PS1='${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w \\$\\[\\033[00m\\] '\nelse\n  PS1='${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ '\nfi\n```\n\n----------------------------------------\n\nTITLE: Example Output: Generating User SDL with Tests (Bash)\nDESCRIPTION: Shows the console output after successfully running the `yarn redwood generate sdl user` command. It indicates that the SDL file, service file, service scenarios file, and service test file for the 'user' model were generated.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_79\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn redwood generate sdl user\nyarn run v1.22.4\n$ /redwood-app/node_modules/.bin/redwood g sdl user\n✔ Generating SDL files...\n✔ Writing $(./api/src/graphql/users.sdl.js)...\n✔ Writing $(./api/src/services/users/users.scenarios.js)...\n✔ Writing $(./api/src/services/users/users.test.js)...\n✔ Writing $(./api/src/services/users/users.js)...\nDone in 1.04s.\n```\n\n----------------------------------------\n\nTITLE: Example Output for Setting Up GraphQL Trusted Documents - Bash\nDESCRIPTION: This example shows terminal feedback after running the trusted-documents setup, including enabling trusted documents, generating stores, and updating handlers. If necessary, the process also sets up experimental server files and configuration. The steps confirm the successful configuration in a clear sequence for developer reference.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_123\n\nLANGUAGE: bash\nCODE:\n```\n~/redwood-app$ yarn rw setup graphql trusted-documents\\n\\u2714 Update Redwood Project Configuration to enable GraphQL Trusted Documents ...\\n\\u2714 Generating Trusted Documents store ...\\n\\u2714 Configuring the GraphQL Handler to use a Trusted Documents store ...\n```\n\n----------------------------------------\n\nTITLE: Sample Weather API JSON Response - JSON\nDESCRIPTION: Provides a sample JSON payload returned by the OpenWeather API for a specific zip code. No extra dependencies are needed to interpret this; it is used to understand the available weather data fields before building the frontend logic. Key properties include city name, main temperature, and weather details. The input is an HTTP API call and the output is the JSON-encoded weather information.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-a-third-party-api.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"coord\": {\n    \"lon\": -122.09,\n    \"lat\": 37.39\n  },\n  \"weather\": [\n    {\n      \"id\": 500,\n      \"main\": \"Rain\",\n      \"description\": \"light rain\",\n      \"icon\": \"10d\"\n    }\n  ],\n  \"base\": \"stations\",\n  \"main\": {\n    \"temp\": 280.44,\n    \"pressure\": 1017,\n    \"humidity\": 61,\n    \"temp_min\": 279.15,\n    \"temp_max\": 281.15\n  },\n  \"visibility\": 12874,\n  \"wind\": {\n    \"speed\": 8.2,\n    \"deg\": 340,\n    \"gust\": 11.3\n  },\n  \"clouds\": {\n    \"all\": 1\n  },\n  \"dt\": 1519061700,\n  \"sys\": {\n    \"type\": 1,\n    \"id\": 392,\n    \"message\": 0.0027,\n    \"country\": \"US\",\n    \"sunrise\": 1519051894,\n    \"sunset\": 1519091585\n  },\n  \"id\": 0,\n  \"name\": \"Mountain View\",\n  \"cod\": 200\n}\n```\n\n----------------------------------------\n\nTITLE: Successful Output Snippet from RedwoodJS SDL Generation\nDESCRIPTION: Shows the initial successful output messages when running `yarn rw g sdl Book`, indicating the creation of SDL and service files before the type generation phase.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/schema-relations.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n✔ Generating SDL files...\n✔ Successfully wrote file $(./api/src/graphql/books.sdl.js)\n✔ Successfully wrote file $(./api/src/services/books/books.scenarios.js)\n✔ Successfully wrote file $(./api/src/services/books/books.test.js)\n✔ Successfully wrote file $(./api/src/services/books/books.js)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Title Template Variations - JSX\nDESCRIPTION: These commented JSX string examples show how different titleTemplate formats produce various page title outcomes in RedwoodJS. No dependencies are needed, as this is conceptual documentation intended to help developers choose appropriate formatting. Each example details an input format and its resulting output.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/seo-head.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n\"%PageTitle | %AppTitle\" => \"Home Page | Redwood App\"\n\n\"%AppTitle · %PageTitle\" => \"Redwood App · Home Page\"\n\n\"%PageTitle : %AppTitle\" => \"Home Page : Redwood App\"\n\n```\n\n----------------------------------------\n\nTITLE: Uninstalling Yarn via Corepack and NPM - Bash\nDESCRIPTION: Disables Corepack and forcefully uninstalls globally installed Yarn using NPM. The command sequence ensures all previously installed Yarn versions are removed. This is useful before reinstalling, upgrading, or troubleshooting Yarn installations. Run with administrative privileges if needed, and expect no output on success.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-yarn.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncorepack disable\nnpm uninstall -g yarn --force\n```\n\n----------------------------------------\n\nTITLE: Output of Default Redwood Scaffold Generation (plaintext)\nDESCRIPTION: Displays the file structure created by `yarn rw g scaffold post`, illustrating the default behavior where components and pages are nested within a directory named after the model (e.g., `Post`).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/cli-commands.md#_snippet_68\n\nLANGUAGE: plaintext\nCODE:\n```\n  √ Generating scaffold files...\n    √ Successfully wrote file `./api/src/graphql/posts.sdl.js`\n    √ Successfully wrote file `./api/src/services/posts/posts.js`\n    √ Successfully wrote file `./api/src/services/posts/posts.scenarios.js`\n    √ Successfully wrote file `./api/src/services/posts/posts.test.js`\n    √ Successfully wrote file `./web/src/layouts/PostsLayout/PostsLayout.js`\n    √ Successfully wrote file `./web/src/pages/Post/EditPostPage/EditPostPage.js`\n    √ Successfully wrote file `./web/src/pages/Post/PostPage/PostPage.js`\n    √ Successfully wrote file `./web/src/pages/Post/PostsPage/PostsPage.js`\n    √ Successfully wrote file `./web/src/pages/Post/NewPostPage/NewPostPage.js`\n    √ Successfully wrote file `./web/src/components/Post/EditPostCell/EditPostCell.js`\n    √ Successfully wrote file `./web/src/components/Post/Post/Post.js`\n    √ Successfully wrote file `./web/src/components/Post/PostCell/PostCell.js`\n    √ Successfully wrote file `./web/src/components/Post/PostForm/PostForm.js`\n    √ Successfully wrote file `./web/src/components/Post/Posts/Posts.js`\n    √ Successfully wrote file `./web/src/components/Post/PostsCell/PostsCell.js`\n    √ Successfully wrote file `./web/src/components/Post/NewPost/NewPost.js`\n  √ Adding layout import...\n  √ Adding set import...\n  √ Adding scaffold routes...\n  √ Adding scaffold asset imports...\n```\n\n----------------------------------------\n\nTITLE: Example SSH Connection Error Message\nDESCRIPTION: Shows a common SSH permission denied error message. This indicates a problem with authentication, potentially due to an incorrect username, password, mismatched public key in the server's `~/.ssh/authorized_keys` file, or a missing private key specified with `-i`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nubuntu@192.168.0.122: Permission denied (publickey,password).\n```\n\n----------------------------------------\n\nTITLE: Cleaning Up Homebrew on Mac\nDESCRIPTION: This command runs the Homebrew cleanup process. It removes stale lock files and outdated downloads for formulae and casks, freeing up disk space. It's recommended to run this after uninstalling packages like Node.js.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/04_how-to/using-nvm.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbrew cleanup\n```\n\n----------------------------------------\n\nTITLE: Describing Directory Structure for Function Tests - Bash\nDESCRIPTION: This bash-formatted tree command illustrates the file and folder organization for serverless function and associated tests within a RedwoodJS project. No executable bash code is present; it visually maps out where test scripts and fixtures should be placed relative to the function code. No dependencies are required to interpret this structure beyond the presence of these files in the directory.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/serverless-functions.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\napi\n├── src\n│ ├── functions\n│ │ ├── divide\n│ │ │ ├── divide.ts\n│ │ │ ├── divide.test.ts\n\n```\n\n----------------------------------------\n\nTITLE: Illustrating Asset Placement in web/public Directory (Text)\nDESCRIPTION: Depicts placing assets like `logo.png` (within an `img` subdirectory) and `favicon.png` directly within the `web/public` directory. Files placed here are copied to the build output (`web/dist`) and served statically relative to the site root, bypassing Vite's processing.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/assets-and-files.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nweb/public/\n├── img/\n│  └── logo.png\n└── favicon.png\n```\n\n----------------------------------------\n\nTITLE: Example Default Shell Prompts (Shell)\nDESCRIPTION: These lines show typical default shell prompts seen when connected to a remote server. They often display the username and a generic hostname or IP address, which might not clearly identify the specific server or environment (e.g., production vs. staging).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_25\n\nLANGUAGE: shell\nCODE:\n```\nroot@remote-server:~#\n# or\nuser@192.168.0.122\n```\n\n----------------------------------------\n\nTITLE: SSH Public Key Authentication Connection Command - Shell\nDESCRIPTION: This snippet is the standard SSH connection command when public key authentication has been configured. Dependencies are the presence of a local public/private keypair, with the public key available on the server. Inputs are the username and server address. Output is a remote shell session upon successful authentication.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nssh ubuntu@192.168.0.122\n```\n\n----------------------------------------\n\nTITLE: Updating JavaScript Test Scenario Name\nDESCRIPTION: Updates the descriptive name of a JavaScript Jest test scenario to better reflect its purpose: testing that the service returns comments specifically for a single post identified by `postId`.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.test.js\"\n// highlight-start\nscenario(\n  'returns all comments for a single post from the database',\n  // highlight-end\n  async (scenario) => {\n    const result = await comments({ postId: scenario.comment.jane.postId })\n    const post = await db.post.findUnique({\n      where: { id: scenario.comment.jane.postId },\n      include: { comments: true },\n    })\n    expect(result.length).toEqual(post.comments.length)\n  }\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a `beforeDestroy` Lifecycle Callback in RedwoodRecord (Future Syntax)\nDESCRIPTION: This snippet illustrates the proposed (not yet implemented) syntax for a `beforeDestroy` lifecycle callback. This static async function would run before a record instance (e.g., `user`) is deleted. It can be used to perform checks or enforce constraints, potentially throwing an error to prevent deletion if conditions aren't met (e.g., ensuring team ownership is transferred).\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/redwoodrecord.md#_snippet_36\n\nLANGUAGE: jsx\nCODE:\n```\nexport default class User extends RedwoodRecord {\n  static beforeDestroy = async (user) => {\n    if ((await user.teams.count()) !== 0) {\n      throw new Error('Please transfer ownership of your teams first')\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting All Prisma Migrations (Linux/Mac - Bash)\nDESCRIPTION: Recursively removes the entire migrations directory from the project using the rm command. Used for resetting migrations during a database switch from SQLite to Postgres. Irreversible; ensure important migration data is backed up before running.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/local-postgres-setup.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nrm -rf api/db/migrations\n```\n\n----------------------------------------\n\nTITLE: Displaying Help for RedwoodJS Deployment Setup Command\nDESCRIPTION: Executes the RedwoodJS CLI `setup deploy` command with the `--help` flag. This displays usage information and available options for configuring the project for deployment to various hosting providers (e.g., Netlify, Vercel, Render, AWS). The command helps generate necessary configuration files.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/01_quick-start.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw setup deploy --help\n```\n\n----------------------------------------\n\nTITLE: SSH Private Key Authentication and Permission Error - Shell\nDESCRIPTION: This snippet shows SSH command-line usage for connecting with a private key using the -i flag and illustrates the warning and error message if the private key file permissions are too permissive. The SSH client is required, the inputs include a PEM path, username, and server. Output includes a permissions error if the file is world-readable. The main limitation is the need to secure the private key file with strict permissions before SSH will use it.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nssh -i ~/.ssh/keyname.pem ubuntu@192.168.0.122\\n\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\nPermissions 0666 for '/Users/rob/.ssh/shared/algostake.pem' are too open.\\nIt is required that your private key files are NOT accessible by others.\\nThis private key will be ignored.\n```\n\n----------------------------------------\n\nTITLE: Updating TypeScript Test Scenario Name\nDESCRIPTION: Updates the descriptive name of a TypeScript Jest test scenario in `comments.test.ts`. This clarifies that the test verifies the retrieval of comments associated only with the specified post.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/02_tutorial/09_chapter6/comment-form.md#_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript title=\"api/src/services/comments/comments.test.ts\"\n// highlight-start\nscenario(\n  'returns all comments for a single post from the database',\n  // highlight-end\n  async (scenario: StandardScenario) => {\n    const result = await comments({ postId: scenario.comment.jane.postId })\n    const post = await db.post.findUnique({\n      where: { id: scenario.comment.jane.postId },\n      include: { comments: true },\n    })\n    expect(result.length).toEqual(post.comments.length)\n  }\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Updating Function to Throw Error on Incorrect Argument Count in JavaScript\nDESCRIPTION: This snippet shows the modified `add` function, updated to meet the requirements of the error test. It uses the rest parameter syntax (`...nums`) to capture all arguments into an array. It then checks if the length of the `nums` array is exactly 2. If not, it explicitly throws the error message 'add() requires two arguments'. Otherwise, it proceeds to return the sum of the first two arguments.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/testing.md#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst add = (...nums) => {\n  if (nums.length !== 2) {\n    throw 'add() requires two arguments'\n  }\n  return nums[0] + nums[1]\n}\n```\n\n----------------------------------------\n\nTITLE: Example SSH Login Welcome Message (Ubuntu)\nDESCRIPTION: Displays a typical welcome message shown upon successfully logging into an Ubuntu server via SSH. It includes system information like OS version, load, memory usage, IP addresses, and the command prompt (`root@remote-server:~#`). The specific message may vary based on the server's OS and configuration.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nWelcome to Ubuntu 22.04 LTS (GNU/Linux 5.15.0-41-generic x86_64)\n\n * Documentation:  https://help.ubuntu.com\n * Management:     https://landscape.canonical.com\n * Support:        https://ubuntu.com/advantage\n\n  System information as of Wed Aug  3 21:09:41 UTC 2022\n\n  System load:  0.25439453125     Users logged in:       0\n  Usage of /:   6.3% of 24.05GB   IPv4 address for eth0: 192.168.0.122\n  Memory usage: 22%               IPv4 address for eth0: 10.48.0.5\n  Swap usage:   0%                IPv4 address for eth1: 10.124.0.2\n  Processes:    97\n\n0 updates can be applied immediately.\n\nThe programs included with the Ubuntu system are free software;\nthe exact distribution terms for each program are described in the\nindividual files in /usr/share/doc/*/copyright.\n\nUbuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by\napplicable law.\n\nroot@remote-server:~#\n```\n\n----------------------------------------\n\nTITLE: Deploying RedwoodJS Project to Edgio Interactively (Shell)\nDESCRIPTION: This command initiates the deployment of the configured RedwoodJS project to Edgio in an interactive mode. If it's the first deployment, it will prompt for browser-based authentication with Edgio.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/deploy/edgio.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn rw deploy edgio\n```\n\n----------------------------------------\n\nTITLE: Inspecting SSH Known Hosts File - Shell\nDESCRIPTION: This code snippet shows the file path to the SSH known_hosts, where all previously accepted remote server keys are stored. Users can look up and edit this file directly, for example, to resolve key fingerprint conflicts. No dependencies other than file system access are required. Input/output is handled via file access.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n~/.ssh/known_hosts\n```\n\n----------------------------------------\n\nTITLE: Creating the Docusaurus Project Directory using mkdir\nDESCRIPTION: This terminal command creates a directory named `docs` at the root of the project using the `mkdir` command. This step ensures the directory exists before proceeding with Docusaurus setup, although it might be redundant if `create-docusaurus` already created it.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/graphql.md#_snippet_87\n\nLANGUAGE: terminal\nCODE:\n```\nmkdir docs // if needed\n```\n\n----------------------------------------\n\nTITLE: Example Git Branch Naming Convention\nDESCRIPTION: These are examples illustrating a suggested naming convention for Git branches, attributed to contributor David Price. The pattern involves using the contributor's initials followed by a hyphenated, descriptive name for the branch's purpose (e.g., `dsp-add-eslint-config-redwood-toml`). These are not executable commands but examples to guide branch organization.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/contributing-walkthrough.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n<davids_initials>-description-with-hyphens\n```\n\nLANGUAGE: text\nCODE:\n```\ndsp-add-eslint-config-redwood-toml\n```\n\n----------------------------------------\n\nTITLE: Example Customized Shell Prompt (Shell)\nDESCRIPTION: This line shows an example of a customized shell prompt designed for better server identification. It includes the application name (\"ruby\"), environment (\"prod\"), and server instance number (\"1\"), making it easier to distinguish between different servers.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_26\n\nLANGUAGE: shell\nCODE:\n```\nroot@ruby-prod1:~#\n```\n\n----------------------------------------\n\nTITLE: Reloading Zsh Configuration (Shell)\nDESCRIPTION: The `source ~/.zshrc` command executes the commands within the `.zshrc` file in the current Zsh shell session. This is necessary to make newly added configurations, such as aliases, available immediately without restarting the shell.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_32\n\nLANGUAGE: shell\nCODE:\n```\nsource ~/.zshrc\n```\n\n----------------------------------------\n\nTITLE: Using an SSH Connection Alias (Shell)\nDESCRIPTION: This command demonstrates the usage of a previously defined shell alias (`ruby-prod1`). Typing this alias executes the associated SSH command (`ssh root@192.168.0.122`), initiating a connection to the remote server. This requires the alias to be defined and sourced in the active shell session.\nSOURCE: https://github.com/emelleby/docwood/blob/main/docs/content/03_reference/docs/intro-to-servers.md#_snippet_33\n\nLANGUAGE: shell\nCODE:\n```\nruby-prod1\n```"
  }
]