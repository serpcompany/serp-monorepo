[
  {
    "owner": "6p5ra",
    "repo": "keyring-rs-docs",
    "content": "TITLE: Storing, Retrieving, and Deleting Passwords with keyring-rs Entry in Rust\nDESCRIPTION: This Rust example demonstrates the usage of the keyring-rs crate's Entry struct to securely manage a password within an application. It includes importing the Entry type, creating an Entry with service and user names, setting a password, retrieving it, comparing it for correctness, deleting the credential, and handling possible errors when accessing deleted entries. The snippet showcases basic methods: Entry::new, set_password, get_password, and delete_credential. It depends on the keyring crate and expects to handle keyring::Error accordingly during these operations.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Import the necessary item from the keyring crate\nuse keyring::Entry;\n\nfn main() -> Result<(), keyring::Error> { // We'll cover Result and Error later!\n\n    // 1. Create an Entry\n    // We need a 'service' name and a 'user' name.\n    println!(\"Creating an Entry for service='Super Productive App', user='alice'\");\n    let entry = Entry::new(\"Super Productive App\", \"alice\")?;\n    // `entry` is now our handle to this specific slot.\n\n    // 2. Store a password\n    let my_secret_password = \"Password123!\";\n    println!(\"Storing the password...\");\n    entry.set_password(my_secret_password)?;\n    println!(\"Password stored successfully!\");\n\n    // 3. Retrieve the password\n    println!(\"Retrieving the password...\");\n    let retrieved_password = entry.get_password()?;\n    println!(\"Retrieved password: {}\", retrieved_password);\n\n    // Let's check if it matches!\n    assert_eq!(my_secret_password, retrieved_password);\n    println!(\"Passwords match!\");\n\n    // 4. Delete the password\n    println!(\"Deleting the password...\");\n    entry.delete_credential()?;\n    println!(\"Password deleted.\");\n\n    // Optional: Try retrieving it again (this should fail)\n    // We'll discuss errors like this in Chapter 3.\n    match entry.get_password() {\n        Ok(_) => println!(\"Password still exists? (This shouldn't happen)\"),\n        Err(e) => println!(\"Correctly failed to get password after deletion: {}\", e),\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Passwords and Secrets with keyring-rs in Rust\nDESCRIPTION: Demonstrates using `keyring::Entry` in Rust to manage credentials. It shows how to store and retrieve text passwords using `set_password`/`get_password` and binary secrets using `set_secret`/`get_secret`, including cleanup with `delete_credential`. Requires the `keyring` crate.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse keyring::Entry;\n\nfn main() -> Result<(), keyring::Error> {\n    // Create the same Entry as before\n    let entry = Entry::new(\"Super Productive App\", \"alice\")?;\n\n    // -- Password Handling (Text) --\n    println!(\"Handling password (text)...\");\n    let my_password = \"super-secret-text-password\";\n    entry.set_password(my_password)?;\n    println!(\"Password stored.\");\n\n    let retrieved_password = entry.get_password()?;\n    println!(\"Retrieved password: {}\", retrieved_password);\n    assert_eq!(my_password, retrieved_password);\n    println!(\"Password matches!\");\n\n    // Clean up the password entry before trying the secret\n    entry.delete_credential()?;\n    println!(\"Password deleted.\");\n\n    // -- Secret Handling (Binary Data) --\n    println!(\"\\nHandling secret (binary data)...\");\n    // Let's imagine this is some non-text token or key\n    let my_secret_data: &[u8] = &[0xDE, 0xAD, 0xBE, 0xEF, 0x12, 0x34];\n    entry.set_secret(my_secret_data)?;\n    println!(\"Secret stored.\");\n\n    let retrieved_secret: Vec<u8> = entry.get_secret()?;\n    // We print the bytes as hex for readability\n    println!(\"Retrieved secret (bytes): {:X?}\", retrieved_secret);\n    assert_eq!(my_secret_data, retrieved_secret.as_slice());\n    println!(\"Secret matches!\");\n\n    // Clean up the secret entry\n    entry.delete_credential()?;\n    println!(\"Secret deleted.\");\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Keyring Usage Example (Rust)\nDESCRIPTION: Demonstrates the core usage of the keyring-rs library. It shows how to create an Entry for a specific service and user, set a password using `set_password`, retrieve it using `get_password`, and delete it using `delete_credential`. This single code block works across macOS, Windows, and Linux without modification due to keyring-rs's platform abstraction.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse keyring::Entry;\n\nfn main() -> Result<(), keyring::Error> {\n    // 1. Create an Entry\n    println!(\"Creating an Entry for service='MyWebApp', user='testuser'\");\n    let entry = Entry::new(\"MyWebApp\", \"testuser\")?;\n\n    // 2. Store a password\n    let my_secret = \"SuperSecure123\";\n    println!(\"Storing the password...\");\n    entry.set_password(my_secret)?; // Uses keyring-rs 'button'\n    println!(\"Password stored!\");\n\n    // 3. Retrieve the password\n    println!(\"Retrieving the password...\");\n    let retrieved = entry.get_password()?; // Uses keyring-rs 'button'\n    println!(\"Retrieved: {}\", retrieved);\n    assert_eq!(my_secret, retrieved);\n\n    // 4. Delete the password\n    println!(\"Deleting the password...\");\n    entry.delete_credential()?; // Uses keyring-rs 'button'\n    println!(\"Password deleted.\");\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Adding keyring-rs Dependency in Cargo.toml Using TOML\nDESCRIPTION: This snippet shows how to add the keyring crate as a dependency in your Rust project's Cargo.toml file. It uses version 4 or the latest available, enabling your project to use keyring-rs for secure secret management.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nkeyring = \"4\" # Or the latest version\n```\n\n----------------------------------------\n\nTITLE: Basic Secret Storage Using keyring-rs\nDESCRIPTION: A simple example demonstrating how to use keyring-rs to store a password securely, which will be automatically directed to the appropriate OS credential store backend.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse keyring::Entry;\n\nfn main() -> Result<(), keyring::Error> {\n    let entry = Entry::new(\"MyCoolApp\", \"user@example.com\")?;\n    entry.set_password(\"my-secret-password\")?; // <--- This line!\n    println!(\"Password stored!\");\n    // ... retrieve and delete ...\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Adding keyring-rs dependency\nDESCRIPTION: This snippet shows how to add the keyring-rs dependency to a Rust project's Cargo.toml file.  This is the basic dependency declaration without specifying any optional features.  It uses the default features provided by keyring-rs.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_11\n\nLANGUAGE: toml\nCODE:\n```\n# In your Cargo.toml file\n[dependencies]\nkeyring = \"4\" # Or the latest version\n```\n\n----------------------------------------\n\nTITLE: Defining CredentialStore Trait (Conceptual) in Rust\nDESCRIPTION: This code defines a conceptual `CredentialStore` trait in Rust. It specifies the required methods for any backend to interact with `keyring-rs`: `set_credential`, `get_credential`, and `delete_credential`. These methods define the core operations needed for storing, retrieving, and deleting credentials.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\n// Conceptual representation of the core trait\n\n/// Represents the required capabilities of any secure credential storage.\npub trait CredentialStore {\n    /// Stores a credential (either password or binary secret).\n    /// Needs the service name, username, and the data itself.\n    fn set_credential(&self, service: &str, username: &str, secret: &[u8]) -> Result<(), keyring::Error>;\n\n    /// Retrieves a credential's secret data (as bytes).\n    /// Needs the service name and username to find the correct one.\n    fn get_credential(&self, service: &str, username: &str) -> Result<Vec<u8>, keyring::Error>;\n\n    /// Deletes a credential from the store.\n    /// Needs the service name and username to identify it.\n    fn delete_credential(&self, service: &str, username: &str) -> Result<(), keyring::Error>;\n\n    // There might be other methods for listing, etc., but these are the core.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CredentialStore Trait for Custom Store in Rust\nDESCRIPTION: This code implements the conceptual `CredentialStore` trait for the `MyInsecureFileStore` struct. It provides implementations for `set_credential`, `get_credential`, and `delete_credential`, using the in-memory HashMap for storage and retrieval. Note that this implementation is insecure and intended for demonstration purposes only.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_17\n\nLANGUAGE: Rust\nCODE:\n```\n// Implementing the trait for our custom store\n\n// Assume CredentialStore trait exists as defined conceptually above\nimpl CredentialStore for MyInsecureFileStore {\n    fn set_credential(&self, service: &str, username: &str, secret: &[u8]) -> Result<(), Error> {\n        let key = make_key(service, username);\n        let mut data = self.data.lock().unwrap(); // Lock the data for access\n        println!(\"(Custom Store) Storing secret for key: {}\", key);\n        data.insert(key, secret.to_vec());\n        // In a real implementation, we would now serialize `data` and write it\n        // securely to self.file_path. We'll skip that here.\n        Ok(())\n    }\n\n    fn get_credential(&self, service: &str, username: &str) -> Result<Vec<u8>, Error> {\n        let key = make_key(service, username);\n        let data = self.data.lock().unwrap(); // Lock the data for read access\n        println!(\"(Custom Store) Getting secret for key: {}\", key);\n        match data.get(&key) {\n            Some(secret) => Ok(secret.clone()), // Found it! Return a copy.\n            None => Err(Error::NoCredentialFound), // Not found. Return standard error.\n        }\n        // A real implementation would read from self.file_path first.\n    }\n\n    fn delete_credential(&self, service: &str, username: &str) -> Result<(), Error> {\n        let key = make_key(service, username);\n        let mut data = self.data.lock().unwrap(); // Lock for modification\n        println!(\"(Custom Store) Deleting secret for key: {}\", key);\n        if data.remove(&key).is_some() {\n            // In a real implementation, write the updated `data` back to the file.\n            Ok(())\n        } else {\n            Err(Error::NoCredentialFound) // Nothing to delete.\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sequence Diagram of Credential Storage with Keyring-rs\nDESCRIPTION: This sequence diagram illustrates the flow of events when storing a secret using keyring-rs.  It starts with a call from your application, proceeds through the Entry object and keyring-rs core logic, and finally interacts with the active backend (a trait object).  Dynamic dispatch ensures the correct backend implementation is called, which then uses the OS API to store the credential.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_18\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant YourApp as Your Application\n    participant Entry as Entry Object\n    participant KeyringCore as keyring-rs Core Logic\n    participant ActiveBackend as Active Backend <br> (Trait Object: dyn CredentialStore)\n    participant ActualStore as OS Vault (e.g., Keychain)\n\n    YourApp->>Entry: entry.set_password(\"secret\") for (svc, usr)\n    Entry->>KeyringCore: Request store \"secret\" for (svc, usr)\n    KeyringCore->>ActiveBackend: backend.set_credential(svc, usr, \"secret\")\n    Note right of ActiveBackend: Rust uses dynamic dispatch <br/> to call the *correct* backend's <br/> implementation (e.g., Keychain's).\n    ActiveBackend->>ActualStore: Call native OS API (e.g., SecItemAdd)\n    ActualStore-->>ActiveBackend: Return OS Result\n    ActiveBackend-->>KeyringCore: Return translated Result<(), keyring::Error>\n    KeyringCore-->>Entry: Return Result\n    Entry-->>YourApp: Return Result\n```\n\n----------------------------------------\n\nTITLE: Sequence Diagram of `get_password` Flow (Mermaid)\nDESCRIPTION: Visualizes the internal sequence of operations when an application calls `get_password` via keyring-rs. It shows how the library detects the operating system, forwards the request to the corresponding backend (macOS, Windows, or Linux), interacts with the native OS credential store, and translates the result back to the application, abstracting the platform-specific details.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant YourApp as Your Application\n    participant KeyringLib as keyring-rs (Core)\n    participant MacBackend as macOS Backend\n    participant WinBackend as Windows Backend\n    participant LinuxBackend as Linux Backend\n    participant OS_Store as Actual OS Store\n\n    YourApp->>KeyringLib: entry.get_password()?\n    KeyringLib->>KeyringLib: Detect OS (e.g., macOS)\n    KeyringLib->>MacBackend: Forward get_password request\n    MacBackend->>OS_Store: Call macOS Keychain API\n    OS_Store-->>MacBackend: Return password data (or OS error)\n    MacBackend-->>KeyringLib: Return Ok(password) (or translated Err)\n    KeyringLib-->>YourApp: Return Ok(password) (or translated Err)\n\n    %% Example if running on Windows instead %%\n    <<alt OS is Windows>>\n        KeyringLib->>KeyringLib: Detect OS (e.g., Windows)\n        KeyringLib->>WinBackend: Forward get_password request\n        WinBackend->>OS_Store: Call Windows Credential Manager API\n        OS_Store-->>WinBackend: Return password data (or OS error)\n        WinBackend-->>KeyringLib: Return Ok(password) (or translated Err)\n        KeyringLib-->>YourApp: Return Ok(password) (or translated Err)\n    <</alt>>\n\n```\n\n----------------------------------------\n\nTITLE: Visualizing Password vs. Secret Storage Flow in keyring-rs\nDESCRIPTION: A Mermaid sequence diagram illustrating the internal process within `keyring-rs` when storing credentials. It contrasts the flow for text passwords (`set_password`) and binary secrets (`set_secret`), showing interaction with the OS backend and storage.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant YourApp as Your Application\n    participant Entry as Entry Object\n    participant KeyringLib as keyring-rs Library\n    participant OS_Backend as OS Credential Store Backend\n    participant OS_Store as Actual OS Store\n\n    alt Password (Text) Path\n        YourApp->>Entry: entry.set_password(\"MyTextPassword\")\n        Entry->>KeyringLib: Request: Store TEXT data \"MyTextPassword\" for (service, user)\n        KeyringLib->>OS_Backend: Store TEXT \"MyTextPassword\" for (service, user)\n        OS_Backend->>OS_Store: Use OS API for storing TEXT data\n        OS_Store-->>OS_Backend: Confirm storage\n        OS_Backend-->>KeyringLib: Success\n        KeyringLib-->>Entry: Success\n        Entry-->>YourApp: Ok(())\n    else Secret (Binary) Path\n        YourApp->>Entry: entry.set_secret(&[0xDE, 0xAD])\n        Entry->>KeyringLib: Request: Store BINARY data [DE, AD] for (service, user)\n        KeyringLib->>OS_Backend: Store BINARY [DE, AD] for (service, user)\n        OS_Backend->>OS_Store: Use OS API for storing BINARY data\n        OS_Store-->>OS_Backend: Confirm storage\n        OS_Backend-->>KeyringLib: Success\n        KeyringLib-->>Entry: Success\n        Entry-->>YourApp: Ok(())\n    end\n```\n\n----------------------------------------\n\nTITLE: Backend Selection Flow Diagram\nDESCRIPTION: A sequence diagram illustrating how keyring-rs detects the OS, selects the appropriate credential store backend, and handles the communication with the operating system secure vault.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_9\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant YourApp as Your Application\n    participant KeyringLib as keyring-rs (Core)\n    participant MacBackend as macOS Keychain Backend\n    participant WinBackend as Windows Credential Manager Backend\n    participant LinBackend as Linux Secret Service Backend\n    participant OS_Vault as OS Secure Vault\n\n    YourApp->>KeyringLib: entry.set_password(\"pwd\") for (svc, usr)\n    KeyringLib->>KeyringLib: Detect OS (e.g., Windows)\n    KeyringLib->>WinBackend: Use Windows Backend to store password\n    WinBackend->>OS_Vault: Call Windows API (e.g., CredWriteW)\n    OS_Vault-->>WinBackend: Confirm storage (or OS Error)\n    WinBackend-->>KeyringLib: Translate to Ok(()) or keyring::Error\n    KeyringLib-->>YourApp: Return Result<(), keyring::Error>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Password Retrieval Flow in keyring-rs with Mermaid Diagram\nDESCRIPTION: This Mermaid sequence diagram visually depicts the flow of a get_password call in keyring-rs. It shows how an application calls Entry, which forwards the request to the keyring-rs library, which then interacts with the OS-specific backend and the underlying secure credential store (e.g., Keychain or Credential Manager). The diagram highlights the layered architecture and data flow of a password retrieval operation.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant YourApp as Your Application\n    participant Entry as Entry Object\n    participant KeyringLib as keyring-rs Library\n    participant OS_Backend as OS Credential Store Backend\n    participant OS_Store as Actual OS Store (e.g., Keychain)\n\n    YourApp->>Entry: entry.get_password()?\n    Entry->>KeyringLib: Request password for (\"Super Productive App\", \"alice\")\n    KeyringLib->>OS_Backend: Find password for (\"Super Productive App\", \"alice\")\n    OS_Backend->>OS_Store: Read credential matching service/user\n    OS_Store-->>OS_Backend: Return stored password data\n    OS_Backend-->>KeyringLib: Return password string\n    KeyringLib-->>Entry: Return password string\n    Entry-->>YourApp: Return password string\n```\n\n----------------------------------------\n\nTITLE: Conceptual Internal Structure of `keyring-rs` using `cfg` (Rust)\nDESCRIPTION: Provides a simplified, illustrative example of how keyring-rs might internally use Rust's conditional compilation features (`#[cfg(target_os = ...)]`) to dispatch calls like `get_password` to the appropriate OS-specific backend module (macOS, Windows, Linux) at compile time. This demonstrates the principle of selecting platform-specific code while maintaining a unified public API. Note: This is not the actual implementation.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// In keyring-rs library (conceptual)\n\n// The public function you call\npub fn get_password(service: &str, user: &str) -> Result<String, keyring::Error> {\n    // Check which OS we are on\n    #[cfg(target_os = \"macos\")]\n    {\n        // Call the macOS specific implementation\n        macos_backend::get_password_from_keychain(service, user)\n    }\n    #[cfg(target_os = \"windows\")]\n    {\n        // Call the Windows specific implementation\n        windows_backend::get_password_from_credmanager(service, user)\n    }\n    #[cfg(all(unix, not(target_os = \"macos\")))] // Simplified Linux check\n    {\n        // Call the Linux specific implementation\n        linux_backend::get_password_from_secretservice(service, user)\n    }\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\", all(unix, not(target_os = \"macos\")))))]\n    {\n        // If no backend is available for this OS\n        Err(keyring::Error::BackendNotAvailable)\n    }\n}\n\n// --- In a separate file: macos_backend.rs ---\n#[cfg(target_os = \"macos\")]\nmod macos_backend {\n    pub fn get_password_from_keychain(service: &str, user: &str) -> Result<String, keyring::Error> {\n        // ... code talking to macOS Keychain APIs ...\n        // ... translate results/errors to keyring::Error ...\n    }\n}\n\n// --- Similarly for windows_backend.rs and linux_backend.rs ---\n```\n\n----------------------------------------\n\nTITLE: Enabling 'encrypted' feature flag\nDESCRIPTION: This snippet shows how to enable the `encrypted` feature flag in Cargo.toml to ensure encrypted communication with the Linux Secret Service.  The expanded table format is used.  It also demonstrates how to combine multiple feature flags.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\n# In your Cargo.toml file\n[dependencies]\n# You can list multiple features\nkeyring = { version = \"4\", features = [\"encrypted\"] }\n# Or combine them if needed, e.g.:\n# keyring = { version = \"4\", features = [\"vendored\", \"encrypted\"] }\n```\n\n----------------------------------------\n\nTITLE: Enabling 'vendored' feature flag\nDESCRIPTION: This snippet demonstrates how to enable the `vendored` feature flag in the Cargo.toml file.  This feature is used to statically link `libdbus` into the application on Linux, avoiding a runtime dependency on the system's `libdbus` library.  The expanded table format is used to specify the feature.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_12\n\nLANGUAGE: toml\nCODE:\n```\n# In your Cargo.toml file\n[dependencies]\n# Use the expanded format to specify features\nkeyring = { version = \"4\", features = [\"vendored\"] }\n```\n\n----------------------------------------\n\nTITLE: Conditional compilation example\nDESCRIPTION: This Rust code snippet illustrates conditional compilation using `#[cfg(feature = \"feature_name\")]`. It demonstrates how different code blocks are included or excluded based on the presence of a feature flag defined in `Cargo.toml`. This controls whether a bundled or system-wide `libdbus` library is used.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n// Conceptual code inside keyring-rs's Linux backend\n\n// This function is always defined\nfn connect_to_dbus() {\n    println!(\"Trying to connect to D-Bus...\");\n\n    // Check if the 'vendored' feature is enabled AT COMPILE TIME\n    #[cfg(feature = \"vendored\")]\n    {\n        // This code block is ONLY included if 'vendored' feature is enabled\n        println!(\"Using bundled (vendored) libdbus library.\");\n        // ... code to initialize the bundled libdbus ...\n    }\n\n    // Check if the 'vendored' feature is NOT enabled AT COMPILE TIME\n    #[cfg(not(feature = \"vendored\"))]\n    {\n        // This code block is ONLY included if 'vendored' feature is NOT enabled\n        println!(\"Using system's libdbus library (dynamic linking).\");\n        // ... code to find and load the system libdbus ...\n    }\n\n    // ... rest of the connection logic ...\n}\n\nfn main() {\n    connect_to_dbus();\n}\n```\n\n----------------------------------------\n\nTITLE: Conceptual Backend Dispatch Implementation\nDESCRIPTION: A conceptual example showing how keyring-rs might implement its platform-specific dispatching using conditional compilation to select the appropriate backend based on the target operating system.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n// Conceptual structure within keyring-rs\n\n// This function figures out which backend to call\nfn dispatch_set_password(entry: &Entry, password: &str) -> Result<(), Error> {\n    // Conditional compilation checks the OS when the code is built\n    #[cfg(target_os = \"macos\")]\n    {\n        // If building for macOS, call the macOS backend function\n        backends::macos::store_credential(entry.service(), entry.username(), password)\n    }\n    #[cfg(target_os = \"windows\")]\n    {\n        // If building for Windows, call the Windows backend function\n        backends::windows::store_credential(entry.service(), entry.username(), password)\n    }\n    #[cfg(all(unix, not(target_os = \"macos\")))] // Simplified Linux check\n    {\n        // If building for Linux, call the Secret Service backend function\n        backends::secretservice::store_credential(entry.service(), entry.username(), password)\n    }\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\", all(unix, not(target_os = \"macos\"))))]\n    {\n        // If no backend is implemented for the current OS\n        Err(Error::BackendNotAvailable)\n    }\n}\n\n// --- Example backend module for Windows (highly simplified concept) ---\n#[cfg(target_os = \"windows\")]\nmod windows {\n    use crate::{Error, /* other internal types */};\n\n    // This function contains Windows-specific logic\n    pub(crate) fn store_credential(service: &str, user: &str, password: &str) -> Result<(), Error> {\n        // 1. Prepare data structures needed by Windows Credential Manager API.\n        // 2. Call Windows functions like `CredWriteW`.\n        // 3. Check the result returned by Windows.\n        // 4. If Windows reported an error, translate it to a `keyring::Error`.\n        // 5. Return `Ok(())` or `Err(translated_error)`.\n        println!(\"Conceptual: Storing credential using Windows backend\");\n        // In real code, this would interact with winapi or similar crates.\n        Ok(()) // Placeholder for success\n    }\n    // ... other functions for get, delete specific to Windows ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Insecure File Store in Rust\nDESCRIPTION: This code defines a custom struct `MyInsecureFileStore` to represent a simple (and insecure) credential store that uses a plain text file. It includes a `file_path` for the storage location and a `HashMap` (protected by a Mutex) for in-memory storage, simulating a cache. A helper function `make_key` creates a unique key from the service and username.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_16\n\nLANGUAGE: Rust\nCODE:\n```\n// In your own code\n\nuse std::collections::HashMap;\nuse std::fs;\nuse std::io;\nuse std::path::PathBuf;\nuse keyring::Error; // Use the standard error type\n\n// Our custom store structure - holds the path to the file\nstruct MyInsecureFileStore {\n    file_path: PathBuf,\n    // We'll use a HashMap in memory as a simple cache/representation\n    // In a real scenario, you'd handle file I/O more directly & securely.\n    data: std::sync::Mutex<HashMap<String, Vec<u8>>>>,\n}\n\n// Helper method to create a unique key for our map/file\nfn make_key(service: &str, username: &str) -> String {\n    format!(\"{}::{}\", service, username)\n}\n```\n\n----------------------------------------\n\nTITLE: Keyring-rs Architecture Overview\nDESCRIPTION: This flowchart diagram provides an overview of the keyring-rs architecture and the relationships between key components. It visualizes how the Entry object interacts with Platform Abstraction and the Credential Store Backend and highlights error handling, feature flags, and secret/password management.\nSOURCE: https://github.com/6p5ra/keyring-rs-docs/blob/main/keyring-rs.md#_snippet_19\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    A0[\"Entry\n\"]\n    A1[\"Credential Store Backend\n\"]\n    A2[\"Platform Abstraction\n\"]\n    A3[\"Error Handling (`keyring::Error`)\n\"]\n    A4[\"Feature Flags\n\"]\n    A5[\"Secret vs. Password Handling\n\"]\n    A6[\"Extensibility (Traits)\n\"]\n    A0 -- \"Uses for operations\" --> A2\n    A2 -- \"Selects and uses\" --> A1\n    A0 -- \"Returns errors via\" --> A3\n    A1 -- \"Generates errors wrapped by\" --> A3\n    A0 -- \"Implements methods for\" --> A5\n    A2 -- \"Handles data types via\" --> A5\n    A4 -- \"Configure available\" --> A1\n    A6 -- \"Defines interface for\" --> A1\n```"
  }
]