[
  {
    "owner": "swiftlang",
    "repo": "swift-syntax",
    "content": "TITLE: Implementing the `EnumSubsetMacro` using SwiftSyntax\nDESCRIPTION: Provides the Swift implementation for the `EnumSubsetMacro`. It conforms to `MemberMacro`, defines custom errors (`EnumSubsetError`), and implements the `expansion` function to generate an initializer (`init?`). The implementation uses SwiftSyntax APIs to inspect the attached enum declaration (`EnumDeclSyntax`), extract its cases, retrieve the superset type from the generic parameter using attribute inspection, and build the `InitializerDeclSyntax` and `SwitchExprSyntax` using result builders and string interpolation.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacros/SwiftSyntaxMacros.docc/SwiftSyntaxMacros.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nenum EnumSubsetError: CustomStringConvertible, Error {\n  case onlyApplicableToEnum\n  case noGenericParameterName\n  \n  var description: String {\n    switch self {\n    case .onlyApplicableToEnum: return \"@EnumSubset can only be applied to an enum\"\n    case .noGenericParameterName: return \"Missing generic parameter specifying the enum's superset\"\n    }\n  }\n}\n\npublic enum EnumSubsetMacro: MemberMacro {\n  public static func expansion(\n    of attribute: AttributeSyntax,\n    providingMembersOf declaration: some DeclGroupSyntax,\n    in context: some MacroExpansionContext\n  ) throws -> [DeclSyntax] {\n    guard let enumDecl = declaration.as(EnumDeclSyntax.self) else {\n      throw EnumSubsetError.onlyApplicableToEnum\n    }\n\n    // Extract the name of the generic parameter. \n    // See section *Inspect the SwiftSyntax Tree* for more details on building this expression.\n    guard let supersetType = attribute\n      .attributeName.as(SimpleTypeIdentifierSyntax.self)?\n      .genericArgumentClause?\n      .arguments.first?\n      .argumentType else {\n      throw EnumSubsetError.noGenericParameterName\n    }\n    \n    // Extract all the enum elements\n    let members = enumDecl.memberBlock.members\n    let caseDecls = members.compactMap { $0.decl.as(EnumCaseDeclSyntax.self) }\n    let elements = caseDecls.flatMap { $0.elements }\n    \n    // Build the initializer using a result builder\n    let initializer = try InitializerDeclSyntax(\"init?(_ superset: \\(supersetType))\") {\n      try SwitchExprSyntax(\"switch superset\") {\n        for element in elements {\n          SwitchCaseSyntax(\n            \"\"\"\n            case .\\(element.identifier):\n              self = .\\(element.identifier)\n            \"\"\"\n          )\n        }\n        SwitchCaseSyntax(\"default: return nil\")\n      }\n    }\n    \n    return [DeclSyntax(initializer)]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Unit Testing a Swift Macro Expansion\nDESCRIPTION: Shows how to write a unit test for the 'stringify' macro using the 'assertMacroExpansion' helper function from the 'SwiftSyntaxMacrosTestSupport' module. The test verifies that the macro invocation '#stringify(a + b)' expands to the expected tuple '(a + b, \"a + b\")'. The 'macros' dictionary maps the macro's name to its implementation type to enable expansion in the test context. This test approach facilitates validating macro behavior and debugging expansions.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacros/SwiftSyntaxMacros.docc/SwiftSyntaxMacros.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nfunc testStringifyMacro() {\n  assertMacroExpansion(\n    \"\"\"\n    #stringify(a + b)\n    \"\"\",\n    expandedSource: \"\"\"\n    (a + b, \"a + b\")\n    \"\"\",\n    macros: [\"stringify\": StringifyMacro.self]\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Swift source code with SwiftParser\nDESCRIPTION: This snippet demonstrates how to use the Parser.parse method to convert Swift source code into a syntax tree. It imports the necessary dependencies, defines a sample source code string, parses it into a SourceFileSyntax object, and shows how to access the parsed content.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftParser/SwiftParser.docc/SwiftParser.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport SwiftParser\n#if compiler(>=6)\ninternal import SwiftSyntax\n#else\nimport SwiftSyntax\n#endif\n\nlet sourceText =\n\"\"\"\nfunc greeting(name: String) {\n  print(\"Hello, \\(name)!\")\n}\n\"\"\"\n\n// Parse the source code in sourceText into a syntax tree\nlet sourceFile: SourceFileSyntax = Parser.parse(source: sourceText)\n\n// The \"description\" of the source tree is the source-accurate view of what was parsed.\nassert(sourceFile.description == sourceText)\n\n// Visualize the complete syntax tree.\ndump(sourceFile)\n```\n\n----------------------------------------\n\nTITLE: Creating Parameterized ClassDeclSyntax using String Interpolation (Swift)\nDESCRIPTION: Illustrates creating a function that generates a `ClassDeclSyntax` node using string interpolation to parameterize the class name. This technique leverages the parsing capabilities enabled by importing `SwiftSyntax` and `SwiftParser` (implicitly used via `SwiftSyntaxBuilder`'s string literal conversion) to build syntax trees dynamically.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntax/Documentation.docc/Working with SwiftSyntax.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nimport SwiftSyntax\nimport SwiftParser\n\nfunc createClass(named name: String) -> ClassDeclSyntax {\n  return \"\"\"\n         class \\(raw: name) {}\n         \"\"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Freestanding Expression Macro in Swift\nDESCRIPTION: Declares the 'stringify' macro as a freestanding expression macro in Swift. The declaration specifies a generic function signature taking a parameter of any type 'T' and returning a tuple containing the parameter and its source code as a string. The macro declaration uses '@freestanding(expression)' to indicate its use as a standalone expression macro, and '#externalMacro' to link to the macro implementation in an external module and type.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacros/SwiftSyntaxMacros.docc/SwiftSyntaxMacros.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@freestanding(expression)\npublic macro stringify<T>(_ value: T) -> (T, String) = #externalMacro(module: \"MyMacroMacros\", type: \"StringifyMacro\")\n```\n\n----------------------------------------\n\nTITLE: Using an Expression Macro in Swift Source Code\nDESCRIPTION: Demonstrates usage of the 'stringify' macro as an inline expression prefixed with '#'. The macro expands at compile time into a tuple containing the value of the expression 'a + b' and its source code as a string literal. This example shows how macros integrate syntactically into Swift source code and illustrates the result of expansion.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacros/SwiftSyntaxMacros.docc/SwiftSyntaxMacros.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nlet (result, code) = #stringify(a + b)\n```\n\n----------------------------------------\n\nTITLE: Custom Error Handling for Operator Folding with SwiftOperators (Swift)\nDESCRIPTION: Shows how to capture and handle errors during the operator folding process by supplying a custom error handler closure. Requires SwiftOperators and an initialized OperatorTable. The foldSingle method takes a sequence expression and an error handler closure, accumulating errors as they arise. Inputs include a sequence expression and an error array; outputs include a folded syntax tree and a populated errors array. The folding operation continues despite errors, producing fallback results.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftOperators/SwiftOperators.docc/SwiftOperators.md#_snippet_4\n\nLANGUAGE: Swift\nCODE:\n```\nvar errors: [OperatorError] = []\nlet foldedExpr2e = opPrecedence.foldSingle(sequenceExpr2) { error in \n  errors.append(error)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an Expression Macro Expansion in Swift\nDESCRIPTION: Provides the implementation of the 'StringifyMacro' macro conforming to the 'ExpressionMacro' protocol. The 'expansion' static method receives the syntax node of the macro invocation and a macro expansion context and returns an 'ExprSyntax' node representing the code expansion. It extracts the first macro argument, then returns a tuple expression combining the argument itself and a string literal containing the argument's source code. The method uses custom string interpolation for correct syntax node generation, ensuring the resulting syntax tree is parseable and properly escaped.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacros/SwiftSyntaxMacros.docc/SwiftSyntaxMacros.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\npublic struct StringifyMacro: ExpressionMacro {\n  public static func expansion(\n    of node: some FreestandingMacroExpansionSyntax,\n    in context: some MacroExpansionContext\n  ) -> ExprSyntax {\n    guard let argument = node.argumentList.first?.expression else {\n      fatalError(\"compiler bug: the macro does not have any arguments\")\n    }\n\n    return \"(\\(argument), \\(literal: argument.description))\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Operator Table with Custom Operators and Precedence in SwiftOperators (Swift)\nDESCRIPTION: Demonstrates how to extend the operator and precedence group table in SwiftOperators by parsing new declarations and updating the OperatorTable instance. Requires SwiftSyntax, SwiftParser, and SwiftOperators. Operator and precedence group declarations are supplied as a multi-line string and parsed; then, addSourceFile is used to register them. The process allows folding of new operators in subsequent parse operations. Accurate parsing is required and errors are thrown on failure.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftOperators/SwiftOperators.docc/SwiftOperators.md#_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\nlet moreOperators = \n  \"\"\"\n  precedencegroup ExponentiationPrecedence {\n    associativity: right\n    higherThan: MultiplicationPrecedence\n  }\n\n  infix operator **: ExponentiationPrecedence\n  \"\"\"\nlet parsedOperators = Parser.parse(source: moreOperators)\n\n// Adds **, ExponentiationPrecedence to the set of known operators and precedence groups.\ntry opPrecedence.addSourceFile(parsedOperators) \n\nlet parsed2 = Parser.parse(source: \"b ** c ** d\")\ndump(parsed2) // contains SequenceExprSyntax(b, **, c, **, d)\nlet folded2 = try opPrecedence.foldAll(parsed2)\ndump(folded2) // contains InfixOperatorExpr(b, **, InfixOperatorExpr(c, **, d))\n```\n\n----------------------------------------\n\nTITLE: Parsing Swift Source String with Parser.parse in Swift\nDESCRIPTION: Demonstrates how to use the `Parser.parse` method from the `SwiftParser` library to parse a Swift source code string into a `SourceFileSyntax` object. It imports necessary modules (`SwiftParser`, `SwiftSyntax`), defines a sample Swift function string, calls `Parser.parse`, asserts the parsed tree's description matches the original source, and uses `dump` to visualize the resulting syntax tree. Requires the `SwiftParser` and `SwiftSyntax` libraries.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftParser/README.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport SwiftParser\n#if compiler(>=6)\ninternal import SwiftSyntax\n#else\nimport SwiftSyntax\n#endif\n\nlet sourceText =\n\"\"\"\nfunc greeting(name: String) {\n  print(\"Hello, \\(name)!\")\n}\n\"\"\"\n\n// Parse the source code in sourceText into a syntax tree\nlet sourceFile: SourceFileSyntax = Parser.parse(source: sourceText)\n\n// The \"description\" of the source tree is the source-accurate view of what was parsed.\nassert(sourceFile.description == sourceText)\n\n// Visualize the complete syntax tree.\ndump(sourceFile)\n```\n\n----------------------------------------\n\nTITLE: Declaring the `EnumSubset` Attached Member Macro in Swift\nDESCRIPTION: Shows the Swift declaration of the `EnumSubset` macro using the `@attached(member)` attribute. It specifies that the macro generates members (specifically `init` via `names: named(init)`) and uses a generic parameter (`Superset`) to indicate the enum it subsets from. The `#externalMacro` directive points to the macro's implementation module (`MyMacroMacros`) and type (`EnumSubsetMacro`).\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacros/SwiftSyntaxMacros.docc/SwiftSyntaxMacros.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n@attached(member, names: named(init))\npublic macro EnumSubset<Superset>() = #externalMacro(module: \"MyMacroMacros\", type: \"EnumSubsetMacro\")\n```\n\n----------------------------------------\n\nTITLE: Deprecating Unsafe Casts on Leaf Syntax Nodes Swift\nDESCRIPTION: Deprecates casting methods (`is`, `as`, `cast`) in Swift Syntax 510 on syntax nodes that are leaf types (i.e., do not serve as base nodes for other syntax types). This change prevents unsafe type-casting attempts that would invariably fail, issuing deprecation warnings instead.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Release Notes/510.md#_snippet_5\n\nLANGUAGE: Swift\nCODE:\n```\n// Deprecated: is, as, cast methods on leaf syntax nodes\n```\n\n----------------------------------------\n\nTITLE: Initializing SourceFileSyntax from String Literal using SwiftSyntaxBuilder (Swift)\nDESCRIPTION: Demonstrates how importing `SwiftSyntaxBuilder` alongside `SwiftSyntax` and `SwiftParser` allows a string literal containing Swift code to be implicitly parsed into a `SourceFileSyntax` node. This is useful when the structure of the source code is known at build time.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntax/Documentation.docc/Working with SwiftSyntax.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport SwiftSyntax\nimport SwiftParser\nimport SwiftSyntaxBuilder\n\n// `file` is a source file syntax node containing the parsed value of the\n// provided text.\nlet file: SourceFileSyntax =\n  \"\"\"\n  print(\"Hello, world!\")\n  \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Infix Operators with Precedence Group in Swift\nDESCRIPTION: Demonstrates how to declare custom infix operators and assign precedence groups in Swift. No external dependencies are necessary, as these are native Swift declarations. The associativity and precedence group can be defined for each operator using 'infix operator' and 'precedencegroup' declarations. Expected input is valid Swift code placed at file scope; the output is that the operator is recognized in subsequent code. Limitations include that these declarations only affect compilation in the current module/file.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftOperators/SwiftOperators.docc/SwiftOperators.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\ninfix operator +: AdditionPrecedence\ninfix operator *: MultiplicationPrecedence\n```\n\n----------------------------------------\n\nTITLE: Applying Operator Folding with SwiftOperators Library in Swift\nDESCRIPTION: Illustrates using the SwiftOperators library to parse an expression and structurally fold SequenceExprSyntax nodes into fully structured syntax representing order of operations. This requires importing SwiftSyntax, SwiftParser, and SwiftOperators. The OperatorTable.standardOperators provides a standard operator table, and folding is done using the foldAll method. Inputs are Swift source expressions as strings; outputs are parsed and folded syntax trees, suitable for structured editing or type-checking. Error handling is via Swift's error throwing mechanism.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftOperators/SwiftOperators.docc/SwiftOperators.md#_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\nimport SwiftSyntax\nimport SwiftParser\nimport SwiftOperators\n\nvar opPrecedence = OperatorTable.standardOperators // Use the Swift standard library operators\nlet parsed = Parser.parse(source: \"x + y * z\")\ndump(parsed) // contains SequenceExprSyntax(x, +, y, *, z)\nlet folded = try opPrecedence.foldAll(parsed)\ndump(folded) // contains InfixOperatorExpr(x, +, InfixOperatorExpr(y, *, z))\n```\n\n----------------------------------------\n\nTITLE: Unqualified Name Lookup in Swift Syntax Trees (Swift)\nDESCRIPTION: This Swift snippet illustrates unqualified name lookup scenarios within a generic struct `Foo` that defines generic parameters, properties, and a method. It shows how identifiers like generic parameters, local variables, and implicit special names like `self` are resolved to their respective declarations, representing typical input for the SwiftLexicalLookup unqualified lookup API. This snippet requires Swift generic and scope rules for analysis.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftLexicalLookup/SwiftLexicalLookup.docc/SwiftLexicalLookup.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nstruct Foo<A, B> {\n  let a = A()\n  let b = B()\n\n  func bar(b: B) { // <-- `B` refers to the generic parameter `B`\n    let a: A = a // <-- `a` refers to the member `a`\n    let b: B = b // <-- `b` refers to the function parameter `b`\n    print(self) // <-- `self` refers to the `struct` declaration\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecating Redundant Base-Type Casts on Base Nodes Swift\nDESCRIPTION: Deprecates `is`, `as`, and `cast` methods on base node protocols in Swift Syntax 510 when performing conversions to the base type itself. A warning now informs developers that the cast will always succeed and suggests using the base node's initializer directly.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Release Notes/510.md#_snippet_7\n\nLANGUAGE: Swift\nCODE:\n```\n// Deprecated: is, as, cast methods on base node protocols for base-type conversions\n```\n\n----------------------------------------\n\nTITLE: Initializing SwiftSyntaxBuilder for Swift Code Generation\nDESCRIPTION: This snippet demonstrates setup and usage of SwiftSyntaxBuilder for the purpose of generating Swift source code using result builders. It covers instantiating the builder, constructing syntax nodes, and outputting the generated code. Dependencies include SwiftSyntax and SwiftSyntaxBuilder libraries.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxBuilder/Documentation.docc/Index.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nlet builder = SwiftSyntaxBuilder()\nlet syntaxNode = builder.build()\nprint(syntaxNode.description)\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of an Enum Subset in Swift\nDESCRIPTION: Demonstrates a repetitive, hand-written Swift enum (`TypeDeclarationKeyword`) that represents a subset of another enum (`Keyword`). It includes a failable initializer to convert from the superset (`Keyword`) and a computed property (`keyword`) to convert back, highlighting the boilerplate code that the `EnumSubset` macro aims to eliminate.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacros/SwiftSyntaxMacros.docc/SwiftSyntaxMacros.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nenum TypeDeclarationKeyword {\n  case `actor`\n  case `class`\n  ...\n\n  init?(_ keyword: Keyword) {\n    switch keyword {\n    case .actor: self = .actor\n    case .class: self = .class\n    ...\n    default: return nil\n    }\n  }\n\n  var keyword: Keyword {\n    switch self {\n    case .actor: return .actor\n    case .class: return .class\n    ...\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Swift Syntax Dependency in SwiftPM\nDESCRIPTION: This Swift code snippet shows how to add the swift-syntax package as a dependency in a Swift Package Manager manifest file (`Package.swift`). It specifies the package's GitHub URL and a version requirement, using `<#latest swift-syntax tag#>` as a placeholder for the desired release version.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/README.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\ndependencies: [\n  .package(url: \"https://github.com/swiftlang/swift-syntax.git\", from: \"<#latest swift-syntax tag#>\",\n],\n```\n\n----------------------------------------\n\nTITLE: Parsing Optional Types Using SwiftSyntax (Swift)\nDESCRIPTION: This Swift extension demonstrates how to parse an optional type using a recursive descent parser. It first parses the underlying type, then checks for a postfix question mark, and constructs a RawOptionalTypeSyntax node encompassing the result. Requires the SwiftSyntax framework and a mutable Parser; expects valid type tokens and the '?' in the input stream, outputting a syntax tree node adhering to the grammar.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/Parsing Basics.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nextension Parser {\n  mutating func parseOptionalType() -> OptionalTypeSyntax {\n    // First, recursively parse a type\n    let base = self.parseType()\n    // Then, parse a postfix question mark token\n    let mark = self.eat(.postfixQuestionMark)\n    // Finally, yield the optional type syntax node.\n    return RawOptionalTypeSyntax(\n      wrappedType: base, \n      questionMark: mark, \n      arena: self.arena\n    )\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Precedence Groups for Custom Operators in Swift\nDESCRIPTION: Shows how to define precedence groups used by custom operators, specifying associativity and relative precedence using 'precedencegroup' declarations. Place these at the top level in a Swift source file. No external dependencies are required. Required parameters include the group name and, optionally, properties like associativity and relative precedence (e.g., 'higherThan'). These influence how operator expressions are parsed and evaluated by the compiler. Applies only within the current compilation context.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftOperators/SwiftOperators.docc/SwiftOperators.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nprecedencegroup AdditionPrecedence {\n  associativity: left\n}\nprecedencegroup MultiplicationPrecedence {\n  associativity: left\n  higherThan: AdditionPrecedence\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Sequential Scope Lookup Behavior in Swift\nDESCRIPTION: This Swift code example demonstrates unqualified name lookup within nested scopes, specifically illustrating how 'guard' and code block scopes interact sequentially. It shows how multiple declarations of the same name introduced in different nested scopes are collected in a bottom-up manner from the closest to the furthest scope. The snippet examines lookup results for identifiers 'a' and 'b' to highlight interleaving results from sequential scopes and their parents.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftLexicalLookup/SwiftLexicalLookup.docc/LookupRules.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nfunc foo(x: Int?) {\n  // Guard scope\n  guard let a = x else { return }\n\n  // In code block scope\n  let a: Int? = a\n\n  // Guard scope\n  guard let b = x, let a else { return }\n\n  // In code block scope\n  let a = b\n\n  a // <-- lookup here\n  b // <-- lookup here\n}\n```\n\n----------------------------------------\n\nTITLE: Swift Conditional Compilation Example with #if Directives\nDESCRIPTION: Demonstrates the usage of Swift's conditional compilation directives (#if, #elseif, #else, #error) to create platform-specific code paths based on build configuration conditions like DEBUG and operating system.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftIfConfig/SwiftIfConfig.docc/SwiftIfConfig.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nfunc f() {\n#if DEBUG\n  log(\"called f\")\n#endif\n\n#if os(Linux)\n  // use Linux API\n#elseif os(iOS) || os(macOS)\n  // use iOS/macOS API\n#else\n  #error(\"unsupported platform\")\n#endif\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Generic Parameter Scope Lookup in Swift\nDESCRIPTION: This Swift code snippet exemplifies unqualified lookup behavior involving generic parameter scopes in nested declarations. It shows how generic parameters introduced in both class and function declarations participate in the lookup results. Lookup performed without identifier matching yields two sets of names: those from the function's generic parameter scope and those from the class's generic parameter scope. The snippet highlights how inner generic parameter scopes take precedence during lookup.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftLexicalLookup/SwiftLexicalLookup.docc/LookupRules.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nclass Foo<A, B: A> { // <-- lookup here\n  func bar<A, C>() {\n    X // <-- lookup here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error Handling Locations in Swift Syntax (Swift)\nDESCRIPTION: This Swift code snippet demonstrates error handling contexts within a sample function `foo() throws`. It shows the use of `try!`, `do ... catch` blocks, and rethrowing errors to illustrate how SwiftLexicalLookup could be used to query which error handling mechanism is responsible for each throwing expression. It requires Swift standard error handling constructs and is intended to be analyzed through the lexical lookup APIs.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftLexicalLookup/SwiftLexicalLookup.docc/SwiftLexicalLookup.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nfunc foo() throws {\n  try! f() // <-- Error handled by `try!`\n\n  do {\n    try f() // <-- Error handled by `do ... catch`\n  } catch {\n    throw f() // <-- Error handled by the throwing function\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Declaration Parsing with Optional Semicolon (Swift)\nDESCRIPTION: This code snippet in Swift extends the Parser to parse a declaration item, optionally consuming a trailing semicolon if present. It demonstrates how to model conditional productions, returning a RawMemberDeclListItemSyntax node that may or may not include a semicolon token. Depends on SwiftSyntax and expects declaration tokens and an optional ';' in the source; outputs a syntax node structured according to SwiftGrammar.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/Parsing Basics.md#_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\nextension Parser {\n  mutating func parseDeclarationItem() -> RawMemberDeclListItemSyntax {\n    // First, recursively parse a declaration\n    let parsedDecl = self.parseDeclaration()\n    // Next, consume the semicolon - if there is one.\n    let semicolon = self.consume(if: .semicolon)\n    return RawMemberDeclListItemSyntax(\n      decl: parsedDecl, \n      semicolon: semicolon,\n      arena: parser.arena)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Swift Syntax Submodules in CMake Build Configuration\nDESCRIPTION: Includes multiple subdirectories related to distinct Swift syntax components for compilation within the CMake build system. Each add_subdirectory call integrates a specific module, such as SwiftParser, SwiftDiagnostics, or SwiftSyntaxMacros, into the overall build. The configuration assumes the existence of these directories containing their own CMakeLists and codebases.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(_SwiftLibraryPluginProviderCShims)\nadd_subdirectory(_SwiftSyntaxCShims)\nadd_subdirectory(SwiftBasicFormat)\nadd_subdirectory(SwiftSyntax)\nadd_subdirectory(SwiftDiagnostics)\nadd_subdirectory(SwiftLexicalLookup)\nadd_subdirectory(SwiftLibraryPluginProvider)\nadd_subdirectory(SwiftParser)\nadd_subdirectory(SwiftParserDiagnostics)\nadd_subdirectory(SwiftRefactor)\nadd_subdirectory(SwiftOperators)\nadd_subdirectory(SwiftIfConfig)\nadd_subdirectory(SwiftSyntaxBuilder)\nadd_subdirectory(SwiftSyntaxMacros)\nadd_subdirectory(SwiftSyntaxMacroExpansion)\nadd_subdirectory(SwiftCompilerPluginMessageHandling)\nadd_subdirectory(SwiftIDEUtils)\nadd_subdirectory(SwiftCompilerPlugin)\nadd_subdirectory(VersionMarkerModules)\n```\n\n----------------------------------------\n\nTITLE: Parsing Inheritance Clause as a Sequence (Swift)\nDESCRIPTION: This function in Swift parses a colon followed by a comma-separated sequence of inherited types, constructing a RawTypeInheritanceClauseSyntax node. It uses a loop with conditional token consumption to process multiple inherited type elements, demonstrating sequence parsing within recursive descent. Prerequisites include SwiftSyntax and a properly configured Parser; the input should have a colon and subsequent types, and outputs a syntax tree node representing the inheritance clause.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/Parsing Basics.md#_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\nextension Parser {\n  mutating func parseInheritance() -> RawTypeInheritanceClauseSyntax {\n    // Eat the colon character.\n    let colon = self.eat(.colon)\n    // Start parsing a list of inherited types.\n    var elements = [RawInheritedTypeSyntax]()\n    do {\n      var keepGoing: RawTokenSyntax? = nil\n      repeat {\n        let type = self.parseType()\n        keepGoing = self.consume(if: .comma)\n        elements.append(RawInheritedTypeSyntax(\n          typeName: type, trailingComma: keepGoing, arena: self.arena))\n      } while keepGoing != nil\n    }\n    // Construct the syntax for the list of inherited types.\n    let inheritedTypes = RawInheritedTypeListSyntax(\n      elements: elements, arena: self.arena)\n    return RawTypeInheritanceClauseSyntax(\n      colon: colon,\n      inheritedTypeCollection: inheritedTypes,\n      arena: self.arena)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying swift-syntax Version Constraints in Package Dependency (Swift)\nDESCRIPTION: This snippet shows how to declare a Swift package dependency on a version range of swift-syntax using the .package syntax. The version range specifies supported versions, helping maintain compatibility across swift-syntax 509 and 510. This requires that the swift package manager is being used and swift-syntax is hosted at the given repository URL. The expected input is a valid package dependency declaration and does not output a value; it constrains swift-syntax versions during build resolution.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntax/Documentation.docc/Macro Versioning.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n.package(url: \"https://github.com/swiftlang/swift-syntax.git\", \"509.0.0\"..<\"511.0.0\"),\n```\n\n----------------------------------------\n\nTITLE: Using SyntaxEnum for exhaustive switching over syntax types in Swift\nDESCRIPTION: Demonstrates how to use the SyntaxEnum type to perform exhaustive switch statements over all syntax node types. This allows for more type-safe handling of different syntax nodes.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Changelog.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nlet node: Syntax\n\nswitch node.as(SyntaxEnum.self) {\n  case .identifierExpr(let identifierExprSyntax):\n  /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Adding 'remark' Case to Diagnostic Severity Swift\nDESCRIPTION: Introduces a new `remark` case to both `DiagnosticSeverity` and `PluginMessage.Diagnostic.Severity` enums in Swift Syntax 510. This aligns with the Swift compiler, allowing tools to describe aspects of translation that don't affect correctness but might be useful information for the user.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Release Notes/510.md#_snippet_4\n\nLANGUAGE: Swift\nCODE:\n```\nDiagnosticSeverity // and PluginMessage.Diagnostic.Severity adds 'remark' case\n```\n\n----------------------------------------\n\nTITLE: Using Opaque Types with Protocol Constraints in Swift\nDESCRIPTION: Demonstrates how to use the 'some' keyword with protocol constraints to avoid heap allocations for a single node. This approach preserves the concrete type while allowing protocol conformance checks.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/When to use protocols in SwiftSyntax.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nsome ExprSyntaxProtocol\n```\n\n----------------------------------------\n\nTITLE: Defining a Source File Syntax Node in Swift\nDESCRIPTION: This Swift code snippet defines the syntax node representation for a Swift source file within the Swift Syntax API. It specifies the node's kind, base kind, diagnostic name, parsing function, associated traits, and child nodes. The children include a collection of statements and an end-of-file token, demonstrating how complex syntax nodes are composed from simpler components. This definition is part of a system that allows strongly typed casting and processing of Swift syntax structures.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/Changing Swift Syntax.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nNode(\n  kind: .sourceFile,\n  base: .syntax,\n  nameForDiagnostics: \"source file\",\n  parserFunction: \"parseSourceFile\",\n  traits: [\"WithStatements\"],\n  children: [\n    Child(\n      name: \"Statements\",\n      kind: .collection(kind: .codeBlockItemList, collectionElementName: \"Statement\")\n    ),\n    Child(\n      name: \"EndOfFileToken\",\n      deprecatedName: \"EOFToken\",\n      kind: .token(choices: [.token(tokenKind: \"EndOfFileToken\")])\n    ),\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Migrating from struct-based to class-based SyntaxVisitor in Swift\nDESCRIPTION: Shows how to convert a struct that conformed to the SyntaxVisitor protocol to a class that extends the SyntaxVisitor class. This involves removing 'mutating' keywords and adding 'override' to method implementations.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Changelog.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nstruct Visitor: SyntaxVisitor {\n  mutating func visit(_ node: EnumDeclSyntax) -> SyntaxVisitorContinueKind {\n    /* ... */\n  }\n}\n\n// Now\nclass Visitor: SyntaxVisitor {\n  override func visit(_ node: EnumDeclSyntax) -> SyntaxVisitorContinueKind {\n    /* ... */\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting a Swift file using swift-parser-cli\nDESCRIPTION: This snippet demonstrates how to use `swift-parser-cli` to format a Swift source file using BasicFormat.  Optionally, a specific node type can be provided to focus on formatting issues within that node. Requires the `swift-parser-cli` executable built from the SwiftSyntax project.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftBasicFormat/SwiftBasicFormat.docc/FilingBugReports.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nswift-parser-cli basic-format /path/to/file/that/formats/incorrectly.swift\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version for SwiftSyntax\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.19.6.  This ensures compatibility with the features used in the project's build configuration. It's a crucial step to ensure that the project can be built successfully on different systems with varying CMake versions.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.19.6)\n```\n\n----------------------------------------\n\nTITLE: Using asProtocol() method for type retrieval in Swift Syntax\nDESCRIPTION: Shows how to retrieve the non-type erased version of a syntax node using the asProtocol() method. This is necessary when working with type erasers in the new struct-based model.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Changelog.md#_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nlet identifierExprSyntax: IdentifierExprSyntax = /* ... */\nlet node = Syntax(identifierExprSyntax)\nnode.asProtocol(SyntaxProtocol.self) // returns an IdentifierExprSyntax with static type SyntaxProtocol\nnode.asProtocol(ExprSyntaxProtocol.self) // returns an IdentifierExprSyntax with static type ExprSyntaxProtocol?\n```\n\n----------------------------------------\n\nTITLE: Value Type Casting in SwiftSyntax\nDESCRIPTION: Shows how to upcast a specific expression type to the generic ExprSyntax value type and how to downcast back to a specific type. This approach avoids existential containers for collections of mixed expression types.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/When to use protocols in SwiftSyntax.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nExprSyntax(integerLiteral)\nexpr.as(IntegerLiteralExprSyntax.self)\n```\n\n----------------------------------------\n\nTITLE: Indexing Elements in SyntaxCollection Swift\nDESCRIPTION: Adds the `SyntaxCollection.index(at:)` method in Swift Syntax 510 to retrieve the index corresponding to the n-th element within a `SyntaxCollection`. This operation has O(n) time complexity, and `SyntaxCollection` does not support direct integer subscripting.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Release Notes/510.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nSyntaxCollection.index(at:)\n```\n\n----------------------------------------\n\nTITLE: Example Usage of `EnumSubset` Macro for AST Inspection\nDESCRIPTION: Provides a minimal Swift code example showing the `EnumSubset` macro applied with a generic parameter (`@EnumSubset<Keyword>`). This snippet is intended to be used with tools like the Swift AST Explorer (<https://swift-ast-explorer.com>) to visualize the abstract syntax tree representation of the macro usage, helping developers understand how to navigate the tree structure (e.g., to extract the generic parameter `Keyword`) within a macro implementation.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacros/SwiftSyntaxMacros.docc/SwiftSyntaxMacros.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n@EnumSubset<Keyword>\n```\n\n----------------------------------------\n\nTITLE: Correct SwiftSyntax Token Initialization Example (Swift)\nDESCRIPTION: This Swift code snippet demonstrates the correct way to initialize a `TokenSyntax` representing the 'async' keyword using the SwiftSyntax API. It uses the static member `.keyword(.async)` to explicitly create a keyword token, satisfying the type requirements validated by `SWIFTSYNTAX_ENABLE_RAWSYNTAX_VALIDATION`.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntax/Documentation.docc/RawSyntaxValidation.md#_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nlet asyncSpecifier: TokenSyntax = .keyword(.async)\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation for Multiple swift-syntax Versions (Swift)\nDESCRIPTION: This snippet demonstrates using Swift conditional compilation directives to branch code according to the available swift-syntax version. It checks for the presence of marker modules like SwiftSyntax510 and SwiftSyntax509, ensuring version-dependent code is only activated for compatible versions. Dependencies include swift-syntax 509 or above, which provide these empty modules. Inputs are available modules during compilation, and output is the selection of appropriate code branches based on swift-syntax version. This technique is essential for safe handling of API changes and prevents compilation errors when upgrading swift-syntax.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntax/Documentation.docc/Macro Versioning.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n#if canImport(SwiftSyntax510)\n// code specific to swift-syntax version >= 510\n#elseif canImport(SwiftSyntax509)\n// code to support swift-syntax version 509\n#else\n// code for swift-syntax < 509. Not needed for macros since macros require swift-syntax >= 509.\n#endif\n```\n\n----------------------------------------\n\nTITLE: Explicit upcasting with designated initializers in Swift Syntax\nDESCRIPTION: Shows how to perform explicit upcasting using designated initializers in the new struct-based Swift Syntax model. This is required when you need to return a more general type than the specific type you have.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Changelog.md#_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nfunc foo() -> ExprSyntax {\n  /* ... */\n  return identiferExprSyntax\n}\n\n// Now\nfunc foo() -> ExprSyntax {\n  /* ... */\n  return ExprSyntax(identiferExprSyntax)\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect SwiftSyntax Token Initialization Example (Swift)\nDESCRIPTION: This Swift code snippet shows an incorrect way to initialize a `TokenSyntax` for the 'async' keyword. It incorrectly uses a string literal, which creates an identifier token instead of the expected keyword token. This type of error can be caught when `SWIFTSYNTAX_ENABLE_RAWSYNTAX_VALIDATION` is enabled.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntax/Documentation.docc/RawSyntaxValidation.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nlet asyncSpecifier: TokenSyntax = \"async\"\n```\n\n----------------------------------------\n\nTITLE: Command to Print Syntax Tree\nDESCRIPTION: This command-line instruction shows how to use `swift-parser-cli` to print the syntax tree of a Swift file. It's used to analyze how the parser interprets potentially unhelpful diagnostics, helping determine if the issue is with the parser's recovery mechanism or contextual error reporting.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/Fixing Bugs.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nswift-parser-cli print-tree /path/to/file/with/unhelpful/diagnostic.swift\n```\n\n----------------------------------------\n\nTITLE: Enabling SwiftSyntax Raw Syntax Validation via Environment Variable (Shell)\nDESCRIPTION: This shell command demonstrates how to enable the SwiftSyntax raw syntax validation feature for testing. Setting the `SWIFTSYNTAX_ENABLE_RAWSYNTAX_VALIDATION` environment variable to `true` before running `swift test` activates additional runtime checks within the SwiftSyntax library.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntax/Documentation.docc/RawSyntaxValidation.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nSWIFTSYNTAX_ENABLE_RAWSYNTAX_VALIDATION=true swift test\n```\n\n----------------------------------------\n\nTITLE: Changing type checking syntax from 'is' operator to 'is()' method in Swift Syntax\nDESCRIPTION: Demonstrates how to check a node's type using the new is() method instead of the Swift 'is' operator, which is no longer supported for Swift Syntax nodes after the change to struct-based modeling.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Changelog.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n// Before \nexprSyntax is IdentifierExprSyntax\n\n// Now\nexprSyntax.is(IdentifierExprSyntax.self)\n```\n\n----------------------------------------\n\nTITLE: Generating source code for swift-syntax\nDESCRIPTION: Command to run the source code generation utility that updates the generated files in the swift-syntax project.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./swift-syntax-dev-utils generate-source-code\n```\n\n----------------------------------------\n\nTITLE: Migrating from 'as?' operator to 'as()' method for downcasting in Swift Syntax\nDESCRIPTION: Demonstrates the change in downcasting syntax nodes from using Swift's as? operator to using the new as() method on type erasers, which is required after the switch to struct-based modeling.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Changelog.md#_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nexprSyntax as? IdentifierExprSyntax\n\n// Now\nexprSyntax.as(IdentifierExprSyntax.self)\n```\n\n----------------------------------------\n\nTITLE: Setting Output Directories in SwiftSyntax\nDESCRIPTION: This snippet sets the archive, library, and runtime output directories if they are not already defined. These directives control where compiled artifacts are placed during the build process.  It uses the `SWIFT_HOST_LIBRARIES_SUBDIRECTORY` variable to define where the libraries will reside. This is critical for organizing the generated files.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_ARCHIVE_OUTPUT_DIRECTORY)\n  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/lib/${SWIFT_HOST_LIBRARIES_SUBDIRECTORY}\")\nendif()\nif(NOT CMAKE_LIBRARY_OUTPUT_DIRECTORY)\n  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/lib/${SWIFT_HOST_LIBRARIES_SUBDIRECTORY}\")\nendif()\nif(NOT CMAKE_RUNTIME_OUTPUT_DIRECTORY)\n  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Running swift-format to ensure consistent style\nDESCRIPTION: Commands to format the swift-syntax codebase using swift-format with the appropriate flags for in-place, parallel, and recursive formatting.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nswift format --in-place --parallel --recursive .\n# Or alternatively\nswift format -ipr .\n```\n\n----------------------------------------\n\nTITLE: Appending Optional Syntax Nodes in String Interpolation Swift\nDESCRIPTION: Introduces `SyntaxStringInterpolation.appendInterpolation(_: (some SyntaxProtocol)?)`, a new API in Swift Syntax 510 allowing optional syntax nodes within syntax node string interpolation. If the provided optional node is `nil`, nothing is appended to the interpolation result.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Release Notes/510.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nSyntaxStringInterpolation.appendInterpolation(_: (some SyntaxProtocol)?)\n```\n\n----------------------------------------\n\nTITLE: Building swift-parser-cli with Swift Package Manager\nDESCRIPTION: This snippet shows how to build the `swift-parser-cli` utility using Swift Package Manager.  It requires having swift installed and the `swift-syntax` project checked out. The built executable can then be used to format Swift source files.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftBasicFormat/SwiftBasicFormat.docc/FilingBugReports.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nswift build --package-path SwiftParserCLI\n```\n\n----------------------------------------\n\nTITLE: Defining Swift Grammar Productions (Grammar Definition)\nDESCRIPTION: This snippet demonstrates the formal grammar syntax of Swift, representing productions for optional types, metatype types, class bodies, and class member sequences. These grammar rules serve as blueprints for implementing parser logic and are prerequisites for writing parsing functions in Swift. Inputs are sequences of tokens; outputs are intermediate grammar symbols guiding the structure of code parsers. Intended primarily for documentation and as a specification, not direct execution.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/Parsing Basics.md#_snippet_0\n\nLANGUAGE: Grammar Definition\nCODE:\n```\noptional-type → type '?'\n```\n\nLANGUAGE: Grammar Definition\nCODE:\n```\nmetatype-type → type '.' 'Type' | type '.' 'Protocol'\n```\n\nLANGUAGE: Grammar Definition\nCODE:\n```\nclass-body → '{' class-members? '}'\n```\n\nLANGUAGE: Grammar Definition\nCODE:\n```\nclass-members → class-member class-members?\n```\n\n----------------------------------------\n\nTITLE: Converting from protocol extensions to protocol conformance extensions in Swift Syntax\nDESCRIPTION: Shows the migration path from extending syntax type protocols to extending the new protocol conformance types. Extensions now target XxxSyntaxProtocol instead of the previous XxxSyntax protocols.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Changelog.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nextension ExprSyntax {\n  func evaluateAsIntegerExpr() -> Int { /* ... */ }\n}\n\n// Now\nextension ExprSyntaxProtocol {\n  func evaluateAsIntegerExpr() -> Int { /* ... */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Source Code with swift-syntax-dev-utils (Bash)\nDESCRIPTION: This bash command executes the `generate-source-code` utility located in the `swift-syntax-dev-utils` directory within the `swift-syntax` project. It is used to regenerate source code files after modifications to the code generation logic.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CodeGeneration/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npath/to/swift-syntax/swift-syntax-dev-utils generate-source-code\n```\n\n----------------------------------------\n\nTITLE: Deprecating typeAnnotation on WildcardPatternSyntax Swift\nDESCRIPTION: Deprecates the `typeAnnotation` property on `WildcardPatternSyntax` in Swift Syntax 510, identifying it as an erroneous addition. Developers should instead use `typeAnnotation` properties available on relevant outer constructs, such as `PatternBindingListSyntax.typeAnnotation`.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Release Notes/510.md#_snippet_8\n\nLANGUAGE: Swift\nCODE:\n```\nWildcardPatternSyntax.typeAnnotation\n```\n\n----------------------------------------\n\nTITLE: Running pre-PR checks\nDESCRIPTION: Command to execute the automated pre-PR checks script that validates changes before submission.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./swift-syntax-dev-utils local-pr-precheck\n```\n\n----------------------------------------\n\nTITLE: Assert Parse Round-Trip Failure Test Case - Swift\nDESCRIPTION: This code snippet demonstrates how to add a new test case in `SwiftParserTest` to assert that a given code snippet does not round-trip correctly.  It involves using the `assertParse` function with the problematic code snippet as input. The goal is to identify which part of the source file causes the round-trip failure.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/Fixing Bugs.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nassertParse(\n  \"\"\"\n  <#your code that does not round trip#>\n  \"\"\"\n)\n```\n\n----------------------------------------\n\nTITLE: Deprecating Redundant Same-Type Casts on SyntaxProtocol Swift\nDESCRIPTION: Deprecates `is`, `as`, and `cast` method overloads on `SyntaxProtocol` in Swift Syntax 510 when the source and target types of the cast are identical. These deprecated methods now emit a warning indicating that such casts will always succeed and are redundant.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Release Notes/510.md#_snippet_6\n\nLANGUAGE: Swift\nCODE:\n```\n// Deprecated: is, as, cast overloads on SyntaxProtocol for same-type conversions\n```\n\n----------------------------------------\n\nTITLE: Renaming NoteMessage.fixItID to noteID Swift\nDESCRIPTION: Renames `NoteMessage.fixItID` to `noteID` in Swift Syntax 510 due to an initial naming error. Accessing the old `fixItID` property is now deprecated and forwards to `noteID`. Types conforming to the `NoteMessage` protocol must be updated to provide `noteID` instead of `fixItID`.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Release Notes/510.md#_snippet_9\n\nLANGUAGE: Swift\nCODE:\n```\nNoteMessage.fixItID // Renamed to noteID\n```\n\n----------------------------------------\n\nTITLE: Git pre-commit hook for format validation\nDESCRIPTION: A bash script to be used as a git pre-commit hook that ensures all code is properly formatted before committing. This script validates the formatting without modifying files.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n#!/usr/bin/env bash\nset -e\nSOURCE_DIR=$(realpath \"$(dirname $0)/../..\")\nswift format lint --strict --parallel --recursive $SOURCE_DIR\n```\n\n----------------------------------------\n\nTITLE: Replacing DiagnosticSpec.highlight with highlights Swift\nDESCRIPTION: Replaces the single string `highlight` property/parameter in `DiagnosticSpec` with an array `highlights` in Swift Syntax 510. This API-incompatible change allows accurate representation when a diagnostic highlights multiple syntax nodes. Usage of `DiagnosticSpec.init(...highlight:...)` is deprecated and forwards to `DiagnosticSpec.init(...highlights:...)`. Migration involves converting single highlight strings to single-element arrays or splitting multi-node highlight strings into multiple array elements.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Release Notes/510.md#_snippet_10\n\nLANGUAGE: Swift\nCODE:\n```\nDiagnosticSpec.highlight // Replaced by highlights: [String]\n```\n\n----------------------------------------\n\nTITLE: Enabling RPATH in SwiftSyntax\nDESCRIPTION: This snippet enables RPATH (Run-Time Path) for macOS.  RPATH allows the executable to find shared libraries at runtime, which is useful for distributing libraries within the application bundle. This helps to ensure the application can find its dependencies after installation.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_MACOSX_RPATH YES)\n```\n\n----------------------------------------\n\nTITLE: Example Error Output from Raw Syntax Validation\nDESCRIPTION: This text shows a sample fatal error message generated when `SWIFTSYNTAX_ENABLE_RAWSYNTAX_VALIDATION` is active and detects incorrect syntax construction. It indicates that an identifier token ('async') was found where a keyword token ('async') was expected within a `typeEffectSpecifiers` node, highlighting the specific validation failure.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntax/Documentation.docc/RawSyntaxValidation.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nFatal error: Error validating child at index 1 of typeEffectSpecifiers:\nExpected token with one of [keyword('async')] but received identifier with text 'async'\n```\n\n----------------------------------------\n\nTITLE: Declaring Swift Syntax Dependency with Bazel Bzlmod\nDESCRIPTION: This Python (Starlark) snippet demonstrates how to declare a dependency on the swift-syntax module using Bazel's modern Bzlmod system within the `MODULE.bazel` file. It uses the `bazel_dep` function to specify the module name and version, supported from release 509.0.0 onwards.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/README.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nbazel_dep(name = \"swift-syntax\", version = \"600.0.1\")\n```\n\n----------------------------------------\n\nTITLE: Adding SwiftSyntax Macro Expansion Source Files in Swift\nDESCRIPTION: This snippet adds multiple source files to the SwiftSyntaxMacroExpansion module, including core macro expansion logic and utility functions. The list includes files related to macro context, argument handling, diagnostics, and pattern replacements necessary for macro expansion functionality.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacroExpansion/CMakeLists.txt#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nadd_swift_syntax_library(SwiftSyntaxMacroExpansion\n  BasicMacroExpansionContext.swift\n  FunctionParameterUtils.swift\n  IndentationUtils.swift\n  MacroArgument.swift\n  MacroExpansion.swift\n  MacroExpansionDiagnosticMessages.swift\n  MacroReplacement.swift\n  MacroSpec.swift\n  MacroSystem.swift\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring Swift Syntax Dependency with Bazel WORKSPACE (http_archive)\nDESCRIPTION: This Python (Starlark) snippet illustrates how to add swift-syntax as a dependency using the legacy Bazel WORKSPACE file and the `http_archive` rule. It downloads a specific source archive by URL and SHA256 hash, stripping a prefix to correctly structure the repository.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/README.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nhttp_archive(\n    name = \"SwiftSyntax\",\n    sha256 = \"f070fd44db9b33f430fd5b5d2700f1e2001c0028711859600e80cc975074fab0\",\n    strip_prefix = \"swift-syntax-509.1.0\",\n    url = \"https://github.com/apple/swift-syntax/archive/refs/tags/509.1.0.tar.gz\",\n)\n```\n\n----------------------------------------\n\nTITLE: Linking SwiftSyntax Libraries as Dependencies for Macro Expansion\nDESCRIPTION: This snippet links several SwiftSyntax libraries to the SwiftSyntaxMacroExpansion target, making them available as dependencies. These libraries include formatting, diagnostics, operators, syntax parsing, syntax building, and macros, which are essential for the macro expansion's functionality and diagnostics support.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacroExpansion/CMakeLists.txt#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\ntarget_link_swift_syntax_libraries(SwiftSyntaxMacroExpansion PUBLIC\n  SwiftBasicFormat\n  SwiftDiagnostics\n  SwiftOperators\n  SwiftSyntax\n  SwiftSyntaxBuilder\n  SwiftSyntaxMacros\n)\n```\n\n----------------------------------------\n\nTITLE: Linking Swift Syntax and Diagnostics Libraries - Swift\nDESCRIPTION: This snippet links external Swift libraries necessary for syntax processing, syntax building, and diagnostics within the project. It declares that the target depends on 'SwiftSyntax', 'SwiftSyntaxBuilder', 'SwiftDiagnostics', and 'SwiftOperators'. These dependencies provide core syntax parsing, syntax node construction, diagnostics reporting, and operator support for the project.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftIfConfig/CMakeLists.txt#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\ntarget_link_swift_syntax_libraries(SwiftIfConfig PUBLIC\n  SwiftSyntax\n  SwiftSyntaxBuilder\n  SwiftDiagnostics\n  SwiftOperators)\n```\n\n----------------------------------------\n\nTITLE: Adding Swift Syntax Source Files for Conditional Compilation - Swift\nDESCRIPTION: This snippet specifies a collection of Swift source files related to 'Active' syntax components and 'IfConfig' handling, included in the Swift syntax library. These files collectively implement language feature detection, syntax traversal, and diagnostics for conditional compilation constructs. Dependencies include core SwiftSyntax and syntax utilities; key functionality includes syntax evaluation, rewriting, and diagnostic reporting.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftIfConfig/CMakeLists.txt#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nadd_swift_syntax_library(SwiftIfConfig\n  ActiveClauseEvaluator.swift\n  ActiveSyntaxVisitor.swift\n  ActiveSyntaxRewriter.swift\n  BuildConfiguration.swift\n  ConfiguredRegions.swift\n  IfConfigRegionState.swift\n  IfConfigDecl+IfConfig.swift\n  IfConfigDiagnostic.swift\n  IfConfigEvaluation.swift\n  IfConfigFunctions.swift\n  SyntaxLiteralUtils.swift\n  SyntaxProtocol+IfConfig.swift\n  VersionTuple+Parsing.swift\n  VersionTuple.swift\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing EnumCaseParameterSyntax Conveniently Swift\nDESCRIPTION: Provides a new convenience initializer `EnumCaseParameterSyntax.init()` in Swift Syntax 510. This initializer accepts a concrete `firstName` value and automatically includes the required `colon = TokenSyntax.colonToken()`.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Release Notes/510.md#_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\nEnumCaseParameterSyntax.init()\n```\n\n----------------------------------------\n\nTITLE: Initializing ClosureCaptureSyntax Conveniently Swift\nDESCRIPTION: Provides a new convenience initializer `ClosureCaptureSyntax.init()` in Swift Syntax 510. This initializer accepts a concrete `name` argument and automatically includes the required `equal = TokenSyntax.equalToken()`.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Release Notes/510.md#_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\nClosureCaptureSyntax.init()\n```\n\n----------------------------------------\n\nTITLE: SwiftSyntax Source Files Inclusion\nDESCRIPTION: The build script aggregates numerous Swift source files into the SwiftSyntax library, covering core syntax representations, raw syntax handling, generated node types, and syntax visitors. This structure supports various functionalities such as syntax parsing, tree traversal, and compatibility, forming the backbone of the SwiftSyntax framework.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntax/CMakeLists.txt#_snippet_1\n\nLANGUAGE: Build Script\nCODE:\n```\nadd_swift_syntax_library(SwiftSyntax\n  AbsolutePosition.swift\n  AbsoluteSyntaxInfo.swift\n  ArenaAllocatedBuffer.swift\n  Assert.swift\n  BumpPtrAllocator.swift\n  CommonAncestor.swift\n  Convenience.swift\n  CustomTraits.swift\n  EditorPlaceholder.swift\n  Identifier.swift\n  MemoryLayout.swift\n  MissingNodeInitializers.swift\n  SourceEdit.swift\n  SourceLength.swift\n  SourceLocation.swift\n  SourcePresence.swift\n  SwiftSyntaxCompatibility.swift\n  Syntax.swift\n  SyntaxChildren.swift\n  SyntaxCollection.swift\n  SyntaxHashable.swift\n  SyntaxIdentifier.swift\n  SyntaxNodeStructure.swift\n  SyntaxProtocol.swift\n  SyntaxText.swift\n  SyntaxTreeViewMode.swift\n  TokenDiagnostic.swift\n  TokenSequence.swift\n  TokenSyntax.swift\n  Trivia.swift\n  Utils.swift\n\n  Raw/RawSyntax.swift\n  Raw/RawSyntaxArena.swift\n  Raw/RawSyntaxLayoutView.swift\n  Raw/RawSyntaxNodeProtocol.swift\n  Raw/RawSyntaxTokenView.swift\n\n  generated/raw/RawSyntaxNodesAB.swift\n  generated/raw/RawSyntaxNodesC.swift\n  generated/raw/RawSyntaxNodesD.swift\n  generated/raw/RawSyntaxNodesEF.swift\n  generated/raw/RawSyntaxNodesGHI.swift\n  generated/raw/RawSyntaxNodesJKLMN.swift\n  generated/raw/RawSyntaxNodesOP.swift\n  generated/raw/RawSyntaxNodesQRS.swift\n  generated/raw/RawSyntaxNodesTUVWXYZ.swift\n  generated/raw/RawSyntaxValidation.swift\n\n  generated/ChildNameForKeyPath.swift\n  generated/Keyword.swift\n  generated/RenamedChildrenCompatibility.swift\n  generated/RenamedNodesCompatibility.swift\n  generated/SyntaxAnyVisitor.swift\n  generated/SyntaxBaseNodes.swift\n  generated/SyntaxCollections.swift\n  generated/SyntaxEnum.swift\n  generated/SyntaxKind.swift\n  generated/SyntaxRewriter.swift\n  generated/SyntaxTraits.swift\n  generated/SyntaxVisitor.swift\n  generated/TokenKind.swift\n  generated/Tokens.swift\n  generated/TriviaPieces.swift\n\n  generated/syntaxNodes/SyntaxNodesAB.swift\n  generated/syntaxNodes/SyntaxNodesC.swift\n  generated/syntaxNodes/SyntaxNodesD.swift\n  generated/syntaxNodes/SyntaxNodesEF.swift\n  generated/syntaxNodes/SyntaxNodesGHI.swift\n  generated/syntaxNodes/SyntaxNodesJKLMN.swift\n  generated/syntaxNodes/SyntaxNodesOP.swift\n  generated/syntaxNodes/SyntaxNodesQRS.swift\n  generated/syntaxNodes/SyntaxNodesTUVWXYZ.swift\n)\n```\n\n----------------------------------------\n\nTITLE: Defining the SwiftDiagnostics Library in CMake\nDESCRIPTION: This CMake command defines a library named `SwiftDiagnostics` using the custom `add_swift_syntax_library` function. It lists the specific Swift source files located in various subdirectories (like `DiagnosticDecorators/`) that comprise the library's implementation, covering functionalities such as diagnostic message handling, formatting, and fix-its.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftDiagnostics/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_swift_syntax_library(SwiftDiagnostics\n  DiagnosticDecorators/ANSIDiagnosticDecorator.swift\n  DiagnosticDecorators/BasicDiagnosticDecorator.swift\n  DiagnosticDecorators/DiagnosticDecorator.swift\n\n  Convenience.swift\n  Diagnostic.swift\n  DiagnosticsFormatter.swift\n  FixIt.swift\n  GroupedDiagnostics.swift\n  Message.swift\n  Note.swift\n)\n```\n\n----------------------------------------\n\nTITLE: Linking SwiftDiagnostics to SwiftSyntax in CMake\nDESCRIPTION: This CMake command uses the custom `target_link_swift_syntax_libraries` function to establish a public link dependency between the `SwiftDiagnostics` library and the `SwiftSyntax` library. This means that `SwiftDiagnostics` requires `SwiftSyntax` to build and function, and any target linking against `SwiftDiagnostics` will also implicitly link against `SwiftSyntax`.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftDiagnostics/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_swift_syntax_libraries(SwiftDiagnostics PUBLIC\n  SwiftSyntax)\n```\n\n----------------------------------------\n\nTITLE: Setting Host Library Subdirectory in SwiftSyntax\nDESCRIPTION: This snippet defines the subdirectory where host libraries will be installed, setting `SWIFT_HOST_LIBRARIES_SUBDIRECTORY` to `swift/host`.  This determines the location of the host libraries relative to the build directory. It aids in organizing the build output and is crucial for linking against host libraries.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(SWIFT_HOST_LIBRARIES_SUBDIRECTORY \"swift/host\")\n```\n\n----------------------------------------\n\nTITLE: Linking Dependencies for the SwiftOperators Library with CMake\nDESCRIPTION: This CMake command utilizes the custom function `target_link_swift_syntax_libraries` to link the `SwiftOperators` library against other required libraries: `SwiftSyntax`, `SwiftDiagnostics`, and `SwiftParser`. The `PUBLIC` keyword ensures that targets linking against `SwiftOperators` also inherit these dependencies.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftOperators/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_swift_syntax_libraries(SwiftOperators PUBLIC\n  SwiftSyntax\n  SwiftDiagnostics\n  SwiftParser)\n```\n\n----------------------------------------\n\nTITLE: Building SwiftIDEUtils Library in CMake\nDESCRIPTION: This snippet uses the `add_swift_syntax_library` function to define the SwiftIDEUtils library. It specifies the source files that constitute the library.  The library is built using a CMake configuration and includes multiple .swift source files.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftIDEUtils/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_swift_syntax_library(SwiftIDEUtils\n  DeclNameLocation.swift\n  FixItApplier.swift\n  NameMatcher.swift\n  SwiftIDEUtilsCompatibility.swift\n  Syntax+Classifications.swift\n  SyntaxClassification.swift\n  SyntaxClassifier.swift\n  Utils.swift\n)\n```\n\n----------------------------------------\n\nTITLE: Linking SwiftIDEUtils with Dependencies in CMake\nDESCRIPTION: This snippet utilizes `target_link_swift_syntax_libraries` to link the SwiftIDEUtils library against its dependencies. It specifies that the SwiftIDEUtils library depends on SwiftParser and SwiftSyntax libraries.  This configuration ensures the correct linking of the library at build time.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftIDEUtils/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_swift_syntax_libraries(SwiftIDEUtils PUBLIC\n  SwiftParser\n  SwiftSyntax)\n```\n\n----------------------------------------\n\nTITLE: Adding Swift Files to SwiftRefactor Library in CMake\nDESCRIPTION: CMake configuration that defines the Swift source files to be included in the SwiftRefactor library. It lists various refactoring-related Swift files that implement different code transformation capabilities.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftRefactor/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_swift_syntax_library(SwiftRefactor\n  AddSeparatorsToIntegerLiteral.swift\n  CallToTrailingClosures.swift\n  ConvertComputedPropertyToStored.swift\n  ConvertComputedPropertyToZeroParameterFunction.swift\n  ConvertStoredPropertyToComputed.swift\n  ConvertZeroParameterFunctionToComputedProperty.swift\n  ExpandEditorPlaceholder.swift\n  FormatRawStringLiteral.swift\n  IntegerLiteralUtilities.swift\n  MigrateToNewIfLetSyntax.swift\n  OpaqueParameterToGeneric.swift\n  RefactoringProvider.swift\n  RemoveSeparatorsFromIntegerLiteral.swift\n  SyntaxUtils.swift\n)\n```\n\n----------------------------------------\n\nTITLE: Defining the SwiftParserDiagnostics Library (CMake)\nDESCRIPTION: Uses the custom `add_swift_syntax_library` CMake function to define the `SwiftParserDiagnostics` library target. It lists all the Swift source files (.swift), including several generated files, that are compiled to create this library.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftParserDiagnostics/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_swift_syntax_library(SwiftParserDiagnostics\n  DiagnosticExtensions.swift\n  LexerDiagnosticMessages.swift\n  MissingNodesError.swift\n  MissingTokenError.swift\n  MultiLineStringLiteralDiagnosticsGenerator.swift\n  ParserDiagnosticMessages.swift\n  ParseDiagnosticsGenerator.swift\n  PresenceUtils.swift\n  SyntaxExtensions.swift\n  Utils.swift\n\n  generated/ChildNameForDiagnostics.swift\n  generated/SyntaxKindNameForDiagnostics.swift\n  generated/TokenNameForDiagnostics.swift\n)\n```\n\n----------------------------------------\n\nTITLE: Defining and Linking SwiftLibraryPluginProvider CMake Target\nDESCRIPTION: This CMake snippet defines the `SwiftLibraryPluginProvider` library using the custom `add_swift_syntax_library` function with `LibraryPluginProvider.swift` as its source. It then uses `target_link_swift_syntax_libraries` to link it privately against `_SwiftLibraryPluginProviderCShims` and publicly against `SwiftSyntaxMacros` and `SwiftCompilerPluginMessageHandling`. This establishes the build configuration and dependencies for this specific library within the SwiftSyntax project.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftLibraryPluginProvider/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_swift_syntax_library(SwiftLibraryPluginProvider\n  LibraryPluginProvider.swift\n)\ntarget_link_swift_syntax_libraries(SwiftLibraryPluginProvider PRIVATE\n  _SwiftLibraryPluginProviderCShims\n)\ntarget_link_swift_syntax_libraries(SwiftLibraryPluginProvider PUBLIC\n  SwiftSyntaxMacros\n  SwiftCompilerPluginMessageHandling\n)\n```\n\n----------------------------------------\n\nTITLE: Defining and Linking the SwiftLexicalLookup Library (CMake)\nDESCRIPTION: Defines the `SwiftLexicalLookup` library using the `add_swift_syntax_library` CMake function, listing its Swift source files (.swift) focused on lexical scope and name lookup (e.g., `IdentifiableSyntax.swift`, `LookupName.swift`, various scope implementations). Subsequently, it links this library publicly against the `SwiftSyntax` and `SwiftIfConfig` libraries using the `target_link_swift_syntax_libraries` function, making their interfaces available to consumers of `SwiftLexicalLookup`.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftLexicalLookup/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_swift_syntax_library(SwiftLexicalLookup\n  IdentifiableSyntax.swift\n  LookupName.swift\n  LookupResult.swift\n  SimpleLookupQueries.swift\n  LookupConfig.swift\n  \n  Scopes/CanInterleaveResultsLaterScopeSyntax.swift\n  Scopes/FunctionScopeSyntax.swift\n  Scopes/GenericParameterScopeSyntax.swift\n  Scopes/IntroducingToSequentialParentScopeSyntax.swift\n  Scopes/LookInMembersScopeSyntax.swift\n  Scopes/NominalTypeDeclSyntax.swift\n  Scopes/ScopeImplementations.swift\n  Scopes/ScopeSyntax.swift\n  Scopes/SequentialScopeSyntax.swift\n  Scopes/WithGenericParametersScopeSyntax.swift\n)\n\ntarget_link_swift_syntax_libraries(SwiftLexicalLookup PUBLIC\n  SwiftSyntax\n  SwiftIfConfig)\n```\n\n----------------------------------------\n\nTITLE: Converting from walk method on syntax nodes to SyntaxVisitor walk method in Swift\nDESCRIPTION: Demonstrates the change in how to invoke the walk method which was moved from syntax nodes to the SyntaxVisitor class. This change requires modifying code to call the walk method on the visitor instance instead of passing the visitor to the syntax node.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Changelog.md#_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// Before \ntree.walk(&visitor)\n\n// Now\nvisitor.walk(tree)\n```\n\n----------------------------------------\n\nTITLE: Configuring and Installing C Shims with CMake - CMake\nDESCRIPTION: Defines a static C library target in CMake for SwiftSyntax Library Plugin support, sets include directories, appends exports, and configures installation. The snippet uses CMake variables and commands (add_library, target_include_directories, set_property, install) and requires CMake as a dependency. Parameters include the target name, source file list, and include directory. Inputs are the target configuration, outputs are the built library and its installation. This must run within a CMake project environment.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/_SwiftLibraryPluginProviderCShims/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(target ${SWIFTSYNTAX_TARGET_NAMESPACE}_SwiftLibraryPluginProviderCShims)\nadd_library(${target} STATIC\n  LoadLibrary.c\n)\ntarget_include_directories(${target} PUBLIC \"include\")\nset_property(GLOBAL APPEND PROPERTY SWIFT_EXPORTS ${target})\ninstall(TARGETS ${target} EXPORT SwiftSyntaxTargets)\n```\n\n----------------------------------------\n\nTITLE: Adding SwiftSyntaxBuilder Library - CMake\nDESCRIPTION: This CMake function adds the SwiftSyntaxBuilder library, specifying the source files needed for compilation. It lists both hand-written Swift files and generated files. The listed files are the building blocks of the SwiftSyntaxBuilder.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxBuilder/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_swift_syntax_library(SwiftSyntaxBuilder\n  ConvenienceInitializers.swift\n  DeclSyntaxParseable.swift\n  Indenter.swift\n  ListBuilder.swift\n  ResultBuilderExtensions.swift\n  SwiftSyntaxBuilderCompatibility.swift\n  Syntax+StringInterpolation.swift\n  SyntaxNodeWithBody.swift\n  SyntaxParsable+ExpressibleByStringInterpolation.swift\n  ValidatingSyntaxNodes.swift\n  WithTrailingCommaSyntax+EnsuringTrailingComma.swift\n\n\n  generated/BuildableNodes.swift\n  generated/ResultBuilders.swift\n  generated/RenamedChildrenBuilderCompatibility.swift\n  generated/SyntaxExpressibleByStringInterpolationConformances.swift\n)\n```\n\n----------------------------------------\n\nTITLE: Defining and Configuring SwiftSyntax C Shims Static Library Target\nDESCRIPTION: This CMake snippet defines a static library target named `SWIFTSYNTAX_TARGET_NAMESPACE_SwiftSyntaxCShims`. It compiles `PlatformMutex.c`, makes the 'include' directory publicly accessible, adds the target to the global `SWIFT_EXPORTS` property for Swift integration, and installs the target as part of the `SwiftSyntaxTargets` export set. Requires CMake and a C compiler.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/_SwiftSyntaxCShims/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(target ${SWIFTSYNTAX_TARGET_NAMESPACE}_SwiftSyntaxCShims)\nadd_library(${target} STATIC\n  PlatformMutex.c\n)\ntarget_include_directories(${target} PUBLIC \"include\")\nset_property(GLOBAL APPEND PROPERTY SWIFT_EXPORTS ${target})\ninstall(TARGETS ${target} EXPORT SwiftSyntaxTargets)\n```\n\n----------------------------------------\n\nTITLE: Linking SwiftSyntaxBuilder to Other Libraries - CMake\nDESCRIPTION: This CMake command links the SwiftSyntaxBuilder library to other SwiftSyntax-related libraries. It declares public dependencies on SwiftBasicFormat, SwiftParser, SwiftParserDiagnostics, and SwiftSyntax. These dependencies are essential for SwiftSyntaxBuilder to function correctly.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxBuilder/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_swift_syntax_libraries(SwiftSyntaxBuilder PUBLIC\n  SwiftBasicFormat\n  SwiftParser\n  SwiftParserDiagnostics\n  SwiftSyntax\n  )\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Options for SwiftSyntaxBuilder - CMake\nDESCRIPTION: This CMake code sets compiler options for the SwiftSyntaxBuilder library. Specifically, it defines a compiler flag to disable the OSLog dependency when compiling for the compiler itself. This avoids unnecessary SDK dependencies during compiler builds.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxBuilder/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(${SWIFTSYNTAX_TARGET_NAMESPACE}SwiftSyntaxBuilder PRIVATE\n  $<$<COMPILE_LANGUAGE:Swift>:-D;SWIFTSYNTAX_NO_OSLOG_DEPENDENCY>)\n```\n\n----------------------------------------\n\nTITLE: Configuring SwiftParser Library in CMake\nDESCRIPTION: Defines the SwiftParser library with a comprehensive list of Swift source files. The library includes components for parsing different Swift language constructs, lexer functionality, and generated helper files.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftParser/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_swift_syntax_library(SwiftParser\n  Attributes.swift\n  Availability.swift\n  CharacterInfo.swift\n  CollectionNodes+Parsable.swift\n  CompilerFiles.swift\n  Declarations.swift\n  Directives.swift\n  ExpressionInterpretedAsVersionTuple.swift\n  Expressions.swift\n  IncrementalParseTransition.swift\n  IsValidIdentifier.swift\n  Lookahead.swift\n  LoopProgressCondition.swift\n  Modifiers.swift\n  Names.swift\n  Nominals.swift\n  Parameters.swift\n  Parser.swift\n  ParseSourceFile.swift\n  Patterns.swift\n  TokenSpec.swift\n  TokenSpecSet.swift\n  Recovery.swift\n  Specifiers.swift\n  Statements.swift\n  StringLiteralRepresentedLiteralValue.swift\n  StringLiterals.swift\n  SwiftVersion.swift\n  SyntaxUtils.swift\n  TokenConsumer.swift\n  TokenPrecedence.swift\n  TopLevel.swift\n  TriviaParser.swift\n  Types.swift\n\n  generated/ExperimentalFeatures.swift\n  generated/IsLexerClassified.swift\n  generated/LayoutNodes+Parsable.swift\n  generated/Parser+TokenSpecSet.swift\n  generated/TokenSpecStaticMembers.swift\n\n  Lexer/Cursor.swift\n  Lexer/Lexeme.swift\n  Lexer/LexemeSequence.swift\n  Lexer/Lexer.swift\n  Lexer/RegexLiteralLexer.swift\n  Lexer/UnicodeScalarExtensions.swift\n)\n```\n\n----------------------------------------\n\nTITLE: Defining SwiftSyntax Project with Languages in CMake\nDESCRIPTION: This snippet defines the SwiftSyntax project and specifies the languages used: C and Swift. This is a fundamental step in any CMakeLists.txt file, informing CMake about the project's name and the programming languages involved. It enables the correct handling of the project's source files.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(SwiftSyntax LANGUAGES C Swift)\n```\n\n----------------------------------------\n\nTITLE: Linking Dependencies for SwiftParser\nDESCRIPTION: Links the SwiftParser library with its required dependencies. The SwiftSyntax and SwiftDiagnostics libraries are specified as PUBLIC dependencies, meaning they will be exposed to consumers of the SwiftParser library.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftParser/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_swift_syntax_libraries(SwiftParser PUBLIC\n  SwiftSyntax\n  SwiftDiagnostics)\n```\n\n----------------------------------------\n\nTITLE: Including Build Modules in SwiftSyntax\nDESCRIPTION: This snippet includes custom CMake modules: `AddSwiftHostLibrary` and `SwiftCompilerCapability`. These modules are likely to contain functions and macros that are project-specific, to handle building Swift libraries and querying compiler features, respectively. This promotes code reusability within the project build process.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(AddSwiftHostLibrary)\ninclude(SwiftCompilerCapability)\n```\n\n----------------------------------------\n\nTITLE: Defining the SwiftOperators Library with CMake\nDESCRIPTION: This CMake command uses the custom function `add_swift_syntax_library` to define a library named `SwiftOperators`. It includes a list of Swift source files (e.g., Operator.swift, OperatorError.swift) that comprise the library's implementation within the Swift Syntax project.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftOperators/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_swift_syntax_library(SwiftOperators\n  Operator.swift\n  OperatorError+Diagnostics.swift\n  OperatorError.swift\n  OperatorTable+Defaults.swift\n  OperatorTable+Folding.swift\n  OperatorTable+Semantics.swift\n  OperatorTable.swift\n  PrecedenceGraph.swift\n  PrecedenceGroup.swift\n  SyntaxSynthesis.swift\n)\n```\n\n----------------------------------------\n\nTITLE: Disabling Implicit String Processing Module Import in Swift\nDESCRIPTION: This snippet calls `swift_supports_implicit_module` to check for implicit string processing module import support and, if supported, adds a compile option to disable it. The disabling improves compile times. The `SWIFT_SUPPORTS_DISABLE_IMPLICIT_STRING_PROCESSING_MODULE_IMPORT` variable governs whether the compile option is added.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nswift_supports_implicit_module(\"string-processing\" SWIFT_SUPPORTS_DISABLE_IMPLICIT_STRING_PROCESSING_MODULE_IMPORT)\nif(SWIFT_SUPPORTS_DISABLE_IMPLICIT_STRING_PROCESSING_MODULE_IMPORT)\n  add_compile_options(\"$<$<COMPILE_LANGUAGE:Swift>:SHELL:-Xfrontend -disable-implicit-string-processing-module-import>\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building Swift Syntax Macros Library in Swift\nDESCRIPTION: This snippet uses the `add_swift_syntax_library` function to create a Swift library named `SwiftSyntaxMacros`. It specifies a list of Swift source files, including macro protocol implementations and supporting files, that are part of this library.  It depends on the SwiftSyntaxBuilder library.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacros/CMakeLists.txt#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nadd_swift_syntax_library(SwiftSyntaxMacros\n  MacroProtocols/AccessorMacro.swift\n  MacroProtocols/AttachedMacro.swift\n  MacroProtocols/BodyMacro.swift\n  MacroProtocols/CodeItemMacro.swift\n  MacroProtocols/DeclarationMacro.swift\n  MacroProtocols/ExpressionMacro.swift\n  MacroProtocols/ExtensionMacro.swift\n  MacroProtocols/FreestandingMacro.swift\n  MacroProtocols/Macro.swift\n  MacroProtocols/Macro+Format.swift\n  MacroProtocols/MemberAttributeMacro.swift\n  MacroProtocols/MemberMacro.swift\n  MacroProtocols/PeerMacro.swift\n  MacroProtocols/PreambleMacro.swift\n\n  AbstractSourceLocation.swift\n  MacroExpansionContext.swift\n  MacroExpansionDiagnosticMessages.swift\n  Syntax+LexicalContext.swift\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Package Name and CMO Support in SwiftSyntax\nDESCRIPTION: This snippet sets the package name and potentially checks for compiler package CMO (Code Module Optimization) support. These are crucial for packaging and module handling. If `SWIFTSYNTAX_EMIT_MODULE` is defined, the snippet calls `swift_get_package_cmo_support`, and sets `SWIFTSYNTAX_PACKAGE_NAME` if not defined, setting a package name based on project name and a prefix.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT DEFINED Swift_COMPILER_PACKAGE_CMO_SUPPORT AND SWIFTSYNTAX_EMIT_MODULE)\n  swift_get_package_cmo_support(Swift_COMPILER_PACKAGE_CMO_SUPPORT)\nendif()\nif(NOT DEFINED SWIFTSYNTAX_PACKAGE_NAME)\n  set(SWIFTSYNTAX_PACKAGE_NAME \"${SWIFT_MODULE_ABI_NAME_PREFIX}${PROJECT_NAME}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Linking SwiftSyntaxMacros Library Dependencies\nDESCRIPTION: This snippet links the `SwiftSyntaxMacros` library to the `SwiftSyntaxBuilder` library using the `target_link_swift_syntax_libraries` function.  The linking is specified as `PUBLIC`, making it visible to clients that link with `SwiftSyntaxMacros`. This establishes the necessary dependencies for the SwiftSyntaxMacros library.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntaxMacros/CMakeLists.txt#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\ntarget_link_swift_syntax_libraries(SwiftSyntaxMacros PUBLIC\n  SwiftSyntaxBuilder\n  )\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories in SwiftSyntax\nDESCRIPTION: This snippet adds the `Sources` directory and the `cmake/modules` directory as subdirectories.  This tells CMake to process the CMakeLists.txt files found within those subdirectories. The `Sources` directory is expected to contain the project's source code, while `cmake/modules` contains custom CMake modules to support the build process.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(Sources)\nadd_subdirectory(cmake/modules)\n```\n\n----------------------------------------\n\nTITLE: Linking Dependencies for SwiftParserDiagnostics (CMake)\nDESCRIPTION: Uses the custom `target_link_swift_syntax_libraries` CMake function to specify the libraries that `SwiftParserDiagnostics` depends on. It links `SwiftParserDiagnostics` publicly against `SwiftBasicFormat`, `SwiftDiagnostics`, `SwiftParser`, and `SwiftSyntax`.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftParserDiagnostics/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_swift_syntax_libraries(SwiftParserDiagnostics PUBLIC\n  SwiftBasicFormat\n  SwiftDiagnostics\n  SwiftParser\n  SwiftSyntax)\n```\n\n----------------------------------------\n\nTITLE: Exporting SwiftSyntax Targets in CMake\nDESCRIPTION: This snippet uses CMake's `export` command to make SwiftSyntax targets available to other projects.  The export is conditional; it only executes when either `PROJECT_IS_TOP_LEVEL` or `SWIFT_SYNTAX_INSTALL_TARGETS` is true.  The configuration is stored in a file named `SwiftSyntaxConfig.cmake` within the binary directory, and the namespace used is `SwiftSyntax::`.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/cmake/modules/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(PROJECT_IS_TOP_LEVEL OR SWIFT_SYNTAX_INSTALL_TARGETS)\n  export(EXPORT SwiftSyntaxTargets\n         FILE ${CMAKE_CURRENT_BINARY_DIR}/SwiftSyntaxConfig.cmake\n         NAMESPACE SwiftSyntax::)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Linking SwiftRefactor with Required Libraries in CMake\nDESCRIPTION: CMake configuration that specifies which Swift syntax libraries should be linked with the SwiftRefactor library. It defines dependencies on SwiftBasicFormat, SwiftParser, SwiftSyntax, and SwiftSyntaxBuilder as public dependencies.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftRefactor/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_swift_syntax_libraries(SwiftRefactor PUBLIC\n  SwiftBasicFormat\n  SwiftParser\n  SwiftSyntax\n  SwiftSyntaxBuilder\n)\n```\n\n----------------------------------------\n\nTITLE: Linking SwiftCompilerPlugin to SwiftSyntax Libraries - CMake\nDESCRIPTION: This snippet links the SwiftCompilerPlugin target publicly to two essential Swift syntax-related libraries: 'SwiftSyntaxMacros' and 'SwiftCompilerPluginMessageHandling'. This linkage ensures that the compiler plugin target has access to macros and message handling capabilities required during compilation. The 'target_link_swift_syntax_libraries' function is a custom command in the build system designed to simplify linking dependencies within the SwiftSyntax project.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftCompilerPlugin/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_swift_syntax_libraries(SwiftCompilerPlugin PUBLIC\\n  SwiftSyntaxMacros\\n  SwiftCompilerPluginMessageHandling\\n)\n```\n\n----------------------------------------\n\nTITLE: Adding SwiftCompilerPlugin Library with Source File - CMake\nDESCRIPTION: This snippet uses a custom CMake function to add the SwiftCompilerPlugin library while excluding it from default build targets. It specifies 'CompilerPlugin.swift' as the source file to be compiled. This setup helps manage compilation of the Swift compiler plugin codebase as part of the SwiftSyntax project. The function 'add_swift_syntax_library' appears to be predefined in the build environment.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftCompilerPlugin/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_swift_syntax_library(SwiftCompilerPlugin\\n  EXCLUDE_FROM_ALL\\n  CompilerPlugin.swift\\n)\n```\n\n----------------------------------------\n\nTITLE: Conditional Target Linking for SwiftSyntax Module\nDESCRIPTION: This code configures the linking dependencies of the SwiftSyntax library based on whether the SWIFTSYNTAX_EMIT_MODULE flag is enabled. It ensures that the appropriate internal or external C shim libraries are linked depending on the compilation context, facilitating the correct interoperation between Swift and C components.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/SwiftSyntax/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif (SWIFTSYNTAX_EMIT_MODULE)\n  target_link_swift_syntax_libraries(SwiftSyntax PRIVATE\n    _SwiftSyntaxCShims)\nelse()\n  # We can't use @_implementationOnly if we don't enable library evolution, so we need\n  # to link _SwiftSyntaxCShims publicly.\n  target_link_swift_syntax_libraries(SwiftSyntax PUBLIC\n    _SwiftSyntaxCShims)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding CMake Modules Path in SwiftSyntax\nDESCRIPTION: This snippet adds the directory containing the custom CMake modules to the CMAKE_MODULE_PATH. This allows CMake to find and use the custom modules defined within the project. This is a standard practice for organizing and reusing build logic.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules)\n```\n\n----------------------------------------\n\nTITLE: Setting Swift Language Version for SwiftSyntax\nDESCRIPTION: This snippet sets the Swift language version to 5. It then sets CMAKE_Swift_LANGUAGE_VERSION to the same value. This ensures the project is built using the specified Swift language features and compiler capabilities. This is important for compatibility and utilizing the desired Swift language syntax.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(SWIFT_VERSION 5)\nset(CMAKE_Swift_LANGUAGE_VERSION ${SWIFT_VERSION})\n```\n\n----------------------------------------\n\nTITLE: Enabling WMO in SwiftSyntax (Conditional)\nDESCRIPTION: This snippet defines the `SWIFT_SYNTAX_ENABLE_WMO_PRE_3_26` option, enabling Whole Module Optimization (WMO) if certain conditions are met (not Debug configuration and Darwin platform). WMO optimizes the entire module at once, which can significantly improve performance, but depends on the swift-driver. The `$<IF>` condition provides a mechanism for tailoring build settings.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\noption(SWIFT_SYNTAX_ENABLE_WMO_PRE_3_26\n       \"Enable Whole Module Optimization (WMO) - requires swift-driver\"\n       $<IF:$<AND:$<NOT:$<CONFIG:Debug>>,$<PLATFORM_ID:Darwin>>,YES,NO>)\n```\n\n----------------------------------------\n\nTITLE: Determining Module Triple in SwiftSyntax\nDESCRIPTION: This snippet determines the module triple using the Swift compiler. The module triple is a string that identifies the target platform and architecture. The code first checks if `SWIFT_HOST_MODULE_TRIPLE` is already defined. If not, it calls the Swift compiler with `-print-target-info` to retrieve the target information and parses it to get the module triple. This triple is then displayed as status message.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"${SWIFT_HOST_MODULE_TRIPLE}\" STREQUAL \"\")\n  set(module_triple_command \"${CMAKE_Swift_COMPILER}\" -print-target-info)\n  if(CMAKE_Swift_COMPILER_TARGET)\n    list(APPEND module_triple_command -target ${CMAKE_Swift_COMPILER_TARGET})\n  endif()\n  execute_process(COMMAND ${module_triple_command} OUTPUT_VARIABLE target_info_json)\n  string(JSON SWIFT_HOST_MODULE_TRIPLE GET \"${target_info_json}\" \"target\" \"moduleTriple\")\nendif()\nmessage(STATUS \"Module triple: ${SWIFT_HOST_MODULE_TRIPLE}\")\n```\n\n----------------------------------------\n\nTITLE: Adding Compile Definitions based on Assertions and Build Flags in Swift\nDESCRIPTION: This snippet adds compile-time definitions. It adds `SWIFTSYNTAX_ENABLE_ASSERTIONS` when `SWIFTSYNTAX_ENABLE_ASSERTIONS` is enabled and the compile language is Swift. It also adds `SWIFT_SYNTAX_BUILD_USING_CMAKE` if compile language is Swift. These preprocessor definitions can be used to conditionally include code based on build settings.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nif (SWIFTSYNTAX_ENABLE_ASSERTIONS)\n  add_compile_definitions(\n    $<$<COMPILE_LANGUAGE:Swift>:SWIFTSYNTAX_ENABLE_ASSERTIONS>\n  )\nendif()\n\nadd_compile_definitions(\n  $<$<COMPILE_LANGUAGE:Swift>:SWIFT_SYNTAX_BUILD_USING_CMAKE>\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Version Marker Static Libraries with CMake in SwiftSyntax - CMake\nDESCRIPTION: These CMake commands add static version marker libraries for different SwiftSyntax versions. Each 'add_library' declaration creates a static library with a versioned name and includes a matching empty Swift source file as its content. Dependencies include CMake (typically 3.0 or newer) and the appropriate Swift source files in their respective directories. Inputs are the library name and the Swift file path, and outputs are the generated static libraries for use during the build process.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Sources/VersionMarkerModules/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(${SWIFTSYNTAX_TARGET_NAMESPACE}SwiftSyntax509 STATIC\n  SwiftSyntax509/Empty.swift)\n```\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(${SWIFTSYNTAX_TARGET_NAMESPACE}SwiftSyntax510 STATIC\n  SwiftSyntax510/Empty.swift)\n```\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(${SWIFTSYNTAX_TARGET_NAMESPACE}SwiftSyntax600 STATIC\n  SwiftSyntax600/Empty.swift)\n```\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(${SWIFTSYNTAX_TARGET_NAMESPACE}SwiftSyntax601 STATIC\n  SwiftSyntax601/Empty.swift)\n```\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(${SWIFTSYNTAX_TARGET_NAMESPACE}SwiftSyntax602 STATIC\n  SwiftSyntax602/Empty.swift)\n```\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(${SWIFTSYNTAX_TARGET_NAMESPACE}SwiftSyntax603 STATIC\n  SwiftSyntax603/Empty.swift)\n```\n\n----------------------------------------\n\nTITLE: Assert Parse Invalid Syntax Tree Test Case - Swift\nDESCRIPTION: This code snippet demonstrates how to add a new test case in `SwiftParserTest` to assert that parsing a given code snippet produces an invalid syntax tree.  It involves using the `assertParse` function with the problematic code and a substructure to check the expected syntax tree. This is useful for identifying where the parser produces incorrect syntax nodes.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/Fixing Bugs.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nassertParse(\n  \"\"\"\n  <#your code that produces an invalid syntax tree#>\n  \"\"\",\n  substructure: <#create a syntax node that you expect the tree to have#>\n)\n```\n\n----------------------------------------\n\nTITLE: Assert Parse Unhelpful Diagnostic Test Case - Swift\nDESCRIPTION: This code snippet demonstrates how to add a new test case in `SwiftParserTest` to assert that parsing a given code snippet produces an unhelpful diagnostic. It involves using the `assertParse` function along with `DiagnosticSpec` to specify the expected diagnostic message and location. Markers like `1️⃣` are used to pinpoint the location of the expected diagnostic.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/Fixing Bugs.md#_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nassertParse(\n  \"\"\"\n  <#your code that produced the unhelpful diagnostic#>\n  \"\"\",\n  diagnostics: [\n    DiagnosticSpec(message: \"<#expected diagnostic message#>\")\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Regenerating Swift Syntax Files Using CodeGeneration Swift Package Bash\nDESCRIPTION: This snippet demonstrates the command to regenerate Swift Syntax files after modifying the CodeGeneration tool. It utilizes the Swift Package Manager to run the `generate-swift-syntax` target located in the CodeGeneration package directory. This process is essential to synchronize source files with updates in syntax node definitions.\nSOURCE: https://github.com/swiftlang/swift-syntax/blob/main/Contributor Documentation/Changing Swift Syntax.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nswift run --package-path CodeGeneration generate-swift-syntax\n```"
  }
]