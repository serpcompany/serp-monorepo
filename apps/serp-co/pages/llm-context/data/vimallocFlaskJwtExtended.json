[
  {
    "owner": "vimalloc",
    "repo": "flask-jwt-extended",
    "content": "TITLE: Implementing JWT Authentication in Flask\nDESCRIPTION: This code snippet demonstrates how to set up basic JWT authentication in a Flask application using Flask-JWT-Extended. It includes creating access tokens, protecting routes, and retrieving the JWT identity.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/basic_usage.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../examples/simple.py\n```\n\n----------------------------------------\n\nTITLE: Setting Flask-JWT-Extended Configuration Options in Python\nDESCRIPTION: Example of how to set configuration options for Flask-JWT-Extended using Flask's configuration handling mechanism. This demonstrates the basic pattern for setting any of the available JWT options in a Flask application.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\napp.config[\"OPTION_NAME\"] = option_value\n```\n\n----------------------------------------\n\nTITLE: Implementing Explicit JWT Refreshing with Refresh Tokens in Flask-JWT-Extended\nDESCRIPTION: This code shows how to use long-lived refresh tokens to create new access tokens when they expire. The example includes login, refresh, and protected endpoints with proper token handling.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/refreshing_tokens.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../examples/refresh_tokens.py\n```\n\n----------------------------------------\n\nTITLE: Implementing Logout Route with Redis Storage\nDESCRIPTION: Example of a Flask route that handles JWT token revocation using Redis as storage. The route accepts both access and refresh tokens, stores their JTIs in Redis with expiration time.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/blocklist_and_token_revoking.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@app.route(\"/logout\", methods=[\"DELETE\"])\n@jwt_required(verify_type=False)\ndef logout():\n    token = get_jwt()\n    jti = token[\"jti\"]\n    ttype = token[\"type\"]\n    jwt_redis_blocklist.set(jti, \"\", ex=ACCESS_EXPIRES)\n\n    # Returns \"Access token revoked\" or \"Refresh token revoked\"\n    return jsonify(msg=f\"{ttype.capitalize()} token successfully revoked\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Automatic User Loading with Flask-JWT-Extended and SQLAlchemy\nDESCRIPTION: A complete example showing how to configure Flask-JWT-Extended to automatically load user objects from a SQLAlchemy database. It demonstrates setting up user identity and lookup loaders to seamlessly convert between user objects and JWT identities.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/automatic_user_loading.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask, jsonify, request\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_jwt_extended import create_access_token, get_jwt_identity, jwt_required, JWTManager, current_user\nfrom datetime import timedelta\n\napp = Flask(__name__)\n\napp.config[\"JWT_SECRET_KEY\"] = \"super-secret\"  # Change this!\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = \"sqlite:///\"\napp.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = False\n\ndb = SQLAlchemy(app)\njwt = JWTManager(app)\n\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.Text, nullable=False, unique=True)\n    full_name = db.Column(db.Text, nullable=False)\n    password = db.Column(db.Text, nullable=False)\n\n    # NOTE: In a real application make sure to properly hash and salt passwords\n    def check_password(self, password):\n        return self.password == password\n\n\n# Register a callback function that takes whatever object is passed in as the\n# identity when creating JWTs and converts it to a JSON serializable format.\n@jwt.user_identity_loader\ndef user_identity_lookup(user):\n    return user.id\n\n\n# Register a callback function that loads a user from your database whenever\n# a protected route is accessed. This should return any python object on a\n# successful lookup, or None if the lookup failed for any reason (for example\n# if the user has been deleted from the database).\n@jwt.user_lookup_loader\ndef user_lookup_callback(_jwt_header, jwt_data):\n    identity = jwt_data[\"sub\"]\n    return User.query.filter_by(id=identity).one_or_none()\n\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    username = request.json.get(\"username\", None)\n    password = request.json.get(\"password\", None)\n\n    user = User.query.filter_by(username=username).one_or_none()\n    if not user or not user.check_password(password):\n        return jsonify(\"Wrong username or password\"), 401\n\n    # Notice that we are passing the actual sqlalchemy user object here\n    access_token = create_access_token(\n        identity=user, expires_delta=timedelta(days=30)\n    )\n    return jsonify(access_token=access_token)\n\n\n# In a protected view, get the current user and return their id, username, and\n# full name\n@app.route(\"/who_am_i\", methods=[\"GET\"])\n@jwt_required()\ndef who_am_i():\n    # We can now access our sqlalchemy User object via `current_user`.\n    return jsonify(\n        id=current_user.id,\n        full_name=current_user.full_name,\n        username=current_user.username,\n    )\n\n\nif __name__ == \"__main__\":\n    db.create_all()\n\n    # Create some users\n    if User.query.count() == 0:\n        users = [\n            User(username=\"test\", full_name=\"test user\", password=\"test\"),\n            User(username=\"panther\", full_name=\"Ann Takamaki\", password=\"password\"),\n        ]\n        db.session.add_all(users)\n        db.session.commit()\n\n    app.run()\n```\n\n----------------------------------------\n\nTITLE: Customizing Flask-JWT-Extended Behaviors Using Loader Functions in Python\nDESCRIPTION: This code snippet demonstrates how to use various loader functions to customize the default behaviors of Flask-JWT-Extended. It shows how to modify responses for expired tokens, missing headers, and invalid tokens through callback functions registered with the JWTManager.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/changing_default_behavior.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask, jsonify\nfrom flask_jwt_extended import JWTManager\n\napp = Flask(__name__)\napp.config['JWT_SECRET_KEY'] = 'super-secret'\njwt = JWTManager(app)\n\n\n# This is an example of a complex custom callback that can be used to\n# customize the behavior of this extension\n@jwt.expired_token_loader\ndef my_expired_token_callback(jwt_header, jwt_payload):\n    return jsonify({\n        'status': 401,\n        'sub_status': 42,\n        'msg': 'The token has expired'\n    }), 401\n\n\n# You can also do this for other callbacks\n@jwt.invalid_token_loader\ndef my_invalid_token_callback(err_str):\n    return jsonify({\n        'status': 422,\n        'sub_status': 43,\n        'message': err_str\n    }), 422\n\n\n@jwt.unauthorized_loader\ndef my_unauthorized_callback(err_str):\n    return jsonify({\n        'status': 401,\n        'sub_status': 44,\n        'message': err_str\n    }), 401\n```\n\n----------------------------------------\n\nTITLE: Implementing Implicit JWT Refreshing with Cookies in Flask-JWT-Extended\nDESCRIPTION: This code demonstrates how to automatically refresh JWTs stored in cookies before they expire. The implementation includes setting cookies, creating a callback to automatically refresh tokens, and protected routes to test the functionality.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/refreshing_tokens.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../examples/implicit_refresh.py\n```\n\n----------------------------------------\n\nTITLE: Configuring Optional JWT Protection in Flask Routes\nDESCRIPTION: Demonstrates how to set up Flask routes that can handle requests with or without JWT tokens. Shows usage of jwt_required with optional=True parameter and handling of JWT-related functions in both authenticated and unauthenticated scenarios.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/optional_endpoints.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask, jsonify\nfrom flask_jwt_extended import create_access_token\nfrom flask_jwt_extended import get_jwt_identity\nfrom flask_jwt_extended import jwt_required\nfrom flask_jwt_extended import JWTManager\n\napp = Flask(__name__)\n\n# Setup the Flask-JWT-Extended extension\napp.config[\"JWT_SECRET_KEY\"] = \"super-secret\"  # Change this!\napp.config[\"JWT_ACCESS_TOKEN_EXPIRES\"] = True\njwt = JWTManager(app)\n\n\n# Create a route to authenticate your users and return JWTs. The\n# create_access_token() function is used to actually generate the JWT.\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    access_token = create_access_token(identity=\"example_user\")\n    return jsonify(access_token=access_token)\n\n\n# Protect a route with jwt_required, which will kick out requests\n# without a valid JWT present.\n@app.route(\"/protected\", methods=[\"GET\"])\n@jwt_required()\ndef protected():\n    # Access the identity of the current user with get_jwt_identity\n    current_user = get_jwt_identity()\n    return jsonify(logged_in_as=current_user), 200\n\n\n# Partially protect a route with jwt_required(optional=True), which will\n# let requests without a valid JWT through, but will add the current user\n# to the request context if they do provide a valid JWT.\n@app.route(\"/partially-protected\", methods=[\"GET\"])\n@jwt_required(optional=True)\ndef partially_protected():\n    # get_jwt_identity will return None if no JWT is present in the request\n    current_user = get_jwt_identity()\n    if current_user:\n        return jsonify(logged_in_as=current_user), 200\n    else:\n        return jsonify(logged_in_as=\"anonymous user\"), 200\n\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\n----------------------------------------\n\nTITLE: Implementing JWT Authentication with Cookies in JavaScript\nDESCRIPTION: Demonstrates cookie-based JWT handling with CSRF protection. Includes functions for login, logout, cookie retrieval, and making authenticated requests with proper CSRF token headers.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/token_locations.rst#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nasync function login() {\n  await fetch('/login_with_cookies', {method: 'post'});\n}\n\nasync function logout() {\n  await fetch('/logout_with_cookies', {method: 'post'});\n}\n\nfunction getCookie(name) {\n  const value = `; ${document.cookie}`;\n  const parts = value.split(`; ${name}=`);\n  if (parts.length === 2) return parts.pop().split(';').shift();\n}\n\nasync function makeRequestWithJWT() {\n  const options = {\n    method: 'post',\n    credentials: 'same-origin',\n    headers: {\n      'X-CSRF-TOKEN': getCookie('csrf_access_token'),\n    },\n  };\n  const response = await fetch('/protected', options);\n  const result = await response.json();\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing JWT Authentication with Headers in JavaScript\nDESCRIPTION: Shows how to handle JWT tokens in request headers using JavaScript. Includes functions for login, logout, and making authenticated requests with the JWT stored in localStorage.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/token_locations.rst#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nasync function login() {\n  const response = await fetch('/login_without_cookies', {method: 'post'});\n  const result = await response.json();\n  localStorage.setItem('jwt', result.access_token);\n}\n\nfunction logout() {\n  localStorage.removeItem('jwt');\n}\n\nasync function makeRequestWithJWT() {\n  const options = {\n    method: 'post',\n    headers: {\n      Authorization: `Bearer ${localStorage.getItem('jwt')}`,\n    }\n  };\n  const response = await fetch('/protected', options);\n  const result = await response.json();\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Token Blocklist with SQLAlchemy\nDESCRIPTION: Example showing database model and logout route implementation using SQLAlchemy for token revocation storage. Includes token type tracking and user association.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/blocklist_and_token_revoking.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass TokenBlocklist(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    jti = db.Column(db.String(36), nullable=False, index=True)\n    type = db.Column(db.String(16), nullable=False)\n    user_id = db.Column(\n        db.ForeignKey('person.id'),\n        default=lambda: get_current_user().id,\n        nullable=False,\n    )\n    created_at = db.Column(\n        db.DateTime,\n        server_default=func.now(),\n        nullable=False,\n    )\n\n@app.route(\"/logout\", methods=[\"DELETE\"])\n@jwt_required(verify_type=False)\ndef modify_token():\n    token = get_jwt()\n    jti = token[\"jti\"]\n    ttype = token[\"type\"]\n    now = datetime.now(timezone.utc)\n    db.session.add(TokenBlocklist(jti=jti, type=ttype, created_at=now))\n    db.session.commit()\n    return jsonify(msg=f\"{ttype.capitalize()} token successfully revoked\")\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Claims to JWTs using additional_claims_loader Decorator in Python\nDESCRIPTION: This snippet demonstrates how to use the '@jwt.additional_claims_loader' decorator to add custom claims to JWTs. The decorated function takes an identity parameter and returns a dictionary of additional claims to be included in the token.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/add_custom_data_claims.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Using the additional_claims_loader, we can specify a method that will be\n# called when creating JWTs. The decorated method must take the identity\n# we are creating a token for and return a dictionary of additional\n# claims to add to the JWT.\n@jwt.additional_claims_loader\ndef add_claims_to_access_token(identity):\n    return {\n        \"aud\": \"some_audience\",\n        \"foo\": \"bar\",\n        \"upcase_name\": identity.upper(),\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Token Freshness Pattern in Flask-JWT-Extended\nDESCRIPTION: This code demonstrates the token freshness pattern, where certain critical routes require a fresh token. The example includes creating fresh and non-fresh tokens and protecting routes based on token freshness.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/refreshing_tokens.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../examples/token_freshness.py\n```\n\n----------------------------------------\n\nTITLE: Implementing JWT Authentication with JSON Body in JavaScript\nDESCRIPTION: Demonstrates sending JWTs in the request body as JSON. Only works with HTTP methods that support request bodies (POST/PUT/PATCH/DELETE).\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/token_locations.rst#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nasync function login() {\n  const response = await fetch('/login_without_cookies', {method: 'post'});\n  const result = await response.json();\n  localStorage.setItem('jwt', result.access_token);\n}\n\nfunction logout() {\n  localStorage.removeItem('jwt');\n}\n\nasync function makeRequestWithJWT() {\n  const options = {\n    method: 'post',\n    body: JSON.stringify({access_token: localStorage.getItem('jwt')}),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  };\n  const response = await fetch('/protected', options);\n  const result = await response.json();\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom JWT Decorator for Admin Access in Python\nDESCRIPTION: This code snippet demonstrates how to create a custom decorator 'admin_required' that verifies both the presence of a valid JWT and checks if the user is an administrator. It utilizes the 'verify_jwt_in_request' function from flask_jwt_extended and checks a custom claim 'is_administrator'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/custom_decorators.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom functools import wraps\nfrom flask import jsonify\nfrom flask_jwt_extended import verify_jwt_in_request, get_jwt\n\ndef admin_required():\n    def wrapper(fn):\n        @wraps(fn)\n        def decorator(*args, **kwargs):\n            verify_jwt_in_request()\n            claims = get_jwt()\n            if claims[\"is_administrator\"]:\n                return fn(*args, **kwargs)\n            else:\n                return jsonify(msg=\"Admins only!\"), 403\n\n        return decorator\n\n    return wrapper\n```\n\n----------------------------------------\n\nTITLE: Generating a Random Secret Key for JWT Authentication in Python\nDESCRIPTION: Example code to generate a secure random string that can be used as a JWT secret key. This demonstrates how to create a cryptographically secure random key for JWT token signing and verification.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n$ python -c 'import os; print(os.urandom(16))'\nb'_5#y2L\"F4Q8z\\n\\xec]/'\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT_SESSION_COOKIE in Flask-JWT-Extended\nDESCRIPTION: Controls if the cookies will be set as session cookies, which are deleted when the browser is closed. Default value is True.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nJWT_SESSION_COOKIE = True\n```\n\n----------------------------------------\n\nTITLE: Sending JWT in Authorization Header\nDESCRIPTION: This code block shows the format of the Authorization header used to send the JWT with each request to a protected route.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/basic_usage.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nAuthorization: Bearer <access_token>\n```\n\n----------------------------------------\n\nTITLE: Testing JWT Authentication with HTTPie\nDESCRIPTION: This series of commands demonstrates how to test JWT authentication using HTTPie. It includes attempts to access a protected route without a token, logging in to obtain a token, and successfully accessing the protected route with the token.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/basic_usage.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ http GET :5000/protected\n\nHTTP/1.0 401 UNAUTHORIZED\nContent-Length: 39\nContent-Type: application/json\nDate: Sun, 24 Jan 2021 18:09:17 GMT\nServer: Werkzeug/1.0.1 Python/3.8.6\n\n{\n    \"msg\": \"Missing Authorization Header\"\n}\n\n\n$ http POST :5000/login username=test password=test\n\nHTTP/1.0 200 OK\nContent-Length: 288\nContent-Type: application/json\nDate: Sun, 24 Jan 2021 18:10:39 GMT\nServer: Werkzeug/1.0.1 Python/3.8.6\n\n{\n    \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTYxMTUxMTgzOSwianRpIjoiMmI0NzliNTQtYTI0OS00ZDNjLWE4NjItZGVkZGIzODljNmVlIiwibmJmIjoxNjExNTExODM5LCJ0eXBlIjoiYWNjZXNzIiwic3ViIjoidGVzdCIsImV4cCI6MTYxNDEwMzgzOX0.UpTueBRwNLK8e-06-oo5Y_9eWbaN5T3IHwKsy6Jauaw\"\n}\n\n\n$ export JWT=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTYxMTUxMTgzOSwianRpIjoiMmI0NzliNTQtYTI0OS00ZDNjLWE4NjItZGVkZGIzODljNmVlIiwibmJmIjoxNjExNTExODM5LCJ0eXBlIjoiYWNjZXNzIiwic3ViIjoidGVzdCIsImV4cCI6MTYxNDEwMzgzOX0.UpTueBRwNLK8e-06-oo5Y_9eWbaN5T3IHwKsy6Jauaw\"\n\n\n$ http GET :5000/protected Authorization:\"Bearer $JWT\"\n\nHTTP/1.0 200 OK\nContent-Length: 24\nContent-Type: application/json\nDate: Sun, 24 Jan 2021 18:12:02 GMT\nServer: Werkzeug/1.0.1 Python/3.8.6\n\n{\n    \"logged_in_as\": \"test\"\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Token Freshness Duration in Flask-JWT-Extended\nDESCRIPTION: This snippet shows how to mark a token as fresh for a specific time period after creation by passing a datetime.timedelta to the fresh parameter when creating access tokens.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/refreshing_tokens.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncreate_access_token(identity, fresh=datetime.timedelta(minutes=15))\n```\n\n----------------------------------------\n\nTITLE: Implementing JWT Token Revocation Callback in Flask-JWT-Extended 4.0.0\nDESCRIPTION: Example of the new callback function signature for a revoked token loader with Flask-JWT-Extended 4.0.0. The callback now takes two parameters (jwt_header and jwt_payload) and returns a response when a revoked token is detected.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/v4_upgrade_guide.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@jwt.revoked_token_loader\ndef revoked_token_response(jwt_header, jwt_payload):\n    return jsonify(msg=f\"I'm sorry {jwt_payload['sub']} I can't let you do that\")\n```\n\n----------------------------------------\n\nTITLE: Making a Refresh Token Request with HTTPie\nDESCRIPTION: This example shows how to make an HTTP request with a refresh token using the HTTPie CLI tool. The command sends a POST request to the refresh endpoint with the refresh token in the Authorization header.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/refreshing_tokens.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ http POST :5000/refresh Authorization:\"Bearer $REFRESH_TOKEN\"\n```\n\n----------------------------------------\n\nTITLE: Testing Automatic User Loading API with HTTPie\nDESCRIPTION: A sequence of HTTP requests using HTTPie to demonstrate the login flow and user data retrieval with JWT authentication. It shows how to obtain a JWT token and use it to access protected routes.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/automatic_user_loading.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ http POST :5000/login username=panther password=password\n\nHTTP/1.0 200 OK\nContent-Length: 281\nContent-Type: application/json\nDate: Sun, 24 Jan 2021 17:23:31 GMT\nServer: Werkzeug/1.0.1 Python/3.8.6\n\n{\n    \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTYxMTUwOTAxMSwianRpIjoiNGFmN2ViNTAtMjk3Yy00ZmY4LWJmOTYtMTZlMDE5MWEzYzMwIiwibmJmIjoxNjExNTA5MDExLCJ0eXBlIjoiYWNjZXNzIiwic3ViIjoyLCJleHAiOjE2MTQxMDEwMTF9.2UhZo-xo19NXaqKLwcMz0NBLAcxxEUeK4Ziqk1T_9h0\"\n}\n\n\n$ export JWT=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTYxMTUwOTAxMSwianRpIjoiNGFmN2ViNTAtMjk3Yy00ZmY4LWJmOTYtMTZlMDE5MWEzYzMwIiwibmJmIjoxNjExNTA5MDExLCJ0eXBlIjoiYWNjZXNzIiwic3ViIjoyLCJleHAiOjE2MTQxMDEwMTF9.2UhZo-xo19NXaqKLwcMz0NBLAcxxEUeK4Ziqk1T_9h0\"\n\n\n$ http GET :5000/who_am_i Authorization:\"Bearer $JWT\"\n\nHTTP/1.0 200 OK\nContent-Length: 57\nContent-Type: application/json\nDate: Sun, 24 Jan 2021 17:31:34 GMT\nServer: Werkzeug/1.0.1 Python/3.8.6\n\n{\n    \"id\": 2,\n    \"full_name\": \"Ann Takamaki\",\n    \"username\": \"panther\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT_CSRF_IN_COOKIES in Flask-JWT-Extended\nDESCRIPTION: Controls if the CSRF double submit token will be stored in additional cookies. Default value is True.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nJWT_CSRF_IN_COOKIES = True\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT_REFRESH_CSRF_COOKIE_NAME in Flask-JWT-Extended\nDESCRIPTION: Sets the name of the cookie that contains the CSRF double submit token for refresh tokens. Only applicable if JWT_CSRF_IN_COOKIES is True. Default value is 'csrf_refresh_token'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nJWT_REFRESH_CSRF_COOKIE_NAME = \"csrf_refresh_token\"\n```\n\n----------------------------------------\n\nTITLE: Setting JWT_CSRF_METHODS in Flask-JWT-Extended\nDESCRIPTION: Defines a list of HTTP methods that should have CSRF checks. Default value is [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"].\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nJWT_CSRF_METHODS = [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing JWT Authentication with Query Strings in JavaScript\nDESCRIPTION: Shows how to send JWTs via URL query parameters. Note: This method is generally not recommended for security reasons but may be useful for specific cases like password reset links.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/token_locations.rst#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nasync function login() {\n  const response = await fetch('/login_without_cookies', {method: 'post'});\n  const result = await response.json();\n  localStorage.setItem('jwt', result.access_token);\n}\n\nfunction logout() {\n  localStorage.removeItem('jwt');\n}\n\nasync function makeRequestWithJWT() {\n  const jwt = localStorage.getItem('jwt')\n  const response = await fetch(`/protected?jwt=${jwt}`, {method: 'post'});\n  const result = await response.json();\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting JWT_CSRF_CHECK_FORM in Flask-JWT-Extended\nDESCRIPTION: Controls if form data should also be checked for the CSRF double submit token. Default value is False.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nJWT_CSRF_CHECK_FORM = False\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents in RestructuredText for Flask-JWT-Extended Documentation\nDESCRIPTION: This snippet defines the table of contents (toctree) for the Flask-JWT-Extended documentation, listing all available sections that users can navigate to. It includes references to installation guides, usage examples, token management, and API documentation.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n\n   installation\n   basic_usage\n   automatic_user_loading\n   add_custom_data_claims\n   optional_endpoints\n   token_locations\n   refreshing_tokens\n   blocklist_and_token_revoking\n   options\n   changing_default_behavior\n   custom_decorators\n   api\n   v4_upgrade_guide\n```\n\n----------------------------------------\n\nTITLE: Installing Flask-JWT-Extended via pip\nDESCRIPTION: Basic installation of Flask-JWT-Extended using pip package manager.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/installation.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install flask-jwt-extended\n```\n\n----------------------------------------\n\nTITLE: Installing Flask-JWT-Extended with asymmetric crypto support\nDESCRIPTION: Installation of Flask-JWT-Extended including additional requirements for asymmetric (public/private) key signing algorithms.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/installation.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install flask-jwt-extended[asymmetric_crypto]\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT_ACCESS_CSRF_HEADER_NAME in Flask-JWT-Extended\nDESCRIPTION: Sets the name of the header on an incoming request that should contain the CSRF double submit token. Default value is 'X-CSRF-TOKEN'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nJWT_ACCESS_CSRF_HEADER_NAME = \"X-CSRF-TOKEN\"\n```\n\n----------------------------------------\n\nTITLE: Setting JWT_REFRESH_CSRF_HEADER_NAME in Flask-JWT-Extended\nDESCRIPTION: Defines the name of the header on an incoming request that should contain the CSRF double submit token for refresh tokens. Default value is 'X-CSRF-TOKEN'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nJWT_REFRESH_CSRF_HEADER_NAME = \"X-CSRF-TOKEN\"\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT_JSON_KEY in Flask-JWT-Extended\nDESCRIPTION: Sets the key that should contain the access token in the JSON body of a request. Default value is 'access_token'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nJWT_JSON_KEY = \"access_token\"\n```\n\n----------------------------------------\n\nTITLE: Setting JWT_REFRESH_JSON_KEY in Flask-JWT-Extended\nDESCRIPTION: Defines the key that should contain the refresh token in the JSON body of a request. Default value is 'access_token'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nJWT_REFRESH_JSON_KEY = \"access_token\"\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT_QUERY_STRING_NAME in Flask-JWT-Extended\nDESCRIPTION: Sets the query string parameter that should contain the JWT. Default value is 'jwt'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nJWT_QUERY_STRING_NAME = \"jwt\"\n```\n\n----------------------------------------\n\nTITLE: Setting JWT_ACCESS_CSRF_COOKIE_NAME in Flask-JWT-Extended\nDESCRIPTION: Defines the name of the cookie that contains the CSRF double submit token. Only applicable if JWT_CSRF_IN_COOKIES is True. Default value is 'csrf_access_token'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nJWT_ACCESS_CSRF_COOKIE_NAME = \"csrf_access_token\"\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT_ACCESS_CSRF_COOKIE_PATH in Flask-JWT-Extended\nDESCRIPTION: Sets the path of the access CSRF double submit cookie. Default value is '/'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nJWT_ACCESS_CSRF_COOKIE_PATH = \"/\"\n```\n\n----------------------------------------\n\nTITLE: Setting JWT_ACCESS_CSRF_FIELD_NAME in Flask-JWT-Extended\nDESCRIPTION: Defines the name of the form field that should contain the CSRF double submit token for an access token. Only applicable if JWT_CSRF_CHECK_FORM is True. Default value is 'csrf_token'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nJWT_ACCESS_CSRF_FIELD_NAME = \"csrf_token\"\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT_REFRESH_CSRF_FIELD_NAME in Flask-JWT-Extended\nDESCRIPTION: Sets the name of the form field that should contain the CSRF double submit token for a refresh token. Only applicable if JWT_CSRF_CHECK_FORM is True. Default value is 'csrf_token'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nJWT_REFRESH_CSRF_FIELD_NAME = \"csrf_token\"\n```\n\n----------------------------------------\n\nTITLE: Setting JWT_REFRESH_CSRF_COOKIE_PATH in Flask-JWT-Extended\nDESCRIPTION: Defines the path of the refresh CSRF double submit cookie. Default value is '/'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nJWT_REFRESH_CSRF_COOKIE_PATH = \"/\"\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT_REFRESH_COOKIE_NAME in Flask-JWT-Extended\nDESCRIPTION: Sets the name of the refresh token cookie. Default value is 'refresh_token_cookie'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nJWT_REFRESH_COOKIE_NAME = \"refresh_token_cookie\"\n```\n\n----------------------------------------\n\nTITLE: Setting JWT_REFRESH_COOKIE_PATH in Flask-JWT-Extended\nDESCRIPTION: Defines the path for the refresh cookies. Default value is '/'.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nJWT_REFRESH_COOKIE_PATH = \"/\"\n```\n\n----------------------------------------\n\nTITLE: Setting JWT_QUERY_STRING_VALUE_PREFIX in Flask-JWT-Extended\nDESCRIPTION: Defines an optional prefix string that should appear before the JWT in a query string parameter. Default value is an empty string.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/options.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nJWT_QUERY_STRING_VALUE_PREFIX = \"\"\n```\n\n----------------------------------------\n\nTITLE: Installing Flask-JWT-Extended with asymmetric crypto support in ZSH\nDESCRIPTION: Installation command for Flask-JWT-Extended with asymmetric crypto support, specifically for ZSH and similar shells that require escaping of brackets.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/installation.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install flask-jwt-extended\\[asymmetric_crypto\\]\n```\n\n----------------------------------------\n\nTITLE: Installing Flask-JWT-Extended from source\nDESCRIPTION: Instructions for installing Flask-JWT-Extended from the source code after cloning the repository.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/installation.rst#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ python setup.py install\n```\n\n----------------------------------------\n\nTITLE: Installing Development Requirements for Flask-JWT-Extended\nDESCRIPTION: Command to install the required dependencies for development and set up git hooks for automatic linting and formatting of code changes.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Running All Tests with Tox for Flask-JWT-Extended\nDESCRIPTION: Command to run the complete test suite using tox, which ensures tests pass, code coverage is complete, documentation builds properly, and code adheres to style guidelines.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntox\n```\n\n----------------------------------------\n\nTITLE: Running Specific Test Environments with Tox\nDESCRIPTION: Example of running a specific test environment (Python 3.8) with tox. Various environments are available including different Python versions, type checking, code coverage, documentation, and style checks.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntox -e py38\n```\n\n----------------------------------------\n\nTITLE: Building Documentation for Flask-JWT-Extended\nDESCRIPTION: Commands to generate a local copy of the documentation by cleaning, building HTML files, and opening the resulting documentation in a browser.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmake clean && make html && open _build/html/index.html\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies for Flask-JWT-Extended\nDESCRIPTION: A requirements file listing the exact versions of Python packages needed for the flask-jwt-extended project. It includes development tools like black and pre-commit for code formatting, tox for testing, and runtime dependencies like Flask, PyJWT, and cryptography.\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nblack==23.12.1\ncryptography==42.0.4\nFlask==3.0.1\npre-commit==3.6.0\nPyJWT==2.10.0\ntox==4.12.1\n```\n\n----------------------------------------\n\nTITLE: Defining Sphinx Documentation Dependencies\nDESCRIPTION: Lists required Python packages for building Sphinx documentation including Pallets theme for Flask-style docs\nSOURCE: https://github.com/vimalloc/flask-jwt-extended/blob/main/docs/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nSphinx\nPallets-Sphinx-Themes\n```"
  }
]