[
  {
    "owner": "samchon",
    "repo": "nestia",
    "content": "TITLE: TypedRoute Method Decorators\nDESCRIPTION: This code snippet shows the declaration of the TypedRoute namespace, which includes several method decorators for HTTP request methods like GET, POST, PUT, PATCH, and DELETE. These decorators enhance performance and type safety by utilizing typia.assertStringify<T>().\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedRoute.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace TypedRoute {\n  export function Get(path?: string): MethodDecorator;\n  export function Post(path?: string): MethodDecorator;\n  export function Put(path?: string): MethodDecorator;\n  export function Patch(path?: string): MethodDecorator;\n  export function Delete(path?: string): MethodDecorator;\n}\n```\n\n----------------------------------------\n\nTITLE: BbsArticle Input Validation (TypeScript)\nDESCRIPTION: Validates the BbsArticle input with title length (3-50), body as string, and files as an array of valid IAttachmentFile objects.  Uses TypedBody.guard for error messages with detailed paths and expected types.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedBody.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst $ao0 = (input, _path, _exceptionable = true) =>\n                ((\"string\" === typeof input.title &&\n                  (3 <= input.title.length ||\n                    $guard(_exceptionable, {\n                      path: _path + \".title\",\n                      expected: \"string & MinLength<3>\",\n                      value: input.title,\n                    })) &&\n                  (input.title.length <= 50 ||\n                    $guard(_exceptionable, {\n                      path: _path + \".title\",\n                      expected: \"string & MaxLength<50>\",\n                      value: input.title,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".title\",\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\n                    value: input.title,\n                  })) &&\n                (\"string\" === typeof input.body ||\n                  $guard(_exceptionable, {\n                    path: _path + \".body\",\n                    expected: \"string\",\n                    value: input.body,\n                  })) &&\n                (((Array.isArray(input.files) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".files\",\n                    expected: \"Array<IAttachmentFile>\",\n                    value: input.files,\n                  })) &&\n                  input.files.every(\n                    (elem, _index1) =>\n                      ((\"object\" === typeof elem && null !== elem) ||\n                        $guard(_exceptionable, {\n                          path: _path + \".files[\" + _index1 + \"]\",\n                          expected: \"IAttachmentFile\",\n                          value: elem,\n                        })) &&\n                        $ao1(\n                          elem,\n                          _path + \".files[\" + _index1 + \"]\",\n                          true && _exceptionable,\n                        )) ||\n                      $guard(_exceptionable, {\n                        path: _path + \".files[\" + _index1 + \"]\",\n                        expected: \"IAttachmentFile\",\n                        value: elem,\n                      }),\n                  )) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".files\",\n                    expected: \"Array<IAttachmentFile>\",\n                    value: input.files,\n                  }));\n```\n\n----------------------------------------\n\nTITLE: NestJS Controller with TypedQuery\nDESCRIPTION: This code snippet demonstrates a NestJS controller with a method that uses `@TypedQuery` to automatically parse and validate query parameters based on the `IPage.IRequest` type. Nestia generates optimized code during compilation for parsing and validation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n[__metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", Promise),\n  ],\n  BbsArticlesController.prototype,\n  \"index\",\n  null,\n);\nexports.BbsArticlesController = BbsArticlesController = __decorate(\n  [(0, common_1.Controller)(\"bbs/articles\")],\n  BbsArticlesController,\n);\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration File: nestia.config.ts\nDESCRIPTION: This code snippet demonstrates the structure of the `nestia.config.ts` file, which configures Nestia for SDK generation. It defines the input, output, and distribute paths, along with an asynchronous function to create a NestJS application instance. The input function creates the NestJS application instance to be analyzed. The output configures the path to save the generated SDK to.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/index.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  distribute: \"packages/api\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with Real Code\nDESCRIPTION: This code provides a concrete example of initializing Agentica with a shopping API, counselor, policy, and RAG components. It demonstrates configuring the Agentica instance with an OpenAI model, defining controllers with HTTP and class protocols, and connecting to the shopping backend with authentication headers. This allows the agent to interact with external APIs and local class-based applications, initiating a conversation with the chatbot.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/chat.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport { OpenApi, HttpLlm } from \"@samchon/openapi\";\nimport typia from \"typia\";\n\nconst main = async (): Promise<void> => {\n  const agent = new Agentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({ apiKey: \"*****\" }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [\n      {\n        protocol: \"http\",\n        name: \"shopping\",\n        application: HttpLlm.application({\n          model: \"chatgpt\",\n          document: OpenApi.convert(\n            await fetch(\n              \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n            ).then(r => r.json()),\n          ),\n        }),\n        connection: {\n          host: \"https://shopping-be.wrtn.ai\",\n          headers: {\n            Authorization: \"Bearer *****\",\n          },\n        },\n      },\n      {\n        protocol: \"class\",\n        name: \"counselor\",\n        application: \n          typia.llm.application<ShoppingCounselor, \"chatgpt\">(),\n        execute: new ShoppingCounselor(),\n      },\n      {\n        protocol: \"class\",\n        name: \"policy\",\n        application: \n          typia.llm.application<ShoppingPolicy, \"chatgpt\">(),\n        execute: new ShoppingPolicy(),\n      },\n      {\n        protocol: \"class\",\n        name: \"rag\",\n        application: \n          typia.llm.application<ShoppingSearchRag, \"chatgpt\">(),\n        execute: new ShoppingSearchRag(),\n      },\n    ],\n  });\n  await agent.conversate(\"I wanna buy MacBook Pro\");\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Controller with Typed Routes\nDESCRIPTION: This code snippet shows a NestJS controller that uses `@nestia/core` to define typed routes and parameters. It demonstrates how to use `TypedParam` and `TypedQuery` decorators for automatic validation and type inference.  The example implements a `GET` endpoint that returns a paginated list of `IBbsArticle.ISummary` objects.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/index.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport core from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport typia, { tags } from \"typia\";\n\n@Controller(\"bbs/articles/:section\")\nexport class TypedBodyControlleer {\n  @core.TypedRoute.Get()\n  public async index(\n    @core.TypedParam(\"section\") section: string,\n    @core.TypedQuery() query: IPage.IRequest,\n  ): Promise<IPage<IBbsArticle.ISummary>> {\n    const limit: number = query.limit ?? 100;\n    const current: number = query.page ?? 1;\n    const records: number = limit * (current + 3) + 5;\n\n    return {\n      pagination: {\n        current,\n        limit,\n        records,\n        pages: Math.ceil(records / limit),\n      },\n      data: new Array(limit).fill(\"\").map(() => ({\n        ...typia.random<IBbsArticle.ISummary>(),\n        section,\n      })),\n    };\n  }\n}\ninterface IPage<T> {\n  data: T[];\n  pagination: IPage.IPagination;\n}\nnamespace IPage {\n  export interface IRequest {\n    page?: null | (number & tags.Type<\"uint32\">);\n    limit?: null | (number & tags.Type<\"uint32\">);\n  }\n  export interface IPagination {\n    current: number & tags.Type<\"uint32\">;\n    limit: number & tags.Type<\"uint32\">;\n    records: number & tags.Type<\"uint32\">;\n    pages: number & tags.Type<\"uint32\">;\n  }\n}\n\nnamespace IBbsArticle {\n  export interface ISummary {\n    id: string & tags.Format<\"uuid\">;\n    section: string;\n    writer: string;\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\n    created_at: string & tags.Format<\"date-time\">;\n    /**\n     * @format date-time\n     */\n    updated_at: string;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using TypedException in Controller\nDESCRIPTION: Demonstrates how to use the TypedException decorator in a Nestia controller to specify different HTTP exception responses. The example uses various status codes and includes a detailed example for a 400 error, associating it with a TypeGuardError.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedException.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Controller } from \"@nestjs/common\";\nimport typia, { TypeGuardError } from \"typia\";\n\nimport {\n  TypedBody,\n  TypedException,\n  TypedParam,\n  TypedRoute,\n} from \"@nestia/core\";\n\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\nimport { IInternalServerError } from \"@api/lib/structures/IInternalServerError\";\nimport { INotFound } from \"@api/lib/structures/INotFound\";\nimport { IUnprocessibleEntity } from \"@api/lib/structures/IUnprocessibleEntity\";\n\n@Controller(\"exception\")\nexport class ExceptionController {\n  @TypedRoute.Post(\":section/typed\")\n  @TypedException<TypeGuardError>({\n    status: 400, \n    description: \"invalid request\",\n    example: {\n      name: \"BadRequestException\",\n      method: \"TypedBody\",\n      path: \"$input.title\",\n      expected: \"string\",\n      value: 123,\n      message: \"invalid type\",\n    },\n  })\n  @TypedException<INotFound>(404, \"unable to find the matched section\")\n  @TypedException<IUnprocessibleEntity>(428)\n  @TypedException<IInternalServerError>(\"5XX\", \"internal server error\")\n  public async typed(\n    @TypedParam(\"section\") section: string,\n    @TypedBody() input: IBbsArticle.IStore,\n  ): Promise<IBbsArticle> {\n    section;\n    input;\n    return typia.random<IBbsArticle>();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: LLM Application Schema for BbsArticle - JSON\nDESCRIPTION: This JSON configures the LLM application schema, specifically defining the `bbs_articles_at` function that retrieves an article by ID. The schema includes descriptions of the input parameters and the output data structure (IBbsArticle), enabling an LLM to understand and interact with the API. This showcases the configuration required for an LLM to interface with a Nestia application.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"model\": \"chatgpt\",\n  \"options\": {\n    \"reference\": false,\n    \"strict\": false,\n    \"separate\": null,\n    \"maxLength\": null\n  },\n  \"functions\": [\n    {\n      \"method\": \"get\",\n      \"path\": \"/bbs/articles/{id}\",\n      \"name\": \"bbs_articles_at\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"description\": \" Target article's {@link IBbsArticle.id }\\n\\n\\n@format uuid\",\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false,\n        \"required\": [\n          \"id\"\n        ],\n        \"$defs\": {}\n      },\n      \"output\": {\n        \"description\": \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\\n\\n\\n@format uuid\",\n            \"type\": \"string\"\n          },\n          \"created_at\": {\n            \"title\": \"Creation time of the article\",\n            \"description\": \"Creation time of the article.\\n\\n\\n@format date-time\",\n            \"type\": \"string\"\n          },\n          \"updated_at\": {\n            \"title\": \"Last updated time of the article\",\n            \"description\": \"Last updated time of the article.\\n\\n\\n@format date-time\",\n            \"type\": \"string\"\n          },\n          \"title\": {\n            \"title\": \"Title of the article\",\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\",\n            \"type\": \"string\"\n          },\n          \"body\": {\n            \"title\": \"Content body\",\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n            \"type\": \"string\"\n          },\n          \"thumbnail\": {\n            \"title\": \"Thumbnail image URI\",\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n            \"anyOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"description\": \"@format uri\\n@contentMediaType image/*\"\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\"\n        ]\n      },\n      \"description\": \"Read an article.\\n\\nReads an article from the DB.\",\n      \"tags\": []\n    }\n  ],\n  \"errors\": []\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Nestia for Simulation in TypeScript\nDESCRIPTION: This code snippet shows the configuration for Nestia SDK, specifically enabling the `simulate` option to `true` in `nestia.config.ts`. This allows the generated SDK to support mockup simulation mode, useful for frontend development when the backend server is not ready.  The `input` property defines how to create a NestJS application instance, and the `output` and `distribute` properties define where the generated SDK will be placed. The `e2e` property determines the location of generated e2e tests.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n      //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  simulate: true, // supports simulation mode\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Defining INestiaConfig Interface\nDESCRIPTION: This code defines the `INestiaConfig` interface, which specifies the structure for the Nestia configuration object.  It details properties like `input` (source of controller classes), `output` (SDK output directory), `swagger` (Swagger configuration), `distribute` (SDK distribution directory), `simulate` (enables simulation mode), `e2e` (E2E test directory), `propagate`, `clone`, `primitive`, `assert`, and `json`. The `IInput` and `ISwaggerConfig` interfaces provide nested configurations for input files and swagger generation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { INestApplication } from \"@nestjs/common\";\nimport type { OpenApi } from \"@samchon/openapi\";\n\n/**\n * Definition for the `nestia.config.ts` file.\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport interface INestiaConfig {\n  /**\n   * Accessor of controller classes.\n   *\n   * You can specify it within two ways\n   *\n   *   - Asynchronous function returning `INestApplication` instance\n   *   - Specify the path or directory of controller class files\n   */\n  input:\n    | (() => Promise<INestApplication>)\n    | INestiaConfig.IInput\n    | string[]\n    | string;\n\n  /**\n   * Output directory that SDK would be placed in.\n   *\n   * If not configured, you can't build the SDK library.\n   */\n  output?: string;\n\n  /**\n   * Building `swagger.json` is also possible.\n   *\n   * If not specified, you can't build the `swagger.json`.\n   */\n  swagger?: INestiaConfig.ISwaggerConfig;\n\n  /**\n   * Target directory that SDK distribution files would be placed in.\n   *\n   * If you configure this property and runs `npx nestia sdk` command,\n   * distribution environments for the SDK library would be generated.\n   *\n   * After the SDK library generation, move to the `distribute` directory,\n   * and runs `npm publish` command, then you can share SDK library with\n   * other client (frontend) developers.\n   *\n   * Recommend to use `\"packages/api\"` value.\n   */\n  distribute?: string;\n\n  /**\n   * Allow simulation mode.\n   *\n   * If you configure this property to be `true`, the SDK library would be contain\n   * simulation mode. In the simulation mode, the SDK library would not communicate\n   * with the real backend server, but just returns random mock-up data\n   * with requestion data validation.\n   *\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\n   * function.\n   *\n   * @default false\n   */\n  simulate?: boolean;\n\n  /**\n   * Target directory that e2e test functions would be placed in.\n   *\n   * If you configure this property and runs `npx nestia e2e` command,\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\n   * generates e2e test functions for every API endpoints.\n   *\n   * If not configured, you can't run `npx nestia e2e` command.\n   */\n  e2e?: string;\n\n  /**\n   * Whether to use propagation mode or not.\n   *\n   * If being configured, interaction functions of the SDK library would\n   * perform the propagation mode. The propagation mode means that never\n   * throwing exception even when status code is not 200 (or 201), but just\n   * returning the {@link IPropagation} typed instance, which can specify its body\n   * type through discriminated union determined by status code.\n   *\n   * @default false\n   */\n  propagate?: boolean;\n\n  /**\n   * Whether to clone DTO structures or not.\n   *\n   * If being configured, all of DTOs used in the backend server would be cloned\n   * into the `structures` directory, and the SDK library would be refer to the\n   * cloned DTOs instead of the original.\n   *\n   * @default false\n   */\n  clone?: boolean;\n\n  /**\n   * Whether to wrap DTO by primitive type.\n   *\n   * If you don't configure this property as `false`, all of DTOs in the\n   * SDK library would be automatically wrapped by {@link Primitive} type.\n   *\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\n   * all of methods in the DTO type would be automatically erased. Also, if\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\n   * converted to return type of the `toJSON()` method.\n   *\n   * @default true\n   */\n  primitive?: boolean;\n\n  /**\n   * Whether to assert parameter types or not.\n   *\n   * If you configure this property to be `true`, all of the function\n   * parameters of SDK library would be checked through\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\n   *\n   * This option would make your SDK library compilation time a little bit slower,\n   * but would enahcne the type safety even in the runtime level.\n   *\n   * @default false\n   */\n  assert?: boolean;\n\n  /**\n   * Whether to optimize JSON string conversion 10x faster or not.\n   *\n   * If you configure this property to be `true`, the SDK library would utilize the\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\n   * to boost up JSON serialization speed and ensure type safety.\n   *\n   * This option would make your SDK library compilation time a little bit slower,\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\n   * safety even in the runtime level.\n   *\n   * @default false\n   */\n  json?: boolean;\n}\nexport namespace INestiaConfig {\n  /**\n   * List of files or directories to include or exclude to specifying the NestJS\n   * controllers.\n   */\n  export interface IInput {\n    /**\n     * List of files or directories containing the NestJS controller classes.\n     */\n    include: string[];\n\n    /**\n     * List of files or directories to be excluded.\n     */\n    exclude?: string[];\n  }\n\n  /**\n   * Building `swagger.json` is also possible.\n   */\n  export interface ISwaggerConfig {\n    /**\n     * Output path of the `swagger.json`.\n     *\n     * If you've configured only directory, the file name would be the `swagger.json`.\n     * Otherwise you've configured the full path with file name and extension, the\n     * `swagger.json` file would be renamed to it.\n     */\n    output: string;\n\n    /**\n     * OpenAPI version.\n     *\n     * If you configure this property to be `2.0` or `3.0`, the newly generated\n     * `swagger.json` file would follow the specified OpenAPI version. The newly\n     * generated `swagger.json` file would be downgraded from the OpenAPI v3.1\n     * specification by {@link OpenApi.downgrade} method.\n     *\n     * @default 3.1\n     */\n    openapi?: \"2.0\" | \"3.0\" | \"3.1\";\n\n    /**\n     * API information.\n     *\n     * If omitted, `package.json` content would be used instead.\n     */\n    info?: Partial<OpenApi.IDocument.IServer>;\n\n    /**\n     * List of server addresses.\n     */\n    servers?: OpenApi.IServer[];\n\n    /**\n     * Security schemes.\n     *\n     * When generating `swagger.json` file through `nestia`, if your controllers or\n     * theirs methods have a security key which is not enrolled in here property,\n     * it would be an error.\n     */\n    security?: Record<string, OpenApi.ISecurityScheme>;\n\n    /**\n     * List of tag names with description.\n     *\n     * It is possible to omit this property or skip some tag name even if\n     * the tag name is used in the API routes. In that case, the tag name\n     * would be used without description.\n     *\n     * Of course, if you've written a comment like `@tag {name} {description}`,\n     * you can entirely replace this property specification.\n     */\n    tags?: OpenApi.IDocument.ITag[];\n\n    /**\n     * Decompose query DTO.\n     *\n     * If you configure this property to be `true`, the query DTO would be decomposed\n     * into individual query parameters per each property. Otherwise you set it to be\n     * `false`, the query DTO would be one object type which contains all of query\n     * parameters.\n     *\n     * @default false\n     */\n    decompose?: boolean;\n\n    /**\n     * Operation ID generator.\n     *\n     * @param props Properties of the API endpoint.\n     * @returns Operation ID.\n     */\n    operationId?(props: {\n      class: string;\n      function: string;\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n      path: string;\n    }): string;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nestia for Swagger Generation in nestia.config.ts\nDESCRIPTION: This TypeScript code defines the configuration for Nestia's Swagger generation. It specifies the input application using NestFactory, sets up Swagger options such as OpenAPI version, output file path, security definitions (bearer authentication), server URLs, and beautification. The input property uses NestFactory to create an instance of YourModule.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  swagger: {\n    openapi: \"3.1\",\n    output: \"dist/swagger.json\",\n    security: {\n      bearer: {\n        type: \"apiKey\",\n        name: \"Authorization\",\n        in: \"header\",\n      },\n    },\n    servers: [\n      {\n        url: \"http://localhost:3000\",\n        description: \"Local Server\",\n      },\n    ],\n    beautify: true,\n  },\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Fastify Multer Setup for NestJS\nDESCRIPTION: This snippet shows how to configure `fastify-multer` when composing a NestJS application to use `@TypedFormData.Body` with `Blob` or `File` types. Without this setup, `@TypedFormData.Body()` will throw a 500 error when `Blob` or `File` types are utilized.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedFormData.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\nimport { NestFactory } from \"@nestjs/core\";\nimport {\n  FastifyAdapter,\n  NestFastifyApplication\n} from \"@nestjs/platform-fastify\";\nimport FastifyMulter from \"fastify-multer\";\n\nexport async function main() {\n  const app = await NestFactory.create<NestFastifyApplication>(\n    AppModule,\n    new FastifyAdapter(),\n  );\n  app.register(FastifyMulter.contentParser as any);\n  await app.listen(3000);\n}\n\n// BbsArticlesController.ts\nimport { TypedFormData, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport FastifyMulter from \"fastify-multer\";\n\nimport { IBbsArticleCreate } from \"./IBbsArticleCreate\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  @TypedRoute.Post()\n  public async create(\n    @TypedFormData.Body(() => FastifyMulter()) input: IBbsArticleCreate,\n  ): Promise<void> {\n    input;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated API Function with Nestia SDK\nDESCRIPTION: This TypeScript snippet showcases a generated API function (`update`) using Nestia.  It demonstrates how Nestia creates typed `fetch` functions based on the NestJS controller, including request and response types, HTTP method, path, and metadata. It uses `PlainFetcher` for making the API call and includes types for input, output, and metadata.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/index.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Update an article.\n * \n * @param section Section code\n * @param id Target article ID\n * @param input Content to update\n * @returns Updated content\n *\n * @controller BbsArticlesController.update()\n * @path PUT /bbs/:section/articles/:id\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\n */\nexport async function update(\n  connection: IConnection,\n  section: string,\n  id: string & Format<\"uuid\">,\n  input: update.Input,\n): Promise<update.Output> {\n  return PlainFetcher.fetch(\n    {\n      ...connection,\n      headers: {\n        ...connection.headers,\n        \"Content-Type\": \"application/json\",\n      },\n    },\n    {\n      ...update.METADATA,\n      path: update.path(section, id),\n    } as const,\n    input,\n  );\n}\nexport namespace update {\n  export type Input = Primitive<IBbsArticle.IStore>;\n  export type Output = Primitive<IBbsArticle>;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:section/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    status: null,\n  } as const;\n\n  export const path = (\n    section: string,\n    id: string & Format<\"uuid\">,\n  ): string => {\n    return `/bbs/articles/${encodeURIComponent(\n      section ?? \"null\",\n    )}/${encodeURIComponent(id ?? \"null\")}`;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: BbsArticlesController with TypedQuery.Body() (TypeScript)\nDESCRIPTION: Illustrates the usage of @TypedQuery.Body() within a NestJS controller to handle the request body.  The store method accepts a body parameter decorated with @TypedQuery.Body(), which automatically parses the incoming application/x-www-form-urlencoded data into the IBbsArticle.IStore interface.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedQuery } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\n\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  @TypedQuery.Post()\n  public async store(\n    @TypedQuery.Body() body: IBbsArticle.IStore,\n  ): Promise<IBbsArticle> {\n    return {\n      id: \"00000000-0000-0000-0000-000000000000\",\n      writer: \"Samchon\",\n      title: body.title,\n      body: body.body,\n      created_at: new Date().toISOString(),\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: WebSocket Controller with Nested Decorators (NestJS/TypeScript)\nDESCRIPTION: Defines a NestJS controller for handling WebSocket connections to an advanced calculator.  It utilizes nested decorators like `@WebSocketRoute.Param`, `@WebSocketRoute.Header`, `@WebSocketRoute.Query`, and `@WebSocketRoute.Acceptor` to extract parameters and manage the WebSocket connection. It imports necessary modules from `@nestia/core`, `@nestjs/common`, `tgrid` and custom interfaces.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WebSocketRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { Driver, WebSocketAcceptor } from \"tgrid\";\nimport { tags } from \"typia\";\n\nimport { IAdvancedCalculator } from \"./api/structures/IAdvancedCalculator\";\nimport { IHeader } from \"./api/structures/IHeader\";\nimport { IListener } from \"./api/structures/IListener\";\nimport { IMemo } from \"./api/structures/IMemo\";\nimport { AdvancedCalculator } from \"./providers/AdvancedCalculator\";\n\n@Controller(\"calculate\")\nexport class CalculateController {\n  /**\n   * Start advanced calculator.\n   * \n   * Start advanced calculator through WebSocket with additional information.\n   * \n   * @param id ID to assign\n   * @param header Header information\n   * @param memo Memo to archive\n   */\n  @WebSocketRoute(\":id/advance\")\n  public async advance(\n    @WebSocketRoute.Param(\"id\") id: string & tags.Format<\"uuid\">,\n    @WebSocketRoute.Header() header: undefined | Partial<IHeader>,\n    @WebSocketRoute.Query() memo: IMemo,\n    @WebSocketRoute.Acceptor()\n    acceptor: WebSocketAcceptor<undefined, IAdvancedCalculator, IListener>,\n  ): Promise<void> {\n    if (header?.precision !== undefined && header.precision < 0)\n      await acceptor.reject(1008, \"Invalid precision value\");\n    else\n      await acceptor.accept(\n        new AdvancedCalculator(\n          id,\n          { precision: header?.precision ?? 2 },\n          memo,\n          acceptor.getDriver(),\n        ),\n      );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated E2E Test Function\nDESCRIPTION: This code snippet presents an example of a generated E2E test function by Nestia.  It imports the `api` object, a type definition `IBbsArticle`, and `typia`. The test function `test_api_body_store` calls `api.functional.body.store` with a random `IBbsArticle.IStore` object generated by `typia.random`. The output of the API call is then asserted using `typia.assert`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { Primitive } from \"typia\";\n\nimport api from \"../../../../src/api\";\nimport type { IBbsArticle } from \"../../../../src/api/structures/IBbsArticle\";\n\nexport const test_api_body_store = async (\n  connection: api.IConnection,\n): Promise<void> => {\n  const output = await api.functional.body.store(\n    connection,\n    typia.random<Primitive<IBbsArticle.IStore>>>(),\n  );\n  typia.assert(output);\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring JSON Serialization in tsconfig.json (JSON)\nDESCRIPTION: Demonstrates how to configure the `stringify` property within the TypeScript compiler options to change the JSON serialization function used by the `@TypedRoute` module.  Allows for different validation and serialization strategies, including disabling validation altogether. The example shows enabling `assert` mode, which utilizes `typia.json.assertStringify<T>()`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedRoute.mdx#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"plugins\": [\n      { \"transform\": \"typia/lib/transform\" },\n      {\n        \"transform\": \"@nestia/core/lib/transform\",\n        \"stringify\": \"assert\",\n        // \"llm\": {\n        //   \"model\": \"chatgpt\",\n        //   \"strict\": true,\n        // },\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing BBS Article Index and Search with Nestia TypeScript\nDESCRIPTION: This test function, `test_api_bbs_article_index_search`, tests the indexing and searching of BBS articles. It creates 100 articles with random content and then retrieves all of them using `api.functional.bbs.articles.index`. It defines a search function using `TestValidator.search` to validate search results based on title and writer. The tests involve searching by title, writer, and a combination of both, ensuring that the search function accurately filters articles based on the provided criteria.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/why.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\n\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\n\nexport async function test_api_bbs_article_index_search(\n  connection: api.IConnection,\n): Promise<void> {\n  // GENERATE 100 ARTICLES\n  const section: string = \"general\";\n  const articles: IBbsArticle[] = await ArrayUtil.asyncRepeat(100)(() =>\n    api.functional.bbs.articles.create(connection, section, {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(4)(),\n      body: RandomGenerator.content(3)()(),\n      format: \"txt\",\n      files: [],\n      password: RandomGenerator.alphabets(8),\n    }),\n  );\n\n  // GET ENTIRE DATA\n  const total: IPage<IBbsArticle.ISummary> =\n    await api.functional.bbs.articles.index(connection, section, {\n      limit: articles.length,\n      sort: [\"-created_at\"],\n    });\n\n  // PREPARE SEARCH FUNCTION\n  const search = TestValidator.search(\"BbsArticleProvider.index()\")(\n    async (input: IBbsArticle.IRequest.ISearch) => {\n      const page: IPage<IBbsArticle.ISummary> =\n        await api.functional.bbs.articles.index(connection, section, {\n          limit: articles.length,\n          search: input,\n          sort: [\"-created_at\"],\n        });\n      return page.data;\n    },\n  )(total.data, 10);\n\n  // SEARCH TITLE\n  await search({\n    fields: [\"title\"],\n    values: (article) => [article.title],\n    request: ([title]) => ({ title }),\n    filter: (article, [title]) => article.title.includes(title),\n  });\n\n  // SEARCH WRITER\n  await search({\n    fields: [\"writer\"],\n    values: (article) => [article.writer],\n    request: ([writer]) => ({ writer }),\n    filter: (article, [writer]) => article.writer.includes(writer),\n  });\n\n  // SEARCH BOTH OF THEM\n  await search({\n    fields: [\"title\", \"writer\"],\n    values: (article) => [article.title, article.writer],\n    request: ([title, writer]) => ({ title, writer }),\n    filter: (article, [title, writer]) =>\n      article.title.includes(title) && article.writer.includes(writer),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Nestia SDK Distribution\nDESCRIPTION: This TypeScript code configures the Nestia SDK for distribution. It defines the input application using NestFactory.create, sets the output directory for generated API files, and specifies the distribution directory for the SDK package. Line 19 is highlighted.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/distribute.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  distribute: \"packages/api\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: TypedQuery Decorators in Nestia Core (TypeScript)\nDESCRIPTION: Defines the TypedQuery decorator and its associated HTTP method decorators (Get, Post, Put, Patch, Delete) within the @nestia/core library. These decorators are used for handling query parameters and defining HTTP endpoints in NestJS controllers.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function TypedQuery(): ParameterDecorator;\nexport namespace TypedQuery {\n  export function Body(): ParameterDecorator;\n  export function Get(path?: string): MethodDecorator;\n  export function Post(path?: string): MethodDecorator;\n  export function Put(path?: string): MethodDecorator;\n  export function Patch(path?: string): MethodDecorator;\n  export function Delete(path?: string): MethodDecorator;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and setting up Nestia with Runtime Swagger\nDESCRIPTION: These Bash commands install the latest version of Nestia and then run the Nestia setup command.  The `--runtime true` argument automatically configures the tsconfig.json file with the necessary plugin for runtime Swagger generation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save-dev nestia@latest\nnpx nestia setup --runtime true\n```\n\n----------------------------------------\n\nTITLE: LLM Configuration JSON\nDESCRIPTION: This JSON configuration defines the settings for an LLM (Language Large Model) within a Nestia project. It specifies the model to use (chatgpt), options such as reference and strictness, and a list of API functions with their respective paths, method types, parameter schemas, and output schemas. The configuration also includes descriptions for each function, parameters, and outputs for LLM understanding.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"model\": \"chatgpt\",\n  \"options\": {\n    \"reference\": false,\n    \"strict\": false,\n    \"separate\": null,\n    \"maxLength\": null\n  },\n  \"functions\": [\n    {\n      \"method\": \"post\",\n      \"path\": \"/bbs/articles\",\n      \"name\": \"bbs_articles_create\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"body\": {\n            \"description\": \"Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the current {@link IBbsArticle.ICreate} type:\\n\\n> Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the parent {@link IBbsArticle} type:\\n\\n> Article entity.\\n> \\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n            \"type\": \"object\",\n            \"properties\": {\n              \"title\": {\n                \"title\": \"Title of the article\",\n                \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\",\n                \"type\": \"string\"\n              },\n              \"body\": {\n                \"title\": \"Content body\",\n                \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                \"type\": \"string\"\n              },\n              \"thumbnail\": {\n                \"title\": \"Thumbnail image URI\",\n                \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                \"anyOf\": [\n                  {\n                    \"type\": \"null\"\n                  },\n                  {\n                    \"type\": \"string\",\n                    \"description\": \"@format uri\\n@contentMediaType image/*\"\n                  }\n                ]\n              }\n            },\n            \"required\": [\n              \"title\",\n              \"body\",\n              \"thumbnail\"\n            ]\n          }\n        },\n        \"additionalProperties\": false,\n        \"required\": [\n          \"body\"\n        ],\n        \"$defs\": {}\n      },\n      \"output\": {\n        \"description\": \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\\n\\n\\n@format uuid\",\n            \"type\": \"string\"\n          },\n          \"created_at\": {\n            \"title\": \"Creation time of the article\",\n            \"description\": \"Creation time of the article.\\n\\n\\n@format date-time\",\n            \"type\": \"string\"\n          },\n          \"updated_at\": {\n            \"title\": \"Last updated time of the article\",\n            \"description\": \"Last updated time of the article.\\n\\n\\n@format date-time\",\n            \"type\": \"string\"\n          },\n          \"title\": {\n            \"title\": \"Title of the article\",\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\",\n            \"type\": \"string\"\n          },\n          \"body\": {\n            \"title\": \"Content body\",\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n            \"type\": \"string\"\n          },\n          \"thumbnail\": {\n            \"title\": \"Thumbnail image URI\",\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n            \"anyOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"description\": \"@format uri\\n@contentMediaType image/*\"\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\"\n        ]\n      },\n      \"description\": \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\n      \"tags\": []\n    },\n    {\n      \"method\": \"put\",\n      \"path\": \"/bbs/articles/{id}\",\n      \"name\": \"bbs_articles_update\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"description\": \" Target article's {@link IBbsArticle.id }\\n\\n\\n@format uuid\",\n            \"type\": \"string\"\n          },\n          \"body\": {\n            \"description\": \"Make all properties in T optional\\n\\n------------------------------\\n\\nDescription of the current {@link PartialIBbsArticle.ICreate} type:\\n\\n> Make all properties in T optional\",\n            \"type\": \"object\",\n            \"properties\": {\n              \"title\": {\n                \"title\": \"Title of the article\",\n                \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\",\n                \"type\": \"string\"\n              },\n              \"body\": {\n                \"title\": \"Content body\",\n                \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                \"type\": \"string\"\n              },\n              \"thumbnail\": {\n                \"title\": \"Thumbnail image URI\",\n                \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                \"anyOf\": [\n                  {\n                    \"type\": \"null\"\n                  },\n                  {\n                    \"type\": \"string\",\n                    \"description\": \"@format uri\\n@contentMediaType image/*\"\n                  }\n                ]\n              }\n            },\n            \"required\": []\n          }\n        },\n        \"additionalProperties\": false,\n        \"required\": [\n          \"id\",\n          \"body\"\n        ],\n        \"$defs\": {}\n      },\n      \"output\": {},\n      \"description\": \"Update an article.\\n\\nUpdates an article with new content.\",\n      \"tags\": []\n    },\n    {\n      \"method\": \"delete\",\n      \"path\": \"/bbs/articles/{id}\",\n      \"name\": \"bbs_articles_erase\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"description\": \" Target article's {@link IBbsArticle.id }\\n\\n\\n@format uuid\",\n            \"type\": \"string\"\n          }\n        },\n        \"additionalProperties\": false,\n        \"required\": [\n          \"id\"\n        ],\n        \"$defs\": {}\n      },\n      \"output\": {},\n      \"description\": \"Erase an article.\\n\\nErases an article from the DB.\",\n      \"tags\": []\n    }\n  ],\n  \"errors\": []\n}\n```\n\n----------------------------------------\n\nTITLE: Update Article Endpoint with Simulation in TypeScript\nDESCRIPTION: This TypeScript code defines an endpoint for updating an article, including both the real API call and the simulation logic.  It uses `PlainFetcher` for the real API call and `NestiaSimulator` to generate mock responses when the simulation mode is enabled. The code defines the input and output types, metadata about the endpoint, and functions for generating the path and random data.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Update an article.\n *\n * @param section Section code\n * @param id Target article ID\n * @param input Content to update\n * @returns Updated content\n *\n * @controller BbsArticlesController.update()\n * @path PUT /bbs/:section/articles/:id\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\n */\nexport async function update(\n  connection: IConnection,\n  section: string,\n  id: string & Format<\"uuid\">,\n  input: update.Input,\n): Promise<update.Output> {\n  return !!connection.simulate\n    ? update.simulate(connection, section, id, input)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...update.METADATA,\n          path: update.path(section, id),\n        } as const,\n        input,\n      );\n}\nexport namespace update {\n  export type Input = Primitive<IBbsArticle.IStore>;\n  export type Output = Primitive<IBbsArticle>;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:section/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    status: null,\n  } as const;\n\n  export const path = (\n    section: string,\n    id: string & Format<\"uuid\">,\n  ): string => {\n    return `/bbs/${encodeURIComponent(\n      section ?? \"null\",\n    )}/articles/${encodeURIComponent(id ?? \"null\")}`;\n  };\n\n  export const random = (g?: Partial<typia.IRandomGenerator>): Output =>\n    typia.random<Output>(g);\n\n  export const simulate = async (\n    connection: IConnection,\n    section: string,\n    id: string & Format<\"uuid\">,\n    input: update.Input,\n  ): Promise<Output> => {\n    const assert = NestiaSimulator.assert({\n      method: METHOD,\n      host: connection.host,\n      path: path(section, id),\n    });\n    assert.param(\"section\")(\"string\")(() => typia.assert(section));\n    assert.param(\"id\")(\"uuid\")(() => typia.assert(id));\n    assert.body(() => typia.assert(input));\n    return random(\n      typeof connection.simulate === \"object\" && connection.simulate !== null\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: TypedFormData Body Decorator Definition TypeScript\nDESCRIPTION: Defines the TypedFormData namespace with a Body decorator function for handling multipart/form-data requests.  It is used to define the Multer configuration for the request and handles type casting and validation of the request body. The interface IMulterBase defines the base Multer types that are compatible.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedFormData.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace TypedFormData {\n  export function Body<Multer extends IMulterBase>(\n    factory: () => Multer | Promise<Multer>\n  ): ParameterDecorator;\n  export type IMulterBase = ExpressMulter.Multer | FastifyMulter.Multer;\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Config with Controller Paths Array\nDESCRIPTION: This configuration specifies an array of paths to controller files or directories as the input for Nestia. Nestia will scan these paths for controllers and generate API documentation. It supports multiple controller locations. The paths are relative to the project root.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: [\"src/controllers\", \"src/fake/controllers\", \"src/test/controllers\"],\n  output: \"src/api\",\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration with Module (Express)\nDESCRIPTION: This snippet configures Nestia to use a NestJS module with the Express adapter as input, allowing for the generation of an SDK based on the module's controllers. It demonstrates how to create a Nest application instance within the `input` function.  The output directory, simulation, distribution and e2e test locations are also configured.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  simulate: true,\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Defining BBS Article Interface (TypeScript)\nDESCRIPTION: This TypeScript code defines the `IBbsArticle` interface, representing the structure of a BBS article. It includes properties such as `id`, `created_at`, `updated_at`, `title`, `body`, and `thumbnail`. The interface also defines nested interfaces `ICreate` for creating new articles and `IUpdate` for updating existing articles. The `typia` library is used for validation and type safety, specifying formats like UUID and date-time.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\n/**\n * Article entity.\n *\n * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\n */\nexport interface IBbsArticle extends IBbsArticle.ICreate {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n \n  /**\n   * Creation time of the article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n \n  /**\n   * Last updated time of the article.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n}\nexport namespace IBbsArticle {\n  /**\n   * Information of the article to create.\n   */\n  export interface ICreate {\n    /**\n     * Title of the article.\n     *\n     * Representative title of the article.\n     */\n    title: string;\n \n    /**\n     * Content body.\n     *\n     * Content body of the article writtn in the markdown format.\n     */\n    body: string;\n \n    /**\n     * Thumbnail image URI.\n     *\n     * Thumbnail image URI which can represent the article.\n     *\n     * If configured as `null`, it means that no thumbnail image in the article.\n     */\n    thumbnail:\n      | null\n      | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\n  }\n \n  /**\n   * Information of the article to update.\n   *\n   * Only the filled properties will be updated.\n   */\n  export type IUpdate = Partial<ICreate>;\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia SDK Functions for BbsArticles\nDESCRIPTION: This code shows Nestia SDK functions for interacting with the `BbsArticlesController`. It defines functions `store` and `update` for making POST and PUT requests, respectively. These functions use `@nestia/fetcher` to send HTTP requests and handle responses. The functions take connection details, section, id, and input data as parameters. The functions also define input and output types, as well as metadata for request and response types.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @packageDocumentation\n * @module api.functional.bbs.articles\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\n */\n//================================================================\nimport type { IConnection, Primitive } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport type { Format } from \"typia/lib/tags/Format\";\n\nimport type { IBbsArticle } from \"../../../structures/IBbsArticle\";\n\n/**\n * Store a new article.\n *\n * @param section Section code\n * @param input Content to store\n * @returns Newly archived article\n *\n * @controller [object Object]\n * @path POST /bbs/articles/:section\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\n */\nexport async function store(\n  connection: IConnection,\n  section: string,\n  input: store.Input,\n): Promise<store.Output> {\n  return PlainFetcher.fetch(\n    {\n      ...connection,\n      headers: {\n        ...connection.headers,\n        \"Content-Type\": \"application/json\",\n      },\n    },\n    {\n      ...store.METADATA,\n      path: store.path(section),\n    } as const,\n    input,\n  );\n}\nexport namespace store {\n  export type Input = Primitive<IBbsArticle.IStore>;\n  export type Output = Primitive<IBbsArticle>;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/articles/:section\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    status: null,\n  } as const;\n\n  export const path = (section: string): string => {\n    return `/bbs/articles/${encodeURIComponent(section ?? \"null\")}`;\n  };\n}\n\n/**\n * Update an article.\n *\n * @param section Section code\n * @param id Target article ID\n * @param input Content to update\n * @returns Updated content\n *\n * @controller [object Object]\n * @path PUT /bbs/articles/:section/:id\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\n */\nexport async function update(\n  connection: IConnection,\n  section: string,\n  id: string & Format<\"uuid\">,\n  input: update.Input,\n): Promise<update.Output> {\n  return PlainFetcher.fetch(\n    {\n      ...connection,\n      headers: {\n        ...connection.headers,\n        \"Content-Type\": \"application/json\",\n      },\n    },\n    {\n      ...update.METADATA,\n      path: update.path(section, id),\n    } as const,\n    input,\n  );\n}\nexport namespace update {\n  export type Input = Primitive<IBbsArticle.IStore>;\n  export type Output = Primitive<IBbsArticle>;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:section/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    status: null,\n  } as const;\n\n  export const path = (\n    section: string,\n    id: string & Format<\"uuid\">,\n  ): string => {\n    return `/bbs/articles/${encodeURIComponent(\n      section ?? \"null\",\n    )}/${encodeURIComponent(id ?? \"null\")}`;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: INestiaConfig Interface Definition\nDESCRIPTION: This interface defines the structure for the `nestia.config.ts` file.  It specifies the available configuration options for Nestia, including input (controller sources), output (SDK generation directory), swagger (Swagger JSON generation), distribute (SDK distribution directory), simulate (simulation mode), e2e (E2E tests generation directory), propagate, clone, primitive, assert, and json options. It provides detailed descriptions of each property and their usage.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { INestApplication } from \"@nestjs/common\";\nimport { OpenApi } from \"@samchon/openapi\";\n\n/**\n * Definition for the `nestia.config.ts` file.\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport interface INestiaConfig {\n  /**\n   * Accessor of controller classes.\n   *\n   * You can specify it within two ways\n   *\n   *   - Asynchronous function returning `INestApplication` instance\n   *   - Specify the path or directory of controller class files\n   */\n  input:\n    | (() => Promise<INestApplication>)\n    | INestiaConfig.IInput\n    | string[]\n    | string;\n\n  /**\n   * Output directory that SDK would be placed in.\n   *\n   * If not configured, you can't build the SDK library.\n   */\n  output?: string;\n\n  /**\n   * Building `swagger.json` is also possible.\n   *\n   * If not specified, you can't build the `swagger.json`.\n   */\n  swagger?: INestiaConfig.ISwaggerConfig;\n\n  /**\n   * Target directory that SDK distribution files would be placed in.\n   *\n   * If you configure this property and runs `npx nestia sdk` command,\n   * distribution environments for the SDK library would be generated.\n   *\n   * After the SDK library generation, move to the `distribute` directory,\n   * and runs `npm publish` command, then you can share SDK library with\n   * other client (frontend) developers.\n   *\n   * Recommend to use `\"packages/api\"` value.\n   */\n  distribute?: string;\n\n  /**\n   * Allow simulation mode.\n   *\n   * If you configure this property to be `true`, the SDK library would be contain\n   * simulation mode. In the simulation mode, the SDK library would not communicate\n   * with the real backend server, but just returns random mock-up data\n   * with requestion data validation.\n   *\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\n   * function.\n   *\n   * @default false\n   */\n  simulate?: boolean;\n\n  /**\n   * Target directory that e2e test functions would be placed in.\n   *\n   * If you configure this property and runs `npx nestia e2e` command,\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\n   * generates e2e test functions for every API endpoints.\n   *\n   * If not configured, you can't run `npx nestia e2e` command.\n   */\n  e2e?: string;\n\n  /**\n   * Whether to use propagation mode or not.\n   *\n   * If being configured, interaction functions of the SDK library would\n   * perform the propagation mode. The propagation mode means that never\n   * throwing exception even when status code is not 200 (or 201), but just\n   * returning the {@link IPropagation} typed instance, which can specify its body\n   * type through discriminated union determined by status code.\n   *\n   * @default false\n   */\n  propagate?: boolean;\n\n  /**\n   * Whether to clone DTO structures or not.\n   *\n   * If being configured, all of DTOs used in the backend server would be cloned\n   * into the `structures` directory, and the SDK library would be refer to the\n   * cloned DTOs instead of the original.\n   *\n   * @default false\n   */\n  clone?: boolean;\n\n  /**\n   * Whether to wrap DTO by primitive type.\n   *\n   * If you don't configure this property as `false`, all of DTOs in the\n   * SDK library would be automatically wrapped by {@link Primitive} type.\n   *\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\n   * all of methods in the DTO type would be automatically erased. Also, if\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\n   * converted to return type of the `toJSON()` method.\n   *\n   * @default true\n   */\n  primitive?: boolean;\n\n  /**\n   * Whether to assert parameter types or not.\n   *\n   * If you configure this property to be `true`, all of the function\n   * parameters of SDK library would be checked through\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\n   *\n   * This option would make your SDK library compilation time a little bit slower,\n   * but would enahcne the type safety even in the runtime level.\n   *\n   * @default false\n   */\n  assert?: boolean;\n\n  /**\n   * Whether to optimize JSON string conversion 10x faster or not.\n   *\n   * If you configure this property to be `true`, the SDK library would utilize the\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\n   * to boost up JSON serialization speed and ensure type safety.\n   *\n   * This option would make your SDK library compilation time a little bit slower,\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\n   * safety even in the runtime level.\n   *\n   * @default false\n   */\n  json?: boolean;\n}\nexport namespace INestiaConfig {\n  /**\n   * List of files or directories to include or exclude to specifying the NestJS\n   * controllers.\n   */\n  export interface IInput {\n    /**\n     * List of files or directories containing the NestJS controller classes.\n     */\n    include: string[];\n\n    /**\n     * List of files or directories to be excluded.\n     */\n    exclude?: string[];\n  }\n\n  /**\n   * Building `swagger.json` is also possible.\n   */\n  export interface ISwaggerConfig {\n    /**\n     * Output path of the `swagger.json`.\n     *\n     * If you've configured only directory, the file name would be the `swagger.json`.\n     * Otherwise you've configured the full path with file name and extension, the\n     * `swagger.json` file would be renamed to it.\n     */\n    output: string;\n\n    /**\n     * OpenAPI version.\n     *\n     * If you configure this property to be `2.0` or `3.0`, the newly generated\n     * `swagger.json` file would follow the specified OpenAPI version. The newly\n     * generated `swagger.json` file would be downgraded from the OpenAPI v3.1\n     * specification by {@link OpenApi.downgrade} method.\n     *\n     * @default 3.1\n     */\n    openapi?: \"2.0\" | \"3.0\" | \"3.1\";\n\n    /**\n     * API information.\n     *\n     * If omitted, `package.json` content would be used instead.\n     */\n    info?: Partial<OpenApi.IDocument.IInfo>;\n\n    /**\n     * List of server addresses.\n     */\n    servers?: OpenApi.IServer[];\n\n    /**\n     * Security schemes.\n     *\n     * When generating `swagger.json` file through `nestia`, if your controllers or\n     * theirs methods have a security key which is not enrolled in here property,\n     * it would be an error.\n     */\n    security?: Record<string, OpenApi.SecurityScheme>;\n\n    /**\n     * List of tag names with description.\n     *\n     * It is possible to omit this property or skip some tag name even if\n     * the tag name is used in the API routes. In that case, the tag name\n     * would be used without description.\n     *\n     * Of course, if you've written a comment like `@tag {name} {description}`,\n     * you can entirely replace this property specification.\n     */\n    tags?: OpenApi.IDocument.ITag[];\n\n    /**\n     * Decompose query DTO.\n     *\n     * If you configure this property to be `true`, the query DTO would be decomposed\n     * into individual query parameters per each property. Otherwise you set it to be\n     * `false`, the query DTO would be one object type which contains all of query\n     * parameters.\n     *\n     * @default false\n     */\n    decompose?: boolean;\n\n    /**\n     * Operation ID generator.\n     *\n     * @param props Properties of the API endpoint.\n     * @returns Operation ID.\n     */\n    operationId?(props: {\n      class: string;\n      function: string;\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n      path: string;\n    }): string;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: WebSocketRoute Decorator Definition\nDESCRIPTION: Defines the WebSocketRoute decorator and its associated parameter decorators like Acceptor, Driver, Header, Param, and Query from the @nestia/core library.  These decorators are essential for defining WebSocket endpoints and extracting data from incoming requests. The WebSocketRoute function itself takes an optional path argument specifying the route.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function WebSocketRoute(path?: string): MethodDecorator;\nexport namespace WebSocketRoute {\n  export function Acceptor(): ParameterDecorator;\n  export function Driver(): ParameterDecorator;\n  export function Header(): ParameterDecorator;\n  export function Param(field: string): ParameterDecorator;\n  export function Query(): ParameterDecorator;\n}\n```\n\n----------------------------------------\n\nTITLE: Attachment File Stringification (TypeScript)\nDESCRIPTION: This snippet stringifies an IAttachmentFile object into a JSON string.  It uses the TypedRoute.Post.string function from core_1 to ensure proper string escaping.  Null values for 'name' and 'extension' are converted to the string 'null' in the JSON output. It handles optional name and extension properties.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedBody.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst $so1 = (input) =>\n            `{\"name\":${\n              null !== input.name ? $string(input.name) : \"null\"\n            },\"extension\":${\n              null !== input.extension ? $string(input.extension) : \"null\"\n            },\"url\":${$string(input.url)}}`;\n```\n\n----------------------------------------\n\nTITLE: E2E Test Program Main Function - TypeScript\nDESCRIPTION: This TypeScript code defines the main function for an E2E test program using @nestia/e2e. It configures the testing environment, starts the backend server, connects to the server using the generated SDK, and dynamically executes test functions located in the `test/features` directory. The results are then aggregated and reported, indicating success or failure of each test.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/development.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DynamicExecutor } from \"@nestia/e2e\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\n\nimport { MyBackend } from \"../src/MyBackend\";\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { ArgumentParser } from \"./helpers/ArgumentParser\";\n\ninterface IOptions {\n  include?: string[];\n  exclude?: string[];\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<IOptions>(async (command, _prompt, action) => {\n    // command.option(\"--mode <string>\", \"target mode\");\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\n    command.option(\"--include <string...>\", \"include feature files\");\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\n\n    return action(async (options) => {\n      // if (typeof options.reset === \"string\")\n      //     options.reset = options.reset === \"true\";\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\n      //     \"LOCAL\",\n      //     \"DEV\",\n      //     \"REAL\",\n      // ]);\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\n      return options as IOptions;\n    });\n  });\n\nasync function main(): Promise<void> {\n  // CONFIGURATIONS\n  const options: IOptions = await getOptions();\n  MyGlobal.testing = true;\n\n  // BACKEND SERVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  //----\n  // CLIENT CONNECTOR\n  //----\n  // DO TEST\n  const connection: api.IConnection = {\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n  };\n  const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\n    prefix: \"test\",\n    parameters: () => [{ ...connection }],\n    filter: (func) =>\n      (!options.include?.length ||\n        (options.include ?? []).some((str) => func.includes(str))) &&\n      (!options.exclude?.length ||\n        (options.exclude ?? []).every((str) => !func.includes(str))),\n  })(__dirname + \"/features\");\n\n  await backend.close();\n\n  const failures: DynamicExecutor.IReport.IExecution[] =\n    report.executions.filter((exec) => exec.error !== null);\n  if (failures.length === 0) {\n    console.log(\"Success\");\n    console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n  } else {\n    for (const f of failures) console.log(f.error);\n    process.exit(-1);\n  }\n\n  console.log(\n    [\n      `All: #${report.executions.length}`,\n      `Success: #${report.executions.length - failures.length}`,\n      `Failed: #${failures.length}`,\n    ].join(\"\\n\"),\n  );\n}\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n```\n\n----------------------------------------\n\nTITLE: TypedHeaders Decorator Definition (TypeScript)\nDESCRIPTION: Defines the `@TypedHeaders()` decorator function for type-safe request header parsing in Nestia. This decorator utilizes `typia.assert<T>()` to validate header values and throws a 400 error if validation fails.  It provides a type-safe alternative to NestJS's `@Headers()` decorator.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedHeaders.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport function TypedHeaders(): ParameterDecorator;\n```\n\n----------------------------------------\n\nTITLE: TypedQuery.Body() Decorator Definition (TypeScript)\nDESCRIPTION: Defines the TypedQuery.Body() decorator within the @nestia/core library. This decorator is used to parse request bodies in application/x-www-form-urlencoded format.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace TypedQuery {\n  export function Body(): ParameterDecorator;\n}\n```\n\n----------------------------------------\n\nTITLE: Client Application Test with Nestia\nDESCRIPTION: Tests the WebSocket API using the generated SDK. It imports the API client, defines a listener, starts the calculator, and validates the results of various operations. The test verifies that the API calls return the expected values and that the listener receives the correct events. It depends on `@nestia/e2e` and `@samchon/calculator-api`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TestValidator } from \"@nestia/e2e\";\nimport api from \"@samchon/calculator-api/lib/index\";\nimport { IListener } from \"@samchon/calculator-api/lib/structures/IListener\";\n\nexport const test_api_calculate_start = async (\n  connection: api.IConnection,\n): Promise<void> => {\n  const stack: IListener.IEvent[] = [];\n  const listener: IListener = {\n    on: (event) => stack.push(event),\n  };\n  const { connector, driver } = await api.functional.calculate.start(\n    connection,\n    listener,\n  );\n  try {\n    TestValidator.equals(\"plus\")(await driver.plus(4, 2))(6);\n    TestValidator.equals(\"minus\")(await driver.minus(4, 2))(2);\n    TestValidator.equals(\"multiply\")(await driver.multiply(4, 2))(8);\n    TestValidator.equals(\"divide\")(await driver.divide(4, 2))(2);\n    TestValidator.equals(\"events\")(stack)([\n      { type: \"plus\", x: 4, y: 2, z: 6 },\n      { type: \"minus\", x: 4, y: 2, z: 2 },\n      { type: \"multiply\", x: 4, y: 2, z: 8 },\n      { type: \"divide\", x: 4, y: 2, z: 2 },\n    ]);\n  } catch (exp) {\n    throw exp;\n  } finally {\n    await connector.close();\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Implement BbsArticlesController Typescript\nDESCRIPTION: Implements the BbsArticlesController using NestJS and Nestia. It defines a POST route for creating articles, validates the input using TypedBody, and returns a mocked IBbsArticle object. Dependencies include @nestia/core, @nestjs/common, and typia.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedBody.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { tags } from \"typia\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  @TypedRoute.Post()\n  public async store(\n    @TypedBody() input: IBbsArticle.IStore,\n  ): Promise<IBbsArticle> {\n    return {\n      ...input,\n      id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\n      created_at: \"2023-04-23T12:04:54.168Z\",\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating BBS Article Test (TypeScript)\nDESCRIPTION: This test function `test_api_bbs_article_update` tests updating an existing BBS article. It first creates an article, then updates it with the correct password using `api.functional.bbs.articles.update`. Finally, it attempts to update the article with an incorrect password, verifying that an error is thrown using `TestValidator.error`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/development.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { v4 } from \"uuid\";\n\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\n\nexport async function test_api_bbs_article_update(\n  connection: api.IConnection,\n): Promise<void> {\n  // STORE A NEW ARTICLE\n  const password: string = v4();\n  const article: IBbsArticle = await api.functional.bbs.articles.create(\n    connection,\n    \"general\",\n    {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(3)(),\n      body: RandomGenerator.content(8)()(),\n      format: \"txt\",\n      files: [\n        {\n          name: \"logo\",\n          extension: \"png\",\n          url: \"https://somewhere.com/logo.png\",\n        },\n      ],\n      password,\n    },\n  );\n\n  // UPDATE WITH EXACT PASSWORD\n  const content: IBbsArticle.ISnapshot =\n    await api.functional.bbs.articles.update(\n      connection,\n      article.section,\n      article.id,\n      {\n        title: RandomGenerator.paragraph(3)(),\n        body: RandomGenerator.content(8)()(),\n        format: \"txt\",\n        files: [],\n        password,\n      },\n    );\n  article.snapshots.push(content);\n\n  // TRY UPDATE WITH WRONG PASSWORD\n  await TestValidator.error(\"update with wrong password\")(() =>\n    api.functional.bbs.articles.update(\n      connection,\n      article.section,\n      article.id,\n      {\n        title: RandomGenerator.paragraph(5)(),\n        body: RandomGenerator.content(8)()(),\n        format: \"txt\",\n        files: [],\n        password: v4(),\n      },\n    ),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: BbsArticlesController with @TypedQuery (TypeScript)\nDESCRIPTION: Implements a NestJS controller with a route that uses @TypedQuery to parse and validate the query parameters according to the IPage.IRequest interface.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedQuery, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { tags } from \"typia\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\nimport { IPage } from \"./IPage\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  @TypedRoute.Get()\n  public async index(\n    @TypedQuery() query: IPage.IRequest\n  ): Promise<IPage<IBbsArticle.ISummary>> {\n    return {\n      pagination: {\n        current: query.page ?? 1,\n        limit: query.limit ?? 100,\n        records: 0,\n        pages: 0,\n      },\n      data: [],\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration in Typescript\nDESCRIPTION: This TypeScript snippet demonstrates the configuration file (`nestia.config.ts`) for Nestia.  It defines the `input` function, which creates a NestJS application instance, and specifies the `output` directory for the generated SDK and the `distribute` directory for packaging.  The configuration leverages `@nestia/sdk`, `NestFactory`, and a custom `YourModule`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/index.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  distribute: \"packages/api\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Setting up Nestia and Webpack with pnpm (Bash)\nDESCRIPTION: This set of commands installs nestia, ts-loader, webpack, webpack-cli, and webpack-node-externals as dev dependencies using pnpm.  It is necessary to manually configure webpack when bundling the NestJS project.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# SETUP NESTIA\nnpx nestia setup --manager pnpm\n\n# INSTALL TS-LOADER & WEBPACK\npnpm install --save-dev ts-loader\npnpm install --save-dev webpack webpack-cli webpack-node-externals\n```\n\n----------------------------------------\n\nTITLE: Configuring Nestia with Typia in tsconfig.json\nDESCRIPTION: This code snippet shows how to configure the Nestia core plugin within the `tsconfig.json` file. It demonstrates how to set up the transform for typia and nestia/core, enable validation, and optionally configure settings for LLM integration with properties like `model` and `strict`. The `validate` property lets you change the validation function used by `@TypedBody()`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedBody.mdx#_snippet_10\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"plugins\": [\n      { \"transform\": \"typia/lib/transform\" },\n      {\n        \"transform\": \"@nestia/core/lib/transform\",\n        \"validate\": \"validate\",\n        // \"llm\": {\n        //   \"model\": \"chatgpt\",\n        //   \"strict\": true,\n        // },\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: INestiaConfig Swagger Configuration Interface\nDESCRIPTION: This snippet shows the interface definition for the swagger configuration within the INestiaConfig. It includes properties for specifying the output path, OpenAPI version, beautification options, API information, server addresses, security schemes, tags, query parameter decomposition, and operation ID generation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace INestiaConfig {\n  /**\n   * Building `swagger.json` is also possible.\n   */\n  export interface ISwaggerConfig {\n    /**\n     * Output path of the `swagger.json`.\n     *\n     * If you've configured only directory, the file name would be the `swagger.json`.\n     * Otherwise you've configured the full path with file name and extension, the\n     * `swagger.json` file would be renamed to it.\n     */\n    output: string;\n\n    /**\n     * OpenAPI version.\n     *\n     * If you configure this property to be `2.0` or `3.0`, the newly generated\n     * `swagger.json` file would follow the specified OpenAPI version. The newly\n     * generated `swagger.json` file would be downgraded from the OpenAPI v3.1\n     * specification by {@link OpenApi.downgrade} method.\n     *\n     * @default 3.1\n     */\n    openapi?: \"2.0\" | \"3.0\" | \"3.1\";\n\n    /**\n     * Whether to beautify JSON content or not.\n     *\n     * If you configure this property to be `true`, the `swagger.json` file would\n     * be beautified with indentation (2 spaces) and line breaks. If you configure\n     * numeric value instead, the indentation would be specified by the number.\n     *\n     * @default false\n     */\n    beautify?: boolean | number;\n\n    /**\n     * API information.\n     *\n     * If omitted, `package.json` content would be used instead.\n     */\n    info?: Partial<OpenApi.IDocument.IInfo>;\n\n    /**\n     * List of server addresses.\n     */\n    servers?: OpenApi.IServer[];\n\n    /**\n     * Security schemes.\n     *\n     * When generating `swagger.json` file through `nestia`, if your controllers or\n     * theirs methods have a security key which is not enrolled in here property,\n     * it would be an error.\n     */\n    security?: Record<string, OpenApi.ISecurityScheme>;\n\n    /**\n     * List of tag names with description.\n     *\n     * It is possible to omit this property or skip some tag name even if\n     * the tag name is used in the API routes. In that case, the tag name\n     * would be used without description.\n     *\n     * Of course, if you've written a comment like `@tag {name} {description}`,\n     * you can entirely replace this property specification.\n     */\n    tags?: OpenApi.IDocument.ITag[];\n\n    /**\n     * Decompose query DTO.\n     *\n     * If you configure this property to be `true`, the query DTO would be decomposed\n     * into individual query parameters per each property. Otherwise you set it to be\n     * `false`, the query DTO would be one object type which contains all of query\n     * parameters.\n     *\n     * @default false\n     */\n    decompose?: boolean;\n\n    /**\n     * Operation ID generator.\n     *\n     * @param props Properties of the API endpoint.\n     * @returns Operation ID.\n     */\n    operationId?(props: {\n      class: string;\n      function: string;\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n      path: string;\n    }): string;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration with Module (Fastify)\nDESCRIPTION: This snippet configures Nestia to use a NestJS module with the Fastify adapter as input, which changes the way the Nest application is created. This allows generation of an SDK using the Fastify adapter for handling HTTP requests.  The output directory, simulation, distribution and e2e test locations are also configured.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\nimport { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule, new FastifyAdpator());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  simulate: true,\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: INestiaConfig Interface\nDESCRIPTION: This snippet defines the INestiaConfig interface, which is used to configure Nestia. It includes options for swagger generation, input source (NestJS application or controller files), output directory, e2e testing, simulation mode and various flags like propagation, cloning, primitive wrapping, parameter assertion and JSON stringify optimization. The interface offers detailed control over Nestia's behavior.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { INestApplication } from \"@nestjs/common\";\nimport type { OpenApi } from \"@samchon/openapi\";\n\n/**\n * Definition for the `nestia.config.ts` file.\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport interface INestiaConfig {\n  /**\n   * Building `swagger.json` is also possible.\n   *\n   * If not specified, you can't build the `swagger.json`.\n   */\n  swagger?: INestiaConfig.ISwaggerConfig;\n\n  /**\n   * Accessor of controller classes.\n   *\n   * You can specify it within two ways\n   *\n   *   - Asynchronous function returning `INestApplication` instance\n   *   - Specify the path or directory of controller class files\n   */\n  input:\n    | (() => Promise<INestApplication>)\n    | INestiaConfig.IInput\n    | string[]\n    | string;\n\n  /**\n   * Output directory that SDK would be placed in.\n   *\n   * If not configured, you can't build the SDK library.\n   */\n  output?: string;\n\n  /**\n   * Target directory that SDK distribution files would be placed in.\n   *\n   * If you configure this property and runs `npx nestia sdk` command,\n   * distribution environments for the SDK library would be generated.\n   *\n   * After the SDK library generation, move to the `distribute` directory,\n   * and runs `npm publish` command, then you can share SDK library with\n   * other client (frontend) developers.\n   *\n   * Recommend to use `\"packages/api\"` value.\n   */\n  distribute?: string;\n\n  /**\n   * Allow simulation mode.\n   *\n   * If you configure this property to be `true`, the SDK library would be contain\n   * simulation mode. In the simulation mode, the SDK library would not communicate\n   * with the real backend server, but just returns random mock-up data\n   * with requestion data validation.\n   *\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\n   * function.\n   *\n   * @default false\n   */\n  simulate?: boolean;\n\n  /**\n   * Target directory that e2e test functions would be placed in.\n   *\n   * If you configure this property and runs `npx nestia e2e` command,\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\n   * generates e2e test functions for every API endpoints.\n   *\n   * If not configured, you can't run `npx nestia e2e` command.\n   */\n  e2e?: string;\n\n  /**\n   * Whether to use propagation mode or not.\n   *\n   * If being configured, interaction functions of the SDK library would\n   * perform the propagation mode. The propagation mode means that never\n   * throwing exception even when status code is not 200 (or 201), but just\n   * returning the {@link IPropagation} typed instance, which can specify its body\n   * type through discriminated union determined by status code.\n   *\n   * @default false\n   */\n  propagate?: boolean;\n\n  /**\n   * Whether to clone DTO structures or not.\n   *\n   * If being configured, all of DTOs used in the backend server would be cloned\n   * into the `structures` directory, and the SDK library would be refer to the\n   * cloned DTOs instead of the original.\n   *\n   * @default false\n   */\n  clone?: boolean;\n\n  /**\n   * Whether to wrap DTO by primitive type.\n   *\n   * If you don't configure this property as `false`, all of DTOs in the\n   * SDK library would be automatically wrapped by {@link Primitive} type.\n   *\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\n   * all of methods in the DTO type would be automatically erased. Also, if\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\n   * converted to return type of the `toJSON()` method.\n   *\n   * @default true\n   */\n  primitive?: boolean;\n\n  /**\n   * Whether to assert parameter types or not.\n   *\n   * If you configure this property to be `true`, all of the function\n   * parameters of SDK library would be checked through\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\n   *\n   * This option would make your SDK library compilation time a little bit slower,\n   * but would enahcne the type safety even in the runtime level.\n   *\n   * @default false\n   */\n  assert?: boolean;\n\n  /**\n   * Whether to optimize JSON string conversion 10x faster or not.\n   *\n   * If you configure this property to be `true`, the SDK library would utilize the\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\n   * to boost up JSON serialization speed and ensure type safety.\n   *\n   * This option would make your SDK library compilation time a little bit slower,\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\n   * safety even in the runtime level.\n   *\n   * @default false\n   */\n  json?: boolean;\n}\nexport namespace INestiaConfig {\n  /**\n   * List of files or directories to include or exclude to specifying the NestJS\n   * controllers.\n   */\n  export interface IInput {\n    /**\n     * List of files or directories containing the NestJS controller classes.\n     */\n    include: string[];\n\n    /**\n     * List of files or directories to be excluded.\n     */\n    exclude?: string[];\n  }\n\n  /**\n   * Building `swagger.json` is also possible.\n   */\n  export interface ISwaggerConfig {\n    /**\n     * OpenAPI version.\n     *\n     * If you configure this property to be `2.0` or `3.0`, the newly generated\n     * `swagger.json` file would follow the specified OpenAPI version. The newly\n     * generated `swagger.json` file would be downgraded from the OpenAPI v3.1\n     * specification by {@link OpenApi.downgrade} method.\n     *\n     * @default 3.1\n     */\n    openapi?: \"2.0\" | \"3.0\" | \"3.1\";\n    \n    /**\n     * Output path of the `swagger.json`.\n     *\n     * If you've configured only directory, the file name would be the `swagger.json`.\n     * Otherwise you've configured the full path with file name and extension, the\n     * `swagger.json` file would be renamed to it.\n     */\n    output: string;\n\n    /**\n     * Whether to beautify JSON content or not.\n     *\n     * If you configure this property to be `true`, the `swagger.json` file would\n     * be beautified with indentation (2 spaces) and line breaks. If you configure\n     * numeric value instead, the indentation would be specified by the number.\n     *\n     * @default false\n     */\n    beautify?: boolean | number;\n\n    /**\n     * API information.\n     *\n     * If omitted, `package.json` content would be used instead.\n     */\n    info?: Partial<OpenApi.IDocument.IInfo>;\n\n    /**\n     * List of server addresses.\n     */\n    servers?: OpenApi.IServer[];\n\n    /**\n     * Security schemes.\n     *\n     * When generating `swagger.json` file through `nestia`, if your controllers or\n     * theirs methods have a security key which is not enrolled in here property,\n     * it would be an error.\n     */\n    security?: Record<string, OpenApi.ISecurityScheme>;\n\n    /**\n     * List of tag names with description.\n     *\n     * It is possible to omit this property or skip some tag name even if\n     * the tag name is used in the API routes. In that case, the tag name\n     * would be used without description.\n     *\n     * Of course, if you've written a comment like `@tag {name} {description}`,\n     * you can entirely replace this property specification.\n     */\n    tags?: OpenApi.IDocument.ITag[];\n\n    /**\n     * Decompose query DTO.\n     *\n     * If you configure this property to be `true`, the query DTO would be decomposed\n     * into individual query parameters per each property. Otherwise you set it to be\n     * `false`, the query DTO would be one object type which contains all of query\n     * parameters.\n     *\n     * @default false\n     */\n    decompose?: boolean;\n\n    /**\n     * Operation ID generator.\n     *\n     * @param props Properties of the API endpoint.\n     * @returns Operation ID.\n     */\n    operationId?(props: {\n      class: string;\n      function: string;\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n      path: string;\n    }): string;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TypedException Decorator\nDESCRIPTION: Defines the TypedException decorator for documenting HTTP exceptions in Nestia controllers. It accepts a status code and an optional description, or an object containing status, description, and examples. This enhances Swagger documentation and SDK function generation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedException.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function TypedException<T extends object>(\n  status: number | \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\",\n  description?: string,\n): MethodDecorator;\nexport function TypedException<T extends object>(props: {\n  status:  number | \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\";\n  description?: string;\n  example?: T;\n  examples?: Record<string, T>;\n}): MethodDecorator;\n```\n\n----------------------------------------\n\nTITLE: Custom Validation Error Logging (TypeScript)\nDESCRIPTION: Shows how to set a custom logger function to handle validation errors encountered by `TypedRoute`. This allows developers to customize how validation errors are logged and reported, useful for debugging and error monitoring.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedRoute.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nTypedRoute.setValidateErrorLogger((err: TypedRoute.IValidateErrorLog) => {\n  // you can customize the validation error logging\n  console.error(err);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining IBbsArticle Interface - TypeScript\nDESCRIPTION: Defines the interface IBbsArticle and IAttachmentFile using TypeScript and typia for data validation. It specifies the structure and format of the article data, including id, created_at, title, body, and attachments. The interface uses typia's tags to enforce constraints such as string length, format, and URL validation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedRoute.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\nexport interface IBbsArticle extends IBbsArticle.IStore {\n  id: string & tags.Format<\"uuid\">;\n  created_at: string & tags.Format<\"date-time\">;\n}\nexport namespace IBbsArticle {\n  export interface IStore {\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\n    body: string;\n    files: IAttachmentFile[];\n  }\n}\n\nexport interface IAttachmentFile {\n  name: null | (string & tags.MinLength<1> & tags.MaxLength<255>);\n  extension: null | (string & tags.MinLength<1> & tags.MaxLength<8>);\n  url: string & tags.Format<\"url\">;\n}\n```\n\n----------------------------------------\n\nTITLE: Package Configuration\nDESCRIPTION: This JSON configuration file defines the metadata and scripts for the generated SDK package.  It includes the package name, version, description, entry points, scripts for building and deploying, repository information, author, license, dependencies, and files to include in the package.  Line 2 is highlighted.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/distribute.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"@ORGANIZATION/PROJECT-api\",\n  \"version\": \"0.1.0\",\n  \"description\": \"SDK library generated by Nestia\",\n  \"main\": \"lib/index.js\",\n  \"typings\": \"lib/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"npm run build:sdk && npm run compile\",\n    \"build:sdk\": \"rimraf ../../src/api/functional && cd ../.. && npx nestia sdk && cd packages/api\",\n    \"compile\": \"rimraf lib && tsc\",\n    \"deploy\": \"npm run build && npm publish\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia\"\n  },\n  \"author\": \"Jeongho Nam\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia/issues\"\n  },\n  \"homepage\": \"https://nestia.io\",\n  \"devDependencies\": {\n    \"rimraf\": \"^5.0.0\",\n    \"typescript\": \"^5.4.2\",\n    \"ts-patch\": \"^3.1.0\"\n  },\n  \"dependencies\": {\n    \"@nestia/fetcher\": \"^4.2.0\",\n    \"typia\": \"^8.0.0\"\n  },\n  \"files\": [\n    \"lib\",\n    \"package.json\",\n    \"README.md\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Config with NestJS App Instance\nDESCRIPTION: This configuration creates a NestJS application instance using `NestFactory.create` and returns it as the input for Nestia. This allows Nestia to analyze the application and generate API documentation. The `YourModule` needs to be defined in your project.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Define IAttachmentFile interface Typescript\nDESCRIPTION: Defines the IAttachmentFile interface for representing attachment files, including name, extension, and URL properties. It leverages typia for data validation, specifically for string length and URL format.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedBody.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\nexport interface IAttachmentFile {\n  name: null | (string & tags.MinLength<1> & tags.MaxLength<255>);\n  extension: null | (string & tags.MinLength<1> & tags.MaxLength<8>);\n  url: string & tags.Format<\"url\">;\n}\n```\n\n----------------------------------------\n\nTITLE: Modern E2E Test with @nestia/sdk\nDESCRIPTION: Presents a modern E2E test function using the `@nestia/sdk` generated SDK library. This approach allows leveraging TypeScript type hints for API calls, making E2E tests safer and easier to develop.  The example tests the creation and retrieval of a BBS article using the SDK.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/why.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport BbsApi from \"@samchon/bbs-api\";\nimport { IBbsArticle } from \"@samchon/bbs-api/lib/structures/bbs/IBbsArticle\";\n\nexport const test_provider_bbs_article_create = async (\n  connection: BbsApi.IConnection\n): Promise<void> => {\n  // Unit test functions can't validate \n  // the backend server's actual behavior.\n  const article: IBbsArticle = await BbsApi.functional.bbs.articles.create(\n    connection,\n    {\n      writer: \"someone\",\n      password: \"1234\",\n      title: \"title\",\n      body: \"content\",\n      format: \"md\",\n      files: [],\n    },\n  );\n  typia.assert(article);\n\n  // This is the reason why I've adopted the e2e test paradigm\n  const read: IBbsArticle = await BbsApi.functional.bbs.articles.at(\n    connection,\n    article.id,\n  );\n  typia.assert(read);\n  TestValidator.equals(\"written\")(article)(read);\n};\n```\n\n----------------------------------------\n\nTITLE: Update Article Function (Nestia SDK)\nDESCRIPTION: This code snippet presents an auto-generated function (`update`) for updating an article, likely generated by Nestia. It takes a connection object, section, ID, and input data. It uses `PlainFetcher` to make the actual API call if simulation is disabled; otherwise, it simulates the API call with `NestiaSimulator` and `typia.random`. The function also includes metadata such as HTTP method, path, and request/response content types.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Update an article.\n *\n * @param section Section code\n * @param id Target article ID\n * @param input Content to update\n * @returns Updated content\n *\n * @controller BbsArticlesController.update()\n * @path PUT /bbs/:section/articles/:id\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\n */\nexport async function update(\n  connection: IConnection,\n  section: string,\n  id: string & Format<\"uuid\">,\n  input: update.Input,\n): Promise<update.Output> {\n  return !!connection.simulate\n    ? update.simulate(connection, section, id, input)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...update.METADATA,\n          path: update.path(section, id),\n        } as const,\n        input,\n      );\n}\nexport namespace update {\n  export type Input = Primitive<IBbsArticle.IStore>;\n  export type Output = Primitive<IBbsArticle>;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:section/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    status: null,\n  } as const;\n\n  export const path = (\n    section: string,\n    id: string & Format<\"uuid\">,\n  ): string => {\n    return `/bbs/${encodeURIComponent(\n      section ?? \"null\",\n    )}/articles/${encodeURIComponent(id ?? \"null\")}`;\n  };\n\n  export const random = (g?: Partial<typia.IRandomGenerator>): Output =>\n    typia.random<Output>(g);\n\n  export const simulate = async (\n    connection: IConnection,\n    section: string,\n    id: string & Format<\"uuid\">,\n    input: update.Input,\n  ): Promise<Output> => {\n    const assert = NestiaSimulator.assert({\n      method: METHOD,\n      host: connection.host,\n      path: path(section, id),\n    });\n    assert.param(\"section\")(() => typia.assert(section));\n    assert.param(\"id\")(() => typia.assert(id));\n    assert.body(() => typia.assert(input));\n    return random(\n      typeof connection.simulate === \"object\" && connection.simulate !== null\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmark Main Program with DynamicBenchmarker\nDESCRIPTION: Defines the main benchmark program using DynamicBenchmarker from @nestia/benchmark.  It configures and runs the benchmark, aggregating results and generating a markdown report. It uses command-line arguments or prompts for configuration, sets up a backend server, and manages progress updates. Dependencies include cli-progress, fs, os, tstl, and project-specific modules.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/benchmark.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DynamicBenchmarker } from \"@nestia/benchmark\";\nimport cliProgress from \"cli-progress\";\nimport fs from \"fs\";\nimport os from \"os\";\nimport { IPointer } from \"tstl\";\n\nimport { MyBackend } from \"../../src/MyBackend\";\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\nimport { MyGlobal } from \"../../src/MyGlobal\";\nimport { ArgumentParser } from \"../helpers/ArgumentParser\";\n\ninterface IOptions {\n  include?: string[];\n  exclude?: string[];\n  count: number;\n  threads: number;\n  simultaneous: number;\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<IOptions>(async (command, prompt, action) => {\n    // command.option(\"--mode <string>\", \"target mode\");\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\n    command.option(\"--include <string...>\", \"include feature files\");\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\n    command.option(\"--count <number>\", \"number of requests to make\");\n    command.option(\"--threads <number>\", \"number of threads to use\");\n    command.option(\n      \"--simultaneous <number>\",\n      \"number of simultaneous requests to make\",\n    );\n    return action(async (options) => {\n      // if (typeof options.reset === \"string\")\n      //     options.reset = options.reset === \"true\";\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\n      //     \"LOCAL\",\n      //     \"DEV\",\n      //     \"REAL\",\n      // ]);\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\n      options.count = Number(\n        options.count ??\n          (await prompt.number(\"count\")(\"Number of requests to make\")),\n      );\n      options.threads = Number(\n        options.threads ??\n          (await prompt.number(\"threads\")(\"Number of threads to use\")),\n      );\n      options.simultaneous = Number(\n        options.simultaneous ??\n          (await prompt.number(\"simultaneous\")(\n            \"Number of simultaneous requests to make\",\n          )),\n      );\n      return options as IOptions;\n    });\n  });\n\nconst main = async (): Promise<void> => {\n  // CONFIGURATIONS\n  const options: IOptions = await getOptions();\n  MyGlobal.testing = true;\n\n  // BACKEND SERVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // DO BENCHMARK\n  const prev: IPointer<number> = { value: 0 };\n  const bar: cliProgress.SingleBar = new cliProgress.SingleBar(\n    {},\n    cliProgress.Presets.shades_classic,\n  );\n  bar.start(options.count, 0);\n\n  const report: DynamicBenchmarker.IReport = await DynamicBenchmarker.master({\n    servant: `${__dirname}/servant.js`,\n    count: options.count,\n    threads: options.threads,\n    simultaneous: options.simultaneous,\n    filter: (func) =>\n      (!options.include?.length ||\n        (options.include ?? []).some((str) => func.includes(str))) &&\n      (!options.exclude?.length ||\n        (options.exclude ?? []).every((str) => !func.includes(str))),\n    progress: (value: number) => {\n      if (value >= 100 + prev.value) {\n        bar.update(value);\n        prev.value = value;\n      }\n    },\n    stdio: \"ignore\",\n  });\n  bar.stop();\n\n  // DOCUMENTATION\n  try {\n    await fs.promises.mkdir(`${MyConfiguration.ROOT}/docs/benchmarks`, {\n      recursive: true,\n    });\n  } catch {}\n  await fs.promises.writeFile(\n    `${MyConfiguration.ROOT}/docs/benchmarks/${os\n      .cpus()[0]\n      .model.trim()\n      .split(\"\\\\\")\n      .join(\"\")\n      .split(\"/\")\n      .join(\"\")}.md`,\n    DynamicBenchmarker.markdown(report),\n    \"utf8\",\n  );\n\n  // CLOSE\n  await backend.close();\n};\nmain().catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n```\n\n----------------------------------------\n\nTITLE: TypedParam Definition Typescript\nDESCRIPTION: Definition of the TypedParam function in Typescript. This shows the required input parameter, the name of the path parameter.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedParam.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function TypedParam(name: string): ParameterDecorator;\n```\n\n----------------------------------------\n\nTITLE: WebSocket Application Setup\nDESCRIPTION: Shows how to upgrade a NestJS application to support WebSocket connections using WebSocketAdaptor from @nestia/core. The WebSocketAdaptor.upgrade() function is called with the NestJS application instance, enabling WebSocket routes to function correctly. It also demonstrates how to start the application and listen for incoming connections.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WebSocketAdaptor } from \"@nestia/core\";\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { CalculateModule } from \"./CalculateModule\";\n\nexport namespace CalculateBackend {\n  export const start = async (): Promise<INestApplication> => {\n    const app: INestApplication = await NestFactory.create(CalculateModule);\n    await WebSocketAdaptor.upgrade(app);\n    await app.listen(3_000, \"0.0.0.0\");\n    return app;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a WebSocket Route for Agentica Chatbot\nDESCRIPTION: This code defines a WebSocket route within a NestJS controller for the Agentica chatbot. When a client connects to the specified URL, an Agentica chatbot instance is created and associated with the WebSocket connection. The code sets up the WebSocket acceptor, creates an instance of `AgenticaRpcService`, and associates it with the acceptor.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/chat.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AgenticaRpcService, IAgenticaRpcListener } from \"@agentica/rpc\";\nimport { WebSocketRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { WebSocketAcceptor } from \"tgrid\";\n\n@Controller(\"chat\")\nexport class ChatController {\n  @WebSocketRoute()\n  public async start(\n    @WebSocketRoute.Acceptor()\n    acceptor: WebSocketAcceptor<\n      null, // header\n      AgenticaRpcService,\n      IAgenticaRpcListener\n    >,\n  ): Promise<void> {\n    const agent = new Agentica({ ... })\n    await acceptor.accept(\n      new AgenticaRpcService({\n        agent,\n        listener: acceptor.getDriver(),\n      }),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Multipart Form with TypedFormData TypeScript\nDESCRIPTION: Illustrates the usage of `@TypedFormData.Body()` for handling multipart/form-data requests in a NestJS controller.  It defines a `create` method that utilizes the decorator to automatically parse and validate the request body according to the `IBbsArticleCreate` interface. Multer is initialized for handling file uploads.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedFormData.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedFormData, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport Multer from \"multer\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  @TypedRoute.Post()\n  public async create(\n    @TypedFormData.Body(() => Multer()) input: IBbsArticleCreate,\n  ): Promise<void> {\n    input;\n  }\n}\n\nexport interface IBbsArticleCreate {\n  title: string;\n  body: string | null;\n  thumbnail?: File | undefined;\n  files: File[];\n  tags: string[];\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled BbsArticlesController (JavaScript)\nDESCRIPTION: Compiled JavaScript code for the BbsArticlesController, showing the implementation details of the TypedQuery decorator and body parameter handling, including the validation and serialization logic generated by Nestia.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __decorate =\n  (this && this.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nvar __metadata =\n  (this && this.__metadata) ||\n  function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n      return Reflect.metadata(k, v);\n  };\nvar __param =\n  (this && this.__param) ||\n  function (paramIndex, decorator) {\n    return function (target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\nvar __awaiter =\n  (this && this.__awaiter) ||\n  function (thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P\n        ? value\n        : new P(function (resolve) {\n            resolve(value);\n          });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done\n          ? resolve(result.value)\n          : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\n  store(body) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        id: \"00000000-0000-0000-0000-000000000000\",\n        writer: \"Samchon\",\n        title: body.title,\n        body: body.body,\n        created_at: new Date().toISOString(),\n      };\n    });\n  }\n};\nexports.BbsArticlesController = BbsArticlesController;\n__decorate(\n  [\n    core_1.TypedQuery.Post({\n      type: \"assert\",\n      assert: (input) => {\n        const assert = (input) => {\n          const __is = (input) => {\n            return (\n              \"object\" === typeof input &&\n              null !== input &&\n              \"string\" === typeof input.id &&\n              \"string\" === typeof input.writer &&\n              \"string\" === typeof input.title &&\n              3 <= input.title.length &&\n              input.title.length <= 50 &&\n              \"string\" === typeof input.body &&\n              \"string\" === typeof input.created_at &&\n              !isNaN(new Date(input.created_at).getTime())\n            );\n          };\n          if (false === __is(input))\n            ((input, _path, _exceptionable = true) => {\n              const $guard = core_1.TypedQuery.Post.guard;\n              const $ao0 = (input, _path, _exceptionable = true) =>\n                (\"string\" === typeof input.id ||\n                  $guard(_exceptionable, {\n                    path: _path + \".id\",\n                    expected: \"string\",\n                    value: input.id,\n                  })) &&\n                (\"string\" === typeof input.writer ||\n                  $guard(_exceptionable, {\n                    path: _path + \".writer\",\n                    expected: \"string\",\n                    value: input.writer,\n                  })) &&\n                ((\"string\" === typeof input.title &&\n                  (3 <= input.title.length ||\n                    $guard(_exceptionable, {\n                      path: _path + \".title\",\n                      expected: \"string & MinLength<3>\",\n                      value: input.title,\n                    })) &&\n                  (input.title.length <= 50 ||\n                    $guard(_exceptionable, {\n                      path: _path + \".title\",\n                      expected: \"string & MaxLength<50>\",\n                      value: input.title,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".title\",\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\n                    value: input.title,\n                  })) &&\n                (\"string\" === typeof input.body ||\n                  $guard(_exceptionable, {\n                    path: _path + \".body\",\n                    expected: \"string\",\n                    value: input.body,\n                  })) &&\n                ((\"string\" === typeof input.created_at &&\n                  (!isNaN(new Date(input.created_at).getTime()) ||\n                    $guard(_exceptionable, {\n                      path: _path + \".created_at\",\n                      expected: 'string & Format<\"date-time\">',\n                      value: input.created_at,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".created_at\",\n                    expected: '(string & Format<\"date-time\">)',\n                    value: input.created_at,\n                  }));\n              return (\n                ((\"object\" === typeof input && null !== input) ||\n                  $guard(true, {\n                    path: _path + \"\",\n                    expected: \"IBbsArticle\",\n                    value: input,\n                  })) &&\n                  $ao0(input, _path + \"\", true)) ||\n                $guard(true, {\n                  path: _path + \"\",\n                  expected: \"IBbsArticle\",\n                  value: input,\n                })\n              );\n            })(input, \"$input\", true);\n          return input;\n        };\n        const stringify = (input) => {\n          const output = new URLSearchParams();\n          output.append(\"id\", input.id);\n          output.append(\"writer\", input.writer);\n          output.append(\"title\", input.title);\n          output.append(\"body\", input.body);\n          output.append(\"created_at\", input.created_at);\n          return output;\n        };\n        return stringify(assert(input));\n      },\n    }),\n    __param(\n      0,\n      core_1.TypedQuery.Body({\n        type: \"assert\",\n        assert: (input) => {\n          const decode = (input) => {\n            const $params = core_1.TypedQuery.Body.params;\n            const $string = core_1.TypedQuery.Body.string;\n            input = $params(input);\n            const output = {\n              title: $string(input.get(\"title\")),\n              body: $string(input.get(\"body\")),\n            };\n            return output;\n          };\n          const assert = (input) => {\n            const __is = (input) => {\n              return (\n                \"object\" === typeof input &&\n                null !== input &&\n                \"string\" === typeof input.title &&\n                3 <= input.title.length &&\n                input.title.length <= 50 &&\n                \"string\" === typeof input.body\n              );\n            };\n            if (false === __is(input))\n              ((input, _path, _exceptionable = true) => {\n                const $guard = core_1.TypedQuery.Body.guard;\n                const $ao0 = (input, _path, _exceptionable = true) =>\n                  ((\"string\" === typeof input.title &&\n                    (3 <= input.title.length ||\n                      $guard(_exceptionable, {\n                        path: _path + \".title\",\n                        expected: \"string & MinLength<3>\",\n                        value: input.title,\n                      })) &&\n                    (input.title.length <= 50 ||\n                      $guard(_exceptionable, {\n                        path: _path + \".title\",\n                        expected: \"string & MaxLength<50>\",\n                        value: input.title,\n                      }))) ||\n                    $guard(_exceptionable, {\n                      path: _path + \".title\",\n                      expected: \"(string & MinLength<3> & MaxLength<50>)\",\n                      value: input.title,\n                    })) &&\n                  (\"string\" === typeof input.body ||\n                    $guard(_exceptionable, {\n                      path: _path + \".body\",\n                      expected: \"string\",\n                      value: input.body,\n                    }));\n                return (\n                  ((\"object\" === typeof input && null !== input) ||\n                    $guard(true, {\n                      path: _path + \"\",\n                      expected: \"IBbsArticle.IStore\",\n                      value: input,\n                    })) &&\n                    $ao0(input, _path + \"\", true)) ||\n                  $guard(true, {\n                    path: _path + \"\",\n                    expected: \"IBbsArticle.IStore\",\n                    value: input,\n                  })\n                );\n              })(input, \"$input\", true);\n            return input;\n          };\n          return assert(decode(input));\n        },\n      })\n    ),\n  ],\n  __metadata(\"design:type\", Function),\n  __metadata(\"design:paramtypes\", [Object]),\n  __metadata(\"design:returntype\", Promise)\n)/// BbsArticlesController\n;\nBbsArticlesController = __decorate(\n  [common_1.Controller(\"bbs/articles\")],\n  BbsArticlesController\n);\n\n```\n\n----------------------------------------\n\nTITLE: Run Nestia SDK Build Scripts in Bash\nDESCRIPTION: These commands show how to execute the Nestia SDK build script. The first command runs the SDK generation process with default configurations.  The second command specifies the configuration file (`nestia.config.ts`) and the TypeScript project file (`tsconfig.json`) to use for SDK generation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia sdk\nnpx nestia sdk --config nestia.config.ts --project tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Using TypedParam in NestJS Controller Typescript\nDESCRIPTION: Demonstrates how to use the TypedParam decorator in a NestJS controller to parse path parameters with specific types, including uint32, string, and uuid. It utilizes typia's type tags for validation and type specification. This example shows how to declare parameters with specific types and tags, and how they are used within the controller methods.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedParam.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedParam } from \"@nestia/core\";\nimport { Controller, Get } from \"@nestjs/common\";\nimport { tags } from \"typia\";\n\n@Controller(\"parameters\")\nexport class ParametersController {\n  @Get(\"uint32/:value\")\n  public async uint32(\n    @TypedParam(\"value\") value: (number & tags.Type<\"uint32\">) | null,\n  ): Promise<(number & tags.Type<\"uint32\">) | null> {\n    return value;\n  }\n\n  @Get(\"string/:value\")\n  public async string(\n    @TypedParam(\"value\") value: string\n  ): Promise<string> {\n    return value;\n  }\n\n  @Get(\"uuid/:value\")\n  public async uuid(\n    @TypedParam(\"value\") value: string & tags.Format<\"uuid\">,\n  ): Promise<string> {\n    return value;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration\nDESCRIPTION: This snippet defines the Nestia configuration using INestiaConfig interface. It specifies the input NestJS application module, OpenAPI swagger options including security definitions and server configurations.  It exports the configuration as NESTIA_CONFIG.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  swagger: {\n    openapi: \"3.1\",\n    output: \"dist/swagger.json\",\n    security: {\n      bearer: {\n        type: \"apiKey\",\n        name: \"Authorization\",\n        in: \"header\",\n      },\n    },\n    servers: [\n      {\n        url: \"http://localhost:3000\",\n        description: \"Local Server\",\n      },\n    ],\n    beautify: true,\n  },\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Initializing Swagger with NestiaSwaggerComposer in main.ts\nDESCRIPTION: This code snippet demonstrates how to initialize and set up Swagger documentation within a NestJS application using NestiaSwaggerComposer. It imports necessary modules, creates a NestJS application instance, generates the Swagger document using NestiaSwaggerComposer, and sets up the Swagger UI using SwaggerModule. The document object is cast to 'any' due to type differences with SwaggerModule.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NestiaSwaggerComposer } from \"@nestia/sdk\";\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\nimport { SwaggerModule } from \"@nestjs/swagger\";\n\nconst main = async (): Promise<void> => {\n  const app: INestApplication = await NestFactory.create(ApplicationModule);\n  const document = await NestiaSwaggerComposer.document(app, {});\n  SwaggerModule.setup(\"api\", app, document as any);\n  await app.listen(3_000);\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: IBbsArticle Interface Definition (TypeScript)\nDESCRIPTION: Defines the IBbsArticle interface with validation constraints using typia. It specifies the structure of a blog article including properties like id, writer, title (with min/max length), body, and created_at (with date-time format).\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\nexport interface IBbsArticle {\n  id: string;\n  writer: string;\n  title: string & tags.MinLength<3> & tags.MaxLength<50>;\n  body: string;\n  created_at: string & tags.Format<\"date-time\">;\n}\nexport namespace IBbsArticle {\n  export interface IStore {\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\n    body: string;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Nestia E2E Tests (Bash)\nDESCRIPTION: These bash commands clone the nestia-start repository, install dependencies, build the test files, and execute the tests. These commands are used to execute end-to-end tests for a nestia project.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/development.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/samchon/nestia-start\ncd nestia-start\nnpm install\nnpm run build:test\nnpm run test\n```\n\n----------------------------------------\n\nTITLE: NestJS Controller for Advanced Calculator WebSocket Route\nDESCRIPTION: Defines a NestJS controller for handling WebSocket connections to an advanced calculator. It uses the `@WebSocketRoute` decorator to map a route to the `advance` method. The method accepts an ID, header, memo, and WebSocket acceptor as parameters, validates the header's precision value, and accepts the connection with an `AdvancedCalculator` instance.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WebSocketRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { Driver, WebSocketAcceptor } from \"tgrid\";\nimport { tags } from \"typia\";\n\nimport { IAdvancedCalculator } from \"./api/structures/IAdvancedCalculator\";\nimport { IHeader } from \"./api/structures/IHeader\";\nimport { IListener } from \"./api/structures/IListener\";\nimport { IMemo } from \"./api/structures/IMemo\";\nimport { AdvancedCalculator } from \"./providers/AdvancedCalculator\";\n\n@Controller(\"calculate\")\nexport class CalculateController {\n  /**\n   * Start advanced calculator.\n   *\n   * Start advanced calculator through WebSocket with additional information.\n   *\n   * @param id ID to assign\n   * @param header Header information\n   * @param memo Memo to archive\n   */\n  @WebSocketRoute(\":id/advance\")\n  public async advance(\n    @WebSocketRoute.Param(\"id\") id: string & tags.Format<\"uuid\">,\n    @WebSocketRoute.Header() header: undefined | Partial<IHeader>,\n    @WebSocketRoute.Query() memo: IMemo,\n    @WebSocketRoute.Acceptor()\n    acceptor: WebSocketAcceptor<undefined, IAdvancedCalculator, IListener>,\n  ): Promise<void> {\n    if (header?.precision !== undefined && header.precision < 0)\n      await acceptor.reject(1008, \"Invalid precision value\");\n    else\n      await acceptor.accept(\n        new AdvancedCalculator(\n          id,\n          { precision: header?.precision ?? 2 },\n          memo,\n          acceptor.getDriver(),\n        ),\n      );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled BbsArticlesController - JavaScript\nDESCRIPTION: This is the compiled JavaScript version of the BbsArticlesController. It demonstrates the equivalent JavaScript code generated from the TypeScript controller and includes decorators and metadata for NestJS and Nestia. The code shows the route definition and the asynchronous function that returns a mock article object.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedRoute.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __decorate =\n  (this && this.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nvar __metadata =\n  (this && this.__metadata) ||\n  function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n      return Reflect.metadata(k, v);\n  };\nvar __awaiter =\n  (this && this.__awaiter) ||\n  function (thisArg, _arguments, P, generator {\n    function adopt(value) {\n      return value instanceof P\n        ? value\n        : new P(function (resolve) {\n            resolve(value);\n          });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done\n          ? resolve(result.value)\n          : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\n  /**\n   * Get random article for testing.\n   */\n  random() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\n        title: \"Hello nestia users\",\n        body: \"Just use `TypedRoute.Get()` function like this\",\n        created_at: \"2023-04-23T12:04:54.168Z\",\n        files: [],\n      };\n    });\n  }\n};\nexports.BbsArticlesController = BbsArticlesController;\n__decorate(\n  [\n    core_1.TypedRoute.Get(\"random\", {\n      type: \"assert\",\n      assert: (input) => {\n        const assert = (input) => {\n          const __is = (input) => {\n            const $io0 = (input) =>\n              \"string\" === typeof input.id &&\n              /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n                input.id,\n              ) &&\n              \"string\" === typeof input.created_at &&\n              !isNaN(new Date(input.created_at).getTime()) &&\n              \"string\" === typeof input.title &&\n              3 <= input.title.length &&\n              input.title.length <= 50 &&\n              \"string\" === typeof input.body &&\n              Array.isArray(input.files) &&\n              input.files.every(\n                (elem) =>\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\n              );\n            const $io1 = (input) =>\n              (null === input.name ||\n                (\"string\" === typeof input.name &&\n                  1 <= input.name.length &&\n                  input.name.length <= 255)) &&\n              (null === input.extension ||\n                (\"string\" === typeof input.extension &&\n                  1 <= input.extension.length &&\n                  input.extension.length <= 8)) &&\n              \"string\" === typeof input.url &&\n              /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\n                input.url,\n              );\n            return \"object\" === typeof input && null !== input && $io0(input);\n          };\n          if (false === __is(input))\n            ((input, _path, _exceptionable = true) => {\n              const $guard = core_1.TypedRoute.Get.guard;\n              const $ao0 = (input, _path, _exceptionable = true) =>\n                ((\"string\" === typeof input.id &&\n                  (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n                    input.id,\n                  ) ||\n                    $guard(_exceptionable, {\n                      path: _path + \".id\",\n                      expected: 'string & Format<\"uuid\">',\n                      value: input.id,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".id\",\n                    expected: '(string & Format<\"uuid\">)',\n                    value: input.id,\n                  })) &&\n                ((\"string\" === typeof input.created_at &&\n                  (!isNaN(new Date(input.created_at).getTime()) ||\n                    $guard(_exceptionable, {\n                      path: _path + \".created_at\",\n                      expected: 'string & Format<\"date-time\">',\n                      value: input.created_at,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".created_at\",\n                    expected: '(string & Format<\"date-time\">)',\n                    value: input.created_at,\n                  })) &&\n                ((\"string\" === typeof input.title &&\n                  (3 <= input.title.length ||\n                    $guard(_exceptionable, {\n                      path: _path + \".title\",\n                      expected: \"string & MinLength<3>\",\n                      value: input.title,\n                    })) &&\n                  (input.title.length <= 50 ||\n                    $guard(_exceptionable, {\n                      path: _path + \".title\",\n                      expected: \"string & MaxLength<50>\",\n                      value: input.title,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".title\",\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\n                    value: input.title,\n                  })) &&\n                (\"string\" === typeof input.body ||\n                  $guard(_exceptionable, {\n                    path: _path + \".body\",\n                    expected: \"string\",\n                    value: input.body,\n                  })) &&\n                (((Array.isArray(input.files) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".files\",\n                    expected: \"Array<IAttachmentFile>\",\n                    value: input.files,\n                  })) &&\n                  input.files.every(\n                    (elem, _index1) =>\n                      ((\"object\" === typeof elem && null !== elem) ||\n                        $guard(_exceptionable, {\n                          path: _path + \".files[\" + _index1 + \"]\",\n                          expected: \"IAttachmentFile\",\n                          value: elem,\n                        })) &&\n                        $ao1(\n                          elem,\n                          _path + \".files[\" + _index1 + \"]\",\n                          true && _exceptionable,\n                        )) ||\n                      $guard(_exceptionable, {\n                        path: _path + \".files[\" + _index1 + \"]\",\n                        expected: \"IAttachmentFile\",\n                        value: elem,\n                      }),\n                  )) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".files\",\n                    expected: \"Array<IAttachmentFile>\",\n                    value: input.files,\n                  }));\n              const $ao1 = (input, _path, _exceptionable = true) =>\n                (null === input.name ||\n                  (\"string\" === typeof input.name &&\n                    (1 <= input.name.length ||\n                      $guard(_exceptionable, {\n                        path: _path + \".name\",\n                        expected: \"string & MinLength<1>\",\n                        value: input.name,\n                      })) &&\n                    (input.name.length <= 255 ||\n```\n\n----------------------------------------\n\nTITLE: Advance Calculator API Function with Nestia\nDESCRIPTION: Defines the `advance` function for starting an advanced calculator through a WebSocket connection. It takes a connection object, an ID, a memo, and a provider as input. It establishes a WebSocket connection, retrieves a driver for the listener, and returns the connector and driver. The `advance` namespace contains type definitions for the function's input and output.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @packageDocumentation\n * @module api.functional.calculate\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\n */\n//================================================================\nimport type { IConnection } from \"@nestia/fetcher\";\nimport { WebSocketConnector } from \"tgrid\";\nimport type { Driver } from \"tgrid\";\nimport type { Format } from \"typia/lib/tags/Format\";\n\nimport type { IAdvancedCalculator } from \"../../structures/IAdvancedCalculator\";\nimport type { IHeader } from \"../../structures/IHeader\";\nimport type { IListener } from \"../../structures/IListener\";\nimport type { IMemo } from \"../../structures/IMemo\";\n\n/**\n * Start advanced calculator.\n *\n * Start advanced calculator through WebSocket with additional information.\n *\n * @param id ID to assign\n * @param memo Memo to archive\n *\n * @controller CalculateController.advance\n * @path /calculate/:id/advance\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\n */\nexport async function advance(\n  connection: IConnection<advance.Header>,\n  id: string & Format<\"uuid\">,\n  memo: advance.Query,\n  provider: advance.Provider,\n): Promise<advance.Output> {\n  const connector: WebSocketConnector<\n    advance.Header,\n    advance.Provider,\n    advance.Listener\n  > = new WebSocketConnector(connection.headers ?? ({} as any), provider);\n  await connector.connect(\n    `${connection.host}/${advance.path(id, memo)}`\n      .split(\"/\")\n      .filter((str) => !!str)\n      .join(\"/\"),\n  );\n  const driver: Driver<advance.Listener> = connector.getDriver();\n  return {\n    connector,\n    driver,\n  };\n}\nexport namespace advance {\n  export type Output = {\n    connector: WebSocketConnector<Header, Provider, Listener>;\n    driver: Driver<Listener>;\n  };\n  export type Header = undefined | Partial<IHeader>;\n  export type Provider = IListener;\n  export type Listener = IAdvancedCalculator;\n  export type Query = IMemo;\n\n  export const path = (id: string & Format<\"uuid\">, memo: advance.Query) => {\n    const variables: URLSearchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(memo as any))\n      if (undefined === value) continue;\n      else if (Array.isArray(value))\n        value.forEach((elem: any) => variables.append(key, String(elem)));\n      else variables.set(key, String(value));\n    const location: string = `/calculate/${encodeURIComponent(id ?? \"null\")}/advance`;\n    return 0 === variables.size\n      ? location\n      : `${location}?${variables.toString()}`;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration: Defining Security Schemes (nestia.config.ts)\nDESCRIPTION: This code snippet demonstrates how to configure security schemes within a Nestia configuration file (nestia.config.ts). It showcases defining basic, bearer, OAuth2, and custom API key security schemes for use in Swagger documentation. The OAuth2 configuration includes implicit flow definition with authorization and refresh URLs and scopes. This configuration instructs Nestia to include these security definitions in the generated swagger.json file.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { INestiaConfig } from \"@nestia/sdk\";\n\nexport const NESTIA_CONFIG: INestiaConfig = {\n  input: [\"src/controllers\"],\n  output: \"src/api\",\n  swagger: {\n    output: \"swagger.json\",\n    beautify: true,\n    operationId: (props) => `${props.class}.${props.function}`,\n    security: {\n      basic: {\n        type: \"http\",\n        scheme: \"basic\",\n      },\n      bearer: {\n        type: \"http\",\n        scheme: \"bearer\",\n      },\n      oauth2: {\n        type: \"oauth2\",\n        flows: {\n          implicit: {\n            authorizationUrl: \"https://example.com/api/oauth/dialog\",\n            refreshUrl: \"https://example.com/api/oauth/refresh\",\n            scopes: {\n              read: \"read authority\",\n              write: \"write authority\",\n            },\n          },\n        },\n      },\n      custom: {\n        type: \"apiKey\",\n        in: \"header\",\n        name: \"Authorization\",\n      },\n    },\n  },\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Initializing DynamicExecutor and Backend Server TypeScript\nDESCRIPTION: This snippet initializes the test environment, including configuring a backend server, establishing a client connection, and using DynamicExecutor to validate API endpoints. It parses command-line options to control test execution, sets up a backend server on localhost, and configures the client to connect to it. The DynamicExecutor is used to run tests in the specified directory, filtering based on include/exclude options. The test results are then analyzed and printed to the console.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/why.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DynamicExecutor } from \"@nestia/e2e\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\n\nimport { MyBackend } from \"../src/MyBackend\";\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { ArgumentParser } from \"./helpers/ArgumentParser\";\n\ninterface IOptions {\n  include?: string[];\n  exclude?: string[];\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<IOptions>(async (command, _prompt, action) => {\n    // command.option(\"--mode <string>\", \"target mode\");\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\n    command.option(\"--include <string...>\", \"include feature files\");\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\n\n    return action(async (options) => {\n      // if (typeof options.reset === \"string\")\n      //     options.reset = options.reset === \"true\";\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\n      //     \"LOCAL\",\n      //     \"DEV\",\n      //     \"REAL\",\n      // ]);\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\n      return options as IOptions;\n    });\n  });\n\nasync function main(): Promise<void> {\n  // CONFIGURATIONS\n  const options: IOptions = await getOptions();\n  MyGlobal.testing = true;\n\n  // BACKEND SERVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  //----\n  // CLIENT CONNECTOR\n  //----\n  // DO TEST\n  const connection: api.IConnection = {\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n  };\n  const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\n    prefix: \"test\",\n    parameters: () => [{ ...connection }],\n    filter: (func) =>\n      (!options.include?.length ||\n        (options.include ?? []).some((str) => func.includes(str))) &&\n      (!options.exclude?.length ||\n        (options.exclude ?? []).every((str) => !func.includes(str))),\n  })(__dirname + \"/features\");\n\n  await backend.close();\n\n  const failures: DynamicExecutor.IReport.IExecution[] =\n    report.executions.filter((exec) => exec.error !== null);\n  if (failures.length === 0) {\n    console.log(\"Success\");\n    console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n  } else {\n    for (const f of failures) console.log(f.error);\n    process.exit(-1);\n  }\n\n  console.log(\n    [\n      `All: #${report.executions.length}`,\n      `Success: #${report.executions.length - failures.length}`,\n      `Failed: #${failures.length}`,\n    ].join(\"\\n\"),\n  );\n}\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript compiler options for Nestia\nDESCRIPTION: This JSON snippet configures the TypeScript compiler to use Nestia's transformation plugins. It adds three transformers to the compiler's plugin array: typia, @nestia/core, and @nestia/sdk. The @nestia/sdk transformer is essential for generating Swagger documentation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"plugins\": [\n      { \"transform\": \"typia/lib/transform\" },\n      { \"transform\": \"@nestia/core/lib/transform\" },\n      { \"transform\": \"@nestia/sdk/lib/transform\" }, // essential\n    ],\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration Example (nestia.config.ts)\nDESCRIPTION: This configuration file defines how Nestia will process a NestJS project. It specifies the input (how to access the controller classes), the output directory for the generated SDK, the distribution directory, and the e2e test output directory. It also shows how to initialize a NestJS application using NestFactory.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: BBS Article Update Test - TypeScript\nDESCRIPTION: This test function `test_api_bbs_article_update` tests the article update functionality. It creates an article, updates it with a correct password, and then attempts to update it with a wrong password, expecting an error. The test uses `@nestia/e2e` for test utilities and `@ORGANIZATION/PROJECT-api` for interacting with the API.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/benchmark.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { v4 } from \"uuid\";\n\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\n\nexport async function test_api_bbs_article_update(\n  connection: api.IConnection,\n): Promise<void> {\n  // STORE A NEW ARTICLE\n  const password: string = v4();\n  const article: IBbsArticle = await api.functional.bbs.articles.create(\n    connection,\n    \"general\",\n    {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(3)(),\n      body: RandomGenerator.content(8)()(),\n      format: \"txt\",\n      files: [\n        {\n          name: \"logo\",\n          extension: \"png\",\n          url: \"https://somewhere.com/logo.png\",\n        },\n      ],\n      password,\n    },\n  );\n\n  // UPDATE WITH EXACT PASSWORD\n  const content: IBbsArticle.ISnapshot =\n    await api.functional.bbs.articles.update(\n      connection,\n      article.section,\n      article.id,\n      {\n        title: RandomGenerator.paragraph(3)(),\n        body: RandomGenerator.content(8)()(),\n        format: \"txt\",\n        files: [],\n        password,\n      },\n    );\n  article.snapshots.push(content);\n\n  // TRY UPDATE WITH WRONG PASSWORD\n  await TestValidator.error(\"update with wrong password\")(() =>\n    api.functional.bbs.articles.update(\n      connection,\n      article.section,\n      article.id,\n      {\n        title: RandomGenerator.paragraph(5)(),\n        body: RandomGenerator.content(8)()(),\n        format: \"txt\",\n        files: [],\n        password: v4(),\n      },\n    ),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nestia with nestia.config.ts\nDESCRIPTION: This code snippet demonstrates the configuration of Nestia using the `nestia.config.ts` file. It imports necessary modules from `@nestia/sdk` and `@nestjs/core`, defines the `NESTIA_CONFIG` object conforming to the `INestiaConfig` interface, and exports it. The configuration includes the input source (NestJS application factory), output directory for generated SDK, enabling simulation mode, distribution directory, and e2e test directory. The `input` field utilizes `NestFactory.create` to create an instance of NestJS application with `YourModule` as the root module.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  simulate: true, // supports simulation mode\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Define IBbsArticleCreate Interface Typescript\nDESCRIPTION: Defines the interface `IBbsArticleCreate` which specifies the structure for creating a BBS article. It includes properties for title, body, thumbnail, files, and tags.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedFormData.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IBbsArticleCreate {\n  title: string;\n  body: string | null;\n  thumbnail?: File | undefined;\n  files: File[];\n  tags: string[];\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing JSON Schema with Typia\nDESCRIPTION: Demonstrates how to customize JSON schema generation with Typia by defining custom properties using `typia.tags.TagBase` or `typia.tags.JsonSchemaPlugin`. Custom properties must start with `x-`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n \ntype Monetary<Value extends string> = tags.TagBase<{\n  target: \"number\";\n  kind: \"monetary\";\n  value: Value;\n  schema: {\n    \"x-monetary\": Value;\n  };\n}>;\n\ntype Placeholder<Value extends string> = tags.JsonSchemaPlugin<{\n  \"x-placeholder\": Value;\n}>;\n\ninterface IAccount {\n  code: string & Placeholder<\"Write you account code please\">;\n  balance: number & Monetary<\"dollar\">;\n};\ntypia.json.application<[IAccount]>();\n```\n\n----------------------------------------\n\nTITLE: Special Tags Example in Typia\nDESCRIPTION: This snippet showcases how to use special tags from `typia` to enhance validation logic within `@TypedFormData.Body()`. It defines an interface `SpecialTag` with various type and comment tags for validation, such as `int32`, `ExclusiveMinimum`, `Maximum`, `MinLength`, `Pattern`, and `Format`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedFormData.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\n\ninterface SpecialTag {\n  int32: number & tags.Type<\"int32\">;\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n  minLength: string & tags.MinLength<3>;\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n  date: null | (string & tags.Format<\"date\">);\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\n  uuids: Array<string & tags.Format<\"uuid\">> &\n    tags.MinItems<3> &\n    tags.MaxItems<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implement Header Controller TypeScript\nDESCRIPTION: Implements a NestJS controller `HeadersController` that uses Nestia's `@TypedHeaders()` decorator to automatically parse and validate request headers against the `IHeaders` interface. The `emplace` method receives the validated headers and a section parameter.  It leverages `@nestjs/common` for controller and route definitions and `@nestia/core` for typed headers.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedHeaders.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Controller } from \"@nestjs/common\";\n\nimport core from \"@nestia/core\";\n\nimport { IHeaders } from \"@api/lib/structures/IHeaders\";\n\n@Controller(\"headers/:section\")\nexport class HeadersController {\n  /**\n   * Emplace headers.\n   *\n   * @param headers Headers for authentication\n   * @param section Target section code\n   * @returns Store article\n   *\n   * @author Samchon\n   */\n  @core.TypedRoute.Patch()\n  public emplace(\n    @core.TypedHeaders() headers: IHeaders,\n    @core.TypedParam(\"section\", \"string\") section: string,\n  ): void {\n    headers;\n    section;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: API Article Creation Test\nDESCRIPTION: Tests the creation of a BBS article via the API. It stores a new article with random data, then reads the stored article again to validate that the created data matches the read data. Dependencies include RandomGenerator, TestValidator, uuid, and the API client library.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/why.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function test_api_bbs_article_create(\n  connection: api.IConnection,\n): Promise<void> {\n  // STORE A NEW ARTICLE\n  const stored: IBbsArticle = await api.functional.bbs.articles.create(\n    connection,\n    \"general\",\n    {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(3)(),\n      body: RandomGenerator.content(8)()(),\n      format: \"txt\",\n      files: [\n        {\n          name: \"logo\",\n          extension: \"png\",\n          url: \"https://somewhere.com/logo.png\",\n        },\n      ],\n      password: v4(),\n    },\n  );\n\n  // READ THE DATA AGAIN\n  const read: IBbsArticle = await api.functional.bbs.articles.at(\n    connection,\n    stored.section,\n    stored.id,\n  );\n  TestValidator.equals(\"created\")(stored)(read);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing BBS Article Creation with Nestia TypeScript\nDESCRIPTION: This test function `test_api_bbs_article_create` creates a new BBS article using the `api.functional.bbs.articles.create` method. It generates random data for the article content (writer, title, body), uploads a dummy file, and then retrieves the article using `api.functional.bbs.articles.at`. Finally, it validates that the created and retrieved articles are identical using `TestValidator.equals`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/why.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { v4 } from \"uuid\";\n\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\n\nexport async function test_api_bbs_article_create(\n  connection: api.IConnection,\n): Promise<void> {\n  // STORE A NEW ARTICLE\n  const stored: IBbsArticle = await api.functional.bbs.articles.create(\n    connection,\n    \"general\",\n    {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(3)(),\n      body: RandomGenerator.content(8)()(),\n      format: \"txt\",\n      files: [\n        {\n          name: \"logo\",\n          extension: \"png\",\n          url: \"https://somewhere.com/logo.png\",\n        },\n      ],\n      password: v4(),\n    },\n  );\n\n  // READ THE DATA AGAIN\n  const read: IBbsArticle = await api.functional.bbs.articles.at(\n    connection,\n    stored.section,\n    stored.id,\n  );\n  TestValidator.equals(\"created\")(stored)(read);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Nestia using npm (Bash)\nDESCRIPTION: This command initiates the Nestia setup wizard using npm to install and configure Nestia automatically in an existing project. During the setup, you will be prompted to configure runtime swagger.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia setup\n```\n\n----------------------------------------\n\nTITLE: Runtime Swagger Composition with Configuration\nDESCRIPTION: This code snippet demonstrates configuring Swagger Document settings in runtime. It imports necessary modules, creates a NestJS application instance, generates the Swagger document using NestiaSwaggerComposer, and sets up the Swagger UI using SwaggerModule. Specific settings like OpenAPI version and servers are defined.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NestiaSwaggerComposer } from \"@nestia/sdk\";\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\nimport { SwaggerModule } from \"@nestjs/swagger\";\n\nconst main = async (): Promise<void> => {\n  const app: INestApplication = await NestFactory.create(ApplicationModule);\n  const document = await NestiaSwaggerComposer.document(app, {\n    openapi: \"3.1\",\n    servers: [\n      {\n        url: \"http://localhost:3000\",\n        description: \"Localhost\"\n      }\n    ]\n  });\n  SwaggerModule.setup(\"api\", app, document as any);\n  await app.listen(3_000);\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: React Component for Nestia Editor Iframe\nDESCRIPTION: This TypeScript snippet demonstrates how to use the `NestiaEditorIframe` component from `@nestia/editor` in a React application.  It requires the `@nestia/editor` and `@samchon/openapi` packages. It takes a Swagger document as input and renders the Nestia Editor in an iframe.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/editor.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { NestiaEditorIframe } from \"@nestia/editor\";\nimport { SwaggerV2, OpenApiV3, OpenApiV3_1 } from \"@samchon/openapi\";\n\nconst document: SwaggerV2 | OpenApiV3 | OpenApiV3_1;\n\n<NestiaEditorIframe swagger={document} \n                    package=\"your-package-name\"\n                    e2e={true} \n                    simulate={true} />\n<NestiaEditorUploader />\n```\n\n----------------------------------------\n\nTITLE: Nestia SDK Build Command\nDESCRIPTION: This bash snippet shows the command to execute the Nestia SDK generation process. It uses `npx` to run the `nestia sdk` command, which analyzes the NestJS backend and generates the SDK library based on the configuration defined in `nestia.config.ts`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/index.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia sdk\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration for Multiple Swagger Files\nDESCRIPTION: This code snippet demonstrates how to configure the `nestia.config.ts` file to generate multiple Swagger document files for different NestJS modules. Each module's configuration includes an input function creating a NestJS application, an output path for the swagger.json file, and security settings.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { AppModule } from \"./src/modules/AppModule\";\nimport { BbsModule } from \"./src/modules/BbsModule\";\nimport { CommonModule } from \"./src/modules/CommonModule\";\n\nexport const NESTIA_CONFIGURATIONS: INestiaConfig[] = [\n  {\n    input: () => NestFactory.create(AppModule),\n    swagger: {\n      output: \"swagger.json\",\n      security: {\n        bearer: {\n          type: \"apiKey\",\n        },\n      },\n    },\n  },\n  {\n    input: () => NestFactory.create(BbsModule),\n    swagger: {\n      output: \"bbs.swagger.json\",\n      security: {\n        bearer: {\n          type: \"apiKey\",\n        },\n      },\n    },\n  },\n  {\n    input: () => NestFactory.create(CommonModule),\n    swagger: {\n      output: \"common.swagger.json\",\n      security: {\n        bearer: {\n          type: \"apiKey\",\n        },\n      },\n    },\n  },\n];\nexport default NESTIA_CONFIGURATIONS;\n```\n\n----------------------------------------\n\nTITLE: TypeScript Interface with JSDoc comments\nDESCRIPTION: This TypeScript interface `IMember` demonstrates the use of JSDoc comments to generate OpenAPI documentation, including titles and descriptions for schema properties. It shows how to use `@title` and `@description` tags to customize the schema and influence the LLM's understanding of each property's purpose. Proper indentation is necessary for the `@description` tag to correctly associate the description with the corresponding property.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IMember {\n  /**\n   * Primary Key.\n   * \n   * Above \"Primary Key\" would be the title of LLM schema. \n   */\n  id: string;\n \n  /**\n   * Below \"Age of the member\" would be the title of LLM schema.\n   * \n   * @title Age of the member\n   */\n  age: number;\n \n  /**\n   * @title Email address of the member\n   * @description The description property also can be filled by \n   *              the comment tag `@description`. Instead, be\n   *              careful about the indentation.\n   */\n  email: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Define DTO with Special Tags in TypeScript\nDESCRIPTION: Defines a TypeScript interface `SpecialTag` with properties that use JSDoc comments and `typia` tags to specify constraints and metadata for JSON schema generation. The tags include type, minimum, maximum, length, pattern, and format validations.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SpecialTag {\n  /**\n   * Deprecated tags are just used for marking.\n   *\n   * @title Unsigned integer\n   * @deprecated\n   */\n  type: number & tags.Type<\"uint32\">;\n\n  /**\n   * Internal tagged property never be shown in JSON schema.\n   *\n   * It even doesn't be shown in other `typia` functions like `assert<T>()`.\n   *\n   * @internal\n   */\n  internal: number[];\n\n  /**\n   * Hidden tagged property never be shown in JSON schema.\n   *\n   * However, it would be shown in other `typia` functions like `stringify<T>()`.\n   *\n   * @hidden\n   */\n  hidden: boolean;\n\n  /**\n   * You can limit the range of number.\n   *\n   * Also, you can configure `default` property by comment tag.\n   *\n   * @default 30\n   */\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n\n  /**\n   * You can limit the length of string.\n   */\n  string: string & tags.MinLength<3>;\n\n  /**\n   * You can limit the pattern of string.\n   */\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n\n  /**\n   * You can limit the format of string.\n   */\n  format: null | (string & tags.Format<\"date-time\">);\n\n  /**\n   * You also can perform union type in type tags.\n   */\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\n\n  /**\n   * In the Array case, only type tags can limit elements' type.\n   */\n  array: Array<string & tags.Format<\"uuid\">> &\n    tags.MinItems<3> &\n    tags.MaxItems<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: NestiaSimulator Assert Function\nDESCRIPTION: The `NestiaSimulator.assert` function generates validation functions for different parts of an HTTP request (parameters, query, body) based on a given configuration object. The configuration object includes properties like host, path, method and content type. These functions use `typia.assert` to validate the data, and throw an `HttpError` if the validation fails, providing detailed error information.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpError } from \"@nestia/fetcher\";\n\nimport typia from \"typia\";\n\nexport namespace NestiaSimulator {\n  export interface IProps {\n    host: string;\n    path: string;\n    method: \"GET\" | \"POST\" | \"PATCH\" | \"PUT\" | \"DELETE\";\n    contentType: string;\n  }\n\n  export const assert = (props: IProps) => {\n    return {\n      param: param(props),\n      query: query(props),\n      body: body(props),\n    };\n  };\n  const param =\n    (props: IProps)\n    (name: string)\n    <T>(task: () => T): void => {\n      validate((exp) => `URL parameter \"${name}\" is not ${exp.expected} type.`)(\n        props,\n      )(task);\n    };\n\n  const query =\n    (props: IProps)\n    <T>(task: () => T): void =>\n      validate(\n        () => \"Request query parameters are not following the promised type.\",\n      )(props)(task);\n\n  const body =\n    (props: IProps)\n    <T>(task: () => T): void =>\n      validate(() => \"Request body is not following the promised type.\")(props)(\n        task,\n      );\n\n  const validate =\n    (message: (exp: typia.TypeGuardError) => string, path?: string)\n    (props: IProps)\n    <T>(task: () => T): void => {\n      try {\n        task();\n      } catch (exp) {\n        if (typia.is<typia.TypeGuardError>(exp))\n          throw new HttpError(\n            props.method,\n            props.host + props.path,\n            400,\n            {\n              \"Content-Type\": props.contentType,\n            },\n            JSON.stringify({\n              method: exp.method,\n              path: path ?? exp.path,\n              expected: exp.expected,\n              value: exp.value,\n              message: message(exp),\n            }),\n          );\n        throw exp;\n      }\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Webpack Configuration (JavaScript)\nDESCRIPTION: This JavaScript code provides a basic webpack configuration file for bundling a NestJS application. It defines the entry point, output path, target, modules, and resolvers. It also uses webpack-node-externals to exclude node_modules from the bundle.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst path = require(\"path\");\nconst nodeExternals = require(\"webpack-node-externals\");\n\nmodule.exports = {\n  // CUSTOMIZE HERE\n  entry: {\n    server: \"./src/executable/server.ts\",\n  },\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"[name].js\",\n  },\n  optimization: {\n    minimize: false,\n  },\n\n  // JUST KEEP THEM\n  externals: [nodeExternals()],\n  mode: \"development\",\n  target: \"node\",\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        loader: \"ts-loader\",\n      },\n    ],\n  },\n  resolve: {\n    extensions: [\".tsx\", \".ts\", \".js\"],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: WebSocket API Client Test\nDESCRIPTION: Illustrates how to test a WebSocket API using @nestia/e2e and a client library. It establishes a connection to the WebSocket endpoint, sends requests using the generated Driver, and validates the results using TestValidator. This ensures the correct functionality of the WebSocket API.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TestValidator } from \"@nestia/e2e\";\nimport api from \"@samchon/calculator-api/lib/index\";\nimport { IListener } from \"@samchon/calculator-api/lib/structures/IListener\";\n\nexport const test_api_calculate_start = async (\n  connection: api.IConnection,\n): Promise<void> => {\n  const stack: IListener.IEvent[] = [];\n  const listener: IListener = {\n    on: (event) => stack.push(event),\n  };\n  const { connector, driver } = await api.functional.calculate.start(\n    connection,\n    listener,\n  );\n  try {\n    TestValidator.equals(\"plus\")(await driver.plus(4, 2))(6);\n    TestValidator.equals(\"minus\")(await driver.minus(4, 2))(2);\n    TestValidator.equals(\"multiply\")(await driver.multiply(4, 2))(8);\n    TestValidator.equals(\"divide\")(await driver.divide(4, 2))(2);\n    TestValidator.equals(\"events\")(stack)([\n      { type: \"plus\", x: 4, y: 2, z: 6 },\n      { type: \"minus\", x: 4, y: 2, z: 2 },\n      { type: \"multiply\", x: 4, y: 2, z: 8 },\n      { type: \"divide\", x: 4, y: 2, z: 2 },\n    ]);\n  } catch (exp) {\n    throw exp;\n  } finally {\n    await connector.close();\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: OpenAPI Security Scheme Definition (@samchon/openapi)\nDESCRIPTION: This TypeScript code defines the structure for OpenAPI security schemes using interfaces.  It encompasses HTTP Basic and Bearer authentication, API Key, OpenID Connect, and OAuth2 security schemes. The OAuth2 interface includes nested interfaces for flow configurations, defining authorization, token, and refresh URLs, along with scopes.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Security scheme of Swagger Documents.\n *\n * `OpenApi.ISecurityScheme` is a data structure representing content of\n * `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\n * schemes as an union type like below.\n *\n * @reference https://swagger.io/specification/#security-scheme-object\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport type ISecurityScheme =\n  | ISecurityScheme.IHttpBasic\n  | ISecurityScheme.IHttpBearer\n  | ISecurityScheme.IApiKey\n  | ISecurityScheme.IOpenId\n  | ISecurityScheme.IOAuth2;\nexport namespace ISecurityScheme {\n  export interface IHttpBasic {\n    type: \"http\";\n    scheme: \"basic\";\n  }\n  export interface IHttpBearer {\n    type: \"http\";\n    scheme: \"bearer\";\n    bearerFormat?: string;\n  }\n  export interface IApiKey {\n    type: \"apiKey\";\n    in?: \"header\" | \"query\" | \"cookie\";\n    name?: string;\n  }\n\n  export interface IOpenId {\n    type: \"openIdConnect\";\n    openIdConnectUrl: string;\n  }\n\n  export interface IOAuth2 {\n    type: \"oauth2\";\n    flows: IOAuth2.IFlowSet;\n    description?: string;\n  }\n  export namespace IOAuth2 {\n    export interface IFlowSet {\n      authorizationCode?: IFlow;\n      implicit?: Omit<IFlow, \"tokenUrl\">;\n      password?: Omit<IFlow, \"authorizationUrl\">;\n      clientCredentials?: Omit<IFlow, \"authorizationUrl\">;\n    }\n    export interface IFlow {\n      authorizationUrl: string;\n      tokenUrl: string;\n      refreshUrl: string;\n      scopes?: Record<string, string>;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating BBS Article Test (TypeScript)\nDESCRIPTION: This test function `test_api_bbs_article_create` creates a new BBS article using the `api.functional.bbs.articles.create` endpoint. It generates random data for the article content and validates the created article by retrieving it using `api.functional.bbs.articles.at` and comparing the data.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/development.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { v4 } from \"uuid\";\n\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\n\nexport async function test_api_bbs_article_create(\n  connection: api.IConnection,\n): Promise<void> {\n  // STORE A NEW ARTICLE\n  const stored: IBbsArticle = await api.functional.bbs.articles.create(\n    connection,\n    \"general\",\n    {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(3)(),\n      body: RandomGenerator.content(8)()(),\n      format: \"txt\",\n      files: [\n        {\n          name: \"logo\",\n          extension: \"png\",\n          url: \"https://somewhere.com/logo.png\",\n        },\n      ],\n      password: v4(),\n    },\n  );\n\n  // READ THE DATA AGAIN\n  const read: IBbsArticle = await api.functional.bbs.articles.at(\n    connection,\n    stored.section,\n    stored.id,\n  );\n  TestValidator.equals(\"created\")(stored)(read);\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration Interface: INestiaConfig.ts\nDESCRIPTION: This code defines the `INestiaConfig` interface, which specifies the available configuration options for Nestia. It includes properties for input, output, swagger generation, distribution, simulation mode, e2e testing, propagation mode, and DTO cloning. The interface offers fine-grained control over the SDK generation process, allowing developers to tailor the generated code to their specific needs. Each option provides different configuration ability for generating SDK.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/index.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { INestApplication } from \"@nestjs/common\";\nimport type { OpenApi } from \"@samchon/openapi\";\n\n/**\n * Definition for the `nestia.config.ts` file.\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport interface INestiaConfig {\n  /**\n   * Accessor of controller classes.\n   *\n   * You can specify it within two ways\n   *\n   *   - Asynchronous function returning `INestApplication` instance\n   *   - Specify the path or directory of controller class files\n   */\n  input:\n    | (() => Promise<INestApplication>)\n    | INestiaConfig.IInput\n    | string[]\n    | string;\n\n  /**\n   * Output directory that SDK would be placed in.\n   *\n   * If not configured, you can't build the SDK library.\n   */\n  output?: string;\n\n  /**\n   * Building `swagger.json` is also possible.\n   *\n   * If not specified, you can't build the `swagger.json`.\n   */\n  swagger?: INestiaConfig.ISwaggerConfig;\n\n  /**\n   * Target directory that SDK distribution files would be placed in.\n   *\n   * If you configure this property and runs `npx nestia sdk` command,\n   * distribution environments for the SDK library would be generated.\n   *\n   * After the SDK library generation, move to the `distribute` directory,\n   * and runs `npm publish` command, then you can share SDK library with\n   * other client (frontend) developers.\n   *\n   * Recommend to use `\"packages/api\"` value.\n   */\n  distribute?: string;\n\n  /**\n   * Allow simulation mode.\n   *\n   * If you configure this property to be `true`, the SDK library would be contain\n   * simulation mode. In the simulation mode, the SDK library would not communicate\n   * with the real backend server, but just returns random mock-up data\n   * with requestion data validation.\n   *\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\n   * function.\n   *\n   * @default false\n   */\n  simulate?: boolean;\n\n  /**\n   * Target directory that e2e test functions would be placed in.\n   *\n   * If you configure this property and runs `npx nestia e2e` command,\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\n   * generates e2e test functions for every API endpoints.\n   *\n   * If not configured, you can't run `npx nestia e2e` command.\n   */\n  e2e?: string;\n\n  /**\n   * Whether to use propagation mode or not.\n   *\n   * If being configured, interaction functions of the SDK library would\n   * perform the propagation mode. The propagation mode means that never\n   * throwing exception even when status code is not 200 (or 201), but just\n   * returning the {@link IPropagation} typed instance, which can specify its body\n   * type through discriminated union determined by status code.\n   *\n   * @default false\n   */\n  propagate?: boolean;\n\n  /**\n   * Whether to clone DTO structures or not.\n   *\n   * If being configured, all of DTOs used in the backend server would be cloned\n   * into the `structures` directory, and the SDK library would be refer to the\n   * cloned DTOs instead of the original.\n   *\n   * @default false\n   */\n  clone?: boolean;\n\n  /**\n   * Whether to wrap DTO by primitive type.\n   *\n   * If you don't configure this property as `false`, all of DTOs in the\n   * SDK library would be automatically wrapped by {@link Primitive} type.\n   *\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\n   * all of methods in the DTO type would be automatically erased. Also, if\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\n   * converted to return type of the `toJSON()` method.\n   *\n   * @default true\n   */\n  primitive?: boolean;\n\n  /**\n   * Whether to assert parameter types or not.\n   *\n   * If you configure this property to be `true`, all of the function\n   * parameters of SDK library would be checked through\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\n   *\n   * This option would make your SDK library compilation time a little bit slower,\n   * but would enahcne the type safety even in the runtime level.\n   *\n   * @default false\n   */\n  assert?: boolean;\n\n  /**\n   * Whether to optimize JSON string conversion 10x faster or not.\n   *\n   * If you configure this property to be `true`, the SDK library would utilize the\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\n   * to boost up JSON serialization speed and ensure type safety.\n   *\n   * This option would make your SDK library compilation time a little bit slower,\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\n   * safety even in the runtime level.\n   *\n   * @default false\n   */\n  json?: boolean;\n}\nexport namespace INestiaConfig {\n  /**\n   * List of files or directories to include or exclude to specifying the NestJS\n   * controllers.\n   */\n  export interface IInput {\n    /**\n     * List of files or directories containing the NestJS controller classes.\n     */\n    include: string[];\n\n    /**\n     * List of files or directories to be excluded.\n     */\n    exclude?: string[];\n  }\n\n  /**\n   * Building `swagger.json` is also possible.\n   */\n  export interface ISwaggerConfig {\n    /**\n     * Output path of the `swagger.json`.\n     *\n     * If you've configured only directory, the file name would be the `swagger.json`.\n     * Otherwise you've configured the full path with file name and extension, the\n     * `swagger.json` file would be renamed to it.\n     */\n    output: string;\n\n    /**\n     * OpenAPI version.\n     *\n     * If you configure this property to be `2.0` or `3.0`, the newly generated\n     * `swagger.json` file would follow the specified OpenAPI version. The newly\n     * generated `swagger.json` file would be downgraded from the OpenAPI v3.1\n     * specification by {@link OpenApi.downgrade} method.\n     *\n     * @default 3.1\n     */\n    openapi?: \"2.0\" | \"3.0\" | \"3.1\";\n\n    /**\n     * API information.\n     *\n     * If omitted, `package.json` content would be used instead.\n     */\n    info?: Partial<OpenApi.IDocument.IInfo>;\n\n    /**\n     * List of server addresses.\n     */\n    servers?: OpenApi.IServer[];\n\n    /**\n     * Security schemes.\n     *\n     * When generating `swagger.json` file through `nestia`, if your controllers or\n     * theirs methods have a security key which is not enrolled in here property,\n     * it would be an error.\n     */\n    security?: Record<string, OpenApi.ISecurityScheme>;\n\n    /**\n     * List of tag names with description.\n     *\n     * It is possible to omit this property or skip some tag name even if\n     * the tag name is used in the API routes. In that case, the tag name\n     * would be used without description.\n     *\n     * Of course, if you've written a comment like `@tag {name} {description}`,\n     * you can entirely replace this property specification.\n     */\n    tags?: OpenApi.IDocument.ITag[];\n\n    /**\n     * Decompose query DTO.\n     *\n     * If you configure this property to be `true`, the query DTO would be decomposed\n     * into individual query parameters per each property. Otherwise you set it to be\n     * `false`, the query DTO would be one object type which contains all of query\n     * parameters.\n     *\n     * @default false\n     */\n    decompose?: boolean;\n\n    /**\n     * Operation ID generator.\n     *\n     * @param props Properties of the API endpoint.\n     * @returns Operation ID.\n     */\n    operationId?(props: {\n      class: string;\n      function: string;\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n      path: string;\n    }): string;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Attachment File Validation (TypeScript)\nDESCRIPTION: This snippet validates an IAttachmentFile object. It checks the types and constraints of the 'name', 'extension', and 'url' properties, including minimum/maximum lengths for name and extension, and a URL format validation using a regular expression.  Validation failures are handled by generating guard clauses with path and expected type information.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedBody.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n(null === input.name ||\n                  (\"string\" === typeof input.name &&\n                    (1 <= input.name.length ||\n                      $guard(_exceptionable, {\n                        path: _path + \".name\",\n                        expected: \"string & MinLength<1>\",\n                        value: input.name,\n                      })) &&\n                    (input.name.length <= 255 ||\n                      $guard(_exceptionable, {\n                        path: _path + \".name\",\n                        expected: \"string & MaxLength<255>\",\n                        value: input.name,\n                      }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".name\",\n                    expected:\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\n                    value: input.name,\n                  })) &&\n                (null === input.extension ||\n                  (\"string\" === typeof input.extension &&\n                    (1 <= input.extension.length ||\n                      $guard(_exceptionable, {\n                        path: _path + \".extension\",\n                        expected: \"string & MinLength<1>\",\n                        value: input.extension,\n                      })) &&\n                    (input.extension.length <= 8 ||\n                      $guard(_exceptionable, {\n                        path: _path + \".extension\",\n                        expected: \"string & MaxLength<8>\",\n                        value: input.extension,\n                      }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".extension\",\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\n                    value: input.extension,\n                  })) &&\n                ((\"string\" === typeof input.url &&\n                  (/^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/.test(\n                    input.url,\n                  ) ||\n                    $guard(_exceptionable, {\n                      path: _path + \".url\",\n                      expected: 'string & Format<\"url\">',\n                      value: input.url,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".url\",\n                    expected: '(string & Format<\"url\">)',\n                    value: input.url,\n                  }))\n```\n\n----------------------------------------\n\nTITLE: Define IBbsArticle interface Typescript\nDESCRIPTION: Defines the IBbsArticle interface with properties for id, created_at, title, body, and files, using typia for data validation. It extends IBbsArticle.IStore and utilizes typia's tags for format and length constraints.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedBody.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\nexport interface IBbsArticle extends IBbsArticle.IStore {\n  id: string & tags.Format<\"uuid\">;\n  created_at: string & tags.Format<\"date-time\">;\n}\nexport namespace IBbsArticle {\n  export interface IStore {\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\n    body: string;\n    files: IAttachmentFile[];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: WebSocket Route Implementation in Controller\nDESCRIPTION: Demonstrates how to use the WebSocketRoute decorator in a NestJS controller to define a WebSocket endpoint.  It shows how to inject WebSocketAcceptor and Driver instances using the corresponding decorators, enabling communication between the server and connected clients. The example includes the use of the Calculator service to handle calculations.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WebSocketRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { Driver, WebSocketAcceptor } from \"tgrid\";\n\nimport { ICalculator } from \"./api/structures/ICalculator\";\nimport { IListener } from \"./api/structures/IListener\";\nimport { Calculator } from \"./providers/Calculator\";\n\n@Controller(\"calculate\")\nexport class CalculateController {\n  /**\n   * Start simple calculator.\n   *\n   * Start simple calculator through WebSocket.\n   */\n  @WebSocketRoute(\"start\")\n  public async start(\n    @WebSocketRoute.Acceptor()\n    acceptor: WebSocketAcceptor<any, ICalculator, IListener>,\n    @WebSocketRoute.Driver() driver: Driver<IListener>,\n  ): Promise<void> {\n    await acceptor.accept(new Calculator(driver));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Nestia and Webpack with npm (Bash)\nDESCRIPTION: This set of commands installs nestia, ts-loader, webpack, webpack-cli, and webpack-node-externals as dev dependencies using npm.  It is necessary to manually configure webpack when bundling the NestJS project.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# SETUP NESTIA\nnpx nestia setup\n\n# INSTALL TS-LOADER & WEBPACK\nnpm install --save-dev ts-loader\nnpm install --save-dev webpack webpack-cli webpack-node-externals\n```\n\n----------------------------------------\n\nTITLE: Customizing Nestia E2E Test Setup\nDESCRIPTION: This code snippet shows how to customize the default E2E test setup generated by Nestia. It imports necessary modules, starts a NestJS application with a dynamic module, validates the server, and handles exceptions. The key customization is in how the `DynamicModule` is mounted, allowing developers to specify controllers and exclude files. The `DynamicExecutor.validate` function also allows the specification of parameters to be used in the tests.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport core from \"@nestia/core\";\nimport { DynamicExecutor } from \"@nestia/e2e\";\n\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\n\nasync function main(): Promise<void> {\n  const server: INestApplication = await NestFactory.create(\n    await core.DynamicModule.mount({\n      // follows your nestia.config.ts setting\n      controllers: {\n        input: [\"src/controllers\"],\n        exclude: [\"src/**/*.fake.ts\"],\n      },\n    }),\n  );\n  await server.listen(37_000);\n\n  const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\n    prefix: \"test\",\n    parameters: () => [\n      {\n        host: \"http://127.0.0.1:37000\",\n      },\n    ],\n  })(`${__dirname}/features`);\n  await server.close();\n\n  const exceptions: Error[] = report.executions\n    .filter((exec) => exec.error !== null)\n    .map((exec) => exec.error!);\n  if (exceptions.length === 0) {\n    console.log(\"Success\");\n    console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n  } else {\n    for (const exp of exceptions) console.log(exp);\n    console.log(\"Failed\");\n    console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n    process.exit(-1);\n  }\n}\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n```\n\n----------------------------------------\n\nTITLE: Correct Function Call with Validation\nDESCRIPTION: This TypeScript function `correctFunctionCall` validates the arguments of a function call against its schema, using `typia`. If validation fails, it triggers a retry with detailed error feedback to guide the LLM in correcting its arguments. The function takes a `FunctionCall` object, an array of `ILlmFunction` objects, and a retry function as input, and returns a Promise.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/chat.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FunctionCall } from \"pseudo\";\nimport { ILlmFunction, IValidation } from \"typia\";\n\nexport const correctFunctionCall = (p: {\n  call: FunctionCall;\n  functions: Array<ILlmFunction<\"chatgpt\">>;\n  retry: (reason: string, errors?: IValidation.IError[]) => Promise<unknown>;\n}): Promise<unknown> => {\n  // FIND FUNCTION\n  const func: ILlmFunction<\"chatgpt\"> | undefined =\n    p.functions.find((f) => f.name === p.call.name);\n  if (func === undefined) {\n    // never happened in my experience\n    return p.retry(\n      \"Unable to find the matched function name. Try it again.\",\n    );\n  }\n\n  // VALIDATE\n  const result: IValidation<unknown> = func.validate(p.call.arguments);\n  if (result.success === false) {\n    // 1st trial: 50% (gpt-4o-mini in shopping mall chatbot)\n    // 2nd trial with validation feedback: 99%\n    // 3nd trial with validation feedback again: never have failed\n    return p.retry(\n      \"Type errors are detected. Correct it through validation errors\",\n      {\n        errors: result.errors,\n      },\n    );\n  }\n  return result.data;\n}\n```\n\n----------------------------------------\n\nTITLE: Shopping Seller Authentication Decorator\nDESCRIPTION: Illustrates how to use `@SwaggerCustomizer` for authentication.  The decorator adds a security scheme to the Swagger documentation, requiring a bearer token for authorized endpoints. Relies on `ShoppingSellerProvider` for authorization logic.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\nimport { Singleton } from \"tstl\";\n\nimport { ShoppingSellerProvider } from \"../providers/shoppings/actors/ShoppingSellerProvider\";\nimport { SwaggerCustomizer } from \"@nestia/core\";\n\nexport const ShoppingSellerAuth =\n  (): ParameterDecorator =>\n  (\n    target: Object,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number\n  ): void => {\n    SwaggerCustomizer((props) => {\n      props.route.security ??= [];\n      props.route.security.push({\n        bearer: [],\n      });\n    })(target, propertyKey as string, undefined!);\n    singleton.get()(target, propertyKey, parameterIndex);\n  };\n\nconst singleton = new Singleton(() =>\n  createParamDecorator(async (_0: any, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return ShoppingSellerProvider.authorize(request);\n  })()\n);\n```\n\n----------------------------------------\n\nTITLE: BBS Article Creation Test - TypeScript\nDESCRIPTION: This test function `test_api_bbs_article_create` tests the article creation functionality of the BBS API. It creates a new article with random data, reads it back from the API, and validates that the created and read articles are identical. It uses `@nestia/e2e` for test utilities and `@ORGANIZATION/PROJECT-api` for API function calls.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/benchmark.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { v4 } from \"uuid\";\n\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\n\nexport async function test_api_bbs_article_create(\n  connection: api.IConnection,\n): Promise<void> {\n  // STORE A NEW ARTICLE\n  const stored: IBbsArticle = await api.functional.bbs.articles.create(\n    connection,\n    \"general\",\n    {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(3)(),\n      body: RandomGenerator.content(8)()(),\n      format: \"txt\",\n      files: [\n        {\n          name: \"logo\",\n          extension: \"png\",\n          url: \"https://somewhere.com/logo.png\",\n        },\n      ],\n      password: v4(),\n    },\n  );\n\n  // READ THE DATA AGAIN\n  const read: IBbsArticle = await api.functional.bbs.articles.at(\n    connection,\n    stored.section,\n    stored.id,\n  );\n  TestValidator.equals(\"created\")(stored)(read);\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Compiler Configuration\nDESCRIPTION: This JSON configuration file defines the TypeScript compiler options for the SDK package.  It includes settings for target ECMAScript version, libraries to include, module system, declaration generation, source map generation, output directory, ES module interop, strict type checking, and paths for module resolution.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/distribute.mdx#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"lib\": [\n      \"DOM\",\n      \"ES2015\"\n    ],\n    \"module\": \"commonjs\",\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"./lib\",\n    \"downlevelIteration\": true,\n    \"newLine\": \"lf\",\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true\n  },\n  \"include\": [\n    \"../../src/api\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: IBbsArticle Interface (TypeScript)\nDESCRIPTION: Defines the IBbsArticle interface and its IStore sub-interface using typia for type validation and constraints. The IBbsArticle interface represents a forum article with fields like id, writer, title, body, and created_at, including format and length validations using typia's tags.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\nexport interface IBbsArticle {\n  id: string;\n  writer: string;\n  title: string & tags.MinLength<3> & tags.MaxLength<50>;\n  body: string;\n  created_at: string & tags.Format<\"date-time\">;\n}\nexport namespace IBbsArticle {\n  export interface IStore {\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\n    body: string;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Validation and Parsing Code Example (JavaScript)\nDESCRIPTION: This JavaScript code example (automatically generated by Nestia) illustrates how the query parameters are validated and parsed to match the `IPage.IRequest` type. The code uses guards and assertions to check the input and ensure it conforms to the expected type.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\npath: _path + \".limit\",\n                    expected: '((number & Type<\"uint32\">) | undefined)',\n                    value: input.limit,\n                  }));\n              return (\n                (((\"object\" === typeof input &&\n                  null !== input &&\n                  false === Array.isArray(input)) ||\n                  $guard(true, {\n                    path: _path + \"\",\n                    expected: \"IPage.IRequest\",\n                    value: input,\n                  })) &&\n                  $ao0(input, _path + \"\", true)) ||\n                $guard(true, {\n                  path: _path + \"\",\n                  expected: \"IPage.IRequest\",\n                  value: input,\n                })\n              );\n            })(input, \"$input\", true);\n          return input;\n        })(output);\n```\n\n----------------------------------------\n\nTITLE: Nestia E2E Test Function: update BbsArticle\nDESCRIPTION: This code defines an E2E test function, `test_api_bbs_articles_update`, for updating a `BbsArticle`. It uses the `api.functional.bbs.articles.update` function to send a PUT request. Parameters such as `section`, `id` (UUID format), and input data are randomly generated using `typia.random<T>()`. The output is then validated using `typia.assert(output)`.  Customization of this function is often required to avoid logic errors due to random parameter generation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { IConnection, Primitive } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport type { Format } from \"typia/lib/tags/Format\";\n\nimport api from \"../../../../src/api\";\nimport type { IBbsArticle } from \"../../../../src/api/structures/IBbsArticle\";\n\nexport const test_api_bbs_articles_update = async (\n  connection: api.IConnection,\n): Promise<void> => {\n  const output = await api.functional.bbs.articles.update(\n    connection,\n    typia.random<string>(),\n    typia.random<string & Format<\"uuid\">>(),\n    typia.random<Primitive<IBbsArticle.IStore>>(),\n  );\n  typia.assert(output);\n};\n```\n\n----------------------------------------\n\nTITLE: Validating IBbsArticle (JavaScript)\nDESCRIPTION: This Javascript snippet contains the generated validation logic for an `IBbsArticle` interface.  It checks properties like `name`, `extension`, and `url` for specific types, lengths, and formats, utilizing regular expressions and guard clauses for validation. The functions $ao0, $io1 are generated to handle object and interface validations respectively.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedRoute.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n$guard(_exceptionable, {\n                        path: _path + \".name\",\n                        expected: \"string & MaxLength<255>\",\n                        value: input.name,\n                      })) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".name\",\n                    expected:\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\n                    value: input.name,\n                  })) &&\n                (null === input.extension ||\n                  (\"string\" === typeof input.extension &&\n                    (1 <= input.extension.length ||\n                      $guard(_exceptionable, {\n                        path: _path + \".extension\",\n                        expected: \"string & MinLength<1>\",\n                        value: input.extension,\n                      })) &&\n                    (input.extension.length <= 8 ||\n                      $guard(_exceptionable, {\n                        path: _path + \".extension\",\n                        expected: \"string & MaxLength<8>\",\n                        value: input.extension,\n                      }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".extension\",\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\n                    value: input.extension,\n                  })) &&\n                ((\"string\" === typeof input.url &&\n                  (/^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\n                    input.url,\n                  ) ||\n                    $guard(_exceptionable, {\n                      path: _path + \".url\",\n                      expected: 'string & Format<\"url\">',\n                      value: input.url,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".url\",\n                    expected: '(string & Format<\"url\">)',\n                    value: input.url,\n                  }));\n              return (\n                ((\"object\" === typeof input && null !== input) ||\n                  $guard(true, {\n                    path: _path + \"\",\n                    expected: \"IBbsArticle\",\n                    value: input,\n                  })) &&\n                  $ao0(input, _path + \"\", true)) ||\n                $guard(true, {\n                  path: _path + \"\",\n                  expected: \"IBbsArticle\",\n                  value: input,\n                })\n              );\n            })(input, \"$input\", true);\n          return input;\n```\n\n----------------------------------------\n\nTITLE: Traditional E2E Test Example (fetch)\nDESCRIPTION: Demonstrates a traditional E2E test function using the `fetch` API. It highlights the lack of type safety in older E2E testing approaches, requiring hard-coded `fetch()` calls with string literals. The example tests the creation and retrieval of a BBS article.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/why.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport { IBbsArticle } from \"@samchon/bbs-api/lib/structures/bbs/IBbsArticle\";\n\nexport const test_api_bbs_article_create = async (\n  host: string,\n): Promise<void> => {\n  // In the traditional age, E2E test function could not take advantages \n  // of type safety of the TypeScript. Instead, have to write hard-coded\n  // `fetch()` function with string literals.\n  const response: Response = await fetch(`${host}/bbs/articles`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      writer: \"someone\",\n      password: \"1234\",\n      title: \"title\",\n      body: \"content\",\n      format: \"md\",\n      files: [],\n    } satisfies IBbsArticle.ICreate),\n  });\n  const article: IBbsArticle = await response.json();\n  typia.assert(article);\n\n  const read: IBbsArticle = await (async () => {\n    const response: Response = await fetch(`${host}/bbs/articles/${article.id}`);\n    const article: IBbsArticle = await response.json();\n    return typia.assert(article);\n  })();\n  TestValidator.equals(\"written\")(article)(read);\n};\n```\n\n----------------------------------------\n\nTITLE: Setting up Nestia and Webpack with yarn (Bash)\nDESCRIPTION: This set of commands installs nestia, ts-loader, webpack, webpack-cli, and webpack-node-externals as dev dependencies using yarn.  It is necessary to manually configure webpack when bundling the NestJS project.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# SETUP NESTIA\nnpx nestia setup --manager yarn\n\n# INSTALL TS-LOADER & WEBPACK\nyarn add -D ts-loader\nyarn add -D webpack webpack-cli webpack-node-externals\n```\n\n----------------------------------------\n\nTITLE: Traditional Unit Test Example\nDESCRIPTION: Illustrates a traditional unit test function. This example leverages type safety by directly importing modules. It tests the creation and retrieval of a BBS article using `BbsArticleProvider`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/why.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport { IBbsArticle } from \"@samchon/bbs-api/lib/structures/bbs/IBbsArticle\";\n\nimport { BbsArticleProvider } from \"../../../../src/providers/bbs/BbsArticleProvider\";\n\nexport const test_provider_bbs_article_create = async (): Promise<void> => {\n  // Besides, unit test could take advantages of type safety.\n  const article: IBbsArticle = await BbsArticleProvider.write({\n    writer: \"someone\",\n    password: \"1234\",\n    title: \"title\",\n    body: \"content\",\n    format: \"md\",\n    files: [],\n  });\n  typia.assert(article);\n\n  // Therefore, unit test had been loved in the past era\n  const read: IBbsArticle = await BbsArticleProvider.at(article.id);\n  typia.assert(read);\n  TestValidator.equals(\"written\")(article)(read);\n};\n```\n\n----------------------------------------\n\nTITLE: Upgrading NestJS Application for WebSocket Support\nDESCRIPTION: This code snippet shows how to upgrade a NestJS application to be compatible with the WebSocket protocol using `WebSocketAdaptor.upgrade()`. It is required to enable WebSocket communication for the Agentica chatbot.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/chat.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst app: INestApplication = await NestFactory.create(AppModule);\nawait WebSocketAdaptor.upgrade(app);\n```\n\n----------------------------------------\n\nTITLE: API Article Index Search Test\nDESCRIPTION: Tests the indexing and searching of BBS articles via the API. It generates 100 articles, retrieves all data, and then performs search operations on title and writer fields, validating the search results against the generated data. Uses ArrayUtil, RandomGenerator, and TestValidator from @nestia/e2e.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/why.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function test_api_bbs_article_index_search(\n  connection: api.IConnection,\n): Promise<void> {\n  // GENERATE 100 ARTICLES\n  const section: string = \"general\";\n  const articles: IBbsArticle[] = await ArrayUtil.asyncRepeat(100)(() =>\n    api.functional.bbs.articles.create(connection, section, {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(4)(),\n      body: RandomGenerator.content(3)()(),\n      format: \"txt\",\n      files: [],\n      password: RandomGenerator.alphabets(8),\n    }),\n  );\n\n  // GET ENTIRE DATA\n  const total: IPage<IBbsArticle.ISummary> =\n    await api.functional.bbs.articles.index(connection, section, {\n      limit: articles.length,\n      sort: [\"-created_at\"],\n    });\n\n  // PREPARE SEARCH FUNCTION\n  const search = TestValidator.search(\"BbsArticleProvider.index()\")(\n    async (input: IBbsArticle.IRequest.ISearch) => {\n      const page: IPage<IBbsArticle.ISummary> =\n        await api.functional.bbs.articles.index(connection, section, {\n          limit: articles.length,\n          search: input,\n          sort: [\"-created_at\"],\n        });\n      return page.data;\n    },\n  )(total.data, 10);\n\n  // SEARCH TITLE\n  await search({\n    fields: [\"title\"],\n    values: (article) => [article.title],\n    request: ([title]) => ({ title }),\n    filter: (article, [title]) => article.title.includes(title),\n  });\n\n  // SEARCH WRITER\n  await search({\n    fields: [\"writer\"],\n    values: (article) => [article.writer],\n    request: ([writer]) => ({ writer }),\n    filter: (article, [writer]) => article.writer.includes(writer),\n  });\n\n  // SEARCH BOTH OF THEM\n  await search({\n    fields: [\"title\", \"writer\"],\n    values: (article) => [article.title, article.writer],\n    request: ([title, writer]) => ({ title, writer }),\n    filter: (article, [title, writer]) =>\n      article.title.includes(title) && article.writer.includes(writer),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nestia for Clone Mode\nDESCRIPTION: This snippet demonstrates how to configure Nestia to clone DTO structures into the 'structures' directory. Setting `clone: true` in the `nestia.config.ts` file enables this functionality.  The `input` function defines how Nestia obtains the NestJS application instance, and the `output` property specifies the output directory for the generated API files.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/index.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\n \nimport { YourModule } from \"./src/YourModule\";\n \nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  clone: true,\n  distribute: \"packages/api\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Setting up Nestia using pnpm (Bash)\nDESCRIPTION: This command initiates the Nestia setup wizard using pnpm. This configures nestia in an existing project. During the setup, you will be prompted to configure runtime swagger.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia setup --manager pnpm\n```\n\n----------------------------------------\n\nTITLE: e2e Test for Advanced Calculator (TypeScript)\nDESCRIPTION: Performs an end-to-end test of the advanced calculator functionality using `@nestia/e2e` and `@samchon/calculator-api`. It establishes a WebSocket connection, invokes calculator methods, and validates the results and event emissions.  It depends on `uuid` for generating unique identifiers and application-specific interfaces.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TestValidator } from \"@nestia/e2e\";\nimport api from \"@samchon/calculator-api/lib/index\";\nimport { IListener } from \"@samchon/calculator-api/lib/structures/IListener\";\nimport { IMemo } from \"@samchon/calculator-api/lib/structures/IMemo\";\nimport { v4 } from \"uuid\";\n\nexport const test_api_calculate_advance = async (\n  connection: api.IConnection,\n): Promise<void> => {\n  const stack: IListener.IEvent[] = [];\n  const listener: IListener = {\n    on: (event) => stack.push(event),\n  };\n\n  const id: string = v4();\n  const memo: IMemo = {\n    title: \"test\",\n    description: null,\n    time: Date.now(),\n  };\n  const { connector, driver } = await api.functional.calculate.advance(\n    {\n      ...connection,\n      headers: { precision: 2 },\n    },\n    id,\n    memo,\n    listener,\n  );\n  try {\n    TestValidator.equals(\"id\")(await driver.getId())(id);\n    TestValidator.equals(\"memo\")(await driver.getMemo())(memo);\n    TestValidator.equals(\"precision\")(await driver.getPrecision())(2);\n    TestValidator.equals(\"plus\")(await driver.plus(1, 2))(3);\n    TestValidator.equals(\"minus\")(await driver.minus(1, 2))(-1);\n    TestValidator.equals(\"multiply\")(await driver.multiply(0.01, 0.02))(0);\n    TestValidator.equals(\"divide\")(await driver.divide(1, 3))(0.33);\n    TestValidator.equals(\"events\")(stack)([\n      { type: \"plus\", x: 1, y: 2, z: 3 },\n      { type: \"minus\", x: 1, y: 2, z: -1 },\n      { type: \"multiply\", x: 0.01, y: 0.02, z: 0 },\n      { type: \"divide\", x: 1, y: 3, z: 0.33 },\n    ]);\n  } catch (exp) {\n    throw exp;\n  } finally {\n    await connector.close();\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Type Checking with Special Tags (TypeScript)\nDESCRIPTION: Defines an interface `SpecialTag` with various properties using typia's `tags` for advanced validation constraints.  It uses `typia.createIs<SpecialTag>()` to create a type checker function. This example demonstrates how to enforce specific formats, ranges, and lengths on data types.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedRoute.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\n\ninterface SpecialTag {\n  int32: number & tags.Type<\"int32\">;\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n  minLength: string & tags.MinLength<3>;\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n  date: null | (string & tags.Format<\"date\">);\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\n  uuids: Array<string & tags.Format<\"uuid\">> &\n    tags.MinItems<3> &\n    tags.MaxItems<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Distributing Swagger: Generated File\nDESCRIPTION: Shows how to load a pre-generated `swagger.json` file and serve it using `SwaggerModule`.  Requires the `swagger.json` file to be generated beforehand and accessible in the project.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NestFactory } from \"@nestjs/core\";\nimport { SwaggerModule } from \"@nestjs/swagger\";\nimport fs from \"fs\";\n\nconst main = async (): Promise<void> => {\n  const app = await NestFactory.create(ApplicationModule);\n  const docs = require(\"...write swagger.json path\");\n  docs.servers = [{ url: \"write your server URL\" }];\n  SwaggerModule.setup(\"swagger\", app, docs);\n\n  await app.listen(8080);\n}\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Defining Controller Methods with Swagger Tags in Nestia\nDESCRIPTION: This TypeScript code defines a NestJS controller with methods that use Swagger tags to control their documentation. The `@deprecated`, `@internal`, `@summary`, `@tag`, and `@security` tags are used to modify the generated Swagger output. The `@TypedRoute` decorators define the HTTP methods and routes.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedBody, TypedParam, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { ApiSecurity } from \"@nestjs/swagger\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles/:section\")\nexport class BbsArticlesController {\n  /**\n   * Would be shown without any mark.\n   *\n   * @param section Section code\n   * @param input Content to store\n   * @returns Newly archived article\n   *\n   * @tag public Some description describing public group...\n   * @summary Public API\n   * @security bearer\n   * @security oauth2 read write\n   */\n  @TypedRoute.Post()\n  public async store(\n    @TypedParam(\"section\") section: string,\n    @TypedBody() input: IBbsArticle.IStore,\n  ): Promise<IBbsArticle> {\n    return {\n      ...typia.random<IBbsArticle>(),\n      ...input,\n      section,\n    };\n  }\n\n  /**\n   * Deprecated API.\n   *\n   * Would be marked as \"deprecated\".\n   *\n   * For reference, top sentence \"Deprecated API.\" can replace the `@summary` tag.\n   *\n   * @param section Section code\n   * @param id Target article ID\n   * @param input Content to update\n   * @returns Updated content\n   *\n   * @deprecated\n   * @operationId updateArticle\n   * @security basic\n   * @security bearer\n   */\n  @TypedRoute.Put(\":id\")\n  public async update(\n    @TypedParam(\"section\") section: string,\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n    @TypedBody() input: IBbsArticle.IStore,\n  ): Promise<IBbsArticle> {\n    return {\n      ...typia.random<IBbsArticle>(),\n      ...input,\n      id,\n      section,\n    };\n  }\n\n  /**\n   * Would not be shown.\n   *\n   * @internal\n   */\n  @ApiSecurity(\"custom\") // LEGACY DECORATOR ALSO CAN BE USED\n  @TypedRoute.Delete(\":id\")\n  public erase(\n    @TypedParam(\"section\") section: string,\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n  ): void {\n    section;\n    id;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TypedQuery Method Decorators (TypeScript)\nDESCRIPTION: Defines the TypedQuery namespace with route decorators for handling form-urlencoded data in Nestia. These decorators are used to define API endpoints that accept and process form data.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace TypedQuery {\n  export function Get(path?: string): MethodDecorator;\n  export function Post(path?: string): MethodDecorator;\n  export function Put(path?: string): MethodDecorator;\n  export function Patch(path?: string): MethodDecorator;\n  export function Delete(path?: string): MethodDecorator;\n}\n```\n\n----------------------------------------\n\nTITLE: Create BbsArticlesController Typescript\nDESCRIPTION: Defines a NestJS controller `BbsArticlesController` that handles the creation of BBS articles. It uses `@TypedFormData.Body` to automatically parse and validate the form data using the `IBbsArticleCreate` interface and Multer for file handling.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedFormData.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedFormData, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport Multer from \"multer\";\n\nimport { IBbsArticleCreate } from \"./IBbsArticleCreate\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  @TypedRoute.Post()\n  public async create(\n    @TypedFormData.Body(() => Multer()) input: IBbsArticleCreate,\n  ): Promise<void> {\n    input;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: IBbsArticle.ISummary Interface (TypeScript)\nDESCRIPTION: Defines the interface for a summary of a BbsArticle with specific type constraints and validation through 'typia' library.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\nexport namespace IBbsArticle {\n  export interface ISummary {\n    id: string & tags.Format<\"uuid\">;\n    writer: string;\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\n    created_at: string & tags.Format<\"date-time\">;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Setup with NX (pnpm)\nDESCRIPTION: This command initializes Nestia in an NX monorepo project using pnpm. The `--manager pnpm` flag specifies the package manager to be used.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia setup --manager pnpm\n```\n\n----------------------------------------\n\nTITLE: Configure npm prepare Script\nDESCRIPTION: This configures the `prepare` script in `package.json` to run `ts-patch install` and `typia patch`. `ts-patch install` applies TypeScript compiler plugins, and `typia patch` restores JSDocComment parsing for TypeScript v5.3 and later.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_26\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"prepare\": \"ts-patch install && typia patch\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Special Tag Interface with Typia - TypeScript\nDESCRIPTION: This TypeScript snippet defines an interface `SpecialTag` with various properties that use `typia`'s `tags` for enhanced validation. It includes examples of `int32`, `range`, `minLength`, `pattern`, `date`, `ip`, and `uuids` with specific validation constraints.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\n\ninterface SpecialTag {\n  int32: number & tags.Type<\"int32\">;\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n  minLength: string & tags.MinLength<3>;\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n  date: null | (string & tags.Format<\"date\">);\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\n  uuids: Array<string & tags.Format<\"uuid\">> &\n    tags.MinItems<3> &\n    tags.MaxItems<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Top-Level IBbsArticle.ICreate Validation\nDESCRIPTION: This code performs a top-level validation for the IBbsArticle.ICreate object. It checks if the input is an object and then calls the $ao0 function to validate its properties. If validation fails, it throws a guard exception.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/pure.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nreturn (\n                (((\"object\" === typeof input && null !== input) ||\n                  $guard(true, {\n                    path: _path + \"\",\n                    expected: \"IBbsArticle.ICreate\",\n                    value: input,\n                  })) &&\n                  $ao0(input, _path + \"\", true)) ||\n                $guard(true, {\n                  path: _path + \"\",\n                  expected: \"IBbsArticle.ICreate\",\n                  value: input,\n                })\n              );\n```\n\n----------------------------------------\n\nTITLE: Calculator Service Definition\nDESCRIPTION: Defines the Calculator service, implementing the ICalculator interface. It demonstrates how to use the Driver<IListener> to send events to the client when calculations are performed. The service exposes methods for basic arithmetic operations (plus, minus, multiply, divide).\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Driver } from \"tgrid\";\n\nimport { ICalculator } from \"../api/structures/ICalculator\";\nimport { IListener } from \"../api/structures/IListener\";\n\nexport class Calculator implements ICalculator {\n  public constructor(private readonly listener: Driver<IListener>) {}\n\n  public plus(x: number, y: number): number {\n    const z: number = x + y;\n    this.listener.on({ type: \"plus\", x, y, z }).catch(() => {});\n    return z;\n  }\n\n  public minus(x: number, y: number): number {\n    const z: number = x - y;\n    this.listener.on({ type: \"minus\", x, y, z }).catch(() => {});\n    return z;\n  }\n\n  public multiply(x: number, y: number): number {\n    const z: number = x * y;\n    this.listener.on({ type: \"multiply\", x, y, z }).catch(() => {});\n    return z;\n  }\n\n  public divide(x: number, y: number): number {\n    const z: number = x / y;\n    this.listener.on({ type: \"divide\", x, y, z }).catch(() => {});\n    return z;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: EncryptedRoute Method Decorators (TypeScript)\nDESCRIPTION: Defines method decorators (Get, Post, Put, Patch, Delete) within the EncryptedRoute namespace. These decorators are used to mark controller methods for encrypted responses using AES-128/256 CBC algorithm.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedRoute.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace EncryptedRoute {\n  export function Get(path?: string): MethodDecorator;\n  export function Post(path?: string): MethodDecorator;\n  export function Put(path?: string): MethodDecorator;\n  export function Patch(path?: string): MethodDecorator;\n  export function Delete(path?: string): MethodDecorator;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Article Interface IBbsArticle in TypeScript\nDESCRIPTION: Defines the `IBbsArticle` interface and its nested interfaces `ICreate` and `IUpdate` to represent an article entity in a Bulletin Board System. It utilizes `typia` for data validation and formatting.  This example demonstrates the namespace strategy in Nestia.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\n/**\n * Article entity.\n *\n * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\n */\nexport interface IBbsArticle extends IBbsArticle.ICreate {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n \n  /**\n   * Creation time of the article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n \n  /**\n   * Last updated time of the article.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n}\nexport namespace IBbsArticle {\n  /**\n   * Information of the article to create.\n   */\n  export interface ICreate {\n    /**\n     * Title of the article.\n     *\n     * Representative title of the article.\n     */\n    title: string;\n \n    /**\n     * Content body.\n     *\n     * Content body of the article writtn in the markdown format.\n     */\n    body: string;\n \n    /**\n     * Thumbnail image URI.\n     *\n     * Thumbnail image URI which can represent the article.\n     *\n     * If configured as `null`, it means that no thumbnail image in the article.\n     */\n    thumbnail:\n      | null\n      | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\n  }\n \n  /**\n   * Information of the article to update.\n   *\n   * Only the filled properties will be updated.\n   */\n  export type IUpdate = Partial<ICreate>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Special Interface with typia Tags in TypeScript\nDESCRIPTION: Defines a TypeScript interface named `Special` using typia tags to specify JSON schema properties such as `type` (deprecated), `internal` (internal), `hidden` (hidden), `number` (range constraints), `string` (length constraints), `pattern` (regex), `format` (date-time), and `array` (element type and minimum items).\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\ninterface Special {\n  /**\n   * Deprecated tags are just used for marking.\n   *\n   * @title Unsigned integer\n   * @deprecated\n   */\n  type: number & tags.Type<\"int32\">;\n \n  /**\n   * Internal tagged property never be shown in JSON schema.\n   *\n   * It even doesn't be shown in other `typia` functions like `assert<T>()`.\n   *\n   * @internal\n   */\n  internal: number[];\n \n  /**\n   * Hidden tagged property never be shown in JSON schema.\n   *\n   * However, it would be shown in other `typia` functions like `stringify<T>()`.\n   *\n   * @hidden\n   */\n  hidden: boolean;\n \n  /**\n   * You can limit the range of number.\n   *\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  number?: number;\n \n  /**\n   * You can limit the length of string.\n   *\n   * Also, multiple range conditions are also possible.\n   */\n  string: string &\n    (\n      | (tags.MinLength<3> & tags.MaxLength<24>)\n      | (tags.MinLength<40> & tags.MaxLength<100>)\n    );\n \n  /**\n   * You can limit the pattern of string.\n   *\n   * @pattern ^[a-z]+$\n   */\n  pattern: string;\n \n  /**\n   * You can limit the format of string.\n   *\n   * @format date-time\n   */\n  format: string | null;\n \n  /**\n   * In the Array case, possible to restrict its elements.\n   */\n  array: Array<string & tags.Format<\"uuid\">> & tags.MinItems<3>;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript validation function for SpecialTag\nDESCRIPTION: This JavaScript code is the compiled output from the TypeScript `SpecialTag` interface. It represents the validation logic generated by `typia.createIs<SpecialTag>()`. It checks the type and format of each property according to the tags specified in the TypeScript interface, including numerical ranges, string lengths, regular expression patterns, and date/IP/UUID formats.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedHeaders.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSpecialTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkSpecialTag = (input) => {\n  const $io0 = (input) =>\n    \"number\" === typeof input.int32 &&\n    Math.floor(input.int32) === input.int32 &&\n    -2147483648 <= input.int32 &&\n    input.int32 <= 2147483647 &&\n    (undefined === input.range ||\n      (\"number\" === typeof input.range &&\n        19 < input.range &&\n        input.range <= 100)) &&\n    \"string\" === typeof input.minLength &&\n    3 <= input.minLength.length &&\n    \"string\" === typeof input.pattern &&\n    /^[a-z]+$/.test(input.pattern) &&\n    (null === input.date ||\n      (\"string\" === typeof input.date &&\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\n    \"string\" === typeof input.ip &&\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\n      input.ip,\n    ) ||\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\n        input.ip,\n      )) &&\n    Array.isArray(input.uuids) &&\n    3 <= input.uuids.length &&\n    input.uuids.length <= 100 &&\n    input.uuids.every(\n      (elem) =>\n        \"string\" === typeof elem &&\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n          elem,\n        ),\n    );\n  return \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkSpecialTag = checkSpecialTag;\n```\n\n----------------------------------------\n\nTITLE: BbsArticlesController with TypedQuery (TypeScript)\nDESCRIPTION: Implements a NestJS controller (BbsArticlesController) with a POST endpoint that uses `@TypedQuery.Post()` to handle form-urlencoded data. It takes an IBbsArticle.IStore object as input and returns an IBbsArticle object, demonstrating the use of TypedQuery decorators for defining form-urlencoded API endpoints.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedQuery } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\n\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  @TypedQuery.Post()\n  public async store(\n    @TypedQuery.Body() body: IBbsArticle.IStore,\n  ): Promise<IBbsArticle> {\n    return {\n      id: \"00000000-0000-0000-0000-000000000000\",\n      writer: \"Samchon\",\n      title: body.title,\n      body: body.body,\n      created_at: new Date().toISOString(),\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: NestJS Module Setup for Nestia Editor\nDESCRIPTION: This TypeScript snippet shows how to integrate the Nestia Editor into a NestJS application using `NestiaEditorModule.setup()`. It requires `@nestia/editor` and `@nestjs/swagger`. It configures the editor with a path, Swagger document URL, package name, and simulation/e2e options.  The swagger path must point to a valid swagger document.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/editor.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { NestiaEditorModule } from \"@nestia/editor/lib/NestiaEditorModule\";\nimport { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\n\nimport { AppModule } from './app.module';\n\nconst bootstrap = async (): Promise<void> => {\n  const app = await NestFactory.create(AppModule);\n  const config = new DocumentBuilder()\n    .setTitle('Cats example')\n    .setDescription('The cats API description')\n    .setVersion('1.0')\n    .addTag('cats')\n    .build();\n  const documentFactory = () => SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api', app, documentFactory)\n\n  await NestiaEditorModule.setup({\n    path: \"editor\",\n    application: app,\n    swagger: \"/api-json\",\n    package: \"your-package-name\",\n    simulate: true,\n    e2e: true,\n  });\n  await app.listen(3000);\n};\nbootstrap().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Compiled BbsArticlesController (JavaScript)\nDESCRIPTION: The compiled JavaScript version of the BbsArticlesController, showing how the TypeScript code is transformed into JavaScript, including decorators and type assertions.  Includes the logic for validating the structure and types of the input.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __decorate =\n  (this && this.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nvar __metadata =\n  (this && this.__metadata) ||\n  function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n      return Reflect.metadata(k, v);\n  };\nvar __param =\n  (this && this.__param) ||\n  function (paramIndex, decorator) {\n    return function (target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\nvar __awaiter =\n  (this && this.__awaiter) ||\n  function (thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P\n        ? value\n        : new P(function (resolve) {\n            resolve(value);\n          });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done\n          ? resolve(result.value)\n          : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\n  index(query) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        pagination: {\n          current: (_a = query.page) !== null && _a !== void 0 ? _a : 1,\n          limit: (_b = query.limit) !== null && _b !== void 0 ? _b : 100,\n          records: 0,\n          pages: 0,\n        },\n        data: [],\n      };\n    });\n  }\n};\nexports.BbsArticlesController = BbsArticlesController;\n__decorate(\n  [\n    core_1.TypedRoute.Get({\n      type: \"assert\",\n      assert: (input) => {\n        const assert = (input) => {\n          const __is = (input) => {\n            const $io0 = (input) =>\n              Array.isArray(input.data) &&\n              input.data.every(\n                (elem) =>\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\n              ) &&\n              \"object\" === typeof input.pagination &&\n              null !== input.pagination &&\n              \"number\" === typeof input.pagination.current &&\n              Math.floor(input.pagination.current) ===\n                input.pagination.current &&\n              0 <= input.pagination.current &&\n              input.pagination.current <= 4294967295 &&\n              \"number\" === typeof input.pagination.limit &&\n              Math.floor(input.pagination.limit) === input.pagination.limit &&\n              0 <= input.pagination.limit &&\n              input.pagination.limit <= 4294967295 &&\n              \"number\" === typeof input.pagination.records &&\n              Math.floor(input.pagination.records) ===\n                input.pagination.records &&\n              0 <= input.pagination.records &&\n              input.pagination.records <= 4294967295 &&\n              \"number\" === typeof input.pagination.pages &&\n              Math.floor(input.pagination.pages) === input.pagination.pages &&\n              0 <= input.pagination.pages &&\n              input.pagination.pages <= 4294967295;\n            const $io1 = (input) =>\n              \"string\" === typeof input.id &&\n              /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n                input.id,\n              ) &&\n              \"string\" === typeof input.writer &&\n              \"string\" === typeof input.title &&\n              3 <= input.title.length &&\n              input.title.length <= 50 &&\n              \"string\" === typeof input.created_at &&\n              !isNaN(new Date(input.created_at).getTime());\n            return \"object\" === typeof input && null !== input && $io0(input);\n          };\n          if (false === __is(input))\n            ((input, _path, _exceptionable = true) => {\n              const $guard = core_1.TypedRoute.Get.guard;\n              const $ao0 = (input, _path, _exceptionable = true) =>\n                (((Array.isArray(input.data) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".data\",\n                    expected: \"Array<IBbsArticle.ISummary>\",\n                    value: input.data,\n                  })) &&\n                  input.data.every(\n                    (elem, _index1) =>\n                      (((\"object\" === typeof elem && null !== elem) ||\n                        $guard(_exceptionable, {\n                          path: _path + \".data[\" + _index1 + \"]\",\n                          expected: \"IBbsArticle.ISummary\",\n                          value: elem,\n                        })) &&\n                        $ao1(\n                          elem,\n                          _path + \".data[\" + _index1 + \"]\",\n                          true && _exceptionable,\n                        )) ||\n                      $guard(_exceptionable, {\n                        path: _path + \".data[\" + _index1 + \"]\",\n                        expected: \"IBbsArticle.ISummary\",\n                        value: elem,\n                      }),\n                  )) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".data\",\n                    expected: \"Array<IBbsArticle.ISummary>\",\n                    value: input.data,\n                  })) &&\n                ((((\"object\" === typeof input.pagination &&\n                  null !== input.pagination) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".pagination\",\n                    expected: \"IPage.IPagination\",\n                    value: input.pagination,\n                  })) &&\n                  $ao2(\n                    input.pagination,\n                    _path + \".pagination\",\n                    true && _exceptionable,\n                  )) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".pagination\",\n                    expected: \"IPage.IPagination\",\n                    value: input.pagination,\n                  }));\n              const $ao1 = (input, _path, _exceptionable = true) =>\n                ((\"string\" === typeof input.id &&\n                  (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n                    input.id,\n                  ) ||\n                    $guard(_exceptionable, {\n                      path: _path + \".id\",\n\n```\n\n----------------------------------------\n\nTITLE: TypedBody Decorator Definition in Nestia Core\nDESCRIPTION: Defines the `@TypedBody()` decorator function within the Nestia core library. It's a parameter decorator that can be used to parse and validate request bodies, providing type safety and improved performance compared to the standard NestJS `@Body()` decorator.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedBody.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport function TypedBody(): ParameterDecorator;\n```\n\n----------------------------------------\n\nTITLE: IPage Interface (TypeScript)\nDESCRIPTION: Defines the structure for paginated data, including interfaces for request parameters and pagination metadata, leveraging 'typia' for type constraints.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\nexport interface IPage<T> {\n  data: T[];\n  pagination: IPage.IPagination;\n}\nexport namespace IPage {\n  /**\n   * Page request data\n   */\n  export interface IRequest {\n    page?: number & tags.Type<\"uint32\">;\n    limit?: number & tags.Type<\"uint32\">;\n  }\n  /**\n   * Page information.\n   */\n  export interface IPagination {\n    current: number & tags.Type<\"uint32\">;\n    limit: number & tags.Type<\"uint32\">;\n    records: number & tags.Type<\"uint32\">;\n    pages: number & tags.Type<\"uint32\">;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Servant Configuration\nDESCRIPTION: Configures the servant process for dynamic benchmarking using DynamicBenchmarker.servant(). It defines the connection details to the API, location of the test features, parameters for the test functions, and a prefix for the test API functions. Catches any errors and exits the process.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/why.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nDynamicBenchmarker.servant({\n  connection: {\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n  },\n  location: `${__dirname}/../features`,\n  parameters: (connection) => [connection],\n  prefix: \"test_api_\",\n}).catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n```\n\n----------------------------------------\n\nTITLE: Define headers DTO with type restrictions (TypeScript)\nDESCRIPTION: This TypeScript code defines an interface `SomeHeadersDto` to represent HTTP headers. It demonstrates the allowed and disallowed types for header properties when using `@TypedHeaders()`. The code highlights restrictions on union types, nullable types, and the use of specific types for certain header names like `Set-Cookie`, `Authorization`, etc.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedHeaders.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SomeHeadersDto {\n  //----\n  // ATOMIC TYPES\n  //----\n  // ALLOWED\n  boolean: boolean;\n  number: number;\n  string: string;\n  bigint: bigint;\n  optional_number?: number;\n  nullable_string: string | null;\n  literal_union: \"A\" | \"B\" | \"C\" | \"D\";\n\n  // NOT ALLOWED\n  mixed_union: string | number | boolean;\n  mixed_literal: \"A\" | \"B\" | 3;\n\n  //----\n  // ARRAY TYPES\n  //----\n  // ALLOWED\n  nullable_element_array: (string | null)[];\n  string_array: string[];\n  number_array: number[];\n  literal_union_array: (\"A\" | \"B\" | \"C\")[];\n  literal_tuple: [\"A\", \"B\", \"C\"];\n\n  // NOT ALLOWED\n  optional_element_array: (string | undefined)[];\n  optional_array: string[] | undefined;\n  nullable_array: string[] | null;\n  union_atomic_array: (string | number)[];\n  mixed_literal_array: (\"A\", \"B\", 3)[];\n  mixed_tuple: [\"A\", \"B\", 3];\n\n  //----\n  // SPECIAL CASES\n  //----\n  // MUST BE ARRAY\n  \"Set-Cookie\": string[];\n\n  // MUST BE ATOMIC\n  Accept: string;\n  Authorization: string;\n\n  // NOT ALLOWED - MUST BE ATOMIC\n  referer: string[];\n  age: number[];\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled ParametersController JavaScript\nDESCRIPTION: JavaScript code showing the compiled ParametersController with TypedParam decorators. Demonstrates how the TypedParam decorator is converted into JavaScript.  It showcases the usage of __decorate, __param, and __metadata to apply the TypedParam decorator and define parameter types.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedParam.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __decorate =\n  (this && this.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nvar __metadata =\n  (this && this.__metadata) ||\n  function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n      return Reflect.metadata(k, v);\n  };\nvar __param =\n  (this && this.__param) ||\n  function (paramIndex, decorator) {\n    return function (target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\nvar __awaiter =\n  (this && this.__awaiter) ||\n  function (thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P\n        ? value\n        : new P(function (resolve) {\n            resolve(value);\n          });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done\n          ? resolve(result.value)\n          : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParametersController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet ParametersController = class ParametersController {\n  uint32(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return value;\n    });\n  }\n  string(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return value;\n    });\n  }\n  uuid(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return value;\n    });\n  }\n};\nexports.ParametersController = ParametersController;\n__decorate(\n  [\n    (0, common_1.Get)(\"uint32/:value\"),\n    __param(\n      0,\n      (0, core_1.TypedParam)(\"value\", {\n        name: '((number & Type<\"uint32\">) | null)',\n        is: (input) => {\n          return (\n            null === input ||\n            (\"number\" === typeof input &&\n              Math.floor(input) === input &&\n              0 <= input &&\n              input <= 4294967295)\n          );\n        },\n        cast: (str) => (\"null\" === str ? null : Number(str)),\n      }),\n    ),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", Promise),\n  ],\n  ParametersController.prototype,\n  \"uint32\",\n  null,\n);\n__decorate(\n  [\n    (0, common_1.Get)(\"string/:value\"),\n    __param(\n      0,\n      (0, core_1.TypedParam)(\"value\", {\n        name: \"string\",\n        is: (input) => {\n          return \"string\" === typeof input;\n        },\n        cast: (str) => str,\n      }),\n    ),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [String]),\n    __metadata(\"design:returntype\", Promise),\n  ],\n  ParametersController.prototype,\n  \"string\",\n  null,\n);\n__decorate(\n  [\n    (0, common_1.Get)(\"uuid/:value\"),\n    __param(\n      0,\n      (0, core_1.TypedParam)(\"value\", {\n        name: '(string & Format<\"uuid\">)',\n        is: (input) => {\n          return (\n            \"string\" === typeof input &&\n            /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n              input,\n            )\n          );\n        },\n        cast: (str) => str,\n      }),\n    ),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", Promise),\n  ],\n  ParametersController.prototype,\n  \"uuid\",\n  null,\n);\nexports.ParametersController = ParametersController = __decorate(\n  [(0, common_1.Controller)(\"parameters\")],\n  ParametersController,\n);\n```\n\n----------------------------------------\n\nTITLE: Article Creation Description in Markdown\nDESCRIPTION: Provides a markdown description of the `IBbsArticle.ICreate` type, emphasizing its purpose and relationship to the parent `IBbsArticle` type. This leverages Nestia's namespace strategy for improved LLM application schema generation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\nInformation of the article to create.\n \n------------------------------\n \nDescription of the current {@link IBbsArticle.ICreate} type:\n \nInformation of the article to create.\n \n> Description of the parent {@link IBbsArticle} type: Article entity.\n> \n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System\n```\n\n----------------------------------------\n\nTITLE: Create BbsArticlesController Javascript\nDESCRIPTION: JavaScript version of the `BbsArticlesController` created from the TypeScript file. This file demonstrates how Nestia handles form data validation, file uploads, and request handling with the NestJS framework.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedFormData.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __decorate =\n  (this && this.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nvar __metadata =\n  (this && this.__metadata) ||\n  function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n      return Reflect.metadata(k, v);\n  };\nvar __param =\n  (this && this.__param) ||\n  function (paramIndex, decorator) {\n    return function (target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\nvar __awaiter =\n  (this && this.__awaiter) ||\n  function (thisArg, _arguments, P, generator {\n    function adopt(value) {\n      return value instanceof P\n        ? value\n        : new P(function (resolve) {\n            resolve(value);\n          });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done\n          ? resolve(result.value)\n          : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\n  create(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      input;\n    });\n  }\n};\nexports.BbsArticlesController = BbsArticlesController;\n__decorate(\n  [\n    core_1.TypedRoute.Post({\n      type: \"assert\",\n      assert: (input) => {\n        const assert = (input) => {\n          const __is = (input) => {\n            return null !== input && undefined === input;\n          };\n          if (false === __is(input))\n            ((input, _path, _exceptionable = true) => {\n              const $guard = core_1.TypedRoute.Post.guard;\n              return (\n                (null !== input ||\n                  $guard(true, {\n                    path: _path + \"\",\n                    expected: \"undefined\",\n                    value: input,\n                  })) &&\n                (undefined === input ||\n                  $guard(true, {\n                    path: _path + \"\",\n                    expected: \"undefined\",\n                    value: input,\n                  }))\n              );\n            })(input, \"$input\", true);\n          return input;\n        };\n        const stringify = (input) => {\n          return undefined;\n        };\n        return stringify(assert(input));\n      },\n    }),\n    __param(\n      0,\n      core_1.TypedFormData.Body({\n        files: [\n          {\n            name: \"thumbnail\",\n            limit: 1,\n          },\n          {\n            name: \"files\",\n            limit: null,\n          },\n        ],\n        validator: {\n          type: \"assert\",\n          assert: (input) => {\n            const decode = (input) => {\n              var _a;\n              const $string = core_1.TypedFormData.Body.string;\n              const $file = core_1.TypedFormData.Body.file;\n              const output = {\n                title: $string(input.get(\"title\")),\n                body: $string(input.get(\"body\")),\n                thumbnail:\n                  (_a = $file(input.get(\"thumbnail\"))) !== null && _a !== void 0\n                    ? _a\n                    : undefined,\n                files: input.getAll(\"files\").map((elem) => $file(elem)),\n                tags: input.getAll(\"tags\").map((elem) => $string(elem)),\n              };\n              return output;\n            };\n            const assert = (input) => {\n              const __is = (input) => {\n                const $io0 = (input) =>\n                  \"string\" === typeof input.title &&\n                  (null === input.body || \"string\" === typeof input.body) &&\n                  (undefined === input.thumbnail ||\n                    input.thumbnail instanceof File) &&\n                  Array.isArray(input.files) &&\n                  input.files.every((elem) => elem instanceof File) &&\n                  Array.isArray(input.tags) &&\n                  input.tags.every((elem) => \"string\" === typeof elem);\n                return (\n                  \"object\" === typeof input && null !== input && $io0(input)\n                );\n              };\n              if (false === __is(input))\n                ((input, _path, _exceptionable = true) => {\n                  const $guard = core_1.TypedFormData.Body.guard;\n                  const $ao0 = (input, _path, _exceptionable = true) =>\n                    (\"string\" === typeof input.title ||\n                      $guard(_exceptionable, {\n                        path: _path + \".title\",\n                        expected: \"string\",\n                        value: input.title,\n                      })) &&\n                    (null === input.body ||\n                      \"string\" === typeof input.body ||\n                      $guard(_exceptionable, {\n                        path: _path + \".body\",\n                        expected: \"(null | string)\",\n                        value: input.body,\n                      })) &&\n                    (undefined === input.thumbnail ||\n                      input.thumbnail instanceof File ||\n                      $guard(_exceptionable, {\n                        path: _path + \".thumbnail\",\n                        expected: \"(File | undefined)\",\n                        value: input.thumbnail,\n                      })) &&\n                    (((Array.isArray(input.files) ||\n                      $guard(_exceptionable, {\n                        path: _path + \".files\",\n                        expected: \"Array<File>\",\n                        value: input.files,\n                      })) &&\n                      input.files.every(\n                        (elem, _index1) =>\n                          elem instanceof File ||\n                          $guard(_exceptionable, {\n                            path: _path + \".files[\" + _index1 + \"]\",\n                            expected: \"File\",\n                            value: elem,\n                          }),\n                      )) ||\n                      $guard(_exceptionable, {\n                        path: _path + \".files\",\n                        expected: \"Array<File>\",\n                        value: input.files,\n                      })) &&\n                    (((Array.isArray(input.tags) ||\n                      $guard(_exceptionable, {\n                        path: _path + \".tags\",\n                        expected: \"Array<string>\",\n                        value: input.tags,\n                      })) &&\n                      input.tags.every(\n                        (elem, _index2) =>\n                          \"string\" === typeof elem ||\n                          $guard(_exceptionable, {\n                            path: _path + \".tags[\" + _index2 + \"]\",\n                            expected: \"string\",\n                            value: elem,\n                          }),\n                      )) ||\n                      $guard(_exceptionable, {\n                        path: _path + \".tags\",\n                        expected: \"Array<string>\",\n                        value: input.tags,\n                      }));\n                  return (\n                    (((\"object\" === typeof input && null !== input) ||\n                      $guard(true, {\n                        path: _path + \"\",\n                        expected: \"IBbsArticleCreate\",\n                        value: input,\n                      })) &&\n                      $ao0(input, _path + \"\", true)) ||\n                    $guard(true, {\n                      path: _path + \"\",\n                      expected: \"IBbsArticleCreate\",\n                      value: input,\n                    })\n                  );\n                })(input, \"$input\", true);\n              return input;\n            };\n            const output = decode(input);\n            return assert(output);\n          },\n        },\n      })\n    ),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", Promise),\n  ],\n\n```\n\n----------------------------------------\n\nTITLE: Special Tag Interface Definition in TypeScript\nDESCRIPTION: Defines an interface `SpecialTag` with various properties that utilize typia's type and comment tags for specifying data validation constraints. It demonstrates how to enforce specific formats, ranges, and patterns for different data types.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedBody.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\n\ninterface SpecialTag {\n  int32: number & tags.Type<\"int32\">;\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n  minLength: string & tags.MinLength<3>;\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n  date: null | (string & tags.Format<\"date\">);\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\n  uuids: Array<string & tags.Format<\"uuid\">> &\n    tags.MinItems<3> &\n    tags.MaxItems<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled BbsArticlesController (JavaScript)\nDESCRIPTION: Represents the compiled JavaScript output of the BbsArticlesController.ts file. Includes the __decorate, __metadata, __param, and __awaiter helpers, along with the controller logic and validation assertions.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __decorate =\n  (this && this.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nvar __metadata =\n  (this && this.__metadata) ||\n  function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n      return Reflect.metadata(k, v);\n  };\nvar __param =\n  (this && this.__param) ||\n  function (paramIndex, decorator) {\n    return function (target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\nvar __awaiter =\n  (this && this.__awaiter) ||\n  function (thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P\n        ? value\n        : new P(function (resolve) {\n            resolve(value);\n          });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done\n          ? resolve(result.value)\n          : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\n  store(body) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        id: \"00000000-0000-0000-0000-000000000000\",\n        writer: \"Samchon\",\n        title: body.title,\n        body: body.body,\n        created_at: new Date().toISOString(),\n      };\n    });\n  }\n};\nexports.BbsArticlesController = BbsArticlesController;\n__decorate(\n  [\n    core_1.TypedQuery.Post({\n      type: \"assert\",\n      assert: (input) => {\n        const assert = (input) => {\n          const __is = (input) => {\n            return (\n              \"object\" === typeof input &&\n              null !== input &&\n              \"string\" === typeof input.id &&\n              \"string\" === typeof input.writer &&\n              \"string\" === typeof input.title &&\n              3 <= input.title.length &&\n              input.title.length <= 50 &&\n              \"string\" === typeof input.body &&\n              \"string\" === typeof input.created_at &&\n              !isNaN(new Date(input.created_at).getTime())\n            );\n          };\n          if (false === __is(input))\n            ((input, _path, _exceptionable = true) => {\n              const $guard = core_1.TypedQuery.Post.guard;\n              const $ao0 = (input, _path, _exceptionable = true) =>\n                (\"string\" === typeof input.id ||\n                  $guard(_exceptionable, {\n                    path: _path + \".id\",\n                    expected: \"string\",\n                    value: input.id,\n                  })) &&\n                (\"string\" === typeof input.writer ||\n                  $guard(_exceptionable, {\n                    path: _path + \".writer\",\n                    expected: \"string\",\n                    value: input.writer,\n                  })) &&\n                ((\"string\" === typeof input.title &&\n                  (3 <= input.title.length ||\n                    $guard(_exceptionable, {\n                      path: _path + \".title\",\n                      expected: \"string & MinLength<3>\",\n                      value: input.title,\n                    })) &&\n                  (input.title.length <= 50 ||\n                    $guard(_exceptionable, {\n                      path: _path + \".title\",\n                      expected: \"string & MaxLength<50>\",\n                      value: input.title,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".title\",\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\n                    value: input.title,\n                  })) &&\n                (\"string\" === typeof input.body ||\n                  $guard(_exceptionable, {\n                    path: _path + \".body\",\n                    expected: \"string\",\n                    value: input.body,\n                  })) &&\n                ((\"string\" === typeof input.created_at &&\n                  (!isNaN(new Date(input.created_at).getTime()) ||\n                    $guard(_exceptionable, {\n                      path: _path + \".created_at\",\n                      expected: 'string & Format<\"date-time\">',\n                      value: input.created_at,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".created_at\",\n                    expected: '(string & Format<\"date-time\">)',\n                    value: input.created_at,\n                  }));\n              return (\n                ((\"object\" === typeof input && null !== input) ||\n                  $guard(true, {\n                    path: _path + \"\",\n                    expected: \"IBbsArticle\",\n                    value: input,\n                  })) &&\n                  $ao0(input, _path + \"\", true)) ||\n                $guard(true, {\n                  path: _path + \"\",\n                  expected: \"IBbsArticle\",\n                  value: input,\n                })\n              );\n            })(input, \"$input\", true);\n          return input;\n        };\n        const stringify = (input) => {\n          const output = new URLSearchParams();\n          output.append(\"id\", input.id);\n          output.append(\"writer\", input.writer);\n          output.append(\"title\", input.title);\n          output.append(\"body\", input.body);\n          output.append(\"created_at\", input.created_at);\n          return output;\n        };\n        return stringify(assert(input));\n      },\n    }),\n    __param(\n      0,\n      core_1.TypedQuery.Body({\n        type: \"assert\",\n        assert: (input) => {\n          const decode = (input) => {\n            const $params = core_1.TypedQuery.Body.params;\n            const $string = core_1.TypedQuery.Body.string;\n            input = $params(input);\n            const output = {\n              title: $string(input.get(\"title\")),\n              body: $string(input.get(\"body\")),\n            };\n            return output;\n          };\n          const assert = (input) => {\n            const __is = (input) => {\n              return (\n                \"object\" === typeof input &&\n                null !== input &&\n                \"string\" === typeof input.title &&\n                3 <= input.title.length &&\n                input.title.length <= 50 &&\n                \"string\" === typeof input.body\n              );\n            };\n            if (false === __is(input))\n              ((input, _path, _exceptionable = true) => {\n                const $guard = core_1.TypedQuery.Body.guard;\n                const $ao0 = (input, _path, _exceptionable = true) =>\n                  ((\"string\" === typeof input.title &&\n                    (3 <= input.title.length ||\n                      $guard(_exceptionable, {\n                        path: _path + \".title\",\n                        expected: \"string & MinLength<3>\",\n                        value: input.title,\n                      })) &&\n                    (input.title.length <= 50 ||\n                      $guard(_exceptionable, {\n                        path: _path + \".title\",\n                        expected: \"string & MaxLength<50>\",\n\n```\n\n----------------------------------------\n\nTITLE: Import Material UI components\nDESCRIPTION: Imports the Alert and Stack components from the Material UI library for creating styled alert messages and arranging elements in a stack layout.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/index.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport Alert from '@mui/material/Alert';\nimport Stack from '@mui/material/Stack';\n```\n\n----------------------------------------\n\nTITLE: Swagger API Definition for BBS Articles (JSON)\nDESCRIPTION: This JSON code defines the Swagger/OpenAPI specification for the BBS article API. It describes the API endpoints for creating, updating, and deleting articles, along with their request and response structures.  It uses references to the `IBbsArticle` and `IBbsArticle.ICreate` schemas defined in the `components/schemas` section to specify the structure of the request and response bodies.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.1.0\",\n  \"servers\": [\n    {\n      \"url\": \"http://localhost:37001\",\n      \"description\": \"Local Server\"\n    }\n  ],\n  \"info\": {\n    \"version\": \"0.1.0\",\n    \"title\": \"@samchon/bbs-api\",\n    \"description\": \"BBS Backend API\",\n    \"license\": {\n      \"name\": \"MIT\"\n    }\n  },\n  \"paths\": {\n    \"/bbs/articles\": {\n      \"post\": {\n        \"summary\": \"Create a new article\",\n        \"description\": \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\n        \"tags\": [],\n        \"parameters\": [],\n        \"requestBody\": {\n          \"description\": \"Information of the article to create\",\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.ICreate\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"description\": \"Newly created article\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            }\n          }\n        },\n        \"x-samchon-accessor\": [\n          \"bbs\",\n          \"articles\",\n          \"create\"\n        ],\n        \"x-samchon-controller\": \"BbsArticleController\"\n      }\n    },\n    \"/bbs/articles/{id}\": {\n      \"put\": {\n        \"summary\": \"Update an article\",\n        \"description\": \"Update an article.\\n\\nUpdates an article with new content.\",\n        \"tags\": [],\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"required\": true,\n            \"description\": \" Target article's {@link IBbsArticle.id }\"\n          }\n        ],\n        \"requestBody\": {\n          \"description\": \"New content to update\",\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/PartialIBbsArticle.ICreate\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"\",\n            \"content\": {\n              \"application/json\": {}\n            }\n          }\n        },\n        \"x-samchon-accessor\": [\n          \"bbs\",\n          \"articles\",\n          \"update\"\n        ],\n        \"x-samchon-controller\": \"BbsArticleController\"\n      },\n      \"delete\": {\n        \"summary\": \"Erase an article\",\n        \"description\": \"Erase an article.\\n\\nErases an article from the DB.\",\n        \"tags\": [],\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"required\": true,\n            \"description\": \" Target article's {@link IBbsArticle.id }\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"\",\n            \"content\": {\n              \"application/json\": {}\n            }\n          }\n        },\n        \"x-samchon-accessor\": [\n          \"bbs\",\n          \"articles\",\n          \"erase\"\n        ],\n        \"x-samchon-controller\": \"BbsArticleController\"\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IBbsArticle\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the article\",\n            \"description\": \"Creation time of the article.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Last updated time of the article\",\n            \"description\": \"Last updated time of the article.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of the article\",\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body\",\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\"\n          },\n          \"thumbnail\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uri\",\n                \"contentMediaType\": \"image/*\"\n              }\n            ],\n            \"title\": \"Thumbnail image URI\",\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\"\n        ],\n        \"description\": \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\"\n      },\n      \"IBbsArticle.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of the article\",\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body\",\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\"\n          },\n          \"thumbnail\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uri\",\n                \"contentMediaType\": \"image/*\"\n              }\n            ],\n            \"title\": \"Thumbnail image URI\",\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\"\n          }\n        },\n        \"required\": [\n          \"title\",\n          \"body\",\n          \"thumbnail\"\n        ],\n        \"description\": \"Information of the article to create.\"\n      },\n      \"PartialIBbsArticle.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of the article\",\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body\",\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\"\n          },\n          \"thumbnail\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              }\n            ],\n            \"title\": \"Thumbnail image URI\",\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Distributing Swagger: NestiaSwaggerComposer Runtime\nDESCRIPTION: Demonstrates how to generate Swagger documentation at runtime using `NestiaSwaggerComposer` and serve it using `SwaggerModule`. Requires `@nestjs/swagger` and `@nestia/sdk` dependencies.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NestiaSwaggerComposer } from \"@nestia/sdk\";\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\nimport { SwaggerModule } from \"@nestjs/swagger\";\n\nconst main = async (): Promise<void> => {\n  const app: INestApplication = await NestFactory.create(ApplicationModule);\n  const document = await NestiaSwaggerComposer.document(app, {});\n  SwaggerModule.setup(\"api\", app, document as any);\n\n  await app.listen(3_000);\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration with Include/Exclude Input\nDESCRIPTION: This snippet configures Nestia to use an object with `include` and `exclude` properties to define the input sources. It includes controllers from the `src/controllers` directory and excludes files matching the `src/**/*.fake.ts` pattern.  The output directory, simulation, distribution and e2e test locations are also configured.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: {\n    include: [\"src/controllers\"],\n    exclude: [\"src/**/*.fake.ts\"],\n  },\n  output: \"src/api\",\n  simulate: true,\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: HTML Meta Refresh Redirect\nDESCRIPTION: This HTML snippet uses the `meta` tag with the `http-equiv=\"refresh\"` attribute to redirect the user to a new URL. The `content` attribute specifies the delay (0 seconds) and the target URL (`/docs/swagger/`).\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/swagger.mdx#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<meta http-equiv=\"refresh\" content=\"0; url=/docs/swagger/\"></meta>\n```\n\n----------------------------------------\n\nTITLE: Swagger JSON Output Demonstrating Tag Effects\nDESCRIPTION: This JSON code represents a portion of the swagger.json file generated by @nestia/sdk based on the controller code and its Swagger tags. It showcases how the `@deprecated`, `@summary`, `@tag`, and `@security` tags influence the OpenAPI specification. The `/bbs/articles/{section}` POST request demonstrates security and tag usages. The `/bbs/articles/{section}/{id}` PUT request uses the `@deprecated` tag.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.1.0\",\n  \"servers\": [\n    {\n      \"url\": \"https://github.com/samchon/nestia\",\n      \"description\": \"insert your server url\"\n    }\n  ],\n  \"info\": {\n    \"version\": \"3.0.3\",\n    \"title\": \"@nestia/test\",\n    \"description\": \"Test program of Nestia\",\n    \"license\": {\n      \"name\": \"MIT\"\n    }\n  },\n  \"paths\": {\n    \"/bbs/articles/{section}\": {\n      \"post\": {\n        \"tags\": [\n          \"public\"\n        ],\n        \"operationId\": \"BbsArticlesController.store\",\n        \"parameters\": [\n          {\n            \"name\": \"section\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \"Section code\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"description\": \"Content to store\",\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.IStore\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"description\": \"Newly archived article\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            }\n          }\n        },\n        \"summary\": \"Public API\",\n        \"description\": \"Would be shown without any mark.\",\n        \"security\": [\n          {\n            \"bearer\": []\n          },\n          {\n            \"oauth2\": [\n              \"read\",\n              \"write\"\n            ]\n          }\n        ]\n      }\n    },\n    \"/bbs/articles/{section}/{id}\": {\n      \"put\": {\n        \"deprecated\": true,\n        \"tags\": [],\n        \"operationId\": \"updateArticle\",\n        \"parameters\": [\n          {\n            \"name\": \"section\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \"Section code\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"description\": \"Content to update\",\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.IStore\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Updated content\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            }\n          }\n        },\n        \"summary\": \"Deprecated API\",\n        \"description\": \"Deprecated API.\\n\\nWould be marked as \\\"deprecated\\\".\\n\\nFor reference, top sentence \\\"Deprecated API.\\\" can replace the `@summary` tag.\",\n        \"security\": [\n          {\n            \"basic\": []\n          },\n          {\n            \"bearer\": []\n          }\n        ]\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IBbsArticle.IStore\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\",\n            \"minLength\": 3,\n            \"maxLength\": 50\n          },\n          \"body\": {\n            \"type\": \"string\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            }\n          }\n        },\n        \"required\": [\n          \"title\",\n          \"body\",\n          \"files\"\n        ]\n      },\n      \"IAttachmentFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"maxLength\": 255\n              }\n            ]\n          },\n          \"extension\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"minLength\": 1,\n                \"maxLength\": 8\n              }\n            ]\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"extension\",\n          \"url\"\n        ]\n      },\n      \"IBbsArticle\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"section\": {\n            \"type\": \"string\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"minLength\": 3,\n            \"maxLength\": 50\n          },\n          \"body\": {\n            \"type\": \"string\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            }\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"section\",\n          \"created_at\",\n          \"title\",\n          \"body\",\n          \"files\"\n        ]\n      }\n    },\n    \"securitySchemes\": {\n      \"basic\": {\n        \"type\": \"http\",\n        \"scheme\": \"basic\"\n      },\n      \"bearer\": {\n        \"type\": \"http\",\n        \"scheme\": \"bearer\"\n      },\n      \"oauth2\": {\n        \"type\": \"oauth2\",\n        \"flows\": {\n          \"implicit\": {\n            \"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\n\n```\n\n----------------------------------------\n\nTITLE: Type Checking with Special Tags (JavaScript)\nDESCRIPTION: Compiled JavaScript code corresponding to the TypeScript example. It defines a function `$io0` which contains validation logic using the regular expressions and checks to ensure the input matches specified formats and constraints. The function `checkSpecialTag` checks that the provided input is an object and applies the `$io0` validation logic.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedRoute.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"use strict\";\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSpecialTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkSpecialTag = (input) => {\n  const $io0 = (input) =>\n    \"number\" === typeof input.int32 &&\n    Math.floor(input.int32) === input.int32 &&\n    -2147483648 <= input.int32 &&\n    input.int32 <= 2147483647 &&\n    (undefined === input.range ||\n      (\"number\" === typeof input.range &&\n        19 < input.range &&\n        input.range <= 100)) &&\n    \"string\" === typeof input.minLength &&\n    3 <= input.minLength.length &&\n    \"string\" === typeof input.pattern &&\n    /^[a-z]+$/.test(input.pattern) &&\n    (null === input.date ||\n      (\"string\" === typeof input.date &&\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\n    \"string\" === typeof input.ip &&\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\n      input.ip,\n    ) ||\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\n        input.ip,\n      )) &&\n    Array.isArray(input.uuids) &&\n    3 <= input.uuids.length &&\n    input.uuids.length <= 100 &&\n    input.uuids.every(\n      (elem) =>\n        \"string\" === typeof elem &&\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n          elem,\n        ),\n    );\n  return \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkSpecialTag = checkSpecialTag;\n```\n\n----------------------------------------\n\nTITLE: NestJS Controller for Simple Calculator WebSocket Route\nDESCRIPTION: Defines a NestJS controller for handling WebSocket connections to a simple calculator. It uses the `@WebSocketRoute` decorator to map a route to the `start` method. The method accepts a WebSocket acceptor and a driver as parameters, and accepts the connection with a `Calculator` instance.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WebSocketRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { Driver, WebSocketAcceptor } from \"tgrid\";\n\nimport { ICalculator } from \"./api/structures/ICalculator\";\nimport { IListener } from \"./api/structures/IListener\";\nimport { Calculator } from \"./providers/Calculator\";\n\n@Controller(\"calculate\")\nexport class CalculateController {\n  /**\n   * Start simple calculator.\n   *\n   * Start simple calculator through WebSocket.\n   */\n  @WebSocketRoute(\"start\")\n  public async start(\n    @WebSocketRoute.Acceptor()\n    acceptor: WebSocketAcceptor<any, ICalculator, IListener>,\n    @WebSocketRoute.Driver() driver: Driver<IListener>,\n  ): Promise<void> {\n    await acceptor.accept(new Calculator(driver));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Searching BBS Article Test (TypeScript)\nDESCRIPTION: This test function `test_api_bbs_article_index_search` validates the BBS article search functionality. It creates 100 articles, retrieves them using `api.functional.bbs.articles.index`, and then performs searches based on title and writer using the `TestValidator.search` helper function. It asserts that the search results match the expected filter criteria.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/development.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\n\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\n\nexport async function test_api_bbs_article_index_search(\n  connection: api.IConnection,\n): Promise<void> {\n  // GENERATE 100 ARTICLES\n  const section: string = \"general\";\n  const articles: IBbsArticle[] = await ArrayUtil.asyncRepeat(100)(() =>\n    api.functional.bbs.articles.create(connection, section, {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(4)(),\n      body: RandomGenerator.content(3)()(),\n      format: \"txt\",\n      files: [],\n      password: RandomGenerator.alphabets(8),\n    }),\n  );\n\n  // GET ENTIRE DATA\n  const total: IPage<IBbsArticle.ISummary> =\n    await api.functional.bbs.articles.index(connection, section, {\n      limit: articles.length,\n      sort: [\"-created_at\"],\n    });\n\n  // PREPARE SEARCH FUNCTION\n  const search = TestValidator.search(\"BbsArticleProvider.index()\")(async (\n    input: IBbsArticle.IRequest.ISearch,\n  ) => {\n    const page: IPage<IBbsArticle.ISummary> =\n      await api.functional.bbs.articles.index(connection, section, {\n        limit: articles.length,\n        search: input,\n        sort: [\"-created_at\"],\n      });\n    return page.data;\n  })(total.data, 10);\n\n  // SEARCH TITLE\n  await search({\n    fields: [\"title\"],\n    values: (article) => [article.title],\n    request: ([title]) => ({ title }),\n    filter: (article, [title]) => article.title.includes(title),\n  });\n\n  // SEARCH WRITER\n  await search({\n    fields: [\"writer\"],\n    values: (article) => [article.writer],\n    request: ([writer]) => ({ writer }),\n    filter: (article, [writer]) => article.writer.includes(writer),\n  });\n\n  // SEARCH BOTH OF THEM\n  await search({\n    fields: [\"title\", \"writer\"],\n    values: (article) => [article.title, article.writer],\n    request: ([title, writer]) => ({ title, writer }),\n    filter: (article, [title, writer]) =>\n      article.title.includes(title) && article.writer.includes(writer),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Traditional Unit Test Example (replicated)\nDESCRIPTION: Illustrates a traditional unit test function, included here for direct comparison with the modern E2E test function. This example leverages type safety but operates at the provider level, not validating the actual backend server behavior.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/why.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport BbsApi from \"@samchon/bbs-api\";\n\nimport { BbsArticleProvider } from \"../../../../src/providers/bbs/BbsArticleProvider\";\n\nexport const test_provider_bbs_article_create = async (): Promise<void> => {\n  // Unit test functions can't validate \n  // the backend server's actual behavior.\n  const article: IBbsArticle = await BbsArticleProvider.write({\n    writer: \"someone\",\n    password: \"1234\",\n    title: \"title\",\n    body: \"content\",\n    format: \"md\",\n    files: [],\n  });\n  typia.assert(article);\n\n  // This is the reason why I've adopted the e2e test paradigm\n  const read: IBbsArticle = await BbsArticleProvider.at(article.id);\n  typia.assert(read);\n  TestValidator.equals(\"written\")(article)(read);\n};\n```\n\n----------------------------------------\n\nTITLE: Validating IAttachmentFile Properties\nDESCRIPTION: This code validates the properties of an IAttachmentFile object. It checks if 'name' and 'extension' are strings with lengths between 1 and 255 and 1 and 8 characters respectively. It also validates 'url' to be a string matching a URL format. Null values are allowed for name and extension.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/pure.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst $ao1 = (input, _path, _exceptionable = true) =>\n                (null === input.name ||\n                  (\"string\" === typeof input.name &&\n                    (1 <= input.name.length ||\n                      $guard(_exceptionable, {\n                        path: _path + \".name\",\n                        expected: \"string & MinLength<1>\",\n                        value: input.name,\n                      })) &&\n                    (input.name.length <= 255 ||\n                      $guard(_exceptionable, {\n                        path: _path + \".name\",\n                        expected: \"string & MaxLength<255>\",\n                        value: input.name,\n                      }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".name\",\n                    expected:\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\n                    value: input.name,\n                  })) &&\n                (null === input.extension ||\n                  (\"string\" === typeof input.extension &&\n                    (1 <= input.extension.length ||\n                      $guard(_exceptionable, {\n                        path: _path + \".extension\",\n                        expected: \"string & MinLength<1>\",\n                        value: input.extension,\n                      })) &&\n                    (input.extension.length <= 8 ||\n                      $guard(_exceptionable, {\n                        path: _path + \".extension\",\n                        expected: \"string & MaxLength<8>\",\n                        value: input.extension,\n                      }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".extension\",\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\n                    value: input.extension,\n                  })) &&\n                ((\"string\" === typeof input.url &&\n                  (/^(?:https?|ftp):\\/\\/(?:\\S+(?:\\:\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?:\\:\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\n                    input.url,\n                  ) ||\n                    $guard(_exceptionable, {\n                      path: _path + \".url\",\n                      expected: 'string & Format<\"url\">',\n                      value: input.url,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".url\",\n                    expected: '(string & Format<\"url\">)',\n                    value: input.url,\n                  }));\n```\n\n----------------------------------------\n\nTITLE: Validating IBbsArticle.ICreate with nested IAttachmentFile array\nDESCRIPTION: This code snippet validates the structure of an IBbsArticle.ICreate object. It checks for the presence and type of a 'files' property, which is an array of IAttachmentFile objects.  Each IAttachmentFile object within the array is validated for properties like 'name', 'extension', and 'url', enforcing minimum and maximum length constraints on 'name' and 'extension', and a URL format on 'url'.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/pure.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst $ao0 = (input, _path, _exceptionable = true) =>\n                (Array.isArray(input.files) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".files\",\n                    expected: \"Array<IAttachmentFile>\",\n                    value: input.files,\n                  })) &&\n                input.files.every(\n                  (elem, _index1) =>\n                    (((\"object\" === typeof elem && null !== elem) ||\n                      $guard(_exceptionable, {\n                        path: _path + \".files[\" + _index1 + \"]\",\n                        expected: \"IAttachmentFile\",\n                        value: elem,\n                      })) &&\n                      $ao1(\n                        elem,\n                        _path + \".files[\" + _index1 + \"]\",\n                        true && _exceptionable,\n                      )) ||\n                      $guard(_exceptionable, {\n                        path: _path + \".files[\" + _index1 + \"]\",\n                        expected: \"IAttachmentFile\",\n                        value: elem,\n                      }),\n                ) ||\n                $guard(_exceptionable, {\n                  path: _path + \".files\",\n                  expected: \"Array<IAttachmentFile>\",\n                  value: input.files,\n                });\n```\n\n----------------------------------------\n\nTITLE: ICalculator Interface Definition\nDESCRIPTION: Defines the ICalculator interface, which specifies the contract for a calculator service. It includes methods for basic arithmetic operations (plus, minus, multiply, and divide), each taking two number arguments and returning a number.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ICalculator {\n  plus(a: number, b: number): number;\n  minus(a: number, b: number): number;\n  multiply(a: number, b: number): number;\n  divide(a: number, b: number): number;\n}\n```\n\n----------------------------------------\n\nTITLE: Swagger Customizer Decorator Interface\nDESCRIPTION: Defines the `SwaggerCustomizer` decorator and its related interfaces for customizing Swagger documentation. This allows modification of the swagger object via a callback function.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nexport function SwaggerCustomizer(\n  closure: (props: SwaggerCustomizer.IProps) => unknown,\n): MethodDecorator;\nexport namespace SwaggerCustomizer {\n  export interface IProps {\n    swagger: OpenApi.IDocument;\n    method: string;\n    path: string;\n    route: OpenApi.IOperation;\n    at(func: Function): ISwaggerEndpoint | undefined;\n    get(accessor: IAccessor): OpenApi.IOperation | undefined;\n  }\n  export interface IAccessor {\n    path: string;\n    method: string;\n  }\n  export interface ISwaggerEndpoint extends IAccessor {\n    route: OpenApi.IOperation;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Swagger JSON Schema from TypeScript DTO\nDESCRIPTION: Shows the JSON schema generated from the `SpecialTag` TypeScript interface, including descriptions, types, formats, minimum/maximum values, and pattern constraints. The schema is structured according to the Swagger/OpenAPI specification.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"SpecialTag\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"type\": {\n        \"deprecated\": true,\n        \"title\": \"Unsigned integer\",\n        \"description\": \"Deprecated tags are just used for marking.\",\n        \"type\": \"integer\"\n      },\n      \"number\": {\n        \"description\": \"You can limit the range of number.\\n\\nAlso, you can configure `default` property by comment tag.\",\n        \"type\": \"number\",\n        \"minimum\": 19,\n        \"exclusiveMinimum\": true,\n        \"maximum\": 100,\n        \"default\": 30\n      },\n      \"string\": {\n        \"description\": \"You can limit the length of string.\",\n        \"type\": \"string\",\n        \"minLength\": 3\n      },\n      \"pattern\": {\n        \"description\": \"You can limit the pattern of string.\",\n        \"type\": \"string\",\n        \"pattern\": \"^[a-z]+$\"\n      },\n      \"format\": {\n        \"oneOf\": [\n          {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n          },\n          {\n            \"type\": \"null\",\n          }\n        ],\n        \"description\": \"You can limit the format of string.\",\n      },\n      \"ip\": {\n        \"oneOf\": [\n          {\n            \"description\": \"You also can perform union type in type tags.\",\n            \"type\": \"string\",\n            \"format\": \"ipv4\"\n          },\n          {\n            \"description\": \"You also can perform union type in type tags.\",\n            \"type\": \"string\",\n            \"format\": \"ipv6\"\n          }\n        ],\n        \"description\": \"You also can perform union type in type tags.\"\n      },\n      \"array\": {\n        \"description\": \"In the Array case, only type tags can limit elements' type.\",\n        \"type\": \"array\",\n        \"items\": {\n          \"description\": \"In the Array case, only type tags can limit elements' type.\",\n          \"type\": \"string\",\n          \"format\": \"uuid\"\n        },\n        \"maxItems\": 100,\n        \"minItems\": 3\n      }\n    },\n    \"required\": [\n      \"type\",\n      \"string\",\n      \"pattern\",\n      \"format\",\n      \"ip\",\n      \"array\"\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled BbsArticlesController Javascript\nDESCRIPTION: The compiled Javascript of the BbsArticlesController with decorators for routing and parameter injection. Includes input validation logic and a mock implementation for the store method.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedBody.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __decorate =\n  (this && this.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nvar __metadata =\n  (this && this.__metadata) ||\n  function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n      return Reflect.metadata(k, v);\n  };\nvar __param =\n  (this && this.__param) ||\n  function (paramIndex, decorator) {\n    return function (target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\nvar __awaiter =\n  (this && this.__awaiter) ||\n  function (thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P\n        ? value\n        : new P(function (resolve) {\n            resolve(value);\n          });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done\n          ? resolve(result.value)\n          : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\n  store(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Object.assign(Object.assign({}, input), {\n        id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\n        created_at: \"2023-04-23T12:04:54.168Z\",\n      });\n    });\n  }\n};\nexports.BbsArticlesController = BbsArticlesController;\n__decorate(\n  [\n    core_1.TypedRoute.Post({\n      type: \"assert\",\n      assert: (input) => {\n        const assert = (input) => {\n          const __is = (input) => {\n            const $io0 = (input) =>\n              \"string\" === typeof input.id &&\n              /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n                input.id,\n              ) &&\n              \"string\" === typeof input.created_at &&\n              !isNaN(new Date(input.created_at).getTime()) &&\n              \"string\" === typeof input.title &&\n              3 <= input.title.length &&\n              input.title.length <= 50 &&\n              \"string\" === typeof input.body &&\n              Array.isArray(input.files) &&\n              input.files.every(\n                (elem) =>\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\n              );\n            const $io1 = (input) =>\n              (null === input.name ||\n                (\"string\" === typeof input.name &&\n                  1 <= input.name.length &&\n                  input.name.length <= 255)) &&\n              (null === input.extension ||\n                (\"string\" === typeof input.extension &&\n                  1 <= input.extension.length &&\n                  input.extension.length <= 8)) &&\n              \"string\" === typeof input.url &&\n              /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\n                input.url,\n              );\n            return \"object\" === typeof input && null !== input && $io0(input);\n          };\n          if (false === __is(input))\n            ((input, _path, _exceptionable = true) => {\n              const $guard = core_1.TypedRoute.Post.guard;\n              const $ao0 = (input, _path, _exceptionable = true) =>\n                ((\"string\" === typeof input.id &&\n                  (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n                    input.id,\n                  ) ||\n                    $guard(_exceptionable, {\n                      path: _path + \".id\",\n                      expected: 'string & Format<\"uuid\">',\n                      value: input.id,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".id\",\n                    expected: '(string & Format<\"uuid\">)',\n                    value: input.id,\n                  })) &&\n                ((\"string\" === typeof input.created_at &&\n                  (!isNaN(new Date(input.created_at).getTime()) ||\n                    $guard(_exceptionable, {\n                      path: _path + \".created_at\",\n                      expected: 'string & Format<\"date-time\">',\n                      value: input.created_at,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".created_at\",\n                    expected: '(string & Format<\"date-time\">)',\n                    value: input.created_at,\n                  })) &&\n                ((\"string\" === typeof input.title &&\n                  (3 <= input.title.length ||\n                    $guard(_exceptionable, {\n                      path: _path + \".title\",\n                      expected: \"string & MinLength<3>\",\n                      value: input.title,\n                    })) &&\n                  (input.title.length <= 50 ||\n                    $guard(_exceptionable, {\n                      path: _path + \".title\",\n                      expected: \"string & MaxLength<50>\",\n                      value: input.title,\n                    }))) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".title\",\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\n                    value: input.title,\n                  })) &&\n                (\"string\" === typeof input.body ||\n                  $guard(_exceptionable, {\n                    path: _path + \".body\",\n                    expected: \"string\",\n                    value: input.body,\n                  })) &&\n                (((Array.isArray(input.files) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".files\",\n                    expected: \"Array<IAttachmentFile>\",\n                    value: input.files,\n                  })) &&\n                  input.files.every(\n                    (elem, _index1) =>\n                      ((\"object\" === typeof elem && null !== elem) ||\n                        $guard(_exceptionable, {\n                          path: _path + \".files[\" + _index1 + \"]\",\n                          expected: \"IAttachmentFile\",\n                          value: elem,\n                        })) &&\n                        $ao1(\n                          elem,\n                          _path + \".files[\" + _index1 + \"]\",\n                          true && _exceptionable,\n                        )) ||\n                      $guard(_exceptionable, {\n                        path: _path + \".files[\" + _index1 + \"]\",\n                        expected: \"IAttachmentFile\",\n                        value: elem,\n                      }),\n                  )) ||\n                  $guard(_exceptionable, {\n                    path: _path + \".files\",\n                    expected: \"Array<IAttachmentFile>\",\n                    value: input.files,\n                  }));\n              const $ao1 = (input, _path, _exceptionable = true) =>\n                (null === input.name ||\n                  (\"string\" === typeof input.name &&\n                    (1 <= input.name.length ||\n                      $guard(_exceptionable, {\n                        path: _path + \".name\",\n                        expected: \"string & MinLength<1>\",\n\n```\n\n----------------------------------------\n\nTITLE: Example Query DTO with Allowed and Disallowed Types - TypeScript\nDESCRIPTION: This TypeScript code illustrates a `SomeQueryDto` interface, showcasing the types that are allowed and disallowed when using `@TypedQuery()`.  It highlights the restrictions on using union types, nullable types, undefinable types, and mixed atomic types within the DTO.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SomeQueryDto {\n  //----\n  // ATOMIC TYPES\n  //----\n  // ALLOWED\n  boolean: boolean;\n  number: number;\n  string: string;\n  bigint: bigint;\n  optional_number?: number;\n  nullable_string: string | null;\n  literal_union: \"A\" | \"B\" | \"C\" | \"D\";\n\n  // NOT ALLOWED\n  mixed_union: string | number | boolean;\n  mixed_literal: \"A\" | \"B\" | 3;\n\n  //----\n  // ARRAY TYPES\n  //----\n  // ALLOWED\n  nullable_element_array: (string | null)[];\n  string_array: string[];\n  number_array: number[];\n  literal_union_array: (\"A\" | \"B\" | \"C\")[];\n  literal_tuple: [\"A\", \"B\", \"C\"];\n\n  // NOT ALLOWED\n  optional_element_array: (string | undefined)[];\n  optional_array: string[] | undefined;\n  nullable_array: string[] | null;\n  union_atomic_array: (string | number)[];\n  mixed_literal_array: (\"A\", \"B\", 3)[];\n  mixed_tuple: [\"A\", \"B\", 3];\n}\n```\n\n----------------------------------------\n\nTITLE: NX Task for Nestia Validation\nDESCRIPTION: This task allows debugging of Nestia errors in an NX environment by running `tsc` directly with the project's `tsconfig.lib.json`. This exposes any type validation errors that Nestia might encounter.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_21\n\nLANGUAGE: json\nCODE:\n```\n \"targets\": {\n    \"build:validate:nestia\": {\n      \"executor\": \"nx:run-commands\",\n      \"options\": {\n        \"commands\": [\n          \"tsc --project packages/<package-name>/tsconfig.lib.json --outDir dist/packages/nestiaTest\"\n        ],\n      }\n    },\n    ...\n }\n```\n\n----------------------------------------\n\nTITLE: tsconfig.json Configuration for Nestia\nDESCRIPTION: Configures the `tsconfig.json` file for Nestia's transformations.  It adds `typia`, `@nestia/core`, and `@nestia/sdk` as TypeScript plugins for runtime swagger composition, validation, and stringification. `strict` and `strictNullChecks` must be set to `true`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_25\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"strict\": true,\n  \"strictNullChecks\": true,\n  \"compilerOptions\": {\n    \"plugins\": [\n      { \"transform\": \"typia/lib/transform\" },\n      { \n        \"transform\": \"@nestia/core/lib/transform\",\n        \"validate\": \"validate\",\n        \"stringify\": \"assert\", \n      },\n      { \"transform\": \"@nestia/sdk/lib/transform\" }, // for runtime swagger composition\n    ],\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Validating IBbsArticle input data\nDESCRIPTION: This code snippet validates an input object to match the IBbsArticle and IAttachmentFile interfaces. It checks types, string lengths (title, name, extension), and the format of the URL field using a regular expression. If validation fails, it throws an error with detailed path information.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/pure.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst __is = (input) => {\n  const $io0 = (input) =>\n    \"string\" === typeof input.title &&\n    3 <= input.title.length &&\n    input.title.length <= 50 &&\n    \"string\" === typeof input.body &&\n    Array.isArray(input.files) &&\n    input.files.every(\n      (elem) =>\n        \"object\" === typeof elem && null !== elem && $io1(elem),\n    );\n  const $io1 = (input) =>\n    (null === input.name ||\n      (\"string\" === typeof input.name &&\n        1 <= input.name.length &&\n        input.name.length <= 255)) &&\n    (null === input.extension ||\n      (\"string\" === typeof input.extension &&\n        1 <= input.extension.length &&\n        input.extension.length <= 8)) &&\n    \"string\" === typeof input.url &&\n    /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\n      input.url,\n    );\n  return \"object\" === typeof input && null !== input && $io0(input);\n};\n```\n\n----------------------------------------\n\nTITLE: Cloned DTO Types after SDK Generation\nDESCRIPTION: This snippet shows the cloned DTO types generated by Nestia when the `clone` option is enabled.  These types are copies of the original DTO structures used in the backend and are included in the generated SDK. The cloned types ensure that the client-side SDK doesn't depend on backend-specific libraries like ORMs.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/index.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace IPageIBbsArticle {\n  export type ISummary = {\n    data: IBbsArticle.ISummary[];\n    pagination: IPage.IPagination;\n  };\n}\nexport namespace IPage {\n  export type IRequest = {\n    page?: null | undefined | (number & Type<\"uint32\">);\n    limit?: null | undefined | (number & Type<\"uint32\">);\n  };\n  export type IPagination = {\n    current: number & Type<\"uint32\">;\n    limit: number & Type<\"uint32\">;\n    records: number & Type<\"uint32\">;\n    pages: number & Type<\"uint32\">;\n  };\n}\n\nexport namespace IBbsArticle {\n  export type ISummary = {\n    id: string & Format<\"uuid\">;\n    section: string;\n    writer: string;\n    title: string & MinLength<3> & MaxLength<50>;\n    created_at: string & Format<\"date-time\">;\n    updated_at: string & Format<\"date-time\">;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Security Schema Definition for Swagger Documents in TypeScript\nDESCRIPTION: Defines TypeScript interfaces representing security schemes for Swagger documents, covering HTTP Basic, HTTP Bearer, API Key, OpenID Connect, and OAuth2. It specifies the structure for defining authentication and authorization mechanisms in the API documentation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Security schema of Swagger Documents.\n *\n * `ISecurityScheme` is a data structure representing content of\n * `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\n * schemes as an union type like below.\n *\n * @reference https://swagger.io/specification/#security-scheme-object\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport type ISecurityScheme =\n  | ISecurityScheme.IHttpBasic\n  | ISecurityScheme.IHttpBearer\n  | ISecurityScheme.IApiKey\n  | ISecurityScheme.IOpenId\n  | ISecurityScheme.IOAuth2;\nexport namespace ISecurityScheme {\n  export interface IHttpBasic {\n    type: \"http\";\n    scheme: \"basic\";\n  }\n  export interface IHttpBearer {\n    type: \"http\";\n    scheme: \"bearer\";\n    bearerFormat?: string;\n  }\n  export interface IApiKey {\n    type: \"apiKey\";\n\n    /**\n     * @default header\n     */\n    in?: \"header\" | \"query\" | \"cookie\";\n\n    /**\n     * @default Authorization\n     */\n    name?: string;\n  }\n\n  export interface IOpenId {\n    type: \"openIdConnect\";\n    openIdConnectUrl: string;\n  }\n\n  export interface IOAuth2 {\n    type: \"oauth2\";\n    flows: IOAuth2.IFlowSet;\n    description?: string;\n  }\n  export namespace IOAuth2 {\n    export interface IFlowSet {\n      authorizationCode?: IFlow;\n      implicit?: Omit<IFlow, \"tokenUrl\">;\n      password?: Omit<IFlow, \"authorizationUrl\">;\n      clientCredentials?: Omit<IFlow, \"authorizationUrl\">;\n    }\n    export interface IFlow {\n      authorizationUrl: string;\n      tokenUrl: string;\n      refreshUrl: string;\n      scopes?: Record<string, string>;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Validator for Special Tag - JavaScript\nDESCRIPTION: This JavaScript code is the compiled output from the TypeScript code defining the `SpecialTag` interface and its validator. It shows how `typia` translates the type and tag constraints into runtime validation logic, including checks for number ranges, string lengths, regular expressions, date formats, and UUID formats.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSpecialTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkSpecialTag = (input) => {\n  const $io0 = (input) =>\n    \"number\" === typeof input.int32 &&\n    Math.floor(input.int32) === input.int32 &&\n    -2147483648 <= input.int32 &&\n    input.int32 <= 2147483647 &&\n    (undefined === input.range ||\n      (\"number\" === typeof input.range &&\n        19 < input.range &&\n        input.range <= 100)) &&\n    \"string\" === typeof input.minLength &&\n    3 <= input.minLength.length &&\n    \"string\" === typeof input.pattern &&\n    /^[a-z]+$/.test(input.pattern) &&\n    (null === input.date ||\n      (\"string\" === typeof input.date &&\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\n    \"string\" === typeof input.ip &&\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\n      input.ip,\n    ) ||\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\n        input.ip,\n      )) &&\n    Array.isArray(input.uuids) &&\n    3 <= input.uuids.length &&\n    input.uuids.length <= 100 &&\n    input.uuids.every(\n      (elem) =>\n        \"string\" === typeof elem &&\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n          elem,\n        ),\n    );\n  return \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkSpecialTag = checkSpecialTag;\n```\n\n----------------------------------------\n\nTITLE: Stringifying IBbsArticle (JavaScript)\nDESCRIPTION: This JavaScript snippet shows how to stringify an `IBbsArticle` object into a JSON string.  The `$io1` function validates properties before serialization, ensuring data integrity.  The `$so0` and `$so1` functions recursively stringify the object's properties and nested files array, handling null values and using the `$string` helper function for proper escaping.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedRoute.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst stringify = (input) => {\n          const $io1 = (input) =>\n            (null === input.name ||\n              (\"string\" === typeof input.name &&\n                1 <= input.name.length &&\n                input.name.length <= 255)) &&\n            (null === input.extension ||\n              (\"string\" === typeof input.extension &&\n                1 <= input.extension.length &&\n                input.extension.length <= 8)) &&\n            \"string\" === typeof input.url &&\n            /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\n              input.url,\n            );\n          const $string = core_1.TypedRoute.Get.string;\n          const $so0 = (input) =>\n            `{\"id\":${$string(input.id)},\"created_at\":${$string(\n              input.created_at,\n            )},\"title\":${$string(input.title)},\"body\":${$string(\n              input.body,\n            )},\"files\":${`[${input.files\n              .map((elem) => $so1(elem))\n              .join(\",\")}]`}}`;\n          const $so1 = (input) =>\n            `{\"name\":${\n              null !== input.name ? $string(input.name) : \"null\"\n            },\"extension\":${\n              null !== input.extension ? $string(input.extension) : \"null\"\n            },\"url\":${$string(input.url)}}`;\n          return $so0(input);\n        };\n```\n\n----------------------------------------\n\nTITLE: Generated JSON Schema for Special Interface\nDESCRIPTION: Presents the JSON schema generated from the `Special` TypeScript interface, showcasing the effects of the typia tags. Note that the `internal` property is excluded from the schema, while `deprecated` and other constraints are properly reflected in the schema definition.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"components\": {\n    \"schemas\": {\n      \"Special\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": {\n            \"type\": \"integer\",\n            \"deprecated\": true,\n            \"title\": \"Unsigned integer\",\n            \"description\": \"Deprecated tags are just used for marking.\"\n          },\n          \"number\": {\n            \"type\": \"number\",\n            \"exclusiveMinimum\": true,\n            \"minimum\": 19,\n            \"maximum\": 100,\n            \"title\": \"You can limit the range of number\",\n            \"description\": \"You can limit the range of number.\"\n          },\n          \"string\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"minLength\": 3,\n                \"maxLength\": 24\n              },\n              {\n                \"type\": \"string\",\n                \"minLength\": 40,\n                \"maxLength\": 100\n              }\n            ],\n            \"title\": \"You can limit the length of string\",\n            \"description\": \"You can limit the length of string.\\n\\nAlso, multiple range conditions are also possible.\"\n          },\n          \"pattern\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[a-z]+$\",\n            \"title\": \"You can limit the pattern of string\",\n            \"description\": \"You can limit the pattern of string.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"You can limit the format of string\",\n            \"description\": \"You can limit the format of string.\"\n          },\n          \"array\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"minItems\": 3,\n            \"title\": \"In the Array case, possible to restrict its elements\",\n            \"description\": \"In the Array case, possible to restrict its elements.\"\n          }\n        },\n        \"required\": [\n          \"type\",\n          \"string\",\n          \"pattern\",\n          \"format\",\n          \"array\"\n        ]\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: IListener Interface (TypeScript)\nDESCRIPTION: Defines the `IListener` interface for event notifications from the calculator. The `on` method receives an `IEvent` object containing the event type and related numerical values. It defines nested interface IEvent.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IListener {\n  on(event: IListener.IEvent): void;\n}\nexport namespace IListener {\n  export interface IEvent {\n    type: string;\n    x: number;\n    y: number;\n    z: number;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration with Directory Input\nDESCRIPTION: This snippet configures Nestia to use multiple directories as input, allowing the tool to discover and generate SDK definitions from controllers located in those directories.  The output directory, simulation, distribution and e2e test locations are also configured.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: [\"src/controllers\", \"src/fake/controllers\", \"src/test/controllers\"],\n  output: \"src/api\",\n  simulate: true,\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Manual Nestia Setup (pnpm)\nDESCRIPTION: This command installs the necessary dependencies for Nestia, TypeScript, ts-node, ts-patch, @nestia/core, @nestia/e2e, @nestia/sdk and typia using pnpm package manager.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n# COMPILERS\npnpm install --save-dev typescript\npnpm install --save-dev ts-node\npnpm install --save-dev ts-patch\n\n# NESTIA\npnpm install --save-dev nestia\npnpm install --save-dev @nestia/sdk\npnpm install --save @nestia/core\npnpm install --save @nestia/e2e\npnpm install --save typia\n```\n\n----------------------------------------\n\nTITLE: Manual Nestia Setup (npm)\nDESCRIPTION: This command installs the necessary dependencies for Nestia, TypeScript, ts-node, ts-patch, @nestia/core, @nestia/e2e, @nestia/sdk and typia using npm package manager.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n# COMPILERS\nnpm install --save-dev typescript\nnpm install --save-dev ts-node\nnpm install --save-dev ts-patch\n\n# NESTIA\nnpm install --save-dev nestia\nnpm install --save @nestia/core\nnpm install --save @nestia/e2e\nnpm install --save @nestia/sdk\nnpm install --save typia\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Custom JSON Schema\nDESCRIPTION: Compiled javascript output for customizing JSON schema generation with Typia.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\n({\n  version: \"3.1\",\n  components: {\n    schemas: {\n      IAccount: {\n        type: \"object\",\n        properties: {\n          code: {\n            type: \"string\",\n            \"x-placeholder\": \"Write you account code please\",\n          },\n          balance: {\n            type: \"number\",\n            \"x-monetary\": \"dollar\",\n          },\n        },\n        required: [\"code\", \"balance\"],\n      },\n    },\n  },\n  schemas: [\n    {\n      $ref: \"#/components/schemas/IAccount\",\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Nestia Setup with NX (yarn)\nDESCRIPTION: This command initializes Nestia in an NX monorepo project using yarn.  The `--manager yarn` flag specifies the package manager to be used.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia setup --manager yarn\n```\n\n----------------------------------------\n\nTITLE: OpenAPI Security Scheme\nDESCRIPTION: This snippet defines the ISecurityScheme interface from the @samchon/openapi package. This interface represents the security scheme object in Swagger documents. It supports various security schemes like HTTP Basic, HTTP Bearer, API Key, OpenID Connect, and OAuth2. It also defines corresponding sub-interfaces for each type of security scheme.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Security scheme of Swagger Documents.\n *\n * `ISecurityScheme` is a data structure representing content of\n * `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\n * schemes as an union type like below.\n *\n * @reference https://swagger.io/specification/#security-scheme-object\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport type ISecurityScheme =\n  | ISecurityScheme.IHttpBasic\n  | ISecurityScheme.IHttpBearer\n  | ISecurityScheme.IApiKey\n  | ISecurityScheme.IOpenId\n  | ISecurityScheme.IOAuth2;\nexport namespace ISecurityScheme {\n  export interface IHttpBasic {\n    type: \"http\";\n    scheme: \"basic\";\n  }\n  export interface IHttpBearer {\n    type: \"http\";\n    scheme: \"bearer\";\n    bearerFormat?: string;\n  }\n```\n\n----------------------------------------\n\nTITLE: Define BbsArticleController with Function Hiding - TypeScript\nDESCRIPTION: This TypeScript code defines a NestJS controller for managing BBS articles. It demonstrates the use of `@hidden` and `@HumanRoute` decorators to control the visibility of the `create` and `erase` methods in Swagger documentation and LLM application schemas, respectively. The controller handles reading, creating, updating, and deleting articles.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HumanRoute, TypedBody, TypedParam, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { tags } from \"typia\";\n\nimport { IBbsArticle } from \"../api/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticleController {\n  /**\n   * Read an article.\n   *\n   * Reads an article from the DB.\n   *\n   * @param id Target article's {@link IBbsArticle.id}\n   * @returns The article\n   */\n  @TypedRoute.Get(\":id\")\n  public async at(\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticle>;\n\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param input Information of the article to create\n   * @returns Newly created article\n   * @hidden\n   */\n  @TypedRoute.Post()\n  public async create(\n    @TypedBody() input: IBbsArticle.ICreate\n  ): Promise<IBbsArticle>;\n\n  /**\n   * Update an article.\n   *\n   * Updates an article with new content.\n   *\n   * @param id Target article's {@link IBbsArticle.id}\n   * @param input New content to update\n   * @internal\n   */\n  @TypedRoute.Put(\":id\")\n  public async update(\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n    @TypedBody() input: IBbsArticle.IUpdate,\n  ): Promise<void>;\n\n  /**\n   * Erase an article.\n   *\n   * Erases an article from the DB.\n   *\n   * @param id Target article's {@link IBbsArticle.id}\n   */\n  @HumanRoute()\n  @TypedRoute.Delete(\":id\")\n  public async erase(\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n  ): Promise<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Swagger Configuration for BbsArticle - JSON\nDESCRIPTION: This JSON snippet configures the Swagger documentation for the `BbsArticleController`. It defines the API endpoints for retrieving and deleting articles, including request parameters, responses, and schema definitions for the `IBbsArticle` data structure. The snippet highlights how the `@HumanRoute` annotation hides the 'erase' method from LLM, while it is still present in the swagger documentation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.1.0\",\n  \"servers\": [\n    {\n      \"url\": \"http://localhost:37001\",\n      \"description\": \"Local Server\"\n    }\n  ],\n  \"info\": {\n    \"version\": \"0.1.0\",\n    \"title\": \"@ORGANIZATION/PROJECT\",\n    \"description\": \"Starter kit of Nestia\",\n    \"license\": {\n      \"name\": \"MIT\"\n    }\n  },\n  \"paths\": {\n    \"/bbs/articles/{id}\": {\n      \"get\": {\n        \"summary\": \"Read an article\",\n        \"description\": \"Read an article.\\n\\nReads an article from the DB.\",\n        \"tags\": [],\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"required\": true,\n            \"description\": \" Target article's {@link IBbsArticle.id }\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"The article\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            }\n          }\n        ,\n        \"x-samchon-accessor\": [\n          \"bbs\",\n          \"articles\",\n          \"at\"\n        ],\n        \"x-samchon-controller\": \"BbsArticleController\"\n      },\n      \"delete\": {\n        \"summary\": \"Erase an article\",\n        \"description\": \"Erase an article.\\n\\nErases an article from the DB.\",\n        \"tags\": [],\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"required\": true,\n            \"description\": \" Target article's {@link IBbsArticle.id }\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"\",\n            \"content\": {\n              \"application/json\": {}\n            }\n          }\n        },\n        \"x-samchon-accessor\": [\n          \"bbs\",\n          \"articles\",\n          \"erase\"\n        ],\n        \"x-samchon-controller\": \"BbsArticleController\"\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IBbsArticle\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the article\",\n            \"description\": \"Creation time of the article.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Last updated time of the article\",\n            \"description\": \"Last updated time of the article.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of the article\",\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body\",\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\"\n          },\n          \"thumbnail\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uri\",\n                \"contentMediaType\": \"image/*\"\n              }\n            ],\n            \"title\": \"Thumbnail image URI\",\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\"\n        ],\n        \"description\": \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\"\n      }\n    }\n  },\n  \"tags\": [],\n  \"x-samchon-emended\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Master Configuration\nDESCRIPTION: Configures and runs the master process for dynamic benchmarking using DynamicBenchmarker.master(). It sets the servant path, request counts, threads, simultaneous requests, and filters for test functions. Progress is tracked using a CLI progress bar, and the benchmark report is saved as a markdown file.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/why.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst report: DynamicBenchmarker.IReport = await DynamicBenchmarker.master({\n    servant: `${__dirname}/servant.js`,\n    count: options.count,\n    threads: options.threads,\n    simultaneous: options.simultaneous,\n    filter: (func) =>\n      (!options.include?.length ||\n        (options.include ?? []).some((str) => func.includes(str))) &&\n      (!options.exclude?.length ||\n        (options.exclude ?? []).every((str) => !func.includes(str))),\n    progress: (value: number) => {\n      if (value >= 100 + prev.value) {\n        bar.update(value);\n        prev.value = value;\n      }\n    },\n    stdio: \"ignore\",\n  });\n```\n\n----------------------------------------\n\nTITLE: Configuring Nestia\nDESCRIPTION: This code snippet shows the configuration file `nestia.config.ts` for Nestia. It defines the input function (which creates the NestJS application), the output directory for the generated SDK, the distribution directory for the SDK package, and the e2e test directory.  The `YourModule` is imported from `./src/YourModule` and used to create a NestJS application.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule);\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Nestia Config with Controller Path String\nDESCRIPTION: This configuration specifies a glob pattern as a string to locate the controller files. Nestia uses this pattern to find all files matching the pattern.  The path is relative to the project root.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: \"src/**/*.controller.ts\",\n  output: \"src/api\",\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: SomeFormDataDto Definition Example\nDESCRIPTION: This snippet illustrates the restrictions on types that can be used with `@TypedFormData.Body()`. It demonstrates allowed and disallowed types for properties, including atomic types, array types, and their combinations with nullable, optional, and union types.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedFormData.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SomeFormDataDto {\n  //----\n  // ATOMIC OR FILE TYPES\n  //----\n  // ALLOWED\n  boolean: boolean;\n  number: number;\n  string: string;\n  bigint: bigint;\n  optional_number?: number;\n  nullable_string: string | null;\n  literal_union: \"A\" | \"B\" | \"C\" | \"D\";\n  blob: Blob;\n  file: File;\n\n  // NOT ALLOWED\n  mixed_union: string | number | boolean;\n  mixed_literal: \"A\" | \"B\" | 3;\n\n  //----\n  // ARRAY TYPES\n  //----\n  // ALLOWED\n  nullable_element_array: (string | null)[];\n  string_array: string[];\n  number_array: number[];\n  literal_union_array: (\"A\" | \"B\" | \"C\")[];\n  literal_tuple: [\"A\", \"B\", \"C\"];\n  blobs: Blob[];\n  files: File[];\n\n  // NOT ALLOWED\n  optional_element_array: (string | undefined)[];\n  optional_array: string[] | undefined;\n  nullable_array: string[] | null;\n  union_atomic_array: (string | number)[];\n  mixed_literal_array: (\"A\", \"B\", 3)[];\n  mixed_tuple: [\"A\", \"B\", 3];\n}\n```\n\n----------------------------------------\n\nTITLE: Define SpecialTag interface with typia tags (TypeScript)\nDESCRIPTION: This TypeScript code defines an interface `SpecialTag` and uses `typia.createIs<SpecialTag>()` to create a type checker. The interface properties are annotated with `typia`'s `tags` to specify validation constraints like `Type`, `ExclusiveMinimum`, `Maximum`, `MinLength`, `Pattern`, and `Format`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedHeaders.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\n\ninterface SpecialTag {\n  int32: number & tags.Type<\"int32\">;\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n  minLength: string & tags.MinLength<3>;\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n  date: null | (string & tags.Format<\"date\">);\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\n  uuids: Array<string & tags.Format<\"uuid\">> &\n    tags.MinItems<3> &\n    tags.MaxItems<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Run Prepare Script (npm)\nDESCRIPTION: This command executes the `prepare` script using npm, which installs ts-patch and patches typia.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\nnpm run prepare\n```\n\n----------------------------------------\n\nTITLE: Swagger Example with TypedException\nDESCRIPTION: Shows how the TypedException decorator affects the generated Swagger documentation, specifically the responses section for the /exception/{section}/typed endpoint.  Each defined exception (400, 404, 428, 5XX) is represented with its corresponding schema, description, and, in some cases, example.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedException.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"openapi\": \"3.1.0\",\n  \"servers\": [\n    {\n      \"url\": \"https://github.com/samchon/nestia\",\n      \"description\": \"insert your server url\"\n    }\n  ],\n  \"info\": {\n    \"version\": \"3.11.1\",\n    \"title\": \"@samchon/nestia-test\",\n    \"description\": \"Test program of Nestia\",\n    \"license\": {\n      \"name\": \"MIT\"\n    }\n  },\n  \"paths\": {\n    \"/exception/{section}/typed\": {\n      \"post\": {\n        \"tags\": [],\n        \"parameters\": [\n          {\n            \"name\": \"section\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.IStore\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            }\n          },\n          \"400\": {\n            \"description\": \"invalid request\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/TypeGuardErrorany\"\n                },\n                \"example\": {\n                  \"name\": \"BadRequestException\",\n                  \"method\": \"TypedBody\",\n                  \"path\": \"$input.title\",\n                  \"expected\": \"string\",\n                  \"value\": 123,\n                  \"message\": \"invalid type\"\n                }\n              }\n            }\n          },\n          \"404\": {\n            \"description\": \"unable to find the matched section\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/INotFound\"\n                }\n              }\n            }\n          },\n          \"428\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUnprocessibleEntity\"\n                }\n              }\n            }\n          },\n          \"5XX\": {\n            \"description\": \"internal server error\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IInternalServerError\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IBbsArticle\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"minLength\": 3,\n            \"maxLength\": 50\n          },\n          \"body\": {\n            \"type\": \"string\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            }\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"title\",\n          \"body\",\n          \"files\"\n        ]\n      },\n      \"IAttachmentFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"maxLength\": 255\n              }\n            ]\n          },\n          \"extension\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"minLength\": 1,\n                \"maxLength\": 8\n              }\n            ]\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"extension\",\n          \"url\"\n        ]\n      },\n      \"IBbsArticle.IStore\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\",\n            \"minLength\": 3,\n            \"maxLength\": 50\n          },\n          \"body\": {\n            \"type\": \"string\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            }\n          }\n        },\n        \"required\": [\n          \"title\",\n          \"body\",\n          \"files\"\n        ]\n      },\n      \"TypeGuardErrorany\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"method\": {\n            \"type\": \"string\"\n          },\n          \"path\": {\n            \"type\": \"string\"\n          },\n          \"expected\": {\n            \"type\": \"string\"\n          },\n          \"value\": {},\n          \"fake_expected_typed_value_\": {},\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"message\": {\n            \"type\": \"string\"\n          },\n          \"stack\": {\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"method\",\n          \"expected\",\n          \"value\",\n          \"name\",\n          \"message\"\n        ]\n      },\n      \"INotFound\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"schema\": {\n            \"type\": \"string\"\n          },\n          \"table\": {\n            \"type\": \"string\"\n          },\n          \"id\": {\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"schema\",\n          \"table\",\n          \"id\"\n        ]\n      },\n      \"IUnprocessibleEntity\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"reason\": {\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"reason\"\n        ]\n      },\n      \"IInternalServerError\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"message\": {\n            \"type\": \"string\"\n          },\n          \"stack\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            }\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"message\",\n          \"stack\"\n        ]\n      }\n    },\n    \"securitySchemes\": {\n      \"bearer\": {\n        \"type\": \"apiKey\"\n      }\n    }\n  },\n  \"tags\": [],\n  \"x-samchon-emended\": true\n}\n```\n\n----------------------------------------\n\nTITLE: IListener Interface Definition\nDESCRIPTION: Defines the IListener interface and its nested IEvent interface. The IListener interface includes an 'on' method for receiving events of type IListener.IEvent. The IEvent interface defines the structure of an event, including its type and numeric properties (x, y, z).\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IListener {\n  on(event: IListener.IEvent): void;\n}\nexport namespace IListener {\n  export interface IEvent {\n    type: string;\n    x: number;\n    y: number;\n    z: number;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: BbsArticlesController Implementation - TypeScript\nDESCRIPTION: Implements the BbsArticlesController using NestJS and the TypedRoute decorator from @nestia/core. This controller defines a 'random' route that returns a mock IBbsArticle object. The TypedRoute.Get decorator is used to define the endpoint and its associated type.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedRoute.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  /**\n   * Get random article for testing.\n   */\n  @TypedRoute.Get(\"random\")\n  public async random(): Promise<IBbsArticle> {\n    return {\n      id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\n      title: \"Hello nestia users\",\n      body: \"Just use `TypedRoute.Get()` function like this\",\n      created_at: \"2023-04-23T12:04:54.168Z\",\n      files: [],\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Calculator Interface Definition\nDESCRIPTION: Defines the interface for an advanced calculator, which includes basic arithmetic operations (plus, minus, multiply, divide) and methods for retrieving the calculator's ID, precision, and memo.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IMemo } from \"./IMemo\";\n\nexport interface IAdvancedCalculator {\n  plus(a: number, b: number): number;\n  minus(a: number, b: number): number;\n  multiply(a: number, b: number): number;\n  divide(a: number, b: number): number;\n\n  getId(): string;\n  getPrecision(): number;\n  getMemo(): IMemo;\n}\n```\n\n----------------------------------------\n\nTITLE: HTML for Static Hosting of Nestia Editor\nDESCRIPTION: This HTML snippet shows how to configure the Nestia Editor when using static hosting. It sets global variables for the package name, simulate, and e2e options. It assumes that the `index.html` file is part of the unzipped `@nestia/editor` distribution.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/editor.mdx#_snippet_1\n\nLANGUAGE: HTML\nCODE:\n```\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, height=device-height, initial-scale=1, minimum-scale=1.0, maximum-scale=3.0s\"\n    />\n    <title>Nestia Editor</title>\n    <script type=\"module\"  src=\"./assets/index-DwHERS4Q.js\"></script>\n  </head>\n  <body style=\"width: 100%; height: 100%; margin: 0px; overflow: hidden;\">\n    <div id=\"root\" style=\"width: 100%; height: 100%\"></div>\n    <script>\n      window.package = \"@ORGANIZATION/PROJECT\";\n      window.simulate = false; \n      window.e2e = false;\n    </script>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Special Tags Example\nDESCRIPTION: This snippet presents the compiled JavaScript code equivalent to the TypeScript code demonstrating special tags.  It shows how `typia` transforms the type annotations and tags into runtime validation logic.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedFormData.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSpecialTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkSpecialTag = (input) => {\n  const $io0 = (input) =>\n    \"number\" === typeof input.int32 &&\n    Math.floor(input.int32) === input.int32 &&\n    -2147483648 <= input.int32 &&\n    input.int32 <= 2147483647 &&\n    (undefined === input.range ||\n      (\"number\" === typeof input.range &&\n        19 < input.range &&\n        input.range <= 100)) &&\n    \"string\" === typeof input.minLength &&\n    3 <= input.minLength.length &&\n    \"string\" === typeof input.pattern &&\n    /^[a-z]+$/.test(input.pattern) &&\n    (null === input.date ||\n      (\"string\" === typeof input.date &&\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\n    \"string\" === typeof input.ip &&\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\n      input.ip,\n    ) ||\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\n        input.ip,\n      )) &&\n    Array.isArray(input.uuids) &&\n    3 <= input.uuids.length &&\n    input.uuids.length <= 100 &&\n    input.uuids.every(\n      (elem) =>\n        \"string\" === typeof elem &&\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n          elem,\n        ),\n    );\n  return \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkSpecialTag = checkSpecialTag;\n```\n\n----------------------------------------\n\nTITLE: Define NestJS DTO with Decorators\nDESCRIPTION: This code snippet demonstrates how DTOs are defined in NestJS using class-validator and @nestjs/swagger decorators. It showcases the verbose and potentially error-prone nature of this approach, especially with the `files` property requiring multiple decorators.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/pure.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ApiProperty } from \"@nestjs/swagger\";\nimport {\n  ArrayNotEmpty,\n  Format,\n  IsArray,\n  IsObject,\n  IsOptional,\n  IsString,\n  Match,\n  MaxLength,\n  Type,\n  ValidateNested,\n} from \"class-validator\";\n\nexport class BbsArticle {\n  @ApiProperty({\n    format: \"uuid\",\n  })\n  @IsString()\n  id!: string;\n\n  // DUPLICATED SCHEMA DEFINITION\n  // - duplicated function call + property type\n  // - have to specify `isArray` and `nullable` props by yourself\n  @ApiProperty({\n    type: () => AttachmentFile,\n    nullable: true,\n    isArray: true,\n    description: \"List of attached files.\",\n  })\n  @Type(() => AttachmentFile)\n  @IsArray()\n  @IsOptional()\n  @IsObject({ each: true })\n  @ValidateNested({ each: true })\n  files!: AttachmentFile[] | null;\n\n  @ApiProperty({\n    type: \"string\",\n    nullable: true,\n    minLength: 5,\n    maxLength: 100,\n    description: \"Title of the article.\",\n  })\n  @IsOptional()\n  @IsString()\n  title!: string | null;\n\n  @ApiProperty({\n    description: \"Main content body of the article.\",\n  })\n  @IsString()\n  body!: string;\n\n  @ApiProperty({\n    format: \"date-time\",\n    description: \"Creation time of article\",\n  })\n  @IsString()\n  created_at!: string;\n}\n\nexport class AttachmentFile {\n  @ApiProperty({\n    type: \"string\",\n    maxLength: 255,\n    pattern: \"^[a-zA-Z0-9-_]+$\",\n    description: \"File name.\",\n  })\n  @Matches(/^[a-z0-9]+$/)\n  @MaxLength(255)\n  @IsString()\n  name!: string | null;\n\n  @ApiProperty({\n    type: \"string\",\n    nullable: true,\n    maxLength: 255,\n    pattern: \"^[a-zA-Z0-9-_]+$\",\n    description: \"File extension.\",\n  })\n  @Matches(/^[a-z0-9]+$/)\n  @MaxLength(8)\n  @IsOptional()\n  @IsString()\n  extension!: string | null;\n\n  @ApiProperty({\n    format: \"url\",\n    description: \"URL of the file.\",\n  })\n  @Format(\"uri\")\n  @IsString()\n  url!: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Config with Include/Exclude Patterns\nDESCRIPTION: This configuration utilizes `include` and `exclude` patterns to specify which controller files to include or exclude from the API documentation generation. This allows for more fine-grained control over which controllers are processed. The paths are relative to the project root.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: {\n    include: [\"src/controllers\"],\n    exclude: [\"src/**/*.fake.ts\"],\n  },\n  output: \"src/api\",\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Nestia project setup and benchmark - Bash\nDESCRIPTION: This bash script provides instructions on how to clone a nestia-start project, navigate into the directory, install dependencies, build the test files, and run the benchmark. These commands will execute the end-to-end tests and provide performance metrics for the backend server.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/benchmark.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/samchon/nestia-start\ncd nestia-start\nnpm install\nnpm run build:test\nnpm run benchmark\n```\n\n----------------------------------------\n\nTITLE: Installing dependencies for Single JS file with yarn (Bash)\nDESCRIPTION: These commands install nestia, ts-loader, webpack, webpack-cli, copy-webpack-plugin and write-file-webpack-plugin as dev dependencies using yarn to create a light JS bundling of the NestJS project.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n# SETUP NESTIA\nnpx nestia setup --manager yarn\n\n# INSTALL SPECIAL DEPENDENCIES\nyarn add -D ts-loader\nyarn add -D webpack webpack-cli\nyarn add -D copy-webpack-plugin write-file-webpack-plugin\n```\n\n----------------------------------------\n\nTITLE: Nestia Config with Fastify Adapter\nDESCRIPTION: This configuration is similar to the previous one but uses the `FastifyAdapter` instead of the default Express adapter. This is useful if you're using Fastify in your NestJS application. `YourModule` still needs to be defined in your project.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\nimport { FastifyAdapter } from \"@nestjs/platform-fastify\";\n\nimport { YourModule } from \"./src/YourModule\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: async () => {\n    const app = await NestFactory.create(YourModule, new FastifyAdapter());\n    // app.setGlobalPrefix(\"api\");\n    // app.enableVersioning({\n    //     type: VersioningType.URI,\n    //     prefix: \"v\",\n    // })\n    return app;\n  },\n  output: \"src/api\",\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: Building Swagger Document using Nestia CLI\nDESCRIPTION: These Bash commands demonstrate how to build Swagger documents using the Nestia CLI. The first command, `npx nestia swagger`, builds only the Swagger document. The second command, `npx nestia all`, builds the Swagger document, SDK (Software Development Kit), and E2E (End-to-End) test functions.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# BUILD SWAGGER DOCUUMET ONLY\nnpx nestia swagger\n\n# BUILD SWAGGER/SDK/E2E AT THE SAME TIME\nnpx nestia all\n```\n\n----------------------------------------\n\nTITLE: Defining BBS Article Controller with Nestia (TypeScript)\nDESCRIPTION: This TypeScript code defines the `BbsArticleController` using Nestia decorators for handling HTTP requests. It includes methods for creating, updating, and erasing articles. The controller uses `TypedBody` and `TypedParam` for request input and parameters, and interacts with the `IBbsArticle` interface.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/strategy.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TypedBody, TypedParam, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { tags } from \"typia\";\n\nimport { IBbsArticle } from \"../api/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticleController {\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param input Information of the article to create\n   * @returns Newly created article\n   */\n  @TypedRoute.Post()\n  public async create(\n    @TypedBody() input: IBbsArticle.ICreate\n  ): Promise<IBbsArticle>;\n\n  /**\n   * Update an article.\n   *\n   * Updates an article with new content.\n   *\n   * @param id Target article's {@link IBbsArticle.id}\n   * @param input New content to update\n   */\n  @TypedRoute.Put(\":id\")\n  public async update(\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n    @TypedBody() input: IBbsArticle.IUpdate,\n  ): Promise<void>;\n\n  /**\n   * Erase an article.\n   *\n   * Erases an article from the DB.\n   *\n   * @param id Target article's {@link IBbsArticle.id}\n   */\n  @TypedRoute.Delete(\":id\")\n  public async erase(\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n  ): Promise<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Error Message: Invalid WebSocketRoute.Param() Type\nDESCRIPTION: Indicates an error during compilation when using `@WebSocketRoute.Param()` with a non-atomic type such as an object or union type (except for nullable primitives).\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nError on nestia.core.WebSocketRoute.Param(): only atomic type is allowed\n```\n\n----------------------------------------\n\nTITLE: Rendering Strength Movie Section\nDESCRIPTION: This snippet renders the strength movie section within the `HomeLayout` component. The `HomeStrengthMovie` component is placed inside the `HomeLayout`, ensuring it's displayed according to the layout's structure. This section adds to the overall visual content.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/index.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<HomeLayout>\n  <HomeStrengthMovie />\n</HomeLayout>\n```\n\n----------------------------------------\n\nTITLE: Executing Nestia E2E\nDESCRIPTION: This snippet showcases the bash commands used to execute the Nestia E2E test generation.  The first command runs the E2E test generation with default configurations. The second command specifies the configuration file (`nestia.config.ts`) and the TypeScript project file (`tsconfig.json`).\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia e2e\nnpx nestia e2e --config nestia.config.ts --project tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Special Tag Validation\nDESCRIPTION: Presents the compiled JavaScript code generated from the TypeScript interface `SpecialTag`, showcasing the validation logic implemented using typia. It highlights how the type and comment tags are translated into runtime checks for data integrity.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedBody.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSpecialTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkSpecialTag = (input) => {\n  const $io0 = (input) =>\n    \"number\" === typeof input.int32 &&\n    Math.floor(input.int32) === input.int32 &&\n    -2147483648 <= input.int32 &&\n    input.int32 <= 2147483647 &&\n    (undefined === input.range ||\n      (\"number\" === typeof input.range &&\n        19 < input.range &&\n        input.range <= 100)) &&\n    \"string\" === typeof input.minLength &&\n    3 <= input.minLength.length &&\n    \"string\" === typeof input.pattern &&\n    /^[a-z]+$/.test(input.pattern) &&\n    (null === input.date ||\n      (\"string\" === typeof input.date &&\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\n    \"string\" === typeof input.ip &&\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\n      input.ip,\n    ) ||\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\n        input.ip,\n      )) &&\n    Array.isArray(input.uuids) &&\n    3 <= input.uuids.length &&\n    input.uuids.length <= 100 &&\n    input.uuids.every(\n      (elem) =>\n        \"string\" === typeof elem &&\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\n          elem,\n        ),\n    );\n  return \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkSpecialTag = checkSpecialTag;\n```\n\n----------------------------------------\n\nTITLE: HTML Iframe Embedding for Nestia Editor\nDESCRIPTION: This HTML snippet demonstrates embedding the Nestia Editor using an `<iframe>` tag. It uses query parameters to specify the URL of the Swagger document, the package name, and whether to enable simulation and e2e testing.  It expects a valid URL for the swagger file.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/editor.mdx#_snippet_2\n\nLANGUAGE: HTML\nCODE:\n```\n<iframe url=\"https://nestia.io/editor/?url={URL_ADDRESS}&package={NAME}&simulate=true&e2e=true\"></iframe>\n```\n\n----------------------------------------\n\nTITLE: Interactive Nestia setup with runtime option selection\nDESCRIPTION: These Bash commands install the latest version of Nestia and then run the Nestia setup command without the `--runtime true` argument. This triggers an interactive prompt, asking the user to select a package manager and whether to transform runtime Swagger.  Answering `true` to the runtime Swagger question configures the tsconfig.json file for runtime Swagger generation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save-dev nestia@latest\nnpx nestia setup\n```\n\n----------------------------------------\n\nTITLE: TypedQuery Decorator Definition (TypeScript)\nDESCRIPTION: Defines the TypedQuery decorator function which can be used to parse and validate URL queries.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedQuery.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport function TypedQuery(): ParameterDecorator;\n```\n\n----------------------------------------\n\nTITLE: BBS Article Search Test - TypeScript\nDESCRIPTION: The `test_api_bbs_article_index_search` function tests the article search functionality. It creates 100 articles, retrieves all data, and prepares a search function. It then searches for articles by title, writer, and both title and writer, validating the search results. It uses `@nestia/e2e` and `@ORGANIZATION/PROJECT-api`.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/benchmark.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\n\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\n\nexport async function test_api_bbs_article_index_search(\n  connection: api.IConnection,\n): Promise<void> {\n  // GENERATE 100 ARTICLES\n  const section: string = \"general\";\n  const articles: IBbsArticle[] = await ArrayUtil.asyncRepeat(100)(() =>\n    api.functional.bbs.articles.create(connection, section, {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(4)(),\n      body: RandomGenerator.content(3)()(),\n      format: \"txt\",\n      files: [],\n      password: RandomGenerator.alphabets(8),\n    }),\n  );\n\n  // GET ENTIRE DATA\n  const total: IPage<IBbsArticle.ISummary> =\n    await api.functional.bbs.articles.index(connection, section, {\n      limit: articles.length,\n      sort: [\"-created_at\"],\n    });\n\n  // PREPARE SEARCH FUNCTION\n  const search = TestValidator.search(\"BbsArticleProvider.index()\")(async (\n    input: IBbsArticle.IRequest.ISearch,\n  ) => {\n    const page: IPage<IBbsArticle.ISummary> =\n      await api.functional.bbs.articles.index(connection, section, {\n        limit: articles.length,\n        search: input,\n        sort: [\"-created_at\"],\n      });\n    return page.data;\n  })(total.data, 10);\n\n  // SEARCH TITLE\n  await search({\n    fields: [\"title\"],\n    values: (article) => [article.title],\n    request: ([title]) => ({ title }),\n    filter: (article, [title]) => article.title.includes(title),\n  });\n\n  // SEARCH WRITER\n  await search({\n    fields: [\"writer\"],\n    values: (article) => [article.writer],\n    request: ([writer]) => ({ writer }),\n    filter: (article, [writer]) => article.writer.includes(writer),\n  });\n\n  // SEARCH BOTH OF THEM\n  await search({\n    fields: [\"title\", \"writer\"],\n    values: (article) => [article.title, article.writer],\n    request: ([title, writer]) => ({ title, writer }),\n    filter: (article, [title, writer]) =>\n      article.title.includes(title) && article.writer.includes(writer),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Swagger CLI Arguments\nDESCRIPTION: These commands demonstrate how to execute the Nestia Swagger generation tool using the command-line interface. The examples cover specifying a custom configuration file (`--config`) and a custom tsconfig.json file (`--project`).\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia swagger\nnpx nestia swagger --config nestia2.config.ts\nnpx nestia swagger --project tsconfig2.json\nnpx nestia swagger --config nestia3.config.ts --project tsconfig3.tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Advanced Calculator Implementation (TypeScript)\nDESCRIPTION: Implements the `IAdvancedCalculator` interface. It provides basic arithmetic operations (plus, minus, multiply, divide) and retrieves calculator metadata. It also uses a listener to notify events.  Dependencies include `tgrid` for driver functionality and application-specific interfaces for data structures.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Driver } from \"tgrid\";\n\nimport { IAdvancedCalculator } from \"../api/structures/IAdvancedCalculator\";\nimport { IHeader } from \"../api/structures/IHeader\";\nimport { IListener } from \"../api/structures/IListener\";\nimport { IMemo } from \"../api/structures/IMemo\";\n\nexport class AdvancedCalculator implements IAdvancedCalculator {\n  private round: (value: number) => number;\n\n  public constructor(\n    private readonly id: string,\n    private readonly header: IHeader,\n    private readonly memo: IMemo,\n    private readonly listener: Driver<IListener>,\n  ) {\n    this.round = roundPrecision(header.precision);\n  }\n\n  public getId(): string {\n    return this.id;\n  }\n  public getPrecision(): number {\n    return this.header.precision;\n  }\n  public getMemo(): IMemo {\n    return this.memo;\n  }\n\n  public plus(x: number, y: number): number {\n    const z: number = this.round(x + y);\n    this.listener.on({ type: \"plus\", x, y, z }).catch(() => {});\n    return z;\n  }\n  public minus(x: number, y: number): number {\n    const z: number = this.round(x - y);\n    this.listener.on({ type: \"minus\", x, y, z }).catch(() => {});\n    return z;\n  }\n  public multiply(x: number, y: number): number {\n    const z: number = this.round(x * y);\n    this.listener.on({ type: \"multiply\", x, y, z }).catch(() => {});\n    return z;\n  }\n  public divide(x: number, y: number): number {\n    const z: number = this.round(x / y);\n    this.listener.on({ type: \"divide\", x, y, z }).catch(() => {});\n    return z;\n  }\n}\n\nconst roundPrecision =\n  (precision: number) =>\n  (value: number): number => {\n    const factor: number = Math.pow(10, precision);\n    return Math.round(value * factor) / factor;\n  };\n```\n\n----------------------------------------\n\nTITLE: Nestia Configuration with File Pattern Input\nDESCRIPTION: This snippet configures Nestia to use a file pattern as input, enabling the tool to find and generate SDK definitions from controller files matching the specified pattern. The pattern targets `*.controller.ts` files within the `src` directory.  The output directory, simulation, distribution and e2e test locations are also configured.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/simulate.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst NESTIA_CONFIG: INestiaConfig = {\n  input: \"src/**/*.controller.ts\",\n  output: \"src/api\",\n  simulate: true,\n  distribute: \"packages/api\",\n  e2e: \"test\",\n};\nexport default NESTIA_CONFIG;\n```\n\n----------------------------------------\n\nTITLE: WebSocket Listener Interface Definition\nDESCRIPTION: Defines the interface for a WebSocket listener, which has an `on` method that accepts an event object containing the event type, x, y and z coordinates.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IListener {\n  on(event: IListener.IEvent): void;\n}\nexport namespace IListener {\n  export interface IEvent {\n    type: string;\n    x: number;\n    y: number;\n    z: number;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Multipart Form with NestJS UploadFile TypeScript\nDESCRIPTION: Demonstrates the traditional `@UploadFile()` approach for handling multipart/form-data requests in a NestJS controller.  It utilizes `@UseInterceptors` with `FileFieldsInterceptor` to handle file uploads and requires manual schema definition using `@ApiBody` for Swagger documentation.  It defines a `create` method to handle file uploads and other fields.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedFormData.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  Body, \n  Controller, \n  Post, \n  UploadedFile, \n  UploadedFiles, \n  UseInterceptors \n} from \"@nestjs/common\";\nimport { ApiBody, ApiConsumes } from \"@nestjs/swagger\";\nimport { FileFieldsInterceptor } from \"@nestjs/platform-express\";\nimport { IsArray, IsOptional, IsString } from \"class-validator\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  @Post()\n  @ApiConsumes(\"multipart/form-data\")\n  @UseInterceptors(\n    FileFieldsInterceptor([\n      { name: \"thumbnail\", maxCount: 1 },\n      { name: \"files\" },\n    ]),\n  )\n  @ApiBody({\n    schema: {\n      type: \"object\",\n      properties: {\n        title: {\n          type: \"string\",\n        },\n        body: {\n          type: \"string\",\n          nullable: true,\n        },\n        thumbnail: {\n          type: \"string\",\n          format: \"binary\",\n        },\n        files: {\n          type: \"array\",\n          items: {\n            type: \"string\",\n            format: \"binary\",\n          },\n        },\n      },\n      required: [\n        \"id\", \n        \"title\", \n        \"body\", \n        \"files\",\n        \"tags\",\n        \"created_at\",\n      ],\n    },\n  })\n  public async create(\n    @Body() input: BbsArticleCreateDto,\n    @UploadedFiles() binary: {\n      thumbnail?: Express.Multer.File[];\n      files: Express.Multer.File[];\n    },\n  ): Promise<void> {\n    input;\n    binary;\n  }\n}\n\nexport class BbsArticleCreateDto {\n  @IsString()\n  title: string;\n\n  @IsString()\n  @IsOptional()\n  body: string | null;\n\n  @IsArray({ each: true })\n  @IsString()\n  tags: string[];\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Controller with Swagger Customization\nDESCRIPTION: Demonstrates the usage of the `@SwaggerCustomizer` decorator within a NestJS controller. The decorator modifies the swagger object to include custom descriptions and properties.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/index.mdx#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SwaggerCustomizer, TypedParam, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { tags } from \"typia\";\n\n@Controller(\"custom\")\nexport class CustomController {\n  @SwaggerCustomizer((props: SwaggerCustomizer.IProps) => {\n    props.swagger.openapi = \"3.1.99\";\n    props.route.description = \"This is a custom description\";\n    (props.route as any)[\"x-special-symbol\"] = \"Something Special\";\n\n    const neighbor = props.at(CustomController.prototype.normal);\n    if (neighbor) {\n      neighbor.description = \"That is the normal description\";\n      (neighbor.route as any)[\"x-special-symbol\"] = \"Something Normal\";\n    }\n  })\n  @TypedRoute.Get(\":key/customize\")\n  public customize(@TypedParam(\"key\") key: number): string {\n    return key.toString();\n  }\n\n  @TypedRoute.Get(\":id/normal\")\n  public normal(@TypedParam(\"id\") id: string & tags.Format<\"uuid\">): string {\n    return id.toString();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Agentica Dependencies\nDESCRIPTION: This command installs the necessary npm packages for using Agentica in a NestJS project. The packages include @agentica/core for the core Agentic AI framework, @agentica/rpc for WebSocket RPC, @samchon/openapi for converting OpenAPI documents, and tgrid for WebSocket support.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/chat.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @agentica/core @agentica/rpc @samchon/openapi tgrid\n```\n\n----------------------------------------\n\nTITLE: Nestia Setup with npm (Bash)\nDESCRIPTION: This command installs Nestia as a dev dependency and then runs the setup wizard to configure it.  The setup wizard prompts for the package manager and whether to transform runtime Swagger.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save-dev nestia@latest\nnpx nestia setup\n```\n\n----------------------------------------\n\nTITLE: Creating Detailed Nestia Boilerplate (Bash)\nDESCRIPTION: This command generates a more comprehensive boilerplate project that includes Prisma ORM, a PostgreSQL database, and demonstrates Functional Programming (FP) and Test-Driven Development (TDD) practices in NestJS backend development.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia template <directory>\n```\n\n----------------------------------------\n\nTITLE: Creating Nestia Boilerplate Project (Bash)\nDESCRIPTION: This command creates a minimal boilerplate project focusing on SDK generation from a NestJS server within the specified directory. It does not include database connections.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia start <directory>\n```\n\n----------------------------------------\n\nTITLE: Deploy NPM Package\nDESCRIPTION: This bash script changes the current directory to `packages/api` and then runs the `npm run deploy` command. It assumes that the necessary build and deployment configurations are set up in the `package.json` file within the `packages/api` directory.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/distribute.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd packages/api\nnpm run deploy\n```\n\n----------------------------------------\n\nTITLE: Benchmark Servant Program with DynamicBenchmarker\nDESCRIPTION: Defines the servant program used by DynamicBenchmarker from @nestia/benchmark. This program specifies the connection details, location of test features, parameters for the connection, and a prefix for identifying test APIs.  It connects to the backend server and executes e2e test functions found in the specified directory. It relies on @nestia/benchmark and project-specific configurations.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/e2e/benchmark.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DynamicBenchmarker } from \"@nestia/benchmark\";\n\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\n\nDynamicBenchmarker.servant({\n  connection: {\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n  },\n  location: `${__dirname}/../features`,\n  parameters: (connection) => [connection],\n  prefix: \"test_api_\",\n}).catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n```\n\n----------------------------------------\n\nTITLE: Webpack Configuration for Single JS File (JavaScript)\nDESCRIPTION: This webpack configuration is optimized for creating a single, lightweight JavaScript file for a NestJS application, suitable for serverless environments. It includes configurations for copying environment files, Prisma engine files and ignoring optional dependencies.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nconst path = require(\"path\");\n\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\nconst WriteFilePlugin = require(\"write-file-webpack-plugin\");\nconst { IgnorePlugin } = require(\"webpack\");\n\nconst lazyImports = [\n  \"@fastify/static\",\n  \"@fastify/view\",\n  \"@nestjs/microservices\",\n  \"@nestjs/websockets\",\n  \"class-transformer\",\n  \"class-validator\",\n];\n\n// @reference https://tech-blog.s-yoshiki.com/entry/297\nmodule.exports = {\n  // CUSTOMIZE HERE\n  entry: {\n    server: \"./src/executable/server.ts\",\n  },\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"[name].js\",\n    chunkFormat: false,\n  },\n  optimization: {\n    minimize: true,\n  },\n\n  // JUST KEEP THEM\n  mode: \"production\",\n  target: \"node\",\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        loader: \"ts-loader\",\n      },\n    ],\n  },\n  resolve: {\n    extensions: [\".tsx\", \".ts\", \".js\"],\n  },\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: \".env\",\n          to: \"[name][ext]\",\n        },\n        {\n          from: \"package.json\",\n          to: \"[name][ext]\",\n        },\n        // {\n        //   from: \"node_modules/**/.prisma/client/*.node\",\n        //   to: () => Promise.resolve(\"[path][name][ext]\"),\n        //   globOptions: {\n        //     dot: true,\n        // },\n      ],\n    }),\n    new WriteFilePlugin(),\n    new IgnorePlugin({\n      checkResource: (resource) => {\n        if (lazyImports.some((modulo) => resource.startsWith(modulo))) {\n          try {\n            require.resolve(resource);\n          } catch (err) {\n            return true;\n          }\n        }\n        return false;\n      },\n    }),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: tsconfig.lib.json Configuration for NX\nDESCRIPTION: This configures the `tsconfig.lib.json` file for Nestia transformations within an NX monorepo. It adds `typia`, `@nestia/core`, and `@nestia/sdk` as TypeScript plugins, enabling runtime swagger composition, validation, and stringification.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_20\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"../../dist/out-tsc\",\n    \"declaration\": true,\n    \"types\": [],\n    \"plugins\": [\n      { \"transform\": \"typia/lib/transform\" },\n      { \n        \"transform\": \"@nestia/core/lib/transform\",\n        \"validate\": \"validate\",\n        \"stringify\": \"assert\", \n      },\n      { \"transform\": \"@nestia/sdk/lib/transform\" }, // for runtime swagger composition\n    ],\n  },\n  \"include\": [\"**/*.ts\"],\n  \"exclude\": [\"jest.config.ts\", \"**/*.spec.ts\", \"**/*.test.ts\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Define Headers Interface TypeScript\nDESCRIPTION: Defines a TypeScript interface `IHeaders` that specifies the structure and types of expected request headers.  This interface includes required and optional header fields with specific types, including string unions, strings, numbers, and boolean arrays. The interface is used by Nestia for automatic validation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedHeaders.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IHeaders {\n  \"x-category\": \"x\" | \"y\" | \"z\";\n  \"x-memo\"?: string;\n  \"x-name\"?: string;\n  \"x-values\": number[];\n  \"x-flags\": boolean[];\n  \"X-Descriptions\": string[]; // ALLOW UPPER-CASE\n}\n```\n\n----------------------------------------\n\nTITLE: IAdvancedCalculator Interface (TypeScript)\nDESCRIPTION: Defines the interface `IAdvancedCalculator` which includes methods for basic arithmetic operations and accessing the calculator's ID, precision, and memo.  It depends on the `IMemo` interface.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IMemo } from \"./IMemo\";\n\nexport interface IAdvancedCalculator {\n  plus(a: number, b: number): number;\n  minus(a: number, b: number): number;\n  multiply(a: number, b: number): number;\n  divide(a: number, b: number): number;\n\n  getId(): string;\n  getPrecision(): number;\n  getMemo(): IMemo;\n}\n```\n\n----------------------------------------\n\nTITLE: Nestia Setup with NX (npm)\nDESCRIPTION: This command initializes Nestia in an NX monorepo project using npm. It's used to configure the project for Nestia's code transformations.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia setup\n```\n\n----------------------------------------\n\nTITLE: Run Prepare Script (pnpm)\nDESCRIPTION: This command executes the `prepare` script using pnpm, which installs ts-patch and patches typia.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\npnpm run prepare\n```\n\n----------------------------------------\n\nTITLE: Define nestia DTO with Interfaces\nDESCRIPTION: This code snippet demonstrates how DTOs are defined in nestia using pure TypeScript interfaces. It showcases the simplicity and readability of this approach, requiring minimal code and being inherently type-safe. It utilizes typia for type validation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/pure.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\nexport interface IBbsArticle {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * List of attached files.\n   */\n  files: null | IAttachmentFile[];\n\n  /**\n   * Title of the article.\n   */\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\n\n  /**\n   * Main content body of the article.\n   */\n  body: string;\n\n  /**\n   * Creation time of article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n}\n\nexport interface IAttachmentFile {\n  /**\n   * File name.\n   */\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\n\n  /**\n   * File extension.\n   */\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\n\n  /**\n   * URL of the file.\n   */\n  url: string & tags.Format<\"uri\">;\n}\n```\n\n----------------------------------------\n\nTITLE: Run Prepare Script (yarn)\nDESCRIPTION: This command executes the `prepare` script using yarn, which installs ts-patch and patches typia.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nyarn run prepare\n```\n\n----------------------------------------\n\nTITLE: Implement Header Controller JavaScript\nDESCRIPTION: Compiled JavaScript code for the `HeadersController`, showing how Nestia generates validation logic. The code uses decorators from `@nestjs/common` and `@nestia/core`. It uses complex logic for type validation and conversion, automatically generated by Nestia based on the Typescript interface.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/TypedHeaders.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n\"use strict\";\nvar __decorate =\n  (this && this.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nvar __metadata =\n  (this && this.__metadata) ||\n  function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n      return Reflect.metadata(k, v);\n  };\nvar __param =\n  (this && this.__param) ||\n  function (paramIndex, decorator) {\n    return function (target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HeadersController = void 0;\nconst common_1 = require(\"@nestjs/common\");\nconst core_1 = __importDefault(require(\"@nestia/core\"));\nlet HeadersController = (exports.HeadersController = class HeadersController {\n  /**\n   * Emplace headers.\n   *\n   * @param headers Headers for authentication\n   * @param section Target section code\n   * @returns Store article\n   *\n   * @author Samchon\n   */\n  emplace(headers, section) {\n    headers;\n    section;\n  }\n});\n__decorate(\n  [\n    (0, common_1.Get)(),\n    __param(\n      0,\n      core_1.default.TypedHeaders((input) => {\n        const $number = core_1.default.TypedHeaders.number;\n        const $boolean = core_1.default.TypedHeaders.boolean;\n        const $string = core_1.default.TypedHeaders.string;\n        const output = {\n          \"x-category\": input[\"x-category\"],\n          \"x-memo\": input[\"x-memo\"],\n          \"x-name\": input[\"x-name\"],\n          \"x-values\": input[\"x-values\"]?.split(\", \")?.map($number),\n          \"x-flags\": input[\"x-flags\"]?.split(\", \")?.map($boolean),\n          \"X-Descriptions\": input[\"x-descriptions\"]?.split(\", \")?.map($string),\n          // AUTOMATIC UPPER-CASE CONVERTING\n        };\n        return ((input) => {\n          const __is = (input) => {\n            const $io0 = (input) =>\n              (\"x\" === input[\"x-category\"] ||\n                \"y\" === input[\"x-category\"] ||\n                \"z\" === input[\"x-category\"]) &&\n              (undefined === input[\"x-memo\"] ||\n                \"string\" === typeof input[\"x-memo\"]) &&\n              (undefined === input[\"x-name\"] ||\n                \"string\" === typeof input[\"x-name\"]) &&\n              Array.isArray(input[\"x-values\"]) &&\n              input[\"x-values\"].every(\n                (elem) => \"number\" === typeof elem && Number.isFinite(elem),\n              ) &&\n              Array.isArray(input[\"x-flags\"]) &&\n              input[\"x-flags\"].every((elem) => \"boolean\" === typeof elem) &&\n              Array.isArray(input[\"X-Descriptions\"]) &&\n              input[\"X-Descriptions\"].every((elem) => \"string\" === typeof elem);\n            return \"object\" === typeof input && null !== input && $io0(input);\n          };\n          if (false === __is(input))\n            ((input, _path, _exceptionable = true) => {\n              const $guard = core_1.default.TypedHeaders.guard;\n              const $ao0 = (input, _path, _exceptionable = true) =>\n                (\"x\" === input[\"x-category\"] ||\n                  \"y\" === input[\"x-category\"] ||\n                  \"z\" === input[\"x-category\"] ||\n                  $guard(_exceptionable, {\n                    path: _path + '[\"x-category\"]',\n                    expected: '(\"x\" | \"y\" | \"z\")',\n                    value: input[\"x-category\"],\n                  })) &&\n                (undefined === input[\"x-memo\"] ||\n                  \"string\" === typeof input[\"x-memo\"] ||\n                  $guard(_exceptionable, {\n                    path: _path + '[\"x-memo\"]',\n                    expected: \"(string | undefined)\",\n                    value: input[\"x-memo\"],\n                  })) &&\n                (undefined === input[\"x-name\"] ||\n                  \"string\" === typeof input[\"x-name\"] ||\n                  $guard(_exceptionable, {\n                    path: _path + '[\"x-name\"]',\n                    expected: \"(string | undefined)\",\n                    value: input[\"x-name\"],\n                  })) &&\n                (((Array.isArray(input[\"x-values\"]) ||\n                  $guard(_exceptionable, {\n                    path: _path + '[\"x-values\"]',\n                    expected: \"Array<number>\",\n                    value: input[\"x-values\"],\n                  })) &&\n                  input[\"x-values\"].every(\n                    (elem, _index1) =>\n                      (\"number\" === typeof elem && Number.isFinite(elem)) ||\n                      $guard(_exceptionable, {\n                        path: _path + '[\"x-values\"][' + _index1 + ']\",\n                        expected: \"number\",\n                        value: elem,\n                      }),\n                  )) ||\n                  $guard(_exceptionable, {\n                    path: _path + '[\"x-values\"]',\n                    expected: \"Array<number>\",\n                    value: input[\"x-values\"],\n                  })) &&\n                (((Array.isArray(input[\"x-flags\"]) ||\n                  $guard(_exceptionable, {\n                    path: _path + '[\"x-flags\"]',\n                    expected: \"Array<boolean>\",\n                    value: input[\"x-flags\"],\n                  })) &&\n                  input[\"x-flags\"].every(\n                    (elem, _index2) =>\n                      \"boolean\" === typeof elem ||\n                      $guard(_exceptionable, {\n                        path: _path + '[\"x-flags\"][' + _index2 + ']\",\n                        expected: \"boolean\",\n                        value: elem,\n                      }),\n                  )) ||\n                  $guard(_exceptionable, {\n                    path: _path + '[\"x-flags\"]',\n                    expected: \"Array<boolean>\",\n                    value: input[\"x-flags\"],\n                  })) &&\n                (((Array.isArray(input[\"X-Descriptions\"]) ||\n                  $guard(_exceptionable, {\n                    path: _path + '[\"X-Descriptions\"]',\n                    expected: \"Array<string>\",\n                    value: input[\"X-Descriptions\"],\n                  })) &&\n                  input[\"X-Descriptions\"].every(\n                    (elem, _index3) =>\n                      \"string\" === typeof elem ||\n                      $guard(_exceptionable, {\n                        path: _path + '[\"X-Descriptions\"][' + _index3 + ']\",\n                        expected: \"string\",\n                        value: elem,\n                      }),\n                  )) ||\n                  $guard(_exceptionable, {\n                    path: _path + '[\"X-Descriptions\"]',\n                    expected: \"Array<string>\",\n                    value: input[\"X-Descriptions\"],\n                  }));\n              return (\n                ((\"object\" === typeof input && null !== input) ||\n                  $guard(true, {\n                    path: _path + \"\",\n                    expected: \"IHeaders\",\n                    value: input,\n                  })) &&\n                  $ao0(input, _path + \"\", true)) ||\n                $guard(true, {\n                  path: _path + \"\",\n                  expected: \"IHeaders\",\n                  value: input,\n                })\n              );\n            })(input, \"$input\", true);\n          return input;\n        })(output);\n      }),\n    ),\n    __param(1, core_1.default.TypedParam(\"section\", \"string\", false)),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object, String]),\n    __metadata(\"design:returntype\", void 0),\n  ],\n  HeadersController.prototype,\n  \"emplace\",\n  null\n);\nexports.HeadersController = HeadersController = __decorate(\n  [(0, common_1.Controller)(\"headers/:section\")],\n  HeadersController\n);\n\n```\n\n----------------------------------------\n\nTITLE: Building and Installing with yarn (Bash)\nDESCRIPTION: These commands run webpack to build the project, removes the node_modules directory and then use yarn to perform a clean install in production mode, omitting dev dependencies, ignoring scripts and uses immutable installs.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nyarn webpack\nrm -rf node_modules\nyarn install --production --ignore-scripts --immutable\n```\n\n----------------------------------------\n\nTITLE: Manual Nestia Setup (yarn)\nDESCRIPTION: This command installs the necessary dependencies for Nestia, TypeScript, ts-node, ts-patch, @nestia/core, @nestia/e2e, @nestia/sdk and typia using yarn package manager.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\n# COMPILERS\nyarn add -D typescript\nyarn add -D ts-node\nyarn add -D ts-patch\n\n# NESTIA\nyarn add -D nestia\nyarn add -D @nestia/sdk\nyarn add @nestia/core\nyarn add @nestia/e2e\nyarn add typia\n```\n\n----------------------------------------\n\nTITLE: Building and Testing Nestia\nDESCRIPTION: These commands compile the Nestia project and run the test automation suite. Successful compilation and passing tests are prerequisites for contributing code.\nSOURCE: https://github.com/samchon/nestia/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# COMPILE\nnpm run build\n\n# DO TEST\nnpm run test\n```\n\n----------------------------------------\n\nTITLE: Custom JSON Stringify for IBbsArticle\nDESCRIPTION: This snippet creates a custom stringify function optimized for serializing IBbsArticle objects into JSON format. It utilizes template literals and manually constructs the JSON string, potentially for better performance than standard JSON.stringify.  It handles null values and escapes strings.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/pure.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringify = (input) => {\n  const $io1 = (input) =>\n    (null === input.name ||\n      (\"string\" === typeof input.name &&\n        1 <= input.name.length &&\n        input.name.length <= 255)) &&\n    (null === input.extension ||\n      (\"string\" === typeof input.extension &&\n        1 <= input.extension.length &&\n        input.extension.length <= 8)) &&\n    \"string\" === typeof input.url &&\n    /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\n    input.url\n    );\n  const $string = core_1.TypedRoute.Post.string;\n  const $so0 = (input) =>\n    `{\"id\":${$string(input.id)},\"created_at\":${$string(\n      input.created_at,\n    )},\"title\":${$string(input.title)},\"body\":${$string(\n      input.body,\n    )},\"files\":${`[${input.files\n      .map((elem) => $so1(elem))\n      .join(\",\")}]`}}`;\n  const $so1 = (input) =>\n    `{\"name\":${\n      null !== input.name ? $string(input.name) : \"null\"\n    },\"extension\":${\n      null !== input.extension ? $string(input.extension) : \"null\"\n    },\"url\":${$string(input.url)}}`;\n  return $so0(input);\n};\n```\n\n----------------------------------------\n\nTITLE: Installing dependencies for Single JS file with pnpm (Bash)\nDESCRIPTION: These commands install nestia, ts-loader, webpack, webpack-cli, copy-webpack-plugin and write-file-webpack-plugin as dev dependencies using pnpm to create a light JS bundling of the NestJS project.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n# SETUP NESTIA\nnpx nestia setup --manager pnpm\n\n# INSTALL SPECIAL DEPENDENCIES\npnpm install --save-dev ts-loader\npnpm install --save-dev webpack webpack-cli\npnpm install --save-dev copy-webpack-plugin write-file-webpack-plugin\n```\n\n----------------------------------------\n\nTITLE: Installing dependencies for Single JS file with npm (Bash)\nDESCRIPTION: These commands install nestia, ts-loader, webpack, webpack-cli, copy-webpack-plugin and write-file-webpack-plugin as dev dependencies using npm to create a light JS bundling of the NestJS project.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n# SETUP NESTIA\nnpx nestia setup\n\n# INSTALL SPECIAL DEPENDENCIES\nnpm install --save-dev ts-loader\nnpm install --save-dev webpack webpack-cli\nnpm install --save-dev copy-webpack-plugin write-file-webpack-plugin\n```\n\n----------------------------------------\n\nTITLE: Setting up Nestia using yarn (Bash)\nDESCRIPTION: This command initiates the Nestia setup wizard using yarn. Yarn berry is not supported.  During the setup, you will be prompted to configure runtime swagger.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx nestia setup --manager yarn\n```\n\n----------------------------------------\n\nTITLE: HTML Meta Refresh Redirection\nDESCRIPTION: This snippet implements an HTTP meta refresh to redirect the user to a new URL. It utilizes the `http-equiv` attribute to specify the type of refresh and the `content` attribute to set the delay (0 seconds) and the destination URL (`/docs/swagger/editor/`).\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/editor.mdx#_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<meta http-equiv=\"refresh\" content=\"0; url=/docs/swagger/editor/\"></meta>\n```\n\n----------------------------------------\n\nTITLE: Building and Installing with npm (Bash)\nDESCRIPTION: These commands run webpack to build the project and then use npm to perform a clean install in production mode, omitting dev dependencies and ignoring scripts.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnpx webpack\nnpm ci --omit=dev --ignore-scripts\n```\n\n----------------------------------------\n\nTITLE: SomeQueryDto Interface Definition in TypeScript\nDESCRIPTION: Defines the SomeQueryDto interface in TypeScript, illustrating the valid and invalid property types for WebSocket query parameters. It includes examples of allowed atomic types (boolean, number, string, bigint, literal union) and array types (nullable element array, string array, number array, literal union array, literal tuple), as well as disallowed mixed union types, optional types, and mixed literal arrays/tuples.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/core/WebSocketRoute.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SomeQueryDto {\n  //----\n  // ATOMIC TYPES\n  //----\n  // ALLOWED\n  boolean: boolean;\n  number: number;\n  string: string;\n  bigint: bigint;\n  optional_number?: number;\n  nullable_string: string | null;\n  literal_union: \"A\" | \"B\" | \"C\" | \"D\";\n\n  // NOT ALLOWED\n  mixed_union: string | number | boolean;\n  mixed_literal: \"A\" | \"B\" | 3;\n\n  //----\n  // ARRAY TYPES\n  //----\n  // ALLOWED\n  nullable_element_array: (string | null)[];\n  string_array: string[];\n  number_array: number[];\n  literal_union_array: (\"A\" | \"B\" | \"C\")[];\n  literal_tuple: [\"A\", \"B\", \"C\"];\n\n  // NOT ALLOWED\n  optional_element_array: (string | undefined)[];\n  optional_array: string[] | undefined;\n  nullable_array: string[] | null;\n  union_atomic_array: (string | number)[];\n  mixed_literal_array: (\"A\", \"B\", 3)[];\n  mixed_tuple: [\"A\", \"B\", 3];\n}\n```\n\n----------------------------------------\n\nTITLE: Importing React Components\nDESCRIPTION: This snippet imports necessary React components from local modules. `HomeLayout` provides the overall page layout, while `HomeHeroMovie` and `HomeStrengthMovie` are responsible for rendering specific movie sections within the layout. This is necessary to construct the page layout.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/index.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport HomeLayout from \"../src/components/home/HomeLayout\";\nimport HomeHeroMovie from \"../src/movies/home/HomeHeroMovie\";\nimport HomeStrengthMovie from \"../src/movies/home/HomeStrengthMovie\";\n```\n\n----------------------------------------\n\nTITLE: NestJS Controller: BbsArticlesController\nDESCRIPTION: Defines a NestJS controller `BbsArticlesController` with methods for storing and updating articles. It utilizes `@nestia/core` for typed routes and parameters, and `typia` for generating random data. The `store` method creates a new article, and the `update` method updates an existing article. Both methods accept a `section` parameter, and the `update` method also accepts an `id` parameter with UUID format validation.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/sdk/e2e.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Controller } from \"@nestjs/common\";\nimport typia, { tags } from \"typia\";\n\nimport core from \"@nestia/core\";\n\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles/:section\")\nexport class BbsArticlesController {\n  /**\n   * Store a new article.\n   *\n   * @param section Section code\n   * @param input Content to store\n   * @returns Newly archived article\n   */\n  @core.TypedRoute.Post()\n  public async store(\n    @core.TypedParam(\"section\") section: string,\n    @core.TypedBody() input: IBbsArticle.IStore,\n  ): Promise<IBbsArticle> {\n    return {\n      ...typia.random<IBbsArticle>(),\n      section,\n      ...input,\n    };\n  }\n\n  /**\n   * Update an article.\n   *\n   * @param section Section code\n   * @param id Target article ID\n   * @param input Content to update\n   * @returns Updated content\n   */\n  @core.TypedRoute.Put(\":id\")\n  public async update(\n    @core.TypedParam(\"section\") section: string,\n    @core.TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n    @core.TypedBody() input: IBbsArticle.IStore,\n  ): Promise<IBbsArticle> {\n    return {\n      ...typia.random<IBbsArticle>(),\n      id,\n      section,\n      ...input,\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Hero Movie Section\nDESCRIPTION: This snippet renders the hero movie section within the `HomeLayout` component. The `HomeHeroMovie` component is placed inside the `HomeLayout`, ensuring it's displayed according to the layout's structure. It contributes to the visual presentation of the homepage.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/index.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<HomeLayout>\n  <HomeHeroMovie />\n</HomeLayout>\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica with Pseudo Code\nDESCRIPTION: This code snippet demonstrates the basic initialization of the Agentica framework. It shows how to fetch a Swagger document and use typia to create LLM applications. It simulates the creation of an Agentica instance with controllers defined by the Swagger document and typia applications, initiating a conversation with the chatbot.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/swagger/chat.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\n\nconst agent = new Agentica({\n  controllers: [\n    await fetch(\n      \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n    ).then(r => r.json()),\n    typia.llm.application<ShoppingCounselor>(),\n    typia.llm.application<ShoppingPolicy>(),\n    typia.llm.application<ShoppingSearchRag>(),\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\n----------------------------------------\n\nTITLE: Building and Installing with pnpm (Bash)\nDESCRIPTION: These commands run webpack to build the project and then use pnpm to perform a clean install in production mode, omitting dev dependencies and ignoring scripts.\nSOURCE: https://github.com/samchon/nestia/blob/master/website/pages/docs/setup.mdx#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\npnpm webpack\npnpm install --production --ignore-scripts\n```"
  }
]