[
  {
    "owner": "google",
    "repo": "flatbuffers",
    "content": "TITLE: Defining FlatBuffers Schema - Monster Example\nDESCRIPTION: A sample FlatBuffers schema (.fbs) that defines data structures for a monster game including vectors, tables, structs, unions and enums. The schema demonstrates core FlatBuffers concepts like namespaces, default values, and root types.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\n// Example IDL file for our monster's schema.\n\nnamespace MyGame.Sample;\n\nenum Color:byte { Red = 0, Green, Blue = 2 }\n\n// Optionally add more tables.\nunion Equipment { Weapon }\n\nstruct Vec3 {\n  x:float;\n  y:float;\n  z:float;\n}\n\ntable Monster {\n  pos:Vec3;\n  mana:short = 150;\n  hp:short = 100;\n  name:string;\n  friendly:bool = false (deprecated);\n  inventory:[ubyte];\n  color:Color = Blue;\n  weapons:[Weapon];\n  equipped:Equipment;\n  path:[Vec3];\n}\n\ntable Weapon {\n  name:string;\n  damage:short;\n}\n\nroot_type Monster;\n```\n\n----------------------------------------\n\nTITLE: Reading FlatBuffer Binary File in C++\nDESCRIPTION: Example showing how to read a FlatBuffer binary file into memory and access its root monster object. Demonstrates file handling and basic FlatBuffer access.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include \"flatbuffers/flatbuffers.h\"\n#include \"monster_test_generate.h\"\n#include <iostream> // C++ header file for printing\n#include <fstream> // C++ header file for file access\n\n\nstd::ifstream infile;\ninfile.open(\"monsterdata_test.mon\", std::ios::binary | std::ios::in);\ninfile.seekg(0,std::ios::end);\nint length = infile.tellg();\ninfile.seekg(0,std::ios::beg);\nchar *data = new char[length];\ninfile.read(data, length);\ninfile.close();\n\nauto monster = GetMonster(data);\n```\n\n----------------------------------------\n\nTITLE: Defining a Table in FlatBuffers Schema\nDESCRIPTION: Example of defining a table in FlatBuffers schema. Shows various field types, default values, and attributes. Tables are the main way of defining objects in FlatBuffers.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_1\n\nLANGUAGE: c\nCODE:\n```\ntable Monster {\n  pos:Vec3;\n  mana:short = 150;\n  hp:short = 100;\n  name:string;\n  friendly:bool = false (deprecated, priority: 1);\n  inventory:[ubyte];\n  color:Color = Blue;\n  test:Any;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FlatBuffers Schema in C\nDESCRIPTION: Example of a FlatBuffers schema file defining a Monster table with various field types, enums, and unions. Demonstrates core schema concepts like namespaces, attributes, and root type declaration.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n// example IDL file\n\nnamespace MyGame;\n\nattribute \"priority\";\n\nenum Color : byte { Red = 1, Green, Blue }\n\nunion Any { Monster, Weapon, Pickup }\n\nstruct Vec3 {\n  x:float;\n  y:float;\n  z:float;\n}\n\ntable Monster {\n  pos:Vec3;\n  mana:short = 150;\n  hp:short = 100;\n  name:string;\n  friendly:bool = false (deprecated, priority: 1);\n  inventory:[ubyte];\n  color:Color = Blue;\n  test:Any;\n}\n\ntable Weapon {}\ntable Pickup {}\n\nroot_type Monster;\n```\n\n----------------------------------------\n\nTITLE: FlatBuffers Builder Initialization\nDESCRIPTION: Examples of initializing FlatBufferBuilder objects across different programming languages with a 1024 byte backing array.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nflatbuffers::FlatBufferBuilder builder(1024);\n```\n\nLANGUAGE: c\nCODE:\n```\nflatcc_builder_t builder, *B;\nB = &builder;\n// Initialize the builder object.\nflatcc_builder_init(B);\n```\n\nLANGUAGE: c#\nCODE:\n```\nFlatBufferBuilder builder = new FlatBufferBuilder(1024);\n```\n\nLANGUAGE: dart\nCODE:\n```\nvar builder = new fb.Builder(initialSize: 1024);\n```\n\nLANGUAGE: go\nCODE:\n```\nbuilder := flatbuffers.NewBuilder(1024)\n```\n\nLANGUAGE: java\nCODE:\n```\nFlatBufferBuilder builder = new FlatBufferBuilder(1024);\n```\n\nLANGUAGE: javascript\nCODE:\n```\nvar builder = new flatbuffers.Builder(1024);\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nval builder = FlatBufferBuilder(1024)\n```\n\nLANGUAGE: lobster\nCODE:\n```\nlet builder = flatbuffers_builder {}\n```\n\nLANGUAGE: lua\nCODE:\n```\nlocal builder = flatbuffers.Builder(1024)\n```\n\nLANGUAGE: php\nCODE:\n```\n$builder = new Google\\FlatBuffers\\FlatbufferBuilder(1024);\n```\n\nLANGUAGE: python\nCODE:\n```\nbuilder = flatbuffers.Builder(1024)\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet mut builder = flatbuffers::FlatBufferBuilder::with_capacity(1024);\n```\n\nLANGUAGE: swift\nCODE:\n```\nlet builder = FlatBufferBuilder(initialSize: 1024)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nlet builder = new flatbuffers.Builder(1024);\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with C\nDESCRIPTION: Shows how to access a vector of Weapon tables from a Monster object using C. The code gets the vector length and accesses the name and damage fields of the second weapon.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_161\n\nLANGUAGE: C\nCODE:\n```\nns(Weapon_vec_t) weapons = ns(Monster_weapons(monster));\nsize_t weapons_len = ns(Weapon_vec_len(weapons));\n// We can use `const char *` instead of `flatbuffers_string_t`.\nconst char *second_weapon_name = \n    ns(Weapon_name(ns(Weapon_vec_at(weapons, 1))));\nuint16_t second_weapon_damage = \n    ns(Weapon_damage(ns(Weapon_vec_at(weapons, 1))));\n```\n\n----------------------------------------\n\nTITLE: Using Object-based API with FlatBuffers in TypeScript\nDESCRIPTION: Demonstrates the object-based API for FlatBuffers, including deserialization from buffer to object, direct object manipulation, and serialization back to FlatBuffer format.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/typescript.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n    // Autogenerated class from table Monster.\n    let monsterobj = new MonsterT();\n\n    // Deserialize from buffer into object.\n    Monster.getRootAsMonster(flatbuffer).unpackTo(monsterobj);\n    // or\n    let monsterobj = Monster.getRootAsMonster(flatbuffer).unpack();\n\n    // Update object directly like a regular TS class instance.\n    console.log(monsterobj.name);\n    monsterobj.name = \"Bob\";\n\n    // Serialize into new flatbuffer.\n    let fbb = new flatbuffers.Builder(1);\n    Monster.finishMonsterBuffer(fbb, monsterobj.pack(fbb));\n```\n\n----------------------------------------\n\nTITLE: Generating Code from FlatBuffer Schema\nDESCRIPTION: Command to use the flatc compiler to generate C++ and Rust code from a FlatBuffer schema file.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/quick_start.md#2025-04-16_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n./flatc --cpp --rust mosnter.fbs\n```\n\n----------------------------------------\n\nTITLE: Creating Monster Object in Rust\nDESCRIPTION: Creates a Monster object in Rust using the FlatBuffers builder. It sets various properties like position, mana, hp, name, inventory, color, weapons, and equipment.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_81\n\nLANGUAGE: rust\nCODE:\n```\nlet orc = Monster::create(&mut builder, &MonsterArgs{\n    pos: Some(&Vec3::new(1.0f32, 2.0f32, 3.0f32)),\n    mana: 150,\n    hp: 80,\n    name: Some(name),\n    inventory: Some(inventory),\n    color: Color::Red,\n    weapons: Some(weapons),\n    equipped_type: Equipment::Weapon,\n    equipped: Some(axe.as_union_value()),\n    path: Some(path),\n    ..Default::default()\n});\n```\n\n----------------------------------------\n\nTITLE: Serializing Data with FlatBuffers in C++\nDESCRIPTION: C++ code snippet demonstrating how to use FlatBufferBuilder to serialize a Monster object.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/quick_start.md#2025-04-16_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include \"flatbuffers.h\"\n#include \"monster_generated.h\"\n\nint main() { \n  // Used to build the flatbuffer\n  FlatBufferBuilder builder;\n\n  // Auto-generated function emitted from `flatc` and the input \n  // `monster.fbs` schema.\n  auto monster = CreateMonsterDirect(builder, \"Abominable Snowman\", 100);\n\n  // Finalize the buffer.\n  builder.Finish(monster);\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with C#\nDESCRIPTION: This C# example shows how to build a Monster object with a union field in FlatBuffers. It demonstrates using StartMonster/EndMonster pattern and explicitly setting both the union type and value fields.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\n// Create the remaining data needed for the Monster.\nvar name = builder.CreateString(\"Orc\");\n\n// Create our monster using `StartMonster()` and `EndMonster()`.\nMonster.StartMonster(builder);\nMonster.AddPos(builder, Vec3.CreateVec3(builder, 1.0f, 2.0f, 3.0f));\nMonster.AddHp(builder, (short)300);\nMonster.AddName(builder, name);\nMonster.AddInventory(builder, inv);\nMonster.AddColor(builder, Color.Red);\nMonster.AddWeapons(builder, weapons);\n// For union fields, we explicitly add the auto-generated enum for the type\n// of value stored in the union.\nMonster.AddEquippedType(builder, Equipment.Weapon);\n// And we just use the `.Value` property of the already serialized axe.\nMonster.AddEquipped(builder, axe.Value); // Axe\nMonster.AddPath(builder, path);\nOffset<Monster> orc = Monster.EndMonster(builder);\n```\n\n----------------------------------------\n\nTITLE: Object-Based API Usage in C++\nDESCRIPTION: Demonstrates the object-based API for FlatBuffers, showing how to unpack a buffer into objects and pack them back.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n// Autogenerated class from table Monster.\nMonsterT monsterobj;\n\n// Deserialize from buffer into object.\nGetMonster(flatbuffer)->UnPackTo(&monsterobj);\n\n// Update object directly like a C++ class instance.\ncout << monsterobj.name;  // This is now a std::string!\nmonsterobj.name = \"Bob\";  // Change the name.\n\n// Serialize into new flatbuffer.\nFlatBufferBuilder fbb;\nfbb.Finish(Monster::Pack(fbb, &monsterobj));\n```\n\n----------------------------------------\n\nTITLE: Reading Data from Serialized FlatBuffer in C++\nDESCRIPTION: C++ code snippet demonstrating how to read data from a serialized FlatBuffer using generated accessors.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/quick_start.md#2025-04-16_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n// Get a view of the root monster from the flatbuffer.\nconst Monster snowman = GetMonster(flatbuffer);\n\n// Access the monster's fields directly.\nASSERT_EQ(snowman->name(), \"Abominable Snowman\");\nASSERT_EQ(snowman->health(), 100);\n```\n\n----------------------------------------\n\nTITLE: Reading FlatBuffer Binary File in Go\nDESCRIPTION: This snippet demonstrates how to read a FlatBuffer binary file in Go. It imports necessary packages, reads the binary file into a byte slice, and uses the generated GetRootAsMonster function to access the data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/go.md#2025-04-16_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n   example \"MyGame/Example\"\n   flatbuffers \"github.com/google/flatbuffers/go\"\n\n   \"os\"\n)\n\nbuf, err := os.ReadFile(\"monster.dat\")\n// handle err\nmonster := example.GetRootAsMonster(buf, 0)\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer Monster Fields in C++\nDESCRIPTION: Shows how to access various fields of a monster object from a FlatBuffer using the generated accessor methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstd::cout << \"hp : \" << monster->hp() << std::endl;              // '80'\nstd::cout << \"mana : \" << monster->mana() << std::endl;          // default value of '150'\nstd::cout << \"name : \" << monster->name()->c_str() << std::endl; // \"MyMonster\"\n```\n\n----------------------------------------\n\nTITLE: Verifying FlatBuffer Data Safety with Buffer Verifier in C++\nDESCRIPTION: Example showing how to use the buffer verifier to check if a FlatBuffer is safe to read. This is especially important when processing data from untrusted sources to prevent crashes from malformed buffers.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nbool ok = VerifyMonsterBuffer(Verifier(buf, len));\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (TypeScript)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in TypeScript. Similar to JavaScript, wraps a Uint8Array in a flatbuffers.ByteBuffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_114\n\nLANGUAGE: TypeScript\nCODE:\n```\n// the data you just read, as a `Uint8Array`.\n// Note that the example here uses `readFileSync` from the built-in `fs` \n// module, but other methods for accessing the file contents will also work.\nlet bytes = new Uint8Array(readFileSync('./monsterdata.bin'));\n\nlet buf = new flatbuffers.ByteBuffer(bytes);\n\n// Get an accessor to the root object inside the buffer.\nlet monster = MyGame.Sample.Monster.getRootAsMonster(buf);\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer Values\nDESCRIPTION: Example showing how to access values from a FlatBuffer Monster object after it has been parsed from binary data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/javascript.md#2025-04-16_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar hp = monster.hp();\nvar pos = monster.pos();\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer Vector as Numpy Array in Python\nDESCRIPTION: This snippet demonstrates how to access a scalar vector from a FlatBuffer as a Numpy array for improved performance.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/python.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ninventory = monster.InventoryAsNumpy()\n# inventory is a numpy array of type np.dtype('uint8')\n```\n\n----------------------------------------\n\nTITLE: Using Object-Based API with FlatBuffers in Dart\nDESCRIPTION: This snippet demonstrates the object-based API for FlatBuffers in Dart, which allows for unpacking a FlatBuffer into objects for easier manipulation, and then packing it back into a FlatBuffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/dart.md#2025-04-16_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n    // Deserialize from buffer into object.\n    MonsterT monster = Monster(flatbuffer).unpack();\n\n    // Update object directly like a Dart class instance.\n    print(monster.Name);\n    monster.Name = \"Bob\";  // Change the name.\n\n    // Serialize into new flatbuffer.\n    final fbb = Builder();\n    fbb.Finish(monster.pack(fbb));\n```\n\n----------------------------------------\n\nTITLE: Reading FlatBuffer Binary File in Python\nDESCRIPTION: This snippet demonstrates how to import the FlatBuffers library and generated code, read a FlatBuffer binary file into a bytearray, and access the root object.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/python.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport MyGame.Example as example\nimport flatbuffers\n\nbuf = open('monster.dat', 'rb').read()\nbuf = bytearray(buf)\nmonster = example.GetRootAsMonster(buf, 0)\n```\n\n----------------------------------------\n\nTITLE: Defining a Union in FlatBuffers Schema\nDESCRIPTION: Example of defining a union in FlatBuffers schema. Shows how to create a union of different table types and use alias names for union members.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_6\n\nLANGUAGE: txt\nCODE:\n```\ntable PointPosition { x:uint; y:uint; }\ntable MarkerPosition {}\nunion Position {\n  Start:MarkerPosition,\n  Point:PointPosition,\n  Finish:MarkerPosition\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in Go\nDESCRIPTION: Creates a FlatBuffer vector by prepending weapon offsets in reverse order. Uses MonsterStartWeaponsVector and EndVector methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_41\n\nLANGUAGE: go\nCODE:\n```\n// Create a FlatBuffer vector and prepend the weapons.\n// Note: Since we prepend the data, prepend them in reverse order.\nsample.MonsterStartWeaponsVector(builder, 2)\nbuilder.PrependUOffsetT(axe)\nbuilder.PrependUOffsetT(sword)\nweapons := builder.EndVector(2)\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in Java with FlatBuffers\nDESCRIPTION: Demonstrates creating two Weapon objects (sword and axe) using the createWeapon helper function in Java. It sets the name and damage for each weapon, illustrating FlatBuffers serialization in Java.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_27\n\nLANGUAGE: Java\nCODE:\n```\nshort weaponOneDamage = 3;\nshort weaponTwoDamage = 5;\n\n// Use the `createWeapon()` helper function to create the weapons, since we\n// set every field.\nint sword = Weapon.createWeapon(builder, weaponOneName, weaponOneDamage);\nint axe = Weapon.createWeapon(builder, weaponTwoName, weaponTwoDamage);\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in TypeScript with FlatBuffers\nDESCRIPTION: Creates two Weapon objects (sword and axe) using the startWeapon, addName, addDamage, and endWeapon functions in TypeScript. It sets the name and damage for each weapon, illustrating FlatBuffers serialization in TypeScript.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_36\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Create the first `Weapon` ('Sword').\nMyGame.Sample.Weapon.startWeapon(builder);\nMyGame.Sample.Weapon.addName(builder, weaponOne);\nMyGame.Sample.Weapon.addDamage(builder, 3);\nlet sword = MyGame.Sample.Weapon.endWeapon(builder);\n\n// Create the second `Weapon` ('Axe').\nMyGame.Sample.Weapon.startWeapon(builder);\nMyGame.Sample.Weapon.addName(builder, weaponTwo);\nMyGame.Sample.Weapon.addDamage(builder, 5);\nlet axe = MyGame.Sample.Weapon.endWeapon(builder);\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in JavaScript with FlatBuffers\nDESCRIPTION: Creates two Weapon objects (sword and axe) using the startWeapon, addName, addDamage, and endWeapon functions in JavaScript. It sets the name and damage for each weapon, demonstrating FlatBuffers serialization in JavaScript.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_28\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Create the first `Weapon` ('Sword').\nMyGame.Sample.Weapon.startWeapon(builder);\nMyGame.Sample.Weapon.addName(builder, weaponOne);\nMyGame.Sample.Weapon.addDamage(builder, 3);\nvar sword = MyGame.Sample.Weapon.endWeapon(builder);\n\n// Create the second `Weapon` ('Axe').\nMyGame.Sample.Weapon.startWeapon(builder);\nMyGame.Sample.Weapon.addName(builder, weaponTwo);\nMyGame.Sample.Weapon.addDamage(builder, 5);\nvar axe = MyGame.Sample.Weapon.endWeapon(builder);\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in C++ with FlatBuffers\nDESCRIPTION: Creates two Weapon objects (sword and axe) using the CreateWeapon helper function. It sets the name and damage for each weapon, demonstrating FlatBuffers serialization in C++.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nshort weapon_one_damage = 3;\nshort weapon_two_damage = 5;\n\n// Use the `CreateWeapon()` shortcut to create Weapons with all the fields\n// set.\nflatbuffers::Offset<Weapon> sword =\n    CreateWeapon(builder, weapon_one_name, weapon_one_damage);\nflatbuffers::Offset<Weapon> axe =\n    CreateWeapon(builder, weapon_two_name, weapon_two_damage);\n```\n\n----------------------------------------\n\nTITLE: Converting JSON to Binary FlatBuffer Format\nDESCRIPTION: Demonstrates how to serialize JSON data using a schema file to generate a binary FlatBuffer file. This example uses myschema.fbs as the schema and mydata.json as the input data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flatc.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nflatc --binary myschema.fbs mydata.json\n```\n\n----------------------------------------\n\nTITLE: Accessing Data from FlatBuffer Object in Java\nDESCRIPTION: This code snippet shows how to access data from a Monster object created from a FlatBuffer. It retrieves the 'hp' (hit points) as a short and the 'pos' (position) as a Vec3 object.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/java.md#2025-04-16_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nshort hp = monster.hp();\nVec3 pos = monster.pos();\n```\n\n----------------------------------------\n\nTITLE: Reading FlatBuffer Binary File in Java\nDESCRIPTION: This snippet demonstrates how to read a FlatBuffer binary file in Java. It imports necessary libraries, reads the file into a byte array, wraps it in a ByteBuffer, and uses it to create a Monster object.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/java.md#2025-04-16_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nimport MyGame.Example.*;\nimport com.google.flatbuffers.FlatBufferBuilder;\n\n// This snippet ignores exceptions for brevity.\nFile file = new File(\"monsterdata_test.mon\");\nRandomAccessFile f = new RandomAccessFile(file, \"r\");\nbyte[] data = new byte[(int)f.length()];\nf.readFully(data);\nf.close();\n\nByteBuffer bb = ByteBuffer.wrap(data);\nMonster monster = Monster.getRootAsMonster(bb);\n```\n\n----------------------------------------\n\nTITLE: Using Mini Reflection to Convert FlatBuffer to String in C++\nDESCRIPTION: Example demonstrating how to use the mini reflection feature to convert a FlatBuffer to a text representation. This lightweight reflection capability requires including the minireflect.h header and using the generated type table.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nauto s = flatbuffers::FlatBufferToString(flatbuf, MonsterTypeTable());\n```\n\n----------------------------------------\n\nTITLE: Defining FlatBuffer Schema in C\nDESCRIPTION: Example of a simple FlatBuffer schema definition for a Monster table with name and health fields.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/quick_start.md#2025-04-16_snippet_1\n\nLANGUAGE: c\nCODE:\n```\ntable Monster {\n  name:string;\n  health:int;\n}\n\nroot_type Monster;\n```\n\n----------------------------------------\n\nTITLE: Declaring RPC Service Interface in FlatBuffers\nDESCRIPTION: Example of RPC service declaration in FlatBuffers schema defining methods that take and return FlatBuffer table types. Shows a MonsterStorage service with Store and Retrieve methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_9\n\nLANGUAGE: txt\nCODE:\n```\nrpc_service MonsterStorage {\n    Store(Monster):StoreResponse;\n    Retrieve(MonsterId):Monster;\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Scalars and Structs in C++\nDESCRIPTION: Demonstrates serializing a vector of scalar values (inventory) and a vector of structs (path) using CreateVector and CreateVectorOfStructs methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_52\n\nLANGUAGE: cpp\nCODE:\n```\n// Create a `vector` representing the inventory of the Orc. Each number\n// could correspond to an item that can be claimed after he is slain.\nunsigned char treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nflatbuffers::Offset<flatbuffers::Vector<unsigned char>> inventory =\n    builder.CreateVector(treasure, 10);\n\n// Construct an array of two `Vec3` structs.\nVec3 points[] = { Vec3(1.0f, 2.0f, 3.0f), Vec3(4.0f, 5.0f, 6.0f) };\n\n// Serialize it as a vector of structs.\nflatbuffers::Offset<flatbuffers::Vector<Vec3>> path =\n    builder.CreateVectorOfStructs(points, 2);\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (C#)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in C#. The ByteBuffer class is used to wrap the byte array before passing to the generated accessor method.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_102\n\nLANGUAGE: C#\nCODE:\n```\nbyte[] bytes = /* the data you just read */\n\n// Get an view to the root object inside the buffer.\nMonster monster = Monster.GetRootAsMonster(new ByteBuffer(bytes));\n```\n\n----------------------------------------\n\nTITLE: Mutating FlatBuffer Values in Go\nDESCRIPTION: This snippet demonstrates how to modify values in an existing FlatBuffer in place. It shows mutation of both table and struct fields, and includes error handling for failed mutations.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/go.md#2025-04-16_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nmonster := example.GetRootAsMonster(buf, 0)\n\n// Set table field.\nif ok := monster.MutateHp(10); !ok {\n  panic(\"failed to mutate Hp\")\n}\n\n// Set struct field.\nmonster.Pos().MutateZ(4)\n\n// This mutation will fail because the mana field is not available in\n// the buffer. It should be set when creating the buffer.\nif ok := monster.MutateMana(20); !ok {\n  panic(\"failed to mutate Hp\")\n}\n```\n\n----------------------------------------\n\nTITLE: Reading FlatBuffer Data in Node.js\nDESCRIPTION: Example showing how to read a FlatBuffer file in Node.js using the FlatBuffers library. Demonstrates importing required modules, reading binary data, and accessing the root object of a Monster schema.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/javascript.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar fs = require('fs');\n\nvar flatbuffers = require('../flatbuffers').flatbuffers;\nvar MyGame = require('./monster_generated').MyGame;\n\nvar data = new Uint8Array(fs.readFileSync('monster.dat'));\nvar buf = new flatbuffers.ByteBuffer(data);\n\nvar monster = MyGame.Example.Monster.getRootAsMonster(buf);\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer Values in Dart\nDESCRIPTION: This snippet shows how to access values from a FlatBuffer Monster object after it has been constructed from binary data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/dart.md#2025-04-16_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nvar hp = monster.hp;\nvar pos = monster.pos;\n```\n\n----------------------------------------\n\nTITLE: Initializing FlatBuffers Parser in C++\nDESCRIPTION: Creates a FlatBuffers parser instance for parsing schema and JSON files into binary buffers.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nflatbuffers::Parser parser;\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with Python\nDESCRIPTION: Shows how to access a vector of Weapon tables from a Monster object using Python. The code gets the vector length and accesses the Name and Damage fields of the second weapon.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_171\n\nLANGUAGE: Python\nCODE:\n```\nweapons_length = monster.WeaponsLength()\nsecond_weapon_name = monster.Weapons(1).Name()\nsecond_weapon_damage = monster.Weapons(1).Damage()\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with JavaScript\nDESCRIPTION: Demonstrates how to access a vector of Weapon tables from a Monster object using JavaScript. The code gets the vector length and accesses the name and damage fields of the second weapon.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_166\n\nLANGUAGE: JavaScript\nCODE:\n```\nvar weaponsLength = monster.weaponsLength();\nvar secondWeaponName = monster.weapons(1).name();\nvar secondWeaponDamage = monster.weapons(1).damage();\n```\n\n----------------------------------------\n\nTITLE: Modular Object Creation in C using FlatBuffers\nDESCRIPTION: Demonstrates how to create modular FlatBuffer objects in C using flatcc_builder for reusable table creation functions. Shows buffer initialization, creation and cleanup.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/c.md#2025-04-16_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nns(Monster_ref_t) create_orc(flatcc_builder_t *B)\n{\n  // ... same as in the tutorial.\n  return s(Monster_create(B, ...));\n}\n\nvoid create_monster_buffer()\n{\n    uint8_t *buf;\n    size_t size;\n    flatcc_builder_t builder, *B;\n\n    // Initialize the builder object.\n    B = &builder;\n    flatcc_builder_init(B);\n    // Only use `buffer_create` without `create/start/end_as_root`.\n    flatcc_builder_buffer_create(create_orc(B));\n    // Allocate and copy buffer to user memory.\n    buf = flatcc_builder_finalize_buffer(B, &size);\n    // ... write the buffer to disk or network, or something.\n\n    free(buf);\n    flatcc_builder_clear(B);\n}\n```\n\n----------------------------------------\n\nTITLE: Reading a FlatBuffer in Rust\nDESCRIPTION: This snippet demonstrates how to read a FlatBuffer binary file in Rust. It includes importing the necessary modules, reading the file into a byte vector, and accessing the root object.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/rust.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nextern crate flatbuffers;\n\n#[allow(dead_code, unused_imports)]\n#[path = \"../../monster_test_generated.rs\"]\nmod monster_test_generated;\npub use monster_test_generated::my_game;\n\nuse std::io::Read;\n\nfn main() {\n    let mut f = std::fs::File::open(\"../monsterdata_test.mon\").unwrap();\n    let mut buf = Vec::new();\n    f.read_to_end(&mut buf).expect(\"file reading failed\");\n\n    let monster = my_game::example::root_as_monster(&buf[..]);\n```\n\n----------------------------------------\n\nTITLE: Loading FlatBuffers in Lua and Reading Binary Data\nDESCRIPTION: This code demonstrates how to require the FlatBuffers library and generated code, then read a FlatBuffer binary file into a string and parse it to access the root monster object.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/lua.md#2025-04-16_snippet_0\n\nLANGUAGE: lua\nCODE:\n```\n-- require the library\nlocal flatbuffers = require(\"flatbuffers\")\n\n-- require the generated code\nlocal monster = require(\"MyGame.Sample.Monster\")\n\n-- read the flatbuffer from a file into a string\nlocal f = io.open('monster.dat', 'rb')\nlocal buf = f:read('*a')\nf:close()\n\n-- parse the flatbuffer to get an instance to the root monster\nlocal monster1 = monster.GetRootAsMonster(buf, 0)\n```\n\n----------------------------------------\n\nTITLE: Reading FlatBuffer Binary File in Kotlin\nDESCRIPTION: Example showing how to read a FlatBuffer binary file into a ByteArray and create a Monster object. Demonstrates importing required libraries and basic file handling.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/kotlin.md#2025-04-16_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport MyGame.Example.*\nimport com.google.flatbuffers.FlatBufferBuilder\n\n// This snippet ignores exceptions for brevity.\nval data = RandomAccessFile(File(\"monsterdata_test.mon\"), \"r\").use {\n    val temp = ByteArray(it.length().toInt())\n    it.readFully(temp)\n    temp\n}\n\nval bb = ByteBuffer.wrap(data)\nval monster = Monster.getRootAsMonster(bb)\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with C++\nDESCRIPTION: Demonstrates how to access a vector of Weapon tables from a Monster object using C++. The code gets the vector length and accesses the name and damage fields of the second weapon.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_160\n\nLANGUAGE: C++\nCODE:\n```\nflatbuffers::Vector<Weapon> weapons = monster->weapons();\nauto weapon_len = weapons->size();\nauto second_weapon_name = weapons->Get(1)->name()->str();\nauto second_weapon_damage = weapons->Get(1)->damage()\n```\n\n----------------------------------------\n\nTITLE: Importing FlatBuffers in C++\nDESCRIPTION: Example of importing FlatBuffers generated code and runtime library in C++, including namespace setup.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\n#include \"monster_generated.h\" // This was generated by `flatc`\n#include \"flatbuffers.h\" // The runtime library for C++\n\n// Simplifies naming in the following examples.\nusing namespace MyGame::Sample; // Specified in the schema.\n```\n\n----------------------------------------\n\nTITLE: Converting Binary FlatBuffer to JSON Format\nDESCRIPTION: Shows how to convert a serialized binary FlatBuffer file back to JSON format using the schema file. This example uses myschema.fbs as the schema and mydata.bin as the input binary data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flatc.md#2025-04-16_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nflatc --json myschema.fbs mydata.bin\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with Dart\nDESCRIPTION: Demonstrates how to access elements of an inventory vector in a Monster object using Dart. The code gets the vector length and accesses the third element using array syntax.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_148\n\nLANGUAGE: Dart\nCODE:\n```\nint invLength = monster.inventory.length;\nvar thirdItem = monster.inventory[2];\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with Lobster\nDESCRIPTION: Demonstrates how to access a vector of Weapon tables from a Monster object using Lobster. The code gets the vector length and accesses the name and damage fields of the second weapon.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_168\n\nLANGUAGE: Lobster\nCODE:\n```\nlet weapons_length = monster.weapons_length\nlet second_weapon_name = monster.weapons(1).name\nlet second_weapon_damage = monster.weapons(1).damage\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with Swift\nDESCRIPTION: Demonstrates how to access elements of an inventory vector in a Monster object using Swift. The code shows multiple ways to access vector elements: by count, by index, or by retrieving the entire array.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_158\n\nLANGUAGE: Swift\nCODE:\n```\n// Get a the count of objects in the vector\nlet count = monster.inventoryCount\n\n// get item at index 4\nlet object = monster.inventory(at: 4)\n\n// or you can fetch the entire array\nlet inv = monster.inventory\n// inv[4] should equal object\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with C++\nDESCRIPTION: Shows how to access elements of an inventory vector in a Monster object using C++. The code retrieves the vector, gets its size, and accesses the third element.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_145\n\nLANGUAGE: C++\nCODE:\n```\nflatbuffers::Vector<unsigned char> inv = monster->inventory();\nauto inv_len = inv->size();\nauto third_item = inv->Get(2);\n```\n\n----------------------------------------\n\nTITLE: Basic FlatBuffers Compiler Command-Line Syntax\nDESCRIPTION: Shows the basic command-line syntax for using the flatc compiler, including options for specifying generators, output paths, include paths, and input files.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flatc.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nflatc [ GENERATOR_OPTIONS ] [ -o PATH ] [- I PATH ] \n  FILES... \n  [ -- BINARY_FILES... ]\n```\n\n----------------------------------------\n\nTITLE: Reading a FlatBuffer File in Dart\nDESCRIPTION: This snippet demonstrates how to import the FlatBuffers library and generated code, then read a FlatBuffer binary file into a List<int> which is passed to the Monster constructor.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/dart.md#2025-04-16_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'dart:io' as io;\n\nimport 'package:flat_buffers/flat_buffers.dart' as fb;\nimport './monster_my_game.sample_generated.dart' as myGame;\n\nList<int> data = await new io.File('monster.dat').readAsBytes();\nvar monster = new myGame.Monster(data);\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (Java)\nDESCRIPTION: Code to access specific fields from a Monster table in Java. Uses accessor methods that return appropriate Java types for each field.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_120\n\nLANGUAGE: Java\nCODE:\n```\nshort hp = monster.hp();\nshort mana = monster.mana();\nString name = monster.name();\n```\n\n----------------------------------------\n\nTITLE: Reading FlatBuffer Data in Browser\nDESCRIPTION: Example demonstrating how to read a FlatBuffer file in a web browser environment using FileReader API. Shows HTML setup and JavaScript code for loading and parsing FlatBuffer data from a file input.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/javascript.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n<script src=\"../js/flatbuffers.js\"></script>\n<script src=\"monster_generated.js\"></script>\n<script>\n  function readFile() {\n    var reader = new FileReader();\n    var file = document.getElementById('file_input').files[0];\n\n    reader.onload = function() {\n      var data = new Uint8Array(reader.result);\n      var buf = new flatbuffers.ByteBuffer(data);\n      var monster = MyGame.Example.Monster.getRootAsMonster(buf);\n    }\n\n    reader.readAsArrayBuffer(file);\n  }\n</script>\n\n<input type=\"file\" id=\"file_input\" onchange=\"readFile();\">\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with PHP\nDESCRIPTION: Demonstrates how to access a vector of Weapon tables from a Monster object using PHP. The code gets the vector length and accesses the name and damage fields of the second weapon using getter methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_170\n\nLANGUAGE: PHP\nCODE:\n```\n$weapons_len = $monster->getWeaponsLength();\n$second_weapon_name = $monster->getWeapons(1)->getName();\n$second_weapon_damage = $monster->getWeapons(1)->getDamage();\n```\n\n----------------------------------------\n\nTITLE: Creating a Complex FlexBuffer Map with Nested Elements in C++\nDESCRIPTION: Demonstrates how to create a more complex FlexBuffer structure with a map containing a vector and a scalar value. This represents a JSON-like structure with nested elements.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flexbuffers.md#2025-04-16_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nfbb.Map([&]() {\n  fbb.Vector(\"vec\", [&]() {\n    fbb.Int(-100);\n    fbb.String(\"Fred\");\n    fbb.IndirectFloat(4.0f);\n  });\n  fbb.UInt(\"foo\", 100);\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing FlexBuffer Data in Java\nDESCRIPTION: Java example of reading a complex FlexBuffer structure. The code demonstrates how to navigate through maps and vectors, access different data types, and handle type conversions.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flexbuffers.md#2025-04-16_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nFlexBuffers.Map map = FlexBuffers.getRoot(bb).asMap();\nmap.size();  // 2\nFlexBuffers.Vector vec = map.get(\"vec\").asVector();\nvec.size();  // 3\nvec.get(0).asLong();  // -100;\nvec.get(1).asString();  // \"Fred\";\nvec.get(1).asLong();  // 0 (Number parsing failed).\nvec.get(2).asFloat();  // 4.0\nvec.get(2).asString().isEmpty();  // true (Wrong Type).\nvec.get(2).asString();  // \"\" (This still works though).\nvec.get(2).toString();  // \"4.0\" (Or have it converted).\nmap.get(\"foo\").asUInt();  // 100\nmap.get(\"unknown\").isNull();  // true\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Scalars and Structs in Lobster\nDESCRIPTION: Demonstrates serializing a vector of scalar values (inventory) and a vector of structs (path) using MyGame_Sample_MonsterCreateInventoryVector and MyGame_Sample_CreateVec3 methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_60\n\nLANGUAGE: lobster\nCODE:\n```\n// Inventory.\nlet inv = builder.MyGame_Sample_MonsterCreateInventoryVector(map(10): _)\n\nbuilder.MyGame_Sample_MonsterStartPathVector(2)\nbuilder.MyGame_Sample_CreateVec3(1.0, 2.0, 3.0)\nbuilder.MyGame_Sample_CreateVec3(4.0, 5.0, 6.0)\nlet path = builder.EndVector(2)\n```\n\n----------------------------------------\n\nTITLE: Creating Vectors in Rust using FlatBuffers\nDESCRIPTION: Demonstrates vector creation in Rust FlatBuffers by creating an inventory vector of unsigned 8-bit integers and a path vector containing Vec3 objects.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_65\n\nLANGUAGE: rust\nCODE:\n```\nlet inventory = builder.create_vector(&[0u8, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\nlet x = Vec3::new(1.0, 2.0, 3.0);\nlet y = Vec3::new(4.0, 5.0, 6.0);\nlet path = builder.create_vector(&[x, y]);\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with Lua\nDESCRIPTION: This Lua code demonstrates creating a Monster with a union field in FlatBuffers. It uses Start/End functions and shows how to properly set both the union type field and union value.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_77\n\nLANGUAGE: Lua\nCODE:\n```\n-- Serialize a name for our monster, called 'orc'\nlocal name = builder:CreateString(\"Orc\")\n\n-- Create our monster by using Start() andEnd()\nmonster.Start(builder)\nmonster.AddPos(builder, vec3.CreateVec3(builder, 1.0, 2.0, 3.0))\nmonster.AddHp(builder, 300)\nmonster.AddName(builder, name)\nmonster.AddInventory(builder, inv)\nmonster.AddColor(builder, color.Red)\nmonster.AddWeapons(builder, weapons)\nmonster.AddEquippedType(builder, equipment.Weapon)\nmonster.AddEquipped(builder, axe)\nmonster.AddPath(builder, path)\nlocal orc = monster.End(builder)\n```\n\n----------------------------------------\n\nTITLE: Language-Specific Schema Compilation Commands\nDESCRIPTION: Collection of flatc compiler commands for generating code in different programming languages from the monster schema.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nflatc --cpp monster.fbs\ncd flatcc\nmkdir -p build/tmp/samples/monster\nbin/flatcc -a -o build/tmp/samples/monster samples/monster/monster.fbs\nflatc --csharp monster.fbs\nflatc --dart monster.fbs\nflatc --go monster.fbs\nflatc --java monster.fbs\nflatc --js monster.fbs\nflatc --kotlin monster.fbs\nflatc --lobster monster.fbs\nflatc --lua monster.fbs\nflatc --php monster.fbs\nflatc --python monster.fbs\nflatc --rust monster.fbs\nflatc --swift monster.fbs\nflatc --ts monster.fbs\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (Go)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's CreateString method. Returns offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_11\n\nLANGUAGE: Go\nCODE:\n```\nweaponOne := builder.CreateString(\"Sword\")\nweaponTwo := builder.CreateString(\"Axe\")\n```\n\n----------------------------------------\n\nTITLE: Accessing Union Fields in C++\nDESCRIPTION: Shows how to check union type and access union data using static_cast in C++. Demonstrates accessing weapon name and damage from an equipped union field.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_175\n\nLANGUAGE: C++\nCODE:\n```\nauto union_type = monster.equipped_type();\n\nif (union_type == Equipment_Weapon) {\n     // Requires `static_cast` to type `const Weapon*`.\n    auto weapon = static_cast<const Weapon*>(monster->equipped());\n\n    auto weapon_name = weapon->name()->str(); // \"Axe\"\n    auto weapon_damage = weapon->damage();    // 5\n}\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (C++)\nDESCRIPTION: Creates string references in FlatBuffers using the Builder's CreateString method. Returns typed offset objects that act as handles to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nflatbuffers::Offset<String> weapon_one_name = builder.CreateString(\"Sword\");\nflatbuffers::Offset<String> weapon_two_name = builder.CreateString(\"Axe\");\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with C++\nDESCRIPTION: Demonstrates how to access a nested Vec3 struct from a Monster object in C++. The code retrieves the pos field and accesses its x, y, and z components.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_130\n\nLANGUAGE: C++\nCODE:\n```\nauto pos = monster->pos();\nauto x = pos->x();\nauto y = pos->y();\nauto z = pos->z();\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (C++)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in C++. This is the entry point to access any data in the buffer. The root object pointer provides the view into the buffer data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_100\n\nLANGUAGE: C++\nCODE:\n```\nuint8_t *buffer_pointer = /* the data you just read */;\n\n// Get an view to the root object inside the buffer.\nMonster monster = GetMonster(buffer_pointer);\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (Swift)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's create(string:) method. Returns offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_20\n\nLANGUAGE: Swift\nCODE:\n```\nlet weapon1Name = builder.create(string: \"Sword\")\nlet weapon2Name = builder.create(string: \"Axe\")\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (Rust)\nDESCRIPTION: Code to access specific fields from a Monster table in Rust. Uses snake_case method names for field accessors.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_127\n\nLANGUAGE: Rust\nCODE:\n```\n// Get and test some scalar types from the FlatBuffer.\nlet hp = monster.hp();\nlet mana = monster.mana();\nlet name = monster.name();\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (C#)\nDESCRIPTION: Code to access specific fields from a Monster table in C#. Unlike most other languages, C# provides properties instead of accessor methods for most values.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_117\n\nLANGUAGE: C#\nCODE:\n```\n// For C#, unlike most other languages support by FlatBuffers, most values\n// (except for vectors and unions) are available as properties instead of\n// accessor methods.\nvar hp = monster.Hp;\nvar mana = monster.Mana;\nvar name = monster.Name;\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (PHP)\nDESCRIPTION: Code to access specific fields from a Monster table in PHP. Uses getter methods with camelCase naming convention.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_125\n\nLANGUAGE: PHP\nCODE:\n```\n$hp = $monster->getHp();\n$mana = $monster->getMana();\n$name = monster->getName();\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (Python)\nDESCRIPTION: Code to access specific fields from a Monster table in Python. Uses CamelCase method names for field accessors.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_126\n\nLANGUAGE: Python\nCODE:\n```\nhp = monster.Hp()\nmana = monster.Mana()\nname = monster.Name()\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (TypeScript)\nDESCRIPTION: Code to access specific fields from a Monster table in TypeScript. Uses accessor methods similar to JavaScript.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_129\n\nLANGUAGE: TypeScript\nCODE:\n```\nlet hp = monster.hp();\nlet mana = monster.mana();\nlet name = monster.name();\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (Swift)\nDESCRIPTION: Code to access specific fields from a Monster table in Swift. Swift provides properties for accessing the fields, with string fields returning optional types.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_128\n\nLANGUAGE: Swift\nCODE:\n```\nlet hp = monster.hp\nlet mana = monster.mana\nlet name = monster.name // returns an optional string\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (C++)\nDESCRIPTION: Code to access specific fields from a Monster table in C++. Demonstrates accessing scalar values like hp and mana, and a string field name.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_115\n\nLANGUAGE: C++\nCODE:\n```\nauto hp = monster->hp();\nauto mana = monster->mana();\nauto name = monster->name()->c_str();\n```\n\n----------------------------------------\n\nTITLE: Creating a Complex FlexBuffer in Java\nDESCRIPTION: Java example of creating a FlexBuffer with a map containing a vector and a scalar value. The code shows how to start and end complex structures and add various data types.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flexbuffers.md#2025-04-16_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nFlexBuffersBuilder builder = new FlexBuffersBuilder(ByteBuffer.allocate(512),\n\t\t                                                FlexBuffersBuilder.BUILDER_FLAG_SHARE_KEYS_AND_STRINGS);\nint smap = builder.startMap();\nint svec = builder.startVector();\nbuilder.putInt(-100);\nbuilder.putString(\"Fred\");\nbuilder.putFloat(4.0);\nbuilder.endVector(\"vec\", svec, false, false);\nbuilder.putInt(\"foo\", 100);\nbuilder.endMap(null, smap);\nByteBuffer bb = builder.finish();\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic FlexBuffer in C++\nDESCRIPTION: Simple example of creating a FlexBuffer containing a single integer value. The code demonstrates how to initialize a builder, add an integer value, and finalize the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flexbuffers.md#2025-04-16_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nflexbuffers::Builder fbb;\nfbb.Int(13);\nfbb.Finish();\n```\n\n----------------------------------------\n\nTITLE: Integrating FlatBuffers in CMake Projects\nDESCRIPTION: CMake configuration for including FlatBuffers as a subdirectory in existing CMake projects, with proper target linking.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/building.md#2025-04-16_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(${FLATBUFFERS_SRC_DIR}\n                 ${CMAKE_CURRENT_BINARY_DIR}/flatbuffers-build\n                 EXCLUDE_FROM_ALL)\n\ntarget_link_libraries(own_project_target PRIVATE flatbuffers)\n```\n\n----------------------------------------\n\nTITLE: Top-Down Monster Creation with FlatBuffers in C\nDESCRIPTION: Shows how to create a Monster object using a top-down approach with nested object creation, including weapons, inventory, and other attributes.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/c.md#2025-04-16_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nuint8_t treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nsize_t treasure_count = c_vec_len(treasure);\nns(Weapon_ref_t) axe;\n\n// NOTE: if we use end_as_root, we MUST also start as root.\nns(Monster_start_as_root(B));\nns(Monster_pos_create(B, 1.0f, 2.0f, 3.0f));\nns(Monster_hp_add(B, 300));\nns(Monster_mana_add(B, 150));\nns(Monster_name_create_str(B, \"Orc\"));\nns(Monster_inventory_create(B, treasure, treasure_count));\nns(Monster_color_add(B, ns(Color_Red)));\nif (1) {\n    ns(Monster_weapons_start(B));\n    ns(Monster_weapons_push_create(B, flatbuffers_string_create_str(B, \"Sword\"), 3));\n    axe = *ns(Monster_weapons_push_create(B, flatbuffers_string_create_str(B, \"Axe\"), 5));\n    ns(Monster_weapons_end(B));\n} else {\n    ns(Monster_weapons_start(B));\n    ns(Monster_weapons_push_start(B));\n    ns(Weapon_name_create_str(B, \"Sword\"));\n    ns(Weapon_damage_add(B, 3));\n    ns(Monster_weapons_push_end(B));\n    ns(Monster_weapons_push_start(B));\n    ns(Monster_weapons_push_start(B));\n    ns(Weapon_name_create_str(B, \"Axe\"));\n    ns(Weapon_damage_add(B, 5));\n    axe = *ns(Monster_weapons_push_end(B));\n    ns(Monster_weapons_end(B));\n}\nns(Monster_equipped_Weapon_add(B, axe));\n\nns(Monster_end_as_root(B));\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with C\nDESCRIPTION: Shows how to access a nested Vec3 struct from a Monster object in C. The code uses namespace prefixed functions to retrieve the pos field and access its x, y, and z components.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_131\n\nLANGUAGE: C\nCODE:\n```\nns(Vec3_struct_t) pos = ns(Monster_pos(monster));\nfloat x = ns(Vec3_x(pos));\nfloat y = ns(Vec3_y(pos));\nfloat z = ns(Vec3_z(pos));\n```\n\n----------------------------------------\n\nTITLE: Reading FlatBuffer Binary File in TypeScript\nDESCRIPTION: Demonstrates how to read a FlatBuffer binary file by importing the library and generated code, reading file data into Uint8Array, and creating a ByteBuffer to access the root monster object.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/typescript.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n  import * as flatbuffers from 'flatbuffers';\n\n  import { MyGame } from './monster_generated';\n\n  let data = new Uint8Array(fs.readFileSync('monster.dat'));\n  let buf = new flatbuffers.ByteBuffer(data);\n\n  let monster = MyGame.Example.Monster.getRootAsMonster(buf);\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in C++\nDESCRIPTION: Retrieves the pointer to the serialized buffer and its size in C++.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_85\n\nLANGUAGE: c++\nCODE:\n```\nuint8_t *buf = builder.GetBufferPointer();\n\nint size = builder.GetSize();\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with Python\nDESCRIPTION: Shows how to access a nested Vec3 struct from a Monster object in Python. The code retrieves the pos field and accesses its X, Y, and Z components.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_141\n\nLANGUAGE: Python\nCODE:\n```\npos = monster.Pos()\nx = pos.X()\ny = pos.Y()\nz = pos.Z()\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with PHP\nDESCRIPTION: Demonstrates how to access a nested Vec3 struct from a Monster object in PHP. The code retrieves the pos field and accesses its x, y, and z components using getter methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_140\n\nLANGUAGE: PHP\nCODE:\n```\n$pos = $monster->getPos();\n$x = $pos->getX();\n$y = $pos->getY();\n$z = $pos->getZ();\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with Rust\nDESCRIPTION: Demonstrates how to access a nested Vec3 struct from a Monster object in Rust. The code uses unwrap() to handle the Option type when retrieving the pos field.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_142\n\nLANGUAGE: Rust\nCODE:\n```\nlet pos = monster.pos().unwrap();\nlet x = pos.x();\nlet y = pos.y();\nlet z = pos.z();\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with Lua\nDESCRIPTION: Shows how to access a nested Vec3 struct from a Monster object in Lua. The code retrieves the pos field and accesses its X, Y, and Z components using method calls.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_139\n\nLANGUAGE: Lua\nCODE:\n```\nlocal pos = mon:Pos()\nlocal x = pos:X()\nlocal y = pos:Y()\nlocal z = pos:Z()\n```\n\n----------------------------------------\n\nTITLE: Accessing Complex FlexBuffer Data in C++\nDESCRIPTION: Shows how to access a complex map structure from a FlexBuffer. The example demonstrates navigating through maps and vectors, type checking, and value conversion.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flexbuffers.md#2025-04-16_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nauto map = flexbuffers::GetRoot(my_buffer).AsMap();\nmap.size();  // 2\nauto vec = map[\"vec\"].AsVector();\nvec.size();  // 3\nvec[0].AsInt64();  // -100;\nvec[1].AsString().c_str();  // \"Fred\";\nvec[1].AsInt64();  // 0 (Number parsing failed).\nvec[2].AsDouble();  // 4.0\nvec[2].AsString().IsTheEmptyString();  // true (Wrong Type).\nvec[2].AsString().c_str();  // \"\" (This still works though).\nvec[2].ToString().c_str();  // \"4\" (Or have it converted).\nmap[\"foo\"].AsUInt8();  // 100\nmap[\"unknown\"].IsNull();  // true\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (Dart)\nDESCRIPTION: Code to access specific fields from a Monster table in Dart. Like C#, Dart provides properties instead of accessor methods for most values.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_118\n\nLANGUAGE: Dart\nCODE:\n```\n// For Dart, unlike other languages support by FlatBuffers, most values\n// are available as properties instead of accessor methods.\nvar hp = monster.hp;\nvar mana = monster.mana;\nvar name = monster.name;\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in C# with FlatBuffers\nDESCRIPTION: Creates two Weapon objects (sword and axe) using the CreateWeapon helper function in C#. It sets the name and damage for each weapon, illustrating FlatBuffers serialization in C#.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nshort weaponOneDamage = 3;\nshort weaponTwoDamage = 5;\n\n// Use the `CreateWeapon()` helper function to create the weapons, since we \n// set every field.\nOffset<Weapon> sword =\n    Weapon.CreateWeapon(builder, weaponOneName, weaponOneDamage);\nOffset<Weapon> axe =\n    Weapon.CreateWeapon(builder, weaponTwoName, weaponTwoDamage);\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in JavaScript\nDESCRIPTION: Creates an array of Weapon offsets and uses the createWeaponsVector method to serialize it into a FlatBuffer vector.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_43\n\nLANGUAGE: javascript\nCODE:\n```\n// Create an array from the two `Weapon`s and pass it to the\n// `createWeaponsVector()` method to create a FlatBuffer vector.\nvar weaps = [sword, axe];\nvar weapons = MyGame.Sample.Monster.createWeaponsVector(builder, weaps);\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (Go)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in Go. Uses an offset parameter (typically 0) when reading from a standard buffer. For builder.Bytes, use builder.Head() as the offset.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_104\n\nLANGUAGE: Go\nCODE:\n```\nvar buf []byte = /* the data you just read */\n\n// Get an accessor to the root object inside the buffer.\nmonster := sample.GetRootAsMonster(buf, 0)\n\n// Note: We use `0` for the offset here, which is typical for most buffers\n// you would read. If you wanted to read from `builder.Bytes` directly, you\n// would need to pass in the offset of `builder.Head()`, as the builder\n// constructs the buffer backwards, so may not start at offset 0.\n```\n\n----------------------------------------\n\nTITLE: Mutating values in an existing FlatBuffer in Swift\nDESCRIPTION: This example demonstrates how to modify values in an existing FlatBuffer without creating a copy. It shows how to mutate scalar fields and struct fields while explaining the difference between Swift's copy-on-write behavior and direct mutation.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/swift.md#2025-04-16_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nvar byteBuffer = ByteBuffer(bytes: data)\n// Get an accessor to the root object inside the buffer.\nlet monster: Monster = try! getCheckedRoot(byteBuffer: &byteBuffer)\n// let monster: Monster = getRoot(byteBuffer: &byteBuffer)\n\nif !monster.mutate(hp: 10) {\n  fatalError(\"couldn't mutate\")\n}\n// mutate a struct field using flatbuffers struct\n// DONT use monster.pos to mutate since swift copy on write \n// will not mutate the value in the buffer\nlet vec = monster.mutablePos.mutate(z: 4)\n\n// This mutation will fail because the mana field is not available in\n// the buffer. It should be set when creating the buffer.\nif !monster.mutate(mana: 20) {\n  fatalError(\"couldn't mutate\")\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in Lobster with FlatBuffers\nDESCRIPTION: Demonstrates creating two Weapon objects (sword and axe) using the MyGame_Sample_WeaponBuilder in Lobster. It sets the name and damage for each weapon, showcasing FlatBuffers serialization in Lobster.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_30\n\nLANGUAGE: Lobster\nCODE:\n```\nlet sword = MyGame_Sample_WeaponBuilder { b }\n      .start()\n      .add_name(weapon_one)\n      .add_damage(3)\n      .end()\n\nlet axe = MyGame_Sample_WeaponBuilder { b }\n      .start()\n      .add_name(weapon_two)\n      .add_damage(5)\n      .end()\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (Swift)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in Swift. Uses either getCheckedRoot for safer access with error checking or getRoot for unchecked access.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_113\n\nLANGUAGE: Swift\nCODE:\n```\n// create a ByteBuffer(:) from an [UInt8] or Data()\nvar buf = // Get your data\n// Get an accessor to the root object inside the buffer.\nlet monster: Monster = try! getCheckedRoot(byteBuffer: &byteBuffer)\n// let monster: Monster = getRoot(byteBuffer: &byteBuffer)\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (Dart)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in Dart. Dart uses a generated factory constructor to read the data directly from a List<int>.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_103\n\nLANGUAGE: Dart\nCODE:\n```\nList<int> data = ... // the data, e.g. from file or network\n// A generated factory constructor that will read the data.\nmyGame.Monster monster = new myGame.Monster(data);\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (Lobster)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's CreateString method. Returns offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_15\n\nLANGUAGE: Lobster\nCODE:\n```\nlet weapon_one = builder.CreateString(\"Sword\")\nlet weapon_two = builder.CreateString(\"Axe\")\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with Lobster\nDESCRIPTION: This Lobster code demonstrates using the MonsterBuilder API to create a Monster with a union field in FlatBuffers. It shows setting all fields including the union type and value.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_76\n\nLANGUAGE: Lobster\nCODE:\n```\n// Name of the monster.\nlet name = builder.CreateString(\"Orc\")\n\nlet orc = MyGame_Sample_MonsterBuilder { b }\n    .start()\n    .add_pos(b.MyGame_Sample_CreateVec3(1.0, 2.0, 3.0))\n    .add_hp(300)\n    .add_name(name)\n    .add_inventory(inv)\n    .add_color(MyGame_Sample_Color_Red)\n    .add_weapons(weapons)\n    .add_equipped_type(MyGame_Sample_Equipment_Weapon)\n    .add_equipped(weapon_offsets[1])\n    .add_path(path)\n    .end()\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in Go with FlatBuffers\nDESCRIPTION: Creates two Weapon objects (sword and axe) using the WeaponStart, WeaponAddName, WeaponAddDamage, and WeaponEnd functions in Go. It sets the name and damage for each weapon, showcasing FlatBuffers serialization in Go.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_26\n\nLANGUAGE: Go\nCODE:\n```\n// Create the first `Weapon` (\"Sword\").\nsample.WeaponStart(builder)\nsample.WeaponAddName(builder, weaponOne)\nsample.WeaponAddDamage(builder, 3)\nsword := sample.WeaponEnd(builder)\n\n// Create the second `Weapon` (\"Axe\").\nsample.WeaponStart(builder)\nsample.WeaponAddName(builder, weaponTwo)\nsample.WeaponAddDamage(builder, 5)\naxe := sample.WeaponEnd(builder)\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with C\nDESCRIPTION: This C code demonstrates how to create a Monster object with an 'equipped' union field in FlatBuffers. It shows setting scalar fields and handling the union field using the Equipment_as_Weapon helper function.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_69\n\nLANGUAGE: C\nCODE:\n```\n// Serialize a name for our monster, called \"Orc\".\n// The _str suffix indicates the source is an ascii-z string.\nflatbuffers_string_ref_t name = flatbuffers_string_create_str(B, \"Orc\");\n\n// Set his hit points to 300 and his mana to 150.\nuint16_t hp = 300;\nuint16_t mana = 150;\n\n// Define an equipment union. `create` calls in C has a single\n// argument for unions where C++ has both a type and a data argument.\nns(Equipment_union_ref_t) equipped = ns(Equipment_as_Weapon(axe));\nns(Vec3_t) pos = { 1.0f, 2.0f, 3.0f };\nns(Monster_create_as_root(B, &pos, mana, hp, name, inventory, ns(Color_Red),\n        weapons, equipped, path));\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (JavaScript)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in JavaScript. The Uint8Array is wrapped in a flatbuffers.ByteBuffer before passing to the generated accessor method.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_106\n\nLANGUAGE: JavaScript\nCODE:\n```\n// the data you just read, as a `Uint8Array`\n// Note that the example here uses `readFileSync` from the built-in `fs`\n// module, but other methods for accessing the file contents will also work.\nvar bytes = new Uint8Array(readFileSync('./monsterdata.bin'));\n\nvar buf = new flatbuffers.ByteBuffer(bytes);\n\n// Get an accessor to the root object inside the buffer.\nvar monster = MyGame.Sample.Monster.getRootAsMonster(buf);\n```\n\n----------------------------------------\n\nTITLE: Handling Data Types in Python FlatBuffers GRPC Server\nDESCRIPTION: This snippet demonstrates how to handle potential type issues in a Python GRPC server using FlatBuffers. It shows the need for type checking and UTF-8 decoding when processing requests that could be either byte arrays or UTF-8 strings.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/README.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef SayHello(self, request, context):\n    # request might be a byte array or a utf8 string\n\n    r = HelloRequest.HelloRequest().GetRootAs(request, 0)\n    reply = \"Unknown\"\n    if r.Name():\n        reply = r.Name()\n    # Issues might happen if type checking isnt present.\n    # thus encoding it as a `reply.decode('UTF-8')`\n    return build_reply(\"welcome \" + reply.decode('UTF-8'))\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with Dart\nDESCRIPTION: Shows how to access a vector of Weapon tables from a Monster object using Dart. The code gets the vector length and accesses the name and damage fields of the second weapon using array syntax.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_163\n\nLANGUAGE: Dart\nCODE:\n```\nint weaponsLength = monster.weapons.length;\nvar secondWeaponName = monster.weapons[1].name;\nvar secondWeaponDamage = monster.Weapons[1].damage;\n```\n\n----------------------------------------\n\nTITLE: Reading a FlexBuffer Value in C++\nDESCRIPTION: Example of how to access a value from a FlexBuffer. The code shows how to get the root element from a buffer and read it as a 64-bit integer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flexbuffers.md#2025-04-16_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nauto root = flexbuffers::GetRoot(my_buffer);\nint64_t i = root.AsInt64();\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in C#\nDESCRIPTION: Creates an array of Weapon offsets and uses the CreateWeaponsVector method to serialize it into a FlatBuffer vector.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_39\n\nLANGUAGE: csharp\nCODE:\n```\n// Create an array of the two weapon offsets.\nvar weaps = new Offset<Weapon>[2];\nweaps[0] = sword;\nweaps[1] = axe;\n\n// Pass the `weaps` array into the `CreateWeaponsVector()` method to create\n// a FlatBuffer vector.\nvar weapons = Monster.CreateWeaponsVector(builder, weaps);\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Table Schema in FlatBuffers\nDESCRIPTION: A simple FlatBuffers schema definition (version 1) with a table containing two integer fields. This serves as the base schema for the evolution examples.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\ntable T {\n  a:int;\n  b:int;\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with Kotlin\nDESCRIPTION: This Kotlin code demonstrates creating a Monster with a union field in FlatBuffers. It uses startMonster/endMonster pattern and properly sets both the union type field and union value.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_75\n\nLANGUAGE: Kotlin\nCODE:\n```\n// Serialize a name for our monster, called \"Orc\".\nval name = builder.createString(\"Orc\")\n\n// Create our monster using `startMonster()` and `endMonster()`.\nMonster.startMonster(builder)\nMonster.addPos(builder, Vec3.createVec3(builder, 1.0f, 2.0f, 3.0f))\nMonster.addName(builder, name)\nMonster.addColor(builder, Color.Red)\nMonster.addHp(builder, 300.toShort())\nMonster.addInventory(builder, inv)\nMonster.addWeapons(builder, weapons)\nMonster.addEquippedType(builder, Equipment.Weapon)\nMonster.addEquipped(builder, axe)\nMonster.addPath(builder, path)\nval orc = Monster.endMonster(builder)\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with Java\nDESCRIPTION: This Java example demonstrates building a Monster object with a union field in FlatBuffers. It uses startMonster/endMonster pattern and shows how to properly handle the union type and value.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_73\n\nLANGUAGE: Java\nCODE:\n```\n// Serialize a name for our monster, called \"Orc\".\nint name = builder.createString(\"Orc\");\n  \n// Create our monster using `startMonster()` and `endMonster()`.\nMonster.startMonster(builder);\nMonster.addPos(builder, Vec3.createVec3(builder, 1.0f, 2.0f, 3.0f));\nMonster.addName(builder, name);\nMonster.addColor(builder, Color.Red);\nMonster.addHp(builder, (short)300);\nMonster.addInventory(builder, inv);\nMonster.addWeapons(builder, weapons);\nMonster.addEquippedType(builder, Equipment.Weapon);\nMonster.addEquipped(builder, axe);\nMonster.addPath(builder, path);\nint orc = Monster.endMonster(builder);\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (Kotlin)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in Kotlin. Similar to Java, first wraps the byte array in a java.nio.ByteBuffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_107\n\nLANGUAGE: Kotlin\nCODE:\n```\nval bytes = /* the data you just read */\nval buf = java.nio.ByteBuffer.wrap(bytes)\n\n// Get an accessor to the root object inside the buffer.\nMonster monster = Monster.getRootAsMonster(buf)\n```\n\n----------------------------------------\n\nTITLE: Creating Monster Object in Swift\nDESCRIPTION: Creates a Monster object in Swift using the FlatBuffers builder. It sets properties like position, hp, name, inventory, color, weapons, and equipment.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_82\n\nLANGUAGE: swift\nCODE:\n```\nlet name = builder.create(string: \"Orc\")\n\nlet orc = Monster.createMonster(\n    &builder,\n    pos: MyGame_Sample_Vec3(x: 1, y: 2, z: 3),\n    hp: 300,\n    nameOffset: name,\n    inventoryVectorOffset: inventoryOffset,\n    color: .red,\n    weaponsVectorOffset: weaponsOffset,\n    equippedType: .weapon,\n    equippedOffset: axe)\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with C#\nDESCRIPTION: Demonstrates how to access a vector of Weapon tables from a Monster object using C#. The code gets the vector length and accesses the Name and Damage properties of the second weapon.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_162\n\nLANGUAGE: C#\nCODE:\n```\nint weaponsLength = monster.WeaponsLength;\nvar secondWeaponName = monster.Weapons(1).Name;\nvar secondWeaponDamage = monster.Weapons(1).Damage;\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (Rust)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's create_string method. Returns offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_19\n\nLANGUAGE: Rust\nCODE:\n```\nlet weapon_one_name = builder.create_string(\"Sword\");\nlet weapon_two_name = builder.create_string(\"Axe\");\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (JavaScript)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's createString method. Returns offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\nvar weaponOne = builder.createString('Sword');\nvar weaponTwo = builder.createString('Axe');\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (PHP)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's createString method. Returns offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_17\n\nLANGUAGE: PHP\nCODE:\n```\n$weapon_one_name = $builder->createString(\"Sword\")\n$weapon_two_name = $builder->createString(\"Axe\");\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer values in Swift\nDESCRIPTION: This code snippet shows how to access values from a FlatBuffer monster object in Swift. It demonstrates accessing a scalar field and a struct field using both native Swift structs and FlatBuffers structs.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/swift.md#2025-04-16_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nlet hp = monster.hp\nlet pos = monster.pos // uses native swift structs\nlet pos = monster.mutablePos // uses flatbuffers structs\n```\n\n----------------------------------------\n\nTITLE: Defining Arrays in FlatBuffers Struct\nDESCRIPTION: Examples showing two equivalent ways to define a fixed-length array in a FlatBuffers struct. The array syntax is a shorthand for defining multiple scalar fields.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nstruct Vec3 {\n  x:float;\n  y:float;\n  z:float;\n}\n```\n\nLANGUAGE: c++\nCODE:\n```\nstruct Vec3 {\n  v:[float:3];\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with Rust\nDESCRIPTION: Shows how to access elements of an inventory vector in a Monster object using Rust. The code unwraps the vector and accesses elements using slice syntax.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_157\n\nLANGUAGE: Rust\nCODE:\n```\n// Get and test an element from the `inventory` FlatBuffer's `vector`.\nlet inv = monster.inventory().unwrap();\n\n// Note that this vector is returned as a slice, because direct access for\n// this type, a `u8` vector, is safe on all platforms:\nlet third_item = inv[2];\n```\n\n----------------------------------------\n\nTITLE: Reading FlatBuffer binary file in Lobster\nDESCRIPTION: This snippet demonstrates how to import the FlatBuffers library and generated code, read a FlatBuffer binary file into a string, and access the root object.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/lobster.md#2025-04-16_snippet_0\n\nLANGUAGE: lobster\nCODE:\n```\ninclude \"monster_generated.lobster\"\n\nlet fb = read_file(\"monsterdata_test.mon\")\nassert fb\nlet monster = MyGame_Example_GetRootAsMonster(fb)\n```\n\n----------------------------------------\n\nTITLE: JSON Field Syntax Examples in FlatBuffers\nDESCRIPTION: Examples of FlatBuffers JSON field syntax for enums, unions, and null values. Shows how to reference enum values with and without type prefixes and how to specify union types.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_11\n\nLANGUAGE: JSON\nCODE:\n```\nfield: EnumVal\n```\n\nLANGUAGE: JSON\nCODE:\n```\nfield: \"Enum.EnumVal\"\n```\n\nLANGUAGE: JSON\nCODE:\n```\nfield: \"EnumVal1 EnumVal2\"\n```\n\nLANGUAGE: JSON\nCODE:\n```\nfield: \"Enum.EnumVal1 Enum.EnumVal2\"\n```\n\nLANGUAGE: JSON\nCODE:\n```\nfoo_type: FooOne\n```\n\nLANGUAGE: JSON\nCODE:\n```\nfield: null\n```\n\nLANGUAGE: JSON\nCODE:\n```\nrad(180)\n```\n\n----------------------------------------\n\nTITLE: Creating Vectors in Python using FlatBuffers\nDESCRIPTION: Shows how to create inventory and path vectors using Python FlatBuffers. The inventory is created by prepending bytes in reverse order, and the path vector contains Vec3 objects with 3D coordinates.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_64\n\nLANGUAGE: python\nCODE:\n```\nMyGame.Sample.Monster.StartInventoryVector(builder, 10)\nfor i in reversed(range(0, 10)):\n    builder.PrependByte(i)\ninv = builder.EndVector()\n\nMyGame.Sample.Monster.StartPathVector(builder, 2)\nMyGame.Sample.Vec3.CreateVec3(builder, 1.0, 2.0, 3.0)\nMyGame.Sample.Vec3.CreateVec3(builder, 4.0, 5.0, 6.0)\npath = builder.EndVector()\n```\n\n----------------------------------------\n\nTITLE: Reading a FlatBuffer Binary File in PHP with PSR Autoload\nDESCRIPTION: Example code demonstrating how to read a FlatBuffer binary file in PHP. It includes a PSR autoload function for loading FlatBuffers classes and shows how to read binary data and access the Monster object properties.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/php.md#2025-04-16_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n// It is recommended that your use PSR autoload when using FlatBuffers in PHP.\n  // Here is an example:\n  function __autoload($class_name) {\n    // The last segment of the class name matches the file name.\n    $class = substr($class_name, strrpos($class_name, \"\\\\\") + 1);\n    $root_dir = join(DIRECTORY_SEPARATOR, array(dirname(dirname(__FILE__)))); // `flatbuffers` root.\n\n    // Contains the `*.php` files for the FlatBuffers library and the `flatc` generated files.\n    $paths = array(join(DIRECTORY_SEPARATOR, array($root_dir, \"php\")),\n                   join(DIRECTORY_SEPARATOR, array($root_dir, \"tests\", \"MyGame\", \"Example\")));\n    foreach ($paths as $path) {\n      $file = join(DIRECTORY_SEPARATOR, array($path, $class . \".php\"));\n      if (file_exists($file)) {\n        require($file);\n        break;\n    }\n  }\n\n  // Read the contents of the FlatBuffer binary file.\n  $filename = \"monster.dat\";\n  $handle = fopen($filename, \"rb\");\n  $contents = $fread($handle, filesize($filename));\n  fclose($handle);\n\n  // Pass the contents to `GetRootAsMonster`.\n  $monster = \\MyGame\\Example\\Monster::GetRootAsMonster($contents);\n```\n\n----------------------------------------\n\nTITLE: Generating FlatBuffer Code in Go\nDESCRIPTION: Command for generating Go code from FlatBuffer schema files. Uses the flatc compiler with Go-specific options to generate the object API with a custom module name.\nSOURCE: https://github.com/google/flatbuffers/blob/master/examples/go-echo/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nflatc -g --gen-object-api --go-module-name echo hero.fbs net.fbs\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with Lobster\nDESCRIPTION: Demonstrates how to access a nested Vec3 struct from a Monster object in Lobster. The code retrieves the pos field and accesses its x, y, and z components.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_138\n\nLANGUAGE: Lobster\nCODE:\n```\nlet pos = monster.pos\nlet x = pos.x\nlet y = pos.y\nlet z = pos.z\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with Java\nDESCRIPTION: Shows how to access a nested Vec3 struct from a Monster object in Java. The code retrieves the pos field and accesses its x, y, and z components.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_135\n\nLANGUAGE: Java\nCODE:\n```\nVec3 pos = monster.pos();\nfloat x = pos.x();\nfloat y = pos.y();\nfloat z = pos.z();\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with C#\nDESCRIPTION: Demonstrates how to access a nested Vec3 struct from a Monster object in C#. The code uses property-based access to retrieve the pos field and access its X, Y, and Z components.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_132\n\nLANGUAGE: C#\nCODE:\n```\nvar pos = monster.Pos.Value;\nvar x = pos.X;\nvar y = pos.Y;\nvar z = pos.Z;\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with Go\nDESCRIPTION: Demonstrates how to access a nested Vec3 struct from a Monster object in Go. The code retrieves the pos field and accesses its X, Y, and Z components, with a note about performance optimization.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_134\n\nLANGUAGE: Go\nCODE:\n```\npos := monster.Pos(nil)\nx := pos.X()\ny := pos.Y()\nz := pos.Z()\n\n// Note: Whenever you access a new object, like in `Pos()`, a new temporary\n// accessor object gets created. If your code is very performance sensitive,\n// you can pass in a pointer to an existing `Vec3` instead of `nil`. This\n// allows you to reuse it across many calls to reduce the amount of object\n// allocation/garbage collection.\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with Dart\nDESCRIPTION: Shows how to access a nested Vec3 struct from a Monster object in Dart. The code retrieves the pos field and accesses its x, y, and z components using property syntax.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_133\n\nLANGUAGE: Dart\nCODE:\n```\nmyGame.Vec3 pos = monster.pos;\ndouble x = pos.x;\ndouble y = pos.y;\ndouble z = pos.z;\n```\n\n----------------------------------------\n\nTITLE: Weapon Table Schema Definition\nDESCRIPTION: FlatBuffer schema definition for a Weapon table containing name and damage fields.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_6\n\nLANGUAGE: c\nCODE:\n```\ntable Weapon {\n  name:string;\n  damage:short;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with Go\nDESCRIPTION: Shows how to access elements of an inventory vector in a Monster object using Go. The code gets the vector length and accesses the third element.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_149\n\nLANGUAGE: Go\nCODE:\n```\ninvLength := monster.InventoryLength()\nthirdItem := monster.Inventory(2)\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with Python\nDESCRIPTION: Demonstrates how to access elements of an inventory vector in a Monster object using Python. The code gets the vector length and accesses the third element.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_156\n\nLANGUAGE: Python\nCODE:\n```\ninv_len = monster.InventoryLength()\nthird_item = monster.Inventory(2)\n```\n\n----------------------------------------\n\nTITLE: Properly Deprecating a Field in FlatBuffers Schema\nDESCRIPTION: A well-evolved schema (version 3) that marks field 'a' as deprecated, which prevents its usage in new code while maintaining compatibility with old data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\ntable T {\n  a:int (deprecated);\n  b:int;\n  c:int;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer Values in Python\nDESCRIPTION: This snippet shows how to access values from a FlatBuffer object after it has been read from a file.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/python.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nhp = monster.Hp()\npos = monster.Pos()\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in Swift\nDESCRIPTION: Creates a FlatBuffer vector containing offsets to previously created Weapon tables using the createVector method.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_50\n\nLANGUAGE: swift\nCODE:\n```\n// Create a FlatBuffer `vector` that contains offsets to the sword and axe\n// we created above.\nlet weaponsOffset = builder.createVector(ofOffsets: [sword, axe])\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Fields in C++\nDESCRIPTION: Example of defining optional fields in FlatBuffers schema using C++ syntax. Shows how to declare fields that can be null when not present in the data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\nstd::optional<T> field;\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with JavaScript\nDESCRIPTION: Shows how to access elements of an inventory vector in a Monster object using JavaScript. The code gets the vector length and accesses the third element.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_151\n\nLANGUAGE: JavaScript\nCODE:\n```\nvar invLength = monster.inventoryLength();\nvar thirdItem = monster.inventory(2);\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with Rust\nDESCRIPTION: Demonstrates how to access a vector of Weapon tables from a Monster object using Rust. The code unwraps the vector, gets its length, and accesses the name and damage fields of the second weapon.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_172\n\nLANGUAGE: Rust\nCODE:\n```\n// Get and test the `weapons` FlatBuffers's `vector`.\nlet weps = monster.weapons().unwrap();\nlet weps_len = weps.len();\n\nlet wep2 = weps.get(1);\nlet second_weapon_name = wep2.name();\nlet second_weapon_damage = wep2.damage();\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with Java\nDESCRIPTION: Shows how to access a vector of Weapon tables from a Monster object using Java. The code gets the vector length and accesses the name and damage fields of the second weapon.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_165\n\nLANGUAGE: Java\nCODE:\n```\nint weaponsLength = monster.weaponsLength();\nString secondWeaponName = monster.weapons(1).name();\nshort secondWeaponDamage = monster.weapons(1).damage();\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with Swift\nDESCRIPTION: Shows how to access a vector of Weapon tables from a Monster object using Swift. The code gets the vector count and accesses the name and damage properties of a weapon at a specific index.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_173\n\nLANGUAGE: Swift\nCODE:\n```\n// Get the count of weapon objects\nlet wepsCount = monster.weaponsCount\n\nlet weapon2 = monster.weapons(at: 1)\nlet weaponName = weapon2.name\nlet weaponDmg = weapon2.damage\n```\n\n----------------------------------------\n\nTITLE: Using Discriminants for Safe Union Evolution\nDESCRIPTION: A correctly evolved union schema that uses explicit discriminant values to safely add variants in any order while maintaining compatibility.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_12\n\nLANGUAGE: c++\nCODE:\n```\nunion U {\n  A = 1,\n  another_a: A = 3,\n  B = 2\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (Java)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in Java. First wraps the byte array in a java.nio.ByteBuffer before passing to the generated accessor method.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_105\n\nLANGUAGE: Java\nCODE:\n```\nbyte[] bytes = /* the data you just read */\njava.nio.ByteBuffer buf = java.nio.ByteBuffer.wrap(bytes);\n\n// Get an accessor to the root object inside the buffer.\nMonster monster = Monster.getRootAsMonster(buf);\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with Swift\nDESCRIPTION: Shows how to access a nested Vec3 struct from a Monster object in Swift. The code retrieves the pos field and accesses its x, y, and z components using property syntax.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_143\n\nLANGUAGE: Swift\nCODE:\n```\nlet pos = monster.pos\nlet x = pos.x\nlet y = pos.y\nlet z = pos.z\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with C++\nDESCRIPTION: This C++ code demonstrates how to create a Monster object with an 'equipped' union field. It shows setting scalar fields like name, position, hp, and mana, as well as properly typing and setting the union field.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_68\n\nLANGUAGE: C++\nCODE:\n```\n// Create the remaining data needed for the Monster.\nauto name = builder.CreateString(\"Orc\");\n\n// Create the position struct\nauto position = Vec3(1.0f, 2.0f, 3.0f);\n\n// Set his hit points to 300 and his mana to 150.\nint hp = 300;\nint mana = 150;\n\n// Finally, create the monster using the `CreateMonster` helper function\n// to set all fields.\n//\n// Here we set the union field by using the `.Union()` method of the\n// `Offset<Weapon>` axe we already serialized above. We just have to specify\n// which type of object we put in the union, and do that with the\n// auto-generated `Equipment_Weapon` enum.\nflatbuffers::Offset<Monster> orc =\n    CreateMonster(builder, &position, mana, hp, name, inventory,\n                  Color_Red, weapons, Equipment_Weapon, axe.Union(),\n                  path);\n```\n\n----------------------------------------\n\nTITLE: Accessing Union Fields in Go\nDESCRIPTION: Shows union handling in Go using flatbuffers.Table for intermediate storage. Demonstrates type checking and initialization of specific union types.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_178\n\nLANGUAGE: Go\nCODE:\n```\n// We need a `flatbuffers.Table` to capture the output of the\n// `monster.Equipped()` function.\nunionTable := new(flatbuffers.Table)\n\nif monster.Equipped(unionTable) {\n    unionType := monster.EquippedType()\n\n    if unionType == sample.EquipmentWeapon {\n        // Create a `sample.Weapon` object that can be initialized with the \n        // contents of the `flatbuffers.Table` (`unionTable`), which was\n        // populated by `monster.Equipped()`.\n        unionWeapon = new(sample.Weapon)\n        unionWeapon.Init(unionTable.Bytes, unionTable.Pos)\n\n        weaponName = unionWeapon.Name()\n        weaponDamage = unionWeapon.Damage()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in Kotlin with FlatBuffers\nDESCRIPTION: Shows how to create two Weapon objects (sword and axe) using the createWeapon helper function in Kotlin. It sets the name and damage for each weapon, illustrating FlatBuffers serialization in Kotlin.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_29\n\nLANGUAGE: Kotlin\nCODE:\n```\nval weaponOneDamage: Short = 3;\nval weaponTwoDamage: Short = 5;\n\n// Use the `createWeapon()` helper function to create the weapons, since we\n// set every field.\nval sword = Weapon.createWeapon(builder, weaponOneName, weaponOneDamage)\nval axe = Weapon.createWeapon(builder, weaponTwoName, weaponTwoDamage)\n```\n\n----------------------------------------\n\nTITLE: JSON Escape Codes and Type Format Examples in FlatBuffers\nDESCRIPTION: Examples of valid escape codes and type formats in FlatBuffers JSON parsing, including escape sequences (\\n, \\t, etc.), unicode representations, and various numeric literal formats.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_10\n\nLANGUAGE: JSON\nCODE:\n```\n\\n - linefeed.\n\\t - tab.\n\\r - carriage return.\n\\b - backspace.\n\\f - form feed.\n\\\" - double quote.\n\\\\ - backslash.\n\\/ - forward slash.\n\\uXXXX - 16-bit unicode code point\n\\xXX - 8-bit binary hexadecimal number XX\n```\n\nLANGUAGE: JSON\nCODE:\n```\n[081, -00094]\n```\n\nLANGUAGE: JSON\nCODE:\n```\n[0x123, +0x45, -0x67]\n```\n\nLANGUAGE: JSON\nCODE:\n```\n[-1.0, 2., .3e0, 3.e4, 0x21.34p-5, -inf, nan]\n```\n\nLANGUAGE: JSON\nCODE:\n```\n\"1\", \"2.0\", \"0x48A\", \"0x0C.0Ep-1\", \"-inf\", \"true\"\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer Values in PHP\nDESCRIPTION: Example showing how to access values from a FlatBuffer Monster object in PHP. This short snippet demonstrates accessing the monster's HP and position properties.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/php.md#2025-04-16_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n$hp = $monster->GetHp();\n  $pos = $monster->GetPos();\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer Fields in Rust\nDESCRIPTION: This snippet shows how to access fields of a FlatBuffer object in Rust using the generated accessors. It demonstrates accessing both stored and default values.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/rust.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nprintln!(\"{}\", monster.hp());     // `80`\nprintln!(\"{}\", monster.mana());   // default value of `150`\nprintln!(\"{:?}\", monster.name()); // Some(\"MyMonster\")\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom String Type for C++ Object API (C++)\nDESCRIPTION: Demonstration of using --cpp-str-type to set a custom string type for the C++ object API. The custom type must support c_str(), length(), and empty() methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flatc.md#2025-04-16_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n--cpp-str-type MyCustomString\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (Python)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in Python. Uses the GetRootAs method with the bytearray buffer and an offset (typically 0).\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_111\n\nLANGUAGE: Python\nCODE:\n```\nbuf = /* the data you just read, in an object of type \"bytearray\" */\n\n# Get an accessor to the root object inside the buffer.\nmonster = MyGame.Sample.Monster.Monster.GetRootAs(buf, 0)\n\n# Note: We use `0` for the offset here, which is typical for most buffers\n# you would read.  If you wanted to read from the `builder.Bytes` directly,\n# you would need to pass in the offset of `builder.Head()`, as the builder\n# constructs the buffer backwards, so may not start at offset 0.\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in Lua with FlatBuffers\nDESCRIPTION: Creates two Weapon objects (sword and axe) using the Start, AddName, AddDamage, and End functions in Lua. It sets the name and damage for each weapon, illustrating FlatBuffers serialization in Lua.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_31\n\nLANGUAGE: Lua\nCODE:\n```\n-- Create the first 'Weapon'\nweapon.Start(builder)\nweapon.AddName(builder, weaponOne)\nweapon.AddDamage(builder, 3)\nlocal sword = weapon.End(builder)\n\n-- Create the second 'Weapon'\nweapon.Start(builder)\nweapon.AddName(builder, weaponTwo)\nweapon.AddDamage(builder, 5)\nlocal axe = weapon.End(builder)\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with Dart\nDESCRIPTION: This Dart code shows how to use the MonsterBuilder API to create a Monster with a union field in FlatBuffers. It demonstrates setting all fields including the union type and value.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_71\n\nLANGUAGE: Dart\nCODE:\n```\n// Serialize a name for our monster, called \"Orc\".\nfinal int name = builder.writeString('Orc');\n\n// Using the Builder API:\n// Set his hit points to 300 and his mana to 150.\nfinal int hp = 300;\nfinal int mana = 150;\n\nfinal monster = new myGame.MonsterBuilder(builder)\n    ..begin()\n    ..addNameOffset(name)\n    ..addInventoryOffset(inventory)\n    ..addWeaponsOffset(weapons)\n    ..addEquippedType(myGame.EquipmentTypeId.Weapon)\n    ..addEquippedOffset(axe)\n    ..addHp(hp)\n    ..addMana(mana)\n    ..addPos(vec3Builder.finish(1.0, 2.0, 3.0))\n    ..addPathOffset(path)\n    ..addColor(myGame.Color.Red);\n\nfinal int orc = monster.finish();\n```\n\n----------------------------------------\n\nTITLE: Accessing Union Fields in C#\nDESCRIPTION: Shows union access in C# using generic type parameters. Demonstrates type checking and property access using Value property.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_177\n\nLANGUAGE: C#\nCODE:\n```\nvar unionType = monster.EquippedType;\n\nif (unionType == Equipment.Weapon) {\n    var weapon = monster.Equipped<Weapon>().Value;\n\n    var weaponName = weapon.Name;     // \"Axe\"\n    var weaponDamage = weapon.Damage; // 5\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in C with FlatBuffers\nDESCRIPTION: Demonstrates creating two Weapon objects (sword and axe) using the Weapon_create function in C. It sets the name and damage for each weapon, showcasing FlatBuffers serialization in C.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_23\n\nLANGUAGE: C\nCODE:\n```\nuint16_t weapon_one_damage = 3;\nuint16_t weapon_two_damage = 5;\n\nns(Weapon_ref_t) sword \n    = ns(Weapon_create(B, weapon_one_name, weapon_one_damage));\nns(Weapon_ref_t) axe \n    = ns(Weapon_create(B, weapon_two_name, weapon_two_damage));\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in Dart\nDESCRIPTION: Retrieves the serialized buffer as a Uint8List in Dart.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_88\n\nLANGUAGE: dart\nCODE:\n```\nfinal Uint8List buf = builder.finish(orc);\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer Data Members in Lua\nDESCRIPTION: This code shows how to access member data from a FlatBuffer object in Lua using the colon notation to retrieve properties like HP and position.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/lua.md#2025-04-16_snippet_1\n\nLANGUAGE: lua\nCODE:\n```\n-- use the : notation to access member data\nlocal hp = monster1:Hp()\nlocal pos = monster1:Pos()\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer Object Properties in Kotlin\nDESCRIPTION: Shows how to access properties from a Monster object after reading from a FlatBuffer. Demonstrates property access syntax in Kotlin.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/kotlin.md#2025-04-16_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nval hp = monster.hp\nval pos = monster.pos!!\n```\n\n----------------------------------------\n\nTITLE: Custom Allocator Definition for FlatBuffers\nDESCRIPTION: Example of implementing a custom allocator for use with the object-based API in FlatBuffers.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename T> struct custom_allocator : public std::allocator<T> {\n\n  typedef T *pointer;\n\n  template <class U>\n  struct rebind {\n    typedef custom_allocator<U> other;\n  };\n\n  pointer allocate(const std::size_t n) {\n    return std::allocator<T>::allocate(n);\n  }\n\n  void deallocate(T* ptr, std::size_t n) {\n    return std::allocator<T>::deallocate(ptr,n);\n  }\n\n  custom_allocator() throw() {}\n\n  template <class U>\n  custom_allocator(const custom_allocator<U>&) throw() {}\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (Lua)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in Lua. Converts the string representation to a binary array structure before accessing the root object.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_109\n\nLANGUAGE: Lua\nCODE:\n```\nlocal bufAsString =   -- The data you just read in\n\n-- Convert the string representation into binary array Lua structure\nlocal buf = flatbuffers.binaryArray.New(bufAsString)\n\n-- Get an accessor to the root object insert the buffer\nlocal mon = monster.GetRootAsMonster(buf, 0)\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in Swift with FlatBuffers\nDESCRIPTION: Demonstrates creating two Weapon objects (sword and axe) using the startWeapon, add(name:), add(damage:), and endWeapon functions in Swift. It sets the name and damage for each weapon, showcasing FlatBuffers serialization in Swift.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_35\n\nLANGUAGE: Swift\nCODE:\n```\n// start creating the weapon by calling startWeapon\nlet weapon1Start = Weapon.startWeapon(&builder)\nWeapon.add(name: weapon1Name, &builder)\nWeapon.add(damage: 3, &builder)\n// end the object by passing the start point for the weapon 1\nlet sword = Weapon.endWeapon(&builder, start: weapon1Start)\n\nlet weapon2Start = Weapon.startWeapon(&builder)\nWeapon.add(name: weapon2Name, &builder)\nWeapon.add(damage: 5, &builder)\nlet axe = Weapon.endWeapon(&builder, start: weapon2Start)\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with Rust\nDESCRIPTION: This Rust code snippet shows the beginning of Monster creation with a union field in FlatBuffers. It demonstrates creating the name field as the first step in the serialization process.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_80\n\nLANGUAGE: Rust\nCODE:\n```\n// Name of the Monster.\nlet name = builder.create_string(\"Orc\");\n\n// Create the monster using the `Monster::create` helper function. This\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with PHP\nDESCRIPTION: This PHP code demonstrates creating a Monster with a union field in FlatBuffers. It uses StartMonster/EndMonster functions and explicitly sets both the union type and union value fields.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_78\n\nLANGUAGE: PHP\nCODE:\n```\n// Serialize a name for our monster, called \"Orc\".\n$name = $builder->createString(\"Orc\");\n\n    // Create our monster by using `StartMonster()` and `EndMonster()`.\n\\MyGame\\Sample\\Monster::StartMonster($builder);\n\\MyGame\\Sample\\Monster::AddPos($builder,\n    \\MyGame\\Sample\\Vec3::CreateVec3($builder, 1.0, 2.0, 3.0));\n\\MyGame\\Sample\\Monster::AddHp($builder, 300);\n\\MyGame\\Sample\\Monster::AddName($builder, $name);\n\\MyGame\\Sample\\Monster::AddInventory($builder, $inv);\n\\MyGame\\Sample\\Monster::AddColor($builder, \\MyGame\\Sample\\Color::Red);\n\\MyGame\\Sample\\Monster::AddWeapons($builder, $weapons);\n\\MyGame\\Sample\\Monster::AddEquippedType($builder, \n    \\MyGame\\Sample\\Equipment::Weapon);\n\\MyGame\\Sample\\Monster::AddEquipped($builder, $axe);\n\\MyGame\\Sample\\Monster::AddPath($builder, $path);\n$orc = \\MyGame\\Sample\\Monster::EndMonster($builder);\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in PHP\nDESCRIPTION: Creates an array of Weapon offsets and uses the CreateWeaponsVector method to serialize it into a FlatBuffer vector.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_47\n\nLANGUAGE: php\nCODE:\n```\n// Create an array from the two `Weapon`s and pass it to the\n// `CreateWeaponsVector()` method to create a FlatBuffer vector.\n$weaps = array($sword, $axe);\n$weapons = \\MyGame\\Sample\\Monster::CreateWeaponsVector($builder, $weaps);\n```\n\n----------------------------------------\n\nTITLE: Changing Field Types in FlatBuffers Schema\nDESCRIPTION: A potentially problematic schema evolution that changes field types from signed to unsigned integers, which may cause issues with negative values.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\ntable T {\n  a:uint;\n  b:uint;\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with JavaScript\nDESCRIPTION: This JavaScript code shows how to create a Monster with a union field in FlatBuffers. It demonstrates using startMonster/endMonster functions and explicitly setting both the union type and value.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_74\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Serialize a name for our monster, called 'Orc'.\nvar name = builder.createString('Orc');\n\n// Create our monster by using `startMonster()` and `endMonster()`.\nMyGame.Sample.Monster.startMonster(builder);\nMyGame.Sample.Monster.addPos(builder,\n   MyGame.Sample.Vec3.createVec3(builder, 1.0, 2.0, 3.0));\nMyGame.Sample.Monster.addHp(builder, 300);\nMyGame.Sample.Monster.addColor(builder, MyGame.Sample.Color.Red)\nMyGame.Sample.Monster.addName(builder, name);\nMyGame.Sample.Monster.addInventory(builder, inv);\nMyGame.Sample.Monster.addWeapons(builder, weapons);\nMyGame.Sample.Monster.addEquippedType(builder, \n    MyGame.Sample.Equipment.Weapon);\nMyGame.Sample.Monster.addEquipped(builder, axe);\nMyGame.Sample.Monster.addPath(builder, path);\nvar orc = MyGame.Sample.Monster.endMonster(builder);\n```\n\n----------------------------------------\n\nTITLE: Table Builder Class in FlatBuffers\nDESCRIPTION: Example of a builder class for constructing a table in FlatBuffers. The builder allows adding fields in any order and handles vtable generation automatically when Finish() is called.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nstruct MonsterBuilder {\n  flatbuffers::FlatBufferBuilder &fbb_;\n  flatbuffers::uoffset_t start_;\n  void add_pos(const Vec3 *pos) { fbb_.AddStruct(4, pos); }\n  void add_mana(int16_t mana) { fbb_.AddElement<int16_t>(6, mana, 150); }\n  void add_hp(int16_t hp) { fbb_.AddElement<int16_t>(8, hp, 100); }\n  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(10, name); }\n  void add_inventory(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> inventory) { fbb_.AddOffset(14, inventory); }\n  void add_color(int8_t color) { fbb_.AddElement<int8_t>(16, color, 2); }\n  MonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }\n  flatbuffers::Offset<Monster> Finish() { return flatbuffers::Offset<Monster>(fbb_.EndTable(start_, 7)); }\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in JavaScript\nDESCRIPTION: Retrieves the serialized buffer as a Uint8Array in JavaScript.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_91\n\nLANGUAGE: javascript\nCODE:\n```\nvar buf = builder.asUint8Array(); // Of type `Uint8Array`.\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with Lua\nDESCRIPTION: Demonstrates how to access elements of an inventory vector in a Monster object using Lua. The code gets the vector length and accesses the third element, noting that Lua is 1-based.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_154\n\nLANGUAGE: Lua\nCODE:\n```\nlocal invLength = mon:InventoryLength()\nlocal thirdItem = mon:Inventory(3) -- Lua is 1-based\n```\n\n----------------------------------------\n\nTITLE: Creating Monster Object in TypeScript\nDESCRIPTION: Creates a Monster object in TypeScript using the FlatBuffers builder. It sets properties like position, hp, color, name, inventory, weapons, and equipment.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_83\n\nLANGUAGE: ts\nCODE:\n```\nlet name = builder.createString('Orc');\n\nMyGame.Sample.Monster.startMonster(builder);\nMyGame.Sample.Monster.addPos(builder,\n    MyGame.Sample.Vec3.createVec3(builder, 1.0, 2.0, 3.0));\nMyGame.Sample.Monster.addHp(builder, 300);\nMyGame.Sample.Monster.addColor(builder, MyGame.Sample.Color.Red)\nMyGame.Sample.Monster.addName(builder, name);\nMyGame.Sample.Monster.addInventory(builder, inv);\nMyGame.Sample.Monster.addWeapons(builder, weapons);\nMyGame.Sample.Monster.addEquippedType(builder,\n    MyGame.Sample.Equipment.Weapon);\nMyGame.Sample.Monster.addEquipped(builder, axe);\nMyGame.Sample.Monster.addPath(builder, path);\nlet orc = MyGame.Sample.Monster.endMonster(builder);\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in Dart with FlatBuffers\nDESCRIPTION: Shows two methods of creating Weapon objects in Dart: using WeaponBuilder and WeaponObjectBuilder. It sets the name and damage for each weapon, demonstrating FlatBuffers serialization in Dart.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_25\n\nLANGUAGE: Dart\nCODE:\n```\nfinal int weaponOneDamage = 3;\nfinal int weaponTwoDamage = 5;\n\nfinal swordBuilder = new myGame.WeaponBuilder(builder)\n    ..begin()\n    ..addNameOffset(weaponOneName)\n    ..addDamage(weaponOneDamage);\nfinal int sword = swordBuilder.finish();\n\nfinal axeBuilder = new myGame.WeaponBuilder(builder)\n    ..begin()\n    ..addNameOffset(weaponTwoName)\n    ..addDamage(weaponTwoDamage);\nfinal int axe = axeBuilder.finish();\n\n// Alternative method using WeaponObjectBuilder\nfinal myGame.WeaponBuilder sword = new myGame.WeaponObjectBuilder(\n    name: \"Sword\",\n    damage: 3,\n);\n\nfinal myGame.WeaponBuilder axe = new myGame.WeaponObjectBuilder(\n    name: \"Axe\",\n    damage: 5,\n);\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with Go\nDESCRIPTION: Demonstrates how to access a vector of Weapon tables from a Monster object using Go. The code shows how to reuse a Weapon object for retrieving data from the vector.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_164\n\nLANGUAGE: Go\nCODE:\n```\nweaponLength := monster.WeaponsLength()\n// We need a `sample.Weapon` to pass into `monster.Weapons()`\n// to capture the output of the function.k\nweapon := new(sample.Weapon)\nif monster.Weapons(weapon, 1) {\n        secondWeaponName := weapon.Name()\n        secondWeaponDamage := weapon.Damage()\n}\n```\n\n----------------------------------------\n\nTITLE: FlatBuffers gRPC Server Implementation\nDESCRIPTION: Example server implementation using FlatBuffers with gRPC integration.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"https://raw.githubusercontent.com/google/flatbuffers/refs/heads/master/grpc/samples/greeter/server.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in TypeScript\nDESCRIPTION: Creates an array of Weapon offsets and uses the createWeaponsVector method to serialize it into a FlatBuffer vector.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\n// Create an array from the two `Weapon`s and pass it to the\n// `createWeaponsVector()` method to create a FlatBuffer vector.\nlet weaps = [sword, axe];\nlet weapons = MyGame.Sample.Monster.createWeaponsVector(builder, weaps);\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in Python\nDESCRIPTION: Creates a FlatBuffer vector by prepending weapon offsets in reverse order. Uses StartWeaponsVector and EndVector methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_48\n\nLANGUAGE: python\nCODE:\n```\n# Create a FlatBuffer vector and prepend the weapons.\n# Note: Since we prepend the data, prepend them in reverse order.\nMyGame.Sample.Monster.StartWeaponsVector(builder, 2)\nbuilder.PrependUOffsetTRelative(axe)\nbuilder.PrependUOffsetTRelative(sword)\nweapons = builder.EndVector()\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in Lua\nDESCRIPTION: Creates a FlatBuffer vector by prepending weapon offsets in reverse order. Uses StartWeaponsVector and EndVector methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_46\n\nLANGUAGE: lua\nCODE:\n```\n-- Create a FlatBuffer vector and prepend the weapons.\n-- Note: Since we prepend the data, prepend them in reverse order.\nmonster.StartWeaponsVector(builder, 2)\nbuilder:PrependUOffsetTRelative(axe)\nbuilder:PrependUOffsetTRelative(sword)\nlocal weapons = builder:EndVector(2)\n```\n\n----------------------------------------\n\nTITLE: Encoding Map Example in FlexBuffers\nDESCRIPTION: Demonstrates how a simple map { foo: 13, bar: 14 } is encoded in FlexBuffers format. This example shows the byte-level representation of keys, values, offsets, and type information.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n0 : uint8_t 'b', 'a', 'r', 0\n4 : uint8_t 'f', 'o', 'o', 0\n8 : uint8_t 2      // key vector of size 2\n// key vector offset points here\n9 : uint8_t 9, 6   // offsets to bar_key and foo_key\n11: uint8_t 2, 1   // offset to key vector, and its byte width\n13: uint8_t 2      // value vector of size\n// value vector offset points here\n14: uint8_t 14, 13 // values\n16: uint8_t 4, 4   // types\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Scalars and Structs in Java\nDESCRIPTION: Shows how to serialize a vector of scalar values (inventory) using createInventoryVector and a vector of structs (path) using createVec3 method.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_57\n\nLANGUAGE: java\nCODE:\n```\n// Create a `vector` representing the inventory of the Orc. Each number\n// could correspond to an item that can be claimed after he is slain.\nbyte[] treasure = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nint inv = Monster.createInventoryVector(builder, treasure);\n\nMonster.startPathVector(fbb, 2);\nVec3.createVec3(builder, 1.0f, 2.0f, 3.0f);\nVec3.createVec3(builder, 4.0f, 5.0f, 6.0f);\nint path = fbb.endVector();\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Scalars and Structs in JavaScript\nDESCRIPTION: Demonstrates serializing a vector of scalar values (inventory) and a vector of structs (path) using createInventoryVector and createVec3 methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_58\n\nLANGUAGE: javascript\nCODE:\n```\n// Create a `vector` representing the inventory of the Orc. Each number\n// could correspond to an item that can be claimed after he is slain.\nvar treasure = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nvar inv = MyGame.Sample.Monster.createInventoryVector(builder, treasure);\n\nMyGame.Sample.Monster.startPathVector(builder, 2);\nMyGame.Sample.Vec3.createVec3(builder, 1.0, 2.0, 3.0);\nMyGame.Sample.Vec3.createVec3(builder, 4.0, 5.0, 6.0);\nvar path = builder.endVector();\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with C\nDESCRIPTION: Demonstrates how to access elements of an inventory vector in a Monster object using C. The code handles null checks and retrieves the vector length.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_146\n\nLANGUAGE: C\nCODE:\n```\n// If `inv` hasn't been set, it will be null. It is valid get\n// the length of null which will be 0, useful for iteration.\nflatbuffers_uint8_vec_t inv = ns(Monster_inventory(monster));\nsize_t inv_len = flatbuffers_uint8_vec_len(inv);\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with TypeScript\nDESCRIPTION: Demonstrates how to access a vector of Weapon tables from a Monster object using TypeScript. The code gets the vector length and accesses the name and damage fields of the second weapon.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_174\n\nLANGUAGE: TypeScript\nCODE:\n```\nlet weaponsLength = monster.weaponsLength();\nlet secondWeaponName = monster.weapons(1).name();\nlet secondWeaponDamage = monster.weapons(1).damage();\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in C++\nDESCRIPTION: Creates a vector of Weapon table offsets and serializes it into the FlatBuffer. Uses std::vector to store offsets temporarily before serialization.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_37\n\nLANGUAGE: cpp\nCODE:\n```\n// Create a std::vector of the offsets we had previous made.\nstd::vector<flatbuffers::Offset<Weapon>> weapons_vector;\nweapons_vector.push_back(sword);\nweapons_vector.push_back(axe);\n\n// Then serialize that std::vector into the buffer and again get an Offset\n// to that vector. Use `auto` here since the full type is long, and it just\n// a \"typed\" number.\nauto weapons = builder.CreateVector(weapons_vector);\n```\n\n----------------------------------------\n\nTITLE: Iterating Over FlatBuffer Vector in Python\nDESCRIPTION: This snippet shows the traditional method of iterating over a vector in a FlatBuffer, which is slower compared to using Numpy arrays.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/python.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ninventory = []\nfor i in range(monster.InventoryLength()):\n    inventory.append(int(monster.Inventory(i)))\n```\n\n----------------------------------------\n\nTITLE: Encoding Root Integer in FlexBuffers\nDESCRIPTION: Illustrates how a simple integer value (13) is encoded as the root element in a FlexBuffer. This example shows the compact representation of the value, type, and root byte width.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\nuint8_t 13, 4, 1    // Value, type, root byte width.\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with Go\nDESCRIPTION: This Go code demonstrates creating a Monster with a union field in FlatBuffers. It uses MonsterStart/MonsterEnd functions and shows how to add both the union type and value fields.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_72\n\nLANGUAGE: Go\nCODE:\n```\n// Serialize a name for our monster, called \"Orc\".\nname := builder.CreateString(\"Orc\")\n\n// Create our monster using `MonsterStart()` and `MonsterEnd()`.\nsample.MonsterStart(builder)\nsample.MonsterAddPos(builder, sample.CreateVec3(builder, 1.0, 2.0, 3.0))\nsample.MonsterAddHp(builder, 300)\nsample.MonsterAddName(builder, name)\nsample.MonsterAddInventory(builder, inv)\nsample.MonsterAddColor(builder, sample.ColorRed)\nsample.MonsterAddWeapons(builder, weapons)\nsample.MonsterAddEquippedType(builder, sample.EquipmentWeapon)\nsample.MonsterAddEquipped(builder, axe)\nsample.MonsterAddPath(builder, path)\norc := sample.MonsterEnd(builder)\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in Kotlin\nDESCRIPTION: Places weapon offsets into an array and uses the createWeaponsVector method to create a FlatBuffer vector.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_44\n\nLANGUAGE: kotlin\nCODE:\n```\n// Place the two weapons into an array, and pass it to the \n// `createWeaponsVector()` method to create a FlatBuffer vector.\nval weaps = intArrayOf(sword, axe)\n\n// Pass the `weaps` array into the `createWeaponsVector()` method to create\n// a FlatBuffer vector.\nval weapons = Monster.createWeaponsVector(builder, weaps)\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with TypeScript\nDESCRIPTION: Shows how to access elements of an inventory vector in a Monster object using TypeScript. The code gets the vector length and accesses the third element.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_159\n\nLANGUAGE: TypeScript\nCODE:\n```\nlet invLength = monster.inventoryLength();\nlet thirdItem = monster.inventory(2);\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with Lua\nDESCRIPTION: Shows how to access a vector of Weapon tables from a Monster object using Lua. The code gets the vector length and accesses the Name and Damage fields of the second weapon, accounting for Lua's 1-based indexing.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_169\n\nLANGUAGE: Lua\nCODE:\n```\nlocal weaponsLength = mon:WeaponsLength()\nlocal secondWeaponName = mon:Weapon(2):Name()\nlocal secondWeaponDamage = mon:Weapon(2):Damage()\n```\n\n----------------------------------------\n\nTITLE: Building FlatBuffers Compiler with CMake\nDESCRIPTION: Commands to build the FlatBuffers compiler (flatc) using CMake build system on Linux platforms.\nSOURCE: https://github.com/google/flatbuffers/blob/master/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncmake -G \"Unix Makefiles\"\nmake -j\n```\n\n----------------------------------------\n\nTITLE: Defining FlatBuffers Schema Grammar in EBNF\nDESCRIPTION: Complete EBNF grammar specification for FlatBuffers schema language, defining all elements of a valid schema file including includes, namespaces, tables, structs, enums, unions, fields, and RPC services. The grammar also specifies rules for constants, identifiers, and metadata.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/grammar.md#2025-04-16_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nschema = include* ( namespace_decl | type_decl | enum_decl | root_decl |\n           file_extension_decl | file_identifier_decl |\n           attribute_decl | rpc_decl | object )*\n\ninclude = `include` string_constant `;`\n\nnamespace_decl = `namespace` ident ( `.` ident )* `;`\n\nattribute_decl = `attribute` ident | `\"` ident `\"` `;`\n\ntype_decl = ( `table` | `struct` ) ident metadata `{` field_decl+ `}`\n\nenum_decl = ( `enum` ident `:` type | `union` ident )  metadata `{`\ncommasep( enumval_decl ) `}`\n\nroot_decl = `root_type` ident `;`\n\nfield_decl = ident `:` type [ `=` scalar ] metadata `;`\n\nrpc_decl = `rpc_service` ident `{` rpc_method+ `}`\n\nrpc_method = ident `(` ident `)` `:` ident metadata `;`\n\ntype = `bool` | `byte` | `ubyte` | `short` | `ushort` | `int` | `uint` |\n       `float` | `long` | `ulong` | `double` | `int8` | `uint8` | `int16` |\n       `uint16` | `int32` | `uint32`| `int64` | `uint64` | `float32` |\n       `float64` | `string` | `[` type `]` | ident\n\nenumval_decl = ident [ `=` integer_constant ] metadata\n\nmetadata = [ `(` commasep( ident [ `:` single_value ] ) `)` ]\n\nscalar = boolean_constant | integer_constant | float_constant\n\nobject = `{` commasep( ident `:` value ) `}`\n\nsingle_value = scalar | string_constant\n\nvalue = single_value | object | `[` commasep( value ) `]`\n\ncommasep(x) = [ x ( `,` x )\\* ]\n\nfile_extension_decl = `file_extension` string_constant `;`\n\nfile_identifier_decl = `file_identifier` string_constant `;`\n\nstring_constant = `\\\".*?\\\"`\n\nident = `[a-zA-Z_][a-zA-Z0-9_]*`\n\n`[:digit:]` = `[0-9]`\n\n`[:xdigit:]` = `[0-9a-fA-F]`\n\ndec_integer_constant = `[-+]?[:digit:]+`\n\nhex_integer_constant = `[-+]?0[xX][:xdigit:]+`\n\ninteger_constant = dec_integer_constant | hex_integer_constant\n\ndec_float_constant = `[-+]?(([.][:digit:]+)|([:digit:]+[.][:digit:]*)|([:digit:]+))([eE][-+]?[:digit:]+)?`\n\nhex_float_constant = `[-+]?0[xX](([.][:xdigit:]+)|([:xdigit:]+[.][:xdigit:]*)|([:xdigit:]+))([pP][-+]?[:digit:]+)`\n\nspecial_float_constant = `[-+]?(nan|inf|infinity)`\n\nfloat_constant = dec_float_constant | hex_float_constant | special_float_constant\n\nboolean_constant = `true` | `false`\n```\n\n----------------------------------------\n\nTITLE: Checking Present Members in FlatBuffers C\nDESCRIPTION: Demonstrates how to check if fields are present in a FlatBuffer object using the C API.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/c.md#2025-04-16_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint hp_present = ns(Monster_hp_is_present(monster)); // 1\nint mana_present = ns(Monster_mana_is_present(monster)); // 0\n```\n\n----------------------------------------\n\nTITLE: Creating FlatBuffer Binary from JSON\nDESCRIPTION: Command to create a FlatBuffer binary file from a JSON input file using a schema definition.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/annotation.md#2025-04-16_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n..\\..\\flatc -b annotated_binary.fbs annotated_binary.json\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Vectors in FlatBuffers with Kotlin\nDESCRIPTION: Shows how to access a vector of Weapon tables from a Monster object using Kotlin. The code uses non-null assertions when accessing the vector elements and their fields.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_167\n\nLANGUAGE: Kotlin\nCODE:\n```\nval weaponsLength = monster.weaponsLength\nval secondWeaponName = monster.weapons(1)!!.name\nval secondWeaponDamage = monster.weapons(1)!!.damage\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with TypeScript\nDESCRIPTION: Demonstrates how to access a nested Vec3 struct from a Monster object in TypeScript. The code retrieves the pos field and accesses its x, y, and z components.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_144\n\nLANGUAGE: TypeScript\nCODE:\n```\nlet pos = monster.pos();\nlet x = pos.x();\nlet y = pos.y();\nlet z = pos.z();\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in PHP with FlatBuffers\nDESCRIPTION: Shows how to create two Weapon objects (sword and axe) using the CreateWeapon function in PHP. It sets the name and damage for each weapon, demonstrating FlatBuffers serialization in PHP.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_32\n\nLANGUAGE: PHP\nCODE:\n```\n$sword = \\MyGame\\Sample\\Weapon::CreateWeapon($builder, $weapon_one_name, 3);\n$axe = \\MyGame\\Sample\\Weapon::CreateWeapon($builder, $weapon_two_name, 5);\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with Kotlin\nDESCRIPTION: Demonstrates how to access elements of an inventory vector in a Monster object using Kotlin. The code gets the vector length and uses non-null assertion when accessing the third element.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_152\n\nLANGUAGE: Kotlin\nCODE:\n```\nval invLength = monster.inventoryLength\nval thirdItem = monster.inventory(2)!!\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in Java\nDESCRIPTION: Places weapon offsets into an array and uses the createWeaponsVector method to create a FlatBuffer vector.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_42\n\nLANGUAGE: java\nCODE:\n```\n// Place the two weapons into an array, and pass it to the \n// `createWeaponsVector()` method to create a FlatBuffer vector.\nint[] weaps = new int[2];\nweaps[0] = sword;\nweaps[1] = axe;\n\n// Pass the `weaps` array into the `createWeaponsVector()` method to create\n// a FlatBuffer vector.\nint weapons = Monster.createWeaponsVector(builder, weaps);\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (C)\nDESCRIPTION: Code to access specific fields from a Monster table in C. Uses field-specific accessor functions with the table object as a parameter.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_116\n\nLANGUAGE: C\nCODE:\n```\nuint16_t hp = ns(Monster_hp(monster));\nuint16_t mana = ns(Monster_mana(monster));\nflatbuffers_string_t name = ns(Monster_name(monster));\n```\n\n----------------------------------------\n\nTITLE: Generating Binary Flatbuffer Schema Files using flatc\nDESCRIPTION: Command to invoke flatc to generate .bfbs (binary flatbuffer schema) files from your .fbs schema files. This creates the intermediate representation that can be used for runtime reflection purposes.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/intermediate_representation.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nflatc -b --schema ${your_fbs_files}\n```\n\n----------------------------------------\n\nTITLE: FlatBuffers gRPC Client Implementation\nDESCRIPTION: Example client implementation using FlatBuffers with gRPC integration.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"https://raw.githubusercontent.com/google/flatbuffers/refs/heads/master/grpc/samples/greeter/client.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with JavaScript\nDESCRIPTION: Demonstrates how to access a nested Vec3 struct from a Monster object in JavaScript. The code retrieves the pos field and accesses its x, y, and z components.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_136\n\nLANGUAGE: JavaScript\nCODE:\n```\nvar pos = monster.pos();\nvar x = pos.x();\nvar y = pos.y();\nvar z = pos.z();\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in Rust with FlatBuffers\nDESCRIPTION: Creates two Weapon objects (sword and axe) using the Weapon::create function with WeaponArgs in Rust. It sets the name and damage for each weapon, illustrating FlatBuffers serialization in Rust.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_34\n\nLANGUAGE: Rust\nCODE:\n```\n// Use the `Weapon::create` shortcut to create Weapons with named field\n// arguments.\nlet sword = Weapon::create(&mut builder, &WeaponArgs{\n    name: Some(weapon_one_name),\n    damage: 3,\n});\nlet axe = Weapon::create(&mut builder, &WeaponArgs{\n    name: Some(weapon_two_name),\n    damage: 5,\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with Java\nDESCRIPTION: Demonstrates how to access elements of an inventory vector in a Monster object using Java. The code gets the vector length and accesses the third element.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_150\n\nLANGUAGE: Java\nCODE:\n```\nint invLength = monster.inventoryLength();\nbyte thirdItem = monster.inventory(2);\n```\n\n----------------------------------------\n\nTITLE: Creating Vectors in Swift using FlatBuffers\nDESCRIPTION: Shows vector creation in Swift FlatBuffers by creating an inventory array of bytes and a path vector of Vec3 structs containing 3D coordinates.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_66\n\nLANGUAGE: swift\nCODE:\n```\nlet inventory: [Byte] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nlet inventoryOffset = builder.createVector(inventory)\n\nlet path = fbb.createVector(ofStructs: [\n    Vec3(x: 1, y: 2, z: 3),\n    Vec3(x: 4, y: 5, z: 6)\n])\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for FlatBuffers Documentation in Bash\nDESCRIPTION: Commands to install the required Python packages for building the FlatBuffers documentation locally. This installs mkdocs-material and mkdocs-redirects which are needed for the documentation build system.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install mkdocs-material\npip install mkdocs-redirects\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in Kotlin\nDESCRIPTION: Retrieves the serialized buffer as a ByteBuffer or byte array in Kotlin.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_92\n\nLANGUAGE: kotlin\nCODE:\n```\nval buf = builder.dataBuffer()\n\nval buf = builder.sizedByteArray()\n```\n\n----------------------------------------\n\nTITLE: Annotating FlatBuffer Binary Files\nDESCRIPTION: Command to annotate FlatBuffer binary files using a schema file. The command takes a schema file (.fbs or .bfbs) and one or more binary files as input, producing annotated .afb files as output.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/annotation.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nflatc --annotate SCHEMA -- BINARY_FILES...\n```\n\n----------------------------------------\n\nTITLE: FlatBuffers gRPC Schema Definition\nDESCRIPTION: Schema definition for a gRPC greeter service using FlatBuffers serialization format.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"https://raw.githubusercontent.com/google/flatbuffers/refs/heads/master/grpc/samples/greeter/greeter.fbs\"\n```\n\n----------------------------------------\n\nTITLE: Serializing Weapon Tables in Python with FlatBuffers\nDESCRIPTION: Demonstrates creating two Weapon objects (sword and axe) using the Start, AddName, AddDamage, and End functions in Python. It sets the name and damage for each weapon, showcasing FlatBuffers serialization in Python.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_33\n\nLANGUAGE: Python\nCODE:\n```\n# Create the first `Weapon` ('Sword').\nMyGame.Sample.Weapon.Start(builder)\nMyGame.Sample.Weapon.AddName(builder, weapon_one)\nMyGame.Sample.Weapon.AddDamage(builder, 3)\nsword = MyGame.Sample.Weapon.End(builder)\n\n# Create the second `Weapon` ('Axe').\nMyGame.Sample.Weapon.Start(builder)\nMyGame.Sample.Weapon.AddName(builder, weapon_two)\nMyGame.Sample.Weapon.AddDamage(builder, 5)\naxe = MyGame.Sample.Weapon.End(builder)\n```\n\n----------------------------------------\n\nTITLE: Parsing Text Files with FlatBuffers Parser\nDESCRIPTION: Demonstrates parsing text files using the FlatBuffers parser, returning false if parsing errors occur.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nparser.Parse(text_file.c_str());\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Objects in FlatBuffers with Kotlin\nDESCRIPTION: Shows how to access a nested Vec3 struct from a Monster object in Kotlin. The code uses the non-null assertion operator to handle potential null values when retrieving the pos field.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_137\n\nLANGUAGE: Kotlin\nCODE:\n```\nval pos = monster.pos!!\nval x = pos.x\nval y = pos.y\nval z = pos.z\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Scalars and Structs in C#\nDESCRIPTION: Demonstrates serializing a vector of scalar values (inventory) and a vector of structs (path) using StartInventoryVector, AddByte, and CreateVec3 methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_54\n\nLANGUAGE: csharp\nCODE:\n```\n// Create a `vector` representing the inventory of the Orc. Each number\n// could correspond to an item that can be claimed after he is slain.\n// Note: Since we prepend the bytes, this loop iterates in reverse order.\nMonster.StartInventoryVector(builder, 10);\nfor (int i = 9; i >= 0; i--)\n{\n    builder.AddByte((byte)i);\n}\nOffset<Vector<byte>> inventory = builder.EndVector();\n\n  // Start building a path vector of length 2.\nMonster.StartPathVector(fbb, 2);\n\n// Serialize the individual Vec3 structs\nVec3.CreateVec3(builder, 1.0f, 2.0f, 3.0f);\nVec3.CreateVec3(builder, 4.0f, 5.0f, 6.0f);\n\n// End the vector to get the offset\nOffset<Vector<Vec3>> path = fbb.EndVector();\n```\n\n----------------------------------------\n\nTITLE: Generating Annotated Binaries with FlatBuffers Compiler\nDESCRIPTION: This command demonstrates how to use the FlatBuffers compiler (flatc) to generate annotated binaries from corrupted test files. It specifies the schema file and the directory containing the test binaries.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/annotated_binary/tests/README.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd .tests/annotated_binary\n../../flatc -annotate annotated_binary.fbs tests/{binary_file}...\n```\n\n----------------------------------------\n\nTITLE: Struct Definition with Memory Alignment in FlatBuffers\nDESCRIPTION: Example of a struct definition in FlatBuffers with manual memory alignment. Structs are fixed-size and use endian-aware scalar handling to ensure cross-platform compatibility.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nFLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 {\n private:\n  float x_;\n  float y_;\n  float z_;\n\n public:\n  Vec3(float x, float y, float z)\n    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) {}\n\n  float x() const { return flatbuffers::EndianScalar(x_); }\n  float y() const { return flatbuffers::EndianScalar(y_); }\n  float z() const { return flatbuffers::EndianScalar(z_); }\n};\nFLATBUFFERS_STRUCT_END(Vec3, 12);\n```\n\n----------------------------------------\n\nTITLE: Defining Build Options for FlatBuffers Project\nDESCRIPTION: Configures various build options for the FlatBuffers project, including enabling/disabling tests, installation, compiler building, code coverage, and other compilation features. Each option includes a descriptive comment about its purpose.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# NOTE: Code coverage only works on Linux & OSX.\noption(FLATBUFFERS_CODE_COVERAGE \"Enable the code coverage build option.\" OFF)\noption(FLATBUFFERS_BUILD_TESTS \"Enable the build of tests and samples.\" ON)\noption(FLATBUFFERS_INSTALL \"Enable the installation of targets.\" ON)\noption(FLATBUFFERS_BUILD_FLATLIB \"Enable the build of the flatbuffers library\"\n       ON)\noption(FLATBUFFERS_BUILD_FLATC \"Enable the build of the flatbuffers compiler\"\n       ON)\noption(FLATBUFFERS_STATIC_FLATC \"Build flatbuffers compiler with -static flag\"\n       OFF)\noption(FLATBUFFERS_BUILD_FLATHASH \"Enable the build of flathash\" OFF)\noption(FLATBUFFERS_BUILD_BENCHMARKS \"Enable the build of flatbenchmark.\"\n       OFF)\noption(FLATBUFFERS_BUILD_GRPCTEST \"Enable the build of grpctest\" OFF)\noption(FLATBUFFERS_BUILD_SHAREDLIB\n       \"Enable the build of the flatbuffers shared library\"\n       OFF)\noption(FLATBUFFERS_LIBCXX_WITH_CLANG \"Force libc++ when using Clang\" ON)\n# NOTE: Sanitizer check only works on Linux & OSX (gcc & llvm).\noption(FLATBUFFERS_CODE_SANITIZE\n      \"Add '-fsanitize' flags to 'flattests' and 'flatc' targets.\"\n      OFF)\noption(FLATBUFFERS_PACKAGE_REDHAT\n       \"Build an rpm using the 'package' target.\"\n       OFF)\noption(FLATBUFFERS_PACKAGE_DEBIAN\n       \"Build an deb using the 'package' target.\"\n       OFF)\noption(FLATBUFFERS_BUILD_CPP17\n       \"Enable the build of c++17 test target. \\\"\n       Requirements: Clang6, GCC7, MSVC2017 (_MSC_VER >= 1914)  or higher.\"\n       OFF)\noption(FLATBUFFERS_BUILD_LEGACY\n       \"Run C++ code generator with '--cpp-std c++0x' switch.\"\n       OFF)\noption(FLATBUFFERS_ENABLE_PCH\n       \"Enable precompile headers support for 'flatbuffers' and 'flatc'. \\\"\n        Only work if CMake supports 'target_precompile_headers'. \\\"\n        This can speed up compilation time.\"\n       OFF)\noption(FLATBUFFERS_SKIP_MONSTER_EXTRA\n      \"Skip generating monster_extra.fbs that contains non-supported numerical\\\"\n      types.\" OFF)\noption(FLATBUFFERS_STRICT_MODE\n      \"Build flatbuffers with all warnings as errors (-Werror or /WX).\"\n      OFF)\n```\n\n----------------------------------------\n\nTITLE: Accessing Union Fields in C\nDESCRIPTION: Demonstrates union access in C using namespace-qualified functions. Shows type checking and accessing weapon properties without explicit casting.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_176\n\nLANGUAGE: C\nCODE:\n```\n// Access union type field.\nif (ns(Monster_equipped_type(monster)) == ns(Equipment_Weapon)) {\n    // Cast to appropriate type:\n    // C allows for silent void pointer assignment, so we need no \n    // explicit cast.\n    ns(Weapon_table_t) weapon = ns(Monster_equipped(monster));\n    const char *weapon_name = ns(Weapon_name(weapon)); // \"Axe\"\n    uint16_t weapon_damage = ns(Weapon_damage(weapon)); // 5\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Scalars in C\nDESCRIPTION: Creates a vector of scalar values (inventory) using flatbuffers_uint8_vec_create function.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_53\n\nLANGUAGE: c\nCODE:\n```\n// Create a `vector` representing the inventory of the Orc. Each number\n// could correspond to an item that can be claimed after he is slain.\nuint8_t treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nflatbuffers_uint8_vec_ref_t inventory;\n// `c_vec_len` is the convenience macro we defined earlier.\ninventory = flatbuffers_uint8_vec_create(B, treasure, c_vec_len(treasure));\n```\n\n----------------------------------------\n\nTITLE: Converting FlatBuffer Schema and JSON to Binary Format using flatc\nDESCRIPTION: Command line example showing how to use the FlatBuffers compiler (flatc) to convert JSON data to a binary FlatBuffer file according to a schema. This enables shipping efficient binary data while working with text formats.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/cpp.md#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nflatc -b myschema.fbs mydata.json\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (Lobster)\nDESCRIPTION: Code to access specific fields from a Monster table in Lobster. Lobster provides property-like accessors for the fields.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_123\n\nLANGUAGE: Lobster\nCODE:\n```\nlet hp = monster.hp\nlet mana = monster.mana\nlet name = monster.name\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (Rust)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in Rust. Uses the root_as_monster function with a &[u8] buffer slice.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_112\n\nLANGUAGE: Rust\nCODE:\n```\nlet buf = /* the data you just read, in a &[u8] */\n\n// Get an accessor to the root object inside the buffer.\nlet monster = root_as_monster(buf).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Forward Declaration of Types in FlatBuffers\nDESCRIPTION: Example of forward declarations in FlatBuffers-generated code, which allows for circular references between types while preventing circular references between objects.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstruct Vec3;\nstruct Monster;\n```\n\n----------------------------------------\n\nTITLE: Handling Build Configuration Dependencies in FlatBuffers\nDESCRIPTION: Checks for dependencies between build options, such as requiring compiler to be built when tests are enabled. Also allows setting the maximum parsing depth and detects locale-independent functions.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT FLATBUFFERS_BUILD_FLATC AND FLATBUFFERS_BUILD_TESTS)\n    message(WARNING\n    \"Cannot build tests without building the compiler. Tests will be disabled.\")\n    set(FLATBUFFERS_BUILD_TESTS OFF)\nendif()\n\nif(DEFINED FLATBUFFERS_MAX_PARSING_DEPTH)\n  # Override the default recursion depth limit.\n  add_definitions(-DFLATBUFFERS_MAX_PARSING_DEPTH=${FLATBUFFERS_MAX_PARSING_DEPTH})\n  message(STATUS \"FLATBUFFERS_MAX_PARSING_DEPTH: ${FLATBUFFERS_MAX_PARSING_DEPTH}\")\nendif()\n\n# Auto-detect locale-narrow 'strtod_l' and  'strtoull_l' functions.\nif(NOT DEFINED FLATBUFFERS_LOCALE_INDEPENDENT)\n  include(CheckCXXSymbolExists)\n\n  set(FLATBUFFERS_LOCALE_INDEPENDENT 0)\n  if(MSVC_LIKE)\n    check_cxx_symbol_exists(_strtof_l stdlib.h FLATBUFFERS_HAS_STRTOF_L)\n    check_cxx_symbol_exists(_strtoui64_l stdlib.h FLATBUFFERS_HAS_STRTOULL_L)\n  else()\n    check_cxx_symbol_exists(strtof_l stdlib.h FLATBUFFERS_HAS_STRTOF_L)\n    check_cxx_symbol_exists(strtoull_l stdlib.h FLATBUFFERS_HAS_STRTOULL_L)\n  endif()\n  if(FLATBUFFERS_HAS_STRTOF_L AND FLATBUFFERS_HAS_STRTOULL_L)\n    set(FLATBUFFERS_LOCALE_INDEPENDENT 1)\n  endif()\nendif()\nadd_definitions(-DFLATBUFFERS_LOCALE_INDEPENDENT=$<BOOL:${FLATBUFFERS_LOCALE_INDEPENDENT}>)\n\nif(NOT WIN32)\n  check_symbol_exists(realpath \"stdlib.h\" HAVE_REALPATH)\n  if(NOT HAVE_REALPATH)\n    add_definitions(-DFLATBUFFERS_NO_ABSOLUTE_PATH_RESOLUTION)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (Kotlin)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's createString method. Returns integer offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_14\n\nLANGUAGE: Kotlin\nCODE:\n```\nval weaponOneName = builder.createString(\"Sword\")\nval weaponTwoName = builder.createString(\"Axe\")\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer Values in TypeScript\nDESCRIPTION: Shows how to access values from a monster object after reading from a FlatBuffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/typescript.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n  let hp = monster.hp();\n  let pos = monster.pos();\n```\n\n----------------------------------------\n\nTITLE: Convenience Creation Function in FlatBuffers\nDESCRIPTION: Example of a convenience function for creating a table in FlatBuffers. This function wraps the builder class to simplify object creation, automatically skipping default values to optimize the output buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\ninline flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb,\n                                                  const Vec3 *pos, int16_t mana,\n                                                  int16_t hp,\n                                                  flatbuffers::Offset<flatbuffers::String> name,\n                                                  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> inventory,\n                                                  int8_t color) {\n  MonsterBuilder builder_(_fbb);\n  builder_.add_inventory(inventory);\n  builder_.add_name(name);\n  builder_.add_pos(pos);\n  builder_.add_hp(hp);\n  builder_.add_mana(mana);\n  builder_.add_color(color);\n  return builder_.Finish();\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (Kotlin)\nDESCRIPTION: Code to access specific fields from a Monster table in Kotlin. Kotlin provides property-like accessors for the fields.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_122\n\nLANGUAGE: Kotlin\nCODE:\n```\nval hp = monster.hp\nval mana = monster.mana\nval name = monster.name\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (Go)\nDESCRIPTION: Code to access specific fields from a Monster table in Go. Note that string fields like Name() return a byte array that needs to be converted to string.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_119\n\nLANGUAGE: Go\nCODE:\n```\nhp := monster.Hp()\nmana := monster.Mana()\nname := string(monster.Name()) // Note: `monster.Name()` returns a byte[].\n```\n\n----------------------------------------\n\nTITLE: FlatBuffers Schema Compilation Function\nDESCRIPTION: Defines a CMake function to compile FlatBuffer schema files into generated headers using the flatc compiler. Takes source file path, options, and output variable as parameters.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_21\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(compile_schema SRC_FBS OPT OUT_GEN_FILE) \n  get_filename_component(SRC_FBS_DIR ${SRC_FBS} PATH)\n  string(REGEX REPLACE \"\\\\.fbs$\" \"_generated.h\" GEN_HEADER ${SRC_FBS})\n  add_custom_command(\n    OUTPUT ${GEN_HEADER}\n    COMMAND \"${FLATBUFFERS_FLATC_EXECUTABLE}\"\n      ${OPT}\n      -o \"${SRC_FBS_DIR}\"\n      \"${CMAKE_CURRENT_SOURCE_DIR}/${SRC_FBS}\"\n    DEPENDS flatc ${SRC_FBS}\n    COMMENT \"flatc generation: `${SRC_FBS}` -> `${GEN_HEADER}`\"\n    )\n  set(${OUT_GEN_FILE} ${GEN_HEADER} PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (Lua)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's CreateString method. Returns offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_16\n\nLANGUAGE: Lua\nCODE:\n```\nlocal weaponOne = builder:CreateString(\"Sword\")\nlocal weaponTwo = builder:CreateString(\"Axe\")\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (JavaScript)\nDESCRIPTION: Code to access specific fields from a Monster table in JavaScript. Uses accessor methods that return appropriate JavaScript types for each field.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_121\n\nLANGUAGE: JavaScript\nCODE:\n```\nvar hp = monster.hp();\nvar mana = monster.mana();\nvar name = monster.name();\n```\n\n----------------------------------------\n\nTITLE: Table Definition in FlatBuffers\nDESCRIPTION: Example of a table definition in FlatBuffers. Tables are variable-sized objects that use vtables for field access and support schema evolution through default values for missing fields.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nstruct Monster : private flatbuffers::Table {\n  const Vec3 *pos() const { return GetStruct<const Vec3 *>(4); }\n  int16_t mana() const { return GetField<int16_t>(6, 150); }\n  int16_t hp() const { return GetField<int16_t>(8, 100); }\n  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(10); }\n  const flatbuffers::Vector<uint8_t> *inventory() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(14); }\n  int8_t color() const { return GetField<int8_t>(16, 2); }\n};\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (Python)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's CreateString method. Returns offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_18\n\nLANGUAGE: Python\nCODE:\n```\nweapon_one = builder.CreateString('Sword')\nweapon_two = builder.CreateString('Axe')\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (PHP)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in PHP. Uses Google\\FlatBuffers\\ByteBuffer to wrap the string data before passing to the generated accessor method.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_110\n\nLANGUAGE: PHP\nCODE:\n```\n$bytes = /* the data you just read, in a string */\n$buf = Google\\FlatBuffers\\ByteBuffer::wrap($bytes);\n\n// Get an accessor to the root object inside the buffer.\n$monster = \\MyGame\\Sample\\Monster::GetRootAsMonster($buf);\n```\n\n----------------------------------------\n\nTITLE: Building FlatBuffers Compiler (flatc)\nDESCRIPTION: Creates the flatc compiler executable target when FLATBUFFERS_BUILD_FLATC is enabled. Configures build options, sanitizer support, and static linking options.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_18\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_BUILD_FLATC)\n  add_executable(flatc ${FlatBuffers_Compiler_SRCS})\n  if(FLATBUFFERS_ENABLE_PCH)\n    add_pch_to_target(flatc include/flatbuffers/pch/flatc_pch.h)\n  endif()\n\n  target_link_libraries(flatc PRIVATE $<BUILD_INTERFACE:ProjectConfig>)\n  target_compile_options(flatc\n    PRIVATE\n      $<$<AND:$<BOOL:${MSVC_LIKE}>,$<CONFIG:Release>>:\n        /MT\n      >\n  )\n\n  if(FLATBUFFERS_CODE_SANITIZE AND NOT WIN32)\n    add_fsanitize_to_target(flatc ${FLATBUFFERS_CODE_SANITIZE})\n  endif()\n  if(NOT FLATBUFFERS_FLATC_EXECUTABLE)\n    set(FLATBUFFERS_FLATC_EXECUTABLE $<TARGET_FILE:flatc>)\n  endif()\n  if(FLATBUFFERS_STATIC_FLATC AND NOT MSVC)\n    target_link_libraries(flatc PRIVATE -static)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Properly Adding a New Union Variant in FlatBuffers\nDESCRIPTION: A correctly evolved union schema that adds a new variant at the end, maintaining compatibility with older data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_10\n\nLANGUAGE: c++\nCODE:\n```\nunion U {\n  A,\n  B,\n  another_a: A\n}\n```\n\n----------------------------------------\n\nTITLE: Building FlatBuffers Shared Library\nDESCRIPTION: Creates a shared version of the flatbuffers library when FLATBUFFERS_BUILD_SHAREDLIB is enabled. Sets library version properties and configures precompiled headers.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_20\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_BUILD_SHAREDLIB)\n  add_library(flatbuffers_shared SHARED ${FlatBuffers_Library_SRCS})\n  target_link_libraries(flatbuffers_shared PRIVATE $<BUILD_INTERFACE:ProjectConfig>)\n  # FlatBuffers use calendar-based versioning and do not provide any ABI\n  # stability guarantees. Therefore, always use the full version as SOVERSION\n  # in order to avoid breaking reverse dependencies on upgrades.\n  set(FlatBuffers_Library_SONAME_FULL \"${PROJECT_VERSION}\")\n  set_target_properties(flatbuffers_shared PROPERTIES\n                        OUTPUT_NAME flatbuffers\n                        SOVERSION \"${FlatBuffers_Library_SONAME_FULL}\"\n                        VERSION \"${FlatBuffers_Library_SONAME_FULL}\")\n  if(FLATBUFFERS_ENABLE_PCH)\n    add_pch_to_target(flatbuffers_shared include/flatbuffers/pch/pch.h)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in C\nDESCRIPTION: Allocates and extracts a readable buffer from the internal builder heap in C.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_86\n\nLANGUAGE: c\nCODE:\n```\nuint8_t *buf;\nsize_t size;\n\nbuf = flatcc_builder_finalize_buffer(B, &size);\n// use buf\nfree(buf);\n\nflatcc_builder_reset(B);\n\nflatcc_builder_clear(B);\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Scalars and Structs in Go\nDESCRIPTION: Demonstrates serializing a vector of scalar values (inventory) and a vector of structs (path) using MonsterStartInventoryVector, PrependByte, and CreateVec3 methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_56\n\nLANGUAGE: go\nCODE:\n```\n// Create a `vector` representing the inventory of the Orc. Each number\n// could correspond to an item that can be claimed after he is slain.\n// Note: Since we prepend the bytes, this loop iterates in reverse.\nsample.MonsterStartInventoryVector(builder, 10)\nfor i := 9; i >= 0; i-- {\n        builder.PrependByte(byte(i))\n}\ninv := builder.EndVector(10)\n\nsample.MonsterStartPathVector(builder, 2)\nsample.CreateVec3(builder, 1.0, 2.0, 3.0)\nsample.CreateVec3(builder, 4.0, 5.0, 6.0)\npath := builder.EndVector(2)\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in Dart\nDESCRIPTION: Demonstrates two approaches: using Builder classes to write a list directly, or creating an array of WeaponBuilder objects for ObjectBuilders.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_40\n\nLANGUAGE: dart\nCODE:\n```\n// If using the Builder classes, serialize the `[sword,axe]`\nfinal weapons = builder.writeList([sword, axe]);\n\n// If using the ObjectBuilders, just create an array from the two `Weapon`s\nfinal List<myGame.WeaponBuilder> weaps = [sword, axe];\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (Java)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's createString method. Returns integer offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_12\n\nLANGUAGE: Java\nCODE:\n```\nint weaponOneName = builder.createString(\"Sword\")\nint weaponTwoName = builder.createString(\"Axe\");\n```\n\n----------------------------------------\n\nTITLE: Serializing Union Fields in FlatBuffers with Python\nDESCRIPTION: This Python code demonstrates creating a Monster with a union field in FlatBuffers. It uses Start/End pattern and shows how to properly set the union type and union value fields.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_79\n\nLANGUAGE: Python\nCODE:\n```\n# Serialize a name for our monster, called \"Orc\".\nname = builder.CreateString(\"Orc\")\n\n# Create our monster by using `Monster.Start()` and `Monster.End()`.\nMyGame.Sample.Monster.Start(builder)\nMyGame.Sample.Monster.AddPos(builder,\n    MyGame.Sample.Vec3.CreateVec3(builder, 1.0, 2.0, 3.0))\nMyGame.Sample.Monster.AddHp(builder, 300)\nMyGame.Sample.Monster.AddName(builder, name)\nMyGame.Sample.Monster.AddInventory(builder, inv)\nMyGame.Sample.Monster.AddColor(builder,\n                                        MyGame.Sample.Color.Color().Red)\nMyGame.Sample.Monster.AddWeapons(builder, weapons)\nMyGame.Sample.Monster.AddEquippedType(\n    builder, MyGame.Sample.Equipment.Equipment().Weapon)\nMyGame.Sample.Monster.AddEquipped(builder, axe)\nMyGame.Sample.Monster.AddPath(builder, path)\norc = MyGame.Sample.Monster.End(builder)\n```\n\n----------------------------------------\n\nTITLE: Building Static FlatBuffers Library\nDESCRIPTION: Creates the static flatbuffers library target when FLATBUFFERS_BUILD_FLATLIB is enabled. Configures include directories and links with project configuration. Optionally enables precompiled headers.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_BUILD_FLATLIB)\n  add_library(flatbuffers STATIC ${FlatBuffers_Library_SRCS})\n\n  # Attach header directory for when build via add_subdirectory().\n  target_include_directories(flatbuffers\n    INTERFACE\n      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n  )\n  target_link_libraries(flatbuffers PRIVATE $<BUILD_INTERFACE:ProjectConfig>)\n\n  if(FLATBUFFERS_ENABLE_PCH)\n    add_pch_to_target(flatbuffers include/flatbuffers/pch/pch.h)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Checking Schema Evolution Conformity with flatc\nDESCRIPTION: A command-line example showing how to use the FlatBuffers compiler to verify that a schema has been properly evolved from a base schema.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\nflatc --conform schema_v1.fbs schema_v2.fbs\n```\n\n----------------------------------------\n\nTITLE: Installing FlatBuffers Shared Library in CMake\nDESCRIPTION: Configures the installation of the FlatBuffers shared library, including targets, export files, and destination paths for different components.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_28\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_BUILD_SHAREDLIB)\n  install(\n    TARGETS flatbuffers_shared EXPORT FlatBuffersSharedTargets\n    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    RUNTIME DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n  )\n\n  install(\n    EXPORT FlatBuffersSharedTargets\n    FILE FlatBuffersSharedTargets.cmake\n    NAMESPACE flatbuffers::\n    DESTINATION ${FB_CMAKE_DIR}\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Vectors in Lua using FlatBuffers\nDESCRIPTION: Creates inventory and path vectors in FlatBuffers using Lua. The inventory vector is created by prepending bytes in reverse order, while the path vector contains Vec3 objects with 3D coordinates.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_62\n\nLANGUAGE: lua\nCODE:\n```\nmonster.StartInventoryVector(builder, 10)\nfor i=10,1,-1 do\n    builder:PrependByte(i)\nend\nlocal inv = builder:EndVector(10)\n\nmonster.StartPathVector(builder, 2)\nvec3.CreateVec3(builder, 1.0, 2.0, 3.0)\nvec3.CreateVec3(builder, 4.0, 5.0, 6.0)\nlocal path = builder:EndVector(2)\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with C#\nDESCRIPTION: Shows how to access elements of an inventory vector in a Monster object using C#. The code gets the vector length and accesses the third element.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_147\n\nLANGUAGE: C#\nCODE:\n```\nint invLength = monster.InventoryLength;\nvar thirdItem = monster.Inventory(2);\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in Lobster\nDESCRIPTION: Uses the MyGame_Sample_MonsterCreateWeaponsVector method to create a FlatBuffer vector from an array of weapon offsets.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_45\n\nLANGUAGE: lobster\nCODE:\n```\nlet weapons = builder.MyGame_Sample_MonsterCreateWeaponsVector([sword, axe])\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (Dart)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's writeString method. Returns integer offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_10\n\nLANGUAGE: Dart\nCODE:\n```\nfinal int weaponOneName = builder.writeString(\"Sword\");\nfinal int weaponTwoName = builder.writeString(\"Axe\");\n```\n\n----------------------------------------\n\nTITLE: Alternative Union Addition Methods in FlatBuffers C\nDESCRIPTION: Shows different approaches to adding unions to a FlatBuffer object in C, including direct union reference, type-specific addition, and low-level type/member addition.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/c.md#2025-04-16_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nns(Equipment_union_ref_t) equipped = ns(Equipment_as_Weapon(axe));\nns(Monster_equipped_add(B, equipped));\n// or alternatively\nns(Monster_equipped_Weapon_add(B, axe);\n// or alternatively\nns(Monster_equipped_add_type(B, ns(Equipment_Weapon));\nns(Monster_equipped_add_member(B, axe));\n```\n\n----------------------------------------\n\nTITLE: Defining Field Declaration in EBNF\nDESCRIPTION: EBNF grammar for field declaration in FlatBuffers schema. Shows the syntax for defining a field with name, type, optional default value, and metadata.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_3\n\nLANGUAGE: ebnf\nCODE:\n```\nfield_decl = ident `:` type [ `=` scalar ] metadata `;`\n```\n\n----------------------------------------\n\nTITLE: Installing FlatBuffers Compiler (flatc) in CMake\nDESCRIPTION: Sets up the installation of the FlatBuffers compiler (flatc), including the executable and export targets.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_27\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_BUILD_FLATC)\n  install(\n    TARGETS flatc EXPORT FlatcTargets\n    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n  )\n\n  install(\n    EXPORT FlatcTargets\n    FILE FlatcTargets.cmake\n    NAMESPACE flatbuffers::\n    DESTINATION ${FB_CMAKE_DIR}\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Compiling FlatBuffers Schema on Unix Systems\nDESCRIPTION: Shell commands for building the FlatBuffers compiler (flatc) on Unix systems using CMAKE and make.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncmake -G \"Unix Makefiles\"\nmake flatc\n```\n\n----------------------------------------\n\nTITLE: Generating Language-Specific Code with FlatC\nDESCRIPTION: Example command showing how to use the FlatC compiler to generate C++ and Rust code from a FlatBuffer schema file.\nSOURCE: https://github.com/google/flatbuffers/blob/master/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./flatc --cpp --rust monster.fbs\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in Rust\nDESCRIPTION: Creates a FlatBuffer vector containing offsets to previously created Weapon tables using the create_vector method.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_49\n\nLANGUAGE: rust\nCODE:\n```\n// Create a FlatBuffer `vector` that contains offsets to the sword and axe\n// we created above.\nlet weapons = builder.create_vector(&[sword, axe]);\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (C#)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's CreateString method. Returns Offset<String> objects that provide typed offsets to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nOffset<String> weaponOneName = builder.CreateString(\"Sword\");\nOffset<String> weaponTwoName = builder.CreateString(\"Axe\");\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct in FlatBuffers Schema\nDESCRIPTION: Example of defining a struct in FlatBuffers schema. Structs are used for simple objects where fields are required and no changes are expected. They are more memory-efficient than tables.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct Vec3 {\n  x:float;\n  y:float;\n  z:float;\n}\n```\n\n----------------------------------------\n\nTITLE: Building FlatBuffers gRPC Test\nDESCRIPTION: Sets up gRPC test target when FLATBUFFERS_BUILD_GRPCTEST is enabled. Configures include paths, finds required dependencies (threads, abseil, protobuf, gRPC), and links them to the test executable.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_24\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_BUILD_GRPCTEST)\n  if(NOT GRPC_INSTALL_PATH)\n    message(SEND_ERROR \"GRPC_INSTALL_PATH variable is not defined. See grpc/README.md\")\n  endif()\n  if(NOT PROTOBUF_DOWNLOAD_PATH)\n    message(SEND_ERROR \"PROTOBUF_DOWNLOAD_PATH variable is not defined. See grpc/README.md\")\n  endif()\n  INCLUDE_DIRECTORIES(${GRPC_INSTALL_PATH}/include)\n  INCLUDE_DIRECTORIES(${PROTOBUF_DOWNLOAD_PATH}/src)\n  find_package(Threads REQUIRED)\n  list(APPEND CMAKE_PREFIX_PATH ${GRPC_INSTALL_PATH})\n  find_package(absl CONFIG REQUIRED)\n  find_package(protobuf CONFIG REQUIRED)\n  find_package(gRPC CONFIG REQUIRED)\n  add_executable(grpctest ${FlatBuffers_GRPCTest_SRCS})\n  target_link_libraries(grpctest\n    PRIVATE\n      $<BUILD_INTERFACE:ProjectConfig>\n      gRPC::grpc++_unsecure\n      gRPC::gpr\n      pthread\n      dl\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding FlatBuffers Interface Library in CMake\nDESCRIPTION: Creates an interface library for FlatBuffers and sets up include directories for build and install interfaces.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_32\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(FlatBuffers INTERFACE)\nadd_library(FlatBuffers::FlatBuffers ALIAS FlatBuffers)\ntarget_include_directories(\n  FlatBuffers\n  INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n            $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/include>)\n```\n\n----------------------------------------\n\nTITLE: Root Table Access Function in FlatBuffers\nDESCRIPTION: Root access function for retrieving the top-level object from a FlatBuffer. This function is only generated for the root table type and allows traversing a FlatBuffer from a raw buffer pointer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\ninline const Monster *GetMonster(const void *buf) { return flatbuffers::GetRoot<Monster>(buf); }\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (C)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in C. Note the use of table_t suffix for reading tables as opposed to ref_t used during construction.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_101\n\nLANGUAGE: C\nCODE:\n```\n// Note that we use the `table_t` suffix when reading a table object\n// as opposed to the `ref_t` suffix used during the construction of\n// the buffer.\nns(Monster_table_t) monster = ns(Monster_as_root(buffer));\n\n// Note: root object pointers are NOT the same as the `buffer` pointer.\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Scalars and Structs in Dart\nDESCRIPTION: Shows how to serialize a vector of scalar values (inventory) using writeListUint8 and a vector of structs (path) using a Vec3Builder.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_55\n\nLANGUAGE: dart\nCODE:\n```\n// Create a list representing the inventory of the Orc. Each number\n// could correspond to an item that can be claimed after he is slain.\nfinal List<int> treasure = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nfinal inventory = builder.writeListUint8(treasure);\n\n// Using the Builder classes, you can write a list of structs like so:\n// Note that the intended order should be reversed if order is important.\nfinal vec3Builder = new myGame.Vec3Builder(builder);\nvec3Builder.finish(4.0, 5.0, 6.0);\nvec3Builder.finish(1.0, 2.0, 3.0);\nfinal int path = builder.endStructVector(2); // the length of the vector\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (C)\nDESCRIPTION: Creates string references in FlatBuffers using the flatbuffers_string_create_str function. Returns string reference objects that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nflatbuffers_string_ref_t weapon_one_name \n    = flatbuffers_string_create_str(B, \"Sword\");\nflatbuffers_string_ref_t weapon_two_name \n    = flatbuffers_string_create_str(B, \"Axe\");\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Tables in C\nDESCRIPTION: Uses the internal builder stack to implement a dynamic vector for Weapon tables. Pushes individual weapon offsets onto the stack and finalizes the vector.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_38\n\nLANGUAGE: c\nCODE:\n```\n// We use the internal builder stack to implement a dynamic vector.\nns(Weapon_vec_start(B));\nns(Weapon_vec_push(B, sword));\nns(Weapon_vec_push(B, axe));\nns(Weapon_vec_ref_t) weapons = ns(Weapon_vec_end(B));\n```\n\n----------------------------------------\n\nTITLE: Adding Precompiled Headers to Targets in FlatBuffers CMake Build\nDESCRIPTION: Defines a function to add precompiled headers to build targets when using CMake 3.16 or newer. For non-MSVC compilers, it excludes src/util.cpp from precompiled header processing.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(add_pch_to_target _target _pch_header)\n  # the command is available since cmake 3.16\n  if(COMMAND target_precompile_headers)\n    target_precompile_headers(${_target} PRIVATE ${_pch_header})\n    if(NOT MSVC)\n      set_source_files_properties(src/util.cpp PROPERTIES SKIP_PRECOMPILE_HEADERS ON)\n    endif()\n  endif()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Scalars in Lua\nDESCRIPTION: Partial snippet showing the start of serializing a vector of scalar values (inventory) in Lua.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_61\n\nLANGUAGE: lua\nCODE:\n```\n-- Create a `vector` representing the inventory of the Orc. Each number\n-- could correspond to an item that can be claimed after he is slain.\n```\n\n----------------------------------------\n\nTITLE: Building FlatBuffers Tests\nDESCRIPTION: Sets up test targets, including flattest executable, when FLATBUFFERS_BUILD_TESTS is enabled. Configures include directories, generates schema files for tests, and sets up C++17 variant of tests when enabled.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_23\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_BUILD_TESTS)\n  add_executable(flattests ${FlatBuffers_Tests_SRCS})\n  target_link_libraries(flattests PRIVATE $<BUILD_INTERFACE:ProjectConfig>)\n  target_include_directories(flattests PUBLIC \n    # Ideally everything is fully qualified from the root directories\n    ${CMAKE_CURRENT_SOURCE_DIR}\n    ${CMAKE_CURRENT_BINARY_DIR}\n    # TODO(derekbailey): update includes to fully qualify src/ and tests/\n    src \n    tests \n    ${CMAKE_CURRENT_BINARY_DIR}/tests \n  )\n\n  # Have tests load data from the source directory, not the build directory.\n  add_definitions(-DFLATBUFFERS_TEST_PATH_PREFIX=${CMAKE_CURRENT_SOURCE_DIR}/)\n\n  # The flattest target needs some generated files\n  SET(FLATC_OPT --cpp --gen-mutable --gen-object-api --reflect-names)\n  SET(FLATC_OPT_COMP ${FLATC_OPT};--gen-compare)\n  SET(FLATC_OPT_SCOPED_ENUMS ${FLATC_OPT_COMP};--scoped-enums)\n\n  compile_schema_for_test(tests/alignment_test.fbs \"${FLATC_OPT_COMP}\")\n  compile_schema_for_test(tests/arrays_test.fbs \"${FLATC_OPT_SCOPED_ENUMS}\")\n  compile_schema_for_test(tests/native_inline_table_test.fbs \"${FLATC_OPT_COMP}\")\n  compile_schema_for_test(tests/native_type_test.fbs \"${FLATC_OPT}\")\n  compile_schema_for_test(tests/key_field/key_field_sample.fbs \"${FLATC_OPT_COMP}\")\n  compile_schema_for_test(tests/64bit/test_64bit.fbs \"${FLATC_OPT_COMP};--bfbs-gen-embed\")\n  compile_schema_for_test(tests/64bit/evolution/v1.fbs \"${FLATC_OPT_COMP}\")\n  compile_schema_for_test(tests/64bit/evolution/v2.fbs \"${FLATC_OPT_COMP}\")\n  compile_schema_for_test(tests/union_underlying_type_test.fbs \"${FLATC_OPT_SCOPED_ENUMS}\")\n\n  if(FLATBUFFERS_CODE_SANITIZE)\n    add_fsanitize_to_target(flattests ${FLATBUFFERS_CODE_SANITIZE})\n  endif()\n  \n  include_directories(${CMAKE_CURRENT_BINARY_DIR}/samples)\n\n  add_executable(flatsamplebinary ${FlatBuffers_Sample_Binary_SRCS})\n  add_executable(flatsampletext ${FlatBuffers_Sample_Text_SRCS})\n  add_executable(flatsamplebfbs ${FlatBuffers_Sample_BFBS_SRCS})\n\n  # Add a library so there is a single target that the generated samples can \n  # link too.\n  if(MSVC OR ${CMAKE_VERSION} VERSION_GREATER_EQUAL \"3.20.0\")\n    add_library(flatsample INTERFACE)\n  else()\n    add_library(flatsample STATIC)\n  endif()\n\n  # Since flatsample has no sources, we have to explicitly set the linker lang.\n  set_target_properties(flatsample PROPERTIES LINKER_LANGUAGE CXX)\n  \n  compile_schema_for_samples(samples/monster.fbs \"${FLATC_OPT_COMP}\")\n\n  target_link_libraries(flatsamplebinary PRIVATE $<BUILD_INTERFACE:ProjectConfig> flatsample)\n  target_link_libraries(flatsampletext PRIVATE $<BUILD_INTERFACE:ProjectConfig> flatsample)\n  target_link_libraries(flatsamplebfbs PRIVATE $<BUILD_INTERFACE:ProjectConfig> flatsample)\n\n  if(FLATBUFFERS_BUILD_CPP17)\n    add_executable(flattests_cpp17 ${FlatBuffers_Tests_CPP17_SRCS})\n    target_link_libraries(flattests_cpp17 PRIVATE $<BUILD_INTERFACE:ProjectConfig>)\n    target_include_directories(flattests_cpp17 PUBLIC src tests)\n    target_compile_features(flattests_cpp17 PRIVATE cxx_std_17) # requires cmake 3.8\n\n    if(FLATBUFFERS_CODE_SANITIZE)\n      add_fsanitize_to_target(flattests_cpp17 ${FLATBUFFERS_CODE_SANITIZE})\n    endif()\n  endif(FLATBUFFERS_BUILD_CPP17)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files for FlatBuffers Library\nDESCRIPTION: Defines the list of source files that comprise the core FlatBuffers library, including header files and implementation files. These files provide the fundamental functionality of the FlatBuffers serialization system.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(FlatBuffers_Library_SRCS\n  include/flatbuffers/allocator.h\n  include/flatbuffers/array.h\n  include/flatbuffers/base.h\n  include/flatbuffers/buffer.h\n  include/flatbuffers/buffer_ref.h\n  include/flatbuffers/default_allocator.h\n  include/flatbuffers/detached_buffer.h\n  include/flatbuffers/code_generator.h\n  include/flatbuffers/file_manager.h\n  include/flatbuffers/flatbuffer_builder.h\n  include/flatbuffers/flatbuffers.h\n  include/flatbuffers/flexbuffers.h\n  include/flatbuffers/flex_flat_util.h\n  include/flatbuffers/hash.h\n  include/flatbuffers/idl.h\n  include/flatbuffers/minireflect.h\n  include/flatbuffers/reflection.h\n  include/flatbuffers/reflection_generated.h\n  include/flatbuffers/registry.h\n  include/flatbuffers/stl_emulation.h\n  include/flatbuffers/string.h\n  include/flatbuffers/struct.h\n  include/flatbuffers/table.h\n  include/flatbuffers/util.h\n  include/flatbuffers/vector.h\n  include/flatbuffers/vector_downward.h\n  include/flatbuffers/verifier.h\n  src/idl_parser.cpp\n  src/idl_gen_text.cpp\n  src/reflection.cpp\n  src/util.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Python Type Annotations (Python)\nDESCRIPTION: Demonstration of using --python-typing to generate type annotations in the Python code output.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flatc.md#2025-04-16_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n--python-typing\n```\n\n----------------------------------------\n\nTITLE: Serializing Vector of Scalars and Structs in Kotlin\nDESCRIPTION: Shows how to serialize a vector of scalar values (inventory) using createInventoryVector and a vector of structs (path) using createVec3 method.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_59\n\nLANGUAGE: kotlin\nCODE:\n```\n// Create a `vector` representing the inventory of the Orc. Each number\n// could correspond to an item that can be claimed after he is slain.\nval treasure = byteArrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\nval inv = Monster.createInventoryVector(builder, treasure)\n\nMonster.startPathVector(fbb, 2)\nVec3.createVec3(builder, 1.0f, 2.0f, 3.0f)\nVec3.createVec3(builder, 4.0f, 5.0f, 6.0f)\nval path = fbb.endVector()\n```\n\n----------------------------------------\n\nTITLE: Installing FlatBuffers Libraries and Headers\nDESCRIPTION: Configures installation of FlatBuffers headers and CMake configuration files when FLATBUFFERS_INSTALL is enabled. Uses GNUInstallDirs for standard installation paths.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_25\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_INSTALL)\n  include(GNUInstallDirs)\n\n  install(DIRECTORY include/flatbuffers DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\n  set(FB_CMAKE_DIR \"${CMAKE_INSTALL_LIBDIR}/cmake/flatbuffers\")\n\n  configure_file(CMake/flatbuffers-config-version.cmake.in flatbuffers-config-version.cmake @ONLY)\n  install(\n      FILES\n        \"CMake/flatbuffers-config.cmake\"\n        \"CMake/BuildFlatBuffers.cmake\"\n        \"${CMAKE_CURRENT_BINARY_DIR}/flatbuffers-config-version.cmake\"\n\n```\n\n----------------------------------------\n\nTITLE: Creating Vectors in PHP using FlatBuffers\nDESCRIPTION: Implements vector creation for monster inventory and path using PHP FlatBuffers. Creates an inventory array of treasures and a path vector containing Vec3 coordinates.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_63\n\nLANGUAGE: php\nCODE:\n```\n$treasure = array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n$inv = \\MyGame\\Sample\\Monster::CreateInventoryVector($builder, $treasure);\n\n\\MyGame\\Example\\Monster::StartPathVector($builder, 2);\n\\MyGame\\Sample\\Vec3::CreateVec3($builder, 1.0, 2.0, 3.0);\n\\MyGame\\Sample\\Vec3::CreateVec3($builder, 1.0, 2.0, 3.0);\n$path = $builder->endVector();\n```\n\n----------------------------------------\n\nTITLE: Building FlatHash Utility\nDESCRIPTION: Creates the flathash executable target when FLATBUFFERS_BUILD_FLATHASH is enabled. Links with the project configuration.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_19\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_BUILD_FLATHASH)\n  add_executable(flathash ${FlatHash_SRCS})\n  target_link_libraries(flathash PRIVATE $<BUILD_INTERFACE:ProjectConfig>)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing FlatBuffers via CocoaPods\nDESCRIPTION: Pod declaration for adding FlatBuffers to an iOS/macOS project using CocoaPods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/swift/README.md#2025-04-16_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\npod 'FlatBuffers'\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version and Project Configuration for FlatBuffers\nDESCRIPTION: Sets the minimum required CMake version and configures the FlatBuffers project with version information pulled from external file. Enables generation of compile_commands.json.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# This is the legacy minimum version flatbuffers supported for a while.\ncmake_minimum_required(VERSION 3.8...3.25.2)\n\n# Attempt to read the current version of flatbuffers by looking at the latest tag.\ninclude(CMake/Version.cmake)\n\nproject(FlatBuffers\n        VERSION ${VERSION_MAJOR}.${VERSION_MINOR}.${VERSION_PATCH}\n        LANGUAGES CXX)\n\n# generate compile_commands.json\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n```\n\n----------------------------------------\n\nTITLE: Adding Sanitizers to Targets in FlatBuffers CMake Build\nDESCRIPTION: Defines a function to add sanitization options to build targets. On Windows, it adds memory leak tracking, while on Unix systems with Clang or newer GCC, it adds address and undefined behavior sanitizers with appropriate compiler and linker flags.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(add_fsanitize_to_target _target _sanitizer)\n  if(WIN32)\n    target_compile_definitions(${_target} PRIVATE FLATBUFFERS_MEMORY_LEAK_TRACKING)\n    message(STATUS \"Sanitizer MSVC::_CrtDumpMemoryLeaks added to ${_target}\")\n  else()\n    # FLATBUFFERS_CODE_SANITIZE: boolean {ON,OFF,YES,NO} or string with list of sanitizer.\n    # List of sanitizer is string starts with '=': \"=address,undefined,thread,memory\".\n    if(IS_CLANG OR (CMAKE_COMPILER_IS_GNUCXX AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 4.9))\n      set(_sanitizer_flags \"=address,undefined\")\n      if(_sanitizer MATCHES \"=.*\")\n        # override default by user-defined sanitizer list\n        set(_sanitizer_flags ${_sanitizer})\n      endif()\n      target_compile_options(${_target} PRIVATE\n        -g -fsigned-char -fno-omit-frame-pointer\n        \"-fsanitize${_sanitizer_flags}\")\n      target_link_libraries(${_target} PRIVATE\n        \"-fsanitize${_sanitizer_flags}\")\n      set_target_properties(${_target} PROPERTIES POSITION_INDEPENDENT_CODE ON)\n      message(STATUS \"Sanitizer ${_sanitizer_flags} added to ${_target}\")\n    endif()\n  endif()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Generated C++ Header Structure for FlatBuffers Schema\nDESCRIPTION: The basic structure of a C++ header file generated from a FlatBuffers schema (monster.fbs), showing the namespace, includes, and overall organization.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// automatically generated, do not modify\n\n#include \"flatbuffers/flatbuffers.h\"\n\nnamespace MyGame {\nnamespace Sample {\n\n```\n\n----------------------------------------\n\nTITLE: Creating Vectors in TypeScript using FlatBuffers\nDESCRIPTION: Implements vector creation in TypeScript FlatBuffers by creating an inventory array and a path vector containing Vec3 objects with 3D coordinates.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_67\n\nLANGUAGE: typescript\nCODE:\n```\nlet treasure = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet inv = MyGame.Sample.Monster.createInventoryVector(builder, treasure);\n\nMyGame.Sample.Monster.startPathVector(builder, 2);\nMyGame.Sample.Vec3.createVec3(builder, 1.0, 2.0, 3.0);\nMyGame.Sample.Vec3.createVec3(builder, 4.0, 5.0, 6.0);\nlet path = builder.endVector();\n```\n\n----------------------------------------\n\nTITLE: Setting Up Include Directories for FlatBuffers Project\nDESCRIPTION: Adds the 'include' and 'grpc' directories to the list of include directories for the build, making headers from these directories available to all targets in the project.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\ninclude_directories(include)\ninclude_directories(grpc)\n```\n\n----------------------------------------\n\nTITLE: Reading a FlatBuffer binary file in Swift\nDESCRIPTION: This snippet demonstrates how to import the FlatBuffers library, define type aliases for generated structures, and read a FlatBuffer binary file into memory. It shows the process of loading FlatBuffer data and accessing the root object.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/swift.md#2025-04-16_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport FlatBuffers\n\ntypealias Monster1 = MyGame.Sample.Monster\ntypealias Vec3 = MyGame.Sample.Vec3\n\nlet path = FileManager.default.currentDirectoryPath\nlet url = URL(fileURLWithPath: path, isDirectory: true).appendingPathComponent(\"monsterdata_test\").appendingPathExtension(\"mon\")\nguard let data = try? Data(contentsOf: url) else { return }\n\nlet monster: Monster = try! getCheckedRoot(byteBuffer: &byteBuffer)\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files for C++17 Tests and Sample Applications\nDESCRIPTION: Lists source files for C++17-specific tests and sample applications that demonstrate FlatBuffers functionality, including binary, text, and BFBS sample applications.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nset(FlatBuffers_Tests_CPP17_SRCS\n  ${FlatBuffers_Library_SRCS}\n  tests/test_assert.h\n  tests/test_assert.cpp\n  tests/cpp17/test_cpp17.cpp\n)\n\nset(FlatBuffers_Sample_Binary_SRCS\n  samples/sample_binary.cpp\n)\n\nset(FlatBuffers_Sample_Text_SRCS\n  ${FlatBuffers_Library_SRCS}\n  samples/sample_text.cpp\n)\n\nset(FlatBuffers_Sample_BFBS_SRCS\n  ${FlatBuffers_Library_SRCS}\n  samples/sample_bfbs.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Options for GCC/Clang in FlatBuffers\nDESCRIPTION: Sets compiler options for GCC and Clang compilers, including various warning flags and version-specific compiler options. Includes conditionals for strict mode and code coverage configurations.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\nelse()\n  target_compile_options(ProjectConfig\n    INTERFACE\n      -Wall\n      $<$<BOOL:${FLATBUFFERS_STRICT_MODE}>:\n        -Werror   # Treat all compiler warnings as errors\n\n        -fno-rtti # Disable runtime type information\n\n        $<$<CXX_COMPILER_ID:GNU>:\n          # False positive string overflow\n          # https://github.com/google/flatbuffers/issues/7366\n          -Wno-error=stringop-overflow\n        >\n      >\n      -pedantic\n      -Wextra\n      -Wno-unused-parameter\n      -Wold-style-cast\n      -fsigned-char\n      -Wnon-virtual-dtor\n\n      # This isn't working for some reason: $<$<CXX_COMPILER_ID:CLANG>:\n      $<$<BOOL:${IS_CLANG}>:\n        -Wnewline-eof\n        -Wno-unknown-warning-option\n        -Wmissing-declarations\n        -Wzero-as-null-pointer-constant\n        $<$<VERSION_GREATER:$<CXX_COMPILER_VERSION>,3.8>:\n          -Wimplicit-fallthrough\n          -Wextra-semi\n          $<$<BOOL:${FLATBUFFERS_STRICT_MODE}>:\n            -Werror=unused-private-field\n          >\n        >\n      >\n\n      $<$<CXX_COMPILER_ID:GNU>:\n        $<$<VERSION_GREATER:$<CXX_COMPILER_VERSION>,4.4>:\n          -Wunused-result\n          -Wunused-parameter\n          -Werror=unused-parameter\n          -Wmissing-declarations\n        >\n        $<$<VERSION_GREATER:$<CXX_COMPILER_VERSION>,4.7>:\n          -Wzero-as-null-pointer-constant\n        >\n        $<$<VERSION_GREATER:$<CXX_COMPILER_VERSION>,7.0>:\n          -faligned-new\n          $<$<BOOL:${FLATBUFFERS_STRICT_MODE}>:\n            -Werror=implicit-fallthrough=2\n          >\n        >\n        $<$<VERSION_GREATER:$<CXX_COMPILER_VERSION>,8.0>:\n          -Wextra-semi\n        >\n      >\n\n      $<$<BOOL:${FLATBUFFERS_CODE_COVERAGE}>:\n        -g\n        -fprofile-arcs\n        -ftest-coverage\n      >\n    )\n\n  if(FLATBUFFERS_CODE_COVERAGE)\n    target_link_options(ProjectConfig\n      INTERFACE\n        -fprofile-arcs\n        -ftest-coverage\n    )\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Union in FlatBuffers\nDESCRIPTION: A simple FlatBuffers schema definition with a union containing two members, which serves as the base for union evolution examples.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_9\n\nLANGUAGE: c++\nCODE:\n```\nunion U {\n  A,\n  B\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in C++\nDESCRIPTION: C++ code snippet showing how to get a pointer to the serialized FlatBuffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/quick_start.md#2025-04-16_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n// Get a pointer to the flatbuffer.\nconst uint8_t* flatbuffer = builder.GetBufferPointer();\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for Android FlatBuffers Project\nDESCRIPTION: This CMake configuration sets up the build environment for an Android project using FlatBuffers. It defines a shared library named 'native-lib', includes FlatBuffers headers, adds the FlatBuffers subdirectory, and links against the required libraries including the Android log library.\nSOURCE: https://github.com/google/flatbuffers/blob/master/android/app/src/main/cpp/CMakeLists.txt#2025-04-16_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.4.1)\n\ninclude_directories(${FLATBUFFERS_SRC}/include)\n\nadd_subdirectory(flatbuffers)\n\nFILE(GLOB Generated_SRCS generated/*.h)\n\nadd_library(native-lib\n             SHARED\n             animals.cpp\n             ${Generated_SRCS})\n\nfind_library(log-lib\n              log)\n\ntarget_link_libraries(native-lib\n                       flatbuffers\n                       ${log-lib})\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in C#\nDESCRIPTION: Retrieves the serialized buffer as a ByteBuffer or byte array in C#.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_87\n\nLANGUAGE: c#\nCODE:\n```\nFlatBuffers.ByteBuffer dataBuffer = builder.DataBuffer;\n\nbyte[] buf = builder.SizedByteArray();\n```\n\n----------------------------------------\n\nTITLE: Including FlatBuffers Headers and Setting C++ Compiler Flags\nDESCRIPTION: Configures include directories for FlatBuffers headers and sets C++ compiler flags for the build. Uses GNU C++11 standard, enables exceptions, enables warnings, and adds a tracking definition.\nSOURCE: https://github.com/google/flatbuffers/blob/master/android/app/src/main/cpp/flatbuffers/CMakeLists.txt#2025-04-16_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude_directories(${FLATBUFFERS_SRC}/include)\n\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=gnu++11 -fexceptions -Wall -DFLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE\")\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files for FlatBuffers Tests\nDESCRIPTION: Lists all source files required for the FlatBuffers test suite, which includes various test cases for different FlatBuffers features like evolution, flexbuffers, JSON parsing, reflection, and more.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nset(FlatBuffers_Tests_SRCS\n  ${FlatBuffers_Library_SRCS}\n  src/idl_gen_fbs.cpp\n  tests/evolution_test.cpp\n  tests/flexbuffers_test.cpp\n  tests/fuzz_test.cpp\n  tests/json_test.cpp\n  tests/key_field_test.cpp\n  tests/monster_test.cpp\n  tests/optional_scalars_test.cpp\n  tests/parser_test.cpp\n  tests/proto_test.cpp\n  tests/reflection_test.cpp\n  tests/test.cpp\n  tests/test_assert.h\n  tests/test_assert.cpp\n  tests/test_builder.h\n  tests/test_builder.cpp\n  tests/util_test.cpp\n  tests/native_type_test_impl.h\n  tests/native_type_test_impl.cpp\n  tests/alignment_test.h\n  tests/alignment_test.cpp\n  tests/64bit/offset64_test.h\n  tests/64bit/offset64_test.cpp\n  include/flatbuffers/code_generators.h\n  src/code_generators.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Build for MacOS\nDESCRIPTION: Commands for configuring CMake build on MacOS using Xcode generator with Release build type.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/building.md#2025-04-16_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncmake -G \"Xcode\" -DCMAKE_BUILD_TYPE=Release\n```\n\n----------------------------------------\n\nTITLE: Building FlatBuffers Compiler with CMake and Make\nDESCRIPTION: Commands to build the FlatBuffers compiler (flatc) using CMake and Make.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/quick_start.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncmake -G \"Unix Makefiles\"\nmake -j\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in Go\nDESCRIPTION: Retrieves the serialized buffer as a byte slice in Go.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_89\n\nLANGUAGE: go\nCODE:\n```\nbuf := builder.FinishedBytes() // Of type `byte[]`.\n```\n\n----------------------------------------\n\nTITLE: Setting Content-Type for Go FlatBuffers GRPC Calls\nDESCRIPTION: This snippet highlights the requirement in Go to set the content-type of the payload to 'application/grpc+flatbuffers' when making GRPC calls with FlatBuffers. It provides an example of how to set the correct content subtype.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/README.md#2025-04-16_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n.SayHello(ctx, b, grpc.CallContentSubtype(\"flatbuffers\"))\n```\n\n----------------------------------------\n\nTITLE: Accessing Table Fields in FlatBuffers (Lua)\nDESCRIPTION: Code to access specific fields from a Monster table in Lua. Uses method-style accessors with a colon operator.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_124\n\nLANGUAGE: Lua\nCODE:\n```\nlocal hp = mon:Hp()\nlocal mana = mon:Mana()\nlocal name = mon:Name()\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files for FlatBuffers Compiler\nDESCRIPTION: Lists all source files required to build the FlatBuffers compiler (flatc), including the core library files plus language-specific code generators for various target languages such as C++, Java, Python, Go, TypeScript, and more.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(FlatBuffers_Compiler_SRCS\n  ${FlatBuffers_Library_SRCS}\n  src/idl_gen_binary.cpp\n  src/idl_gen_text.cpp\n  src/idl_gen_cpp.cpp\n  src/idl_gen_csharp.cpp\n  src/idl_gen_dart.cpp\n  src/idl_gen_kotlin.cpp\n  src/idl_gen_kotlin_kmp.cpp\n  src/idl_gen_go.cpp\n  src/idl_gen_java.cpp\n  src/idl_gen_ts.cpp\n  src/idl_gen_php.cpp\n  src/idl_gen_python.cpp\n  src/idl_gen_lobster.cpp\n  src/idl_gen_rust.cpp\n  src/idl_gen_fbs.cpp\n  src/idl_gen_grpc.cpp\n  src/idl_gen_json_schema.cpp\n  src/idl_gen_swift.cpp\n  src/file_name_saving_file_manager.cpp\n  src/file_binary_writer.cpp\n  src/file_writer.cpp\n  src/idl_namer.h\n  src/namer.h\n  src/flatc.cpp\n  src/flatc_main.cpp\n  src/bfbs_gen.h\n  src/bfbs_gen_lua.h\n  src/bfbs_gen_nim.h\n  src/bfbs_namer.h\n  include/codegen/idl_namer.h\n  include/codegen/namer.h\n  include/codegen/python.h\n  include/codegen/python.cc\n  include/flatbuffers/code_generators.h\n  src/binary_annotator.h\n  src/binary_annotator.cpp\n  src/annotated_binary_text_gen.h\n  src/annotated_binary_text_gen.cpp\n  src/bfbs_gen_lua.cpp\n  src/bfbs_gen_nim.cpp\n  src/code_generators.cpp\n  grpc/src/compiler/schema_interface.h\n  grpc/src/compiler/cpp_generator.h\n  grpc/src/compiler/cpp_generator.cc\n  grpc/src/compiler/go_generator.h\n  grpc/src/compiler/go_generator.cc\n  grpc/src/compiler/java_generator.h\n  grpc/src/compiler/java_generator.cc\n  grpc/src/compiler/python_generator.h\n  grpc/src/compiler/python_generator.cc\n  grpc/src/compiler/swift_generator.h\n  grpc/src/compiler/swift_generator.cc\n  grpc/src/compiler/ts_generator.h\n  grpc/src/compiler/ts_generator.cc\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files for gRPC Test\nDESCRIPTION: Lists source files required for testing the gRPC integration with FlatBuffers, including the FlatBuffers gRPC header, test assertions, and specific gRPC test implementation files.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nset(FlatBuffers_GRPCTest_SRCS\n  include/flatbuffers/flatbuffers.h\n  include/flatbuffers/grpc.h\n  include/flatbuffers/util.h\n  src/util.cpp\n  tests/monster_test.grpc.fb.h\n  tests/test_assert.h\n  tests/test_builder.h\n  tests/monster_test.grpc.fb.cc\n  tests/test_assert.cpp\n  tests/test_builder.cpp\n  grpc/tests/grpctest.cpp\n  grpc/tests/message_builder_test.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Building TypeScript gRPC Project\nDESCRIPTION: Command to build the TypeScript project using npm.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/ts/greeter/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Properly Adding a New Field in FlatBuffers Schema\nDESCRIPTION: A well-evolved schema (version 2) that adds a new field 'c' at the end of the table definition, maintaining compatibility with older data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\ntable T {\n  a:int;\n  b:int;\n  c:int;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in Lobster\nDESCRIPTION: Retrieves the serialized buffer as a string in Lobster.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_93\n\nLANGUAGE: lobster\nCODE:\n```\nlet buf = builder.SizedCopy() // Of type `string`.\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in Python\nDESCRIPTION: Retrieves the serialized buffer as a bytearray in Python.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_96\n\nLANGUAGE: py\nCODE:\n```\nbuf = builder.Output() # Of type `bytearray`.\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in PHP\nDESCRIPTION: Retrieves the serialized buffer as a ByteBuffer in PHP.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_95\n\nLANGUAGE: php\nCODE:\n```\n$buf = $builder->dataBuffer(); // Of type `Google\\FlatBuffers\\ByteBuffer`\n```\n\n----------------------------------------\n\nTITLE: Extending C++ Compiler Flags in CMake for FlatBuffers\nDESCRIPTION: Appends user-defined C++ flags (FLATBUFFERS_CXX_FLAGS) to the standard CMAKE_CXX_FLAGS variable if defined, then displays the final flags for debugging purposes.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\n# Append FLATBUFFERS_CXX_FLAGS to CMAKE_CXX_FLAGS.\nif(DEFINED FLATBUFFERS_CXX_FLAGS)\n  message(STATUS \"extend CXX_FLAGS with ${FLATBUFFERS_CXX_FLAGS}\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${FLATBUFFERS_CXX_FLAGS}\")\nendif()\nmessage(STATUS \"CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}\")\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server\nDESCRIPTION: Command to start the gRPC server using npm script.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/ts/greeter/README.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run server\n```\n\n----------------------------------------\n\nTITLE: Installing FlatBuffers via Swift Package Manager\nDESCRIPTION: Package dependency declaration for adding FlatBuffers to a Swift project using SPM. Replace X.Y.Z with the desired version number.\nSOURCE: https://github.com/google/flatbuffers/blob/master/swift/README.md#2025-04-16_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n.package(url: \"https://github.com/google/flatbuffers.git\", from: \"X.Y.Z\"),\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer values in Lobster\nDESCRIPTION: This snippet shows how to access values from a FlatBuffer object in Lobster, demonstrating that functions like hp() and pos() appear as field accesses.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/lobster.md#2025-04-16_snippet_1\n\nLANGUAGE: lobster\nCODE:\n```\nlet hp = monster.hp\nlet pos = monster.pos\n```\n\n----------------------------------------\n\nTITLE: Finishing FlatBuffer Serialization in C++\nDESCRIPTION: Completes the serialization of the Monster object in C++ by calling the Finish() method on the builder.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_84\n\nLANGUAGE: c++\nCODE:\n```\nbuilder.Finish(orc);\n```\n\n----------------------------------------\n\nTITLE: Namespace Closing in FlatBuffers Generated Code\nDESCRIPTION: Closing braces for nested namespaces in FlatBuffers generated code, following the namespace hierarchy defined in the schema file.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\n}; // namespace MyGame\n}; // namespace Sample\n```\n\n----------------------------------------\n\nTITLE: Defining Directories and Source Files for FlatBuffers Benchmarks\nDESCRIPTION: Sets up directory paths for the benchmark files and defines the source files for the FlatBenchmark target.\nSOURCE: https://github.com/google/flatbuffers/blob/master/benchmarks/CMakeLists.txt#2025-04-16_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(CPP_BENCH_DIR ${CMAKE_CURRENT_SOURCE_DIR}/cpp)\nset(CPP_FB_BENCH_DIR ${CPP_BENCH_DIR}/flatbuffers)\nset(CPP_RAW_BENCH_DIR ${CPP_BENCH_DIR}/raw)\nset(CPP_BENCH_FBS ${CPP_FB_BENCH_DIR}/bench.fbs)\nset(CPP_BENCH_FB_GEN ${CPP_FB_BENCH_DIR}/bench_generated.h)\n\nset(FlatBenchmark_SRCS\n    ${CPP_BENCH_DIR}/benchmark_main.cpp\n    ${CPP_FB_BENCH_DIR}/fb_bench.cpp\n    ${CPP_RAW_BENCH_DIR}/raw_bench.cpp\n    ${CPP_BENCH_FB_GEN}\n)\n```\n\n----------------------------------------\n\nTITLE: Example FlatBuffer Binary Annotation\nDESCRIPTION: Example command showing how to annotate a specific binary file using a schema file in the tests/annotated_binary directory.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/annotation.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd tests/annotated_binary\n../../flatc --annotate annotated_binary.fbs -- annotated_binary.bin\n```\n\n----------------------------------------\n\nTITLE: Improper Field Addition in FlatBuffers Schema\nDESCRIPTION: An incorrectly evolved schema that adds a new field at the beginning of the table, breaking compatibility with older code and data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\ntable T {\n  c:int;\n  a:int;\n  b:int;\n}\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Client\nDESCRIPTION: Command to start the gRPC client with a port parameter using npm script.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/ts/greeter/README.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run client 3000\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in TypeScript\nDESCRIPTION: Retrieves the serialized buffer as a Uint8Array in TypeScript.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_99\n\nLANGUAGE: ts\nCODE:\n```\nlet buf = builder.asUint8Array(); // Of type `Uint8Array`.\n```\n\n----------------------------------------\n\nTITLE: Creating String References in FlatBuffers (TypeScript)\nDESCRIPTION: Creates string references in FlatBuffers using the builder's createString method. Returns offsets that point to the serialized string data in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nlet weaponOne = builder.createString('Sword');\nlet weaponTwo = builder.createString('Axe');\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with Lobster\nDESCRIPTION: Shows how to access elements of an inventory vector in a Monster object using Lobster. The code gets the vector length and accesses the third element.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_153\n\nLANGUAGE: Lobster\nCODE:\n```\nlet inv_len = monster.inventory_length\nlet third_item = monster.inventory(2)\n```\n\n----------------------------------------\n\nTITLE: Running Flatbuffers Fuzzer Tests with Specific Locales\nDESCRIPTION: Examples of running Flatbuffers fuzzer tests with different locale settings using the FLATBUFFERS_TEST_LOCALE environment variable.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/fuzzer/readme.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n>FLATBUFFERS_TEST_LOCALE=\"\" ./scalar_parser\n>FLATBUFFERS_TEST_LOCALE=\"ru_RU.CP1251\" ./parser_fuzzer\n```\n\n----------------------------------------\n\nTITLE: Running FlatBuffers Swift Benchmarks in Terminal\nDESCRIPTION: Command to execute Swift benchmarks directly from the terminal using the Swift Package Manager benchmark tool. This provides a command-line alternative to running benchmarks in Xcode.\nSOURCE: https://github.com/google/flatbuffers/blob/master/benchmarks/swift/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nswift package benchmark\n```\n\n----------------------------------------\n\nTITLE: Improper Union Variant Addition in FlatBuffers\nDESCRIPTION: An incorrectly evolved union schema that adds a new variant in the middle, breaking compatibility with older data and code.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_11\n\nLANGUAGE: c++\nCODE:\n```\nunion U {\n  A,\n  another_a: A,\n  B\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Server Component in Go Greeter Example\nDESCRIPTION: Commands to navigate to the server directory, clean the environment, and launch the server application.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/go/greeter/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd server\ngo clean\ngo run main.go\n```\n\n----------------------------------------\n\nTITLE: Properly Reordering Fields Using ID Attributes\nDESCRIPTION: A correctly evolved schema that uses explicit ID attributes to safely reorder fields while maintaining compatibility.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\ntable T {\n  c:int (id: 2);\n  a:int (id: 0);\n  b:int (id: 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring C++ Standard for Code Generation (C++)\nDESCRIPTION: Example of using --cpp-std to specify the C++ standard for code generation. Options include c++0x, c++11 (default), and c++17 (experimental).\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flatc.md#2025-04-16_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n--cpp-std c++17\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Object in FlatBuffers (Lobster)\nDESCRIPTION: Code to access the root Monster object from a FlatBuffer in Lobster. The data is read into a string and passed directly to the generated accessor function.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_108\n\nLANGUAGE: Lobster\nCODE:\n```\nbuf = /* the data you just read, in a string */\n\n// Get an accessor to the root object inside the buffer.\nlet monster = MyGame_Sample_GetRootAsMonster(buf)\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in Swift\nDESCRIPTION: Retrieves the serialized buffer as a byte array or Data object in Swift.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_98\n\nLANGUAGE: swift\nCODE:\n```\nlet buf = builder.sizedByteArray\n\nlet bufData = ByteBuffer(data: builder.data)\n\nlet buf = builder.sizedBuffer\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server with Swift FlatBuffers\nDESCRIPTION: Command to run the server component of the Swift FlatBuffers gRPC example.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/swift/Greeter/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nswift run Server\n```\n\n----------------------------------------\n\nTITLE: Union Type Definition in FlatBuffers\nDESCRIPTION: Example of how unions are represented in generated FlatBuffers code. Unions use enums to identify which type is stored, with helper functions for type name lookup.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nenum {\n  Any_NONE = 0,\n  Any_Monster = 1,\n};\n\ninline const char **EnumNamesAny() {\n  static const char *names[] = { \"NONE\", \"Monster\", nullptr };\n  return names;\n}\n\ninline const char *EnumNameAny(int e) { return EnumNamesAny()[e]; }\n```\n\n----------------------------------------\n\nTITLE: Setting Fuzzing Control Parameters\nDESCRIPTION: Examples of setting timeout, memory limits, and forcing stops on UBSAN errors for Flatbuffers fuzzing tests.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/fuzzer/readme.md#2025-04-16_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n-timeout=10 -rss_limit_mb=2048 -jobs=4 -workers=4\n\nexport UBSAN_OPTIONS=halt_on_error=1\nexport ASAN_OPTIONS=halt_on_error=1\n```\n\n----------------------------------------\n\nTITLE: Installing FlatBuffers Static Library in CMake\nDESCRIPTION: Configures the installation of the FlatBuffers static library, including targets, export files, and destination paths.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_26\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_BUILD_FLATLIB)\n  install(\n    TARGETS flatbuffers EXPORT FlatBuffersTargets\n    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n  )\n\n  install(EXPORT FlatBuffersTargets\n    FILE FlatBuffersTargets.cmake\n    NAMESPACE flatbuffers::\n    DESTINATION ${FB_CMAKE_DIR}\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC File Naming for C++ (C++)\nDESCRIPTION: Example of using --grpc-filename-suffix to customize the file naming convention for gRPC-generated C++ files.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flatc.md#2025-04-16_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n--grpc-filename-suffix=.fbs\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in Rust\nDESCRIPTION: Retrieves the serialized buffer as a byte slice in Rust.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_97\n\nLANGUAGE: rust\nCODE:\n```\nlet buf = builder.finished_data(); // Of type `&[u8]`\n```\n\n----------------------------------------\n\nTITLE: Setting C++ Standard and Compiler Detection in FlatBuffers CMake\nDESCRIPTION: Sets the default C++ standard to 11 if not already defined and detects compiler type (MSVC-like or Clang). Also configures compilation timing measurement if requested.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT DEFINED FLATBUFFERS_CPP_STD)\n  set(FLATBUFFERS_CPP_STD 11)\nendif()\n\nset(MSVC_LIKE OFF)\nif(MSVC OR CMAKE_CXX_COMPILER_FRONTEND_VARIANT STREQUAL \"MSVC\")\n    set(MSVC_LIKE ON)\nendif()\n\nif(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  set(IS_CLANG ON)\nelse()\n  set(IS_CLANG OFF)\nendif()\n\nif(DEFINED FLATBUFFERS_COMPILATION_TIMINGS)\n  message(\"Recording Compilation Timings to ${FLATBUFFERS_COMPILATION_TIMINGS}\")\n  file(REMOVE ${FLATBUFFERS_COMPILATION_TIMINGS})\n  set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE \"time -f 'Wall: %E User: %U Sys: %S | %C' -q -a -o ${FLATBUFFERS_COMPILATION_TIMINGS}\")\n  set_property(GLOBAL PROPERTY RULE_LAUNCH_CUSTOM \"time -f 'Wall: %E User: %U Sys: %S | %C' -q -a -o ${FLATBUFFERS_COMPILATION_TIMINGS}\")\n  set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK \"time -f 'Wall: %E User: %U Sys: %S | %C' -q -a -o ${FLATBUFFERS_COMPILATION_TIMINGS}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Enum Definition with Reverse Lookup in FlatBuffers\nDESCRIPTION: Example of how FlatBuffers generates enum definitions with helper functions for name lookup. This enables converting between numeric enum values and their string representations.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/internals.md#2025-04-16_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nenum {\n  Color_Red = 0,\n  Color_Green = 1,\n  Color_Blue = 2,\n};\n\ninline const char **EnumNamesColor() {\n  static const char *names[] = { \"Red\", \"Green\", \"Blue\", nullptr };\n  return names;\n}\n\ninline const char *EnumNameColor(int e) { return EnumNamesColor()[e]; }\n```\n\n----------------------------------------\n\nTITLE: Configuring FlatBuffers Packaging on Unix Systems in CMake\nDESCRIPTION: Sets up packaging options for FlatBuffers on Unix systems, including Debian and RedHat package configurations.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_31\n\nLANGUAGE: CMake\nCODE:\n```\nif(UNIX)\n    # Use of CPack only supported on Linux systems.\n    if(FLATBUFFERS_PACKAGE_DEBIAN)\n        include(CMake/PackageDebian.cmake)\n        include(CPack)\n    endif()\n    if (FLATBUFFERS_PACKAGE_REDHAT)\n        include(CMake/PackageRedhat.cmake)\n        include(CPack)\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating FlatBuffers Library Target\nDESCRIPTION: Defines the actual library target named 'flatbuffers' and specifies the source files to be included in the build. This creates the native library that can be linked with Android applications.\nSOURCE: https://github.com/google/flatbuffers/blob/master/android/app/src/main/cpp/flatbuffers/CMakeLists.txt#2025-04-16_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library( # Sets the name of the library.\n             flatbuffers\n\n             ${FlatBuffers_Library_SRCS}\n             ${Generated_SRCS}\n)\n```\n\n----------------------------------------\n\nTITLE: Renaming Fields in FlatBuffers Schema\nDESCRIPTION: A schema evolution that renames fields, which is generally safe for binary compatibility but requires code refactoring.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\ntable T {\n  aa:int;\n  bb:int;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Swift Format Command\nDESCRIPTION: Command to format Swift code using swiftformat with a custom configuration file\nSOURCE: https://github.com/google/flatbuffers/blob/master/Formatters.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nswiftformat --config swift.swiftformat .\n```\n\n----------------------------------------\n\nTITLE: Defining FlatBuffers Library Source Files\nDESCRIPTION: Lists all header and implementation files required to build the FlatBuffers library. Includes core components like allocator, builder, parser, and utilities needed for the complete FlatBuffers functionality.\nSOURCE: https://github.com/google/flatbuffers/blob/master/android/app/src/main/cpp/flatbuffers/CMakeLists.txt#2025-04-16_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(FlatBuffers_Library_SRCS\n        ${FLATBUFFERS_SRC}/include/flatbuffers/allocator.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/array.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/base.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/buffer.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/buffer_ref.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/default_allocator.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/detached_buffer.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/flatbuffer_builder.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/flatbuffers.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/flexbuffers.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/flex_flat_util.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/hash.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/idl.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/minireflect.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/reflection.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/reflection_generated.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/registry.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/stl_emulation.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/string.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/struct.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/table.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/util.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/vector.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/vector_downward.h\n        ${FLATBUFFERS_SRC}/include/flatbuffers/verifier.h\n        ${FLATBUFFERS_SRC}/src/idl_parser.cpp\n        ${FLATBUFFERS_SRC}/src/idl_gen_text.cpp\n        ${FLATBUFFERS_SRC}/src/reflection.cpp\n        ${FLATBUFFERS_SRC}/src/util.cpp\n        ${FLATBUFFERS_SRC}/src/idl_gen_fbs.cpp\n        ${FLATBUFFERS_SRC}/src/code_generators.cpp\n        )\n```\n\n----------------------------------------\n\nTITLE: Setting File Extension in FlatBuffers Schema\nDESCRIPTION: Shows how to declare a custom file extension for binary files output by flatc compiler instead of the default .bin extension.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_8\n\nLANGUAGE: txt\nCODE:\n```\nfile_extension \"ext\";\n```\n\n----------------------------------------\n\nTITLE: Executing .NET Tests on Linux\nDESCRIPTION: Command to run the .NET tests which handles downloading the .NET installer and SDK if not present, builds tests with msbuild, and executes them using mono.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/FlatBuffers.Test/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./NetTest.sh\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Build for Unix Systems\nDESCRIPTION: Commands for configuring CMake build on Unix-like systems using Unix Makefiles generator with Release build type.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/building.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncmake -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release\n```\n\n----------------------------------------\n\nTITLE: Configuring Fuzzer Test Executables\nDESCRIPTION: Creates and configures multiple fuzzer test executables targeting different components of FlatBuffers, including monster, parser, and verifier tests.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/fuzzer/CMakeLists.txt#2025-04-16_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(scalar_fuzzer flatbuffers_scalar_fuzzer.cc)\ntarget_link_libraries(scalar_fuzzer PRIVATE flatbuffers_fuzzed)\n\nadd_executable(parser_fuzzer flatbuffers_parser_fuzzer.cc)\ntarget_link_libraries(parser_fuzzer PRIVATE flatbuffers_fuzzed)\n\nadd_executable(verifier_fuzzer flatbuffers_verifier_fuzzer.cc)\ntarget_link_libraries(verifier_fuzzer PRIVATE flatbuffers_fuzzed)\n```\n\n----------------------------------------\n\nTITLE: Setting Up FlatBuffers Tests in CMake\nDESCRIPTION: Enables testing and adds test targets for FlatBuffers, including optional C++17 and gRPC tests.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_30\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_BUILD_TESTS)\n  enable_testing()\n\n  add_test(NAME flattests COMMAND flattests)\n  if(FLATBUFFERS_BUILD_CPP17)\n    add_test(NAME flattests_cpp17 COMMAND flattests_cpp17)\n  endif()\n  if(FLATBUFFERS_BUILD_GRPCTEST)\n    add_test(NAME grpctest COMMAND grpctest)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for FlatBuffers with Conan Integration\nDESCRIPTION: Sets up the CMake environment for building FlatBuffers, including Conan package management integration. It sets the minimum CMake version, includes Conan build info, and configures Windows-specific settings for shared library builds.\nSOURCE: https://github.com/google/flatbuffers/blob/master/conan/CMakeLists.txt#2025-04-16_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8)\n\nmessage(STATUS \"Conan FlatBuffers Wrapper\")\n\ninclude(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)\nconan_basic_setup()\n\nif (WIN32 AND MSVC_LIKE AND FLATBUFFERS_BUILD_SHAREDLIB)\n    set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)\nendif(WIN32 AND MSVC_LIKE AND FLATBUFFERS_BUILD_SHAREDLIB)\n\ninclude(${CMAKE_SOURCE_DIR}/CMakeListsOriginal.txt)\n```\n\n----------------------------------------\n\nTITLE: Customizing Go Package Import Path (Go)\nDESCRIPTION: Example of using --go-import to override the default import path for flatbuffers in Go code generation.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flatc.md#2025-04-16_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n--go-import \"custom/path/flatbuffers\"\n```\n\n----------------------------------------\n\nTITLE: Generating Linux Test Main for Swift Tests\nDESCRIPTION: Command to regenerate the Linux main test file when Swift test cases are modified. This should be run whenever test functions are added or removed.\nSOURCE: https://github.com/google/flatbuffers/blob/master/swift/README.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nswift test --generate-linuxmain\n```\n\n----------------------------------------\n\nTITLE: Setting Up FlatBuffers Library Sources\nDESCRIPTION: Defines the source files needed to build the FlatBuffers library for fuzzing tests, including core headers and implementation files.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/fuzzer/CMakeLists.txt#2025-04-16_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(FlatBuffers_Library_SRCS\n    ${FLATBUFFERS_DIR}/include/flatbuffers/allocator.h\n    ${FLATBUFFERS_DIR}/include/flatbuffers/array.h\n    # ... additional files ...\n    ${FLATBUFFERS_DIR}/tests/64bit/test_64bit_bfbs_generated.h\n)\n```\n\n----------------------------------------\n\nTITLE: Running Various Flatbuffers Fuzzer Tests\nDESCRIPTION: Examples of running different Flatbuffers fuzzer tests with various flags and options for libFuzzer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/fuzzer/readme.md#2025-04-16_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n./verifier_fuzzer ../.corpus_verifier/ ../.seed_verifier/\n\n./parser_fuzzer -only_ascii=1  -max_len=500 -dict=../parser_fbs.dict ../.corpus_parser/ ../.seed_parser/\n\n./monster_fuzzer -only_ascii=1 -max_len=500 -dict=../monster_json.dict ../.corpus_monster/ ../.seed_monster/\n\n./scalar_fuzzer -use_value_profile=1 -max_len=500 -dict=../scalar_json.dict ../.corpus_scalar/ ../.seed_scalar/\n\nFLATBUFFERS_TEST_LOCALE=\"ru_RU.CP1251\" ./scalar_fuzzer -reduce_depth=1 -use_value_profile=1 -shrink=1 -max_len=3000 -timeout=10 -rss_limit_mb=2048 ../.corpus_parser/ ../.seed_parser/\n```\n\n----------------------------------------\n\nTITLE: Accessing Vectors in FlatBuffers with PHP\nDESCRIPTION: Shows how to access elements of an inventory vector in a Monster object using PHP. The code gets the vector length and accesses the third element using getter methods.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_155\n\nLANGUAGE: PHP\nCODE:\n```\n$inv_len = $monster->getInventoryLength();\n$third_item = $monster->getInventory(2);\n```\n\n----------------------------------------\n\nTITLE: Generating C++ Includes with Custom Path (C++)\nDESCRIPTION: Example of using the --cpp-include option to add a custom include statement in the generated C++ file.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/flatc.md#2025-04-16_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n--cpp-include \"custom_header.h\"\n```\n\n----------------------------------------\n\nTITLE: Improper Field Deletion in FlatBuffers Schema\nDESCRIPTION: An incorrectly evolved schema that completely removes a field, breaking compatibility with older code and data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\ntable T {\n  b:int;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Sanitizer Options and Compiler Flags\nDESCRIPTION: Sets up build options for Address Sanitizer (ASAN) and Memory Sanitizer (MSAN) along with core compiler flags for the project.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/fuzzer/CMakeLists.txt#2025-04-16_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\noption(USE_ASAN \"Use fuzzers with ASASN\" OFF)\noption(USE_MSAN \"Use fuzzers with MSASN\" OFF)\noption(OSS_FUZZ \"Set this option to use flags by oss-fuzz\" OFF)\n\nset(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fuse-ld=lld\")\n\nadd_compile_options(\n  -std=c++17\n  -Wall\n  -pedantic\n  -Werror\n  -Wextra\n  -Wno-unused-parameter\n  -fsigned-char\n  -fno-omit-frame-pointer\n  -g\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Flatbuffer Binary from JSON and Schema\nDESCRIPTION: Command to create a flatbuffer binary (annotated_binary.bin) from a JSON file (annotated_binary.json) using the flatc compiler with the annotated_binary.fbs schema.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/annotated_binary/README.md#2025-04-16_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n..\\..\\flatc -b annotated_binary.fbs annotated_binary.json\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Mode in CMake\nDESCRIPTION: Command to enable strict warning mode in CMake build configuration using FLATBUFFERS_STRICT_MODE flag.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/building.md#2025-04-16_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ncmake -DFLATBUFFERS_STRICT_MODE=ON\n```\n\n----------------------------------------\n\nTITLE: Building with Bazel and Swift Support\nDESCRIPTION: Script for setting up Bazel build environment with Swift support, including installation of required dependencies and running builds/tests.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/building.md#2025-04-16_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncurl -sL --fail https://github.com/bazelbuild/bazelisk/releases/download/v1.25.0/bazelisk-linux-amd64 -o bazelisk && chmod +x bazelisk\nsudo apt install -y clang\nSWIFT_VERSION=\"6.0.3\"\ncurl -L https://download.swift.org/swift-${SWIFT_VERSION}-release/debian12/swift-${SWIFT_VERSION}-RELEASE/swift-${SWIFT_VERSION}-RELEASE-debian12.tar.gz | tar xz\nCC=clang PATH=$PATH:$(pwd)/swift-${SWIFT_VERSION}-RELEASE-debian12/usr/bin bazel build //...\nCC=clang PATH=$PATH:$(pwd)/swift-${SWIFT_VERSION}-RELEASE-debian12/usr/bin bazel test //...\n```\n\n----------------------------------------\n\nTITLE: Improper Default Value Changes in FlatBuffers Schema\nDESCRIPTION: An incorrectly evolved schema that changes default values of existing fields, which can break compatibility with older data.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/evolution.md#2025-04-16_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\ntable T {\n  a:int = 1;\n  b:int = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing FlatBuffers Implementation with Bazel\nDESCRIPTION: Command for running all FlatBuffers gRPC tests using Bazel build system.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$bazel test tests/...\n```\n\n----------------------------------------\n\nTITLE: Schema Compilation Helper Functions for Tests and Samples\nDESCRIPTION: Defines helper functions to compile FlatBuffer schema files for test and sample targets, adding the generated files to the appropriate targets.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_22\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(compile_schema_for_test SRC_FBS OPT)\n  compile_schema(\"${SRC_FBS}\" \"${OPT}\" GEN_FILE)\n  target_sources(flattests PRIVATE ${GEN_FILE})\nendfunction()\n\nfunction(compile_schema_for_samples SRC_FBS OPT)\n  compile_schema(\"${SRC_FBS}\" \"${OPT}\" GEN_FILE)\n  target_sources(flatsample PRIVATE ${GEN_FILE})\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Creating Annotated Binary Example in tests\\annotated_binary Directory\nDESCRIPTION: Example command to generate annotated_binary.afb file in the tests\\annotated_binary directory using the flatc compiler with annotated_binary.fbs schema and annotated_binary.bin binary file.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/annotated_binary/README.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd tests\\annotated_binary\n..\\..\\flatc --annotate annotated_binary.fbs -- annotated_binary.bin\n```\n\n----------------------------------------\n\nTITLE: Configuring FlatBuffers Benchmark Executable\nDESCRIPTION: Sets up the main FlatBuffers benchmark executable, configures its properties, includes, and links necessary libraries. It requires C++11 and sets specific compiler options.\nSOURCE: https://github.com/google/flatbuffers/blob/master/benchmarks/CMakeLists.txt#2025-04-16_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(flatbenchmark ${FlatBenchmark_SRCS})\n\ntarget_compile_features(flatbenchmark PRIVATE\n    cxx_std_11 # requires cmake 3.8\n)\n\ntarget_compile_options(flatbenchmark\n    PRIVATE\n        -fno-aligned-new\n        -Wno-deprecated-declarations\n)\n\nset_target_properties(flatbenchmark \n    PROPERTIES RUNTIME_OUTPUT_DIRECTORY \n    \"${CMAKE_BINARY_DIR}\"\n)\n\ntarget_include_directories(flatbenchmark PUBLIC ${CMAKE_SOURCE_DIR})\n\ntarget_link_libraries(flatbenchmark PRIVATE\n    benchmark::benchmark_main # _main to use their entry point \n    gtest # Link to gtest so we can also assert in the benchmarks\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in Java\nDESCRIPTION: Retrieves the serialized buffer as a ByteBuffer or byte array in Java.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_90\n\nLANGUAGE: java\nCODE:\n```\njava.nio.ByteBuffer buf = builder.dataBuffer();\n\nbyte[] buf = builder.sizedByteArray();\n```\n\n----------------------------------------\n\nTITLE: Generating FlatBuffers Benchmark Code with Custom Command\nDESCRIPTION: Adds a custom command to generate FlatBuffers benchmark code from the schema using flatc. It depends on flatc, flatbuffers runtime, and the schema file.\nSOURCE: https://github.com/google/flatbuffers/blob/master/benchmarks/CMakeLists.txt#2025-04-16_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n    OUTPUT ${CPP_BENCH_FB_GEN}\n    COMMAND \n        \"${FLATBUFFERS_FLATC_EXECUTABLE}\"\n        --cpp\n        -o ${CPP_FB_BENCH_DIR}\n        ${CPP_BENCH_FBS}\n    DEPENDS \n        flatc\n        flatbuffers\n        ${CPP_BENCH_FBS}\n    COMMENT \"Run Flatbuffers Benchmark Codegen: ${CPP_BENCH_FB_GEN}\"\n    VERBATIM)\n```\n\n----------------------------------------\n\nTITLE: Installing gRPC Python Dependencies\nDESCRIPTION: Command to install the gRPC Python package using pip, which is a prerequisite for running the example.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/python/greeter/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install grpcio\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Client with Swift FlatBuffers\nDESCRIPTION: Command to run the client component of the Swift FlatBuffers gRPC example with port and name parameters.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/swift/Greeter/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nswift run Client {port} {name}\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Build for Windows\nDESCRIPTION: Commands for configuring CMake build on Windows using Visual Studio 2022 generator with Release build type.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/building.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncmake -G \"Visual Studio 17 2022\" -DCMAKE_BUILD_TYPE=Release\n```\n\n----------------------------------------\n\nTITLE: Installing MkDocs dependencies for FlatBuffers documentation\nDESCRIPTION: This snippet shows how to install the required Python packages for building and serving FlatBuffers documentation locally using MkDocs and the Material theme.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/contributing.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install mkdocs-material\npip install mkdocs-redirects\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Client with FlatBuffers\nDESCRIPTION: Command to start the Python client, connecting to the server on the specified port and sending a NAME parameter for the greeting.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/python/greeter/README.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython client.py ${PORT} ${NAME}\n```\n\n----------------------------------------\n\nTITLE: Running Bazel Repository Test for FlatBuffers TypeScript Integration\nDESCRIPTION: Command for running the Bazel test that validates FlatBuffers integration with rules_js. This test should be executed from the top-level of the FlatBuffers repository.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/ts/bazel_repository_test_dir/README.md#2025-04-16_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ bazel test //tests/ts:bazel_repository_test\n```\n\n----------------------------------------\n\nTITLE: Creating ProjectConfig Interface Library for FlatBuffers\nDESCRIPTION: Creates an interface library to store shared configuration settings that each target can link to. It sets the C++ standard feature based on the FLATBUFFERS_CPP_STD variable and enforces strict standard compliance.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\n# Creates an interface library that stores the configuration settings that each\n# target links too. This is a compromise between setting configuration globally\n# with add_compile_options() and the more targetted target_compile_options().\n# This way each target in this file can share settings and override them if\n# needed.\nadd_library(ProjectConfig INTERFACE)\ntarget_compile_features(ProjectConfig\n  INTERFACE\n    cxx_std_${FLATBUFFERS_CPP_STD}\n)\n\n# Force the standard to be met.\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Server with FlatBuffers\nDESCRIPTION: Command to start the Python server on a specified port. The PORT parameter should be replaced with an actual port number.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/python/greeter/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython server.py ${PORT}\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files for FlatHash Utility\nDESCRIPTION: Lists the source files required for the FlatHash utility, which is a tool for generating hash values used by FlatBuffers. It includes the hash header and implementation file.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset(FlatHash_SRCS\n  include/flatbuffers/hash.h\n  src/flathash.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake and Fetching Dependencies for FlatBuffers Benchmarks\nDESCRIPTION: Sets up CMake minimum version, includes FetchContent, and declares GoogleTest and Google Benchmark repositories for fetching. It also configures Windows-specific settings and makes the content available.\nSOURCE: https://github.com/google/flatbuffers/blob/master/benchmarks/CMakeLists.txt#2025-04-16_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\ninclude(FetchContent)\n\nFetchContent_Declare(\n    googletest\n    GIT_REPOSITORY https://github.com/google/googletest.git\n    GIT_TAG        e2239ee6043f73722e7aa812a459f54a28552929 # release-1.11.0\n)\nFetchContent_Declare(\n    googlebenchmark\n    GIT_REPOSITORY https://github.com/google/benchmark.git\n    GIT_TAG        0d98dba29d66e93259db7daa53a9327df767a415 # v1.6.1\n)\n\nset(gtest_force_shared_crt ON CACHE BOOL \"\" FORCE)\nFetchContent_MakeAvailable(\n    googletest\n    googlebenchmark\n)\n```\n\n----------------------------------------\n\nTITLE: Serving FlatBuffers documentation locally with MkDocs\nDESCRIPTION: This command starts a local server that watches for changes in the FlatBuffers documentation and renders the pages in real-time. It should be run from the root directory of the FlatBuffers project.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/contributing.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdocs serve -f docs/mkdocs.yml\n```\n\n----------------------------------------\n\nTITLE: Running the Client Component in Go Greeter Example\nDESCRIPTION: Commands to navigate to the client directory, clean the environment, and run the client application with an optional name parameter.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/go/greeter/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd client\ngo clean\ngo run main.go --name NAME\n```\n\n----------------------------------------\n\nTITLE: Accessing Serialized FlatBuffer in Lua\nDESCRIPTION: Retrieves the serialized buffer as a string in Lua.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_94\n\nLANGUAGE: lua\nCODE:\n```\nlocal bufAsString = builder:Output()\n```\n\n----------------------------------------\n\nTITLE: Building and Serving FlatBuffers Documentation Locally in Bash\nDESCRIPTION: Command to build and serve the FlatBuffers documentation locally for development purposes. The command uses mkdocs to serve the documentation using the configuration file specified in docs/mkdocs.yml.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdocs serve -f docs/mkdocs.yml\n```\n\n----------------------------------------\n\nTITLE: Generating Annotated Flatbuffer Binary with flatc\nDESCRIPTION: Command to use flatc for generating an annotated flatbuffer binary from a schema file and binary file(s). The schema can be in plain text (.fbs) or binary (.bfbs) format.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/annotated_binary/README.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nflatc --annotate {schema_file} -- {binary_file}...\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Options for MSVC in FlatBuffers\nDESCRIPTION: Sets compiler options for Microsoft Visual C++ compiler, including warning levels and specific warning suppressions. Contains conditionals for strict mode and Clang compiler variants.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\nif(MSVC_LIKE)\n  target_compile_options(ProjectConfig\n    INTERFACE\n      /W4\n      $<$<BOOL:${FLATBUFFERS_STRICT_MODE}>:\n        /WX       # Treat all compiler warnings as errors\n      >\n      /wd4512   # C4512: assignment operator could not be generated\n      /wd4316   # C4316: object allocated on the heap may not be aligned\n      /wd4456   # C4456: hides previous local declaration\n      $<$<CXX_COMPILER_ID:Clang>:\n        /D_CRT_SECURE_NO_WARNINGS\n      >\n  )\n```\n\n----------------------------------------\n\nTITLE: Compiling FlatBuffers Schema on Windows\nDESCRIPTION: Shell commands for building the FlatBuffers compiler (flatc) on Windows systems using CMAKE and msbuild.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/tutorial.md#2025-04-16_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncmake -G \"Visual Studio 17 2022\"\nmsbuild.exe FlatBuffers.sln\n```\n\n----------------------------------------\n\nTITLE: Running TypeScript ESLint Command\nDESCRIPTION: Command to lint TypeScript files using ESLint in the project directory\nSOURCE: https://github.com/google/flatbuffers/blob/master/Formatters.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\neslint ts/** --ext .ts\n```\n\n----------------------------------------\n\nTITLE: Ensuring Byte Array Requests in Python FlatBuffers Client\nDESCRIPTION: This code snippet shows how to ensure that requests sent to and from Python are byte arrays when using FlatBuffers. It demonstrates the proper way to serialize and deserialize FlatBuffer objects in a Python client.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/README.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef say_hello(stub, builder):\n    hello_request = bytes(builder.Output())\n    reply = stub.SayHello(hello_request)\n    r = HelloReply.HelloReply.GetRootAs(reply)\n    print(r.Message())\n```\n\n----------------------------------------\n\nTITLE: Alternative TypeScript Project Setup\nDESCRIPTION: Alternative command to install dependencies and compile TypeScript files.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/examples/ts/greeter/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install && tsc\n```\n\n----------------------------------------\n\nTITLE: Declaring File Identifier in FlatBuffers Schema\nDESCRIPTION: Demonstrates how to specify a file identifier in a FlatBuffer schema. The identifier must be exactly 4 characters long and will be placed at offsets 4-7 in the buffer.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/schema.md#2025-04-16_snippet_7\n\nLANGUAGE: txt\nCODE:\n```\nfile_identifier \"MYFI\";\n```\n\n----------------------------------------\n\nTITLE: Setting Signed Char Flag for ARM Platform Compatibility\nDESCRIPTION: Ensures the use of signed chars which is important for platforms like ARM that don't use signed chars by default. This prevents issues with certain bounds checks in the FlatBuffers library.\nSOURCE: https://github.com/google/flatbuffers/blob/master/android/app/src/main/cpp/flatbuffers/CMakeLists.txt#2025-04-16_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_CXX_FLAGS\n   \"${CMAKE_CXX_FLAGS} -fsigned-char\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Base CMake Settings for FlatBuffers Fuzzer Tests\nDESCRIPTION: Initial CMake configuration setting minimum version, build options, and core project settings including position independent code and compile commands export.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/fuzzer/CMakeLists.txt#2025-04-16_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.9)\n\nset(CMAKE_VERBOSE_MAKEFILE ON)\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\nset(CMAKE_POSITION_INDEPENDENT_CODE ON)\n\nproject(FlatBuffersFuzzerTests)\n```\n\n----------------------------------------\n\nTITLE: Defining Fuzzer Configuration Interface Library\nDESCRIPTION: Creates an interface library with conditional compilation and linking options for fuzzing and sanitizer configurations.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/fuzzer/CMakeLists.txt#2025-04-16_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(fuzzer_config INTERFACE)\n\ntarget_compile_options(\n  fuzzer_config\n  INTERFACE\n    $<$<NOT:$<BOOL:${OSS_FUZZ}>>:\n      -fsanitize-coverage=trace-cmp\n    >\n    $<$<BOOL:${USE_ASAN}>:\n      -fsanitize=fuzzer,undefined,address\n    >\n    $<$<BOOL:${USE_MSAN}>:\n      -fsanitize=fuzzer,undefined,memory\n      -fsanitize-memory-track-origins=2\n    >\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project for FlatBuffers Test Package\nDESCRIPTION: This CMake snippet sets up a project named 'test_package', configures Conan package manager, and creates an executable. It sets the C++ standard to C++11 and links against Conan-provided libraries.\nSOURCE: https://github.com/google/flatbuffers/blob/master/conan/test_package/CMakeLists.txt#2025-04-16_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nproject(test_package CXX)\ncmake_minimum_required(VERSION 2.8.11)\n\ninclude(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)\nconan_basic_setup()\n\nadd_executable(${PROJECT_NAME} test_package.cpp)\ntarget_link_libraries(${PROJECT_NAME} ${CONAN_LIBS})\nset_property(TARGET ${PROJECT_NAME} PROPERTY CXX_STANDARD 11)\n```\n\n----------------------------------------\n\nTITLE: Truncating Binary File for Invalid Root Table Test\nDESCRIPTION: This command truncates the annotated_binary.bin file to 70 bytes, creating a test case where the root table is cut short. The resulting file is used to test FlatBuffers' handling of incomplete root tables.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/annotated_binary/tests/README.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ntruncate annotated_binary.bin --size=70 >> invalid_root_table_too_short.bin\n```\n\n----------------------------------------\n\nTITLE: Building Flatbuffers Fuzzer Tests with CMake\nDESCRIPTION: Commands to build the Flatbuffers fuzzer tests using CMake with Clang compiler in Debug mode and Address Sanitizer enabled.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/fuzzer/readme.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd tests/fuzzer\nCC=clang CXX=clang++ cmake . -DCMAKE_BUILD_TYPE=Debug -DUSE_ASAN=ON\n```\n\n----------------------------------------\n\nTITLE: Merging Flatbuffers Fuzzer Corpus\nDESCRIPTION: Commands to merge and minimize the corpus for different Flatbuffers fuzzer tests using libFuzzer's -merge flag.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/fuzzer/readme.md#2025-04-16_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n./verifier_fuzzer -merge=1 ../.seed_verifier/ ../.corpus_verifier/\n./parser_fuzzer -merge=1 ../.seed_parser/ ../.corpus_parser/\n./monster_fuzzer -merge=1 ../.seed_monster/ ../.corpus_monster/\n./scalar_fuzzer -merge=1 ../.seed_scalar/ ../.corpus_scalar/\n```\n\n----------------------------------------\n\nTITLE: Testing FlatBuffers with Bazel (Compiler)\nDESCRIPTION: Command for running compiler tests for FlatBuffers with gRPC using Bazel build system.\nSOURCE: https://github.com/google/flatbuffers/blob/master/grpc/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$bazel test src/compiler/...\n```\n\n----------------------------------------\n\nTITLE: Running the Echo Client\nDESCRIPTION: Command to execute the client component of the FlatBuffers networking example in Go, which will connect to the previously started server.\nSOURCE: https://github.com/google/flatbuffers/blob/master/examples/go-echo/README.md#2025-04-16_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngo run client/client.go\n```\n\n----------------------------------------\n\nTITLE: ASCII Box Drawing and Typography Example\nDESCRIPTION: Demonstrates various box drawing characters and typography formatting using Unicode and ASCII characters.\nSOURCE: https://github.com/google/flatbuffers/blob/master/kotlin/flatbuffers-kotlin/src/jvmTest/resources/utf8_sample.txt#2025-04-16_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n  ╔══════════════════════════════════════════╗\n  ║                                          ║\n  ║   • 'single' and \"double\" quotes         ║\n  ║                                          ║\n  ║   • Curly apostrophes: \"We've been here\" ║\n  ║                                          ║\n  ║   • Latin-1 apostrophe and accents: '´`  ║\n  ║                                          ║\n  ║   • ‚deutsche' „Anführungszeichen\"       ║\n  ║                                          ║\n  ║   • †, ‡, ‰, •, 3–4, —, −5/+5, ™, …      ║\n  ║                                          ║\n  ║   • ASCII safety test: 1lI|, 0OD, 8B     ║\n  ║                      ╭─────────╮         ║\n  ║   • the euro symbol: │ 14.95 € │         ║\n  ║                      ╰─────────╯         ║\n  ╚══════════════════════════════════════════╝\n```\n\n----------------------------------------\n\nTITLE: Installing Go Dependencies\nDESCRIPTION: Command to download and install required Go dependencies for the echo example using Go modules.\nSOURCE: https://github.com/google/flatbuffers/blob/master/examples/go-echo/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngo mod tidy\n```\n\n----------------------------------------\n\nTITLE: Running C++ Clang Format Script\nDESCRIPTION: Shell command to run clang-format on C++ code according to Google style guide\nSOURCE: https://github.com/google/flatbuffers/blob/master/Formatters.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsh scripts/clang-format-git.sh\n```\n\n----------------------------------------\n\nTITLE: Documenting FlatBuffers Changelog in Markdown\nDESCRIPTION: This Markdown document outlines the changelog for FlatBuffers, detailing changes and improvements across multiple versions. It includes version numbers, bullet points for each change, and covers various aspects such as API changes, bug fixes, and performance improvements.\nSOURCE: https://github.com/google/flatbuffers/blob/master/dart/CHANGELOG.md#2025-04-16_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# Changelog\n\n## 23.5.26\n\n- omit type annotationes for local variables (#7067, #7069, #7070)\n- remove BSD 3-clause license (#7073)\n- correctly parse lists of enums (#7157)\n- align naming conventions for generated code (#7187)\n- add `putBool` to fix errors when serializing structs with booleans (#7359)\n- fix handling of +/-inf defaults in codegen (#7588)\n- fix import issues in generated code (#7621)\n- Fix incorrect storage of floats as ints in some cases (#7703)\n- add final modifiers to the library implementation (#7943)\n\n## 2.0.5\n\n- switch to null safety (#6696)\n- add Object APIs (pack/unpack) (#6682, #6723, #6846)\n- add custom builder buffer allocator support (#6711)\n- add `Builder.size()` - finished buffer size (#6403)\n- make `writeString()` argument non-nullable (#6737)\n- make tables fixed size (expect the number of fields when creating) (#6735)\n- make table deduplication optional (param `deduplicateTables`) (#6734)\n- change `Builder.reset()` to reuse an existing buffer (#6661)\n- change table building to assert() instead of exceptions (#6754)\n- optimize `writeString()` for ASCII (param `asciiOptimization`) (#6736)\n- change `StringReader` to make ASCII optimization optional (param `asciiOptimization`) (#6758)\n- change `[byte]` and `[ubyte]` representation to `dart:typed_data` `Int8List` and `Uint8List` (#6839)\n- rename `lowFinish()` to `buffer` getter (#6712)\n- fix `Builder._writeString()` - always write trailing zero byte (#6390)\n- fix `Builder.reset()` - clear vTables (#6386)\n- make sure added padding is zeroed, same as in C++ (#6716)\n- many performance improvements (#6755)\n\n## 1.9.2\n\n- Ensure `_writeString` adds enough padding to null terminate strings.\n\n## 1.9.1\n\n- Changed constant identifiers to be compatible with Dart 2.x\n- No longer supports Dart 1.x\n\n## 1.9.0\n\n- Initial release, supports Dart 1.x and many dev versions of Dart 2.x\n```\n\n----------------------------------------\n\nTITLE: Opening FlatBuffers Swift Benchmarks in Xcode\nDESCRIPTION: Command to open Swift benchmarks in Xcode with jemalloc disabled. This specifies the environment variable BENCHMARK_DISABLE_JEMALLOC as true to prevent interference with memory allocation measurement.\nSOURCE: https://github.com/google/flatbuffers/blob/master/benchmarks/swift/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nopen --env BENCHMARK_DISABLE_JEMALLOC=true Package.swift\n```\n\n----------------------------------------\n\nTITLE: Cleaning .NET Test Environment\nDESCRIPTION: Command to clean up downloaded .NET installer and SDK files, which will be re-downloaded on next test execution.\nSOURCE: https://github.com/google/flatbuffers/blob/master/tests/FlatBuffers.Test/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./clean.sh\n```\n\n----------------------------------------\n\nTITLE: Configuring and Installing pkg-config File for FlatBuffers in CMake\nDESCRIPTION: Generates and installs a pkg-config file for FlatBuffers when either the shared or static library is built.\nSOURCE: https://github.com/google/flatbuffers/blob/master/CMakeLists.txt#2025-04-16_snippet_29\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLATBUFFERS_BUILD_SHAREDLIB OR FLATBUFFERS_BUILD_FLATLIB)\n    configure_file(CMake/flatbuffers.pc.in flatbuffers.pc @ONLY)\n    install(\n      FILES \"${CMAKE_CURRENT_BINARY_DIR}/flatbuffers.pc\"\n      DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version for Android Studio FlatBuffers Project\nDESCRIPTION: Sets the minimum required CMake version for building the native library. Version 3.4.1 is specified as the minimum compatible version for this project.\nSOURCE: https://github.com/google/flatbuffers/blob/master/android/app/src/main/cpp/flatbuffers/CMakeLists.txt#2025-04-16_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.4.1)\n```\n\n----------------------------------------\n\nTITLE: Accessing FlatBuffer Values in Go\nDESCRIPTION: This snippet shows how to access values from a FlatBuffer object in Go. It retrieves the 'hp' value and the 'pos' struct.\nSOURCE: https://github.com/google/flatbuffers/blob/master/docs/source/languages/go.md#2025-04-16_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nhp := monster.Hp()\npos := monster.Pos(nil)\n```\n\n----------------------------------------\n\nTITLE: Starting the Echo Server\nDESCRIPTION: Command to run the server component of the FlatBuffers networking example in Go.\nSOURCE: https://github.com/google/flatbuffers/blob/master/examples/go-echo/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngo run server/server.go\n```"
  }
]