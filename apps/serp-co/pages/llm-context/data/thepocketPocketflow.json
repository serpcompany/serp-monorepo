[
  {
    "owner": "the-pocket",
    "repo": "pocketflow",
    "content": "TITLE: Configuring Agent Flow with PocketFlow\nDESCRIPTION: Implementation of the agent flow by connecting nodes with appropriate transition paths. This flow manages the decision-making process, directing execution between searching the web and answering questions based on node outputs.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/demo.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# flow.py\nfrom pocketflow import Flow\n\ndef create_agent_flow():\n    \"\"\"\n    Create and connect the nodes to form a complete agent flow.\n\n    The flow works like this:\n    1. DecideAction node decides whether to search or answer\n    2. If search, go to SearchWeb node\n    3. If answer, go to AnswerQuestion node\n    4. After SearchWeb completes, go back to DecideAction\n\n    Returns:\n        Flow: A complete research agent flow\n    \"\"\"\n    # Create instances of each node\n    decide = DecideAction()\n    search = SearchWeb()\n    answer = AnswerQuestion()\n\n    # Connect the nodes\n    # If DecideAction returns \"search\", go to SearchWeb\n    decide - \"search\" >> search\n\n    # If DecideAction returns \"answer\", go to AnswerQuestion\n    decide - \"answer\" >> answer\n\n    # After SearchWeb completes and returns \"decide\", go back to DecideAction\n    search - \"decide\" >> decide\n\n    # Create and return the flow, starting with the DecideAction node\n    return Flow(start=decide)\n```\n\n----------------------------------------\n\nTITLE: Implementing Complex Order Processing Pipeline with Nested Flows in Python\nDESCRIPTION: Shows how to break down a complex order processing pipeline into nested flows for payment, inventory, and shipping. This creates a clean separation of concerns while maintaining a clear execution path.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/flow.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Payment processing sub-flow\nvalidate_payment >> process_payment >> payment_confirmation\npayment_flow = Flow(start=validate_payment)\n\n# Inventory sub-flow\ncheck_stock >> reserve_items >> update_inventory\ninventory_flow = Flow(start=check_stock)\n\n# Shipping sub-flow\ncreate_label >> assign_carrier >> schedule_pickup\nshipping_flow = Flow(start=create_label)\n\n# Connect the flows into a main order pipeline\npayment_flow >> inventory_flow >> shipping_flow\n\n# Create the master flow\norder_pipeline = Flow(start=payment_flow)\n\n# Run the entire pipeline\norder_pipeline.run(shared_data)\n```\n\n----------------------------------------\n\nTITLE: Implementing Online Query & Answer Stage for RAG in Python\nDESCRIPTION: This code snippet defines three Node classes (EmbedQuery, RetrieveDocs, GenerateAnswer) for the online query & answer stage of a RAG pipeline. It embeds the query, retrieves relevant documents, and generates an answer using a language model.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/rag.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass EmbedQuery(Node):\n    def prep(self, shared):\n        return shared[\"question\"]\n\n    def exec(self, question):\n        return get_embedding(question)\n\n    def post(self, shared, prep_res, q_emb):\n        shared[\"q_emb\"] = q_emb\n\nclass RetrieveDocs(Node):\n    def prep(self, shared):\n        # We'll need the query embedding, plus the offline index/chunks\n        return shared[\"q_emb\"], shared[\"index\"], shared[\"all_chunks\"]\n\n    def exec(self, inputs):\n        q_emb, index, chunks = inputs\n        I, D = search_index(index, q_emb, top_k=1)\n        best_id = I[0][0]\n        relevant_chunk = chunks[best_id]\n        return relevant_chunk\n\n    def post(self, shared, prep_res, relevant_chunk):\n        shared[\"retrieved_chunk\"] = relevant_chunk\n        print(\"Retrieved chunk:\", relevant_chunk[:60], \"...\")\n\nclass GenerateAnswer(Node):\n    def prep(self, shared):\n        return shared[\"question\"], shared[\"retrieved_chunk\"]\n\n    def exec(self, inputs):\n        question, chunk = inputs\n        prompt = f\"Question: {question}\\nContext: {chunk}\\nAnswer:\"\n        return call_llm(prompt)\n\n    def post(self, shared, prep_res, answer):\n        shared[\"answer\"] = answer\n        print(\"Answer:\", answer)\n\nembed_qnode = EmbedQuery()\nretrieve_node = RetrieveDocs()\ngenerate_node = GenerateAnswer()\n\nembed_qnode >> retrieve_node >> generate_node\nOnlineFlow = Flow(start=embed_qnode)\n```\n\n----------------------------------------\n\nTITLE: Implementing OpenAI LLM Wrapper in Python\nDESCRIPTION: This snippet demonstrates how to create a wrapper function for calling the OpenAI API. It uses the OpenAI client to send a chat completion request and returns the generated content.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/llm.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef call_llm(prompt):\n    from openai import OpenAI\n    client = OpenAI(api_key=\"YOUR_API_KEY_HERE\")\n    r = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    return r.choices[0].message.content\n\n# Example usage\ncall_llm(\"How are you?\")\n```\n\n----------------------------------------\n\nTITLE: Implementing OpenAI Utility Functions for PocketFlow\nDESCRIPTION: Defines two utility functions: 'call_llm' for making requests to OpenAI's GPT-4o model, and 'get_embedding' for generating text embeddings using OpenAI's text-embedding-ada-002 model. These functions serve as helpers for PocketFlow integration.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom openai import OpenAI\nimport os\n\ndef call_llm(prompt):\n    client = OpenAI(api_key=API_KEY)\n    response = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    return response.choices[0].message.content\n\ndef get_embedding(text):\n    client = OpenAI(api_key=API_KEY)\n    response = client.embeddings.create(\n        model=\"text-embedding-ada-002\",\n        input=text\n    )\n    return response.data[0].embedding\n```\n\n----------------------------------------\n\nTITLE: Creating and Running a Simple Flow Sequence in Python\nDESCRIPTION: Demonstrates how to create a minimal flow of two nodes in a chain and run it. The flow executes node_a, then node_b if the default action is returned.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/flow.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnode_a >> node_b\nflow = Flow(start=node_a)\nflow.run(shared)\n```\n\n----------------------------------------\n\nTITLE: Defining Agent Nodes for PocketFlow\nDESCRIPTION: Implementation of three core PocketFlow nodes: DecideAction for determining whether to search or answer, SearchWeb for retrieving information from the web, and AnswerQuestion for generating final responses based on accumulated context.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/demo.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# nodes.py\nfrom pocketflow import Node\nimport yaml\n\nclass DecideAction(Node):\n    def prep(self, shared):\n        \"\"\"Prepare the context and question for the decision-making process.\"\"\"\n        # Get the current context (default to \"No previous search\" if none exists)\n        context = shared.get(\"context\", \"No previous search\")\n        # Get the question from the shared store\n        question = shared[\"question\"]\n        # Return both for the exec step\n        return question, context\n\n    def exec(self, inputs):\n        \"\"\"Call the LLM to decide whether to search or answer.\"\"\"\n        question, context = inputs\n\n        print(f\"ü§î Agent deciding what to do next...\")\n\n        # Create a prompt to help the LLM decide what to do next with proper yaml formatting\n        prompt = f\"\"\"\n### CONTEXT\nYou are a research assistant that can search the web.\nQuestion: {question}\nPrevious Research: {context}\n\n### ACTION SPACE\n[1] search\n  Description: Look up more information on the web\n  Parameters:\n    - query (str): What to search for\n\n[2] answer\n  Description: Answer the question with current knowledge\n  Parameters:\n    - answer (str): Final answer to the question\n\n## NEXT ACTION\nDecide the next action based on the context and available actions.\nReturn your response in this format:\n\n```yaml\nthinking: |\n    <your step-by-step reasoning process>\naction: search OR answer\nreason: <why you chose this action>\nanswer: <if action is answer>\nsearch_query: <specific search query if action is search>\n```\nIMPORTANT: Make sure to:\n1. Use proper indentation (4 spaces) for all multi-line fields\n2. Use the | character for multi-line text fields\n3. Keep single-line fields without the | character\n\"\"\"\n\n        # Call the LLM to make a decision\n        response = call_llm(prompt)\n\n        # Parse the response to get the decision\n        yaml_str = response.split(\"```yaml\")[1].split(\"```\")[0].strip()\n        decision = yaml.safe_load(yaml_str)\n\n        return decision\n\n    def post(self, shared, prep_res, exec_res):\n        \"\"\"Save the decision and determine the next step in the flow.\"\"\"\n        # If LLM decided to search, save the search query\n        if exec_res[\"action\"] == \"search\":\n            shared[\"search_query\"] = exec_res[\"search_query\"]\n            print(f\"üîç Agent decided to search for: {exec_res['search_query']}\")\n        else:\n            shared[\"context\"] = exec_res[\"answer\"] #save the context if LLM gives the answer without searching.\n            print(f\"üí° Agent decided to answer the question\")\n\n        # Return the action to determine the next node in the flow\n        return exec_res[\"action\"]\n\nclass SearchWeb(Node):\n    def prep(self, shared):\n        \"\"\"Get the search query from the shared store.\"\"\"\n        return shared[\"search_query\"]\n\n    def exec(self, search_query):\n        \"\"\"Search the web for the given query.\"\"\"\n        # Call the search utility function\n        print(f\"üåê Searching the web for: {search_query}\")\n        results = search_web(search_query)\n        return results\n\n    def post(self, shared, prep_res, exec_res):\n        \"\"\"Save the search results and go back to the decision node.\"\"\"\n        # Add the search results to the context in the shared store\n        previous = shared.get(\"context\", \"\")\n        shared[\"context\"] = previous + \"\\n\\nSEARCH: \" + shared[\"search_query\"] + \"\\nRESULTS: \" + exec_res\n\n        print(f\"üìö Found information, analyzing results...\")\n\n        # Always go back to the decision node after searching\n        return \"decide\"\n\nclass AnswerQuestion(Node):\n    def prep(self, shared):\n        \"\"\"Get the question and context for answering.\"\"\"\n        return shared[\"question\"], shared.get(\"context\", \"\")\n\n    def exec(self, inputs):\n        \"\"\"Call the LLM to generate a final answer.\"\"\"\n        question, context = inputs\n\n        print(f\"‚úçÔ∏è Crafting final answer...\")\n\n        # Create a prompt for the LLM to answer the question\n        prompt = f\"\"\"\n### CONTEXT\nBased on the following information, answer the question.\nQuestion: {question}\nResearch: {context}\n\n## YOUR ANSWER:\nProvide a comprehensive answer using the research results.\n\"\"\"\n        # Call the LLM to generate an answer\n        answer = call_llm(prompt)\n        return answer\n\n    def post(self, shared, prep_res, exec_res):\n        \"\"\"Save the final answer and complete the flow.\"\"\"\n        # Save the answer in the shared store\n        shared[\"answer\"] = exec_res\n\n        print(f\"‚úÖ Answer generated successfully\")\n\n        # We're done - no need to continue the flow\n        return \"done\"\n```\n\n----------------------------------------\n\nTITLE: Setting up Chroma Vector Database in Python\nDESCRIPTION: Demonstrates the implementation of Chroma for vector storage and search. This example shows client initialization with local storage, collection creation, adding vectors with metadata, and performing vector similarity queries.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/vector.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport chromadb\nfrom chromadb.config import Settings\n\nclient = chromadb.Client(Settings(\n    chroma_db_impl=\"duckdb+parquet\",\n    persist_directory=\"./chroma_data\"\n))\n\ncoll = client.create_collection(\"my_collection\")\n\nvectors = [[0.1, 0.2, 0.3], [0.2, 0.2, 0.2]]\nmetas = [{\"doc\": \"text1\"}, {\"doc\": \"text2\"}]\nids = [\"id1\", \"id2\"]\ncoll.add(embeddings=vectors, metadatas=metas, ids=ids)\n\nres = coll.query(query_embeddings=[[0.15, 0.25, 0.3]], n_results=2)\nprint(res)\n```\n\n----------------------------------------\n\nTITLE: Flow Chaining Syntax in PocketFlow\nDESCRIPTION: Code examples showing the syntax for chaining nodes in PocketFlow. This demonstrates how to connect nodes using the '>>' operator for simple chains and directed branching with action strings.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nnode_1 >> node_2\n```\n\n----------------------------------------\n\nTITLE: Search Agent Implementation with Node Classes in Python\nDESCRIPTION: Complete implementation of a search agent using Node classes for decision making, web searching, and answer generation. Includes flow control and context management.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/agent.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass DecideAction(Node):\n    def prep(self, shared):\n        context = shared.get(\"context\", \"No previous search\")\n        query = shared[\"query\"]\n        return query, context\n        \n    def exec(self, inputs):\n        query, context = inputs\n        prompt = f\"\"\"\nGiven input: {query}\nPrevious search results: {context}\nShould I: 1) Search web for more info 2) Answer with current knowledge\nOutput in yaml:\n```yaml\naction: search/answer\nreason: why this action\nsearch_term: search phrase if action is search\n```\"\"\"\n        resp = call_llm(prompt)\n        yaml_str = resp.split(\"```yaml\")[1].split(\"```\")[0].strip()\n        result = yaml.safe_load(yaml_str)\n        \n        assert isinstance(result, dict)\n        assert \"action\" in result\n        assert \"reason\" in result\n        assert result[\"action\"] in [\"search\", \"answer\"]\n        if result[\"action\"] == \"search\":\n            assert \"search_term\" in result\n        \n        return result\n\n    def post(self, shared, prep_res, exec_res):\n        if exec_res[\"action\"] == \"search\":\n            shared[\"search_term\"] = exec_res[\"search_term\"]\n        return exec_res[\"action\"]\n\nclass SearchWeb(Node):\n    def prep(self, shared):\n        return shared[\"search_term\"]\n        \n    def exec(self, search_term):\n        return search_web(search_term)\n    \n    def post(self, shared, prep_res, exec_res):\n        prev_searches = shared.get(\"context\", [])\n        shared[\"context\"] = prev_searches + [\n            {\"term\": shared[\"search_term\"], \"result\": exec_res}\n        ]\n        return \"decide\"\n        \nclass DirectAnswer(Node):\n    def prep(self, shared):\n        return shared[\"query\"], shared.get(\"context\", \"\")\n        \n    def exec(self, inputs):\n        query, context = inputs\n        return call_llm(f\"Context: {context}\\nAnswer: {query}\")\n\n    def post(self, shared, prep_res, exec_res):\n       print(f\"Answer: {exec_res}\")\n       shared[\"answer\"] = exec_res\n\n# Connect nodes\ndecide = DecideAction()\nsearch = SearchWeb()\nanswer = DirectAnswer()\n\ndecide - \"search\" >> search\ndecide - \"answer\" >> answer\nsearch - \"decide\" >> decide  # Loop back\n\nflow = Flow(start=decide)\nflow.run({\"query\": \"Who won the Nobel Prize in Physics 2024?\"})\n```\n\n----------------------------------------\n\nTITLE: Implementing Offline Indexing Stage for RAG in Python\nDESCRIPTION: This code snippet defines three Node classes (ChunkDocs, EmbedDocs, StoreIndex) for the offline indexing stage of a RAG pipeline. It chunks documents, embeds the chunks, and stores them in a vector index.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/rag.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass ChunkDocs(BatchNode):\n    def prep(self, shared):\n        # A list of file paths in shared[\"files\"]. We process each file.\n        return shared[\"files\"]\n\n    def exec(self, filepath):\n        # read file content. In real usage, do error handling.\n        with open(filepath, \"r\", encoding=\"utf-8\") as f:\n            text = f.read()\n        # chunk by 100 chars each\n        chunks = []\n        size = 100\n        for i in range(0, len(text), size):\n            chunks.append(text[i : i + size])\n        return chunks\n    \n    def post(self, shared, prep_res, exec_res_list):\n        # exec_res_list is a list of chunk-lists, one per file.\n        # flatten them all into a single list of chunks.\n        all_chunks = []\n        for chunk_list in exec_res_list:\n            all_chunks.extend(chunk_list)\n        shared[\"all_chunks\"] = all_chunks\n\nclass EmbedDocs(BatchNode):\n    def prep(self, shared):\n        return shared[\"all_chunks\"]\n\n    def exec(self, chunk):\n        return get_embedding(chunk)\n\n    def post(self, shared, prep_res, exec_res_list):\n        # Store the list of embeddings.\n        shared[\"all_embeds\"] = exec_res_list\n        print(f\"Total embeddings: {len(exec_res_list)}\")\n\nclass StoreIndex(Node):\n    def prep(self, shared):\n        # We'll read all embeds from shared.\n        return shared[\"all_embeds\"]\n\n    def exec(self, all_embeds):\n        # Create a vector index (faiss or other DB in real usage).\n        index = create_index(all_embeds)\n        return index\n\n    def post(self, shared, prep_res, index):\n        shared[\"index\"] = index\n\n# Wire them in sequence\nchunk_node = ChunkDocs()\nembed_node = EmbedDocs()\nstore_node = StoreIndex()\n\nchunk_node >> embed_node >> store_node\n\nOfflineFlow = Flow(start=chunk_node)\n```\n\n----------------------------------------\n\nTITLE: Creating Document Embeddings and FAISS Index\nDESCRIPTION: This class processes a collection of documents, generates embeddings for each document, and creates a FAISS index for efficient similarity search. The embeddings are stored in an L2 distance-based index for later retrieval.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass PrepareEmbeddings(Node):\n    def prep(self, shared):\n        # Get list of (filename, content) pairs\n        return list(shared[\"data\"].items())\n        \n    def exec(self, items):\n        # Create embeddings for each document\n        embeddings = []\n        filenames = []\n        for filename, content in items:\n            embedding = get_embedding(content)\n            embeddings.append(embedding)\n            filenames.append(filename)\n            \n        # Create FAISS index\n        dim = len(embeddings[0])\n        index = faiss.IndexFlatL2(dim)\n        index.add(np.array(embeddings).astype('float32'))\n        \n        return index, filenames\n    \n    def post(self, shared, prep_res, exec_res):\n        # Store index and filenames in shared store\n        index, filenames = exec_res\n        shared[\"search_index\"] = index\n        shared[\"filenames\"] = filenames\n        return \"default\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Interactive Multi-Agent Taboo Game in Python\nDESCRIPTION: This snippet showcases a more complex multi-agent system where two agents play the word-guessing game Taboo. It includes AsyncHinter and AsyncGuesser classes that communicate asynchronously to provide hints and make guesses.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/multi_agent.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass AsyncHinter(AsyncNode):\n    async def prep_async(self, shared):\n        guess = await shared[\"hinter_queue\"].get()\n        if guess == \"GAME_OVER\":\n            return None\n        return shared[\"target_word\"], shared[\"forbidden_words\"], shared.get(\"past_guesses\", [])\n\n    async def exec_async(self, inputs):\n        if inputs is None:\n            return None\n        target, forbidden, past_guesses = inputs\n        prompt = f\"Generate hint for '{target}'\\nForbidden words: {forbidden}\"\n        if past_guesses:\n            prompt += f\"\\nPrevious wrong guesses: {past_guesses}\\nMake hint more specific.\"\n        prompt += \"\\nUse at most 5 words.\"\n        \n        hint = call_llm(prompt)\n        print(f\"\\nHinter: Here's your hint - {hint}\")\n        return hint\n\n    async def post_async(self, shared, prep_res, exec_res):\n        if exec_res is None:\n            return \"end\"\n        await shared[\"guesser_queue\"].put(exec_res)\n        return \"continue\"\n\nclass AsyncGuesser(AsyncNode):\n    async def prep_async(self, shared):\n        hint = await shared[\"guesser_queue\"].get()\n        return hint, shared.get(\"past_guesses\", [])\n\n    async def exec_async(self, inputs):\n        hint, past_guesses = inputs\n        prompt = f\"Given hint: {hint}, past wrong guesses: {past_guesses}, make a new guess. Directly reply a single word:\"\n        guess = call_llm(prompt)\n        print(f\"Guesser: I guess it's - {guess}\")\n        return guess\n\n    async def post_async(self, shared, prep_res, exec_res):\n        if exec_res.lower() == shared[\"target_word\"].lower():\n            print(\"Game Over - Correct guess!\")\n            await shared[\"hinter_queue\"].put(\"GAME_OVER\")\n            return \"end\"\n            \n        if \"past_guesses\" not in shared:\n            shared[\"past_guesses\"] = []\n        shared[\"past_guesses\"].append(exec_res)\n        \n        await shared[\"hinter_queue\"].put(exec_res)\n        return \"continue\"\n\nasync def main():\n    # Set up game\n    shared = {\n        \"target_word\": \"nostalgia\",\n        \"forbidden_words\": [\"memory\", \"past\", \"remember\", \"feeling\", \"longing\"],\n        \"hinter_queue\": asyncio.Queue(),\n        \"guesser_queue\": asyncio.Queue()\n    }\n    \n    print(\"Game starting!\")\n    print(f\"Target word: {shared['target_word']}\")\n    print(f\"Forbidden words: {shared['forbidden_words']}\")\n\n    # Initialize by sending empty guess to hinter\n    await shared[\"hinter_queue\"].put(\"\")\n\n    # Create nodes and flows\n    hinter = AsyncHinter()\n    guesser = AsyncGuesser()\n\n    # Set up flows\n    hinter_flow = AsyncFlow(start=hinter)\n    guesser_flow = AsyncFlow(start=guesser)\n\n    # Connect nodes to themselves\n    hinter - \"continue\" >> hinter\n    guesser - \"continue\" >> guesser\n\n    # Run both agents concurrently\n    await asyncio.gather(\n        hinter_flow.run_async(shared),\n        guesser_flow.run_async(shared)\n    )\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing Agent Communication with asyncio.Queue in Python\nDESCRIPTION: This snippet demonstrates a simple multi-agent system where agents communicate using an asyncio.Queue. It includes an AgentNode class that listens for messages, and a system message sender that simulates periodic updates.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/multi_agent.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass AgentNode(AsyncNode):\n    async def prep_async(self, _):\n        message_queue = self.params[\"messages\"]\n        message = await message_queue.get()\n        print(f\"Agent received: {message}\")\n        return message\n\n# Create node and flow\nagent = AgentNode()\nagent >> agent  # connect to self\nflow = AsyncFlow(start=agent)\n\n# Create heartbeat sender\nasync def send_system_messages(message_queue):\n    counter = 0\n    messages = [\n        \"System status: all systems operational\",\n        \"Memory usage: normal\",\n        \"Network connectivity: stable\",\n        \"Processing load: optimal\"\n    ]\n    \n    while True:\n        message = f\"{messages[counter % len(messages)]} | timestamp_{counter}\"\n        await message_queue.put(message)\n        counter += 1\n        await asyncio.sleep(1)\n\nasync def main():\n    message_queue = asyncio.Queue()\n    shared = {}\n    flow.set_params({\"messages\": message_queue})\n    \n    # Run both coroutines\n    await asyncio.gather(\n        flow.run_async(shared),\n        send_system_messages(message_queue)\n    )\n    \nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Finding Relevant Documents Based on User Queries\nDESCRIPTION: This class handles user queries, converts them to embeddings, and searches the FAISS index to find the most semantically similar document. It uses the same embedding function as the document processing to ensure compatibility.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclass FindRelevantDocument(Node):\n    def prep(self, shared):\n        # Get user question\n        question = input(\"Enter your question (or press Enter to quit): \")\n        if not question:\n            return None\n        return question\n        \n    def exec(self, question):\n        if question is None:\n            return None\n            \n        # Get question embedding and search\n        query_embedding = get_embedding(question)\n        \n        # Search for most similar document\n        D, I = shared[\"search_index\"].search(\n            np.array([query_embedding]).astype('float32'),\n            k=1\n        )\n        most_relevant_idx = I[0][0]\n        most_relevant_file = shared[\"filenames\"][most_relevant_idx]\n        \n        return question, most_relevant_file\n        \n    def post(self, shared, prep_res, exec_res):\n        if exec_res is None:\n            return \"end\"\n            \n```\n\n----------------------------------------\n\nTITLE: Implementing Article Writing Workflow with Multiple LLM Nodes in Python\nDESCRIPTION: This code demonstrates how to implement a three-stage article writing workflow using the Node pattern. It creates nodes for outline generation, content writing, and review/refinement, connecting them in sequence and executing the workflow with a shared context.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/workflow.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass GenerateOutline(Node):\n    def prep(self, shared): return shared[\"topic\"]\n    def exec(self, topic): return call_llm(f\"Create a detailed outline for an article about {topic}\")\n    def post(self, shared, prep_res, exec_res): shared[\"outline\"] = exec_res\n\nclass WriteSection(Node):\n    def prep(self, shared): return shared[\"outline\"]\n    def exec(self, outline): return call_llm(f\"Write content based on this outline: {outline}\")\n    def post(self, shared, prep_res, exec_res): shared[\"draft\"] = exec_res\n\nclass ReviewAndRefine(Node):\n    def prep(self, shared): return shared[\"draft\"]\n    def exec(self, draft): return call_llm(f\"Review and improve this draft: {draft}\")\n    def post(self, shared, prep_res, exec_res): shared[\"final_article\"] = exec_res\n\n# Connect nodes\noutline = GenerateOutline()\nwrite = WriteSection()\nreview = ReviewAndRefine()\n\noutline >> write >> review\n\n# Create and run flow\nwriting_flow = Flow(start=outline)\nshared = {\"topic\": \"AI Safety\"}\nwriting_flow.run(shared)\n```\n\n----------------------------------------\n\nTITLE: Implementing BatchNode for Chunk-based Text Summarization in Python\nDESCRIPTION: This snippet demonstrates how to use BatchNode to summarize a large file by breaking it into chunks. The prep() method splits the content, exec() summarizes each chunk, and post() combines the results.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/batch.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass MapSummaries(BatchNode):\n    def prep(self, shared):\n        # Suppose we have a big file; chunk it\n        content = shared[\"data\"]\n        chunk_size = 10000\n        chunks = [content[i:i+chunk_size] for i in range(0, len(content), chunk_size)]\n        return chunks\n\n    def exec(self, chunk):\n        prompt = f\"Summarize this chunk in 10 words: {chunk}\"\n        summary = call_llm(prompt)\n        return summary\n\n    def post(self, shared, prep_res, exec_res_list):\n        combined = \"\\n\".join(exec_res_list)\n        shared[\"summary\"] = combined\n        return \"default\"\n\nmap_summaries = MapSummaries()\nflow = Flow(start=map_summaries)\nflow.run(shared)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Batch Summarization Node in PocketFlow for Text Processing\nDESCRIPTION: This code implements a BatchSummarizeNode class that extends PocketFlow's BatchNode. It processes text files in batches by reading from a shared store, calling an LLM to summarize each text into 50 words, and writing the summaries back to the shared store. The implementation includes the required prep, exec, and post methods for the BatchNode lifecycle.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pocketflow import BatchNode\nimport os\n\nclass BatchSummarizeNode(BatchNode):\n    def prep(self, shared):\n        # Return list of (filename, content) tuples from shared store\n        return [(fn, content) for fn, content in shared[\"data\"].items()]\n        \n    def exec(self, item):\n        # Unpack the filename and content\n        filename, text = item\n        # Call LLM to summarize\n        prompt = f\"Summarize this text in 50 words:\\n\\n{text}\"\n        summary = call_llm(prompt)\n        return filename, summary\n    \n    def post(self, shared, prep_res, exec_res_list):\n        # Store all summaries in a dict by filename\n        shared[\"summaries\"] = {\n            filename: summary \n            for filename, summary in exec_res_list\n        }\n        return \"default\"\n\n# Create test data structure\nshared = {\n    \"data\": {},\n    \"summaries\": {}\n}\n\n# Load all files from the directory\npath = \"./data/PaulGrahamEssaysLarge\"\nfor filename in os.listdir(path):\n    with open(os.path.join(path, filename), \"r\") as f:\n        shared[\"data\"][filename] = f.read()\n\n# Create and run the batch node\nbatch_summarize = BatchSummarizeNode()\nbatch_summarize.run(shared)\n```\n\n----------------------------------------\n\nTITLE: Implementing Claude (Anthropic) LLM Wrapper in Python\nDESCRIPTION: This snippet shows how to create a wrapper function for the Anthropic API. It uses the Anthropic client to send a message and returns the generated content.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/llm.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef call_llm(prompt):\n    from anthropic import Anthropic\n    client = Anthropic(api_key=\"YOUR_API_KEY_HERE\")\n    r = client.messages.create(\n        model=\"claude-3-7-sonnet-20250219\",\n        max_tokens=3000,\n        messages=[\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n    )\n    return r.content[0].text\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Node with Multiple Async Stages in Python\nDESCRIPTION: Demonstrates implementation of an AsyncNode subclass that performs document summarization with user verification. Uses async methods for file reading, LLM processing, and user feedback collection. Shows integration with AsyncFlow and transition definitions.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/async.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass SummarizeThenVerify(AsyncNode):\n    async def prep_async(self, shared):\n        # Example: read a file asynchronously\n        doc_text = await read_file_async(shared[\"doc_path\"])\n        return doc_text\n\n    async def exec_async(self, prep_res):\n        # Example: async LLM call\n        summary = await call_llm_async(f\"Summarize: {prep_res}\")\n        return summary\n\n    async def post_async(self, shared, prep_res, exec_res):\n        # Example: wait for user feedback\n        decision = await gather_user_feedback(exec_res)\n        if decision == \"approve\":\n            shared[\"summary\"] = exec_res\n            return \"approve\"\n        return \"deny\"\n\nsummarize_node = SummarizeThenVerify()\nfinal_node = Finalize()\n\n# Define transitions\nsummarize_node - \"approve\" >> final_node\nsummarize_node - \"deny\"    >> summarize_node  # retry\n\nflow = AsyncFlow(start=summarize_node)\n\nasync def main():\n    shared = {\"doc_path\": \"document.txt\"}\n    await flow.run_async(shared)\n    print(\"Final Summary:\", shared.get(\"summary\"))\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing a File Summarization Node in Python\nDESCRIPTION: This comprehensive example demonstrates a complete Node implementation for summarizing file content. It includes prep, exec, exec_fallback, and post methods, showcasing how to handle shared data, call an LLM, and implement fallback logic.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/node.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass SummarizeFile(Node):\n    def prep(self, shared):\n        return shared[\"data\"]\n\n    def exec(self, prep_res):\n        if not prep_res:\n            return \"Empty file content\"\n        prompt = f\"Summarize this text in 10 words: {prep_res}\"\n        summary = call_llm(prompt)  # might fail\n        return summary\n\n    def exec_fallback(self, prep_res, exc):\n        # Provide a simple fallback instead of crashing\n        return \"There was an error processing your request.\"\n\n    def post(self, shared, prep_res, exec_res):\n        shared[\"summary\"] = exec_res\n        # Return \"default\" by not returning\n\nsummarize_node = SummarizeFile(max_retries=3)\n\n# node.run() calls prep->exec->post\n# If exec() fails, it retries up to 3 times before calling exec_fallback()\naction_result = summarize_node.run(shared)\n\nprint(\"Action returned:\", action_result)  # \"default\"\nprint(\"Summary stored:\", shared[\"summary\"])\n```\n\n----------------------------------------\n\nTITLE: Using Online Query & Answer Flow for RAG in Python\nDESCRIPTION: This code snippet demonstrates how to use the OnlineFlow defined for the RAG pipeline. It assumes the OfflineFlow has already been run, and sets up a question in the shared dictionary before running the flow.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/rag.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Suppose we already ran OfflineFlow and have:\n# shared[\"all_chunks\"], shared[\"index\"], etc.\nshared[\"question\"] = \"Why do people like cats?\"\n\nOnlineFlow.run(shared)\n# final answer in shared[\"answer\"]\n```\n\n----------------------------------------\n\nTITLE: Generating Text Embeddings with Cohere in Python\nDESCRIPTION: Example code showing how to create embeddings using Cohere's API. Requires an API key and provides a straightforward interface for transforming text into vector representations.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/embedding.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport cohere\n\nco = cohere.Client(\"YOUR_API_KEY\")\nresp = co.embed(texts=[\"Hello world\"])\nvec = resp.embeddings[0]\nprint(vec)\n```\n\n----------------------------------------\n\nTITLE: Defining Branching and Looping Flow in Python\nDESCRIPTION: Shows how to create a more complex flow with branching and looping for an expense approval process. It demonstrates different actions leading to different nodes and creating loops.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/flow.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Define the flow connections\nreview - \"approved\" >> payment        # If approved, process payment\nreview - \"needs_revision\" >> revise   # If needs changes, go to revision\nreview - \"rejected\" >> finish         # If rejected, finish the process\n\nrevise >> review   # After revision, go back for another review\npayment >> finish  # After payment, finish the process\n\nflow = Flow(start=review)\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Text Summarization with AsyncParallelBatchNode\nDESCRIPTION: Demonstrates how to create a parallel batch node for concurrent text summarization using AsyncParallelBatchNode. The implementation includes methods for preparation, execution, and post-processing of multiple text summaries simultaneously.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/parallel.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass ParallelSummaries(AsyncParallelBatchNode):\n    async def prep_async(self, shared):\n        # e.g., multiple texts\n        return shared[\"texts\"]\n\n    async def exec_async(self, text):\n        prompt = f\"Summarize: {text}\"\n        return await call_llm_async(prompt)\n\n    async def post_async(self, shared, prep_res, exec_res_list):\n        shared[\"summary\"] = \"\\n\\n\".join(exec_res_list)\n        return \"default\"\n\nnode = ParallelSummaries()\nflow = AsyncFlow(start=node)\n```\n\n----------------------------------------\n\nTITLE: Implementing BatchFlow for Multi-file Summarization in Python\nDESCRIPTION: This example shows how to use BatchFlow to summarize multiple files. The prep() method generates a list of parameter dictionaries, one for each file to be processed. The BatchFlow then runs a summarization flow for each file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/batch.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass SummarizeAllFiles(BatchFlow):\n    def prep(self, shared):\n        # Return a list of param dicts (one per file)\n        filenames = list(shared[\"data\"].keys())  # e.g., [\"file1.txt\", \"file2.txt\", ...]\n        return [{\"filename\": fn} for fn in filenames]\n\n# Suppose we have a per-file Flow (e.g., load_file >> summarize >> reduce):\nsummarize_file = SummarizeFile(start=load_file)\n\n# Wrap that flow into a BatchFlow:\nsummarize_all_files = SummarizeAllFiles(start=summarize_file)\nsummarize_all_files.run(shared)\n```\n\n----------------------------------------\n\nTITLE: Implementing Map Reduce for Document Summarization in Python using PocketFlow\nDESCRIPTION: This code demonstrates how to use the Map Reduce pattern in PocketFlow for summarizing multiple documents. It uses a BatchNode for the map phase to summarize individual files and a regular Node for the reduce phase to combine summaries.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/mapreduce.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass SummarizeAllFiles(BatchNode):\n    def prep(self, shared):\n        files_dict = shared[\"files\"]  # e.g. 10 files\n        return list(files_dict.items())  # [(\"file1.txt\", \"aaa...\"), (\"file2.txt\", \"bbb...\"), ...]\n\n    def exec(self, one_file):\n        filename, file_content = one_file\n        summary_text = call_llm(f\"Summarize the following file:\\n{file_content}\")\n        return (filename, summary_text)\n\n    def post(self, shared, prep_res, exec_res_list):\n        shared[\"file_summaries\"] = dict(exec_res_list)\n\nclass CombineSummaries(Node):\n    def prep(self, shared):\n        return shared[\"file_summaries\"]\n\n    def exec(self, file_summaries):\n        # format as: \"File1: summary\\nFile2: summary...\\n\"\n        text_list = []\n        for fname, summ in file_summaries.items():\n            text_list.append(f\"{fname} summary:\\n{summ}\\n\")\n        big_text = \"\\n---\\n\".join(text_list)\n\n        return call_llm(f\"Combine these file summaries into one final summary:\\n{big_text}\")\n\n    def post(self, shared, prep_res, final_summary):\n        shared[\"all_files_summary\"] = final_summary\n\nbatch_node = SummarizeAllFiles()\ncombine_node = CombineSummaries()\nbatch_node >> combine_node\n\nflow = Flow(start=batch_node)\n\nshared = {\n    \"files\": {\n        \"file1.txt\": \"Alice was beginning to get very tired of sitting by her sister...\",\n        \"file2.txt\": \"Some other interesting text ...\",\n        # ...\n    }\n}\nflow.run(shared)\nprint(\"Individual Summaries:\", shared[\"file_summaries\"])\nprint(\"\\nFinal Summary:\\n\", shared[\"all_files_summary\"])\n```\n\n----------------------------------------\n\nTITLE: Implementing Agent Decision Prompt Template in Python\nDESCRIPTION: A template for creating agent decision prompts that include context, action space definitions, and expected response format using YAML.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/agent.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nf\"\"\"\n### CONTEXT\nTask: {task_description}\nPrevious Actions: {previous_actions}\nCurrent State: {current_state}\n\n### ACTION SPACE\n[1] search\n  Description: Use web search to get results\n  Parameters:\n    - query (str): What to search for\n\n[2] answer\n  Description: Conclude based on the results\n  Parameters:\n    - result (str): Final answer to provide\n\n### NEXT ACTION\nDecide the next action based on the current context and available action space.\nReturn your response in the following format:\n\n```yaml\nthinking: |\n    <your step-by-step reasoning process>\naction: <action_name>\nparameters:\n    <parameter_name>: <parameter_value>\n```\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Text Summarization Node in PocketFlow with Python\nDESCRIPTION: This code defines a SummarizeNode class that extends the Node class from the PocketFlow framework. The node has three key methods: prep() to read text from a shared store, exec() to call an LLM for summarization, and post() to store the summary back in the shared store. The code also includes test functionality that loads text from a file and executes the node.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pocketflow import Node\n\nclass SummarizeNode(Node):\n    def prep(self, shared):\n        # Read data from shared store\n        return shared[\"data\"][\"before.txt\"]\n        \n    def exec(self, text):\n        # Call LLM to summarize\n        prompt = f\"Summarize this text in 50 words:\\n\\n{text}\"\n        return call_llm(prompt)\n    \n    def post(self, shared, prep_res, exec_res):\n        # Store the summary back\n        shared[\"summary\"] = exec_res\n        # No specific next action needed\n        return \"default\"\n\n# Create test data\nshared = {\n    \"data\": {},\n    \"summary\": None\n}\n\n# Load the file\nwith open(\"./data/PaulGrahamEssaysLarge/before.txt\", \"r\") as f:\n    shared[\"data\"][\"before.txt\"] = f.read()\n\n# Create and run the node\nsummarize_node = SummarizeNode()\nsummarize_node.run(shared)\n```\n\n----------------------------------------\n\nTITLE: Implementing Node Communication with Shared Store in Python\nDESCRIPTION: Illustrates how nodes in a PocketFlow communicate using the shared store. The LoadData node writes to the store, while the Summarize node reads from it, processes the data, and writes the result back to the store.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/communication.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass LoadData(Node):\n    def post(self, shared, prep_res, exec_res):\n        # We write data to shared store\n        shared[\"data\"] = \"Some text content\"\n        return None\n\nclass Summarize(Node):\n    def prep(self, shared):\n        # We read data from shared store\n        return shared[\"data\"]\n\n    def exec(self, prep_res):\n        # Call LLM to summarize\n        prompt = f\"Summarize: {prep_res}\"\n        summary = call_llm(prompt)\n        return summary\n\n    def post(self, shared, prep_res, exec_res):\n        # We write summary to shared store\n        shared[\"summary\"] = exec_res\n        return \"default\"\n\nload_data = LoadData()\nsummarize = Summarize()\nload_data >> summarize\nflow = Flow(start=load_data)\n\nshared = {}\nflow.run(shared)\n```\n\n----------------------------------------\n\nTITLE: Implementing Text Summarization with Structured Output\nDESCRIPTION: A Python Node implementation that prompts an LLM to summarize text into a YAML-structured output with validation. The code demonstrates how to extract and parse the structured response from the LLM.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/structure.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass SummarizeNode(Node):\n    def exec(self, prep_res):\n        # Suppose `prep_res` is the text to summarize.\n        prompt = f\"\"\"\nPlease summarize the following text as YAML, with exactly 3 bullet points\n\n{prep_res}\n\nNow, output:\n```yaml\nsummary:\n  - bullet 1\n  - bullet 2\n  - bullet 3\n```\"\"\"\n        response = call_llm(prompt)\n        yaml_str = response.split(\"```yaml\")[1].split(\"```\")[0].strip()\n\n        import yaml\n        structured_result = yaml.safe_load(yaml_str)\n\n        assert \"summary\" in structured_result\n        assert isinstance(structured_result[\"summary\"], list)\n\n        return structured_result\n```\n\n----------------------------------------\n\nTITLE: Creating Parallel File Processing Flow with AsyncParallelBatchFlow\nDESCRIPTION: Shows how to implement parallel file processing using AsyncParallelBatchFlow. The implementation enables concurrent processing of multiple files by running separate instances of a sub-flow for each file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/parallel.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass SummarizeMultipleFiles(AsyncParallelBatchFlow):\n    async def prep_async(self, shared):\n        return [{\"filename\": f} for f in shared[\"files\"]]\n\nsub_flow = AsyncFlow(start=LoadAndSummarizeFile())\nparallel_flow = SummarizeMultipleFiles(start=sub_flow)\nawait parallel_flow.run_async(shared)\n```\n\n----------------------------------------\n\nTITLE: Extracting PocketFlow Node Call Stack for Debugging\nDESCRIPTION: A utility function that inspects the runtime call stack to extract the hierarchy of PocketFlow nodes currently being executed, useful for debugging complex flow executions and understanding execution context.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/viz.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\ndef get_node_call_stack():\n    stack = inspect.stack()\n    node_names = []\n    seen_ids = set()\n    for frame_info in stack[1:]:\n        local_vars = frame_info.frame.f_locals\n        if 'self' in local_vars:\n            caller_self = local_vars['self']\n            if isinstance(caller_self, BaseNode) and id(caller_self) not in seen_ids:\n                seen_ids.add(id(caller_self))\n                node_names.append(type(caller_self).__name__)\n    return node_names\n```\n\n----------------------------------------\n\nTITLE: Configuring Qdrant Vector Database in Python\nDESCRIPTION: Illustrates how to set up and use Qdrant for vector search operations. This example covers client creation, collection setup with cosine distance metric, point insertion with payloads, and vector similarity search.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/vector.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport qdrant_client\nfrom qdrant_client.models import Distance, VectorParams, PointStruct\n\nclient = qdrant_client.QdrantClient(\n    url=\"https://YOUR-QDRANT-CLOUD-ENDPOINT\",\n    api_key=\"YOUR_API_KEY\"\n)\n\ncollection = \"my_collection\"\nclient.recreate_collection(\n    collection_name=collection,\n    vectors_config=VectorParams(size=128, distance=Distance.COSINE)\n)\n\npoints = [\n    PointStruct(id=1, vector=[0.1]*128, payload={\"type\": \"doc1\"}),\n    PointStruct(id=2, vector=[0.2]*128, payload={\"type\": \"doc2\"}),\n]\n\nclient.upsert(collection_name=collection, points=points)\n\nresults = client.search(\n    collection_name=collection,\n    query_vector=[0.15]*128,\n    limit=2\n)\nprint(results)\n```\n\n----------------------------------------\n\nTITLE: Directed Branching in PocketFlow\nDESCRIPTION: Example of directed branching in PocketFlow where an action string determines the path. The Node's post() method returns an action string that determines which path to follow.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nnode_1 - \"action\" ->> node_2\n```\n\n----------------------------------------\n\nTITLE: Implementing PocketFlow Nodes for Q&A System\nDESCRIPTION: Defines two main nodes: GetQuestionNode for handling user input and AnswerNode for processing questions through an LLM. Each node implements prep, exec, and post methods for data flow control.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/guide.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# nodes.py\nfrom pocketflow import Node\nfrom utils.call_llm import call_llm\n\nclass GetQuestionNode(Node):\n    def exec(self, _):\n        # Get question directly from user input\n        user_question = input(\"Enter your question: \")\n        return user_question\n    \n    def post(self, shared, prep_res, exec_res):\n        # Store the user's question\n        shared[\"question\"] = exec_res\n        return \"default\"  # Go to the next node\n\nclass AnswerNode(Node):\n    def prep(self, shared):\n        # Read question from shared\n        return shared[\"question\"]\n    \n    def exec(self, question):\n        # Call LLM to get the answer\n        return call_llm(question)\n    \n    def post(self, shared, prep_res, exec_res):\n        # Store the answer in shared\n        shared[\"answer\"] = exec_res\n```\n\n----------------------------------------\n\nTITLE: PocketFlow Q&A System Entry Point\nDESCRIPTION: Main application entry point that initializes shared state, creates the Q&A flow, and executes it. Demonstrates how to run the flow and access results from shared state.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/guide.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# main.py\nfrom flow import create_qa_flow\n\n# Example main function\n# Please replace this with your own main function\ndef main():\n    shared = {\n        \"question\": None,  # Will be populated by GetQuestionNode from user input\n        \"answer\": None     # Will be populated by AnswerNode\n    }\n\n    # Create the flow and run it\n    qa_flow = create_qa_flow()\n    qa_flow.run(shared)\n    print(f\"Question: {shared['question']}\")\n    print(f\"Answer: {shared['answer']}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested BatchFlows for Directory and File Processing in Python\nDESCRIPTION: This snippet demonstrates how to nest BatchFlows for multi-level batch processing. It processes multiple directories, each containing multiple files. The outer BatchFlow handles directories, while the inner BatchFlow processes files within each directory.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/batch.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass FileBatchFlow(BatchFlow):\n    def prep(self, shared):\n        directory = self.params[\"directory\"]\n        # e.g., files = [\"file1.txt\", \"file2.txt\", ...]\n        files = [f for f in os.listdir(directory) if f.endswith(\".txt\")]\n        return [{\"filename\": f} for f in files]\n\nclass DirectoryBatchFlow(BatchFlow):\n    def prep(self, shared):\n        directories = [ \"/path/to/dirA\", \"/path/to/dirB\"]\n        return [{\"directory\": d} for d in directories]\n\n# MapSummaries have params like {\"directory\": \"/path/to/dirA\", \"filename\": \"file1.txt\"}\ninner_flow = FileBatchFlow(start=MapSummaries())\nouter_flow = DirectoryBatchFlow(start=inner_flow)\n```\n\n----------------------------------------\n\nTITLE: Implementing Sentence-Based Chunking in Python with NLTK\nDESCRIPTION: A more contextually aware chunking method that uses NLTK to split text by sentences and then groups a specified number of sentences together. This approach preserves sentence boundaries but may not handle very long sentences or paragraphs effectively.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/chunking.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport nltk\n\ndef sentence_based_chunk(text, max_sentences=2):\n    sentences = nltk.sent_tokenize(text)\n    chunks = []\n    for i in range(0, len(sentences), max_sentences):\n        chunks.append(\" \".join(sentences[i : i + max_sentences]))\n    return chunks\n```\n\n----------------------------------------\n\nTITLE: Creating Embeddings with Hugging Face in Python\nDESCRIPTION: Code snippet for generating embeddings using Hugging Face's Inference API. Uses the sentence-transformers/all-MiniLM-L6-v2 model through a REST API call to transform text into vector representations.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/embedding.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport requests\n\nAPI_URL = \"https://api-inference.huggingface.co/models/sentence-transformers/all-MiniLM-L6-v2\"\nHEADERS = {\"Authorization\": \"Bearer YOUR_HF_TOKEN\"}\n\nres = requests.post(API_URL, headers=HEADERS, json={\"inputs\": \"Hello world\"})\nvec = res.json()[0]\nprint(vec)\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Flows in Python\nDESCRIPTION: Demonstrates how to create a nested flow structure by using a flow as a node within another flow. This allows for powerful composition patterns and reuse of smaller flows.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/flow.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Create a sub-flow\nnode_a >> node_b\nsubflow = Flow(start=node_a)\n\n# Connect it to another node\nsubflow >> node_c\n\n# Create the parent flow\nparent_flow = Flow(start=subflow)\n```\n\n----------------------------------------\n\nTITLE: Designing Shared Store for LLM System in Python\nDESCRIPTION: This snippet illustrates the design of a shared store using a Python dictionary. It demonstrates nested structures for storing user context and results, which is crucial for data management in LLM systems.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/guide.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nshared = {\n    \"user\": {\n        \"id\": \"user123\",\n        \"context\": {                # Another nested dict\n            \"weather\": {\"temp\": 72, \"condition\": \"sunny\"},\n            \"location\": \"San Francisco\"\n        }\n    },\n    \"results\": {}                   # Empty dict to store outputs\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Embeddings with Jina AI in Python\nDESCRIPTION: Example code for creating text embeddings using Jina AI's API. Sends a POST request to the Jina API endpoint with the input text and specified model (jina-embeddings-v3) to receive vector representations.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/embedding.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport requests\n\nurl = \"https://api.jina.ai/v2/embed\"\nheaders = {\"Authorization\": \"Bearer YOUR_JINA_TOKEN\"}\npayload = {\"data\": [\"Hello world\"], \"model\": \"jina-embeddings-v3\"}\nres = requests.post(url, headers=headers, json=payload)\nvec = res.json()[\"data\"][0][\"embedding\"]\nprint(vec)\n```\n\n----------------------------------------\n\nTITLE: Implementing Milvus Vector Database in Python\nDESCRIPTION: Shows how to use Milvus for vector similarity search with PyMilvus. This example demonstrates connecting to Milvus, defining a collection schema, inserting vector data, creating an IVF_FLAT index, and performing similarity search.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/vector.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pymilvus import connections, FieldSchema, CollectionSchema, DataType, Collection\nimport numpy as np\n\nconnections.connect(alias=\"default\", host=\"localhost\", port=\"19530\")\n\nfields = [\n    FieldSchema(name=\"id\", dtype=DataType.INT64, is_primary=True),\n    FieldSchema(name=\"embedding\", dtype=DataType.FLOAT_VECTOR, dim=128)\n]\nschema = CollectionSchema(fields)\ncollection = Collection(\"MyCollection\", schema)\n\nemb = np.random.rand(10, 128).astype('float32')\nids = list(range(10))\ncollection.insert([ids, emb])\n\nindex_params = {\n    \"index_type\": \"IVF_FLAT\",\n    \"params\": {\"nlist\": 128},\n    \"metric_type\": \"L2\"\n}\ncollection.create_index(\"embedding\", index_params)\ncollection.load()\n\nquery_emb = np.random.rand(1, 128).astype('float32')\nresults = collection.search(query_emb, \"embedding\", param={\"nprobe\": 10}, limit=3)\nprint(results)\n```\n\n----------------------------------------\n\nTITLE: RAG Flow Setup and Execution\nDESCRIPTION: Sets up and executes the RAG flow by loading document data, creating nodes, establishing connections between nodes, and running the flow with shared context.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Create test data\nshared = {\"data\": {}}\n\n# Load all files\npath = \"./data/PaulGrahamEssaysLarge\"\nfor filename in os.listdir(path):\n    with open(os.path.join(path, filename), \"r\") as f:\n        shared[\"data\"][filename] = f.read()\n\n# Create nodes and flow\nprep_embeddings = PrepareEmbeddings()\nfind_relevant = FindRelevantDocument()\nanswer = AnswerQuestion()\n\n# Connect nodes\nprep_embeddings >> find_relevant\nfind_relevant - \"answer\" >> answer\nfind_relevant - \"end\" >> None\nanswer - \"continue\" >> find_relevant\n\n# Create and run flow\nrag_flow = Flow(start=prep_embeddings)\nrag_flow.run(shared)\n```\n\n----------------------------------------\n\nTITLE: Implementing Graceful Fallback for Node Execution in Python\nDESCRIPTION: This snippet shows how to implement a graceful fallback method for a Node. By default, it re-raises the exception, but it can be overridden to return a fallback result instead.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/node.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef exec_fallback(self, prep_res, exc):\n    raise exc\n```\n\n----------------------------------------\n\nTITLE: Using Params for Node Configuration in Python\nDESCRIPTION: Demonstrates how to use Params for node-specific configuration in PocketFlow. The SummarizeFile node uses a filename parameter to process specific files. The example shows how to set params for both individual nodes and flows.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/communication.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass SummarizeFile(Node):\n    def prep(self, shared):\n        # Access the node's param\n        filename = self.params[\"filename\"]\n        return shared[\"data\"].get(filename, \"\")\n\n    def exec(self, prep_res):\n        prompt = f\"Summarize: {prep_res}\"\n        return call_llm(prompt)\n\n    def post(self, shared, prep_res, exec_res):\n        filename = self.params[\"filename\"]\n        shared[\"summary\"][filename] = exec_res\n        return \"default\"\n\n# 2) Set params\nnode = SummarizeFile()\n\n# 3) Set Node params directly (for testing)\nnode.set_params({\"filename\": \"doc1.txt\"})\nnode.run(shared)\n\n# 4) Create Flow\nflow = Flow(start=node)\n\n# 5) Set Flow params (overwrites node params)\nflow.set_params({\"filename\": \"doc2.txt\"})\nflow.run(shared)  # The node summarizes doc2, not doc1\n```\n\n----------------------------------------\n\nTITLE: Initializing Shared Store in Python\nDESCRIPTION: Demonstrates the structure of a typical shared store in PocketFlow, implemented as a Python dictionary. This shared store can contain various data types and is accessible by all nodes in the flow.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/communication.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nshared = {\"data\": {}, \"summary\": {}, \"config\": {...}, ...}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ollama (Local LLM) Wrapper in Python\nDESCRIPTION: This snippet demonstrates how to create a wrapper function for the Ollama local LLM. It uses the ollama library to send a chat request and returns the generated content.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/llm.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef call_llm(prompt):\n    from ollama import chat\n    response = chat(\n        model=\"llama2\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    return response.message.content\n```\n\n----------------------------------------\n\nTITLE: Answer Question Node Implementation\nDESCRIPTION: Implements a Node class for processing questions using context, generating prompts for LLM, and handling responses. Includes preparation, execution, and post-processing methods.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass AnswerQuestion(Node):\n    def prep(self, shared):\n        return (\n            shared[\"current_question\"],\n            shared[\"context\"]\n        )\n        \n    def exec(self, inputs):\n        question, context = inputs\n        prompt = f\"\"\"\nContext: {context}\n\nQuestion: {question}\n\nAnswer the question based on the context above. If the context doesn't contain relevant information, say so.\nAnswer:\"\"\"\n        return call_llm(prompt)\n    \n    def post(self, shared, prep_res, exec_res):\n        print(f\"\\nQ: {shared['current_question']}\")\n        print(f\"A: {exec_res}\")\n        print(f\"\\nSource: {shared['relevant_file']}\")\n        return \"continue\"  # Loop back for more questions\n```\n\n----------------------------------------\n\nTITLE: Creating and Running a Flow in PocketFlow\nDESCRIPTION: Example of creating a Flow by specifying a start point and then running it with a shared context. This pattern initializes the flow execution with a specific entry point.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nFlow(start=node_a)\n```\n\nLANGUAGE: python\nCODE:\n```\nflow.run(shared)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Node with Retry Parameters in Python\nDESCRIPTION: This snippet demonstrates how to create a Node instance with custom retry parameters. It sets the maximum number of retries to 3 and the wait time between retries to 10 seconds.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/node.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmy_node = SummarizeFile(max_retries=3, wait=10)\n```\n\n----------------------------------------\n\nTITLE: Working with Weaviate Vector Database in Python\nDESCRIPTION: Demonstrates how to use Weaviate for vector-based data storage and retrieval. This example shows creating a schema, inserting objects with vectors, and performing vector similarity queries with the Weaviate client.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/vector.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport weaviate\n\nclient = weaviate.Client(\"https://YOUR-WEAVIATE-CLOUD-ENDPOINT\")\n\nschema = {\n    \"classes\": [\n        {\n            \"class\": \"Article\",\n            \"vectorizer\": \"none\"\n        }\n    ]\n}\nclient.schema.create(schema)\n\nobj = {\n    \"title\": \"Hello World\",\n    \"content\": \"Weaviate vector search\"\n}\nclient.data_object.create(obj, \"Article\", vector=[0.1]*128)\n\nresp = (\n    client.query\n    .get(\"Article\", [\"title\", \"content\"])\n    .with_near_vector({\"vector\": [0.15]*128})\n    .with_limit(3)\n    .do()\n)\nprint(resp)\n```\n\n----------------------------------------\n\nTITLE: Generating Text Embeddings with Google Vertex AI in Python\nDESCRIPTION: Example for creating embeddings using Google's Vertex AI platform. Initializes the service with a GCP project ID and location, then uses the textembedding-gecko model to generate vector representations.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/embedding.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom vertexai.preview.language_models import TextEmbeddingModel\nimport vertexai\n\nvertexai.init(project=\"YOUR_GCP_PROJECT_ID\", location=\"us-central1\")\nmodel = TextEmbeddingModel.from_pretrained(\"textembedding-gecko@001\")\n\nemb = model.get_embeddings([\"Hello world\"])\nprint(emb[0])\n```\n\n----------------------------------------\n\nTITLE: Creating Q&A Flow with PocketFlow\nDESCRIPTION: Implements flow creation by connecting question and answer nodes in sequence. Creates a reusable flow function that can be imported and executed.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/guide.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# flow.py\nfrom pocketflow import Flow\nfrom nodes import GetQuestionNode, AnswerNode\n\ndef create_qa_flow():\n    \"\"\"Create and return a question-answering flow.\"\"\"\n    # Create nodes\n    get_question_node = GetQuestionNode()\n    answer_node = AnswerNode()\n    \n    # Connect nodes in sequence\n    get_question_node >> answer_node\n    \n    # Create flow starting with input node\n    return Flow(start=get_question_node)\n```\n\n----------------------------------------\n\nTITLE: Extracting Product Information Using YAML Structure\nDESCRIPTION: An example of structured output for extracting product information in YAML format. This structure includes product name, price, and a multi-line description.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/structure.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nproduct:\n  name: Widget Pro\n  price: 199.99\n  description: |\n    A high-quality widget designed for professionals.\n    Recommended for advanced users.\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncNode for Recipe Fetching in Python\nDESCRIPTION: Defines an AsyncNode class that handles ingredient input and fetches recipes asynchronously. Uses prep_async to gather ingredient input and exec_async to perform the API call using fetch_recipes function.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-async-basic/README.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def prep_async(self, shared):\n    ingredient = input(\"Enter ingredient: \")\n    return ingredient\n\nasync def exec_async(self, ingredient):\n    # Async API call\n    recipes = await fetch_recipes(ingredient)\n    return recipes\n```\n\n----------------------------------------\n\nTITLE: Calling LLM and Getting Embeddings in Python\nDESCRIPTION: Example usage of calling an LLM and getting embeddings for a given text input.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nresponse = call_llm(\"What's the meaning of life?\")\nprint(response)\nembedding = get_embedding(\"What's the meaning of life?\")\nprint(embedding)\n```\n\n----------------------------------------\n\nTITLE: Implementing FAISS Vector Database in Python\nDESCRIPTION: Demonstrates how to use FAISS for vector similarity search in Python. This example shows index creation, adding vectors to the index, and performing a k-nearest neighbors search with L2 distance metric.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/vector.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport faiss\nimport numpy as np\n\n# Dimensionality of embeddings\nd = 128\n\n# Create a flat L2 index\nindex = faiss.IndexFlatL2(d)\n\n# Random vectors\ndata = np.random.random((1000, d)).astype('float32')\nindex.add(data)\n\n# Query\nquery = np.random.random((1, d)).astype('float32')\nD, I = index.search(query, k=5)\n\nprint(\"Distances:\", D)\nprint(\"Neighbors:\", I)\n```\n\n----------------------------------------\n\nTITLE: Converting Text to Speech with ElevenLabs API in Python\nDESCRIPTION: This code example demonstrates how to use the ElevenLabs API for text-to-speech conversion. It uses the requests library to make HTTP calls to the ElevenLabs API with your API key and voice ID. The resulting audio is saved as an MP3 file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/text_to_speech.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport requests\n\napi_key = \"ELEVENLABS_KEY\"\nvoice_id = \"ELEVENLABS_VOICE\"\nurl = f\"https://api.elevenlabs.io/v1/text-to-speech/{voice_id}\"\nheaders = {\"xi-api-key\": api_key, \"Content-Type\": \"application/json\"}\n\njson_data = {\n    \"text\": \"Hello from ElevenLabs!\",\n    \"voice_settings\": {\"stability\": 0.75, \"similarity_boost\": 0.75}\n}\n\nresp = requests.post(url, headers=headers, json=json_data)\n\nwith open(\"elevenlabs.mp3\", \"wb\") as f:\n    f.write(resp.content)\n```\n\n----------------------------------------\n\nTITLE: Comparison of JSON vs YAML for Dialogue Representation\nDESCRIPTION: A comparison showing how JSON requires explicit escaping for quotes and newlines, while YAML handles multi-line strings more elegantly using block literals.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/structure.md#2025-04-22_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"dialogue\": \"Alice said: \\\"Hello Bob.\\\\nHow are you?\\\\nI am good.\\\"\"\n}\n```\n\nLANGUAGE: yaml\nCODE:\n```\ndialogue: |\n  Alice said: \"Hello Bob.\n  How are you?\n  I am good.\"\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key with Environment Variable\nDESCRIPTION: Shows how to set the OpenAI API key as an environment variable for use with the RAG system.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-rag/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis as a Vector Database in Python\nDESCRIPTION: Shows how to use Redis for vector storage and similarity search. This example demonstrates creating a vector index with FLAT algorithm and L2 distance metric, inserting binary-packed float vectors, and performing K-nearest neighbors queries.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/vector.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport redis\nimport struct\n\nr = redis.Redis(host=\"localhost\", port=6379)\n\n# Create index\nr.execute_command(\n    \"FT.CREATE\", \"my_idx\", \"ON\", \"HASH\",\n    \"SCHEMA\", \"embedding\", \"VECTOR\", \"FLAT\", \"6\",\n    \"TYPE\", \"FLOAT32\", \"DIM\", \"128\",\n    \"DISTANCE_METRIC\", \"L2\"\n)\n\n# Insert\nvec = struct.pack('128f', *[0.1]*128)\nr.hset(\"doc1\", mapping={\"embedding\": vec})\n\n# Search\nqvec = struct.pack('128f', *[0.15]*128)\nq = \"*=>[KNN 3 @embedding $BLOB AS dist]\"\nres = r.ft(\"my_idx\").search(q, query_params={\"BLOB\": qvec})\nprint(res.docs)\n```\n\n----------------------------------------\n\nTITLE: Implementing Chat History Handling in LLM Wrapper\nDESCRIPTION: This snippet demonstrates how to modify the LLM wrapper function to handle chat history. It accepts a list of messages instead of a single prompt.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/llm.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef call_llm(messages):\n    from openai import OpenAI\n    client = OpenAI(api_key=\"YOUR_API_KEY_HERE\")\n    r = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=messages\n    )\n    return r.choices[0].message.content\n```\n\n----------------------------------------\n\nTITLE: Implementing Naive Fixed-Size Chunking in Python\nDESCRIPTION: A simple implementation that splits text into chunks of a fixed number of characters. This approach ignores sentence or semantic boundaries, which can lead to awkward cuts that lose coherence.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/chunking.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef fixed_size_chunk(text, chunk_size=100):\n    chunks = []\n    for i in range(0, len(text), chunk_size):\n        chunks.append(text[i : i + chunk_size])\n    return chunks\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncNode for User Approval in Python\nDESCRIPTION: Defines an AsyncNode that handles user approval flow asynchronously. The post_async method requests user input about a suggested recipe and returns either 'accept' or 'retry' based on the response.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-async-basic/README.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def post_async(self, shared, prep_res, suggestion):\n    # Async user input\n    answer = await get_user_input(\n        f\"Accept {suggestion}? (y/n): \"\n    )\n    return \"accept\" if answer == \"y\" else \"retry\"\n```\n\n----------------------------------------\n\nTITLE: Listing Python Dependencies for PocketFlow\nDESCRIPTION: This requirements file lists the minimum versions of Python packages needed for the PocketFlow project. It includes OpenAI's API library, NumPy for numerical operations, FAISS for vector search, dotenv for environment variable management, and the PocketFlow package itself.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-embeddings/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nopenai>=1.0.0\nnumpy>=1.24.0\nfaiss-cpu>=1.7.0\npython-dotenv>=1.0.0\npocketflow>=0.1.0\n```\n\n----------------------------------------\n\nTITLE: Querying SerpApi using Python\nDESCRIPTION: This example demonstrates how to use SerpApi for web searches. It requires an API key. The code sends a GET request to the SerpApi endpoint with the necessary parameters, including the search engine to use (Google in this case), and prints the JSON response.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/websearch.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport requests\n\nAPI_KEY = \"YOUR_SERPAPI_KEY\"\nquery = \"example\"\n\nurl = \"https://serpapi.com/search\"\nparams = {\n    \"engine\": \"google\",\n    \"q\": query,\n    \"api_key\": API_KEY\n}\n\nresponse = requests.get(url, params=params)\nresults = response.json()\nprint(results)\n```\n\n----------------------------------------\n\nTITLE: Implementing LLM API Call Utility in Python\nDESCRIPTION: This code snippet shows the implementation of a utility function to call an LLM API using the OpenAI library. It includes error handling and a simple test case.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/guide.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# utils/call_llm.py\nfrom openai import OpenAI\n\ndef call_llm(prompt):    \n    client = OpenAI(api_key=\"YOUR_API_KEY_HERE\")\n    r = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    return r.choices[0].message.content\n    \nif __name__ == \"__main__\":\n    prompt = \"What is the meaning of life?\"\n    print(call_llm(prompt))\n```\n\n----------------------------------------\n\nTITLE: Specifying Package Dependencies for PocketFlow\nDESCRIPTION: Lists required Python packages and their minimum versions needed to run PocketFlow. Includes core dependencies like PocketFlow itself, numpy for numerical computations, faiss-cpu for vector similarity search, and openai for API integration.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat-memory/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.5\nnumpy>=1.20.0\nfaiss-cpu>=1.7.0\nopenai>=1.0.0\n```\n\n----------------------------------------\n\nTITLE: Setting up Pinecone Vector Database with Python\nDESCRIPTION: Shows how to connect to Pinecone, create an index, insert vector data, and perform similarity queries. This example demonstrates the initialization process requiring an API key and environment setup.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/vector.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pinecone\n\npinecone.init(api_key=\"YOUR_API_KEY\", environment=\"YOUR_ENV\")\n\nindex_name = \"my-index\"\n\n# Create the index if it doesn't exist\nif index_name not in pinecone.list_indexes():\n    pinecone.create_index(name=index_name, dimension=128)\n\n# Connect\nindex = pinecone.Index(index_name)\n\n# Upsert\nvectors = [\n    (\"id1\", [0.1]*128),\n    (\"id2\", [0.2]*128)\n]\nindex.upsert(vectors)\n\n# Query\nresponse = index.query([[0.15]*128], top_k=3)\nprint(response)\n```\n\n----------------------------------------\n\nTITLE: Generating Mermaid Diagrams from PocketFlow Graph\nDESCRIPTION: A function that recursively traverses a PocketFlow graph structure, assigning unique IDs to nodes and generating Mermaid syntax for hierarchical visualization. Handles Flow nodes as subgraphs and tracks node relationships.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/viz.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef build_mermaid(start):\n    ids, visited, lines = {}, set(), [\"graph LR\"]\n    ctr = 1\n    def get_id(n):\n        nonlocal ctr\n        return ids[n] if n in ids else (ids.setdefault(n, f\"N{ctr}\"), (ctr := ctr + 1))[0]\n    def link(a, b):\n        lines.append(f\"    {a} --> {b}\")\n    def walk(node, parent=None):\n        if node in visited:\n            return parent and link(parent, get_id(node))\n        visited.add(node)\n        if isinstance(node, Flow):\n            node.start and parent and link(parent, get_id(node.start))\n            lines.append(f\"\\n    subgraph sub_flow_{get_id(node)}[{type(node).__name__}]\")\n            node.start and walk(node.start)\n            for nxt in node.successors.values():\n                node.start and walk(nxt, get_id(node.start)) or (parent and link(parent, get_id(nxt))) or walk(nxt)\n            lines.append(\"    end\\n\")\n        else:\n            lines.append(f\"    {(nid := get_id(node))}['{type(node).__name__}']\")\n            parent and link(parent, nid)\n            [walk(nxt, nid) for nxt in node.successors.values()]\n    walk(start)\n    return \"\\n\".join(lines)\n```\n\n----------------------------------------\n\nTITLE: Implementing Google PaLM API LLM Wrapper in Python\nDESCRIPTION: This snippet demonstrates how to create a wrapper function for the Google PaLM API. It uses the google.generativeai library to generate text based on the given prompt.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/llm.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef call_llm(prompt):\n    import google.generativeai as genai\n    genai.configure(api_key=\"YOUR_API_KEY_HERE\")\n    r = genai.generate_text(\n        model=\"models/text-bison-001\",\n        prompt=prompt\n    )\n    return r.result\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies List\nDESCRIPTION: Specifies required Python packages with their minimum version requirements. Includes pocketflow, SerpAPI client for Google search results, OpenAI SDK, and PyYAML for structured data handling.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-search/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.1.0\ngoogle-search-results>=2.4.2  # SerpAPI client\nopenai>=1.0.0  # for search result analysis\npyyaml>=6.0.1  # for structured output\n```\n\n----------------------------------------\n\nTITLE: RAG System Pipeline Flow Diagram\nDESCRIPTION: Mermaid diagram showing the two-phase pipeline of the RAG system: offline document indexing and online query processing.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-rag/README.md#2025-04-22_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    subgraph OfflineFlow[Offline Document Indexing]\n        ChunkDocs[ChunkDocumentsNode] --> EmbedDocs[EmbedDocumentsNode] --> CreateIndex[CreateIndexNode]\n    end\n    \n    subgraph OnlineFlow[Online Processing]\n        EmbedQuery[EmbedQueryNode] --> RetrieveDoc[RetrieveDocumentNode] --> GenerateAnswer[GenerateAnswerNode]\n    end\n```\n\n----------------------------------------\n\nTITLE: Implementing Azure OpenAI LLM Wrapper in Python\nDESCRIPTION: This snippet shows how to create a wrapper function for the Azure OpenAI API. It uses the AzureOpenAI client to send a chat completion request and returns the generated content.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/llm.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef call_llm(prompt):\n    from openai import AzureOpenAI\n    client = AzureOpenAI(\n        azure_endpoint=\"https://<YOUR_RESOURCE_NAME>.openai.azure.com/\",\n        api_key=\"YOUR_API_KEY_HERE\",\n        api_version=\"2023-05-15\"\n    )\n    r = client.chat.completions.create(\n        model=\"<YOUR_DEPLOYMENT_NAME>\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    return r.choices[0].message.content\n```\n\n----------------------------------------\n\nTITLE: Flow Diagram for Memory Chat Application\nDESCRIPTION: Mermaid flowchart showing the relationship between nodes in the PocketFlow chat application, illustrating how user questions flow through retrieval, answering, and embedding processes.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat-memory/README.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    Question[GetUserQuestionNode] -->|retrieve| Retrieve[RetrieveNode]\n    Retrieve -->|answer| Answer[AnswerNode]\n    Answer -->|question| Question\n    Answer -->|embed| Embed[EmbedNode]\n    Embed -->|question| Question\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies\nDESCRIPTION: Lists required Python packages with minimum version constraints. Includes PocketFlow 0.0.1+, OpenAI 1.0.0+, and PyYAML 6.0+.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-workflow/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: requirements\nCODE:\n```\npocketflow>=0.0.1\nopenai>=1.0.0\npyyaml>=6.0\n```\n\n----------------------------------------\n\nTITLE: Creating Embeddings with AWS Bedrock in Python\nDESCRIPTION: Code for generating embeddings using AWS Bedrock. Uses the Titan text embedding model from Amazon to transform input text into vector representations, with the AWS SDK for Python (boto3).\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/embedding.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport boto3, json\n\nclient = boto3.client(\"bedrock-runtime\", region_name=\"us-east-1\")\nbody = {\"inputText\": \"Hello world\"}\nresp = client.invoke_model(modelId=\"amazon.titan-embed-text-v2:0\", contentType=\"application/json\", body=json.dumps(body))\nresp_body = json.loads(resp[\"body\"].read())\nvec = resp_body[\"embedding\"]\nprint(vec)\n```\n\n----------------------------------------\n\nTITLE: Example RAG System Output\nDESCRIPTION: Sample output showing the execution flow of the RAG system, including document chunking, embedding, retrieval, and answer generation for a query about installing PocketFlow.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-rag/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n‚úÖ Created 5 chunks from 5 documents\n‚úÖ Created 5 document embeddings\nüîç Creating search index...\n‚úÖ Index created with 5 vectors\nüîç Embedding query: How to install PocketFlow?\nüîé Searching for relevant documents...\nüìÑ Retrieved document (index: 0, distance: 0.3427)\nüìÑ Most relevant text: \"Pocket Flow is a 100-line minimalist LLM framework\n        Lightweight: Just 100 lines. Zero bloat, zero dependencies, zero vendor lock-in.\n        Expressive: Everything you love‚Äî(Multi-)Agents, Workflow, RAG, and more.\n        Agentic Coding: Let AI Agents (e.g., Cursor AI) build Agents‚Äî10x productivity boost!\n        To install, pip install pocketflow or just copy the source code (only 100 lines).\"\n\nü§ñ Generated Answer:\nTo install PocketFlow, use the command `pip install pocketflow` or simply copy its 100 lines of source code.\n```\n\n----------------------------------------\n\nTITLE: Adding Logging to LLM Wrapper in Python\nDESCRIPTION: This snippet shows how to add logging functionality to the LLM wrapper function. It logs both the input prompt and the generated response.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/llm.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef call_llm(prompt):\n    import logging\n    logging.info(f\"Prompt: {prompt}\")\n    response = ... # Your implementation here\n    logging.info(f\"Response: {response}\")\n    return response\n```\n\n----------------------------------------\n\nTITLE: Visualizing Complex Order Processing Pipeline with Mermaid\nDESCRIPTION: A Mermaid flowchart visualizing the complex order processing pipeline with nested flows for payment, inventory, and shipping. It shows the hierarchy and connections between different sub-flows.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/flow.md#2025-04-22_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    subgraph order_pipeline[Order Pipeline]\n        subgraph paymentFlow[\"Payment Flow\"]\n            A[Validate Payment] --> B[Process Payment] --> C[Payment Confirmation]\n        end\n\n        subgraph inventoryFlow[\"Inventory Flow\"]\n            D[Check Stock] --> E[Reserve Items] --> F[Update Inventory]\n        end\n\n        subgraph shippingFlow[\"Shipping Flow\"]\n            G[Create Label] --> H[Assign Carrier] --> I[Schedule Pickup]\n        end\n\n        paymentFlow --> inventoryFlow\n        inventoryFlow --> shippingFlow\n    end\n```\n\n----------------------------------------\n\nTITLE: Example of Data Science Flow for Mermaid Visualization\nDESCRIPTION: A code example demonstrating how to create a complex PocketFlow structure for data science workflows and visualize it using the build_mermaid function. Shows how to connect nodes and flows in a hierarchical manner.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/viz.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass DataPrepBatchNode(BatchNode):\n    def prep(self,shared): return []\nclass ValidateDataNode(Node): pass\nclass FeatureExtractionNode(Node): pass\nclass TrainModelNode(Node): pass\nclass EvaluateModelNode(Node): pass\nclass ModelFlow(Flow): pass\nclass DataScienceFlow(Flow):pass\n\nfeature_node = FeatureExtractionNode()\ntrain_node = TrainModelNode()\nevaluate_node = EvaluateModelNode()\nfeature_node >> train_node >> evaluate_node\nmodel_flow = ModelFlow(start=feature_node)\ndata_prep_node = DataPrepBatchNode()\nvalidate_node = ValidateDataNode()\ndata_prep_node >> validate_node >> model_flow\ndata_science_flow = DataScienceFlow(start=data_prep_node)\nresult = build_mermaid(start=data_science_flow)\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for PocketFlow\nDESCRIPTION: This snippet lists the required Python packages and their minimum versions for the PocketFlow project. It includes aiohttp for asynchronous HTTP requests and openai for integrating with OpenAI's language models.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-async-basic/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow\naiohttp>=3.8.0  # For async HTTP requests\nopenai>=1.0.0   # For async LLM calls\n```\n\n----------------------------------------\n\nTITLE: Converting Text to Speech with Amazon Polly in Python\nDESCRIPTION: This code snippet demonstrates how to use Amazon Polly to convert text to speech and save the output as an MP3 file. It requires AWS credentials and the boto3 library, and specifies voice parameters like OutputFormat and VoiceId.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/text_to_speech.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport boto3\n\npolly = boto3.client(\"polly\", region_name=\"us-east-1\",\n                     aws_access_key_id=\"YOUR_AWS_ACCESS_KEY_ID\",\n                     aws_secret_access_key=\"YOUR_AWS_SECRET_ACCESS_KEY\")\n\nresp = polly.synthesize_speech(\n    Text=\"Hello from Polly!\",\n    OutputFormat=\"mp3\",\n    VoiceId=\"Joanna\"\n)\n\nwith open(\"polly.mp3\", \"wb\") as f:\n    f.write(resp[\"AudioStream\"].read())\n```\n\n----------------------------------------\n\nTITLE: Thought Dictionary Structure Definition\nDESCRIPTION: Python dictionary structure defining the format of individual thought entries containing thinking process and plan updates.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/design.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n{\n    \"thought_number\": int,      # The sequence number of this thought.\n    \"current_thinking\": str,    # Detailed text of the evaluation and thinking for this step.\n    \"planning\": list[dict],     # The updated plan structure (list of dictionaries).\n    \"next_thought_needed\": bool # Flag indicating if the loop should continue.\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: Defines the minimum required versions for PocketFlow and python-dotenv packages. PocketFlow requires version 0.1.0 or higher, while python-dotenv requires version 0.19.0 or higher.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-database/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.1.0\npython-dotenv>=0.19.0\n```\n\n----------------------------------------\n\nTITLE: Generating Embeddings with OpenAI in Python\nDESCRIPTION: Example code for creating text embeddings using OpenAI's API. Requires an API key and uses the text-embedding-ada-002 model. Returns a vector representation of the input text.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/embedding.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom openai import OpenAI\n\nclient = OpenAI(api_key=\"YOUR_API_KEY\")\nresponse = client.embeddings.create(\n    model=\"text-embedding-ada-002\",\n    input=text\n)\n    \n# Extract the embedding vector from the response\nembedding = response.data[0].embedding\nembedding = np.array(embedding, dtype=np.float32)\nprint(embedding)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Research Agent Graph Structure\nDESCRIPTION: This Mermaid diagram illustrates the graph structure of the research agent, showing the relationships between DecideAction, SearchWeb, and AnswerQuestion nodes.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/README.md#2025-04-22_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    A[DecideAction] -->|\"search\"| B[SearchWeb]\n    A -->|\"answer\"| C[AnswerQuestion]\n    B -->|\"decide\"| A\n```\n\n----------------------------------------\n\nTITLE: Example Execution Command\nDESCRIPTION: Command to run the example implementation of the OpenAI embeddings integration.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-embeddings/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: PocketFlow Feedback Workflow Diagram\nDESCRIPTION: Mermaid flowchart showing the workflow structure with ProcessNode, ReviewNode, and ResultNode, including the feedback loop for approved/rejected states.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-web-hitl/README.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    subgraph FeedbackFlow[MinimalFeedbackFlow]\n        Process[ProcessNode] -- default --> Review[ReviewNode]\n        Review -- approved --> Result[ResultNode]\n        Review -- rejected --> Process\n    end\n```\n\n----------------------------------------\n\nTITLE: Visualizing Chain-of-Thought Process Flow\nDESCRIPTION: Mermaid flowchart diagram illustrating the self-looping nature of the ChainOfThoughtNode, which continues thinking until a solution is reached.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/README.md#2025-04-22_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    cot[ChainOfThoughtNode] -->|\"continue\"| cot\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Multi-Agent Communication Flow Diagram\nDESCRIPTION: Mermaid flowchart illustrating the asynchronous communication pattern between the AsyncHinter and AsyncGuesser nodes through a Message Queue.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-multi-agent/README.md#2025-04-22_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    AsyncHinter[AsyncHinter Node] <--> MessageQueue{Message Queue}\n    MessageQueue <--> AsyncGuesser[AsyncGuesser Node]\n```\n\n----------------------------------------\n\nTITLE: Flow Diagram of Chain of Thought Node\nDESCRIPTION: Mermaid flowchart showing the self-looping structure of the Chain of Thought node.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/design.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    cot[ChainOfThoughtNode] -->|\"continue\"| cot\n```\n\n----------------------------------------\n\nTITLE: Creating Main Script for Agent Execution\nDESCRIPTION: Main script to execute the research agent, accepting questions from the command line or using a default question. It initializes the agent flow, processes the question, and prints the final answer.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/demo.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# main.py\nimport sys\n\ndef main():\n    \"\"\"Simple function to process a question.\"\"\"\n    # Default question\n    default_question = \"Who won the Nobel Prize in Physics 2024?\"\n\n    # Get question from command line if provided with --\n    question = default_question\n    for arg in sys.argv[1:]:\n        if arg.startswith(\"--\"):\n            question = arg[2:]\n            break\n\n    # Create the agent flow\n    agent_flow = create_agent_flow()\n\n    # Process the question\n    shared = {\"question\": question}\n    print(f\"ü§î Processing question: {question}\")\n    agent_flow.run(shared)\n    print(\"\\nüéØ Final Answer:\")\n    print(shared.get(\"answer\", \"No answer found\"))\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Displaying Majority Vote Results in Python\nDESCRIPTION: Python code snippet showing the output format of the majority vote process, including all structured answers, the consensus answer, and its frequency.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-majority-vote/README.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n========================\nAll structured answers: ['0.333', '0.333', '0.333', '0.6', '0.333']\nMajority vote => 0.333\nFrequency => 4\n========================\n\n=== Final Answer ===\n0.333\n====================\n```\n\n----------------------------------------\n\nTITLE: Visualizing A2A Client-Server Interaction\nDESCRIPTION: Mermaid sequence diagram illustrating the simplified interaction between the A2A client and server, including the internal processing of the PocketFlow agent.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-a2a/README.md#2025-04-22_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client as \"Client ([minimal_a2a_client.py](a2a_client.py))\"\n    participant Server as \"Server (localhost:10003)\"\n    \n    Note over Client: User enters question\n    Client->>+Server: POST / (JSON-RPC Request: tasks/send)\n    Note over Server: Processes request internally (runs PocketFlow)\n    Server-->>-Client: HTTP 200 OK (JSON-RPC Response: result=Task)\n    Note over Client: Displays final answer\n```\n\n----------------------------------------\n\nTITLE: Image Processing Flow Diagram\nDESCRIPTION: Mermaid flowchart showing the image processing pipeline, demonstrating how images flow through loading, filter application, and saving stages within AsyncParallelBatchFlow.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-parallel-batch-flow/README.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    subgraph AsyncParallelBatchFlow[Image Processing Flow]\n        subgraph AsyncFlow[Per Image-Filter Flow]\n            A[Load Image] --> B[Apply Filter]\n            B --> C[Save Image]\n        end\n    end\n```\n\n----------------------------------------\n\nTITLE: Creating Text Embeddings with Azure OpenAI in Python\nDESCRIPTION: Code snippet demonstrating how to generate embeddings using Azure OpenAI Service. Configures API parameters for Azure and uses the ada-embedding engine to create vector representations of text.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/embedding.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport openai\n\nopenai.api_type = \"azure\"\nopenai.api_base = \"https://YOUR_RESOURCE_NAME.openai.azure.com\"\nopenai.api_version = \"2023-03-15-preview\"\nopenai.api_key = \"YOUR_AZURE_API_KEY\"\n\nresp = openai.Embedding.create(engine=\"ada-embedding\", input=\"Hello world\")\nvec = resp[\"data\"][0][\"embedding\"]\nprint(vec)\n```\n\n----------------------------------------\n\nTITLE: Project Structure Overview\nDESCRIPTION: Directory structure showing the organization of the PocketFlow embeddings integration project, including tools, utilities, and configuration files.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-embeddings/README.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow-tool-embeddings/\n‚îú‚îÄ‚îÄ tools/\n‚îÇ   ‚îî‚îÄ‚îÄ embeddings.py     # OpenAI embeddings API wrapper\n‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îî‚îÄ‚îÄ call_llm.py      # Centralized OpenAI client configuration\n‚îú‚îÄ‚îÄ nodes.py             # PocketFlow node implementation\n‚îú‚îÄ‚îÄ flow.py             # Flow configuration\n‚îî‚îÄ‚îÄ main.py             # Example usage\n```\n\n----------------------------------------\n\nTITLE: Problem Solving Trace Output\nDESCRIPTION: A detailed trace showing the structured thinking process for solving a probability problem. The trace includes multiple thought steps with evaluations, Markov chain modeling, and generating function analysis.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/README.md#2025-04-22_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nü§î Processing question: You keep rolling a fair die until you roll three, four, five in that order consecutively on three rolls. What is the probability that you roll the die an odd number of times?\n\nThought 1:\n  Let me think through this problem by setting up a clear approach.\n\n  We need to find the probability that the total number of die rolls will be odd, given we stop when we roll \"3,4,5\" consecutively in that order.\n\n  This is a problem about a stochastic process that ends when a specific pattern occurs. To solve it, I'll:\n  1. Set up a Markov chain model to track progress toward the target sequence\n  2. Calculate expected lengths and probabilities for different outcomes\n  3. Determine if the total number of rolls has equal probability of being odd vs. even\n\n  First, I need to understand what states we can be in while rolling the die:\n  - State 0: Haven't rolled any of the sequence yet\n  - State 1: Just rolled a 3, waiting for 4\n  - State 2: Rolled 3 followed by 4, waiting for 5\n  - State 3: Success! Rolled the full \"3,4,5\" sequence\n\n  When the die is rolled, we transition between these states with certain probabilities. Each state depends only on the previous 0-2 rolls, making this a Markov process.\n```\n\n----------------------------------------\n\nTITLE: Agent Architecture Diagram\nDESCRIPTION: Mermaid diagram showing the component relationships and decision flow of the research agent system\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-supervisor/README.md#2025-04-22_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    subgraph InnerAgent[Inner Research Agent]\n        DecideAction -->|\"search\"| SearchWeb\n        DecideAction -->|\"answer\"| UnreliableAnswerNode\n        SearchWeb -->|\"decide\"| DecideAction\n    end\n    \n    InnerAgent --> SupervisorNode\n    SupervisorNode -->|\"retry\"| InnerAgent\n```\n\n----------------------------------------\n\nTITLE: Customizing Text Input for PocketFlow Summarization\nDESCRIPTION: Demonstrates how to modify the main.py script to summarize custom text using the PocketFlow implementation. It uses the shared store to pass data and retrieve the summary.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-node/README.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nshared = {\"data\": \"Your text to summarize here...\"}\nflow.run(shared)\nprint(\"Summary:\", shared[\"summary\"])\n```\n\n----------------------------------------\n\nTITLE: Displaying Project Structure for PocketFlow Hello World Application\nDESCRIPTION: Shows the directory structure of a basic PocketFlow application, including documentation files, utility functions, implementation files, and project documentation.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-hello-world/README.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n.\n‚îú‚îÄ‚îÄ docs/          # Documentation files\n‚îú‚îÄ‚îÄ utils/         # Utility functions\n‚îú‚îÄ‚îÄ flow.py        # PocketFlow implementation\n‚îú‚îÄ‚îÄ main.py        # Main application entry point\n‚îî‚îÄ‚îÄ README.md      # Project documentation\n```\n\n----------------------------------------\n\nTITLE: Implementing Utility Functions for LLM and Web Search\nDESCRIPTION: A utility module containing functions for LLM API calls using OpenAI and web search using DuckDuckGo. Includes test functions that demonstrate how to use each utility with example inputs and outputs.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/demo.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# utils.py\nfrom openai import OpenAI\nimport os\nfrom duckduckgo_search import DDGS\n\ndef call_llm(prompt):\n    client = OpenAI(api_key=\"your-api-key\")\n    r = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    return r.choices[0].message.content\n\ndef search_web(query):\n    results = DDGS().text(query, max_results=5)\n    # Convert results to a string\n    results_str = \"\\n\\n\".join([f\"Title: {r['title']}\\nURL: {r['href']}\\nSnippet: {r['body']}\" for r in results])\n    return results_str\n\nprint(\"## Testing call_llm\")\nprompt = \"In a few words, what is the meaning of life?\"\nprint(f\"## Prompt: {prompt}\")\nresponse = call_llm(prompt)\nprint(f\"## Response: {response}\")\n\nprint(\"## Testing search_web\")\nquery = \"Who won the Nobel Prize in Physics 2024?\"\nprint(f\"## Query: {query}\")\nresults = search_web(query)\nprint(f\"## Results: {results}\")\n```\n\n----------------------------------------\n\nTITLE: Adding In-Memory Caching to LLM Wrapper in Python\nDESCRIPTION: This snippet shows how to add in-memory caching to the LLM wrapper function using the lru_cache decorator. It caches up to 1000 recent calls to improve performance.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/llm.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import lru_cache\n\n@lru_cache(maxsize=1000)\ndef call_llm(prompt):\n    # Your implementation here\n    pass\n```\n\n----------------------------------------\n\nTITLE: Generated Mermaid Diagram for Data Science Flow\nDESCRIPTION: The Mermaid diagram syntax generated from the previous data science flow example, showing the hierarchical structure with nested flows and node connections.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/viz.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n    subgraph sub_flow_N1[DataScienceFlow]\n    N2['DataPrepBatchNode']\n    N3['ValidateDataNode']\n    N2 --> N3\n    N3 --> N4\n\n    subgraph sub_flow_N5[ModelFlow]\n    N4['FeatureExtractionNode']\n    N6['TrainModelNode']\n    N4 --> N6\n    N7['EvaluateModelNode']\n    N6 --> N7\n    end\n\n    end\n```\n\n----------------------------------------\n\nTITLE: Chat Flow Architecture Diagram\nDESCRIPTION: Mermaid flowchart showing the self-looping ChatNode structure that handles the conversation flow.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat/README.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    chat[ChatNode] -->|continue| chat\n```\n\n----------------------------------------\n\nTITLE: Starting FastAPI Server with Uvicorn\nDESCRIPTION: Command to launch the FastAPI server using Uvicorn ASGI server with hot reload enabled for development.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-web-hitl/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nuvicorn server:app --reload --port 8000\n```\n\n----------------------------------------\n\nTITLE: Shared Store Data Structure Definition\nDESCRIPTION: Python type definitions for the shared store object containing problem statement, thoughts history, and solution state.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/design.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nshared = {\n    \"problem\": str,             # The problem statement.\n    \"thoughts\": list[dict],     # List of thought dictionaries generated so far.\n    \"current_thought_number\": int, # Counter for the current thought being generated.\n    \"solution\": str | None    # Stores the final conclusion text when finished.\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Branching Flow with Mermaid\nDESCRIPTION: A Mermaid flowchart visualizing the branching and looping flow of the expense approval process. It shows the different paths based on the review outcome.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/flow.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    review[Review Expense] -->|approved| payment[Process Payment]\n    review -->|needs_revision| revise[Revise Report]\n    review -->|rejected| finish[Finish Process]\n\n    revise --> review\n    payment --> finish\n```\n\n----------------------------------------\n\nTITLE: Visualizing Workflow Flow with Mermaid\nDESCRIPTION: Mermaid flowchart showing the task processing loop. Illustrates the main workflow steps: Process Task -> Review (with approval/rejection paths) -> Final Result or back to Process.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-web-hitl/docs/design.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    Process[Process Task] -- \"default\" --> Review{Wait for Feedback}\n    Review -- \"approved\" --> Result[Final Result]\n    Review -- \"rejected\" --> Process\n```\n\n----------------------------------------\n\nTITLE: Running the Web Crawler Script\nDESCRIPTION: This command executes the main Python script (main.py) to start the web crawling and content analysis process. The user will be prompted to enter the target website URL and the maximum number of pages to crawl.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-crawler/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Implementing DeepSeek LLM Wrapper in Python\nDESCRIPTION: This snippet shows how to create a wrapper function for the DeepSeek API. It uses the OpenAI client with a custom base URL to send a chat completion request and returns the generated content.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/llm.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef call_llm(prompt):\n    from openai import OpenAI\n    client = OpenAI(api_key=\"YOUR_DEEPSEEK_API_KEY\", base_url=\"https://api.deepseek.com\")\n    r = client.chat.completions.create(\n        model=\"deepseek-chat\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    return r.choices[0].message.content\n```\n\n----------------------------------------\n\nTITLE: Summarizing Documents as Bullet Points in YAML\nDESCRIPTION: A YAML structure for representing document summaries as bullet points. This format allows for clean, hierarchical representation of summarized information.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/structure.md#2025-04-22_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nsummary:\n  - This product is easy to use.\n  - It is cost-effective.\n  - Suitable for all skill levels.\n```\n\n----------------------------------------\n\nTITLE: Visualizing TranslateTextNode in Batch Processing\nDESCRIPTION: Mermaid flowchart showing the TranslateTextNode responsible for batch translation processing.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch/README.md#2025-04-22_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    batch[TranslateTextNode]\n```\n\n----------------------------------------\n\nTITLE: Flow Diagram Implementation in Mermaid\nDESCRIPTION: Mermaid flowchart showing the connection between three nodes in the system flow.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-hello-world/docs/design.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    firstNode[First Node] --> secondNode[Second Node]\n    secondNode --> thirdNode[Third Node]\n```\n\n----------------------------------------\n\nTITLE: Example Output of PocketFlow SQLite Database Integration\nDESCRIPTION: Sample output showing the database initialization status, task creation status, and listing of all tasks with their details including ID, title, description, status, and creation timestamp.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-database/README.md#2025-04-22_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nDatabase Status: Database initialized\nTask Status: Task created successfully\n\nAll Tasks:\n- ID: 1\n  Title: Example Task\n  Description: This is an example task created using PocketFlow\n  Status: pending\n  Created: 2024-03-02 12:34:56\n```\n\n----------------------------------------\n\nTITLE: Workflow Node Diagram\nDESCRIPTION: Mermaid diagram showing the sequential flow between workflow nodes for outline generation, content writing and style application\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-workflow/README.md#2025-04-22_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n    Outline[Generate Outline] --> Write[Write Content]\n    Write --> Style[Apply Style]\n```\n\n----------------------------------------\n\nTITLE: Printing Summaries in Python\nDESCRIPTION: Code that prints out filename and summary pairs from a shared dictionary. This demonstrates basic Python string formatting and dictionary iteration.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Summaries:\")\nfor filename, summary in shared[\"summaries\"].items():\n    print(f\"\\n{filename}:\")\n    print(summary)\n```\n\n----------------------------------------\n\nTITLE: Running the Application with a Custom Query\nDESCRIPTION: Example of how to run the application with a specific query about Q-Mesh protocol.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-rag/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython main.py --\"How does the Q-Mesh protocol achieve high transaction speeds?\"\n```\n\n----------------------------------------\n\nTITLE: Querying Google Custom Search JSON API using Python\nDESCRIPTION: This snippet demonstrates how to use the Google Custom Search JSON API to perform a web search. It requires an API key and a Custom Search Engine ID (CX_ID). The code sends a GET request to the API endpoint with the necessary parameters and prints the JSON response.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/websearch.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport requests\n\nAPI_KEY = \"YOUR_API_KEY\"\nCX_ID = \"YOUR_CX_ID\"\nquery = \"example\"\n\nurl = \"https://www.googleapis.com/customsearch/v1\"\nparams = {\n    \"key\": API_KEY,\n    \"cx\": CX_ID,\n    \"q\": query\n}\n\nresponse = requests.get(url, params=params)\nresults = response.json()\nprint(results)\n```\n\n----------------------------------------\n\nTITLE: Creating Mermaid Flowchart for LLM System Design\nDESCRIPTION: This snippet demonstrates how to create a Mermaid flowchart to visualize the design of an LLM system. It shows a process flow with batching, error checking, and multiple processing steps.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/guide.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```mermaid\nflowchart LR\n    start[Start] --> batch[Batch]\n    batch --> check[Check]\n    check -->|OK| process\n    check -->|Error| fix[Fix]\n    fix --> check\n    \n    subgraph process[Process]\n      step1[Step 1] --> step2[Step 2]\n    end\n    \n    process --> endNode[End]\n```\n```\n\n----------------------------------------\n\nTITLE: Starting PocketFlow A2A Server\nDESCRIPTION: Command to run the A2A server that wraps the PocketFlow agent, making it accessible via the A2A protocol on localhost port 10003.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-a2a/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython a2a_server.py --port 10003\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies for PocketFlow\nDESCRIPTION: Specifies the required Python packages and their minimum versions needed for the PocketFlow project. Dependencies include PocketFlow itself, requests for HTTP operations, BeautifulSoup for HTML parsing, and the OpenAI library for content analysis functionality.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-crawler/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.1.0\nrequests>=2.31.0\nbeautifulsoup4>=4.12.0\nopenai>=1.0.0  # for content analysis\n```\n\n----------------------------------------\n\nTITLE: Installing Requirements and Running the Application\nDESCRIPTION: Commands to install required dependencies and execute the chat application.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat-memory/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Defining Core Dependencies for PocketFlow\nDESCRIPTION: Lists the core Python package dependencies with minimum version requirements. Includes PocketFlow itself, aiohttp for HTTP requests, OpenAI SDK for LLM integration, and DuckDuckGo search library.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.1\naiohttp>=3.8.0  # For HTTP requests\nopenai>=1.0.0   # For LLM calls \nduckduckgo-search>=7.5.2    # For web search\n```\n\n----------------------------------------\n\nTITLE: Executing Custom Reasoning Problem with Majority Voting in Python\nDESCRIPTION: Python command to run the main script with a custom problem and specified number of attempts for the majority voting process.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-majority-vote/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython main.py --problem \"Your complex reasoning problem here\" --tries 5\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: This snippet defines the minimum required versions for three Python packages: pocketflow, anthropic, and pyyaml. These dependencies are crucial for the project to function correctly.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.1\nanthropic>=0.15.0\npyyaml>=6.0\n```\n\n----------------------------------------\n\nTITLE: Installing and Running the Chat Application\nDESCRIPTION: Commands for installing dependencies and launching the chat application from the terminal.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Converting Text to Speech with Azure TTS in Python\nDESCRIPTION: This code demonstrates how to use Azure Cognitive Services for text-to-speech conversion. It requires the azure-cognitiveservices-speech library and your Azure subscription key and region. The output is saved as a WAV file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/text_to_speech.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport azure.cognitiveservices.speech as speechsdk\n\nspeech_config = speechsdk.SpeechConfig(\n    subscription=\"AZURE_KEY\", region=\"AZURE_REGION\")\naudio_cfg = speechsdk.audio.AudioConfig(filename=\"azure_tts.wav\")\n\nsynthesizer = speechsdk.SpeechSynthesizer(\n    speech_config=speech_config,\n    audio_config=audio_cfg\n)\n\nsynthesizer.speak_text_async(\"Hello from Azure TTS!\").get()\n```\n\n----------------------------------------\n\nTITLE: Specifying PocketFlow Dependencies in Python\nDESCRIPTION: This snippet defines the required Python packages and their minimum versions for the PocketFlow project. It includes pocketflow itself, aiohttp for async HTTP requests, openai for async LLM calls, and duckduckgo-search for web search capabilities.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-supervisor/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.1\naiohttp>=3.8.0  # For async HTTP requests\nopenai>=1.0.0   # For async LLM calls \nduckduckgo-search>=7.5.2    # For web search\n```\n\n----------------------------------------\n\nTITLE: Example Output of Batch Translation Process\nDESCRIPTION: Sample console output showing the progress and results of the translation process, including the languages translated and the locations of saved files.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nTranslated Chinese text\nTranslated Spanish text\nTranslated Japanese text\nTranslated German text\nTranslated Russian text\nTranslated Portuguese text\nTranslated French text\nTranslated Korean text\nSaved translation to translations/README_CHINESE.md\nSaved translation to translations/README_SPANISH.md\nSaved translation to translations/README_JAPANESE.md\nSaved translation to translations/README_GERMAN.md\nSaved translation to translations/README_RUSSIAN.md\nSaved translation to translations/README_PORTUGUESE.md\nSaved translation to translations/README_FRENCH.md\nSaved translation to translations/README_KOREAN.md\n\n=== Translation Complete ===\nTranslations saved to: translations\n============================\n```\n\n----------------------------------------\n\nTITLE: Specifying PocketFlow and OpenAI Package Dependencies\nDESCRIPTION: This snippet defines the minimum version requirements for the PocketFlow and OpenAI packages. It ensures compatibility with PocketFlow version 0.0.1 or higher and OpenAI version 1.0.0 or higher.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-structured-output/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.1\nopenai>=1.0.0\n```\n\n----------------------------------------\n\nTITLE: Installing and Running the Application in Bash\nDESCRIPTION: Commands to install required dependencies and start the travel advisor chat application.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat-guardrail/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Specifying minimum version requirements for PocketFlow dependencies\nDESCRIPTION: Defines the minimum required versions for the core dependencies of the PocketFlow project, including the pocketflow package itself, OpenAI's Python client, and PyYAML for YAML parsing.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-map-reduce/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.1\nopenai>=1.0.0\npyyaml>=6.0 \n```\n\n----------------------------------------\n\nTITLE: Program Output Example\nDESCRIPTION: Sample console output showing the processing of multiple images with different filters, including timing comparisons between sequential and parallel processing methods.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-parallel-batch-flow/README.md#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n=== Processing Images in Parallel ===\nParallel Image Processor\n------------------------------\nFound 3 images:\n- images/bird.jpg\n- images/cat.jpg\n- images/dog.jpg\n\nRunning sequential batch flow...\nProcessing 3 images with 3 filters...\nTotal combinations: 9\nLoading image: images/bird.jpg\nApplying grayscale filter...\nSaved: output/bird_grayscale.jpg\n...etc\n\nTiming Results:\nSequential batch processing: 13.76 seconds\nParallel batch processing: 1.71 seconds\nSpeedup: 8.04x\n\nProcessing complete! Check the output/ directory for results.\n```\n\n----------------------------------------\n\nTITLE: Specifying Pocketflow Package Version\nDESCRIPTION: Defines the required version of the Pocketflow library as 0.1.0 using pip package format.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-communication/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow==0.1.0\n```\n\n----------------------------------------\n\nTITLE: PocketFlow Workflow Diagram for Mathematical Agent\nDESCRIPTION: Mermaid flowchart showing the three-node workflow of the agent: getting tools, deciding which tool to use, and executing the selected tool.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-mcp/README.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    tools[GetToolsNode] -->|decide| decide[DecideToolNode]\n    decide -->|execute| execute[ExecuteToolNode]\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for Chain-of-Thought Implementation\nDESCRIPTION: Command to install all necessary dependencies for the Chain-of-Thought project using pip and the requirements.txt file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Implementing a Retry Node in Python\nDESCRIPTION: This code shows how to implement a Node that prints the current retry count and deliberately raises an exception. It demonstrates how to access the current retry count using self.cur_retry.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/node.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass RetryNode(Node):\n    def exec(self, prep_res):\n        print(f\"Retry {self.cur_retry} times\")\n        raise Exception(\"Failed\")\n```\n\n----------------------------------------\n\nTITLE: PocketFlow Dependencies Requirements\nDESCRIPTION: Core dependencies required for PocketFlow application, including PocketFlow package, FastAPI framework, Uvicorn ASGI server, and Jinja2 templating engine.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-web-hitl/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.1\nfastapi\nuvicorn[standard] # ASGI server for FastAPI\njinja2 # For HTML templating\n```\n\n----------------------------------------\n\nTITLE: Example Output of Text Converter Application\nDESCRIPTION: This code block demonstrates the expected output and user interaction with the Text Converter application. It shows the menu options, user input, and transformed text output.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-flow/README.md#2025-04-22_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nWelcome to Text Converter!\n=========================\n\nEnter text to convert: Pocket Flow is a 100-line LLM framework\n\nChoose transformation:\n1. Convert to UPPERCASE\n2. Convert to lowercase\n3. Reverse text\n4. Remove extra spaces\n5. Exit\n\nYour choice (1-5): 1\n\nResult: POCKET FLOW IS A 100-LINE LLM FRAMEWORK\n\nConvert another text? (y/n): n\n\nThank you for using Text Converter!\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for PocketFlow\nDESCRIPTION: Installs the necessary Python packages for working with PocketFlow, vector search with FAISS, and OpenAI integration.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n! pip install pocketflow\n! pip install faiss-cpu\n! pip install openai\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Text Converter Project\nDESCRIPTION: This command installs the required dependencies for the Text Converter project using pip. It reads the dependencies from the requirements.txt file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-flow/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Defining Python Dependencies for PocketFlow Project\nDESCRIPTION: Lists the required Python packages for the PocketFlow project with their minimum version requirements. The file specifies that pocketflow version 0.0.1 or newer and openai version 1.0.0 or newer are required dependencies.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat-guardrail/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.1\nopenai>=1.0.0\n```\n\n----------------------------------------\n\nTITLE: Sample Output of School Grades Calculator\nDESCRIPTION: Expected console output showing the calculated averages for individual students, classes, and the overall school average.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-nested-batch/README.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nProcessing class_a...\n- student1: Average = 8.2\n- student2: Average = 8.3\nClass A Average: 8.25\n\nProcessing class_b...\n- student3: Average = 7.3\n- student4: Average = 8.8\nClass B Average: 8.05\n\nSchool Average: 8.15\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pip\nDESCRIPTION: Command to install required Python packages from requirements.txt file\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-supervisor/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncNode for Recipe Suggestion with LLM in Python\nDESCRIPTION: Defines an AsyncNode that processes recipe data through an LLM asynchronously. The exec_async method calls an LLM to select the best recipe from the available options.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-async-basic/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def exec_async(self, recipes):\n    # Async LLM call\n    suggestion = await call_llm_async(\n        f\"Choose best recipe from: {recipes}\"\n    )\n    return suggestion\n```\n\n----------------------------------------\n\nTITLE: Directory Structure Example\nDESCRIPTION: Shows the recommended file and folder organization for a PocketFlow project, including main components, utility functions, and documentation.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/guide.md#2025-04-22_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nmy_project/\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ nodes.py\n‚îú‚îÄ‚îÄ flow.py\n‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ call_llm.py\n‚îÇ   ‚îî‚îÄ‚îÄ search_web.py\n‚îú‚îÄ‚îÄ requirements.txt\n‚îî‚îÄ‚îÄ docs/\n    ‚îî‚îÄ‚îÄ design.md\n```\n\n----------------------------------------\n\nTITLE: Running the Multi-Agent Taboo Game Application\nDESCRIPTION: Command to execute the main Python script that launches the Taboo game with the AsyncHinter and AsyncGuesser agents.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-multi-agent/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Plan Step Dictionary Structure\nDESCRIPTION: Python dictionary structure for representing individual plan steps with status tracking and nested sub-steps capability.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/design.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n{\n    \"description\": str,                     # Description of the step.\n    \"status\": str,                          # \"Pending\", \"Done\", \"Verification Needed\".\n    \"result\": str | None,                   # Optional: Concise result when status is \"Done\".\n    \"mark\": str | None,                     # Optional: Reason for \"Verification Needed\".\n    \"sub_steps\": list[dict] | None          # Optional: Nested list for sub-steps.\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pip\nDESCRIPTION: Command to install the required Python packages specified in requirements.txt for running the application.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-web-hitl/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Specifying pandas dependency for PocketFlow\nDESCRIPTION: This dependency specification indicates that the PocketFlow package requires pandas version 2.0.0 or higher to function properly.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch-node/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npandas>=2.0.0\n```\n\n----------------------------------------\n\nTITLE: Running the Default Chain-of-Thought Example\nDESCRIPTION: Command to execute the main script with the default Jane Street probability problem, demonstrating the Chain-of-Thought process in action.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Dependencies Installation Command\nDESCRIPTION: Command to install project dependencies from requirements.txt file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-embeddings/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Converting Text to Speech with IBM Watson TTS in Python\nDESCRIPTION: This snippet shows how to use IBM Watson Text-to-Speech service to convert text to audio. It requires the ibm-watson library, your IBM API key, and service URL. The synthesized speech is saved as an MP3 file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/text_to_speech.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom ibm_watson import TextToSpeechV1\nfrom ibm_cloud_sdk_core.authenticators import IAMAuthenticator\n\nauth = IAMAuthenticator(\"IBM_API_KEY\")\nservice = TextToSpeechV1(authenticator=auth)\nservice.set_service_url(\"IBM_SERVICE_URL\")\n\nresp = service.synthesize(\n    \"Hello from IBM Watson!\",\n    voice=\"en-US_AllisonV3Voice\",\n    accept=\"audio/mp3\"\n).get_result()\n\nwith open(\"ibm_tts.mp3\", \"wb\") as f:\n    f.write(resp.content)\n```\n\n----------------------------------------\n\nTITLE: Running the PocketFlow BatchFlow Image Processing Example\nDESCRIPTION: Command to execute the main Python script that demonstrates the BatchFlow concept for image processing with multiple filters.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch-flow/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Processing Flow Node Results\nDESCRIPTION: Processes execution results and updates shared context with current question and relevant file information.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nquestion, filename = exec_res\nshared[\"current_question\"] = question\nshared[\"relevant_file\"] = filename\nshared[\"context\"] = shared[\"data\"][filename]\nreturn \"answer\"\n```\n\n----------------------------------------\n\nTITLE: Running Majority Vote Reasoning Test in Python\nDESCRIPTION: Python command to execute the main script and run a test problem using the majority voting system.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-majority-vote/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Project Structure for PocketFlow SQLite Database Integration\nDESCRIPTION: Directory structure showing the organization of the project files, including tools directory, node implementation, flow configuration, and example usage.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-database/README.md#2025-04-22_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow-tool-database/\n‚îú‚îÄ‚îÄ tools/\n‚îÇ   ‚îî‚îÄ‚îÄ database.py    # SQLite database operations\n‚îú‚îÄ‚îÄ nodes.py          # PocketFlow node implementation\n‚îú‚îÄ‚îÄ flow.py          # Flow configuration\n‚îî‚îÄ‚îÄ main.py          # Example usage\n```\n\n----------------------------------------\n\nTITLE: Testing API Key and Web Search Functionality\nDESCRIPTION: This command runs the utils.py script to test the LLM call and web search features, ensuring the API key is working correctly.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython utils.py\n```\n\n----------------------------------------\n\nTITLE: Verifying API Key Configuration\nDESCRIPTION: Command to check if the OpenAI API key is working properly by running the utils.py script.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-rag/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython utils.py\n```\n\n----------------------------------------\n\nTITLE: Converting Text to Speech with Google Cloud TTS in Python\nDESCRIPTION: This code example shows how to use Google Cloud Text-to-Speech to synthesize speech from text and save it as an MP3 file. It requires the google-cloud-texttospeech library and sets up voice parameters like language code and audio encoding.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/text_to_speech.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom google.cloud import texttospeech\n\nclient = texttospeech.TextToSpeechClient()\ninput_text = texttospeech.SynthesisInput(text=\"Hello from Google Cloud TTS!\")\nvoice = texttospeech.VoiceSelectionParams(language_code=\"en-US\")\naudio_cfg = texttospeech.AudioConfig(audio_encoding=texttospeech.AudioEncoding.MP3)\n\nresp = client.synthesize_speech(input=input_text, voice=voice, audio_config=audio_cfg)\n\nwith open(\"gcloud_tts.mp3\", \"wb\") as f:\n    f.write(resp.audio_content)\n```\n\n----------------------------------------\n\nTITLE: Running the PocketFlow SQLite Database Example\nDESCRIPTION: Command to execute the main.py script which initializes a database, creates a task, and lists tasks.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-database/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Running Research Agent with Default Question\nDESCRIPTION: This command executes the main.py script to run the research agent with the default question about Nobel Prize winners.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Running Application with Custom Topic\nDESCRIPTION: Command to run the main application with a user-specified topic\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-workflow/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython main.py Climate Change\n```\n\n----------------------------------------\n\nTITLE: Switching from Fake to Real OpenAI LLM Streaming\nDESCRIPTION: Code modification to replace the fake streaming implementation with the real OpenAI API integration. This requires changing the function call in main.py.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-llm-streaming/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Change this line:\nchunks = fake_stream_llm(prompt)\n# To this:\nchunks = stream_llm(prompt)\n```\n\n----------------------------------------\n\nTITLE: Installing and Running PocketFlow Example\nDESCRIPTION: Commands to install required dependencies and execute the main program for the school grades calculator example.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-nested-batch/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Running Research Agent with Custom Question\nDESCRIPTION: This command demonstrates how to run the research agent with a custom question by using the '--' prefix followed by the question.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython main.py --\"What is quantum computing?\"\n```\n\n----------------------------------------\n\nTITLE: Running Application with Default Topic\nDESCRIPTION: Command to run the main application using the default 'AI Safety' topic\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-workflow/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Querying Brave Search API using Python\nDESCRIPTION: This snippet shows how to use the Brave Search API for web searches. It requires a subscription token. The code sends a GET request to the API endpoint with the necessary headers and parameters, then prints the JSON response.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/websearch.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport requests\n\nSUBSCRIPTION_TOKEN = \"YOUR_BRAVE_API_TOKEN\"\nquery = \"example\"\n\nurl = \"https://api.search.brave.com/res/v1/web/search\"\nheaders = {\n    \"X-Subscription-Token\": SUBSCRIPTION_TOKEN\n}\nparams = {\n    \"q\": query\n}\n\nresponse = requests.get(url, headers=headers, params=params)\nresults = response.json()\nprint(results)\n```\n\n----------------------------------------\n\nTITLE: Setting Anthropic API Key for LLM Access\nDESCRIPTION: Bash command to set the Anthropic API key as an environment variable, which is required for accessing Claude models used in the Chain-of-Thought implementation.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport ANTHROPIC_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key for PocketFlow Agent\nDESCRIPTION: Bash command to set the OpenAI API key as an environment variable, required for the PocketFlow agent to function.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-a2a/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: Running the Web Search Tool\nDESCRIPTION: Command to execute the main Python script that runs the web search tool, prompting the user for a search query and number of results to fetch.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-search/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Running the Application\nDESCRIPTION: Commands to install required packages and run the main application with default parameters.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-rag/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key in Bash\nDESCRIPTION: Command to set the OpenAI API key as an environment variable before running the application.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat-memory/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key for PocketFlow Taboo Game\nDESCRIPTION: Command to set the OpenAI API key as an environment variable, which is required for the LLM functionality in the Taboo game.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-multi-agent/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=your_api_key_here\n```\n\n----------------------------------------\n\nTITLE: System Environment Variable Setup\nDESCRIPTION: Command to set OpenAI API key as a system environment variable for alternative configuration.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-embeddings/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=your_api_key_here\n```\n\n----------------------------------------\n\nTITLE: Querying DuckDuckGo Instant Answer API using Python\nDESCRIPTION: This example demonstrates how to use the DuckDuckGo Instant Answer API. This API is free and doesn't require an API key. The code sends a GET request to the API endpoint with the query and format parameters, then prints the JSON response.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/websearch.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport requests\n\nquery = \"example\"\nurl = \"https://api.duckduckgo.com/\"\nparams = {\n    \"q\": query,\n    \"format\": \"json\"\n}\n\nresponse = requests.get(url, params=params)\nresults = response.json()\nprint(results)\n```\n\n----------------------------------------\n\nTITLE: Environment Variable Configuration\nDESCRIPTION: Example of setting OpenAI API key in a .env file for secure configuration management.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-embeddings/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nOPENAI_API_KEY=your_api_key_here\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key\nDESCRIPTION: Environment variable configuration for OpenAI API authentication\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-supervisor/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: Print Summary Result in Python\nDESCRIPTION: Simple print statement to display a summary value from a shared dictionary.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Summary:\", shared[\"summary\"])\n```\n\n----------------------------------------\n\nTITLE: Running the Text Converter Application\nDESCRIPTION: This command executes the main Python script to start the Text Converter application. It launches the interactive command-line interface for text transformation.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-flow/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for PocketFlow Text Summarization Project\nDESCRIPTION: Installs the required dependencies for the PocketFlow text summarization project using pip and the requirements.txt file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-node/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key\nDESCRIPTION: Command to set the OpenAI API key as an environment variable\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-workflow/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=your_api_key_here\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Node Description\nDESCRIPTION: HTML markup defining the structure and styling for describing a Node and its three steps.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<p style=\"font-family: Arial, sans-serif; font-size: 24px; font-weight: bold; color: #333; margin: 4px 0; padding: 0;\">\n2. Node\n</p>\n\n<p style=\"font-family: Arial, sans-serif; font-size: 16px; color: #333;\">\nA <strong>Node</strong> is your smallest unit of work with 3 steps \n<code>prep->exec->post</code>:\n</p>\n\n<ol style=\"font-family: Arial, sans-serif; font-size: 16px; color: #333; margin: 20px 0; padding-left: 20px;\">\n\n<li style=\"margin-bottom: 16px;\">\n    <p style=\"margin: 0 0 8px 0;\">\n    <code>prep(shared)</code>\n    </p>\n    <p style=\"margin: 0 0 8px 0;\">\n    - Reads and preprocess data from the <strong>shared store</strong>.\n    </p>\n    <p style=\"margin: 0;\">\n    - E.g., load a file, query a database, or turn data into a string.\n    </p>\n</li>\n\n<li style=\"margin-bottom: 16px;\">\n    <p style=\"margin: 0 0 8px 0;\">\n    <code>exec(prep_res)</code>\n    </p>\n    <p style=\"margin: 0 0 8px 0;\">\n    - Executes the core logic\n    </p>\n    <p style=\"margin: 0 0 8px 0;\">\n    - E.g., call an LLM, invoke remote APIs, or embed texts.\n    </p>\n</li>\n\n<li style=\"margin-bottom: 16px;\">\n    <p style=\"margin: 0 0 8px 0;\">\n    <code>post(shared, prep_res, exec_res)</code>\n    </p>\n    <p style=\"margin: 0;\">\n    - Writes data back to the <strong>shared store</strong>.\n    </p>\n</li>\n\n</ol>\n```\n\n----------------------------------------\n\nTITLE: Querying Bing Web Search API using Python\nDESCRIPTION: This code snippet shows how to use the Bing Web Search API for web searches. It requires a subscription key. The script sends a GET request to the API endpoint with the necessary headers and parameters, then prints the JSON response.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/websearch.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport requests\n\nSUBSCRIPTION_KEY = \"YOUR_BING_API_KEY\"\nquery = \"example\"\n\nurl = \"https://api.bing.microsoft.com/v7.0/search\"\nheaders = {\"Ocp-Apim-Subscription-Key\": SUBSCRIPTION_KEY}\nparams = {\"q\": query}\n\nresponse = requests.get(url, headers=headers, params=params)\nresults = response.json()\nprint(results)\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for PocketFlow BatchFlow Example\nDESCRIPTION: Command to install the required dependencies for the BatchFlow image processing example using pip package manager.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch-flow/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key in Bash\nDESCRIPTION: Environment variable setup for OpenAI API authentication required to run the chat application.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: Generating Server Configuration in YAML\nDESCRIPTION: A YAML structure for server configuration settings. This example includes host address, port number, and SSL settings.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/structure.md#2025-04-22_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nserver:\n  host: 127.0.0.1\n  port: 8080\n  ssl: true\n```\n\n----------------------------------------\n\nTITLE: Running PocketFlow Text Summarization Example\nDESCRIPTION: Executes the main Python script to run the PocketFlow text summarization example.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-node/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key for Research Agent\nDESCRIPTION: This command sets the OpenAI API key as an environment variable for use in the research agent project.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: YAML Front Matter Configuration for Design Pattern Documentation\nDESCRIPTION: Configuration block that defines the layout and navigation properties for a design pattern documentation page. Sets up default layout, page title, navigation order, and indicates the page has child pages.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/index.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nlayout: default\ntitle: \"Design Pattern\"\nnav_order: 3\nhas_children: true\n---\n```\n\n----------------------------------------\n\nTITLE: Using Offline Indexing Flow for RAG in Python\nDESCRIPTION: This code snippet demonstrates how to use the OfflineFlow defined for the RAG pipeline. It initializes the shared dictionary with file paths and runs the flow.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/design_pattern/rag.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nshared = {\n    \"files\": [\"doc1.txt\", \"doc2.txt\"],  # any text files\n}\nOfflineFlow.run(shared)\n```\n\n----------------------------------------\n\nTITLE: Running Default Question\nDESCRIPTION: Command to execute the agent with default Nobel Prize question\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-supervisor/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Research Agent Project\nDESCRIPTION: This command installs the required packages for the research agent project using pip and the requirements.txt file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Specifying PocketFlow Dependency Version in Plaintext\nDESCRIPTION: This code snippet defines the minimum required version of PocketFlow for the project. It uses the greater than or equal to operator to indicate that version 0.1.0 or any higher version is acceptable.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-flow/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.1.0\n```\n\n----------------------------------------\n\nTITLE: Running the Recipe Finder Example with Bash\nDESCRIPTION: Commands to install dependencies and run the Recipe Finder application. Requires installing packages from requirements.txt before executing the main.py script.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-async-basic/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Running Custom Question\nDESCRIPTION: Command to execute the agent with a custom question using -- prefix\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-supervisor/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython main.py --\"What is quantum computing?\"\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for Batch Translation\nDESCRIPTION: Command to install the necessary dependencies for the translation project using pip.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for PocketFlow\nDESCRIPTION: This requirements file specifies that the PocketFlow project depends on Pillow version 10.0.0 or higher. Pillow is a fork of the Python Imaging Library (PIL) and provides image processing capabilities.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch-flow/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow\nPillow>=10.0.0\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Caching in LLM Wrapper\nDESCRIPTION: This snippet demonstrates how to implement conditional caching in the LLM wrapper function. It allows using cached results only when not retrying, addressing conflicts with Node retries.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/llm.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import lru_cache\n\n@lru_cache(maxsize=1000)\ndef cached_call(prompt):\n    pass\n\ndef call_llm(prompt, use_cache):\n    if use_cache:\n        return cached_call(prompt)\n    # Call the underlying function directly\n    return cached_call.__wrapped__(prompt)\n\nclass SummarizeNode(Node):\n    def exec(self, text):\n        return call_llm(f\"Summarize: {text}\", self.cur_retry==0)\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies for PocketFlow\nDESCRIPTION: This requirements file specifies the necessary Python packages and their minimum versions needed for the PocketFlow project to function properly. It includes the pocketflow package itself, OpenAI API integration, PDF processing via PyMuPDF, and image processing capabilities through Pillow.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-pdf-vision/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plain\nCODE:\n```\npocketflow>=0.1.0\nopenai>=1.0.0\nPyMuPDF>=1.22.0  # for PDF processing\nPillow>=10.0.0   # for image processing\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Web Search Tool\nDESCRIPTION: Command to install the required Python packages for the web search tool using pip and the requirements.txt file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-search/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Developer Quotation on Reduced Motivation\nDESCRIPTION: A developer expressing diminished motivation to create iPhone applications due to Apple's restrictive App Store control, despite enjoying the development experience itself.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/data/PaulGrahamEssaysLarge/apple.txt#2025-04-22_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n  While I did enjoy developing for the iPhone, the control they\n  place on the App Store does not give me the drive to develop\n  applications as I would like. In fact I don't intend to make any\n  more iPhone applications unless absolutely necessary.\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Majority Vote Reasoning Project\nDESCRIPTION: Bash command to install the required packages for the project using pip and the requirements.txt file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-majority-vote/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies for PocketFlow\nDESCRIPTION: This snippet lists the required Python packages for the PocketFlow project. It specifies PocketFlow version 0.0.1 or newer, OpenAI API version 1.0.0 or newer, as well as fastmcp and PyYAML without version constraints.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-mcp/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plain\nCODE:\n```\npocketflow>=0.0.1\nopenai>=1.0.0\nfastmcp\npyyaml\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for PocketFlow Application\nDESCRIPTION: Command to install all required dependencies for the PocketFlow application from the requirements.txt file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-hello-world/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Example of Using Call Stack Debugging in a Data Science Flow\nDESCRIPTION: A code example demonstrating how to integrate the call stack debugging function into nodes within a PocketFlow data science workflow. Shows how to access and print the execution context during flow runtime.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/utility_function/viz.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass DataPrepBatchNode(BatchNode): \n    def prep(self, shared): return []\nclass ValidateDataNode(Node): pass\nclass FeatureExtractionNode(Node): pass\nclass TrainModelNode(Node): pass\nclass EvaluateModelNode(Node): \n    def prep(self, shared):\n        stack = get_node_call_stack()\n        print(\"Call stack:\", stack)\nclass ModelFlow(Flow): pass\nclass DataScienceFlow(Flow):pass\n\nfeature_node = FeatureExtractionNode()\ntrain_node = TrainModelNode()\nevaluate_node = EvaluateModelNode()\nfeature_node >> train_node >> evaluate_node\nmodel_flow = ModelFlow(start=feature_node)\ndata_prep_node = DataPrepBatchNode()\nvalidate_node = ValidateDataNode()\ndata_prep_node >> validate_node >> model_flow\ndata_science_flow = DataScienceFlow(start=data_prep_node)\ndata_science_flow.run({})\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for PocketFlow\nDESCRIPTION: This snippet defines the required Python packages and their minimum versions for the PocketFlow project. It includes PocketFlow itself and the Anthropic library for Claude API access.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.1\nanthropic>=0.15.0   # For Claude API access\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies\nDESCRIPTION: Command to install required project dependencies from requirements.txt file\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-workflow/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for PocketFlow A2A Integration\nDESCRIPTION: Command to install required Python packages for the PocketFlow A2A integration project using pip.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-a2a/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Python Package Requirements\nDESCRIPTION: Lists required Python packages with minimum version constraints for the pocketflow project. Includes pocketflow>=0.0.1, openai>=1.0.0, and pyyaml>=6.0.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-multi-agent/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: requirements\nCODE:\n```\npocketflow>=0.0.1\nopenai>=1.0.0\npyyaml>=6.0\n```\n\n----------------------------------------\n\nTITLE: Setting Up Python Virtual Environment for PocketFlow Database Project\nDESCRIPTION: Commands for creating a Python virtual environment and activating it, with separate instructions for Windows and Unix-based systems.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-database/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies for PocketFlow Project\nDESCRIPTION: A requirements.txt file that specifies all necessary Python packages with version constraints for the PocketFlow project. The dependencies are organized into sections for different components: PocketFlow Agent Logic, A2A Server Infrastructure, CLI tools, and A2A Client.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-a2a/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# For PocketFlow Agent Logic\npocketflow>=0.0.1\nopenai>=1.0.0\nduckduckgo-search>=7.5.2\npyyaml>=5.1\n\n# For A2A Server Infrastructure (from common)\nstarlette>=0.37.2,<0.38.0\nuvicorn[standard]>=0.29.0,<0.30.0\nsse-starlette>=1.8.2,<2.0.0\npydantic>=2.0.0,<3.0.0\nhttpx>=0.27.0,<0.28.0\nanyio>=3.0.0,<5.0.0 # Dependency of starlette/httpx\n\n# For running __main__.py\nclick>=8.0.0,<9.0.0\n\n# For A2A Client\nhttpx>=0.27.0,<0.28.0\nhttpx-sse>=0.4.0\nasyncclick>=8.1.8 # Or just 'click' if you prefer asyncio.run\npydantic>=2.0.0,<3.0.0 # For common.types\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies for PocketFlow\nDESCRIPTION: This requirements.txt file specifies the minimum version requirements for Python packages needed by the PocketFlow project. It requires pocketflow version 0.0.1 or newer and openai version 1.0.0 or newer.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.1\nopenai>=1.0.0\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Running the Application\nDESCRIPTION: Commands for installing the required Python packages from requirements.txt and launching the main application.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-mcp/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Installing and Running PocketFlow Comparison Script\nDESCRIPTION: Instructions for installing PocketFlow and running the main script to compare sequential and parallel processing performance.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-parallel-batch/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install pocketflow\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Project Setup and Execution Commands\nDESCRIPTION: Commands for installing project dependencies and running the main program. Requires pip package manager and Python environment.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-parallel-batch-flow/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Output of Sequential vs Parallel Processing Comparison\nDESCRIPTION: Sample output showing the execution of sequential and parallel processing tasks, demonstrating the time difference between the two approaches.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-parallel-batch/README.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n=== Running Sequential (AsyncBatchNode) ===\n[Sequential] Summarizing file1.txt...\n[Sequential] Summarizing file2.txt...\n[Sequential] Summarizing file3.txt...\n\n=== Running Parallel (AsyncParallelBatchNode) ===\n[Parallel] Summarizing file1.txt...\n[Parallel] Summarizing file2.txt...\n[Parallel] Summarizing file3.txt...\n\nSequential took: 3.00 seconds\nParallel took:   1.00 seconds\n```\n\n----------------------------------------\n\nTITLE: Running the Batch Translation Process\nDESCRIPTION: Command to execute the main Python script that initiates the batch translation process.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies for PocketFlow Database Project\nDESCRIPTION: Command to install required packages listed in the requirements.txt file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-database/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Installing PocketFlow via pip\nDESCRIPTION: Command to install PocketFlow using pip package manager. Alternatively, users can copy the source code directly.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install pocketflow\n```\n\n----------------------------------------\n\nTITLE: Specifying OpenAI Dependency for PocketFlow\nDESCRIPTION: This snippet defines the required Python package dependencies for the PocketFlow project. It specifies that the OpenAI Python client library version 1.0.0 or higher is required for the project to function properly.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-node/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow\nopenai>=1.0.0\n```\n\n----------------------------------------\n\nTITLE: Virtual Environment Setup Commands\nDESCRIPTION: Commands for creating and activating a Python virtual environment for the project, ensuring isolated dependencies.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-embeddings/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n```\n\n----------------------------------------\n\nTITLE: Defining Python Dependencies for PocketFlow\nDESCRIPTION: This snippet lists the required Python packages needed to run the PocketFlow project. It includes Pillow for image processing with a minimum version of 10.0.0 and NumPy for numerical operations with a minimum version of 1.24.0.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-parallel-batch-flow/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow\nPillow>=10.0.0  # For image processing\nnumpy>=1.24.0   # For image array operations \n```\n\n----------------------------------------\n\nTITLE: Verifying API Key Configuration\nDESCRIPTION: Command to run a utility script that verifies the Anthropic API key is correctly set up and the environment is properly configured.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython utils.py\n```\n\n----------------------------------------\n\nTITLE: Defining Python Dependencies for PocketFlow\nDESCRIPTION: This requirements file specifies the minimum versions of Python packages needed for the PocketFlow project. It includes the pocketflow library itself, the anthropic client library, and PyYAML for YAML processing.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-majority-vote/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.1\nanthropic>=0.15.0\npyyaml>=6.0\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Web Crawler Project\nDESCRIPTION: This command installs the required Python packages listed in the requirements.txt file for the web crawler project.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-crawler/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key in Bash\nDESCRIPTION: Command to set the OpenAI API key as an environment variable for authentication.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat-guardrail/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: Batch Node Documentation in HTML\nDESCRIPTION: HTML markup that describes the Batch processing concept and its three main functions: prep(), exec() and post(). Includes styling and formatting.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow_demo.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<!-- Title -->\n<p style=\"font-family: Arial, sans-serif; font-size: 24px; font-weight: bold; color: #333; \">\n  3. Batch\n</p>\n\n<!-- Description of Batch processing -->\n<p style=\"font-family: Arial, sans-serif; font-size: 16px; color: #333; margin-bottom: 16px;\">\n  <strong>Batch</strong> helps repeat the same work multiple items. \n  Instead of calling <code style=\"background: #f2f2f2; padding: 2px 4px; border-radius: 3px;\">exec()</code> once, a Batch Node calls \n  <code style=\"background: #f2f2f2; padding: 2px 4px; border-radius: 3px;\">exec()</code> \n  for each item in a list from <code style=\"background: #f2f2f2; padding: 2px 4px; border-radius: 3px;\">prep()</code>. \n</p>\n```\n\n----------------------------------------\n\nTITLE: Shared Memory Structure Definition in Python\nDESCRIPTION: Python dictionary structure defining the shared memory organization for data exchange between nodes.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-hello-world/docs/design.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nshared = {\n    \"key\": \"value\"\n}\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key Environment Variable\nDESCRIPTION: This command sets the OPENAI_API_KEY environment variable with the user's API key for accessing OpenAI's services, which is required for the content analysis feature.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-crawler/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY='your-api-key'\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages with pip\nDESCRIPTION: Installation commands for required Python packages including pocketflow, aiohttp, openai, and duckduckgo-search, specifying minimum version requirements.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-agent/demo.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n! pip install pocketflow>=0.0.1\n! pip install aiohttp>=3.8.0\n! pip install openai>=1.0.0\n! pip install duckduckgo-search>=7.5.2\n```\n\n----------------------------------------\n\nTITLE: Application Flow Diagram in Mermaid\nDESCRIPTION: Flowchart showing the application's node structure and data flow between user input, guardrail validation, and LLM processing.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-chat-guardrail/README.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    user[UserInputNode] -->|validate| guardrail[GuardrailNode]\n    guardrail -->|retry| user\n    guardrail -->|process| llm[LLMNode]\n    llm -->|continue| user\n```\n\n----------------------------------------\n\nTITLE: Visualizing Text Converter Workflow with Mermaid\nDESCRIPTION: This Mermaid diagram illustrates the workflow of the Text Converter application. It shows the interaction between the TextInput and TextTransform nodes, as well as the exit path.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-flow/README.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    Input[TextInput Node] -->|transform| Transform[TextTransform Node]\n    Transform -->|input| Input\n    Transform -->|exit| End[End]\n    Input -->|exit| End\n```\n\n----------------------------------------\n\nTITLE: Setting up Markov Chain Equations with Parity for Die Roll Sequence Problem\nDESCRIPTION: System of linear equations using first-step analysis to determine probability of odd number of die rolls until sequence 3,4,5. The equations track the parity of roll count from each state in the Markov chain.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/README.md#2025-04-22_snippet_7\n\nLANGUAGE: mathematics\nCODE:\n```\nP‚ÇÄ = (1/6)*(1-P‚ÇÅ) + (5/6)*(1-P‚ÇÄ) = 5/6 - 5P‚ÇÄ/6 + 1/6 - P‚ÇÅ/6\nP‚ÇÅ = (1/6)*(1-P‚ÇÇ) + (1/6)*(1-P‚ÇÅ) + (4/6)*(1-P‚ÇÄ) = 1 - P‚ÇÇ/6 - P‚ÇÅ/6 - 4P‚ÇÄ/6\nP‚ÇÇ = (1/6)*1 + (1/6)*(1-P‚ÇÅ) + (4/6)*(1-P‚ÇÄ) = 1/6 + 1/6 - P‚ÇÅ/6 + 4/6 - 4P‚ÇÄ/6 = 6/6 - P‚ÇÅ/6 - 4P‚ÇÄ/6\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key Environment Variable\nDESCRIPTION: Command to set up the OpenAI API key as an environment variable, which is required for the real streaming implementation to authenticate with the OpenAI service.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-llm-streaming/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: Visualizing MajorityVoteNode Flow with Mermaid\nDESCRIPTION: Mermaid flowchart representing the MajorityVoteNode in the majority vote reasoning implementation.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-majority-vote/README.md#2025-04-22_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    mv[MajorityVoteNode] \n```\n\n----------------------------------------\n\nTITLE: Developer Quotation on Bug Fix Approval Delays\nDESCRIPTION: A developer explaining how the App Store approval process delays bug fixes for weeks, creating a negative user experience and harming Apple's platform reputation compared to competitors.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/data/PaulGrahamEssaysLarge/apple.txt#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  I believe that they think their approval process helps users by\n  ensuring quality.  In reality, bugs like ours get through all the\n  time and then it can take 4-8 weeks to get that bug fix approved,\n  leaving users to think that iPhone apps sometimes just don't work.\n  Worse for Apple, these apps work just fine on other platforms\n  that have immediate approval processes.\n```\n\n----------------------------------------\n\nTITLE: Running the PocketFlow Hello World Application\nDESCRIPTION: Command to execute the PocketFlow application by running the main Python script.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-hello-world/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Quote from Apple's 1984 Commercial\nDESCRIPTION: Text from Apple's famous 1984 commercial that the author ironically repurposes to criticize Apple's current App Store policies, suggesting Apple has become what it once rebelled against.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/data/PaulGrahamEssaysLarge/apple.txt#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n  We have triumphed over the unprincipled dissemination of facts.We have created, for the first time in all history, a garden of\n  pure ideology, where each worker may bloom secure from the pests\n  of contradictory and confusing truths.\n```\n\n----------------------------------------\n\nTITLE: Running the PocketFlow BatchNode Example\nDESCRIPTION: Command to execute the main script of the PocketFlow BatchNode CSV processing example.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch-node/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies for PocketFlow Project in requirements.txt\nDESCRIPTION: This code snippet defines the required Python packages and their minimum versions for the PocketFlow project. It includes the pocketflow package itself, numpy for numerical operations, faiss-cpu for vector similarity search, and openai for AI functionality.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-rag/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npocketflow>=0.0.1\nnumpy>=1.20.0\nfaiss-cpu>=1.7.0\nopenai>=1.0.0\n```\n\n----------------------------------------\n\nTITLE: Running PocketFlow A2A Client\nDESCRIPTION: Command to start the A2A client that interacts with the PocketFlow agent server, allowing users to send queries and receive responses.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-a2a/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython a2a_client.py --agent-url http://localhost:10003\n```\n\n----------------------------------------\n\nTITLE: Creating Virtual Environment for PocketFlow Setup\nDESCRIPTION: Commands to create and activate a Python virtual environment for the PocketFlow application, with instructions for both Unix-based systems and Windows.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-hello-world/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n```\n\n----------------------------------------\n\nTITLE: Eric Raymond's Quote on Learning Lisp\nDESCRIPTION: A quote from Eric Raymond's essay 'How to Become a Hacker' describing the value of learning Lisp for programmers, even if they don't use it regularly.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/data/PaulGrahamEssaysLarge/avg.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n  Lisp is worth learning for the profound enlightenment experience\n  you will have when you finally get it; that experience will make\n  you a better programmer for the rest of your days, even if you\n  never actually use Lisp itself a lot.\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for PocketFlow BatchNode Example\nDESCRIPTION: Command to install the required dependencies for the PocketFlow BatchNode example project using pip and requirements.txt.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch-node/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Installing and Running the LLM Streaming Application\nDESCRIPTION: Commands to install the required dependencies and run the main application. This sets up the environment and launches the StreamNode implementation.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-llm-streaming/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\npython main.py\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key in Bash\nDESCRIPTION: Command to set the OpenAI API key as an environment variable, which is required to run the PocketFlow agent with MCP.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-mcp/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: Initializing Python Virtual Environment for PocketFlow Project\nDESCRIPTION: Creates a virtual environment and activates it for the PocketFlow project. This isolates the project dependencies from the system-wide Python installation.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-node/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Multi-Agent Taboo Game\nDESCRIPTION: Command to install all required dependencies for the Taboo game from the requirements.txt file.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-multi-agent/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Setting API Keys for SerpAPI and OpenAI\nDESCRIPTION: Bash commands to set environment variables for SerpAPI and OpenAI API keys, which are required for the web search and analysis functionalities.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-tool-search/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport SERPAPI_API_KEY='your-serpapi-key'\nexport OPENAI_API_KEY='your-openai-key'\n```\n\n----------------------------------------\n\nTITLE: Testing API Connection\nDESCRIPTION: Command to verify LLM and web search functionality\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-supervisor/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython utils.py\n```\n\n----------------------------------------\n\nTITLE: Setting API Key for Anthropic Model in Bash\nDESCRIPTION: Bash command to set the ANTHROPIC_API_KEY environment variable for authentication with the Anthropic API.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-majority-vote/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport ANTHROPIC_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: Setting Up API Key for Anthropic LLM\nDESCRIPTION: Bash command to set the environment variable for the Anthropic API key, required for accessing the translation model.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-batch/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport ANTHROPIC_API_KEY=\"your-api-key-here\"\n```\n\n----------------------------------------\n\nTITLE: Verifying OpenAI API Key Setup\nDESCRIPTION: Python command to run a quick check ensuring the OpenAI API key is set up correctly for the PocketFlow agent.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-a2a/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython utils.py\n```\n\n----------------------------------------\n\nTITLE: Running Chain-of-Thought with Custom Problem\nDESCRIPTION: Command showing how to provide a custom reasoning problem to the Chain-of-Thought implementation using command line arguments.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/pocketflow-thinking/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython main.py --\"Your complex reasoning problem here\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Jekyll Front Matter for Core Abstraction Page\nDESCRIPTION: This YAML front matter block configures the Jekyll page metadata for the Core Abstraction documentation section. It sets the layout, title, navigation order, and indicates that this page has child pages.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/docs/core_abstraction/index.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nlayout: default\ntitle: \"Core Abstraction\"\nnav_order: 2\nhas_children: true\n---\n```\n\n----------------------------------------\n\nTITLE: Developer Quotation on App Store Quality Issues\nDESCRIPTION: A developer's perspective on how Apple's approval process leads to poor quality applications in the App Store, with developers releasing suboptimal versions due to the lengthy review process.\nSOURCE: https://github.com/the-pocket/pocketflow/blob/main/cookbook/data/PaulGrahamEssaysLarge/apple.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n  As a result of their process, the App Store is full of half-baked\n  applications. I make a new version almost every day that I release\n  to beta users. The version on the App Store feels old and crappy.\n  I'm sure that a lot of developers feel this way: One emotion is\n  \"I'm not really proud about what's in the App Store\", and it's\n  combined with the emotion \"Really, it's Apple's fault.\"\n```"
  }
]