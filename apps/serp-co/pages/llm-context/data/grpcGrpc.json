[
  {
    "owner": "grpc",
    "repo": "grpc",
    "content": "TITLE: Starting gRPC Interop Server with Bazel\nDESCRIPTION: Starts the gRPC interop server using Bazel. This command sets the GRPC_VERBOSITY to DEBUG and executes the interop_server target with the specified port number.\nSOURCE: https://github.com/grpc/grpc/blob/master/test/cpp/interop/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nGRPC_VERBOSITY=DEBUG ibazel run --compilation_mode=dbg //test/cpp/interop:interop_server -- --port={port_number}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Using System or Bundled gRPC in CMake for C++\nDESCRIPTION: This snippet demonstrates toggling between using a system-installed gRPC package or building gRPC as part of the project within a CMake build. It uses an option to select the preferred method, thus providing flexibility for users who already have gRPC installed or prefer a bundled build. Essential for projects that need to support both environments cleanly.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/cpp/README.md#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\noption(USE_SYSTEM_GRPC \"Use system installed gRPC\" OFF)\nif(USE_SYSTEM_GRPC)\n  # Find system-installed gRPC\n  find_package(gRPC CONFIG REQUIRED)\nelse()\n  # Build gRPC using FetchContent or add_subdirectory\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple .proto Files via Wildcard in .NET Project (XML, .NET)\nDESCRIPTION: This .csproj XML snippet configures the project to include all .proto files in the directory tree for gRPC and message code generation. The <Protobuf> element uses a wildcard (**) to include every proto file discovered recursively at build time. This is useful for large projects or when the number of proto files is dynamic. On build, all included files will be compiled into corresponding C# gRPC and message types.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_2\n\nLANGUAGE: XML\nCODE:\n```\n<ItemGroup>\n    <Protobuf Include=\"**\\*.proto\" />\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Testing Bidirectional gRPC C++ Client with Mock Stub\nDESCRIPTION: Demonstrates a more complex Google Test setup for testing the `DoBidiStream` method. It involves mocking the `BidiStreamRaw` call on the stub to return a mock reader/writer (`MockClientReaderWriter`), then setting detailed expectations on the mock reader/writer's `Write` and `Read` methods using Google Mock actions like `SaveArg`, `copy`, and `Return` to simulate stream interaction.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/unit_testing.md#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nACTION_P(copy, msg) {\n  arg0->set_message(msg->message());\n}\n\n\nauto rw = new MockClientReaderWriter<EchoRequest, EchoResponse>();\nEchoRequest msg;\nEXPECT_CALL(*rw, Write(_, _)).Times(3).WillRepeatedly(DoAll(SaveArg<0>(&msg), Return(true)));\nEXPECT_CALL(*rw, Read(_)).\n      WillOnce(DoAll(WithArg<0>(copy(&msg)), Return(true))).\n      WillOnce(DoAll(WithArg<0>(copy(&msg)), Return(true))).\n      WillOnce(DoAll(WithArg<0>(copy(&msg)), Return(true))).\n      WillOnce(Return(false));\n\nMockEchoTestServiceStub  stub;\nEXPECT_CALL(stub, BidiStreamRaw(_)).Times(AtLeast(1)).WillOnce(Return(rw));\n\nFakeClient client(stub);\nclient.DoBidiStream();\n```\n\n----------------------------------------\n\nTITLE: Compiling and Linking gRPC Example Targets with CMake - CMake\nDESCRIPTION: This snippet utilizes CMake's `foreach` loop to define multiple example binaries for various client and server flows. For each target, it calls `add_executable` with the appropriate source file and then links the executable against all required libraries, including the generated gRPC protocol library (`hw_grpc_proto`), abseil libraries, reflection, gRPC++, and protobuf. It expects the absl and gRPC dependencies to be available and prebuilt, along with previously generated protocol source files. Each target outputs a distinct client or server executable. The approach is scalable and avoids code duplication for similar targets.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/flow_control/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(_target\n  client_flow_control_client client_flow_control_server\n  server_flow_control_client server_flow_control_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::check\n    absl::flags\n    absl::flags_parse\n    absl::log\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Displaying Generated gRPC C++ Stub Interface\nDESCRIPTION: Illustrates the structure of the C++ StubInterface class typically generated by the gRPC protoc plugin from a .proto service definition. It shows the pure virtual methods corresponding to the defined RPCs ('Echo' and 'BidiStreamRaw') that are implemented by concrete stubs and targeted for mocking.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/unit_testing.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nclass EchoTestService final {\n  public:\n  class StubInterface {\n    virtual ::grpc::Status Echo(::grpc::ClientContext* context, const ::grpc::testing::EchoRequest& request, ::grpc::testing::EchoResponse* response) = 0;\n  …\n    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::grpc::testing::EchoRequest, ::grpc::testing::EchoResponse>> BidiStream(::grpc::ClientContext* context) {\n      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::grpc::testing::EchoRequest, ::grpc::testing::EchoResponse>>(BidiStreamRaw(context));\n    }\n  …\n    private:\n    virtual ::grpc::ClientReaderWriterInterface< ::grpc::testing::EchoRequest, ::grpc::testing::EchoResponse>* BidiStreamRaw(::grpc::ClientContext* context) = 0;\n  …\n  } // End StubInterface\n…\n} // End EchoTestService\n```\n\n----------------------------------------\n\nTITLE: Generating Protobuf and gRPC sources\nDESCRIPTION: Defines custom commands to generate C++ protobuf and gRPC code from the helloworld.proto file. It uses the protobuf compiler (protoc) and the gRPC plugin to generate .pb.cc, .pb.h, .grpc.pb.cc, and .grpc.pb.h files in the binary directory. Requires protobuf and gRPC tools to be installed and available.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\n# Generated sources\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Example gRPC Service Config (JSON)\nDESCRIPTION: Shows the JSON representation of the example service configuration from the textproto snippet. It illustrates the standard protobuf-to-JSON conversion rules, including snake_case to camelCase field names, the representation of Duration as a string, and repeated fields as JSON arrays.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/service_config.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"loadBalancingConfig\": [ { \"round_robin\": {} } ],\n  \"methodConfig\": [\n    {\n      \"name\": [\n        { \"service\": \"foo\", \"method\": \"bar\" },\n        { \"service\": \"baz\" }\n      ],\n      \"timeout\": \"1.000000001s\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Troubleshooting Missing Python Headers During gRPC Python Build - Shell\nDESCRIPTION: A common compilation error involving missing Python.h header files is addressed here. The recommended fix is to install the Python development package (python-dev) on the system, typically via the system's package manager. This snippet provides an example command for Ubuntu systems.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/grpcio/README.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n/tmp/pip-build-U8pSsr/cython/Cython/Plex/Scanners.c:4:20: fatal error: Python.h: No such file or directory\\n#include \"Python.h\"\\n                ^\\ncompilation terminated.\n```\n\nLANGUAGE: shell\nCODE:\n```\nsudo apt-get install python-dev\n```\n\n----------------------------------------\n\nTITLE: Example gRPC Service Config (textproto)\nDESCRIPTION: Provides an example of a gRPC service configuration using the text format representation of the `grpc.service_config.ServiceConfig` protobuf message. It demonstrates configuring a round-robin load balancing policy and setting a timeout for specific methods or services.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/service_config.md#_snippet_0\n\nLANGUAGE: textproto\nCODE:\n```\n{\n  # Use round_robin LB policy.\n  load_balancing_config: { round_robin: {} }\n  # This method config applies to method \"foo/bar\" and to all methods\n  # of service \"baz\".\n  method_config: {\n    name: {\n      service: \"foo\"\n      method: \"bar\"\n    }\n    name: {\n      service: \"baz\"\n    }\n    # Default timeout for matching methods.\n    timeout: {\n      seconds: 1\n      nanos: 1\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Protobuf and gRPC Libraries with Dependency Linking Using CMake for C++\nDESCRIPTION: Creates static libraries from the generated protobuf and gRPC source and header files. It sets up three libraries: hw_grpc_proto, status_proto, and error_details_proto, each linked against the appropriate protobuf, gRPC, and reflection libraries. This modular organization allows reuse of generated code and manages dependencies effectively.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/error_details/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n\nadd_library(status_proto\n  ${status_proto_srcs}\n  ${status_proto_hdrs})\ntarget_link_libraries(status_proto\n  ${_PROTOBUF_LIBPROTOBUF})\n\nadd_library(error_details_proto\n  ${error_details_proto_srcs}\n  ${error_details_proto_hdrs})\ntarget_link_libraries(error_details_proto\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Listing specific gRPC method details using grpc_cli in Shell\nDESCRIPTION: Command to retrieve detailed information about a specific gRPC method by specifying its fully qualified name using grpc_cli ls with the long listing (-l) flag. The command helps explore the method signature and protobuf message definitions from the server via server reflection.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ grpc_cli ls localhost:50051 helloworld.Greeter.SayHello -l\n```\n\n----------------------------------------\n\nTITLE: Calling a unary RPC method with grpc_cli in Shell\nDESCRIPTION: Command to call a remote unary RPC method on a gRPC server using grpc_cli call. The first example demonstrates sending a request in text protobuf format and receiving the textual response output. Subsequent examples show how to specify local proto files for service definitions if server reflection is unavailable, and how to pass raw binary protobuf data as input and output files for non-protobuf or binary RPC calls.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$ grpc_cli call localhost:50051 SayHello \"name: 'gRPC CLI'\"\n```\n\nLANGUAGE: Shell\nCODE:\n```\n$ grpc_cli call localhost:50051 SayHello \"name: 'world'\" \\\n  --protofiles=examples/protos/helloworld.proto\n```\n\nLANGUAGE: Shell\nCODE:\n```\n$ grpc_cli call localhost:50051 /helloworld.Greeter/SayHello \\\n  --input_binary_file=input.bin \\\n  --output_binary_file=output.bin\n```\n\n----------------------------------------\n\nTITLE: Enabling Wait-for-Ready in gRPC Python\nDESCRIPTION: This snippet demonstrates how to enable the 'wait-for-ready' option on a per-RPC basis in gRPC Python. Setting the `wait_for_ready` parameter to `True` will cause the RPC to wait until the channel is in the READY state before sending the request. This prevents immediate failures if the server is not initially available.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/wait_for_ready/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nstub = ...Stub(...)\n\nstub.important_transaction_1(..., wait_for_ready=True)\nstub.unimportant_transaction_2(...)\nstub.important_transaction_3(..., wait_for_ready=True)\nstub.unimportant_transaction_4(...)\n# The unimportant transactions can be status report, or health check, etc.\n```\n\n----------------------------------------\n\nTITLE: Configuring Protobuf Code Generation in CMake\nDESCRIPTION: Locates the 'helloworld.proto' file, defines variables for the generated Protobuf and gRPC C++ source and header files within the build directory. Sets up a custom command using `_PROTOBUF_PROTOC` (protoc executable) and `_GRPC_CPP_PLUGIN_EXECUTABLE` (gRPC C++ plugin) to generate these files from the .proto file. Specifies output directories, include paths, and ensures the command runs when the .proto file changes. Adds the directory containing generated headers to the include path.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/error_handling/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Proto files\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\n# Generated sources\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n\n# Include generated *.pb.h files\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Disabling Non-Fatal Logs Using absl Flags in Bash\nDESCRIPTION: This snippet demonstrates how to disable all gRPC logs except those with fatal severity by setting absl logging flags via command-line arguments. The flags `--v=-1` and `--minloglevel=3` reduce log verbosity and set the minimum log severity, respectively. This commands apply to executable gRPC applications and require absl logging support.\nSOURCE: https://github.com/grpc/grpc/blob/master/TROUBLESHOOTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./helloworld_application_using_grpc --v=-1 --minloglevel=3\n```\n\n----------------------------------------\n\nTITLE: Listing All Services with gRPC CLI\nDESCRIPTION: Command to list all services exposed at a given port using the gRPC CLI tool.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_reflection_tutorial.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ grpc_cli ls localhost:50051\n```\n\n----------------------------------------\n\nTITLE: Listing available services with grpcurl (shell)\nDESCRIPTION: This command uses `grpcurl` to list the services available via reflection on the gRPC server.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/xds/README.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n> grpcurl --plaintext localhost:50051 list\ngrpc.health.v1.Health\ngrpc.reflection.v1alpha.ServerReflection\nhelloworld.Greeter\n```\n\n----------------------------------------\n\nTITLE: Fetching and Building gRPC via CMake FetchContent Module in C++ Projects\nDESCRIPTION: Configures CMake to automatically clone the gRPC repository and its submodules during configuration, integrating gRPC source as a subdirectory for build. Requires CMake version 3.16 or newer and proper network access. This streamlines the build process by embedding gRPC compilation within the project’s build lifecycle, easing dependency management.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/cpp/README.md#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\nproject(my_project)\n\ninclude(FetchContent)\nFetchContent_Declare(\n  gRPC\n  GIT_REPOSITORY https://github.com/grpc/grpc\n  GIT_TAG        RELEASE_TAG_HERE  # e.g v1.28.0\n)\nset(FETCHCONTENT_QUIET OFF)\nFetchContent_MakeAvailable(gRPC)\n\nadd_executable(my_exe my_exe.cc)\ntarget_link_libraries(my_exe grpc++)\n```\n\n----------------------------------------\n\nTITLE: Linking Executable Dependencies\nDESCRIPTION: Inside the `foreach` loop (partially shown), this command links the `multiplex_client` and `multiplex_server` executable targets. They are linked against the custom `example_grpc_proto` library (containing generated code), Abseil flags and logging libraries, and the core gRPC, Protobuf, and Reflection libraries.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/multiplex/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(_target multiplex_client multiplex_server)\n  # add_executable for executables is in the previous snippet\n  target_link_libraries(${_target}\n    example_grpc_proto\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Debugging Connection Behavior in gRPC Python\nDESCRIPTION: Environment variable configuration targeted at debugging connection-related issues in gRPC applications. This traces call errors, connectivity state changes, and load balancing algorithms like pick_first, round_robin, and glb.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/debug/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nGRPC_VERBOSITY=debug\nGRPC_TRACE=call_error,connectivity_state,pick_first,round_robin,glb\n```\n\n----------------------------------------\n\nTITLE: Using Python's pdb Debugger with gRPC Applications\nDESCRIPTION: Simple example of adding a breakpoint in a gRPC Python application using the built-in pdb debugger. This causes the application to pause execution and provide an interactive debugging interface when the interpreter reaches this line.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/debug/README.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport pdb; pdb.set_trace()\n```\n\n----------------------------------------\n\nTITLE: Creating a gRPC Server with Gzip Compression Enabled in Python\nDESCRIPTION: Initializes a gRPC server configured to compress all responses using Gzip compression by setting the compression parameter at server creation. Requires grpc and concurrent.futures.ThreadPoolExecutor. This setting applies globally to all RPCs served, optimizing bandwidth usage server-wide.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/compression/README.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nserver = grpc.server(futures.ThreadPoolExecutor(),\n                     compression=grpc.Compression.Gzip)\n```\n\n----------------------------------------\n\nTITLE: Creating gRPC Proto Library\nDESCRIPTION: This section creates a static library named `hw_grpc_proto` that includes the generated protobuf and gRPC source files.  It links the library with reflection, gRPC, and protobuf libraries.  The library encapsulates all the generated code for use by client and server executables.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/generic_api/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# hw_grpc_proto\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Importing gRPC Service and Stub - Python\nDESCRIPTION: This code snippet demonstrates how to import generated Python modules based on a gRPC proto definition. It imports message definitions and the gRPC service and stub from the specified proto file.  The example uses a proto located at 'envoy/service/status/v3/csds.proto'. Dependencies include the protobuf compiler and gRPC tools.  The output is the ability to use the generated gRPC service and stub classes in the Python code.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/distrib/python/xds_protos/README.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Import the message definitions\nfrom envoy.service.status.v3 import csds_pb2\n# Import the gRPC service and stub\nfrom envoy.service.status.v3 import csds_pb2_grpc\n```\n\n----------------------------------------\n\nTITLE: Retrieving Protobuf File Information\nDESCRIPTION: This snippet retrieves the absolute path and the path of the helloworld.proto file. These paths are then used in subsequent commands to generate the necessary source files.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Proto file\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n```\n\n----------------------------------------\n\nTITLE: Listing gRPC server services and methods using grpc_cli in Shell\nDESCRIPTION: Commands to query gRPC servers using the grpc_cli ls command to list available services and methods. The first example lists all services exposed by a server at a given address and port. The second example lists a specific service and its methods in detail with the long listing (-l) flag. These commands help discover server capabilities through server reflection.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ grpc_cli ls localhost:50051\n```\n\nLANGUAGE: Shell\nCODE:\n```\n$ grpc_cli ls localhost:50051 helloworld.Greeter -l\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC Code with Protocol Buffers\nDESCRIPTION: This command generates Python code from the `prime.proto` protocol buffer definition using the `grpc_tools.protoc` tool. It specifies the input directory (`.`), the output directories for both Python and gRPC-specific Python code (`.`), and the protocol buffer file itself. This allows running the client and server without Bazel.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/multiprocessing/README.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncd examples/python/multiprocessing\npython -m grpc_tools.protoc -I . prime.proto  --python_out=. --grpc_python_out=.\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC C++ Mock Code with Bazel\nDESCRIPTION: Demonstrates how to configure a Bazel `grpc_proto_library` rule to automatically generate the gRPC C++ mock stub code. Setting the `generate_mocks = True` attribute within the rule definition triggers the generation process during the build, providing an alternative to the direct protoc command.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/unit_testing.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ngrpc_proto_library(\n  name = \"echo_proto\",\n  srcs = [\"echo.proto\"],\n  generate_mocks = True,\n)\n```\n\n----------------------------------------\n\nTITLE: gRPC Channel class in AsyncIO Python API\nDESCRIPTION: This snippet documents the Channel class, which models client-side communication channels in gRPC AsyncIO Python API. It manages connection details, load balancing, and flow control, and is typically encapsulated within stub objects for invoking remote procedures asynchronously.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: Channel\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC C++ server\nDESCRIPTION: This code snippet illustrates launching the gRPC C++ server. Running the server separately allows the client to establish a connection and complete RPCs successfully once the server is available.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/wait_for_ready/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ tools/bazel run examples/cpp/helloworld:greeter_callback_server\n```\n\n----------------------------------------\n\nTITLE: Cancelling gRPC Unary RPC Client-Side Python\nDESCRIPTION: Shows how to enable client-side cancellation for a unary gRPC call using the `.future()` method, which returns a `grpc.Future`. This future's `.cancel()` method can be invoked (e.g., in a signal handler) to terminate the in-progress RPC. Calling `.result()` after cancellation raises an `RpcError` unless the process exits. Requires `sys` and `signal` modules.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/cancellation/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nstub = hash_name_pb2_grpc.HashFinderStub(channel)\nfuture = stub.Find.future(hash_name_pb2.HashNameRequest(desired_name=name))\ndef cancel_request(unused_signum, unused_frame):\n    future.cancel()\n    sys.exit(0)\nsignal.signal(signal.SIGINT, cancel_request)\n\nresult = future.result()\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC and Protobuf Source Files in CMake\nDESCRIPTION: This snippet retrieves the absolute path for the 'helloworld.proto' file, determines its directory, and sets the output paths for the generated C++ source and header files. It uses an add_custom_command to invoke protoc, generating the gRPC and Protobuf code as needed. The outputs are later referenced by the build system and require both the protoc compiler and gRPC plugin to be available.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/load_balancing/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Generating Only gRPC Client Code from .proto File (XML, .NET)\nDESCRIPTION: This .csproj XML snippet configures Grpc.Tools to generate only C# client code (and no service base code) from the specified .proto file on build. The <Protobuf> element's GrpcServices attribute is set to \"Client\" to restrict code generation. This is suited for projects that are only consuming gRPC services and not implementing them. The path in Include should point to the relevant proto contract.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_3\n\nLANGUAGE: XML\nCODE:\n```\n<ItemGroup>\n    <Protobuf Include=\"Protos\\greet.proto\" GrpcServices=\"Client\" />\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Defining a Podspec for gRPC Proto Library Integration in Ruby\nDESCRIPTION: This Ruby Podspec defines the configuration to integrate a Protocol Buffers-based proto library for gRPC Objective-C into an Xcode project via Cocoapods. It specifies deployment targets, dependencies on the protobuf and gRPC plugins, source locations, and the commands to generate Objective-C protobuf and gRPC client files using the protoc compiler and gRPC plugin. Subspects separate generated message files and gRPC service files with appropriate ARC settings and dependencies. Variables allow flexible directory paths and command execution. The spec enables seamless updates with `pod update` and requires setting correct paths relative to the Podfile. It is designed for iOS 15+, OS X 11+, and supports multiple Apple platforms.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/objective-c/README.md#_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nPod::Spec.new do |s|\n  s.name     = '<Podspec file name>'\n  s.version  = '0.0.1'\n  s.license  = '...'\n  s.authors  = { '<your name>' => '<your email>' }\n  s.homepage = '...'\n  s.summary = '...'\n  s.source = { :git => 'https://github.com/...' }\n\n  s.ios.deployment_target = '15.0'\n  s.osx.deployment_target = '11.0'\n  s.tvos.deployment_target = '13.0'\n  s.watchos.deployment_target = '6.0'\n  s.visionos.deployment_target = '1.0'\n\n  # Base directory where the .proto files are.\n  src = '.'\n\n  # We'll use protoc with the gRPC plugin.\n  s.dependency '!ProtoCompiler-gRPCPlugin', '~> 1.0'\n\n  # Pods directory corresponding to this app's Podfile, relative to the location of this podspec.\n  pods_root = '<path to your Podfile>/Pods'\n\n  # Path where Cocoapods downloads protoc and the gRPC plugin.\n  protoc_dir = \"#{pods_root}/!ProtoCompiler\"\n  protoc = \"#{protoc_dir}/protoc\"\n  plugin = \"#{pods_root}/!ProtoCompiler-gRPCPlugin/grpc_objective_c_plugin\"\n\n  # Directory where you want the generated files to be placed. This is an example.\n  dir = \"#{pods_root}/#{s.name}\"\n\n  # Run protoc with the Objective-C and gRPC plugins to generate protocol messages and gRPC clients.\n  # You can run this command manually if you later change your protos and need to regenerate.\n  # Alternatively, you can advance the version of this podspec and run `pod update`.\n  s.prepare_command = <<-CMD\n    mkdir -p #{dir}\n    #{protoc} \\\n        --plugin=protoc-gen-grpc=#{plugin} \\\n        --objc_out=#{dir} \\\n        --grpc_out=#{dir} \\\n        -I #{src} \\\n        -I #{protoc_dir} \\\n        #{src}/*.proto\n  CMD\n\n  # The --objc_out plugin generates a pair of .pbobjc.h/.pbobjc.m files for each .proto file.\n  s.subspec 'Messages' do |ms|\n    ms.source_files = \"#{dir}/*.pbobjc.{h,m}\"\n    ms.header_mappings_dir = dir\n    ms.requires_arc = false\n    # The generated files depend on the protobuf runtime.\n    ms.dependency 'Protobuf'\n  end\n\n  # The --objcgrpc_out plugin generates a pair of .pbrpc.h/.pbrpc.m files for each .proto file with\n  # a service defined.\n  s.subspec 'Services' do |ss|\n    ss.source_files = \"#{dir}/*.pbrpc.{h,m}\"\n    ss.header_mappings_dir = dir\n    ss.requires_arc = true\n    # The generated files depend on the gRPC runtime, and on the files generated by `--objc_out`.\n    ss.dependency 'gRPC-ProtoRPC'\n    ss.dependency \"#{s.name}/Messages\"\n  end\n\n  s.pod_target_xcconfig = {\n    # This is needed by all pods that depend on Protobuf:\n    'GCC_PREPROCESSOR_DEFINITIONS' => '$(inherited) GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS=1',\n    # This is needed by all pods that depend on gRPC-RxLibrary:\n    'CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES' => 'YES',\n  }\nend\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC C++ Mock Code with Protoc\nDESCRIPTION: Provides the command-line instruction for using the `protoc` compiler with the gRPC C++ plugin. The `generate_mock_code=true` flag is crucial here, instructing the plugin to generate a separate header file (`echo_mock.grpc.pb.h` in this case) containing the mock stub definition alongside the standard generated code.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/unit_testing.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nprotoc -I . --grpc_out=generate_mock_code=true:. --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` echo.proto\n```\n\n----------------------------------------\n\nTITLE: Generating C++ gRPC Sources from Proto Files - CMake Function\nDESCRIPTION: Defines the android_protobuf_grpc_generate_cpp CMake function, which automates the generation of C++ source and header files from .proto definitions. The function invokes protoc with the gRPC C++ plugin for each provided proto file, configures output directory structure, and registers all generated files as output. Dependencies include the protoc binary, gRPC C++ plugin, and the proto definitions to process. It expects input lists for source and header files, and the root include directory; outputs are registered C++ source/header files.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/android/helloworld/app/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(android_protobuf_grpc_generate_cpp SRC_FILES HDR_FILES INCLUDE_ROOT)\n  if(NOT ARGN)\n    message(SEND_ERROR \"Error: android_protobuf_grpc_generate_cpp() called without any proto files\")\n    return()\n  endif()\n\n  set(${SRC_FILES})\n  set(${HDR_FILES})\n  set(PROTOBUF_INCLUDE_PATH -I ${INCLUDE_ROOT})\n  foreach(FIL ${ARGN})\n    get_filename_component(ABS_FIL ${FIL} ABSOLUTE)\n    get_filename_component(FIL_WE ${FIL} NAME_WE)\n    file(RELATIVE_PATH REL_FIL ${CMAKE_CURRENT_SOURCE_DIR}/${INCLUDE_ROOT} ${ABS_FIL})\n    get_filename_component(REL_DIR ${REL_FIL} DIRECTORY)\n    set(RELFIL_WE \"${REL_DIR}/${FIL_WE}\")\n\n    list(APPEND ${SRC_FILES} \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.pb.cc\")\n    list(APPEND ${HDR_FILES} \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.pb.h\")\n    list(APPEND ${SRC_FILES} \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.grpc.pb.cc\")\n    list(APPEND ${HDR_FILES} \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.grpc.pb.h\")\n\n    add_custom_command(\n      OUTPUT \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.grpc.pb.cc\"\n             \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.grpc.pb.h\"\n             \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.pb.cc\"\n             \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.pb.h\"\n      COMMAND ${helloworld_PROTOBUF_PROTOC_EXECUTABLE}\n      ARGS --grpc_out=${GRPC_PROTO_GENS_DIR}\n        --cpp_out=${GRPC_PROTO_GENS_DIR}\n        --plugin=protoc-gen-grpc=${helloworld_GRPC_CPP_PLUGIN_EXECUTABLE}\n        ${PROTOBUF_INCLUDE_PATH}\n        ${REL_FIL}\n      WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n      DEPENDS ${helloworld_PROTOBUF_PROTOC_EXECUTABLE} ${helloworld_GRPC_CPP_PLUGIN_EXECUTABLE} ${ABS_FIL} )\n  endforeach()\n\n  set_source_files_properties(${${SRC_FILES}} ${${HDR_FILES}} PROPERTIES GENERATED TRUE)\n  set(${SRC_FILES} ${${SRC_FILES}} PARENT_SCOPE)\n  set(${HDR_FILES} ${${HDR_FILES}} PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Querying gRPC Channel State (C++)\nDESCRIPTION: This C++ method allows an application to query the current connectivity state of a gRPC channel. It returns an enum representing one of the five defined states. The boolean parameter 'try_to_connect' can be used to explicitly transition an IDLE channel to CONNECTING, effectively simulating an RPC attempt and resetting the IDLE timeout.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ngrpc_connectivity_state GetState(bool try_to_connect);\n```\n\n----------------------------------------\n\nTITLE: HTTP/2 Framing for gRPC Unary Request\nDESCRIPTION: Illustrates the structure of an HTTP/2 request used for a gRPC unary call. Shows mandatory and optional headers like :method, :path, :authority, grpc-timeout, content-type, and authorization, followed by a DATA frame containing the length-prefixed message.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#_snippet_0\n\nLANGUAGE: HTTP/2\nCODE:\n```\nHEADERS (flags = END_HEADERS)\n:method = POST\n:scheme = http\n:path = /google.pubsub.v2.PublisherService/CreateTopic\n:authority = pubsub.googleapis.com\ngrpc-timeout = 1S\ncontent-type = application/grpc+proto\ngrpc-encoding = gzip\nauthorization = Bearer y235.wef315yfh138vh31hv93hv8h3v\n\nDATA (flags = END_STREAM)\n<Length-Prefixed Message>\n```\n\n----------------------------------------\n\nTITLE: Client Interceptor classes in AsyncIO Python API\nDESCRIPTION: This snippet describes classes for client-side interceptors such as ClientCallDetails, InterceptedUnaryUnaryCall, ClientInterceptor, and specific call interceptors for different RPC types. These classes enable modification and monitoring of client RPCs for functionalities like logging, authentication, or retries.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: ClientCallDetails\n.. autoclass:: InterceptedUnaryUnaryCall\n.. autoclass:: ClientInterceptor\n.. autoclass:: UnaryUnaryClientInterceptor\n.. autoclass:: UnaryStreamClientInterceptor\n.. autoclass:: StreamUnaryClientInterceptor\n.. autoclass:: StreamStreamClientInterceptor\n```\n\n----------------------------------------\n\nTITLE: Generating Protobuf and gRPC Code\nDESCRIPTION: This snippet adds a custom command to generate C++ source files from the helloworld.proto file using the protobuf compiler (protoc) and the gRPC plugin. It defines the output files, specifies the command and arguments to be executed.  It depends on the helloworld.proto file.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Performing Standard gRPC Unary RPC Python\nDESCRIPTION: Demonstrates a basic unary gRPC call using a generated stub in Python. The method call blocks until the server responds or an error occurs, returning the deserialized response object directly. This standard approach does not provide a direct method for client-side cancellation via the return value.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/cancellation/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> stub = hash_name_pb2_grpc.HashFinderStub(channel)\n>>> stub.Find(hash_name_pb2.HashNameRequest(desired_name=name))\n<hash_name_pb2.HashNameResponse object at 0x7fe2eb8ce2d0>\n```\n\n----------------------------------------\n\nTITLE: Logging Request Headers in C++ gRPC\nDESCRIPTION: Defines functions to log request headers for client and server contexts, capturing call metadata such as method name, peer info, and metadata contents. These functions aid in tracking incoming and outgoing request headers during gRPC calls.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/binary-logging.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// The context provides the method_name, deadline, peer, and metadata contents.\n// direction = CLIENT_SEND\nLogRequestHeaders(ClientContext context);\n\n// The context provides the metadata contents\n// direction = SERVER_RECV\nLogRequestHeaders(ServerContext context);\n```\n\n----------------------------------------\n\nTITLE: Integrating Protobuf Compilation into setuptools - Python setup.py\nDESCRIPTION: Shows how to register the `grpc_tools.command.BuildPackageProtos` command class within a `setuptools.setup` call. This integrates the protobuf and gRPC stub compilation as a custom build command for setuptools-based projects. Note that `grpcio-tools` must be installed *before* running setup.py for this to work directly.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/distrib/python/grpcio_tools/README.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsetuptools.setup(\n  # ...\n  cmdclass={\n    'build_proto_modules': grpc_tools.command.BuildPackageProtos,\n  }\n  # ...\n)\n```\n\n----------------------------------------\n\nTITLE: Overriding Per-Call Compression Algorithm in gRPC C++ Client\nDESCRIPTION: Overrides the default channel compression setting for an individual RPC call by setting the compression algorithm (DEFLATE) on the ClientContext before making the call. Requires an initialized ClientContext object.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/compression/README.md#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n    // Overwrite the call's compression algorithm to DEFLATE.\n    context.set_compression_algorithm(GRPC_COMPRESS_DEFLATE);\n```\n\n----------------------------------------\n\nTITLE: Generating Protobuf Code\nDESCRIPTION: This section defines the generated source and header files and uses `add_custom_command` to invoke the protobuf compiler (`protoc`). It generates the C++ code for the protobuf messages and the gRPC service definition. The command uses the protobuf compiler with the gRPC plugin to generate the appropriate C++ files. It depends on the protobuf file.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/generic_api/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Generated sources\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC Load Balancing Policy in C++ Client\nDESCRIPTION: Demonstrates how to set the load balancing policy for a gRPC client channel in C++. It uses ChannelArguments to specify the policy name \"round_robin\" and creates a custom channel connecting to localhost on port 50051 with insecure credentials. This snippet requires including the gRPC C++ headers and linking against gRPC libraries. It is dependent on the hello world gRPC client implementation and modifies channel creation to support load balancing.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/load_balancing/README.md#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n  ChannelArguments args;\n  // Set the load balancing policy for the channel.\n  args.SetLoadBalancingPolicyName(\"round_robin\");\n  GreeterClient greeter(grpc::CreateCustomChannel(\n      \"localhost:50051\", grpc::InsecureChannelCredentials(), args));\n```\n\n----------------------------------------\n\nTITLE: Activating Python Virtual Environment\nDESCRIPTION: This Bash snippet activates the previously created Python virtual environment. This process changes the shell's environment to use the dependencies specified in the virtual environment, allowing correct package imports. The script is sourced, which executes its commands within the current shell session.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsource ~/.virtualenvs/grpc-python/bin/activate\n```\n\n----------------------------------------\n\nTITLE: RPC Context class in AsyncIO Python API\nDESCRIPTION: This snippet details the RpcContext class, which provides context for an ongoing RPC call, including methods for retrieving details about the call, sending responses, and managing RPC state in an asynchronous environment.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: RpcContext\n```\n\n----------------------------------------\n\nTITLE: gRPC Metadata class in AsyncIO Python API\nDESCRIPTION: This snippet describes the Metadata class used for representing gRPC call metadata in the AsyncIO Python API. Metadata consists of key-value pairs transmitted with RPCs, supporting custom headers and context propagation.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: Metadata\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Command for Protobuf/gRPC Generation - CMake\nDESCRIPTION: Defines a custom build command that runs the `protoc` compiler with the gRPC plugin. It specifies the output directories for generated C++ and gRPC code, the include path for the proto file, the gRPC plugin executable, and the input proto file. This command is triggered when the input proto file changes.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/cancellation/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Compression for gRPC PHP Client\nDESCRIPTION: Demonstrates setting compression options for a PHP gRPC client using 'grpc.default_compression_algorithm' and 'grpc.default_compression_level' channel arguments during client creation. The example sets GZIP compression (algorithm value 2) with a medium compression level (level value 2). Possible algorithm values are 0 (None), 1 (DEFLATE), 2 (GZIP), 3 (Stream GZIP). Possible level values are 0 (None), 1 (Low), 2 (Medium), 3 (High).\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_26\n\nLANGUAGE: php\nCODE:\n```\n$client = new Helloworld\\GreeterClient('localhost:50051', [\n    'credentials' => Grpc\\ChannelCredentials::createInsecure(),\n    'grpc.default_compression_algorithm' => 2,\n    'grpc.default_compression_level' => 2,\n]);\n```\n\n----------------------------------------\n\nTITLE: Cloning gRPC Repo and Initializing Submodules for Unit Tests - Shell Script\nDESCRIPTION: Shows cloning the gRPC repository at a release tag and initializing submodules, establishing an environment for running the project\\'s PHP unit test suite. This is a prerequisite for integration with the test runner and stub generation scripts.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_15\n\nLANGUAGE: sh\nCODE:\n```\n$ git clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc\n$ cd grpc\n$ git submodule update --init\n```\n\n----------------------------------------\n\nTITLE: Setting GDB Breakpoint in gRPC Stub Function (Bash)\nDESCRIPTION: Shows how to run a gRPC client application under the GDB debugger and set a specific breakpoint (`-ex 'b ...'`) within a generated C++ gRPC stub method. This allows stepping through the code execution at a specific point.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/debugging/README.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\ngdb -ex 'b helloworld::Greeter::Stub::SayHello' \\\n    -ex run \\\n    --args ./bazel-bin/examples/cpp/debugging/crashing_greeter_client \\\n            --crash_on_errors=true \\\n            --target=localhork:50051\n```\n\n----------------------------------------\n\nTITLE: Initializing gRPC Custom Metrics Server in C++\nDESCRIPTION: Sets up a gRPC C++ server to support custom metrics. It creates a ServerMetricRecorder, initializes the OrcaService with the recorder and reporting options, registers the OrcaService with the server builder, and enables call metric recording on the server. This is the necessary setup before metrics can be reported.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/orca/README.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nGreeterServiceImpl service;\n// Setup custom metrics recording\nauto server_metric_recorder =\n    grpc::experimental::ServerMetricRecorder::Create();\ngrpc::experimental::OrcaService orca_service(\n    server_metric_recorder.get(),\n    grpc::experimental::OrcaService::Options().set_min_report_duration(\n        absl::Seconds(0.1)));\nbuilder.RegisterService(&orca_service);\ngrpc::ServerBuilder::experimental_type(&builder).EnableCallMetricRecording(\n    nullptr);\n```\n\n----------------------------------------\n\nTITLE: Defining Client Executable and Linking Dependencies\nDESCRIPTION: This snippet defines an executable target named `client` using the specified source files (`client.cc` and `caching_interceptor.h`). It then links this executable to necessary libraries including the previously defined `kvs_grpc_proto`, Abseil, Protobuf reflection, gRPC core, and the core Protobuf library.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/interceptors/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# client\nadd_executable(client \"client.cc\" \"caching_interceptor.h\")\ntarget_link_libraries(client\n  absl::check\n  kvs_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Defining Mock gRPC C++ Stub using Google Mock\nDESCRIPTION: Shows how to define a mock class `MockEchoTestServiceStub` that inherits from the generated `EchoTestService::StubInterface`. It uses Google Mock's `MOCK_METHOD` macro to declare mock implementations for the pure virtual RPC methods (`Echo` and `BidiStreamRaw`) of the interface, enabling their behavior to be controlled and verified in tests.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/unit_testing.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nclass MockEchoTestServiceStub : public EchoTestService::StubInterface {\n public:\n  MOCK_METHOD3(Echo, ::grpc::Status(::grpc::ClientContext* context, const ::grpc::testing::EchoRequest& request, ::grpc::testing::EchoResponse* response));\n  MOCK_METHOD1(BidiStreamRaw, ::grpc::ClientReaderWriterInterface< ::grpc::testing::EchoRequest, ::grpc::testing::EchoResponse>*(::grpc::ClientContext* context));\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Protobuf Item Metadata with Additional Arguments in MSBuild XML\nDESCRIPTION: This snippet demonstrates how to define a <Protobuf> item within an MSBuild ItemGroup to include .proto files for processing. It shows setting the ProtoRoot, OutputDir, disabling CompileOutputs, and providing multiple additional command-line arguments to the protoc compiler using the AdditionalProtocArguments metadata, separated by semicolons.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_6\n\nLANGUAGE: xml\nCODE:\n```\n  <ItemGroup>\n    <Protobuf Include=\"proto_root/**/*.proto\" ProtoRoot=\"proto_root\"\n              OutputDir=\"%(RelativeDir)\" CompileOutputs=\"false\"\n              AdditionalProtocArguments=\"--plugin=protoc-gen-myplugin=D:\\myplugin.exe;--myplugin_out=.\" />\n  </ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Setting Default Channel Compression Algorithm in gRPC C++ Client\nDESCRIPTION: Configures the default compression algorithm (GZIP) for all RPC calls made on a specific gRPC channel using ChannelArguments when creating the client. This setting applies unless overridden per call. Requires the gRPC C++ library.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/compression/README.md#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n  ChannelArguments args;\n  // Set the default compression algorithm for the channel.\n  args.SetCompressionAlgorithm(GRPC_COMPRESS_GZIP);\n  GreeterClient greeter(grpc::CreateCustomChannel(\n      \"localhost:50051\", grpc::InsecureChannelCredentials(), args));\n```\n\n----------------------------------------\n\nTITLE: Including Generated Headers in Build\nDESCRIPTION: Adds the directory containing generated protobuf headers to the include path, ensuring that subsequent source files can include and depend on generated code.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/codelab/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\ninclude_directories(\"${CMAKE_SOURCE_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Defining Executable Targets for Client and Server\nDESCRIPTION: Uses a loop to create multiple executables: client and server versions of the greeter callback application, linking each with required libraries including absl flags, OpenTelemetry metrics and Prometheus exporter, gRPC plugin, and utility code.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/codelab/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(_target\n  greeter_callback_client greeter_callback_server greeter_callback_client_solution greeter_callback_server_solution)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    opentelemetry-cpp::metrics\n    opentelemetry-cpp::prometheus_exporter\n    gRPC::grpcpp_otel_plugin\n    util)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Making a gRPC Call with Deflate Compression Override in Python\nDESCRIPTION: Demonstrates how to override the channel-level compression by specifying the Deflate compression algorithm directly on an individual RPC call. Uses a generated GreeterStub to invoke the SayHello method with a HelloRequest. Depends on the grpc module and the appropriate protobuf-generated stub and request classes. This snippet sends compressed payload specifically for this call.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/compression/README.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nstub = helloworld_pb2_grpc.GreeterStub(channel)\nresponse = stub.SayHello(helloworld_pb2.HelloRequest(name='you'),\n                         compression=grpc.Compression.Deflate)\n```\n\n----------------------------------------\n\nTITLE: Running the Route Guide Server with Bazel\nDESCRIPTION: Command to build and run the gRPC RouteGuide callback server example using Bazel build system.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/route_guide/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntools/bazel run examples/cpp/route_guide:route_guide_callback_server\n```\n\n----------------------------------------\n\nTITLE: Stream-Unary Pattern in gRPC Python\nDESCRIPTION: In this pattern, the client can send multiple messages to the server in a single call, while the server responds with a single message. Implemented through client_streaming_method in client.py and ClientStreamingMethod in server.py.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/data_transmission/README.en.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclient_streaming_method\nClientStreamingMethod\n```\n\n----------------------------------------\n\nTITLE: Unary-Stream Pattern in gRPC Python\nDESCRIPTION: In this pattern, the client sends a single request to the server, and the server responds with multiple messages. Implemented through server_streaming_method in client.py and ServerStreamingMethod in server.py.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/data_transmission/README.en.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nserver_streaming_method\nServerStreamingMethod\n```\n\n----------------------------------------\n\nTITLE: Initializing ProtoReflectionDescriptorDatabase in a Python Client\nDESCRIPTION: Initializes a `ProtoReflectionDescriptorDatabase` instance for a gRPC Python client. This requires an active gRPC channel (`channel`) to the target server. The `ProtoReflectionDescriptorDatabase` uses this channel to communicate with the server's reflection service to retrieve service information.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/server_reflection.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport grpc\nfrom grpc_reflection.v1alpha.proto_reflection_descriptor_database import ProtoReflectionDescriptorDatabase\n\nchannel = grpc.secure_channel(server_address, creds)\nreflection_db = ProtoReflectionDescriptorDatabase(channel)\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC C++ client with wait-for-ready setting\nDESCRIPTION: This code snippet shows how to execute the gRPC C++ client that performs multiple RPCs, some of which have the wait-for-ready option set. It demonstrates the effect of this setting on RPCs failing or succeeding based on the channel's connection status.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/wait_for_ready/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ tools/bazel run examples/cpp/wait_for_ready:greeter_callback_client\n```\n\n----------------------------------------\n\nTITLE: Configuring Health Client and Server Executable Targets\nDESCRIPTION: Creates executable targets for health client and server applications and links them with the generated proto libraries, Abseil libraries, and other dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/health/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# Targets greeter_[async_](client|server)\nforeach(_target\n  health_client health_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    health_grpc_proto\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Building and Linking gRPC Client/Server Executables in CMake\nDESCRIPTION: Iterates through the targets `greeter_client` and `greeter_server`. For each target, it creates an executable using the corresponding source file (e.g., `greeter_client.cc`). It then links the executable against the `hw_grpc_proto` library (containing generated code), Abseil flags and log initialization libraries, and the core gRPC C++ (`_GRPC_GRPCPP`), Protobuf (`_PROTOBUF_LIBPROTOBUF`), and reflection (`_REFLECTION`) libraries.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/error_handling/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Targets greeter_(client|server)\nforeach(_target\n  greeter_client greeter_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Adding gRPC Admin Services to Server Builder (C++)\nDESCRIPTION: Demonstrates how to integrate the gRPC Admin Service into a C++ server using `grpc::AddAdminServices`. This method is called on a `grpc::ServerBuilder` instance before building and starting the server. Requires the gRPC library.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/debugging/README.md#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\ngrpc::ServerBuilder builder;\ngrpc::AddAdminServices(&builder);\nbuilder.AddListeningPort(\":50051\", grpc::ServerCredentials(...));\nstd::unique_ptr<grpc::Server> server(builder.BuildAndStart());\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Generic API Server (Shell)\nDESCRIPTION: Command to start the example gRPC server (`greeter_server`) implemented using generic APIs. The server is expected to listen on port 50051 for incoming client requests.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/generic_api/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ ./greeter_server\n```\n\n----------------------------------------\n\nTITLE: Dynamically Creating gRPC Messages using Reflection in Python Client\nDESCRIPTION: Illustrates retrieving a message type descriptor (`FindMessageTypeByName`) from the reflection-backed `DescriptorPool` (`desc_pool`) and then using `MessageFactory` to dynamically create an instance of that message type. This is useful for clients interacting with services whose message types are not known at compile time. Requires `MessageFactory` from `google.protobuf.message_factory`.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/server_reflection.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nrequest_desc = desc_pool.FindMessageTypeByName(\"helloworld.HelloRequest\")\nrequest = MessageFactory(desc_pool).GetPrototype(request_desc)()\n```\n\n----------------------------------------\n\nTITLE: Defining Proto File Paths and Generated Files - CMake\nDESCRIPTION: Uses `get_filename_component` to get the absolute path and directory of the helloworld.proto file. Then, it defines CMake variables to hold the expected paths for the C++ and gRPC source and header files that will be generated from the proto file.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/cancellation/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\n```\n\n----------------------------------------\n\nTITLE: Defining the xDS Bootstrap File Format in JSON for gRPC\nDESCRIPTION: This JSON structure outlines the complete xDS bootstrap configuration used by gRPC clients. It defines essential components like the xDS server(s) to connect to (`xds_servers`), client identification information (`node`), external certificate provider configurations (`certificate_providers`), templates for listener resource names (`server_listener_resource_name_template`, `client_default_listener_resource_name_template`), and authority-specific settings (`authorities`). This configuration can be provided via the `GRPC_XDS_BOOTSTRAP` environment variable (file path) or `GRPC_XDS_BOOTSTRAP_CONFIG` (direct JSON content).\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/grpc_xds_bootstrap_format.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  // The xDS server to talk to.  The value is an ordered array of server\n  // configurations, to support failing over to a secondary xDS server if the\n  // primary is down.\n  //\n  // Prior to gRFC A71, all but the first entry was ignored.\n  \"xds_servers\": [\n    {\n\n      // A target URI string suitable for creating a gRPC channel.\n      \"server_uri\": <string containing the target URI of xds server>,\n\n      // List of channel creds; client will stop at the first type it\n      // supports.  This field is required and must contain at least one\n      // channel creds type that the client supports.\n      //\n      // See section titled \"Supported Channel Credentials\".\n      \"channel_creds\": [\n        {\n          \"type\": <string containing channel cred type>,\n\n          // The \"config\" field is optional; it may be missing if the\n          // credential type does not require config parameters.\n          \"config\": <JSON object containing config for the type>\n        }\n      ],\n\n      // A list of features supported by the server.  New values will\n      // be added over time.  For forward compatibility reasons, the\n      // client will ignore any entry in the list that it does not\n      // understand, regardless of type.\n      // \n      // See section titled \"Supported Server Features\".\n      \"server_features\": [ ... ]\n    }\n  ],\n\n  // Identifies a specific gRPC instance.\n  \"node\": {\n\n    // Opaque identifier for the gRPC instance.\n    \"id\": <string>,\n\n    // Identifier for the local service cluster where the gRPC instance is\n    // running.\n    \"cluster\": <string>,\n\n    // Specifies where the gRPC instance is running.\n    \"locality\": {\n      \"region\": <string>,\n      \"zone\": <string>,\n      \"sub_zone\": <string>,\n    },\n\n    // Opaque metadata extending the node identifier.\n    \"metadata\": <JSON Object>,\n  }\n\n  // Map of supported certificate providers, keyed by the provider instance\n  // name.\n  // See section titled \"Supported certificate providers\".\n  \"certificate_providers\": {\n\n    // Certificate provider instance name, specified by the\n    // control plane, to fetch certificates from.\n    \"<instance_name>\": {\n\n      // Name of the plugin implementation.\n      \"plugin_name\": <string containing plugin type>,\n\n      // A JSON object containing the configuration for the plugin, whose schema\n      // is defined by the plugin.  The \"config\" field is optional; it may be\n      // missing if the credential type does not require config parameters.\n      \"config\": <JSON object containing config for the type>\n    }\n  }\n\n  // A template for the name of the Listener resource to subscribe to for a gRPC\n  // server. If the token `%s` is present in the string, all instances of the\n  // token will be replaced with the server's listening \"IP:port\" (e.g.,\n  // \"0.0.0.0:8080\", \"[::]:8080\").\n  \"server_listener_resource_name_template\": \"example/resource/%s\",\n\n  // A template for the name of the Listener resource to subscribe to for a gRPC\n  // client channel.  Used only when the channel is created with an \"xds:\" URI\n  // with no authority.\n  //\n  // If starts with \"xdstp:\", will be interpreted as a new-style name, in which\n  // case the authority of the URI will be used to select the relevant\n  // configuration in the \"authorities\" map.\n  //\n  // The token \"%s\", if present in this string, will be replaced with the\n  // service authority (i.e., the path part of the target URI used to create the\n  // gRPC channel).  If the template starts with \"xdstp:\", the replaced string\n  // will be percent-encoded.  In that case, the replacement string must include\n  // only characters allowed in a URI path as per RFC-3986 section 3.3 (which\n  // includes '/'), and all other characters must be percent-encoded.\n  //\n  // Defaults to \"%s\".\n  \"client_default_listener_resource_name_template\": <string>,\n\n  // A map of authority name to corresponding configuration.\n  //\n  // This is used in the following cases:\n  // - A gRPC client channel is created using an \"xds:\" URI that includes\n  //   an authority.\n  // - A gRPC client channel is created using an \"xds:\" URI with no\n  //   authority, but the \"client_default_listener_resource_name_template\"\n  //   field turns it into an \"xdstp:\" URI.\n  // - A gRPC server is created and the\n  //   \"server_listener_resource_name_template\" field is an \"xdstp:\" URI.\n  //\n  // In any of those cases, it is an error if the specified authority is\n  // not present in this map.\n  \"authorities\": {\n    // Entries are keyed by authority name.\n    // Note: If a new-style resource name has no authority, we will use\n    // the empty string here as the key.\n    \"<authority_name>\": {\n\n      // A template for the name of the Listener resource to subscribe\n      // to for a gRPC client channel.  Used only when the channel is\n      // created using an \"xds:\" URI with this authority name.\n      //\n      // The token \"%s\", if present in this string, will be replaced\n      // with percent-encoded service authority (i.e., the path part of the\n      // target URI used to create the gRPC channel).  The replacement string\n      // must include only characters allowed in a URI path as per RFC-3986\n      // section 3.3 (which includes '/'), and all other characters must be\n      // percent-encoded.\n      //\n      // Must start with \"xdstp://<authority_name>/\".  If it does not,\n      // that is considered a bootstrap file parsing error.\n      //\n      // If not present in the bootstrap file, defaults to\n      // \"xdstp://<authority_name>/envoy.config.listener.v3.Listener/%s\".\n      \"client_listener_resource_name_template\": <string>,\n\n      // Ordered list of xDS servers to contact for this authority.\n      // Format is exactly the same as the top level \"xds_servers\" field.\n      //\n      // If the same server is listed in multiple authorities, the\n      // entries will be de-duped (i.e., resources for both authorities\n      // will be fetched on the same ADS stream).\n      //\n      // If not specified, the top-level server list is used.\n      \"xds_servers\": [ ... ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Grpc.Tools Package Reference in .csproj (XML, .NET)\nDESCRIPTION: This snippet shows how to reference the Grpc.Tools NuGet package in a .csproj file to enable code generation of C# classes from .proto files during build. The PrivateAssets property is set to 'all' to ensure the tooling dependency is only used at build-time and isn't included at runtime. The IncludeAssets property restricts which asset types are included, supporting granular NuGet asset management. No runtime components are added to the published application. The Version property specifies the desired version of the tools.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_0\n\nLANGUAGE: XML\nCODE:\n```\n<PackageReference Include=\"Grpc.Tools\" Version=\"2.50.0\">\n  <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n  <PrivateAssets>all</PrivateAssets>\n</PackageReference>\n```\n\n----------------------------------------\n\nTITLE: Overriding Per-Call Compression Algorithm in gRPC C++ Server\nDESCRIPTION: Overrides the default server compression setting for a specific response within a service handler method by setting the compression algorithm (DEFLATE) on the ServerContext. Requires access to the ServerContext object within the handler.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/compression/README.md#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n    // Overwrite the call's compression algorithm to DEFLATE.\n    context->set_compression_algorithm(GRPC_COMPRESS_DEFLATE);\n```\n\n----------------------------------------\n\nTITLE: Creating Client/Server Executables\nDESCRIPTION: This section defines the client and server executables, links them with the `hw_grpc_proto` library, and other necessary dependencies, such as absl flags. It iterates through a list of target names (`greeter_client`, `greeter_server`) and creates executable targets. Each executable links against the `hw_grpc_proto` library, reflection, gRPC, and protobuf libraries.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/generic_api/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# Targets greeter_(client|server)\nforeach(_target\n  greeter_client greeter_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Building and Running gRPC Load Balancing Example Using Shell Commands\nDESCRIPTION: Commands used to compile the example client/server source code using make, then execute the server and client binaries respectively. These commands assume a proper Makefile is present in the current directory. This sequence demonstrates starting the gRPC server followed by the client to test load balancing functionality.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/load_balancing/README.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nmake\n./greeter_server\n```\n\nLANGUAGE: sh\nCODE:\n```\n./greeter_client\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Reflection Messages and Service in Proto\nDESCRIPTION: This .proto snippet defines the messages and service contract for the gRPC Server Reflection Protocol. It includes the structure for client requests (`DescriptorDatabaseRequest`) with different query types (file name, symbol, extension) and server responses (`DescriptorDatabaseResponse`) which return file descriptors or extension lists, all exchanged over a bidirectional streaming RPC (`DescriptorDatabaseInfo`).\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server-reflection.md#_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\npackage grpc.reflection.v1alpha;\nmessage DescriptorDatabaseRequest {\n  string host = 1;\n  oneof message_request {\n    string files_for_file_name = 3;\n    string files_for_symbol_name = 4;\n    FileContainingExtensionRequest file_containing_extension = 5;\n    string list_all_extensions_of_type = 6;\n  }\n}\n\nmessage FileContainingExtensionRequest {\n  string base_message = 1;\n  int64 extension_id = 2;\n}\n\nmessage DescriptorDatabaseResponse {\n  string valid_host = 1;\n  DescriptorDatabaseRequest original_request = 2;\n  oneof message_response {\n    // These are proto2 type google.protobuf.FileDescriptorProto, but\n    // we avoid taking a dependency on descriptor.proto, which uses\n    // proto2 only features, by making them opaque\n    // bytes instead\n    repeated bytes fd_proto = 4;\n    ListAllExtensionsResponse extensions_response = 5;\n    // Notably includes error code 5, NOT FOUND\n    int32 error_code = 6;\n  }\n}\n\nmessage ListAllExtensionsResponse {\n  string base_type_name;\n  repeated int64 extension_number;\n}\n\nservice ProtoDescriptorDatabase {\n  rpc DescriptorDatabaseInfo(stream DescriptorDatabaseRequest) returns (stream DescriptorDatabaseResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a DescriptorPool with Reflection Database in Python Client\nDESCRIPTION: Creates a `google.protobuf.descriptor_pool.DescriptorPool` instance using the `ProtoReflectionDescriptorDatabase` (`reflection_db`) created previously. This descriptor pool can then be used to find service, method, and message type descriptors fetched dynamically via server reflection.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/server_reflection.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom google.protobuf.descriptor_pool import DescriptorPool\n\ndesc_pool = DescriptorPool(reflection_db)\n```\n\n----------------------------------------\n\nTITLE: Creating gRPC Proto Library\nDESCRIPTION: Creates a static library named `hw_grpc_proto` from the generated protobuf and gRPC source files.  This library encapsulates the generated code, making it easier to link against the client and server executables. Links against necessary gRPC, protobuf, and abseil libraries.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  absl::check\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Calling a Remote Method with gRPC CLI\nDESCRIPTION: Command to call a unary method on a gRPC server and display the response using the gRPC CLI tool.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_reflection_tutorial.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n$ grpc_cli call localhost:50051 SayHello \"name: 'gRPC CLI'\"\n```\n\n----------------------------------------\n\nTITLE: Building gRPC C++ with CMake and Make on Linux/Unix - Shell\nDESCRIPTION: Configures and builds gRPC C++ using CMake and the default Make generator on Linux or Unix-like systems. Creates a build directory, runs CMake specifying C++17 standard, and then compiles using `make`. Use `-DBUILD_SHARED_LIBS=ON` during the `cmake` step to build shared libraries.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\n$ mkdir -p cmake/build\n$ cd cmake/build\n$ cmake -DCMAKE_CXX_STANDARD=17 ../..\n$ make\n```\n\n----------------------------------------\n\nTITLE: Creating PHP gRPC Client with SSL Credentials - PHP\nDESCRIPTION: Demonstrates constructing a gRPC PHP client with SSL channel credentials, loading a PEM certificate from file. The PHP array parameter 'credentials' is set to a ChannelCredentials object created by Grpc\\ChannelCredentials::createSsl. Useful for secure, production-ready communications to gRPC servers.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_20\n\nLANGUAGE: php\nCODE:\n```\n$client = new Helloworld\\GreeterClient('localhost:50051', [\n    'credentials' => Grpc\\ChannelCredentials::createSsl(\n        file_get_contents('<path to certificate>'))\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating C++ Library for HelloWorld Proto Generated Code\nDESCRIPTION: Adds a library target for the generated HelloWorld proto code and links necessary dependencies including reflection, gRPC++, and Protocol Buffers.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/health/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# Include generated *.pb.h files\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n\n# hw_grpc_proto\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Defining Server Executable and Linking Dependencies\nDESCRIPTION: This snippet defines an executable target named `server` using the specified source file (`server.cc`). It links this executable to libraries required for the server, including the `kvs_grpc_proto` library, various Abseil utilities (check, flags_parse, log_initialize), Protobuf reflection, gRPC core, and the core Protobuf library.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/interceptors/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# server\nadd_executable(server \"server.cc\")\ntarget_link_libraries(server\n  absl::check\n  absl::flags_parse\n  absl::log_initialize\n  kvs_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Running the Benchmark Driver with QPS Workers - Bash\nDESCRIPTION: This snippet demonstrates running the performance driver executable with a specified set of QPS worker hosts and a JSON configuration scenario. The 'QPS_WORKERS' environment variable is set to define worker machine addresses, and the driver takes a formatted scenario JSON string as input. The setup enables distribution of load and test roles to multiple hosts for realistic benchmarking. The process requires the driver and worker binaries to be built and accessible, and assumes the input scenario JSON is correctly formatted.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ export QPS_WORKERS=<host1>:<10000>,<host2>,10000,<host3>:10000\n$ bins/opt/qps_json_driver --scenario_json='<scenario_json_scenario_config_string>'\n```\n\n----------------------------------------\n\nTITLE: Enabling Most Verbose gRPC Tracing (Bash)\nDESCRIPTION: Sets environment variables `GRPC_VERBOSITY` and `GRPC_TRACE` to enable all gRPC trace logs for detailed debugging. Requires running the gRPC application after setting these variables.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/debugging/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nGRPC_VERBOSITY=debug\nGRPC_TRACE=all\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC/Protobuf C++ Library in CMake\nDESCRIPTION: Creates a CMake library target named `hw_grpc_proto` comprising the generated gRPC and Protobuf C++ source and header files. This library encapsulates the generated code and is linked against the core gRPC C++ library (`_GRPC_GRPCPP`), the Protobuf library (`_PROTOBUF_LIBPROTOBUF`), and the gRPC reflection library (`_REFLECTION`). The `include_directories` command ensures that the generated header files can be found.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/auth/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Include generated *.pb.h files\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n\n# hw_grpc_proto\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Using gRPC stub in Ruby\nDESCRIPTION: Example Ruby code showing how to create a gRPC stub, make a request to a math service, and handle the response. This demonstrates the basic pattern for making RPC calls with gRPC in Ruby.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/README.md#_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nstub = Math::Math::Stub.new('my.test.math.server.com:8080', :this_channel_is_insecure)\nreq = Math::DivArgs.new(dividend: 7, divisor: 3)\nGRPC.logger.info(\"div(7/3): req=#{req.inspect}\")\nresp = stub.div(req)\nGRPC.logger.info(\"Answer: #{resp.inspect}\")\n```\n\n----------------------------------------\n\nTITLE: Adding gRPC Dependency with Bazel Build System in C++\nDESCRIPTION: Provides a Bazel build configuration snippet to include gRPC as a dependency by downloading a specific gRPC commit archive and loading Bazel build configurations for gRPC dependencies. This snippet requires knowledge of the desired gRPC commit SHA and expects Bazel to be installed on the system. It sets up gRPC source retrieval and integrates its dependencies through defined Bazel macros, enabling efficient and repeatable builds.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/cpp/README.md#_snippet_0\n\nLANGUAGE: bazel\nCODE:\n```\nhttp_archive(\n    name = \"com_github_grpc_grpc\",\n    urls = [\n        \"https://github.com/grpc/grpc/archive/YOUR_GRPC_COMMIT_SHA.tar.gz\",\n    ],\n    strip_prefix = \"grpc-YOUR_GRPC_COMMIT_SHA\",\n)\nload(\"@com_github_grpc_grpc//bazel:grpc_deps.bzl\", \"grpc_deps\")\ngrpc_deps()\nload(\"@com_github_grpc_grpc//bazel:grpc_extra_deps.bzl\", \"grpc_extra_deps\")\ngrpc_extra_deps()\n```\n\n----------------------------------------\n\nTITLE: Applying CallCredentials to an RPC in gRPC Python\nDESCRIPTION: Shows how to apply CallCredentials to a gRPC RPC call. The CallCredentials object, created using grpc.metadata_call_credentials or other methods, is passed as the credentials argument to the stub's RPC method.  This ensures that the authentication metadata is sent with the call.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/auth/README.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ncall_credentials = grpc.metadata_call_credentials(my_foo_plugin)\nstub.FooRpc(request, credentials=call_credentials)\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Greeter Client (Shell)\nDESCRIPTION: Executes the compiled `greeter_client` application in a separate terminal. The client connects to the server running on localhost:50051, sends custom metadata, makes an RPC call, and prints the metadata received from the server.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/README.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n$ ./greeter_client\n```\n\n----------------------------------------\n\nTITLE: Generating Protobuf and gRPC Source Files with CMake and protoc\nDESCRIPTION: This snippet determines the absolute path to the 'helloworld.proto' file, sets output paths for generated source and header files, and defines a custom build step with protoc. The command uses both --grpc_out and --cpp_out to generate gRPC and protobuf code, and expects access to protoc and the gRPC C++ plugin. It enforces a dependency on the .proto file and organizes generated files in the build directory. Required tools: protoc, grpc_cpp_plugin, existing proto definitions. Inputs: Helloworld proto file path. Outputs: Generated .cc and .h files for protobuf and gRPC services.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/ostream/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(hw_proto \"../../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Using OAuth2 Access Token for Authentication in gRPC Python\nDESCRIPTION: Shows how to obtain an OAuth2 access token using the google-auth library and then create CallCredentials using the grpc.access_token_call_credentials function. The resulting CallCredentials can then be used to authenticate gRPC calls with the obtained access token. Requires the google-auth package.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/auth/README.md#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nimport google.auth\n\ngoogle_credentials, unused_project_id = google.auth.default()\ncall_credentials = grpc.access_token_call_credentials(google_credentials.token)\n```\n\n----------------------------------------\n\nTITLE: Listing Available Services using Reflection Database in Python Client\nDESCRIPTION: Demonstrates how to use the `get_services()` method of the `ProtoReflectionDescriptorDatabase` (`reflection_db`) instance to retrieve a list of all service names exposed by the reflection-enabled gRPC server.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/server_reflection.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nservices = reflection_db.get_services()\n```\n\n----------------------------------------\n\nTITLE: Enabling gRPC Transport Trace Logs (Bash)\nDESCRIPTION: Configures gRPC tracing via environment variables to focus on transport-related debugging, including TCP, HTTP, secure endpoints, and transport security. Requires setting these variables before running the gRPC application.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/debugging/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nGRPC_VERBOSITY=debug\nGRPC_TRACE=tcp,http,secure_endpoint,transport_security\n```\n\n----------------------------------------\n\nTITLE: Setting up gRPC Dependency in Bazel WORKSPACE (Starlark)\nDESCRIPTION: This Starlark code snippet configures a Bazel `WORKSPACE` file to include gRPC as a remote dependency. It utilizes the `http_archive` rule to fetch a specific version of the gRPC source code and then loads and calls the `grpc_deps` and `grpc_extra_deps` rules provided by gRPC to pull in its necessary transitive dependencies. This setup allows the Bazel project to depend on and build against gRPC.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/bazel_support.md#_snippet_0\n\nLANGUAGE: Starlark\nCODE:\n```\nworkspace(name = \"example_workspace\")\n\nload(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\")\n\nhttp_archive(\n    name = \"com_github_grpc_grpc\",\n    strip_prefix = \"grpc-1.45.0\",\n    sha256 = \"ec19657a677d49af59aa806ec299c070c882986c9fcc022b1c22c2a3caf01bcd\",\n    urls = [\"https://github.com/grpc/grpc/archive/refs/tags/v1.45.0.tar.gz\"],\n)\n\nload(\"@com_github_grpc_grpc//bazel:grpc_deps.bzl\", \"grpc_deps\")\n\ngrpc_deps()\n\nload(\"@com_github_grpc_grpc//bazel:grpc_extra_deps.bzl\", \"grpc_extra_deps\")\n\ngrpc_extra_deps()\n```\n\n----------------------------------------\n\nTITLE: Building and Linking gRPC Helloworld Protobuf and Application Libraries - CMake\nDESCRIPTION: This portion creates shared libraries from generated proto sources and for the main application logic itself. It adds the proto sources to a library, links standard gRPC and Android dependencies, and sets up the entry main library with its dependent includes and libraries. Required dependencies include gRPC++, protobuf, android, and log libraries, as well as the previously generated proto source headers. Inputs: generated source/header files and main application source. Outputs: shared libraries for proto logic and app, linked to all necessary dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/android/helloworld/app/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(PROTO_BASE_DIR ${GRPC_SRC_DIR}/examples/protos)\n\nandroid_protobuf_grpc_generate_cpp(\n  HELLOWORLD_PROTO_SRCS HELLOWORLD_PROTO_HDRS ${PROTO_BASE_DIR} ${PROTO_BASE_DIR}/helloworld.proto)\n\nadd_library(helloworld_proto_lib\n  SHARED ${HELLOWORLD_PROTO_HDRS} ${HELLOWORLD_PROTO_SRCS})\n\ntarget_link_libraries(helloworld_proto_lib\n  grpc++\n  libprotobuf\n  android\n  log)\n\nfind_library(log-lib\n log)\n\nadd_library(grpc-helloworld\n  SHARED src/main/cpp/grpc-helloworld.cc)\n\ntarget_include_directories(grpc-helloworld\n  PRIVATE ${HELLOWORLD_PROTO_HEADERS})\n\ntarget_link_libraries(grpc-helloworld\n  helloworld_proto_lib\n  android\n  ${log-lib})\n```\n\n----------------------------------------\n\nTITLE: Verifying Client-Side gRPC Metrics Output\nDESCRIPTION: This output example demonstrates metrics exported on the client side after executing the client. It includes call durations, attempt counts, and message size metrics, indicating observability data collection.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/observability/README.md#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Running Unit Tests for gRPC PHP - Shell Script\nDESCRIPTION: Navigates to the PHP source directory and invokes the shell script 'run_tests.sh', triggering the suite of unit tests for the gRPC PHP extension and libraries. Requires a build environment and all dependencies to be installed.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_16\n\nLANGUAGE: sh\nCODE:\n```\n$ cd grpc/src/php\n$ ./bin/run_tests.sh\n```\n\n----------------------------------------\n\nTITLE: Including Generated Headers\nDESCRIPTION: This line includes the directory where the generated protobuf headers are located, ensuring that the compiler can find them. It makes the generated headers accessible to the rest of the project. The `include_directories` command adds the current binary directory to the include paths.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/generic_api/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Include generated *.pb.h files\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Generating Load Test Configuration Templates Using Python Script - Bash\nDESCRIPTION: This snippet covers the usage of 'loadtest_template.py', a Python utility that combines and generalizes YAML configuration files into a parameterized template suitable for multi-language benchmarking. Supported options include specifying input files, output file, and flags to inject parameter keys for further substitution (e.g., client pool, server pool, image names). Requires Python, PyYAML, and the script present. It outputs a YAML template file designed for repeated or flexible use across test environments.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ ./tools/run_tests/performance/loadtest_template.py \\\n    -i ../test-infra/config/samples/*_example_loadtest.yaml \\\n    --inject_client_pool --inject_server_pool \\\n    --inject_big_query_table --inject_timeout_seconds \\\n    -o ./tools/run_tests/performance/templates/loadtest_template_basic_all_languages.yaml \\\n    --name basic_all_languages\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Receive Message Size for gRPC PHP Client\nDESCRIPTION: Illustrates how to configure the maximum message size a PHP gRPC client can receive. This is done by passing the 'grpc.max_receive_message_length' option (in bytes) in the options array during the instantiation of the Helloworld\\GreeterClient. In this example, it's set to 8MB (8*1024*1024 bytes).\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_25\n\nLANGUAGE: php\nCODE:\n```\n$client = new Helloworld\\GreeterClient('localhost:50051', [\n    'credentials' => Grpc\\ChannelCredentials::createInsecure(),\n    'grpc.max_receive_message_length' => 8*1024*1024,\n]);\n```\n\n----------------------------------------\n\nTITLE: Running gRPC C++ OpenTelemetry Example Client - Bash\nDESCRIPTION: This shell command launches the client for the gRPC C++ OpenTelemetry example, which continuously sends RPC calls to the server at one-second intervals. The client depends on the same environment and libraries as the server, and is used to generate traffic and corresponding observable metrics exported through the Prometheus endpoint.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ tools/bazel run examples/cpp/otel:greeter_callback_client\n```\n\n----------------------------------------\n\nTITLE: Queuing a Completion Event in gRPC (C++)\nDESCRIPTION: Demonstrates how a completion event (tag) is queued onto a gRPC completion queue using `grpc_cq_end_op()`. The function first queues the tag in the event queue. It then finds the associated pollset and kicks a worker thread using `grpc_pollset_kick`. If the queue type is GRPC_CQ_NEXT, any worker is kicked; if it's GRPC_CQ_PLUCK, the specific worker associated with the tag is identified from a map and kicked.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/core/grpc-cq.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\ngrpc_cq_end_op(cq, tag) {\n  \\\\ 1. Queue the tag in the event queue\n\n  \\\\ 2. Find the pollset corresponding to the completion queue\n  \\\\     (i)  If the cq is of type GRPC_CQ_NEXT, then KICK ANY worker\n  \\\\          i.e., call grpc_pollset_kick(pollset, nullptr)\n  \\\\     (ii) If the cq is of type GRPC_CQ_PLUCK, then search the tag<->worker\n  \\\\          map on the completion queue to find the worker. Then specifically\n  \\\\          kick that worker i.e  call grpc_pollset_kick(pollset, worker)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring the PEM File Watcher Certificate Provider in gRPC xDS Bootstrap (JSON)\nDESCRIPTION: Defines the JSON configuration object for the `file_watcher` certificate provider plugin, specified under a unique instance name within the top-level `certificate_providers` map. This plugin watches PEM files for certificate updates. Configuration parameters include `certificate_file`, `private_key_file`, `ca_certificate_file` (paths to respective PEM files), and `refresh_interval` (a JSON duration string specifying how often to check for file updates).\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/grpc_xds_bootstrap_format.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"certificate_file\": \"<path to the certificate file in PEM format>\",\n    \"private_key_file\": \"<path to private key file in PEM format>\",\n    \"ca_certificate_file\": \"<path to CA certificate file in PEM format>\",\n    \"refresh_interval\": \"<JSON form of google.protobuf.Duration>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running gRPC Server with Admin Services (Bash)\nDESCRIPTION: Builds a specific gRPC server example that includes admin services using Bazel and then executes the resulting binary in the background (`&`). This prepares the server to be inspected by tools like `grpcdebug`.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/debugging/README.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\nbazel build --config=dbg examples/cpp/debugging:all\n./bazel-bin/examples/cpp/debugging/greeter_callback_server_admin&\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Server with Observability in Python\nDESCRIPTION: This snippet demonstrates how to start the gRPC server that has been instrumented for observability by executing the server module with Python. It assumes dependencies are installed and the server code is properly configured.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/observability/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython -m observability_greeter_server\n```\n\n----------------------------------------\n\nTITLE: Installing Specific Version of gRPC PHP Extension - Shell Script\nDESCRIPTION: Installs a specified version of the gRPC extension with PECL, enabling version pinning for compatibility requirements. Useful when working in environments where precise version control is essential or when dictated by application or platform support matrices.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ [sudo] pecl install grpc-1.30.0\n```\n\n----------------------------------------\n\nTITLE: Building gRPC for a Specific Language\nDESCRIPTION: Builds the gRPC library for a specified target language without executing tests. Replace `YOUR_LANGUAGE` with the actual language (e.g., `c++`, `csharp`, `python`). Requires Python and potentially language-specific prerequisites, including C/C++ tools, as many implementations use the native gRPC core library.\nSOURCE: https://github.com/grpc/grpc/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npython tools/run_tests/run_tests.py -l YOUR_LANGUAGE --build_only\n```\n\n----------------------------------------\n\nTITLE: Logging Request Messages in C++ gRPC\nDESCRIPTION: Provides functions for logging message contents in gRPC calls, including message length and the message data itself, which may be partial or stripped. Supports detailed message-level tracing for client and server interactions.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/binary-logging.md#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n// direction = CLIENT_SEND\nLogRequestMessage(ClientContext context, uint32_t length, T message);\n// direction = SERVER_RECV\nLogRequestMessage(ServerContext context, uint32_t length, T message);\n// direction = CLIENT_RECV\nLogResponseMessage(ClientContext context, uint32_t length, T message);\n// direction = SERVER_SEND\nLogResponseMessage(ServerContext context, uint32_t length, T message);\n```\n\n----------------------------------------\n\nTITLE: Starting the gRPC Server on Localhost (Bash)\nDESCRIPTION: This Bash command initiates the gRPC server application by running the compiled './server' binary from the command line. Ensure that the server binary is built and available in the current directory before executing this command. It listens on the default configured address, here expected to be 0.0.0.0:50052, and is required for client-server communication testing.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/retry/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n./server\n```\n\n----------------------------------------\n\nTITLE: Generating Proto and gRPC C++ Files\nDESCRIPTION: Defines a custom build command using `add_custom_command` to invoke the `protoc` compiler. It specifies the output files, the command (`_PROTOBUF_PROTOC`), arguments for output directories (`--grpc_out`, `--cpp_out`), include paths (`-I`), the gRPC C++ plugin (`--plugin`), the input proto files, and the dependencies (the proto files themselves). This step generates the `.pb.cc`, `.pb.h`, `.grpc.pb.cc`, and `.grpc.pb.h` files.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/multiplex/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n        \"${rg_proto_srcs}\" \"${rg_proto_hdrs}\" \"${rg_grpc_srcs}\" \"${rg_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${rg_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\" \"${rg_proto}\"\n      DEPENDS \"${hw_proto}\" \"${rg_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Defining and Linking Client/Server Executable Targets - CMake\nDESCRIPTION: This loop iterates through 'client' and 'server', creating an executable target for each using their respective source files (`client.cc`, `server.cc`). It then links each executable to the generated `hw_grpc_proto` library and various Abseil and core gRPC/Protobuf libraries required for logging, flags, and core functionality.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/retry/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# Targets (client|server)\nforeach(_target\n  client server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::check\n    absl::flags\n    absl::flags_parse\n    absl::log\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Reporting Per-Request gRPC Metrics in C++\nDESCRIPTION: Demonstrates how to report metrics from within a gRPC service implementation for a specific request. It retrieves the call metric recorder from the server context using `ExperimentalGetCallMetricRecorder` and then uses it to record a metric like CPU utilization. Includes a check to ensure the recorder is available, which depends on `EnableCallMetricRecording` having been called during server setup.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/orca/README.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nauto recorder = context->ExperimentalGetCallMetricRecorder();\nif (recorder == nullptr) {\n  return Status(grpc::StatusCode::INTERNAL,\n                \"Unable to access metrics recorder. Make sure \"\n                \"EnableCallMetricRecording had been called.\");\n}\nrecorder->RecordCpuUtilizationMetric(0.5);\n```\n\n----------------------------------------\n\nTITLE: Including Generated Header Directories\nDESCRIPTION: This snippet adds the current binary directory to the include directories. This allows the compiler to find the generated header files during compilation of the C++ source files.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# Include generated *.pb.h files\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Starting the Retry Client\nDESCRIPTION: This shell command starts either the synchronous or asynchronous retry client, written in Python. The client is designed to handle errors injected by the flaky server by utilizing retry policies defined in gRPC. The retry_client.py is the synchronous version, and async_retry_client.py is the asynchronous one.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/retry/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npython3 retry_client.py\n# Or\npython3 async_retry_client.py\n```\n\n----------------------------------------\n\nTITLE: Logging User Data in C++ gRPC\nDESCRIPTION: Defines functions for logging user-specific data associated with gRPC calls on client and server sides. Facilitates inclusion of custom application data into logs for comprehensive call analysis.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/binary-logging.md#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n// The context provides the user data contents\n// direction = CLIENT_SEND\nLogUserData(ClientContext context);\n\n// direction = SERVER_SEND\nLogUserData(ServerContext context);\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project for gRPC Example\nDESCRIPTION: Sets the minimum required CMake version to 3.16, defines the project name as 'ErrorHandling' with C and CXX languages, and includes common CMake configuration settings from a shared file.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/error_handling/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(ErrorHandling C CXX)\n\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Generating Load Test Configurations with loadtest_config.py (Bash)\nDESCRIPTION: This snippet illustrates how to generate LoadTest configurations using the `loadtest_config.py` script for C# and Java tests, including tests against C++ clients and servers, and running each test twice. It uses a template file and specifies various options like languages, substitution keys, category, and output file.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ ./tools/run_tests/performance/loadtest_config.py -l go -l java \\\n    -t ./tools/run_tests/performance/templates/loadtest_template_basic_all_languages.yaml \\\n    -s client_pool=workers-8core -s driver_pool=drivers \\\n    -s server_pool=workers-8core \\\n    -s big_query_table=e2e_benchmarks.experimental_results \\\n    -s timeout_seconds=3600 --category=scalable \\\n    -d --allow_client_language=c++ --allow_server_language=c++ \\\n    --runs_per_test=2 -o ./loadtest.yaml\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC client with secure credentials (python)\nDESCRIPTION: This command runs the gRPC client with the `--secure true` flag, enabling secure communication with the server.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/xds/README.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\npython client.py xds:///my-backend --secure true\n```\n\n----------------------------------------\n\nTITLE: Defining GRPC Health Checking Service and Messages in Proto3\nDESCRIPTION: This snippet provides the Protocol Buffers (proto3) definition for the GRPC Health service used for health checking. It declares the request and response messages, including a ServingStatus enum, and specifies two service methods (Check and Watch) to respectively query or watch health status updates for a particular service. Dependencies include a Protocol Buffers compiler supporting proto3 syntax and the GRPC runtime that implements the Health API based on this schema. The \"service\" parameter in HealthCheckRequest targets the specific service to query; results are returned via HealthCheckResponse with a status field. This protocol is constrained by exact service name matching and does not support wildcards by default.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/health-checking.md#_snippet_0\n\nLANGUAGE: Proto3\nCODE:\n```\nsyntax = \"proto3\";\n\npackage grpc.health.v1;\n\nmessage HealthCheckRequest {\n  string service = 1;\n}\n\nmessage HealthCheckResponse {\n  enum ServingStatus {\n    UNKNOWN = 0;\n    SERVING = 1;\n    NOT_SERVING = 2;\n    SERVICE_UNKNOWN = 3;  // Used only by the Watch method.\n  }\n  ServingStatus status = 1;\n}\n\nservice Health {\n  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);\n\n  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Install gRPC Dependency with pecl\nDESCRIPTION: This command installs the gRPC extension for PHP using the PEAR Extension Community Library (PECL). It compiles and installs the necessary library to enable gRPC functionality in PHP environments.\nSOURCE: https://github.com/grpc/grpc/blob/master/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\npecl install grpc\n```\n\n----------------------------------------\n\nTITLE: Building and Running the gRPC C++ Server (Shell)\nDESCRIPTION: Compiles the server code using 'make' and then executes the compiled server binary (greeter_server). Assumes the code generation steps are complete and the Makefile is present.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/compression/README.md#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nmake\n./greeter_server\n```\n\n----------------------------------------\n\nTITLE: Critical Section with Mutex Lock/Unlock\nDESCRIPTION: This code snippet demonstrates a typical way of protecting a critical section using a mutex lock and unlock. It ensures that only one thread can execute the `do_stuff()` function at a time, preventing race conditions and data corruption.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/core/combiner-explainer.md#_snippet_0\n\nLANGUAGE: \nCODE:\n```\nmu.lock()\ndo_stuff()\nmu.unlock()\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Flow Control Client in Python\nDESCRIPTION: This command executes the gRPC flow control client, which is implemented in Python. It expects that the user is located in the `grpc/examples/python/flow_control` directory. The client will then establish a connection with the server and initiate a bi-directional streaming call.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/flow_control/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n$ python3 flow_control_client.py\n```\n\n----------------------------------------\n\nTITLE: Building the Helloworld Example Project with ExternalProject\nDESCRIPTION: Configures the build for the Helloworld example project, linking it with all previously built dependencies. Uses find_package to locate dependencies instead of manual imports.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/cmake_externalproject/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nExternalProject_Add(helloworld\n  PREFIX helloworld\n  SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/..\"\n  BINARY_DIR \"${CMAKE_CURRENT_BINARY_DIR}/helloworld\"\n  INSTALL_COMMAND \"\"\n  CMAKE_CACHE_ARGS\n        -DCMAKE_CXX_STANDARD:STRING=17\n        -DProtobuf_DIR:PATH=${CMAKE_CURRENT_BINARY_DIR}/protobuf/lib/cmake/protobuf\n        -Dc-ares_DIR:PATH=${CMAKE_CURRENT_BINARY_DIR}/c-ares/lib/cmake/c-ares\n        -Dre2_DIR:STRING=${CMAKE_CURRENT_BINARY_DIR}/re2/lib/cmake/re2\n        -Dutf8_range_DIR:STRING=${CMAKE_CURRENT_BINARY_DIR}/utf8_range/lib/cmake/utf8_range\n        -DZLIB_ROOT:STRING=${CMAKE_CURRENT_BINARY_DIR}/zlib\n        -Dabsl_DIR:STRING=${CMAKE_CURRENT_BINARY_DIR}/absl/lib/cmake/absl\n        -DgRPC_DIR:PATH=${CMAKE_CURRENT_BINARY_DIR}/grpc/lib/cmake/grpc\n        ${_CMAKE_ARGS_OPENSSL_ROOT_DIR}\n  DEPENDS protobuf grpc\n)\n```\n\n----------------------------------------\n\nTITLE: Building Protobuf Compiler protoc from Source - Shell Script\nDESCRIPTION: This shell script shows how to build the protobuf compiler (protoc) from source by running autogen, configure, make, and install. This is a fallback when no binary protoc is available, but may complicate uninstallation. Prerequisites: build-essential tools, automake, and proper permissions.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\n$ cd grpc/third_party/protobuf\n$ ./autogen.sh && ./configure && make\n$ [sudo] make install\n```\n\n----------------------------------------\n\nTITLE: gRPC Server class for AsyncIO in Python\nDESCRIPTION: This snippet explains the Server class, which manages server-side RPC handling, service registration, and server lifecycle in gRPC AsyncIO Python API. It allows setting up servers to handle incoming RPCs in an asynchronous environment.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: Server\n```\n\n----------------------------------------\n\nTITLE: Generating PHP Classes from .proto with protoc and grpc_php_plugin - Shell Script\nDESCRIPTION: Executes protoc using both --php_out and --grpc_out flags and points to the grpc_php_plugin to generate PHP message classes and gRPC client stubs from a .proto service definition. Expects input and output directories, and the plugin to be present on the system PATH or specified directly.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_14\n\nLANGUAGE: sh\nCODE:\n```\n$ protoc -I=. echo.proto --php_out=. --grpc_out=. \\\n--plugin=protoc-gen-grpc=<path to grpc_php_plugin>\n```\n\n----------------------------------------\n\nTITLE: Setting DSCP in gRPC client using Go\nDESCRIPTION: This example shows how to specify the DSCP channel argument within a Go gRPC client to enable traffic prioritization. It initializes channel options with the dscp value, which is an integer between 0 and 63, and notes the default is system unspecified. Works on POSIX systems where supported.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/qos-dscp.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nvar opts []grpc.DialOption\nopts = append(opts, grpc.WithDefaultServiceConfig(`{\"\" : {\"grpc.primary_user_agent\" : \"MyClient\"}}`))\n// Add DSCP value to options\nopts = append(opts, grpc.WithChannelArguments(map[string]interface{}{\"grpc.dscp\" : 46}))\nconn, err := grpc.Dial(address, opts...)\n// Use conn for RPCs\n```\n\n----------------------------------------\n\nTITLE: Building Abseil C++ Library with ExternalProject\nDESCRIPTION: Configures the build for the Abseil C++ library using ExternalProject_Add. Sets position-independent code and C++17 standard.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/cmake_externalproject/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nExternalProject_Add(absl\n  PREFIX absl\n  SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../../../../third_party/abseil-cpp\"\n  CMAKE_CACHE_ARGS\n        -DCMAKE_POSITION_INDEPENDENT_CODE:BOOL=TRUE\n        -DCMAKE_INSTALL_PREFIX:PATH=${CMAKE_CURRENT_BINARY_DIR}/absl\n        -DCMAKE_CXX_STANDARD:STRING=17\n)\n```\n\n----------------------------------------\n\nTITLE: Listing a Service with Details using gRPC CLI\nDESCRIPTION: Command to list detailed information about a specific service using the gRPC CLI tool with the -l flag.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_reflection_tutorial.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ grpc_cli ls localhost:50051 helloworld.Greeter -l\n```\n\n----------------------------------------\n\nTITLE: Adding NuGet Package Reference for Protobuf Files (XML)\nDESCRIPTION: This snippet shows how to add a NuGet package reference to a .NET project that contains .proto files. The package is added using the PackageReference element in the project's .csproj file. The Version attribute specifies the version of the package to include.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_20\n\nLANGUAGE: XML\nCODE:\n```\n<PackageReference Include=\"My.Example.Protos\" Version=\"1.0.0\" />\n```\n\n----------------------------------------\n\nTITLE: Offloading Combiner Work to Workqueue\nDESCRIPTION: This code shows how `offload` is implemented using a `workqueue`. It pushes a continuation function (`continue_from_while_loop`) onto the workqueue and then breaks out of the current loop. This allows another thread to pick up the work and continue processing the queue.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/core/combiner-explainer.md#_snippet_5\n\nLANGUAGE: \nCODE:\n```\n  workqueue.run(continue_from_while_loop);\n  break;\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC client (python)\nDESCRIPTION: This command runs the gRPC client script, connecting to the server using the `xds:///` scheme and specifying the backend name.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/xds/README.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npython client.py xds:///my-backend\n```\n\n----------------------------------------\n\nTITLE: Setting C++ Standard Version in CMake for gRPC Projects\nDESCRIPTION: This CMake snippet enforces the use of the C++17 standard for all targets in a project using gRPC, ensuring consistency and preventing compilation issues caused by mismatched C++ versions. Requires a CMake environment with support for specifying C++ standards and assumes a gRPC-compatible compiler. This establishes explicit standard requirements to maintain compatibility across all linked binaries.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/cpp/README.md#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```\n\n----------------------------------------\n\nTITLE: Generating C++ and gRPC Sources from Proto - CMake\nDESCRIPTION: This custom command invokes the `protoc` compiler and the gRPC C++ plugin to generate the necessary C++ source and header files from the `helloworld.proto` definition. It specifies the output directory, include path, and the plugin executable.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/retry/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Building grpc_php_plugin with Bazel - Shell Script\nDESCRIPTION: Uses Bazel as the build system to build the grpc_php_plugin and the protoc binary for generating PHP protobuf stubs. Bazel must be installed; outputs are placed in the corresponding bazel-bin directories.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\n$ bazel build @com_google_protobuf//:protoc\n$ bazel build src/compiler:grpc_php_plugin\n```\n\n----------------------------------------\n\nTITLE: Building and Linking gRPC Proto and Utility Libraries in CMake for C++\nDESCRIPTION: This snippet creates two CMake static libraries: 'hw_grpc_proto' and 'util'. The 'hw_grpc_proto' library bundles all generated protobuf and gRPC sources and headers, and links against gRPC, protobuf, and reflection libraries. The 'util' library includes a utility implementation and links it with OpenTelemetry, hw_grpc_proto, and core gRPC/protobuf libraries. All dependencies must be available via find_package or as part of the build tree. Expected input: generated source/header files and local util.cc. Output: reusable static libraries prepared for linking in example targets.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/ostream/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n\nadd_library(util\n  \"../util.cc\")\ntarget_link_libraries(util\n  hw_grpc_proto\n  opentelemetry-cpp::metrics\n  ${_GRPC_GRPCPP}\n  ${_REFLECTION}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Expected Output of grpc_cli Service Listing\nDESCRIPTION: Displays the expected output when listing services using `grpc_cli` against a server with reflection enabled for the 'helloworld.Greeter' service. It confirms the presence of both the application service and the gRPC reflection service.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/server_reflection.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ngrpc.reflection.v1alpha.ServerReflection\nhelloworld.Greeter\n```\n\n----------------------------------------\n\nTITLE: Including generated header files\nDESCRIPTION: Adds the current binary directory to the include directories list.  This makes the generated header files (.pb.h and .grpc.pb.h) available for inclusion in the C++ source code during compilation.  Necessary for compiling the client and server code that uses the generated protobuf and gRPC classes.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies for gRPC Observability\nDESCRIPTION: This snippet shows how to install the required Python packages listed in requirements.txt for setting up gRPC observability with OpenTelemetry. It uses pip to install dependencies in the current environment.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/observability/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Building the Example Client and Server (Shell)\nDESCRIPTION: Compiles the C++ client and server source code for the metadata example using the provided `Makefile`. This creates the `greeter_client` and `greeter_server` executables.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ make\n```\n\n----------------------------------------\n\nTITLE: Logging Response Headers in C++ gRPC\nDESCRIPTION: Provides logging functions for response headers on the client and server sides, capturing metadata sent after processing requests. Essential for tracing how responses are constructed and transmitted in gRPC communications.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/binary-logging.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// The context provides the metadata contents\n// direction = CLIENT_RECV\nLogResponseHeaders(ClientContext context);\n\n// direction = SERVER_SEND\nLogResponseHeaders(ServerContext context);\n```\n\n----------------------------------------\n\nTITLE: Starting the Async gRPC Server with Unix Domain Sockets in Python\nDESCRIPTION: Command for running the asynchronous greeter server that listens on Unix Domain Socket paths. Similar to the synchronous version, it binds to both relative and absolute socket paths.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/uds/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 async_greeter_server.py\nINFO:root:Server listening on: unix:helloworld.sock\nINFO:root:Server listening on: unix:///tmp/helloworld.sock\n...\n```\n\n----------------------------------------\n\nTITLE: Enabling Protobuf Imports from NuGet Package (XML)\nDESCRIPTION: This snippet shows how to enable importing .proto files from a NuGet package within a .NET project. This involves setting a property (e.g., `<IncludeMyExampleProtosProtos>true</IncludeMyExampleProtosProtos>`) to true, which updates the `Protobuf_StandardImportsPath` to include the directory containing the package's .proto files. This allows local .proto files to import definitions from the NuGet package's .proto files.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_22\n\nLANGUAGE: XML\nCODE:\n```\n<PropertyGroup>\n  <!-- Update the Protobuf_StandardImportsPath -->\n  <IncludeMyExampleProtosProtos>true</IncludeMyExampleProtosProtos>\n</PropertyGroup>\n\n<ItemGroup>\n  <!-- my_services.proto imports common_message.proto from the package\n   My.Example.Protos -->\n  <Protobuf Include=\"my_services.proto\" />\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Helloworld Example Server with Reflection\nDESCRIPTION: Commands to build the C++ helloworld example server with Server Reflection enabled and run it in the background.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_reflection_tutorial.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ make -C examples/cpp/helloworld\n$ examples/cpp/helloworld/greeter_server &\n```\n\n----------------------------------------\n\nTITLE: Creating Generated Code Library\nDESCRIPTION: Creates a static library target named `example_grpc_proto` which consists of all the generated C++ source and header files (`.pb.cc`, `.pb.h`, `.grpc.pb.cc`, `.grpc.pb.h`) for both `helloworld` and `route_guide` services.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/multiplex/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(example_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs}\n  ${rg_grpc_srcs}\n  ${rg_grpc_hdrs}\n  ${rg_proto_srcs}\n  ${rg_proto_hdrs}\n)\n```\n\n----------------------------------------\n\nTITLE: Specifying DSCP in gRPC Python client\nDESCRIPTION: This snippet illustrates how to set the DSCP value using channel options in a Python gRPC client. It involves passing 'grpc.dscp' with a value between 0 and 63 during channel creation, affecting packet classification and priority. The configuration applies primarily on POSIX systems that support this feature.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/qos-dscp.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nimport grpc\nchannel_options = [(\"grpc.dscp\", 46)]  # Set DSCP to EF\nchannel = grpc.insecure_channel('localhost:50051', options=channel_options)\n// Use channel for RPC calls\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Server using Shell Command\nDESCRIPTION: This shell snippet launches the example gRPC server, which listens for incoming client connections on port 50051. The server must be compiled beforehand using either Bazel or CMake, resulting in an executable named 'server' in the current directory. Running this command is a prerequisite for connecting the example client and testing cancellation functionality.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/cancellation/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n./server\n```\n\n----------------------------------------\n\nTITLE: Requiring google/protobuf Composer Package - JSON\nDESCRIPTION: Specifies the composer dependency for a pure-PHP implementation of Protocol Buffers, included in the composer.json. It is an alternative to the C extension and is recommended for ease of installation.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"require\": {\n        \"google/protobuf\": \"~v3.12.2\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Xcode Command Line Tools Prerequisite on macOS - Shell\nDESCRIPTION: Installs the Xcode Command Line Tools on macOS using the `xcode-select` command. This is a prerequisite for building software from source on macOS.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n $ [sudo] xcode-select --install\n```\n\n----------------------------------------\n\nTITLE: Defining Project and Including Common CMake\nDESCRIPTION: This snippet defines the project name, specifies the source languages (C and C++), and includes a common CMake configuration file.  The common configuration file likely contains project-wide settings and functions.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(Metadata C CXX)\n\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Installing grpcio dependency for Python gRPC Status Proto\nDESCRIPTION: Command to install the required grpcio package from PyPI using pip. This is the only dependency needed for the gRPC Python status proto reference package.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/grpcio_status/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install grpcio\n```\n\n----------------------------------------\n\nTITLE: Specifying ProtoRoot in MSBuild XML\nDESCRIPTION: This XML snippet demonstrates how to use the `ProtoRoot` attribute in an MSBuild project file to define the root directory for .proto files. It specifies different ProtoRoot values for .proto files located in the 'Protos' directory and those located outside the project directory. This configuration helps preserve directory structure in the generated .cs files and set import search paths.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_9\n\nLANGUAGE: XML\nCODE:\n```\n<Protobuf Include=\"Protos\\Services\\**\\*.proto\"\n          ProtoRoot=\"Protos\" />\n<Protobuf Include=\"Protos\\Messages\\**\\*.proto\"\n          ProtoRoot=\"Protos\"\n          GrpcServices=\"None\" />\n<Protobuf Include=\"..\\OutsideProjectProtos\\**\\*.proto\"\n          ProtoRoot=\"..\\OutsideProjectProtos\" />\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC/Protobuf C++ Code using CMake Custom Command\nDESCRIPTION: Defines a CMake custom command to generate C++ source and header files (`.pb.cc`, `.pb.h`, `.grpc.pb.cc`, `.grpc.pb.h`) from `helloworld.proto` using the protobuf compiler (`_PROTOBUF_PROTOC`) and the gRPC C++ plugin (`_GRPC_CPP_PLUGIN_EXECUTABLE`). It specifies the output directory (`CMAKE_CURRENT_BINARY_DIR`), include path (`hw_proto_path`), and ensures the command runs only when the input proto file changes. The generated files are prerequisites for compiling the `hw_grpc_proto` library.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/auth/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\n# Generated sources\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC server (shell)\nDESCRIPTION: These commands set up a virtual environment, activate it, install the necessary Python packages, and then run the gRPC server script.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/xds/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nvirtualenv venv -p python3\nsource venv/bin/activate\npip install -r requirements.txt\npython server.py\n```\n\n----------------------------------------\n\nTITLE: Creating gRPC Protobuf Library Target\nDESCRIPTION: Defines a library target 'hw_grpc_proto' that compiles the generated protobuf and gRPC code. Links against required gRPC, Reflection, and Protobuf libraries to create a reusable component for the client and server applications.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# hw_grpc_proto\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Load Balancing Policies in gRPC Backend Service (JSON)\nDESCRIPTION: This JSON snippet defines a list of `localityLbPolicies` for a gRPC backend service, attempting to configure custom load balancers. The first policy (`test.ThisLoadBalancerDoesNotExist`) is expected to be ignored by the client as it's unimplemented. The second policy (`test.RpcBehaviorLoadBalancer`) is expected to be implemented and used, configured with data to set an `rpcBehavior` header resulting in an error code 15 (DATA_LOSS). This setup tests the client's ability to select a valid custom LB policy from a list and apply its configuration.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/xds-test-descriptions.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n[ \n  {\n    \"customPolicy\": {\n      \"name\": \"test.ThisLoadBalancerDoesNotExist\",\n      \"data\": \"{ \\\"foo\\\": \\\"bar\\\" }\"\n    }\n  },\n  {\n    \"customPolicy\": {\n      \"name\": \"test.RpcBehaviorLoadBalancer\",\n      \"data\": \"{ \\\"rpcBehavior\\\": \\\"error-code-15\\\" }\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Creating a Feature Branch\nDESCRIPTION: This command creates a new branch from the current branch in a Git repository. This is used to isolate the user's changes and avoid impacting the main branch directly.  The user specifies the new branch name, which is a custom name indicating the feature.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b my-feature-branch\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project\nDESCRIPTION: This snippet defines the minimum CMake version required, the project name, and includes a common CMake file. It sets up the project environment for building the C++ helloworld example. The `cmake_minimum_required` command specifies the minimum CMake version. The `project` command defines the project and its languages. The `include` command brings in common settings.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/generic_api/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(GenericAPI C CXX)\n\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Building Protobuf Library with ExternalProject\nDESCRIPTION: Configures the build for the Protocol Buffers library with dependencies on Abseil and UTF8 Range. Disables tests and sets compiler options.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/cmake_externalproject/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nExternalProject_Add(protobuf\n  PREFIX protobuf\n  SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../../../../third_party/protobuf\"\n  CMAKE_CACHE_ARGS\n        -DCMAKE_INSTALL_PREFIX:PATH=${CMAKE_CURRENT_BINARY_DIR}/protobuf\n        -DCMAKE_CXX_STANDARD:STRING=17\n        -Dprotobuf_BUILD_TESTS:BOOL=OFF\n        -Dprotobuf_WITH_ZLIB:BOOL=OFF\n        -Dprotobuf_ABSL_PROVIDER:STRING=package\n        -Dabsl_DIR:STRING=${CMAKE_CURRENT_BINARY_DIR}/absl/lib/cmake/absl\n        -Dutf8_range_DIR:STRING=${CMAKE_CURRENT_BINARY_DIR}/utf8_range/lib/cmake/utf8_range\n        -Dprotobuf_MSVC_STATIC_RUNTIME:BOOL=OFF\n  DEPENDS absl utf8_range\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Generated Source File Variables\nDESCRIPTION: This snippet defines variables for the generated source and header files for both protobuf and gRPC based on the current binary directory. These variables are used in subsequent commands to specify output files and dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Generated sources\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\n```\n\n----------------------------------------\n\nTITLE: Generating and Linking gRPC Proto Files (C++)\nDESCRIPTION: This code includes the generated header files by specifying the include directories. It creates a library named `hw_grpc_proto` that links the generated sources and headers. The `target_link_libraries` command links the library with reflection, gRPC++ and protobuf libraries. This ensures that the project can use the generated code.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/wait_for_ready/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Include generated *.pb.h files\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n\n# hw_grpc_proto\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Cloning the gRPC Repository (Shell)\nDESCRIPTION: Clones the gRPC repository from GitHub using Git. Replace `RELEASE_TAG_HERE` with the desired stable release tag to get the example code.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ git clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc\n```\n\n----------------------------------------\n\nTITLE: Creating C++ Library for Health Service Proto Generated Code\nDESCRIPTION: Adds a library target for the generated Health service proto code and links necessary dependencies including Protocol Buffers.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/health/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n#health_grpc_proto\nadd_library(health_grpc_proto\n  ${health_grpc_srcs}\n  ${health_grpc_hdrs}\n  ${health_proto_srcs}\n  ${health_proto_hdrs})\ntarget_link_libraries(health_grpc_proto\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Greeter Server (Shell)\nDESCRIPTION: Executes the compiled `greeter_server` application. The server starts listening for incoming gRPC requests on the default port 50051 and prints received metadata to the console.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/README.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n$ ./greeter_server\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Call Credentials to an RPC in gRPC Python\nDESCRIPTION: Demonstrates how to apply multiple CallCredentials to a single gRPC RPC call using grpc.composite_call_credentials. This allows for stacking multiple authentication mechanisms.  The resulting composite credentials are then passed to the stub's RPC method.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/auth/README.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ncall_credentials_foo = ...\ncall_credentials_bar = ...\ncall_credentials = grpc.composite_call_credentials(\n    call_credentials_foo,\n    call_credentials_bar)\nstub.FooRpc(request, credentials=call_credentials)\n```\n\n----------------------------------------\n\nTITLE: Including Common CMake Configuration - CMake\nDESCRIPTION: This command includes a common CMake file that likely contains shared build configurations, macros, or variable definitions used across different gRPC examples or components.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/retry/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Building and Running the PHP gRPC Client with Apache via Docker\nDESCRIPTION: Builds a Docker image tagged `grpc-php/apache` using `apache.Dockerfile`, which sets up Apache with the PHP gRPC client. It then runs this image interactively, linking to the `node-server` container and mapping host port 80 to the container's port 80, allowing access via a web browser.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/php/echo/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ docker build -t grpc-php/apache -f ./apache.Dockerfile .\n$ docker run -it --rm --link node-server:node-server -p 80:80 grpc-php/apache\n```\n\n----------------------------------------\n\nTITLE: Compiling gRPC Objective-C Plugin and Creating Symbolic Link in Shell\nDESCRIPTION: These shell commands compile the gRPC Objective-C plugin for the Protocol Buffers compiler and create a symbolic link in the system PATH to enable protoc to detect the plugin by name. The compilation command `make grpc_objective_c_plugin` must be run from the root of the cloned grpc repository. The symbolic link named with the prefix 'protoc-gen-' allows protoc to invoke the plugin automatically. Alternatives include copying the binary directly or specifying its path manually when invoking protoc.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/objective-c/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmake grpc_objective_c_plugin\n```\n\nLANGUAGE: shell\nCODE:\n```\nln -s `pwd`/bins/opt/grpc_objective_c_plugin /usr/local/bin/protoc-gen-objcgrpc\n```\n\n----------------------------------------\n\nTITLE: Configuring Proto File Paths and Source Generation\nDESCRIPTION: Defines the path to the 'helloworld.proto' file, and sets output variables for the generated protobuf and gRPC source and header files. Adds a custom command to invoke protoc for code generation with gRPC plugin.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/codelab/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(hw_proto \"../../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Enabling gRPC Tracing and Logging in php.ini - Shell Script\nDESCRIPTION: php.ini lines for enabling gRPC core debugging, adjusting verbosity and trace modules. Switching on all traces except polling, pollable_refcount, timer, and timer_check modules. Tracks to /var/log/grpc.log or equivalent; remember to manage log file size.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_22\n\nLANGUAGE: sh\nCODE:\n```\ngrpc.grpc_verbosity=debug\ngrpc.grpc_trace=all,-polling,-polling_api,-pollable_refcount,-timer,-timer_check\n```\n\n----------------------------------------\n\nTITLE: Cacheable Unary Call Test Procedure\nDESCRIPTION: This test verifies that gRPC requests marked as cacheable use the GET verb instead of POST, and that the server sets appropriate cache control headers for the response to be cached by a proxy. It involves two calls to CacheableUnaryCall with the same request, asserting that both calls are successful and the payload bodies of both responses are the same.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n 1. Client calls CacheableUnaryCall with `SimpleRequest` request with payload\n    set to current timestamp. Timestamp format is irrelevant, and resolution is\n    in nanoseconds.\n    Client adds a `x-user-ip` header with value `1.2.3.4` to the request.\n    This is done since some proxys such as GFE will not cache requests from\n    localhost.\n    Client marks the request as cacheable by setting the cacheable flag in the\n    request context. Longer term this should be driven by the method option\n    specified in the proto file itself.\n 2. Client calls CacheableUnaryCall again immediately with the same request and\n    configuration as the previous call.\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Build Options\nDESCRIPTION: Defines standard boolean options that users can toggle when configuring the build. `utf8_range_ENABLE_TESTS` controls whether the test suite is built, and `utf8_range_ENABLE_INSTALL` controls whether installation rules are configured. Both are enabled by default.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\noption (utf8_range_ENABLE_TESTS \"Build test suite\" ON)\noption (utf8_range_ENABLE_INSTALL \"Configure installation\" ON)\n```\n\n----------------------------------------\n\nTITLE: Applying Load Test Configuration with kubectl (Bash)\nDESCRIPTION: This snippet shows how to apply a LoadTest configuration to a Kubernetes cluster using `kubectl apply`. It assumes that the LoadTest controller is running in the cluster. The configuration is read from the `loadtest_config.yaml` file and applied to the cluster.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ kubectl apply -f loadtest_config.yaml\n```\n\n----------------------------------------\n\nTITLE: Creating Python Virtual Environment\nDESCRIPTION: This Python command creates a virtual environment for the project. A virtual environment helps isolate the project's dependencies from the global Python environment and other projects.  The command utilizes the \"venv\" module to create a virtual environment named \"grpc-python\".\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython -m venv ~/.virtualenvs/grpc-python\n```\n\n----------------------------------------\n\nTITLE: Building and Running the PHP gRPC CLI Client via Docker\nDESCRIPTION: Builds a Docker image tagged `grpc-php/echo-client` using `cli.Dockerfile`, then runs this image interactively. The container links to the running `node-server` container and executes the `client.php` script within the container's environment.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/php/echo/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ docker build -t grpc-php/echo-client -f ./cli.Dockerfile .\n$ docker run -it --rm --link node-server:node-server grpc-php/echo-client\n$ php client.php\n```\n\n----------------------------------------\n\nTITLE: Creating Client and Server Executables (C++)\nDESCRIPTION: This snippet iterates over the specified targets (`greeter_callback_client`, `greeter_callback_server`) and creates executables for each. It links these executables with the `hw_grpc_proto` library, as well as dependencies such as absl flags and parsing utilities. These dependencies are essential for the client and server to function.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/wait_for_ready/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Targets greeter_[async_](client|server)\nforeach(_target\n  greeter_callback_client greeter_callback_server\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Loading Debug Symbols | gdb | gdb\nDESCRIPTION: Demonstrates how to use `gdb` to identify the base address of the loaded `grpc_c.so` shared library and load the corresponding debug symbol file (`.dbg`) using the `add-symbol-file` command. The base address is crucial for correctly mapping symbols.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/nativedebug/README.md#_snippet_3\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) info sharedlibrary\nFrom                To                  Syms Read   Shared Object Library\n...\n0x00007ffff3497450  0x00007ffff3a61912  Yes (*)     /home/.rvm/gems/ruby-3.0.0/gems/grpc-1.60.1-x86_64-linux/src/ruby/lib/grpc/3.0/grpc_c.so\n0x00007ffff3e78730  0x00007ffff3ea60df  Yes (*)     /home/.rvm/gems/ruby-3.0.0/gems/google-protobuf-3.24.4-x86_64-linux/lib/google/3.0/protobuf_c.so\n(*): Shared library is missing debugging information.\n(gdb) add-symbol-file /home/grpc-native-debug-1.60.1-x86_64-linux/symbols/grpc-1.60.1-x86_64-linux-ruby-3.0.dbg 0x00007ffff3497450\nadd symbol table from file \"/home/grpc-native-debug-1.60.1-x86_64-linux/symbols/grpc-1.60.1-x86_64-linux-ruby-3.0.dbg\" at\n\t.text_addr = 0x7ffff3497450\n(y or n) y\nReading symbols from /home/grpc-native-debug-1.60.1-x86_64-linux/symbols/grpc-1.60.1-x86_64-linux-ruby-3.0.dbg...\n(gdb)\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies\nDESCRIPTION: This command installs the Python dependencies required by the project. It uses pip, the Python package installer, to install the dependencies listed in the \"requirements.txt\" file. This ensures that the necessary libraries are available for the project to run and for testing.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Locating External Libraries: Prometheus and OpenTelemetry\nDESCRIPTION: Uses find_package to locate the 'prometheus-cpp' and 'opentelemetry-cpp' packages, requiring their presence for the build process, ensuring dependencies are available for instrumentation and metrics.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/codelab/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(prometheus-cpp CONFIG REQUIRED)\nfind_package(opentelemetry-cpp CONFIG REQUIRED)\n```\n\n----------------------------------------\n\nTITLE: Finding Required Package Dependencies for OpenTelemetry and Prometheus\nDESCRIPTION: Locates required external packages prometheus-cpp and opentelemetry-cpp using CMake's find_package command. These dependencies must be installed on the system for the build to succeed.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Find prometheus-cpp package\nfind_package(prometheus-cpp CONFIG REQUIRED)\n\n# Find opentelemetry-cpp package\nfind_package(opentelemetry-cpp CONFIG REQUIRED)\n```\n\n----------------------------------------\n\nTITLE: Refactoring GoogleTest Suite and main for iOS Compatibility in C++\nDESCRIPTION: This refactored snippet adapts a GoogleTest-based C++ test for iOS compatibility by introducing a test fixture class inheriting from ::testing::Test, and moving setup and teardown logic to static SetUpTestCase and TearDownTestCase methods. The test is rewritten to ASSERT_DEATH_IF_SUPPORTED for conditional death test support, as regular ASSERT_DEATH is not supported on iOS. The main function initializes the gRPC test environment and GoogleTest but omits direct gRPC initialization and shutdown in main. Dependencies include GoogleTest with GTMGoogleTestRunner and gRPC; main expects argc and argv for initialization. It outputs test results but is designed for use with GTMGoogleTestRunner on iOS, with setup and teardown called before and after every test due to framework limitations.\nSOURCE: https://github.com/grpc/grpc/blob/master/test/cpp/README-iOS.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nclass MyTest : public ::testing::Test {\n protected:\n  static void SetUpTestCase() { grpc_init(); }\n  static void TearDownTestCase() { grpc_shutdown(); }\n};\n\nTEST_F(MyTest, TestOne) {\n  ASSERT_DEATH_IF_SUPPORTED(ThisShouldDie(), \"\");\n}\n\nint main(int argc, char** argv) {\ngrpc::testing::TestEnvironment env(&argc, argv);\n  ::testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building and Running C++ Server (Cocoapods)\nDESCRIPTION: Temporarily changes directory to the C++ helloworld server example, builds it using `make`, and runs the `greeter_server` executable in the background. This provides the necessary server endpoint for the Objective-C client to connect to.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ pushd ../../cpp/helloworld\n$ make\n$ ./greeter_server &\n$ popd\n```\n\n----------------------------------------\n\nTITLE: Peer Identity Property Name\nDESCRIPTION: This snippet shows how to define the name of the peer identity property. It specifies the name of the property that represents the client's verified identity, in this case, the x509_subject_alternative_name. This is essential for establishing the authenticated identity for authorization.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_side_auth.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\npeer_identity_property_name = \"x509_subject_alternative_name\"\n```\n\n----------------------------------------\n\nTITLE: Waiting for gRPC Channel State Change (C++)\nDESCRIPTION: This synchronous C++ API method blocks execution until the gRPC channel's connectivity state changes from the 'source_state' or a specified 'deadline' is reached. It returns true if the state changed and false if the deadline expired. This notification simply indicates a change has occurred, requiring the application to poll the state using GetState to determine the new state.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nbool WaitForStateChange(grpc_connectivity_state source_state, gpr_timespec deadline);\n```\n\n----------------------------------------\n\nTITLE: Building and Installing gRPC PHP Extension from Source - Shell Script\nDESCRIPTION: Demonstrates compiling the gRPC PHP extension from source, moving into the extension directory, running phpize for preparing the build environment, configuring with custom library subdirectory, and executing the build and install steps. This process requires phpize, make, and PHP development headers installed.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ grpc_root=\"$(pwd)\"\n$ cd src/php/ext/grpc\n$ phpize\n$ GRPC_LIB_SUBDIR=libs/opt ./configure --enable-grpc=\"${grpc_root}\"\n$ make\n$ [sudo] make install\n```\n\n----------------------------------------\n\nTITLE: Running Interop Tests with Python\nDESCRIPTION: This script runs tests for cross-platform/cross-language interoperability. It supports tests for various gRPC implementations, including C++ and C#. It requires the grpc repository and may utilize Docker for environment isolation. It uses parameters such as the language (-l) and server language (-s), and `--use_docker` builds a Docker container. The output is the result of running the interop tests. Docker disk space can be an issue.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntools/run_tests/run_interop_tests.py -l python -s c++ --use_docker\n```\n\n----------------------------------------\n\nTITLE: Installing upb with vcpkg\nDESCRIPTION: These commands clone the vcpkg repository, bootstrap vcpkg, integrate vcpkg with the system, and install the upb package using vcpkg. This provides a method to build and install upb using a dependency manager. Assumes git is installed and available.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/upb/upb/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\n./vcpkg install upb\n```\n\n----------------------------------------\n\nTITLE: Building gRPC C++ CSM Client Docker Image Using Dockerfile (Shell)\nDESCRIPTION: This snippet demonstrates the command to build the Docker image for the gRPC C++ CSM client using a dedicated Dockerfile located at examples/cpp/csm/Dockerfile.client. It assumes a docker environment with access to the gRPC workspace and builds the client image for deployment or testing. This process is essential for containerizing the client component with all its dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/csm/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ndocker build -f examples/cpp/csm/Dockerfile.client\n```\n\n----------------------------------------\n\nTITLE: Building gRPC C++ CSM Client Docker Image Instructions\nDESCRIPTION: This snippet shows the Docker command used to build the gRPC C++ Client image for the CSM observability example from the specified Dockerfile. It requires Docker to be installed and running, and expects the build context to be the gRPC workspace root. The image is built using the Dockerfile.client file, which contains the client-specific build steps and dependencies. The resulting image can be tagged and pushed to a Docker registry.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/csm/observability/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\ndocker build -f examples/cpp/csm/observability/Dockerfile.client\n```\n\n----------------------------------------\n\nTITLE: Setting AdditionalImportDirs in MSBuild XML\nDESCRIPTION: This XML snippet shows how to use the `AdditionalImportDirs` attribute in an MSBuild project file. It defines additional directories to search when importing .proto files. This is useful when importing .proto files that are not part of the project but are required for compilation.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_10\n\nLANGUAGE: XML\nCODE:\n```\n  <Protobuf Include=\"protos/*.proto\"\n            ProtoRoot=\"protos\"\n            AdditionalImportDirs=\"/folder/protos/mytypes/;/another/folder/\"\n      ... />\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to Objective-C Helloworld (Cocoapods)\nDESCRIPTION: Changes the current working directory to the location of the Objective-C helloworld example project within the cloned gRPC repository. This is necessary before running build or dependency commands specific to the example.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ cd examples/objective-c/helloworld\n```\n\n----------------------------------------\n\nTITLE: Adding a Single .proto File to a .NET Project for gRPC Code Generation (XML, .NET)\nDESCRIPTION: This .csproj XML snippet demonstrates how to add a single .proto file for automatic gRPC and message code generation in C#. The <Protobuf> item is added under an <ItemGroup> element, with the Include attribute specifying the file path. This triggers protoc and the gRPC plugin to generate required C# types for use within the project on build. The specified proto file should reside in the given relative path within the project directory. No additional attributes restrict generated asset types, so the default is to create both client and service classes.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_1\n\nLANGUAGE: XML\nCODE:\n```\n<ItemGroup>\n    <Protobuf Include=\"Protos\\greet.proto\" />\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Configuring DSCP value in gRPC channel arguments (POSIX systems)\nDESCRIPTION: This snippet demonstrates how to set the DSCP value using the 'GRPC_ARG_DSCP' channel argument in a gRPC client to control packet prioritization. It specifies the valid range (0-63), default behavior (system default), and notes on platform applicability (POSIX only). It relies on gRPC core APIs for channel configuration.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/qos-dscp.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ngrpc::ChannelArguments args;\nargs.SetInt(GRPC_ARG_DSCP, 46);  // Set DSCP to Expedited Forwarding (EF)\n// Use args when creating channel\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake SuperBuild for gRPC Helloworld Example\nDESCRIPTION: Initializes the CMake SuperBuild project for the HelloWorld example, setting the minimum required CMake version and defining the project.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/cmake_externalproject/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\n# Project\nproject(HelloWorld-SuperBuild C CXX)\n\ninclude(ExternalProject)\n```\n\n----------------------------------------\n\nTITLE: Running Local Bazel Builds and Tests\nDESCRIPTION: This general command runs Bazel tests locally on any platform without remote configuration, but requires starting the port server first. It is suitable for development and testing.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/remote_build/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbazel test --config=opt //test/...\n```\n\n----------------------------------------\n\nTITLE: Building and Installing gRPC Python Observability from Source using Shell\nDESCRIPTION: Provides shell commands to clone the gRPC repository, initialize submodules, build the `grpcio_observability` package using its makefile, and install it using pip. Requires Git, Python development headers (e.g., `python-dev`), Cython, and a GCC-like compiler. The `GRPC_PYTHON_BUILD_WITH_CYTHON=1` environment variable ensures the package is built using Cython.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/grpcio_observability/README.rst#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nexport REPO_ROOT=grpc  # REPO_ROOT can be any directory of your choice\ngit clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc $REPO_ROOT\ncd $REPO_ROOT\ngit submodule update --init\n\ncd src/python/grpcio_observability\npython -m make_grpcio_observability\n\n# For the next command do `sudo pip install` if you get permission-denied errors\nGRPC_PYTHON_BUILD_WITH_CYTHON=1 pip install .\n```\n\n----------------------------------------\n\nTITLE: Configuring Generated Source Files for Protobuf and gRPC\nDESCRIPTION: Specifies the output source and header files for protobuf and gRPC code generation, stored in the binary directory. Sets up custom commands to generate these files using the protoc compiler with gRPC plugin.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/deadline/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Cloning gRPC Repository (Bazel)\nDESCRIPTION: Clones the gRPC repository from GitHub using the `--recursive` flag. This fetches the main repository and all its submodules in one command, which is required for the Bazel build process.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$ git clone --recursive https://github.com/grpc/grpc\n```\n\n----------------------------------------\n\nTITLE: Including common CMake configuration\nDESCRIPTION: Includes a common CMake configuration file from the parent directory. This centralizes common settings and definitions, promoting code reuse and consistency across the gRPC project's build system. Assumed to contain common build settings.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building gRPC C++ Helloworld with CMake\nDESCRIPTION: This CMake script sets up a build pipeline for a C++ gRPC helloworld example by defining how to locate proto files, generate corresponding C++ sources using protoc and the gRPC plugin, and create both shared libraries and executables for the client and server. Dependencies include gRPC, Protobuf, and Abseil libraries, which must be installed and discoverable by CMake. The main input is the helloworld.proto definition file, and the outputs are two executables, greeter_client and greeter_server, both linked to the generated code and necessary libraries. Users must ensure CMake version 3.16+ and proper path configuration for dependencies; this file does not handle dependency installation.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/compression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(Compression C CXX)\n\ninclude(../cmake/common.cmake)\n\n# Proto file\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\n# Generated sources\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n\n# Include generated *.pb.h files\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n\n# hw_grpc_proto\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n\n# Targets greeter_(client|server)\nforeach(_target\n  greeter_client greeter_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::flags_parse\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Enabling gRPC Connection Behavior Trace Logs (Bash)\nDESCRIPTION: Sets environment variables to activate gRPC tracing specifically for connection management aspects like call errors, connectivity state, and load balancing policies. This requires setting these variables before launching the gRPC application.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/debugging/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nGRPC_VERBOSITY=debug\nGRPC_TRACE=call_error,connectivity_state,pick_first,round_robin,glb\n```\n\n----------------------------------------\n\nTITLE: Client Compressed Unary Call Test Procedure\nDESCRIPTION: This test verifies the client can compress unary messages by sending both compressed and uncompressed payloads. It sends an initial probing request to check if the server supports the CompressedRequest feature, asserting an INVALID_ARGUMENT status for the probe and successful subsequent calls with the expected response size and contents.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n    {\n      expect_compressed:{\n        value: true\n      }\n      response_size: 314159\n      payload:{\n        body: 271828 bytes of zeros\n      }\n    }\n```\n\nLANGUAGE: text\nCODE:\n```\n    {\n      expect_compressed:{\n        value: true\n      }\n      response_size: 314159\n      payload:{\n        body: 271828 bytes of zeros\n      }\n    }\n```\n\nLANGUAGE: text\nCODE:\n```\n    {\n      expect_compressed:{\n        value: false\n      }\n      response_size: 314159\n      payload:{\n        body: 271828 bytes of zeros\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Installation using CMake\nDESCRIPTION: Conditionally configures installation rules if the `utf8_range_ENABLE_INSTALL` option is ON. It includes helper modules, installs targets (`utf8_validity`, `utf8_range`) to standard library/binary destinations, configures and installs CMake package configuration files (`.cmake`) and a pkgconfig file (`.pc`), and explicitly installs public header files (`.h`) to the include directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif (utf8_range_ENABLE_INSTALL)\n  include(CMakePackageConfigHelpers)\n  include(GNUInstallDirs)\n\n  install(EXPORT ${PROJECT_NAME}-targets\n    DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\"\n    NAMESPACE utf8_range::\n  )\n  install(TARGETS utf8_validity utf8_range EXPORT ${PROJECT_NAME}-targets\n        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n  )\n\n  configure_package_config_file(\n    cmake/${PROJECT_NAME}-config.cmake.in\n    \"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config.cmake\"\n    INSTALL_DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\"\n  )\n  install(FILES \"${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config.cmake\"\n    DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\"\n  )\n  configure_file(${CMAKE_CURRENT_SOURCE_DIR}/cmake/utf8_range.pc.cmake\n                 ${CMAKE_CURRENT_BINARY_DIR}/utf8_range.pc @ONLY)\n  install(\n    FILES ${CMAKE_CURRENT_BINARY_DIR}/utf8_range.pc\n    DESTINATION \"${CMAKE_INSTALL_LIBDIR}/pkgconfig\")\n\n  # Install public headers explicitly.\n  install(FILES utf8_range.h utf8_validity.h\n    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n  )\nendif ()\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version and Project Properties - CMake\nDESCRIPTION: This snippet specifies the minimum required version of CMake to build the project and defines the project name and the programming languages (C and C++) used.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/retry/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(Retry C CXX)\n```\n\n----------------------------------------\n\nTITLE: Running gRPC C++ Observability Server with Config File (Shell)\nDESCRIPTION: This snippet shows how to set the `GRPC_GCP_OBSERVABILITY_CONFIG_FILE` environment variable to point to the server configuration file and then run the observability-enabled gRPC C++ greeter server using bazel. The server will listen on the default port 50051 and report observability data according to the specified configuration.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/gcp_observability/helloworld/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ export\n    GRPC_GCP_OBSERVABILITY_CONFIG_FILE=\"$(pwd)/examples/cpp/gcp_observability/helloworld/server_config.json\"\n$ tools/bazel run examples/cpp/gcp_observability/helloworld:greeter_server\n```\n\n----------------------------------------\n\nTITLE: Setting the GRPC_XDS_BOOTSTRAP environment variable (shell)\nDESCRIPTION: This command sets the `GRPC_XDS_BOOTSTRAP` environment variable to point to the xDS bootstrap configuration file. This allows the client to find and use the xDS server.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/xds/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nexport GRPC_XDS_BOOTSTRAP=/etc/xds-bootstrap.json\n```\n\n----------------------------------------\n\nTITLE: Creating C++ Library using CMake\nDESCRIPTION: Defines a static or shared library target named `utf8_validity` from source files `utf8_validity.cc` and `utf8_range.c`. This library serves as a C++ wrapper, potentially adding more features or better integration with C++ standards/libraries.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library (utf8_validity utf8_validity.cc utf8_range.c)\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Client and Server Targets in CMake\nDESCRIPTION: This snippet creates executable targets for both greeter_client and greeter_server applications, linking them to the generated protobuf/grpc library and core dependencies. It uses a loop to minimize code duplication for client and server definitions. Each executable depends on the generated sources from the proto files and links against Abseil, gRPC, and Protobuf libraries.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/load_balancing/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(_target\n  greeter_client greeter_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::flags_parse\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Deadline Example Server\nDESCRIPTION: Command to run the server component of the gRPC deadline example. The server listens on port 50051 and implements response delay and deadline propagation functionalities.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/deadline/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n./server\n```\n\n----------------------------------------\n\nTITLE: Initializing gRPC Admin Server in Python\nDESCRIPTION: Creates and starts a gRPC admin server on localhost port 50051 using Python. The snippet demonstrates initializing a gRPC server with a thread pool executor, binding it to an insecure port, adding admin servicers from the grpc_admin package, and starting the server to enable debug and admin services. It requires grpc and grpc_admin modules, along with ThreadPoolExecutor from the concurrent.futures module. The server exposes internal debugging info such as channel tracing metrics and client status discovery. Inputs include server configuration and binding port, while output is the running admin server instance. This snippet is critical for developers aiming to monitor or debug gRPC internals in Python environments.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/grpcio_admin/README.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nserver = grpc.server(ThreadPoolExecutor())\nport = server.add_insecure_port('localhost:50051')\ngrpc_admin.add_admin_servicers(self._server)\nserver.start()\n```\n\n----------------------------------------\n\nTITLE: Defining Proto File Paths and Generated Source Variables - CMake\nDESCRIPTION: This snippet determines the absolute path and directory of the `helloworld.proto` file and defines variables that hold the expected paths for the C++ and gRPC C++ source and header files that will be generated from the proto file.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/retry/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Proto file\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\n# Generated sources\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\n```\n\n----------------------------------------\n\nTITLE: Including Protobuf Files from a NuGet Package for Compilation (XML)\nDESCRIPTION: This snippet demonstrates how to include .proto files from a NuGet package for compilation in a .NET project. It uses the Protobuf element with the Include attribute, referencing the path to the .proto file using a property defined in the NuGet package. This assumes the NuGet package defines a property (e.g., `$(MyExampleProtos_ProtosPath)`) that points to the directory containing the .proto files.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_21\n\nLANGUAGE: XML\nCODE:\n```\n<Protobuf Include=\"$(MyExampleProtos_ProtosPath)/greet.proto\" />\n```\n\n----------------------------------------\n\nTITLE: Install gRPC Dependency with Go Get\nDESCRIPTION: This command adds the gRPC library as a dependency to a Go project. It fetches the latest version from the specified path and integrates it into the project's dependency management.\nSOURCE: https://github.com/grpc/grpc/blob/master/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngo get google.golang.org/grpc\n```\n\n----------------------------------------\n\nTITLE: Building gRPC CLI tool with cmake in Shell\nDESCRIPTION: Shell commands to initialize git submodules and build the grpc_cli command line tool using cmake. The commands set up a build directory, configure build options to enable tests and set the C++ standard to 17, and compile the grpc_cli binary. These commands assume a working environment with the grpc repository cloned and prerequisites installed.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit submodule update --init\n\n$ mkdir -p cmake/build\n$ cd cmake/build\n$ cmake -DgRPC_BUILD_TESTS=ON -DCMAKE_CXX_STANDARD=17 ../..\n$ make grpc_cli\n```\n\n----------------------------------------\n\nTITLE: Run Android Instrumentation Tests with Gradle\nDESCRIPTION: This command executes instrumentation tests on a connected Android device or emulator using Gradle. It configures the test runner with specific server host, port, and TLS settings as arguments.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/android/test/interop/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ ./gradlew connectedAndroidTest \\\n  -Pandroid.testInstrumentationRunnerArguments.server_host=grpc-test.sandbox.googleapis.com \\\n  -Pandroid.testInstrumentationRunnerArguments.server_port=443 \\\n  -Pandroid.testInstrumentationRunnerArguments.use_tls=true\n```\n\n----------------------------------------\n\nTITLE: Creating C Library using CMake\nDESCRIPTION: Defines a static or shared library target named `utf8_range` from the source file `utf8_range.c`. This represents the core C implementation of the library.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library (utf8_range\n  utf8_range.c\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing CsmOpenTelemetryPlugin\nDESCRIPTION: This code snippet demonstrates how to initialize the CsmOpenTelemetryPlugin within a Python application.  It requires the grpc_csm_observability package to be installed and a meter provider to be configured. The plugin is instantiated with the provider, enabling CSM observability features within gRPC.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/grpcio_csm_observability/README.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nimport grpc_csm_observability\n    \n    csm_otel_plugin = grpc_csm_observability.CsmOpenTelemetryPlugin(\n        meter_provider=provider\n    )\n```\n\n----------------------------------------\n\nTITLE: Building Zlib Compression Library with ExternalProject\nDESCRIPTION: Configures the build for the Zlib compression library, setting the installation directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/cmake_externalproject/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nExternalProject_Add(zlib\n  PREFIX zlib\n  SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../../../../third_party/zlib\"\n  CMAKE_CACHE_ARGS\n        -DCMAKE_INSTALL_PREFIX:PATH=${CMAKE_CURRENT_BINARY_DIR}/zlib\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Load Test Templates with Prebuilt Images - Bash\nDESCRIPTION: This snippet illustrates using 'loadtest_template.py' to generate a configuration template incorporating prebuilt worker images. It takes several input files and injects driver image/pool fields, server and client pools, and output table parameters, as well as scenario metadata. This template enables advanced workflows where prebuilt Docker/container images are reused for test orchestration. Users need Python and the template script, and must specify the relevant sample inputs and template output.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ ./tools/run_tests/performance/loadtest_template.py \\\n    -i ../test-infra/config/samples/templates/*_example_loadtest_with_prebuilt_workers.yaml \\\n    --inject_client_pool --inject_driver_image --inject_driver_pool \\\n    --inject_server_pool --inject_big_query_table --inject_timeout_seconds \\\n    -o ./tools/run_tests/performance/templates/loadtest_template_prebuilt_all_languages.yaml \\\n    --name prebuilt_all_languages\n```\n\n----------------------------------------\n\nTITLE: Installing From Source\nDESCRIPTION: This series of shell commands downloads the gRPC repository, initializes submodules, and installs the grpcio-csm-observability package from source.  The REPO_ROOT variable allows users to choose where to download the gRPC repository. Git is required for cloning and managing the repository, and pip is used for the final installation step.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/grpcio_csm_observability/README.rst#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ export REPO_ROOT=grpc  # REPO_ROOT can be any directory of your choice\n$ git clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc $REPO_ROOT\n$ cd $REPO_ROOT\n$ git submodule update --init\n\n$ cd src/python/grpcio_csm_observability\n\n# For the next command do `sudo pip install` if you get permission-denied errors\n$ pip install .\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple gRPC Internal Tracers Using GRPC_TRACE and absl Flags in Bash\nDESCRIPTION: This snippet enables logging from multiple internal gRPC tracers (tcp, http, api) by setting the `GRPC_TRACE` environment variable with comma-separated values. It also sets the logging verbosity to `--v=2` and a minimum log level of 0 to ensure trace logs are visible. This configuration helps gather detailed logs across different gRPC subsystems simultaneously for comprehensive troubleshooting.\nSOURCE: https://github.com/grpc/grpc/blob/master/TROUBLESHOOTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nGRPC_TRACE=tcp,http,api ./helloworld_application_using_grpc  --v=2 --minloglevel=0\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC and Protobuf Source Files with CMake - CMake\nDESCRIPTION: This snippet defines an `add_custom_command` in CMake to automatically generate C++ source and header files from a protocol buffer (`.proto`) input file using the Protobuf compiler (`protoc`) and gRPC plugin. It expects environment variables or cache entries such as `_PROTOBUF_PROTOC` and `_GRPC_CPP_PLUGIN_EXECUTABLE` to be set and requires the input `.proto` file to be in the correct location. The key parameters are the input proto file path and the output directory for the generated files. Output consists of generated .pb.h/.pb.cc and .grpc.pb.h/.grpc.pb.cc files for use in the build. Users must ensure all dependencies and plugins are available and compatible.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/flow_control/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Creating 'util' Library for Utility Functions\nDESCRIPTION: Defines a library target 'util' built from 'util.cc' and links it with 'hw_grpc_proto', metrics, gRPC, reflection, and protobuf dependencies, encapsulating helper functionalities for use in executables.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/codelab/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(util\n  \"util.cc\")\ntarget_link_libraries(util\n  hw_grpc_proto\n  opentelemetry-cpp::metrics\n  ${_GRPC_GRPCPP}\n  ${_REFLECTION}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Linking Library to Abseil using CMake\nDESCRIPTION: Links the `utf8_validity` target publicly to the Abseil strings library (`absl::strings`). This makes the Abseil strings library a required dependency for users of `utf8_validity` and ensures the necessary include paths and link flags are propagated.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(utf8_validity PUBLIC absl::strings)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Protobuf Code Generation for gRPC\nDESCRIPTION: Configures the build to generate C++ code from the helloworld.proto file using protoc and the gRPC plugin. Creates custom commands to generate the required .pb.cc, .pb.h, .grpc.pb.cc, and .grpc.pb.h files in the build directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Proto file\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\n# Generated sources\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n\n# Include generated *.pb.h files\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\ninclude_directories(\"${CMAKE_SOURCE_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Building RE2 Regular Expression Library with ExternalProject\nDESCRIPTION: Configures the build for the RE2 regular expression library with position-independent code and C++17 standard.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/cmake_externalproject/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nExternalProject_Add(re2\n  PREFIX re2\n  SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../../../../third_party/re2\"\n  CMAKE_CACHE_ARGS\n        -DCMAKE_POSITION_INDEPENDENT_CODE:BOOL=TRUE\n        -DCMAKE_INSTALL_PREFIX:PATH=${CMAKE_CURRENT_BINARY_DIR}/re2\n        -DCMAKE_CXX_STANDARD:STRING=17\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project and Dependencies (C++)\nDESCRIPTION: This snippet sets up the minimum CMake version and project name. It includes a common CMake file for shared configurations. It retrieves the proto file path and sets up generated source and header file names for protobuf and gRPC code. The `add_custom_command` generates the protobuf and gRPC code by invoking the protoc compiler with specified parameters. Dependencies include protobuf and gRPC.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/wait_for_ready/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(HelloWorld C CXX)\n\ninclude(../cmake/common.cmake)\n\n# Proto file\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\n# Generated sources\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Running All Docker Test Images for gRPC PHP\nDESCRIPTION: Command to run all Docker images for testing the gRPC PHP extension. This executes the tests in all available environment configurations.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ./src/php/bin/run_all_docker_images.sh\n```\n\n----------------------------------------\n\nTITLE: Viewing Initial Stack Trace | gdb | gdb\nDESCRIPTION: Shows an example stack trace in `gdb` when debugging an application using a pre-compiled `grpc` binary gem without debug symbols loaded. Function names and source information are largely missing, replaced by addresses and '??'.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/nativedebug/README.md#_snippet_1\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) bt\n#0  0x00007ffff7926e56 in epoll_wait (epfd=5, events=0x7ffff3cb4144, maxevents=100, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n#1  0x00007ffff383eb9e in ?? () from /home/.rvm/gems/ruby-3.0.0/gems/grpc-1.60.1-x86_64-linux/src/ruby/lib/grpc/3.0/grpc_c.so\n#2  0x00007ffff355e002 in ?? () from /home/.rvm/gems/ruby-3.0.0/gems/grpc-1.60.1-x86_64-linux/src/ruby/lib/grpc/3.0/grpc_c.so\n#3  0x00007ffff38466e2 in ?? () from /home/.rvm/gems/ruby-3.0.0/gems/grpc-1.60.1-x86_64-linux/src/ruby/lib/grpc/3.0/grpc_c.so\n#4  0x00007ffff35ba2ea in ?? () from /home/.rvm/gems/ruby-3.0.0/gems/grpc-1.60.1-x86_64-linux/src/ruby/lib/grpc/3.0/grpc_c.so\n#5  0x00007ffff34abf6b in ?? () from /home/.rvm/gems/ruby-3.0.0/gems/grpc-1.60.1-x86_64-linux/src/ruby/lib/grpc/3.0/grpc_c.so\n#6  0x00007ffff7c67ca7 in rb_nogvl (func=0x7ffff34abed3, data1=0x0, ubf=<optimized out>, data2=<optimized out>, flags=<optimized out>) at thread.c:1669\n#7  0x00007ffff34ab110 in ?? () from /home/.rvm/gems/ruby-3.0.0/gems/grpc-1.60.1-x86_64-linux/src/ruby/lib/grpc/3.0/grpc_c.so\n#8  0x00007ffff7c6780c in thread_do_start (th=0x555555ad16e0) at thread.c:769\n#9  thread_start_func_2 (th=th@entry=0x555555ad16e0, stack_start=<optimized out>) at thread.c:822\n#10 0x00007ffff7c679a6 in thread_start_func_1 (th_ptr=<optimized out>) at /home/.rvm/src/ruby-3.0.0/thread_pthread.c:994\n#11 0x00007ffff78a63ec in start_thread (arg=<optimized out>) at ./nptl/pthread_create.c:444\n#12 0x00007ffff7926a4c in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n```\n\n----------------------------------------\n\nTITLE: Finding and Linking Installed gRPC Using CMake find_package in C++\nDESCRIPTION: Shows how to locate an installed gRPC package with CMake's find_package command and link it to an executable target. Requires gRPC C++ libraries to be installed on the system and discoverable by CMake. This snippet facilitates integration of pre-built gRPC binaries, reducing build times by leveraging existing installations.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/cpp/README.md#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(gRPC CONFIG REQUIRED)\nadd_executable(my_exe my_exe.cc)\ntarget_link_libraries(my_exe gRPC::grpc++)\n```\n\n----------------------------------------\n\nTITLE: Resolving Proto File Paths\nDESCRIPTION: Uses `get_filename_component` to find the absolute paths of the `helloworld.proto` and `route_guide.proto` files and their containing directories. These paths are needed by the protobuf compiler.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/multiplex/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\nget_filename_component(rg_proto \"../../protos/route_guide.proto\" ABSOLUTE)\nget_filename_component(rg_proto_path \"${rg_proto}\" PATH)\n```\n\n----------------------------------------\n\nTITLE: Viewing Stack Trace After Loading Symbols | gdb | gdb\nDESCRIPTION: Displays the `gdb` stack trace after successfully loading the `.dbg` symbol file. Function names derived from the debug symbols are now visible, greatly improving the clarity of the call stack during debugging.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/nativedebug/README.md#_snippet_4\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) bt\n#0  0x00007ffff7926e56 in epoll_wait (epfd=5, events=0x7ffff3cb4144, maxevents=100, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n#1  0x00007ffff383eb9e in do_epoll_wait (ps=0x555555ad1690, deadline=...) at src/core/lib/iomgr/ev_epoll1_linux.cc:723\n#2  pollset_work (ps=0x555555ad1690, worker_hdl=0x0, deadline=...) at src/core/lib/iomgr/ev_epoll1_linux.cc:1038\n#3  0x00007ffff355e002 in pollset_work (pollset=<optimized out>, worker=<optimized out>, deadline=...) at src/core/lib/iomgr/ev_posix.cc:249\n#4  0x00007ffff38466e2 in grpc_pollset_work (pollset=<optimized out>, worker=<optimized out>, deadline=...) at src/core/lib/iomgr/pollset.cc:48\n#5  0x00007ffff35ba2ea in cq_next (cq=0x555555ad1510, deadline=..., reserved=<optimized out>) at src/core/lib/surface/completion_queue.cc:1043\n#6  0x00007ffff34abf6b in run_poll_channels_loop_no_gil (arg=arg@entry=0x0) at ../../../../src/ruby/ext/grpc/rb_channel.c:663\n#7  0x00007ffff7c67ca7 in rb_nogvl (func=0x7ffff34abed3 <run_poll_channels_loop_no_gil>, data1=0x0, ubf=<optimized out>, data2=<optimized out>, flags=flags@entry=0) at thread.c:1669\n#8  0x00007ffff7c68138 in rb_thread_call_without_gvl (func=<optimized out>, data1=<optimized out>, ubf=<optimized out>, data2=<optimized out>) at thread.c:1785\n#9  0x00007ffff34ab110 in run_poll_channels_loop (arg=<optimized out>) at ../../../../src/ruby/ext/grpc/rb_channel.c:734\n#10 0x00007ffff7c6780c in thread_do_start (th=0x555555ad16e0) at thread.c:769\n#11 thread_start_func_2 (th=th@entry=0x555555ad16e0, stack_start=<optimized out>) at thread.c:822\n#12 0x00007ffff7c679a6 in thread_start_func_1 (th_ptr=<optimized out>) at /home/.rvm/src/ruby-3.0.0/thread_pthread.c:994\n#13 0x00007ffff78a63ec in start_thread (arg=<optimized out>) at ./nptl/pthread_create.c:444\n#14 0x00007ffff7926a4c in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n```\n\n----------------------------------------\n\nTITLE: Referencing Proto Files Outside Project Directory and Using the Link Attribute (XML, .NET)\nDESCRIPTION: This .csproj snippet shows how to reference proto files located outside the project directory for code generation and make them visible in Visual Studio's Solution Explorer. The Include attribute specifies the relative path to the proto file, and the Link attribute defines the virtual path under which it appears in the IDE. GrpcServices attribute controls whether client, server, or no gRPC code is generated, supporting modular and DRY sharing of contracts. This pattern is especially useful for multi-project solutions where proto files are shared centrally.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_4\n\nLANGUAGE: XML\nCODE:\n```\n<ItemGroup>\n   <Protobuf Include=\"..\\Proto\\aggregate.proto\" GrpcServices=\"Client\" Link=\"Protos\\aggregate.proto\"/>\n   <Protobuf Include=\"..\\Proto\\greet.proto\" GrpcServices=\"None\" Link=\"Protos\\greet.proto\"/>\n   <Protobuf Include=\"..\\Proto\\count.proto\" GrpcServices=\"None\" Link=\"Protos\\count.proto\"/>\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Building Android App with Gradle (Shell)\nDESCRIPTION: This command uses the Gradle wrapper (`gradlew`) to execute the `installDebug` task. This task typically builds the debug variant of the Android application and installs it onto a connected device or emulator, streamlining the development and testing process.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/android/helloworld/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ ./gradlew installDebug\n```\n\n----------------------------------------\n\nTITLE: Declaring and Running a GoogleTest Death Test in C++\nDESCRIPTION: This snippet demonstrates a basic GoogleTest death test in C++ and the corresponding main method setup used in non-iOS builds. It includes a test function using ASSERT_DEATH to verify behavior, and a main function that initializes the test environment, calls InitGoogleTest with command line arguments, initializes gRPC, runs all tests, and then shuts down gRPC. Dependencies include the GoogleTest and gRPC libraries, and key parameters are argc and argv from the command line, propagated throughout test initialization. The output is the result of RUN_ALL_TESTS, and this version is not suitable for iOS due to incompatibility with GTMGoogleTestRunner.\nSOURCE: https://github.com/grpc/grpc/blob/master/test/cpp/README-iOS.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nTEST(MyTest, TestOne) {\n  ASSERT_DEATH(ThisShouldDie(), \"\");\n}\n\nint main(int argc, char** argv) {\ngrpc::testing::TestEnvironment env(&argc, argv);\n  ::testing::InitGoogleTest(&argc, argv);\n  grpc_init();\n  return RUN_ALL_TESTS();\n  grpc_shutdown();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building and Running PHP-FPM for gRPC Client via Docker\nDESCRIPTION: Builds a Docker image tagged `grpc-php/fpm` using `fpm.Dockerfile` for the PHP-FPM setup. It then runs this image interactively, linking to the `node-server`, naming the container `fpm`, and mapping host port 9000 to the container's port 9000.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/php/echo/README.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n$ docker build -t grpc-php/fpm -f ./fpm.Dockerfile .\n$ docker run -it --rm --link node-server:node-server -p 9000:9000 \\\n  --name fpm grpc-php/fpm\n```\n\n----------------------------------------\n\nTITLE: Unary-Unary Pattern in gRPC Python\nDESCRIPTION: In this pattern, the client sends a single request and the server responds with a single response, making it similar to a traditional function call. Implemented through simple_method in client.py and SimpleMethod in server.py.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/data_transmission/README.en.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nsimple_method\nSimpleMethod\n```\n\n----------------------------------------\n\nTITLE: Creating and Linking gRPC Proto Library in CMake\nDESCRIPTION: This snippet adds an interface library 'hw_grpc_proto' built from generated gRPC and protobuf sources. It links the required libraries for reflection, core gRPC, and the Protobuf runtime. This library encapsulates all gRPC and Protobuf generated code required by both client and server applications.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/load_balancing/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Updating Git Submodules and Building gRPC C Core Library - Shell Script\nDESCRIPTION: Updates git submodules and builds the C core of gRPC using make. Sets an environment variable to allow pthread support on fork, required for advanced PHP use cases. Assumes a UNIX-like environment with make, gcc, and dependencies ready.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ git submodule update --init\n$ EXTRA_DEFINES=GRPC_POSIX_FORK_ALLOW_PTHREAD_ATFORK make\n```\n\n----------------------------------------\n\nTITLE: Initializing ProtoReflectionDescriptorDatabase in C++\nDESCRIPTION: Code to initialize a ProtoReflectionDescriptorDatabase instance with a gRPC channel for use with Server Reflection in a C++ client.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_reflection_tutorial.md#_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\nstd::shared_ptr<grpc::Channel> channel =\n    grpc::CreateChannel(server_address, server_cred);\ngrpc::ProtoReflectionDescriptorDatabase reflection_db(channel);\n```\n\n----------------------------------------\n\nTITLE: Running gRPC C++ OpenTelemetry Example Server - Bash\nDESCRIPTION: This shell command starts the gRPC C++ example server configured with OpenTelemetry and Prometheus exporter. It requires Bazel to be installed and the example to be built with all listed dependencies including absl, protobuf, prometheus-cpp, opentelemetry-cpp (with WITH_ABSEIL=ON and WITH_PROMETHEUS=ON), and grpc (with gRPC_BUILD_GRPCPP_OTEL_PLUGIN=ON). The server listens for incoming RPCs and provides a Prometheus metrics endpoint for observability.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ tools/bazel run examples/cpp/otel:greeter_callback_server\n```\n\n----------------------------------------\n\nTITLE: Suppressing Missing Expected Protoc Output Warning\nDESCRIPTION: This XML snippet demonstrates how to suppress the warning message \"Some expected protoc outputs were not generated\" by setting the `Protobuf_NoWarnMissingExpected` MSBuild property to `true`. This should only be done if you understand the cause of the warning and have addressed the underlying issue or determined that it is not relevant.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_13\n\nLANGUAGE: XML\nCODE:\n```\n<PropertyGroup>\n  <Protobuf_NoWarnMissingExpected>true</Protobuf_NoWarnMissingExpected>\n</PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: Running Protocol Buffers Compiler Explicitly in MSBuild\nDESCRIPTION: XML configuration for bypassing Grpc.Tools build logic and running the protocol buffers compiler explicitly in a project file. Defines properties for compiler paths and implements a custom target to execute the compiler command.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_16\n\nLANGUAGE: xml\nCODE:\n```\n<Target Name=\"MyProtoCompile\">\n  <PropertyGroup>\n    <ProtoCCommand>$(Protobuf_ProtocFullPath) --plugin=protoc-gen-grpc=$(gRPC_PluginFullPath)  -I $(Protobuf_StandardImportsPath) ....rest of your command.... </ProtoCCommand>\n  </PropertyGroup>\n  <Message Importance=\"high\" Text=\"$(ProtoCCommand)\" />\n  <Exec Command=\"$(ProtoCCommand)\" />\n</Target>\n```\n\n----------------------------------------\n\nTITLE: Identifying gRPC-Web Clients with X-User-Agent\nDESCRIPTION: Specifies the use of the `X-User-Agent` header to identify gRPC-Web clients. This header should be used instead of the standard `User-Agent` header, which is typically controlled by the browser environment. The format follows the standard gRPC user-agent convention.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md#_snippet_3\n\nLANGUAGE: HTTP Header Format\nCODE:\n```\nX-User-Agent: grpc-web-javascript/0.1\n```\n\n----------------------------------------\n\nTITLE: MSBuild Targets File for Proto NuGet Package Integration\nDESCRIPTION: XML configuration for a .targets file that allows .proto files bundled in a NuGet package to be included in Grpc.Tools compilation. It defines the path to proto files and conditionally adds it to the import path when users opt in.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_19\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\"?>\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <!-- This targets file allows .proto files bundled in package, \n  to be included in Grpc.Tools compilation. -->\n  \n  <PropertyGroup>\n    <!-- Define a property containing the path of the proto files.\n         Content from the nupkg. -->\n    <MyExampleProtos_ProtosPath>$( [System.IO.Path]::GetFullPath($(MSBuildThisFileDirectory)../content/protos) )</MyExampleProtos_ProtosPath>\n  </PropertyGroup>\n\n  <!-- Run immediately before the Protobuf_BeforeCompile extension point. -->\n  <!-- Only include protos if project has set <IncludeMyExampleProtosProtos> \n       property to true. -->\n  <Target Name=\"MyExampleProtos_BeforeCompile\"\n          BeforeTargets=\"Protobuf_BeforeCompile\"\n          Condition=\" '$(IncludeMyExampleProtosProtos)' == 'true' \">\n    <PropertyGroup>\n      <!-- Add proto files by including path in Protobuf_StandardImportsPath.\n           This path is passed to protoc via the -I option -->\n      <Protobuf_StandardImportsPath>$(Protobuf_StandardImportsPath);$(MyPackage_ProtosPath)</Protobuf_StandardImportsPath>\n    </PropertyGroup>\n\n    <!-- These message are not required but included here for diagnostics -->\n    <Message Text=\"Included proto files at $(MyExampleProtos_ProtosPath) in import path.\" Importance=\"high\" />\n    <Message Text=\"Updated proto imports path: $(Protobuf_StandardImportsPath)\" Importance=\"high\" />\n  </Target>\n</Project>\n```\n\n----------------------------------------\n\nTITLE: Creating a DescriptorPool with Reflection Database in C++\nDESCRIPTION: Code to create a DescriptorPool using the ProtoReflectionDescriptorDatabase for use with Server Reflection in a C++ client.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_reflection_tutorial.md#_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\ngoogle::protobuf::DescriptorPool desc_pool(&reflection_db);\n```\n\n----------------------------------------\n\nTITLE: Defining Generated File Variables\nDESCRIPTION: Sets CMake variables to represent the expected paths of the C++ source and header files that will be generated by `protoc` from the `.proto` files. These paths are within the CMake binary directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/multiplex/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nset(rg_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/route_guide.pb.cc\")\nset(rg_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/route_guide.pb.h\")\nset(rg_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/route_guide.grpc.pb.cc\")\nset(rg_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/route_guide.grpc.pb.h\")\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Service Proto\nDESCRIPTION: Defines the structure of the gRPC service 'EchoTestService' using protocol buffers syntax. It includes two methods: a unary RPC 'Echo' and a bidirectional streaming RPC 'BidiStream', specifying their request and response types.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/unit_testing.md#_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nservice EchoTestService {\n        rpc Echo(EchoRequest) returns (EchoResponse);\n        rpc BidiStream(stream EchoRequest) returns (stream EchoResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing gRPC via vcpkg Package Manager\nDESCRIPTION: Describes the commands to set up the vcpkg package manager on Linux or Windows and use it to install gRPC. This community-maintained approach provides up-to-date versions of gRPC on supported platforms, simplifying dependency management without manual build steps. Requires Git and platform-specific bootstrap scripts to prepare vcpkg.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/cpp/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n\n# Bootstrap on Linux:\n./bootstrap-vcpkg.sh\n# Bootstrap on Windows instead:\n# ./bootstrap-vcpkg.bat\n\n./vcpkg integrate install\n\n# install gRPC using vcpkg package manager\n./vcpkg install grpc\n```\n\n----------------------------------------\n\nTITLE: Locally Building Docker Images without Pushing to Artifact Registry (Bash)\nDESCRIPTION: This command allows developers to quickly build local variations of their Docker images by running the push_testing_images.sh script in a special LOCAL_ONLY_MODE. When the environment variable is set to true, the script avoids interaction with the centralized artifact registry, significantly speeding up local test iterations. Requires the same script dependencies as the standard build, but images are retained only on the local Docker instance.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/dockerfile/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nLOCAL_ONLY_MODE=true tools/dockerfile/push_testing_images.sh\n```\n\n----------------------------------------\n\nTITLE: Pushing Windows RBE Docker Image\nDESCRIPTION: This command pushes the built Docker image to the Google Artifact Registry (GAR). It uses the fully qualified image name including the registry and repository. This makes the image available for use by RBE workers.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/toolchains/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ndocker push us-docker.pkg.dev/grpc-testing/testing-images-public/rbe_windows2019\n```\n\n----------------------------------------\n\nTITLE: Defining Retry Policy via Service Config in gRPC (C++)\nDESCRIPTION: This C++ code snippet defines the service configuration string for enabling and configuring retry logic in gRPC clients, using the channel argument 'GRPC_ARG_SERVICE_CONFIG'. It specifies 'maxAttempts', 'initialBackoff', 'maxBackoff', 'backoffMultiplier', and a list of retryable status codes for the 'helloworld.Greeter' service. This configuration is required for instructing gRPC to automatically retry RPC calls under specified conditions. To use this, the client must supply it as a channel argument during gRPC channel creation. Inputs include status codes and backoff parameters; outputs are client retry behaviors as defined. The policy string must be valid JSON and may require absl::string_view and gRPC core dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/retry/README.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr absl::string_view kRetryPolicy =\n    \"{\\\"methodConfig\\\" : [{\"\n    \"   \\\"name\\\" : [{\\\"service\\\": \\\"helloworld.Greeter\\\"}],\"\n    \"   \\\"waitForReady\\\": true,\"\n    \"   \\\"retryPolicy\\\": {\"\n    \"     \\\"maxAttempts\\\": 4,\"\n    \"     \\\"initialBackoff\\\": \\\"1s\\\",\"\n    \"     \\\"maxBackoff\\\": \\\"120s\\\",\"\n    \"     \\\"backoffMultiplier\\\": 1.0,\"\n    \"     \\\"retryableStatusCodes\\\": [\\\"UNAVAILABLE\\\"]\"\n    \"    }\"\n    \"}]}\";\n```\n\n----------------------------------------\n\nTITLE: Including Common CMake Configuration\nDESCRIPTION: Includes a shared CMake file `common.cmake` which is assumed to define common build settings, find dependencies, and set crucial variables like `_PROTOBUF_PROTOC`, `_GRPC_CPP_PLUGIN_EXECUTABLE`, `_REFLECTION`, `_GRPC_GRPCPP`, and `_PROTOBUF_LIBPROTOBUF`.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/multiplex/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Creating Dynamic Messages in C++\nDESCRIPTION: Code to get message type descriptors and create messages dynamically in a C++ client using Server Reflection.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_reflection_tutorial.md#_snippet_10\n\nLANGUAGE: c++\nCODE:\n```\nconst google::protobuf::Descriptor* request_desc =\n    desc_pool->FindMessageTypeByName(\"helloworld.HelloRequest\");\ngoogle::protobuf::DynamicMessageFactory dmf;\ngoogle::protobuf::Message* request = dmf.GetPrototype(request_desc)->New();\n```\n\n----------------------------------------\n\nTITLE: Illustrating gRPC-Web Trailer Encoding in HTTP/1 Style\nDESCRIPTION: Demonstrates how gRPC-Web encodes trailers within the response body when needed (e.g., over HTTP/1). Key-value pairs are formatted like an HTTP/1 headers block (RFC 7230, Section 3.2), using lowercase keys and omitting the final terminating newline. This trailer block constitutes the last message in the response.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md#_snippet_1\n\nLANGUAGE: HTTP Header Format\nCODE:\n```\nkey1: foo\\r\\n\nkey2: bar\\r\\n\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Client with Observability in Python\nDESCRIPTION: This code shows how to start the gRPC client that interacts with the server, with an emphasis on observability metrics. The client should be launched shortly after the server, within 10 seconds, to ensure connection.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/observability/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython -m observability_greeter_client\n```\n\n----------------------------------------\n\nTITLE: Concatenating Load Test Configuration YAML Files Using Python Script - Bash\nDESCRIPTION: This snippet demonstrates the usage pattern of the 'loadtest_concat_yaml.py' Python script. The script concatenates multiple YAML configuration files into a single output YAML file, which can be used for unified benchmark runs. Requires Python with PyYAML installed, as well as the script itself in the system PATH. Inputs are one or more YAML files specified with the -i option, and the output is specified with -o. The resulting YAML file contains all merged configurations for further benchmarking tools.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ loadtest_concat_yaml.py -i infile1.yaml infile2.yaml -o outfile.yaml\n```\n\n----------------------------------------\n\nTITLE: Navigating to the xDS example directory (shell)\nDESCRIPTION: This command navigates to the directory containing the xDS example scripts.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/xds/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd grpc/examples/python/xds\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC Protobuf and Build Environment - CMake\nDESCRIPTION: This snippet sets up required environment variables and directory structures for building the gRPC Helloworld example using CMake on Android. Dependencies include the Protobuf compiler and gRPC C++ plugin, which must be present at specified paths. Key parameters are paths to protoc binaries, source and build directories, and the ABI target; these determine where files are generated and how libraries are linked.\nInputs: paths to protoc binaries, source directories.\nOutputs: created build and generated code directories, prepared for further build steps.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/android/helloworld/app/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nset(helloworld_PROTOBUF_PROTOC_EXECUTABLE \"/usr/local/bin/protoc\" CACHE STRING \"Protoc binary on host\")\nset(helloworld_GRPC_CPP_PLUGIN_EXECUTABLE \"/usr/local/bin/grpc_cpp_plugin\" CACHE STRING \"gRPC CPP plugin binary on host\")\n\nset(GRPC_SRC_DIR ../../../../)\n\nset(GRPC_BUILD_DIR ../grpc/outputs/${ANDROID_ABI})\nfile(MAKE_DIRECTORY ${GRPC_BUILD_DIR})\n\nadd_subdirectory(${GRPC_SRC_DIR} ${GRPC_BUILD_DIR})\n\nset(GRPC_PROTO_GENS_DIR ${CMAKE_BINARY_DIR}/gens)\nfile(MAKE_DIRECTORY ${GRPC_PROTO_GENS_DIR})\ninclude_directories(${GRPC_PROTO_GENS_DIR})\n```\n\n----------------------------------------\n\nTITLE: Authenticating and Logging In with gcloud for Docker Artifact Registry (Bash)\nDESCRIPTION: This snippet authenticates Docker with the Google Artifact Registry by configuring Docker's credential helper to use gcloud and logging into a GCP account. Prerequisites include having gcloud CLI installed and properly initialized. The command sequence expects no arguments, operating on the standard Docker installation and target GCP project. On completion, Docker gains credentials needed to push and pull images from us-docker.pkg.dev.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/dockerfile/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngcloud auth configure-docker us-docker.pkg.dev\ngcloud auth login\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC/Protobuf C++ Files Using CMake Function (CMake)\nDESCRIPTION: This snippet defines the 'android_protobuf_grpc_generate_cpp' CMake function, which automates the steps for generating C++ source and header files from .proto schemas using 'protoc' and the gRPC C++ plugin. It performs file path computations and adds custom build commands to invoke code generation, outputting results into a dedicated 'gens' directory. Dependencies include the defined PROTOBUF_PROTOC_EXECUTABLE and gRPC_CPP_PLUGIN_EXECUTABLE; callers must supply output file variables, include root, and a list of .proto sources.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/android/test/interop/app/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(android_protobuf_grpc_generate_cpp SRC_FILES HDR_FILES INCLUDE_ROOT)\n  if(NOT ARGN)\n    message(SEND_ERROR \"Error: android_protobuf_grpc_generate_cpp() called without any proto files\")\n    return()\n  endif()\n\n  set(${SRC_FILES})\n  set(${HDR_FILES})\n  set(PROTOBUF_INCLUDE_PATH -I ${INCLUDE_ROOT})\n  foreach(FIL ${ARGN})\n    get_filename_component(ABS_FIL ${FIL} ABSOLUTE)\n    get_filename_component(FIL_WE ${FIL} NAME_WE)\n    file(RELATIVE_PATH REL_FIL ${CMAKE_CURRENT_SOURCE_DIR}/${INCLUDE_ROOT} ${ABS_FIL})\n    get_filename_component(REL_DIR ${REL_FIL} DIRECTORY)\n    set(RELFIL_WE \"${REL_DIR}/${FIL_WE}\")\n\n    list(APPEND ${SRC_FILES} \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.pb.cc\")\n    list(APPEND ${HDR_FILES} \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.pb.h\")\n    list(APPEND ${SRC_FILES} \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.grpc.pb.cc\")\n    list(APPEND ${HDR_FILES} \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.grpc.pb.h\")\n\n    add_custom_command(\n      OUTPUT \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.grpc.pb.cc\"\n             \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.grpc.pb.h\"\n             \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.pb.cc\"\n             \"${GRPC_PROTO_GENS_DIR}/${RELFIL_WE}.pb.h\"\n      COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}\n      ARGS --grpc_out=${GRPC_PROTO_GENS_DIR}\n        --cpp_out=${GRPC_PROTO_GENS_DIR}\n        --plugin=protoc-gen-grpc=${gRPC_CPP_PLUGIN_EXECUTABLE}\n        ${PROTOBUF_INCLUDE_PATH}\n        ${REL_FIL}\n      WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n      DEPENDS ${PROTOBUF_PROTOC_EXECUTABLE} ${gRPC_CPP_PLUGIN_EXECUTABLE} ${ABS_FIL} )\n  endforeach()\n\n  set_source_files_properties(${${SRC_FILES}} ${${HDR_FILES}} PROPERTIES GENERATED TRUE)\n  set(${SRC_FILES} ${${SRC_FILES}} PARENT_SCOPE)\n  set(${HDR_FILES} ${${HDR_FILES}} PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Verifying Metrics Export via Prometheus Endpoint - Bash\nDESCRIPTION: These shell commands use curl to request the exported Prometheus metrics from the gRPC server and client endpoints (default ports: 9464 and 9465). The commands can be used in separate terminals to ensure that metrics are being properly collected and exposed. The port numbers may need to be updated if custom Prometheus endpoints are configured in the application.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ curl localhost:9464/metrics\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ curl localhost:9465/metrics\n```\n\n----------------------------------------\n\nTITLE: Linking Generated Library Dependencies\nDESCRIPTION: Links the `example_grpc_proto` library target against the necessary external libraries provided by the common CMake configuration: protobuf library (`_PROTOBUF_LIBPROTOBUF`), gRPC C++ library (`_GRPC_GRPCPP`), and the gRPC reflection library (`_REFLECTION`).\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/multiplex/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(\n  example_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Including Generated Headers Directory - CMake\nDESCRIPTION: Adds the current binary directory (where generated files are placed) to the list of directories searched for header files. This allows the compiled source files to find the generated `.pb.h` and `.grpc.pb.h` headers.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/cancellation/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Empty Request (gRPC Interop Test, JSON Payload)\nDESCRIPTION: This snippet represents an empty request payload, corresponding to the `grpc.testing.Empty` message type. It is used when calling RPC methods that require no input parameters.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{}\n```\n\n----------------------------------------\n\nTITLE: Building C-Ares Library with ExternalProject\nDESCRIPTION: Configures the build for the C-Ares library as a static library with position-independent code. Sets installation directory and build options.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/cmake_externalproject/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nExternalProject_Add(c-ares\n  PREFIX c-ares\n  SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../../../../third_party/cares/cares\"\n  CMAKE_CACHE_ARGS\n        -DCMAKE_INSTALL_PREFIX:PATH=${CMAKE_CURRENT_BINARY_DIR}/c-ares\n        -DCARES_SHARED:BOOL=OFF\n        -DCARES_STATIC:BOOL=ON\n        -DCARES_STATIC_PIC:BOOL=ON\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Objective-C Dependencies with Cocoapods\nDESCRIPTION: Executes the `pod install` command within the Objective-C helloworld project directory. This command fetches and installs the dependencies listed in the project's Podfile, including the gRPC Objective-C library, and generates the necessary Xcode workspace file.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$ pod install\n```\n\n----------------------------------------\n\nTITLE: Building and Running the php-zts Docker Image\nDESCRIPTION: Commands to build and run the php-zts Docker image, which builds the gRPC extension against PHP with Zend Thread Safety (ZTS) enabled to test thread safety compatibility.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ cd grpc\n$ docker build -t grpc-php/php-zts -f ./src/php/docker/php-zts/Dockerfile .\n$ docker run -it --rm grpc-php/php-zts\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Client Application (Bash)\nDESCRIPTION: This Bash command executes the gRPC client by calling the './client' binary. The client must be built and located in the current working directory. When started, it attempts to connect to the gRPC server at the predefined endpoint and demonstrates retry behavior according to the configured policy. Outputs indicate the result of request attempts and any server/state responses received.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/retry/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n./client\n```\n\n----------------------------------------\n\nTITLE: Installing gRPC PHP Extension with PECL - Shell Script\nDESCRIPTION: This shell script demonstrates how to install the gRPC PHP extension using PECL. The command supports optional sudo for systems requiring escalated privileges and allows installing a specific version if needed. Requires a compatible PHP and gcc version as prerequisites; outputs installation logs and installs to the platform's standard extension directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ [sudo] pecl install grpc\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Protoc and gRPC Plugin Paths via Environment Variables in Bash\nDESCRIPTION: This Bash snippet shows how to use environment variables to instruct Grpc.Tools to use custom-built versions of the protoc compiler and grpc_csharp_plugin. By setting PROTOBUF_PROTOC and GRPC_PROTOC_PLUGIN to the full paths of the custom binaries before running 'dotnet build', you can override the default tools shipped with the NuGet package.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nexport PROTOBUF_PROTOC=$my_custom_build/protoc\nexport GRPC_PROTOC_PLUGIN=$my_custom_build/grpc_csharp_plugin\ndotnet build myproject.csproj\n```\n\n----------------------------------------\n\nTITLE: Configuring Outlier Detection in gRPC Backend Service (JSON)\nDESCRIPTION: This JSON snippet defines the `outlierDetection` configuration for a gRPC backend service. It specifies an interval of 2 seconds for detection checks and requires a minimum request volume of 20 before success rate enforcement begins. This configuration is used in a test to verify that clients correctly apply outlier detection and temporarily avoid backends failing requests.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/xds-test-descriptions.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"interval\": {\n    \"seconds\": 2,\n    \"nanos\": 0\n  },\n  \"successRateRequestVolume\": 20\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Initial FullDuplexCall Request with Payload (gRPC Interop Test, JSON Payload)\nDESCRIPTION: This snippet defines the initial request payload for the `FullDuplexCall` in the Custom Metadata test. It includes `response_parameters` specifying the desired response size and a large dummy `payload` body.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"response_parameters\":{\n    \"size\": 314159\n  },\n  \"payload\":{\n    \"body\": \"271828 bytes of zeros\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generated File Paths and Custom Protoc Command\nDESCRIPTION: This snippet defines variables for the paths of the Protobuf and gRPC generated C++ source and header files. It then sets up a custom command that invokes the `protoc` compiler and the `grpc_cpp_plugin` to generate these files from the `keyvaluestore.proto` definition.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/interceptors/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Proto file\nget_filename_component(kvs_proto \"../../protos/keyvaluestore.proto\" ABSOLUTE)\nget_filename_component(kvs_proto_path \"${kvs_proto}\" PATH)\n\n# Generated sources\nset(kvs_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/keyvaluestore.pb.cc\")\nset(kvs_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/keyvaluestore.pb.h\")\nset(kvs_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/keyvaluestore.grpc.pb.cc\")\nset(kvs_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/keyvaluestore.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${kvs_proto_srcs}\" \"${kvs_proto_hdrs}\" \"${kvs_grpc_srcs}\" \"${kvs_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${kvs_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${kvs_proto}\"\n      DEPENDS \"${kvs_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Building gRPC Protobuf Shared Libraries for Android (CMake)\nDESCRIPTION: This set of snippets demonstrates invoking 'android_protobuf_grpc_generate_cpp' to produce source/header files for each proto schema (messages, empty, test), followed by creating shared libraries from those results. Each library links against core dependencies such as libprotobuf, grpc++, Android NDK libraries, and in some cases, other generated proto libraries. The aim is to modularize proto-based code generation and linkage for structured deployment on Android.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/android/test/interop/app/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nandroid_protobuf_grpc_generate_cpp(\n  MESSAGES_PROTO_SRCS MESSAGES_PROTO_HDRS\n  ${GRPC_SRC_DIR} ${GRPC_SRC_DIR}/src/proto/grpc/testing/messages.proto)\n\nadd_library(messages_proto_lib\n  SHARED ${MESSAGES_PROTO_SRCS} ${MESSAGES_PROTO_HDRS})\n\ntarget_link_libraries(messages_proto_lib\n  libprotobuf\n  grpc++\n  android\n  log)\n```\n\nLANGUAGE: CMake\nCODE:\n```\nandroid_protobuf_grpc_generate_cpp(\n  EMPTY_PROTO_SRCS EMPTY_PROTO_HDRS\n  ${GRPC_SRC_DIR} ${GRPC_SRC_DIR}/src/proto/grpc/testing/empty.proto)\n\nadd_library(empty_proto_lib\n  SHARED ${EMPTY_PROTO_SRCS} ${EMPTY_PROTO_HDRS})\n\ntarget_link_libraries(empty_proto_lib\n  libprotobuf\n  grpc++\n  android\n  log)\n```\n\nLANGUAGE: CMake\nCODE:\n```\nandroid_protobuf_grpc_generate_cpp(\n  TEST_PROTO_SRCS TEST_PROTO_HDRS\n  ${GRPC_SRC_DIR} ${GRPC_SRC_DIR}/src/proto/grpc/testing/test.proto)\n\nadd_library(test_proto_lib\n  SHARED ${TEST_PROTO_SRCS} ${TEST_PROTO_HDRS})\n\ntarget_link_libraries(test_proto_lib\n  libprotobuf\n  grpc++\n  empty_proto_lib\n  messages_proto_lib\n  android\n  log)\n```\n\n----------------------------------------\n\nTITLE: Adding Generated Headers Directory\nDESCRIPTION: Adds the binary output directory (`CMAKE_CURRENT_BINARY_DIR`) to the list of directories where the compiler searches for header files. This is necessary so that the compiled C++ files can include the generated `.pb.h` and `.grpc.pb.h` files.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/multiplex/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Empty Unary Call Test Procedure\nDESCRIPTION: This test verifies support for zero-size messages by having the client call EmptyCall with the default Empty message and asserting a successful call with a non-null response. The focus is on ensuring gRPC implementations can handle requests and responses with no payload.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n 1. Client calls EmptyCall with the default Empty message\n```\n\n----------------------------------------\n\nTITLE: AuthMetadataPlugin Class Definition in gRPC Python\nDESCRIPTION: Defines the interface for a custom authentication plugin that manipulates metadata for each gRPC call.  Implementations must not block and should use the provided callback to pass metadata. The plugin is used to add authentication-related HTTP headers to the RPC.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/auth/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass AuthMetadataPlugin:\n    \"\"\"A specification for custom authentication.\"\"\"\n\n    def __call__(self, context, callback):\n        \"\"\"Implements authentication by passing metadata to a callback.\n\n        Implementations of this method must not block.\n\n        Args:\n          context: An AuthMetadataContext providing information on the RPC that\n            the plugin is being called to authenticate.\n          callback: An AuthMetadataPluginCallback to be invoked either\n            synchronously or asynchronously.\n        \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Building and Running the fork-support Docker Image\nDESCRIPTION: Commands to build and run the fork-support Docker image, which tests whether the gRPC extension properly supports the pcntl_fork() function without freezing or crashing.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ cd grpc\n$ docker build -t grpc-php/fork-support -f ./src/php/docker/fork-support/Dockerfile .\n$ docker run -it --rm grpc-php/fork-support\n```\n\n----------------------------------------\n\nTITLE: Committing Changes (Git)\nDESCRIPTION: This git command commits staged changes with a descriptive message. The '-m' flag includes a message to detail the changes being committed. The message should provide a brief, yet comprehensive description of the alterations made in the commit.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -m \"Add new feature: brief description\"\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Client with Bazel\nDESCRIPTION: This command runs the gRPC client example using Bazel. It executes the `client` target and passes the server address as a command-line argument. The `[SERVER_ADDRESS]` placeholder should be replaced with the actual address where the server is running.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/multiprocessing/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nbazel run //examples/python/multiprocessing:client -- [SERVER_ADDRESS]\n```\n\n----------------------------------------\n\nTITLE: Sharing a .proto File Between Projects Using MSBuild Link Attribute (XML, .NET)\nDESCRIPTION: Demonstrates referencing a .proto file located in a shared directory outside the project by adding a <Protobuf> entry with the Link attribute in the .csproj file. This facilitates usage of the same proto contract in multiple projects without copying the file, helping keep contracts in sync across services. The GrpcServices property can be set to restrict what types of code get generated (e.g., setting to 'None' suppresses both client and server stub generation).\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_5\n\nLANGUAGE: XML\nCODE:\n```\n<ItemGroup>\n   <Protobuf Include=\"..\\Protos\\greet.proto\" GrpcServices=\"None\" Link=\"Protos\\greet.proto\"/>\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Fetching Service and Method Descriptors via Reflection in Python Client\nDESCRIPTION: Shows how to use the reflection-backed `DescriptorPool` (`desc_pool`) to obtain service (`FindServiceByName`) and method (`FindMethodByName`) descriptors at runtime in a Python client. This allows the client to understand the structure of the remote service without needing pre-compiled proto files.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/server_reflection.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nservice_desc = desc_pool.FindServiceByName(\"helloworld.Greeter\")\nmethod_desc = service_desc.FindMethodByName(\"helloworld.Greeter.SayHello\")\n```\n\n----------------------------------------\n\nTITLE: Building Client and Server Executables with OpenTelemetry Integration\nDESCRIPTION: Creates executable targets for both client and server applications using a foreach loop. Links against Abseil libraries, OpenTelemetry metrics, Prometheus exporter, the gRPC OpenTelemetry plugin, and the previously defined utility library.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# Targets greeter_callback_(client|server)\nforeach(_target\n  greeter_callback_client greeter_callback_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    opentelemetry-cpp::metrics\n    opentelemetry-cpp::prometheus_exporter\n    gRPC::grpcpp_otel_plugin\n    util)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Debugging gRPC Client Errors with GDB (Bash)\nDESCRIPTION: Demonstrates building a specific gRPC client example using Bazel with debugging symbols and then running it under the GDB debugger. The `-ex run` flag immediately starts the program, allowing GDB to catch exceptions for inspection.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/debugging/README.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nbazel build --config=dbg examples/cpp/debugging:crashing_greeter_client\ngdb -ex run \\\n    --args ./bazel-bin/examples/cpp/debugging/crashing_greeter_client \\\n            --crash_on_errors=true \\\n            --target=localhork:50051\n```\n\n----------------------------------------\n\nTITLE: Displaying Correct UTF-8 Greek Text\nDESCRIPTION: Demonstrates a correctly encoded multi-byte UTF-8 sequence for the Greek word 'kosme'. This serves as a basic check for correct decoding of valid UTF-8.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/utf8_corpus_dir/utf8_corpus_kuhn.txt#_snippet_0\n\nLANGUAGE: UTF-8\nCODE:\n```\n\"Îºá½¹ÏƒÎ¼Îµ\"\n```\n\n----------------------------------------\n\nTITLE: Adding and Linking Greeter Callback Client and Server Executables in CMake\nDESCRIPTION: This CMake snippet uses a foreach loop to define two executable targets: 'greeter_callback_client' and 'greeter_callback_server'. Each target is built from its own .cc file and linked against absl libraries (flags, log), OpenTelemetry, custom exporters, the gRPC OpenTelemetry plugin, utility library, and protobuf dependencies. It leverages all prior configuration, requiring all dependencies to be installed and available to CMake. Inputs: client/server source files, linked libraries. Output: Built binaries for both example client and server demonstrating distributed tracing.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/ostream/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(_target\n  greeter_callback_client greeter_callback_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    opentelemetry-cpp::metrics\n    opentelemetry-cpp::ostream_metrics_exporter\n    opentelemetry-cpp::ostream_span_exporter\n    opentelemetry-cpp::trace\n    gRPC::grpcpp_otel_plugin\n    util\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Building gRPC C++ with CMake and Ninja on Windows - Batch\nDESCRIPTION: Configures gRPC C++ build using CMake with the Ninja generator (`-GNinja`) for potentially faster builds on Windows. Requires setting up the Visual C++ environment (`vcvarsall.bat`) and specifies Release configuration and C++17 standard. Use `-DBUILD_SHARED_LIBS=ON` during the first `cmake` step to build DLLs (not recommended).\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_14\n\nLANGUAGE: batch\nCODE:\n```\n> @rem Run from grpc directory after cloning the repo with --recursive or updating submodules.\n> cd cmake\n> md build\n> cd build\n> call \"%VS140COMNTOOLS%..\\..\\VC\\vcvarsall.bat\" x64\n> cmake -GNinja -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_STANDARD=17 ..\\..\n> cmake --build .\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to Objective-C Examples (Bazel)\nDESCRIPTION: Changes the current working directory to the parent directory of the Objective-C examples within the cloned gRPC repository. This is the location where Bazel build commands for the examples are typically run.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n$ cd grpc/examples/objective-c\n```\n\n----------------------------------------\n\nTITLE: Client-Side Call classes in AsyncIO Python API\nDESCRIPTION: This snippet covers various client-side call classes such as Call, UnaryUnaryCall, UnaryStreamCall, StreamUnaryCall, and StreamStreamCall. These classes represent different RPC call patterns, managing request/response flow asynchronously.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: Call\n.. autoclass:: UnaryUnaryCall\n.. autoclass:: UnaryStreamCall\n.. autoclass:: StreamUnaryCall\n.. autoclass:: StreamStreamCall\n```\n\n----------------------------------------\n\nTITLE: Running All Bazel Tests for gRPC Python - Bazel CLI - Bash\nDESCRIPTION: This command runs all Bazel tests associated with the gRPC Python source tree using standalone strategies for both spawning and genrule actions. No additional dependencies are required beyond a properly installed and configured Bazel environment with all gRPC prerequisites. The command targets all tests under the src/python directory and outputs the build and test results through standard output and error streams. Key parameters are --spawn_strategy and --genrule_strategy, both set to 'standalone', ensuring that actions are executed locally. Input: none. Output: test results summary on the CLI.\nSOURCE: https://github.com/grpc/grpc/blob/master/summerofcode/2018/naresh.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbazel test --spawn_strategy=standalone --genrule_strategy=standalone //src/python/...\n```\n\n----------------------------------------\n\nTITLE: Generating Protobuf and gRPC Sources Using CMake for C++\nDESCRIPTION: Defines custom commands to generate C++ protobuf and gRPC source and header files from .proto definitions using protoc and the gRPC plugin. It specifies output files for each proto, sets include directories, and defines dependencies on corresponding proto source files. This enables automatic regeneration of source code when proto files change.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/error_details/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\nget_filename_component(status_proto \"../../../third_party/googleapis/google/rpc/status.proto\" ABSOLUTE)\nget_filename_component(status_proto_path \"${status_proto}\" PATH)\nget_filename_component(error_details_proto \"../../../third_party/googleapis/google/rpc/error_details.proto\" ABSOLUTE)\nget_filename_component(error_details_proto_path \"${error_details_proto}\" PATH)\nget_filename_component(protobuf_proto_path \"../../../third_party/protobuf/src\" ABSOLUTE)\n\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n\nset(status_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/status.pb.cc\")\nset(status_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/status.pb.h\")\nadd_custom_command(\n      OUTPUT \"${status_proto_srcs}\" \"${status_proto_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS \n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${status_proto_path}\"\n        -I \"${protobuf_proto_path}\"\n        \"${status_proto}\"\n      DEPENDS \"${status_proto}\")\n\nset(error_details_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/error_details.pb.cc\")\nset(error_details_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/error_details.pb.h\")\nadd_custom_command(\n      OUTPUT \"${error_details_proto_srcs}\" \"${error_details_proto_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS \n          --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n          -I \"${error_details_proto_path}\"\n          -I \"${protobuf_proto_path}\"\n          \"${error_details_proto}\"\n      DEPENDS \"${error_details_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC C++ KeyValueStore Server (Bazel)\nDESCRIPTION: Command to build and run the gRPC C++ key-value store server example using Bazel. This starts the server-side component which includes a simple logging interceptor.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/interceptors/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ tools/bazel run examples/cpp/interceptors:keyvaluestore_server\n```\n\n----------------------------------------\n\nTITLE: Testing First Possible UTF-8 Sequences (1-6 Bytes)\nDESCRIPTION: Tests the decoder's handling of the lowest possible Unicode code point representable by 1 to 6 UTF-8 bytes (U+0000, U+0080, U+0800, U+10000, U+200000, U+4000000). These test boundary conditions for different sequence lengths. Note that 5 and 6-byte sequences are outside the range defined by RFC 3629.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/utf8_corpus_dir/utf8_corpus_kuhn.txt#_snippet_1\n\nLANGUAGE: UTF-8\nCODE:\n```\n2.1.1  1 byte  (U-00000000):        \" \"\n2.1.2  2 bytes (U-00000080):        \"Â€\"                                       |\n2.1.3  3 bytes (U-00000800):        \"à €\"                                       |\n2.1.4  4 bytes (U-00010000):        \"ð €€\"                                       |\n2.1.5  5 bytes (U-00200000):        \"øˆ€€€\"                                       |\n2.1.6  6 bytes (U-04000000):        \"ü„€€€€\"                                       |\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version\nDESCRIPTION: This snippet specifies the minimum required CMake version for the project. It ensures compatibility with features and functionalities used in the build process. This is a prerequisite for correct interpretation of the CMake instructions.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Enabling gRPC Python Client Forking (Shell)\nDESCRIPTION: This snippet demonstrates how to enable client-side forking support for gRPC Python applications by setting two required environment variables. This feature is currently limited to the \"epoll1\" and \"poll\" polling strategies. These variables must be exported in the shell environment before running the gRPC application.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/fork_support.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nexport GRPC_ENABLE_FORK_SUPPORT=true\nexport GRPC_POLL_STRATEGY=poll\n```\n\n----------------------------------------\n\nTITLE: Building and Pushing Multi-Architecture Docker Images with QEMU Support (Bash)\nDESCRIPTION: This snippet installs support for multiple CPU architectures on Linux, configures QEMU and binfmt interpreters, and runs a custom script to rebuild and push modified Docker images to the artifact registry. It relies on apt and Docker being installed, as well as network access to fetch the QEMU Docker image. Key commands include installing qemu-user-static and binfmt-support, running a privileged QEMU setup container, and executing push_testing_images.sh. The process is used when image changes need to be propagated to centralized storage for CI use.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/dockerfile/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install binfmt-support qemu-user-static\n\ndocker run --rm --privileged multiarch/qemu-user-static --reset -p yes\n\ntools/dockerfile/push_testing_images.sh\n```\n\n----------------------------------------\n\nTITLE: Linking and Building Interop Shared Library for gRPC Testing (CMake)\nDESCRIPTION: This snippet bundles test and support code, including generated proto libraries and several C++ test components, into the 'grpc-interop' shared object. It finds required Android system libraries and links all proto-based and interop libraries, ensuring all gRPC and protobuf dependencies are met. The compiled shared library is intended for running gRPC interop tests on Android platforms.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/android/test/interop/app/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nfind_library(log-lib\n log)\n\nadd_library(grpc-interop\n  SHARED\n  src/main/cpp/grpc-interop.cc\n  ${GRPC_SRC_DIR}/test/cpp/interop/backend_metrics_lb_policy.h\n  ${GRPC_SRC_DIR}/test/cpp/interop/backend_metrics_lb_policy.cc\n  ${GRPC_SRC_DIR}/test/cpp/interop/interop_client.h\n  ${GRPC_SRC_DIR}/test/cpp/interop/interop_client.cc\n  ${GRPC_SRC_DIR}/test/core/test_util/histogram.h\n  ${GRPC_SRC_DIR}/test/core/test_util/histogram.cc\n  ${GRPC_SRC_DIR}/test/core/test_util/test_lb_policies.h\n  ${GRPC_SRC_DIR}/test/core/test_util/test_lb_policies.cc)\n\ntarget_link_libraries(grpc-interop\n  messages_proto_lib\n  empty_proto_lib\n  test_proto_lib\n  android\n  ${log-lib})\n```\n\n----------------------------------------\n\nTITLE: Logging Call Status in C++ gRPC\nDESCRIPTION: Includes functions to log call status with grpc_status_code and details, for both client and server contexts. These functions are vital for tracing call completion and error handling in gRPC logs.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/binary-logging.md#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n// The context provides the metadata contents\n// direction = CLIENT_RECV\nLogStatus(ClientContext context, grpc_status_code code, string details);\n\n// direction = SERVER_SEND\nLogStatus(ServerContext context, grpc_status_code code, string details);\n```\n\n----------------------------------------\n\nTITLE: Implementing Sample gRPC C++ Client Logic\nDESCRIPTION: Presents a simple C++ `FakeClient` class designed to use a `EchoTestService::StubInterface`. It contains methods `DoEcho` (for unary RPC) and `DoBidiStream` (for bidirectional streaming), which call the corresponding methods on the provided stub, simulating typical client-side interactions.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/unit_testing.md#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nclass FakeClient {\n public:\n  explicit FakeClient(EchoTestService::StubInterface* stub) : stub_(stub) {}\n\n  void DoEcho() {\n    ClientContext context;\n    EchoRequest request;\n    EchoResponse response;\n    request.set_message(\"hello world\");\n    Status s = stub_->Echo(&context, request, &response);\n    EXPECT_EQ(request.message(), response.message());\n    EXPECT_TRUE(s.ok());\n  }\n\n  void DoBidiStream() {\n    EchoRequest request;\n    EchoResponse response;\n    ClientContext context;\n    std::string msg(\"hello\");\n\n    std::unique_ptr<ClientReaderWriterInterface<EchoRequest, EchoResponse>>\n        stream = stub_->BidiStream(&context);\n\n    request.set_message(msg + \"0\");\n    EXPECT_TRUE(stream->Write(request));\n    EXPECT_TRUE(stream->Read(&response));\n    EXPECT_EQ(response.message(), request.message());\n\n    request.set_message(msg + \"1\");\n    EXPECT_TRUE(stream->Write(request));\n    EXPECT_TRUE(stream->Read(&response));\n    EXPECT_EQ(response.message(), request.message());\n\n    request.set_message(msg + \"2\");\n    EXPECT_TRUE(stream->Write(request));\n    EXPECT_TRUE(stream->Read(&response));\n    EXPECT_EQ(response.message(), request.message());\n\n    stream->WritesDone();\n    EXPECT_FALSE(stream->Read(&response));\n\n    Status s = stream->Finish();\n    EXPECT_TRUE(s.ok());\n  }\n\n  void ResetStub(EchoTestService::StubInterface* stub) { stub_ = stub; }\n\n private:\n  EchoTestService::StubInterface* stub_;\n};\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Reflection Server with Bazel\nDESCRIPTION: Command to build and run the reflection server example using Bazel. The server starts on the default port 50051 and must be executed from within the examples/cpp/reflection directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/reflection/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n$ bazel run :reflection_server\n```\n\n----------------------------------------\n\nTITLE: Building and Running Benchmark Workers for C-core Wrapped Languages - Bash\nDESCRIPTION: This snippet describes building and running gRPC benchmark worker processes for languages that use gRPC C-core (such as C++, Python, C#, Node, Ruby). The user must first run the build script, then execute the appropriate worker script for the target language. Each worker script is language-specific (e.g., 'run_worker_csharp.sh'). Assumes a POSIX shell environment and dependencies for each language are installed. The running worker is ready to connect to a benchmark driver for distributed performance testing.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ cd <grpc_repo_root>\n$ tools/run_tests/performance/build_performance.sh\n$ tools/run_tests/performance/run_worker_<language>.sh\n```\n\n----------------------------------------\n\nTITLE: Generating Memory Profile for gRPC-Go Server With pprof (Shell)\nDESCRIPTION: Collects and displays a memory allocation profile for the gRPC-Go server using the 'go tool pprof' command after a benchmark run. Requires the Go toolchain and appropriate pprof endpoints exposed by the server. Replace <pprof_port> with the port where the pprof debugging endpoint is available. The output is presented in text format, summarizing memory allocations for further analysis.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\ngo tool pprof --text --alloc_space http://localhost:<pprof_port>/debug/heap\n```\n\n----------------------------------------\n\nTITLE: Install gRPC Dependency with pip\nDESCRIPTION: Install the official gRPC library for Python using the pip package installer. This command downloads and installs the necessary grpcio package and its dependencies into the Python environment.\nSOURCE: https://github.com/grpc/grpc/blob/master/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\npip install grpcio\n```\n\n----------------------------------------\n\nTITLE: Adding Source Directory | gdb | gdb\nDESCRIPTION: Demonstrates using the `gdb` `dir` command to add the base directory of the unpacked source `grpc` gem to the debugger's source file search path. This allows `gdb` to find source files located within that directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/nativedebug/README.md#_snippet_7\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) dir /home/grpc-1.60.1\nSource directories searched: /home/grpc-1.60.1:$cdir:$cwd\n(gdb)\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC server\nDESCRIPTION: This command executes the `greeter_server` application. The server listens for incoming gRPC requests on port 50051.  No specific dependencies are required besides a compiled `greeter_server` executable.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/error_handling/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ ./greeter_server\n```\n\n----------------------------------------\n\nTITLE: Running the Route Guide Client with Bazel\nDESCRIPTION: Command to build and run the gRPC RouteGuide callback client example using Bazel build system.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/route_guide/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ntools/bazel run examples/cpp/route_guide:route_guide_callback_client\n```\n\n----------------------------------------\n\nTITLE: Cleaning and Building the gRPC Project with Make - Shell\nDESCRIPTION: This shell snippet provides commands to force-clean the source tree, initialize submodules, install build dependencies on Ubuntu systems, and build gRPC using make from the repository root. These steps are often necessary if the build fails due to missing prerequisites like 'aclocal', or if the environment requires a clean rebuild. Commands require permissions to run 'sudo' for installing packages and assume the user is running on a Debian-based system. Inputs: None; Outputs: Cleaned repo and compiled gRPC binaries.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_17\n\nLANGUAGE: sh\nCODE:\n```\n$ git clean -f -d -x && git submodule foreach --recursive git clean -f -d -x\n$ [sudo] apt-get install build-essential autoconf libtool pkg-config\n$ make\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Deadline Example Client\nDESCRIPTION: Command to run the client component of the gRPC deadline example. The client sends requests to test both successful calls and timeout conditions.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/deadline/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n./client\n```\n\n----------------------------------------\n\nTITLE: Building UTF8 Range Library with ExternalProject\nDESCRIPTION: Configures the build for the UTF8 Range library with a dependency on Abseil. Sets cache arguments for position-independent code, install path, and dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/cmake_externalproject/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nExternalProject_Add(utf8_range\n  PREFIX utf8_range\n  SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../../../../third_party/utf8_range\"\n  CMAKE_CACHE_ARGS\n        -DCMAKE_POSITION_INDEPENDENT_CODE:BOOL=TRUE\n        -DCMAKE_INSTALL_PREFIX:PATH=${CMAKE_CURRENT_BINARY_DIR}/utf8_range\n        -DCMAKE_CXX_STANDARD:STRING=17\n        -Dutf8_range_ENABLE_TESTS:BOOL=OFF\n        -Dprotobuf_VERSION:STRING=0.0.1\n        -Dabsl_DIR:STRING=${CMAKE_CURRENT_BINARY_DIR}/absl/lib/cmake/absl\n  DEPENDS absl\n)\n```\n\n----------------------------------------\n\nTITLE: Installing gRPC Python Observability via PyPI using Shell\nDESCRIPTION: Installs the `grpcio-observability` package from the Python Package Index (PyPI) using the pip package installer. This is the standard installation method for Python packages and requires pip to be available in the environment. Note that this package is currently only available for Linux.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/grpcio_observability/README.rst#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npip install grpcio-observability\n```\n\n----------------------------------------\n\nTITLE: Conditional Offloading of Combiner Work\nDESCRIPTION: This snippet demonstrates how to avoid long tail latencies by offloading combiner work to another thread if certain conditions are met. If `control_can_be_returned` is true and `some_still_queued_thing_is_covered_by_poller`, the combiner offloads work to another thread using `offload_combiner_work_to_some_other_thread()`.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/core/combiner-explainer.md#_snippet_4\n\nLANGUAGE: \nCODE:\n```\nwhile (q.pop(&f)) {\n  f();\n  if (control_can_be_returned && some_still_queued_thing_is_covered_by_poller) {\n    offload_combiner_work_to_some_other_thread();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC LoadBalancerStatsService\nDESCRIPTION: This snippet defines the gRPC service `LoadBalancerStatsService`, which is used by the test driver to validate the load balancing behavior of the test client. It includes the request and response messages for retrieving the client's statistics, like `LoadBalancerStatsRequest`, `LoadBalancerStatsResponse`, `LoadBalancerAccumulatedStatsRequest`, and `LoadBalancerAccumulatedStatsResponse`, allowing the test driver to inspect the distribution of RPCs across different backends.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/xds-test-descriptions.md#_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nmessage LoadBalancerStatsRequest {\n  // Request stats for the next num_rpcs sent by client.\n  int32 num_rpcs = 1;\n  // If num_rpcs have not completed within timeout_sec, return partial results.\n  int32 timeout_sec = 2;\n}\n\nmessage LoadBalancerStatsResponse {\n  message RpcsByPeer {\n    // The number of completed RPCs for each peer.\n    map<string, int32> rpcs_by_peer = 1;\n  }\n  // The number of completed RPCs for each peer.\n  map<string, int32> rpcs_by_peer = 1;\n  // The number of RPCs that failed to record a remote peer.\n  int32 num_failures = 2;\n  map<string, RpcsByPeer> rpcs_by_method = 3;\n}\n\nmessage LoadBalancerAccumulatedStatsRequest {}\n\nmessage LoadBalancerAccumulatedStatsResponse {\n  // The total number of RPCs have ever issued for each type.\n  // Deprecated: use stats_per_method.rpcs_started instead.\n  map<string, int32> num_rpcs_started_by_method = 1 [deprecated = true];\n  // The total number of RPCs have ever completed successfully for each type.\n  // Deprecated: use stats_per_method.result instead.\n  map<string, int32> num_rpcs_succeeded_by_method = 2 [deprecated = true];\n  // The total number of RPCs have ever failed for each type.\n  // Deprecated: use stats_per_method.result instead.\n  map<string, int32> num_rpcs_failed_by_method = 3 [deprecated = true];\n\n  message MethodStats {\n    // The number of RPCs that were started for this method.\n    int32 rpcs_started = 1;\n\n    // The number of RPCs that completed with each status for this method.  The\n    // key is the integral value of a google.rpc.Code; the value is the count.\n    map<int32, int32> result = 2;\n  }\n\n  // Per-method RPC statistics.  The key is the RpcType in string form; e.g.\n  // 'EMPTY_CALL' or 'UNARY_CALL'\n  map<string, MethodStats> stats_per_method = 4;\n}\n\nservice LoadBalancerStatsService {\n  // Gets the backend distribution for RPCs sent by a test client.\n  rpc GetClientStats(LoadBalancerStatsRequest)\n      returns (LoadBalancerStatsResponse) {}\n  // Gets the accumulated stats for RPCs sent by a test client.\n  rpc GetClientAccumulatedStats(LoadBalancerAccumulatedStatsRequest)\n      returns (LoadBalancerAccumulatedStatsResponse) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Channel and Call Credentials in gRPC Python\nDESCRIPTION: Illustrates how to combine ChannelCredentials (e.g., SSL credentials) and CallCredentials into a single composite credential. This allows for both channel-level and call-level authentication.  The grpc.composite_channel_credentials function is used to create the composite credential, which is then used to create a secure channel.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/auth/README.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nchannel_credentials = ...\ncall_credentials = ...\ncomposite_credentials = grpc.composite_channel_credentials(\n    channel_credential,\n    call_credentials)\nchannel = grpc.secure_channel(server_address, composite_credentials)\n```\n\n----------------------------------------\n\nTITLE: Testing Last Possible UTF-8 Sequences (1-6 Bytes)\nDESCRIPTION: Tests the decoder's handling of the highest possible Unicode code point representable by 1 to 6 UTF-8 bytes (U+007F, U+07FF, U+FFFF, U+1FFFFF, U+3FFFFFF, U+7FFFFFFF). These test upper boundary conditions. Note: Sequences resulting in codepoints above U+10FFFF (covered by 4, 5, and 6-byte examples here) are invalid according to modern Unicode standards (RFC 3629).\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/utf8_corpus_dir/utf8_corpus_kuhn.txt#_snippet_2\n\nLANGUAGE: UTF-8\nCODE:\n```\n2.2.1  1 byte  (U-0000007F):        \" \"\n2.2.2  2 bytes (U-000007FF):        \"ß¿\"                                       |\n2.2.3  3 bytes (U-0000FFFF):        \"ï¿¿\"                                       |\n2.2.4  4 bytes (U-001FFFFF):        \"÷¿¿¿\"                                       |\n2.2.5  5 bytes (U-03FFFFFF):        \"û¿¿¿¿\"                                       |\n2.2.6  6 bytes (U-7FFFFFFF):        \"ý¿¿¿¿¿\"                                       |\n```\n\n----------------------------------------\n\nTITLE: Including C++ Guards in Header Files with C\nDESCRIPTION: This code pattern shows how to make a C header file compatible with both C and C++ by wrapping its contents with extern \\\"C\\\" when compiled as C++. The snippet is intended to be placed at the top and bottom of public header files to allow them to be included from C++ code. The pattern depends on checking the __cplusplus macro and requires the header file to be self-contained and protected by an include guard. Inputs: none; Outputs: allows proper name mangling for C linkage. All header files intended for public use must include this pattern.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/c-style-guide.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#ifdef __cplusplus\nextern \"C\" {\n# endif\n\n/* ... body of file ... */\n\n#ifdef __cplusplus\n}\n# endif\n```\n\n----------------------------------------\n\nTITLE: Building gRPC Python CSM Client with Docker - Shell\nDESCRIPTION: This snippet demonstrates how to build a Docker image for the gRPC Python CSM Hello World client using a specific Dockerfile. It requires Docker to be installed and must be executed from the gRPC workspace directory. The Docker image is tagged for a remote registry and is built based on Dockerfile.client, containing all necessary client code and dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/observability/csm/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndocker build -f examples/python/observability/csm/Dockerfile.client -t \"us-docker.pkg.dev/grpc-testing/examples/csm-o11y-example-python-client\" .\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Services and Messages\nDESCRIPTION: This code snippet defines the messages and services used for the xDS client configuration. It includes the `ClientConfigureRequest`, `ClientConfigureResponse`, and the `XdsUpdateClientConfigureService` service, which is used to dynamically update the client's configuration during the test. It enables control over RPC types, metadata, and deadlines, allowing for flexible testing of client behavior.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/xds-test-descriptions.md#_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nmessage ClientConfigureRequest {\n  // Type of RPCs to send.\n  enum RpcType {\n    EMPTY_CALL = 0;\n    UNARY_CALL = 1;\n  }\n\n  // Metadata to be attached for the given type of RPCs.\n  message Metadata {\n    RpcType type = 1;\n    string key = 2;\n    string value = 3;\n  }\n\n  // The types of RPCs the client sends.\n  repeated RpcType types = 1;\n  // The collection of custom metadata to be attached to RPCs sent by the client.\n  repeated Metadata metadata = 2;\n  // The deadline to use, in seconds, for all RPCs.  If unset or zero, the\n  // client will use the default from the command-line.\n  int32 timeout_sec = 3;\n}\n\nmessage ClientConfigureResponse {}\n\nservice XdsUpdateClientConfigureService {\n  // Update the tes client's configuration.\n  rpc Configure(ClientConfigureRequest) returns (ClientConfigureResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running Benchmark Worker for gRPC-Java - Bash\nDESCRIPTION: This command sequence details the process for building and running the gRPC-Java benchmark worker. The commands must be run inside the grpc-java repository and require Gradle with certain flags for skipping codegen and Android dependencies. The produced binary is executed with the appropriate driver port parameter. Useful for distributed testing in environments specific to Java.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ cd <grpc-java-repo>\n$ ./gradlew -PskipCodegen=true -PskipAndroid=true :grpc-benchmarks:installDist\n$ benchmarks/build/install/grpc-benchmarks/bin/benchmark_worker --driver_port <driver_port>\n```\n\n----------------------------------------\n\nTITLE: Adding gRPC and Protobuf Libraries as a Single Target\nDESCRIPTION: Creates a library target 'hw_grpc_proto' that includes generated gRPC and protobuf source and header files, and links necessary gRPC and protobuf libraries and reflection support.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/deadline/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Building and Running the grpc-src Docker Image\nDESCRIPTION: Commands to build and run the grpc-src Docker image, which builds a 'thin' gRPC PECL extension with dynamic linking to the gRPC C Core library, allowing additional configure options.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ cd grpc\n$ docker build -t grpc-php/grpc-src -f ./src/php/docker/grpc-src/Dockerfile .\n$ docker run -it --rm grpc-php/grpc-src\n```\n\n----------------------------------------\n\nTITLE: Implementing GRPC Connection Backoff Algorithm\nDESCRIPTION: This pseudocode outlines the core connection backoff algorithm. It starts with an initial backoff and deadline, then repeatedly attempts to connect. If the connection fails, it sleeps until the deadline and recalculates the backoff, applying a multiplier, jitter, and a maximum backoff limit. The algorithm continues until a successful connection is established. The algorithm utilizes parameters such as INITIAL_BACKOFF, MULTIPLIER, JITTER, MAX_BACKOFF, and MIN_CONNECT_TIMEOUT.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md#_snippet_0\n\nLANGUAGE: pseudocode\nCODE:\n```\nConnectWithBackoff()\n  current_backoff = INITIAL_BACKOFF\n  current_deadline = now() + INITIAL_BACKOFF\n  while (TryConnect(Max(current_deadline, now() + MIN_CONNECT_TIMEOUT))\n         != SUCCESS)\n    SleepUntil(current_deadline)\n    current_backoff = Min(current_backoff * MULTIPLIER, MAX_BACKOFF)\n    current_deadline = now() + current_backoff +\n      UniformRandom(-JITTER * current_backoff, JITTER * current_backoff)\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC client\nDESCRIPTION: This command executes the `greeter_client` application.  The client sends gRPC requests to the server running on port 50051. The `greeter_client` executable needs to be compiled before execution.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/error_handling/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ ./greeter_client\n```\n\n----------------------------------------\n\nTITLE: Setting Default Compression Algorithm in gRPC C++ Server\nDESCRIPTION: Configures the default compression algorithm (GZIP) for all responses sent by the gRPC server using the ServerBuilder. This setting applies unless overridden per call within the service handler.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/compression/README.md#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n  ServerBuilder builder;\n  // Set the default compression algorithm for the server.\n  builder.SetDefaultCompressionAlgorithm(GRPC_COMPRESS_GZIP);\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Policy CMP0077\nDESCRIPTION: Conditionally sets CMake policy CMP0077 to 'NEW' if it exists. This policy governs how the `option()` command handles variables, ensuring modern behavior where variables are honored. This helps maintain consistent behavior across different CMake versions.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif (POLICY CMP0077)\n  cmake_policy(SET CMP0077 NEW)\nendif (POLICY CMP0077)\n```\n\n----------------------------------------\n\nTITLE: Building grpc_php_plugin with cmake - Shell Script\nDESCRIPTION: Illustrates building grpc_php_plugin (the plugin for protoc that generates PHP client stubs) using cmake and make. This procedure ensures both protoc and the plugin are available for later .proto file compilation. Requires cmake, make, and C++ build tools installed.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\n$ git clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc\n$ cd grpc\n$ git submodule update --init\n$ mkdir -p cmake/build\n$ cd cmake/build\n$ cmake ../..\n$ make protoc grpc_php_plugin\n```\n\n----------------------------------------\n\nTITLE: Including Common CMake Configurations\nDESCRIPTION: Includes an external common CMake script, likely defining shared variables, functions, or settings used across multiple CMakeLists. It helps maintain consistent build configurations.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/deadline/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to gRPC Load Balancing Example\nDESCRIPTION: Changes the current working directory in the shell to the examples/cpp/load_balancing folder inside the cloned gRPC repository. This is required to build and run the specific load balancing tutorial example. The command assumes the repository was cloned in the current directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/load_balancing/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ cd examples/cpp/load_balancing/\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectory Source Directory | gdb | gdb\nDESCRIPTION: Demonstrates adding a specific subdirectory within the unpacked source gem to `gdb`'s source search path using the `dir` command. This is necessary for locating source files that are not in the top-level source directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/nativedebug/README.md#_snippet_9\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) dir /home/grpc-1.60.1/src/ruby/ext/grpc\nSource directories searched: /home/grpc-1.60.1/src/ruby/ext/grpc:/home/grpc-1.60.1:$cdir:$cwd\n```\n\n----------------------------------------\n\nTITLE: Running gRPC C++ Observability Client with Config File (Shell)\nDESCRIPTION: This snippet demonstrates how to set the `GRPC_GCP_OBSERVABILITY_CONFIG_FILE` environment variable for the client configuration file and then execute the observability-enabled gRPC C++ greeter client using bazel. The client will attempt to connect to the server and perform RPCs, with observability data recorded based on its configuration.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/gcp_observability/helloworld/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ export\n    GRPC_GCP_OBSERVABILITY_CONFIG_FILE=\"$(pwd)/examples/cpp/gcp_observability/helloworld/client_config.json\"\n$ tools/bazel run examples/cpp/gcp_observability/helloworld:greeter_client\n```\n\n----------------------------------------\n\nTITLE: Installing Specific Version of Protobuf Extension from PECL - Shell Script\nDESCRIPTION: Demonstrates installing a specific version of the protobuf PHP extension from PECL. Useful for compatibility matching with existing gRPC and protobuf tooling.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\n$ [sudo] pecl install protobuf-3.12.2\n```\n\n----------------------------------------\n\nTITLE: Enabling Protobuf Extension in php.ini - Shell Script\nDESCRIPTION: Instructs to add the 'extension=protobuf.so' line to php.ini, registering the protobuf extension so that PHP can handle protocol buffer messages natively. Ensuring proper placement and file permissions is crucial.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\nextension=protobuf.so\n```\n\n----------------------------------------\n\nTITLE: Updating xxhash Manually from Upstream via Shell Commands\nDESCRIPTION: This snippet contains a sequence of shell commands for updating the xxhash library by pulling only relevant files. The method involves adding the upstream as a git remote, fetching content, and selectively exporting header and license files using git show and text processing. Dependencies: git, sed. Inputs: remote repository URL, branches; Outputs: header and license files in place. The approach avoids unwanted upstream files and focuses only on files required for gRPC.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngit remote add xxhash https://github.com/Cyan4973/xxHash.git\ngit fetch xxhash\ngit show xxhash/dev:xxhash.h > third_party/xxhash/xxhash.h\ngit show xxhash/dev:LICENSE | sed -nE '/^-+$/q;p' > third_party/xxhash/LICENSE\n```\n\n----------------------------------------\n\nTITLE: Configuring .proto File Code Generation with Grpc.Tools in XML\nDESCRIPTION: This XML snippet demonstrates how to add a .proto file to a .csproj project to enable automatic C# code generation with the Grpc.Tools package. The ItemGroup element contains a Protobuf child element referencing the proto file's relative path. The project must reference the Grpc.Tools NuGet package to process this configuration. No additional parameters are required, and this snippet assumes the proto file exists at the specified location. The generated C# files are output as build artifacts, typically not checked into source control.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/Grpc.Tools/README.md#_snippet_0\n\nLANGUAGE: XML\nCODE:\n```\n<ItemGroup>\n    <Protobuf Include=\"Protos\\greet.proto\" />\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Install Android Application using Gradle\nDESCRIPTION: This command uses Gradle to build and install the debug version of the Android application. It's executed from the command line and assumes Gradle is configured correctly.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/android/test/interop/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ ./gradlew installDebug\n```\n\n----------------------------------------\n\nTITLE: Requiring grpc/grpc Composer Package - JSON\nDESCRIPTION: Defines the composer.json snippet required to install the 'grpc/grpc' package, necessary for PHP-side use of gRPC service stubs and runtime tooling. Used by Composer, the PHP package manager, to resolve dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"require\": {\n        \"grpc/grpc\": \"~1.30.0\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Usage of ProtoBuf Any\nDESCRIPTION: This code demonstrates how to use the `Any` type in Protocol Buffers to pack and unpack messages. The `Pack` method serializes a message into the `Any` type, while the `Unpack` method deserializes it. The `Is` method checks if the `Any` type contains a specific message type. This allows for handling different types of error detail messages.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/errors/README.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nany_message.Pack(message)\nany_message.Unpack(message)\nassert any_message.Is(message.DESCRIPTOR)\n```\n\n----------------------------------------\n\nTITLE: Building Artifacts and Packages with Python\nDESCRIPTION: This script provides a generalized framework to run tasks based on their labels. It is used to build binary artifacts, distribute packages, and test them. The script takes labels as arguments to specify the tasks to run. Key parameters include a file to specify the task (-f) and labels for the task. The output will be the result of the specified tasks.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntools/run_tests/task_runner.py -f python artifact linux x64\n```\n\n----------------------------------------\n\nTITLE: Building Base Docker Image with gRPC PECL Extension\nDESCRIPTION: Builds a base Docker image tagged `grpc-php/base` using the instructions specified in `base.Dockerfile`. This image includes the necessary gRPC PECL extension required for PHP gRPC clients.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/php/echo/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ docker build -t grpc-php/base -f ./base.Dockerfile .\n```\n\n----------------------------------------\n\nTITLE: Installing gRPC Python using pip on Linux/macOS/Windows - Shell\nDESCRIPTION: Commands to install the gRPC Python package using pip, either locally or system-wide. Includes platform-specific recommendations such as using pip.exe on Windows and running the command line as administrator for Windows users. Users are advised to ensure they have an updated version of pip to correctly retrieve pre-built wheels from PyPI.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/grpcio/README.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ pip install grpcio\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo pip install grpcio\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ pip.exe install grpcio\n```\n\n----------------------------------------\n\nTITLE: Installing gRPC Ruby gem using the gem command\nDESCRIPTION: Simple shell command to install the gRPC Ruby gem directly from RubyGems.org using the gem command line tool.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngem install grpc\n```\n\n----------------------------------------\n\nTITLE: Cloning Repository and Running Node.js gRPC Server via Docker\nDESCRIPTION: Clones the `grpc-web` repository, changes into the directory, uses `docker-compose` to build prerequisite and Node.js server images, and then runs the Node.js server in a detached Docker container named `node-server`, mapping host port 9090 to the container's port 9090.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/php/echo/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ git clone https://github.com/grpc/grpc-web\n$ cd grpc-web\n$ docker-compose build prereqs node-server\n$ docker run -d -p 9090:9090 --name node-server grpcweb/node-server\n```\n\n----------------------------------------\n\nTITLE: Running Objective-C Helloworld with Bazel (Initial Attempt)\nDESCRIPTION: Runs the Bazel command to execute the `HelloWorld` target. If a default simulator isn't configured or available, this command might fail but will often provide information about available runtimes and devices in the error output, guiding the user on the correct command.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/README.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\n$ bazel run :HelloWorld\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Server with Bazel\nDESCRIPTION: This command is used to run the gRPC server example using Bazel. It builds and executes the `server` target defined in the `//examples/python/multiprocessing:server` Bazel package. The '&' symbol runs the server in the background.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/multiprocessing/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbazel run //examples/python/multiprocessing:server &\n```\n\n----------------------------------------\n\nTITLE: Cloning the gRPC Repository using Git (Shell)\nDESCRIPTION: Clones the specific release tag of the gRPC repository from GitHub. This step is necessary to obtain the example source code. Requires Git to be installed.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/compression/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ git clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc\n```\n\n----------------------------------------\n\nTITLE: Installing protobuf with PECL\nDESCRIPTION: This command installs the protobuf extension for PHP using PECL (PHP Extension Community Library).  The `sudo` command is used to grant necessary permissions for the installation process. It downloads and installs the protobuf extension, enabling PHP applications to work with protobuf data.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/upb/upb/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ sudo pecl install protobuf\n```\n\n----------------------------------------\n\nTITLE: Setting Proto File Paths for gRPC HelloWorld Example\nDESCRIPTION: Locates and defines paths for the HelloWorld and Health service proto files that will be used for code generation.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/health/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Proto file\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\nget_filename_component(health_proto \"../../../src/proto/grpc/health/v1/health.proto\" ABSOLUTE)\nget_filename_component(health_proto_path \"${health_proto}\" PATH)\n```\n\n----------------------------------------\n\nTITLE: Debugging Transport Protocol in gRPC Python\nDESCRIPTION: Environment variable configuration focused on debugging transport-related issues in gRPC applications. This traces TCP, HTTP, secure endpoints, and transport security components specifically.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/debug/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nGRPC_VERBOSITY=debug\nGRPC_TRACE=tcp,http,secure_endpoint,transport_security\n```\n\n----------------------------------------\n\nTITLE: Adding gRPC to a Gemfile with GitHub source\nDESCRIPTION: Example showing how to add the gRPC gem to a Gemfile when pulling from GitHub, with the important submodules parameter set to true to ensure proper installation.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/README.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ngem 'grpc', github: 'grpc/grpc', submodules: true\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Bazel Test\nDESCRIPTION: This Bazel command executes a specific unit test within the gRPC project. It uses the bazel test command to run the unit test identified by the specified target, which is the path to the test file. The \"--cache_test_results=no\" flag prevents the use of cached test results to ensure a fresh test run.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nbazel test --cache_test_results=no \"//src/python/grpcio_tests/tests/unit:_abort_test\"\n```\n\n----------------------------------------\n\nTITLE: Implementing gRPC Completion Queue Next/Pluck in C++\nDESCRIPTION: Illustrates the core logic of `grpc_completion_queue_next()` and `grpc_completion_queue_pluck()` APIs in C++. The functions loop indefinitely, first checking for queued events (specific tag for pluck), then checking for queue shutdown. For pluck, it registers the tag/worker pair. Finally, it calls `grpc_pollset_work` to perform polling, which might schedule closures and queue events on potentially different completion queues.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/core/grpc-cq.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ngrpc_completion_queue_next(cq, deadline)/pluck(cq, deadline, tag) {\n  while(true) {\n    \\\\ 1. If an event is queued in the completion queue, dequeue and return\n    \\\\    (in case of pluck() dequeue only if the tag is the one we are interested in)\n\n    \\\\ 2. If completion queue shutdown return\n\n    \\\\ 3. In case of pluck, add (tag, worker) pair to the tag<->worker map on the cq\n\n    \\\\ 4.  Call grpc_pollset_work(cq’s-pollset, deadline) to do polling\n    \\\\     Note that if this function found some fds to be readable/writable/error,\n    \\\\     it would have scheduled those closures (which may queue completion events\n    \\\\    on SOME completion queue - not necessarily this one)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Async gRPC Client to Unix Domain Socket Server in Python\nDESCRIPTION: Command for running the asynchronous greeter client that connects to the server via Unix Domain Sockets. Shows the client successfully receiving responses from both socket paths.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/uds/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 async_greeter_client.py\nINFO:root:Received: Hello to unix:helloworld.sock!\nINFO:root:Received: Hello to unix:///tmp/helloworld.sock!\n```\n\n----------------------------------------\n\nTITLE: CMake Minimum Version and Project Initialization for gRPC C++ Application\nDESCRIPTION: Sets the minimum required CMake version to 3.16 and initializes a project named 'Deadline' with C and C++ language support, establishing the basic build configuration environment for the gRPC application.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/deadline/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(Deadline C CXX)\n```\n\n----------------------------------------\n\nTITLE: Cloning gRPC Repo (Fork)\nDESCRIPTION: This snippet demonstrates cloning a forked gRPC repository using the git clone command. It retrieves a copy of the repository from a specified GitHub URL, allowing the user to work with the project's source code locally. The URL should be updated with the user's GitHub username.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/<your-username>/grpc.git\n```\n\n----------------------------------------\n\nTITLE: Adding Client and Server Executables\nDESCRIPTION: Uses a `foreach` loop to define executable targets for both the `multiplex_client` and `multiplex_server`. It adds each executable from its respective `.cc` source file.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/multiplex/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(_target multiplex_client multiplex_server)\n  add_executable(${_target} \"${_target}.cc\")\n  # target_link_libraries for executables follows in the next snippet\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Initializing git submodules when building from source\nDESCRIPTION: Shell command to initialize and update all git submodules required for building gRPC Ruby from source.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ngit submodule update --init\n```\n\n----------------------------------------\n\nTITLE: Required Python Dependencies for gRPC Observability\nDESCRIPTION: Lists the essential Python packages required for `grpcio-observability` to function correctly. These are `grpcio` (the core gRPC library for Python) and `opentelemetry-api` (the OpenTelemetry API library for telemetry data). These dependencies are typically installed automatically when using pip.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/grpcio_observability/README.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\ngrpcio\nopentelemetry-api\n```\n\n----------------------------------------\n\nTITLE: Generating Objective-C and gRPC Client Files with Protoc Using Shell Command Syntax\nDESCRIPTION: The prepare_command section in the Podspec runs a shell multipart command to generate Objective-C message and gRPC service files from proto definitions. It creates the output directory, invokes the protoc compiler with the gRPC plugin, sets multiple include directories, and processes all .proto files in the base directory. This setup enables automated regeneration of Objective-C bindings for the proto service definitions using the installed protoc and plugin binaries.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/objective-c/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nmkdir -p #{dir}\n#{protoc} \\\n    --plugin=protoc-gen-grpc=#{plugin} \\\n    --objc_out=#{dir} \\\n    --grpc_out=#{dir} \\\n    -I #{src} \\\n    -I #{protoc_dir} \\\n    #{src}/*.proto\n```\n\n----------------------------------------\n\nTITLE: Configuring UnaryCall Request with Payload (gRPC Interop Test, JSON Payload)\nDESCRIPTION: This snippet defines the request payload for the `UnaryCall` in the Custom Metadata test. It specifies a desired `response_size` and includes a large dummy `payload` body.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"response_size\": 314159,\n  \"payload\":{\n    \"body\": \"271828 bytes of zeros\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Expected Client Output (Text)\nDESCRIPTION: Illustrates the expected console output from the `greeter_client` after successfully executing. It shows two 'SayHello' requests being sent and the corresponding successful responses received from the server.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/generic_api/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n### Send: SayHello(name=World)\nOk. ReplyMessage=Hello World\n### Send: SayHello(name=gRPC)\nOk. ReplyMessage=Hello gRPC\n```\n\n----------------------------------------\n\nTITLE: Installing Python Modules\nDESCRIPTION: This script installs Python modules required for tooling and testing. It is a helper script to install Python modules, likely needed by testing scripts and other development tools within the gRPC project. Its usage requires the script to be executed from the root directory of the gRPC project.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./tools/distrib/install_all_python_modules.sh\n```\n\n----------------------------------------\n\nTITLE: Generating C++ Source Files from Health Service Proto Definition\nDESCRIPTION: Defines the generated source file paths and adds a custom command to compile the Health service proto file into C++ code using protoc with gRPC plugin.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/health/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Health protos\nset(health_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/health.pb.cc\")\nset(health_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/health.pb.h\")\nset(health_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/health.grpc.pb.cc\")\nset(health_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/health.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${health_proto_srcs}\" \"${health_proto_hdrs}\" \"${health_grpc_srcs}\" \"${health_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${health_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${health_proto}\"\n      DEPENDS \"${health_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Installing grpcio-tools from Source - bash\nDESCRIPTION: Provides a sequence of shell commands to clone the gRPC repository, initialize submodules, build the `grpcio_tools` package, and install it locally using pip with Cython support. Requires Python headers, Cython, and a GCC-like compiler.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/distrib/python/grpcio_tools/README.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nexport REPO_ROOT=grpc\ngit clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc $REPO_ROOT\ncd $REPO_ROOT\ngit submodule update --init\n\ncd tools/distrib/python/grpcio_tools\npython ../make_grpcio_tools.py\n\nGRPC_PYTHON_BUILD_WITH_CYTHON=1 pip install .\n```\n\n----------------------------------------\n\nTITLE: Configuring DSCP in Java gRPC client\nDESCRIPTION: This code snippet demonstrates how to set the DSCP value in a Java gRPC client using 'ManagedChannelBuilder' with channel arguments. The 'grpc.dscp' key is assigned an integer between 0 and 63 to prioritize traffic. It is intended for use on POSIX-compatible systems that support setting DSCP values via gRPC configuration.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/qos-dscp.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\nManagedChannel channel = ManagedChannelBuilder.forTarget(\"localhost:50051\")\n    .withOption(\"grpc.dscp\", 46) // Set DSCP to EF\n    .usePlaintext()\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Installing Build Prerequisites on Linux (apt) - Shell\nDESCRIPTION: Installs essential packages (`build-essential`, `autoconf`, `libtool`, `pkg-config`) required for building gRPC C++ from source on Debian-based Linux distributions using the `apt-get` package manager.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n $ [sudo] apt-get install build-essential autoconf libtool pkg-config\n```\n\n----------------------------------------\n\nTITLE: Configuring Request for Username Echo (gRPC Interop Test, JSON Payload)\nDESCRIPTION: This snippet shows the payload for a `UnaryCall` in the Google Default Credentials test. Setting `fill_username` to `true` instructs the server to echo the authenticated username in the response.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"fill_username\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Testing with GTest using CMake\nDESCRIPTION: Conditionally configures the test suite if the `utf8_range_ENABLE_TESTS` option is ON. It enables testing, finds the required GTest package, adds a test executable (`tests`) built from `utf8_validity_test.cc`, links it to `utf8_validity` and GTest, registers a test named `utf8_validity_test`, and adds a custom target `check` to run the tests.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif (utf8_range_ENABLE_TESTS)\n  enable_testing()\n\n  find_package(GTest REQUIRED)\n\n  add_executable(tests utf8_validity_test.cc)\n  target_link_libraries(tests utf8_validity GTest::gmock_main)\n\n  add_test(NAME utf8_validity_test COMMAND tests)\n\n  add_custom_target(check\n    COMMAND tests\n    DEPENDS tests\n  )\nendif ()\n```\n\n----------------------------------------\n\nTITLE: Testing Malformed UTF-8: Lonely 5-Byte Start Characters\nDESCRIPTION: Tests the decoder's response to receiving the first byte of potential 5-byte sequences (bytes 0xf8-0xfb) when they are not followed by the required four continuation bytes (here, followed by a space). These start bytes are invalid according to modern UTF-8 standards (RFC 3629) regardless of following bytes and should always be treated as errors.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/utf8_corpus_dir/utf8_corpus_kuhn.txt#_snippet_8\n\nLANGUAGE: UTF-8\nCODE:\n```\n   \"ø ù ú û \"\n```\n\n----------------------------------------\n\nTITLE: Creating Utility Library with OpenTelemetry Support\nDESCRIPTION: Defines a 'util' library that provides common functionality for the client and server applications. Links against the protobuf library, OpenTelemetry metrics, gRPC, and Protobuf dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# util\nadd_library(util\n  \"util.cc\")\ntarget_link_libraries(util\n  hw_grpc_proto\n  opentelemetry-cpp::metrics\n  ${_GRPC_GRPCPP}\n  ${_REFLECTION}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Installing gRPC C++ with CMake Using Pre-installed Dependencies - Shell\nDESCRIPTION: Configures the gRPC C++ build for installation (`-DgRPC_INSTALL=ON`) using CMake, specifying that all dependencies (Abseil, c-ares, Protobuf, RE2, OpenSSL, zlib) should be found as pre-installed packages (`-DgRPC_<depname>_PROVIDER=package`). Specifies C++17 standard. After configuration, builds using `make` and installs using `make install`. Requires dependencies to be already installed on the system.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_15\n\nLANGUAGE: sh\nCODE:\n```\n# NOTE: all of gRPC's dependencies need to be already installed\n$ cmake ../.. -DgRPC_INSTALL=ON                \\\n              -DCMAKE_BUILD_TYPE=Release       \\\n              -DCMAKE_CXX_STANDARD=17          \\\n              -DgRPC_ABSL_PROVIDER=package     \\\n              -DgRPC_CARES_PROVIDER=package    \\\n              -DgRPC_PROTOBUF_PROVIDER=package \\\n              -DgRPC_RE2_PROVIDER=package      \\\n              -DgRPC_SSL_PROVIDER=package      \\\n              -DgRPC_ZLIB_PROVIDER=package\n$ make\n$ make install\n```\n\n----------------------------------------\n\nTITLE: Running Nginx to Proxy PHP-FPM for gRPC Client via Docker\nDESCRIPTION: Runs an Nginx (version 1.17.4) container interactively. It mounts the local `nginx.conf` as the default Nginx configuration inside the container (read-only), links to the previously started `fpm` container, and maps host port 80 to the container's port 80 to handle incoming web requests and forward PHP requests to PHP-FPM.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/php/echo/README.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n$ docker run -it --rm -v $(pwd)/nginx.conf:/etc/nginx/conf.d/default.conf:ro \\\n  --link fpm:fpm -p 80:80 nginx:1.17.4\n```\n\n----------------------------------------\n\nTITLE: Enabling Server Reflection in a gRPC Python Server\nDESCRIPTION: Demonstrates enabling gRPC server reflection in Python. It involves importing the necessary module (`grpc_reflection.v1alpha.reflection`), defining the service names to be reflected (including the application service 'Greeter' and the reflection service itself), and calling `reflection.enable_server_reflection` with the service names and the server instance. This allows clients to query the server for available services and methods. Requires the `grpcio-reflection` package to be installed.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/server_reflection.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# add the following import statement to use server reflection\nfrom grpc_reflection.v1alpha import reflection\n# ...\ndef serve():\n    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))\n    helloworld_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)\n    # the reflection service will be aware of \"Greeter\" and \"ServerReflection\" services.\n    SERVICE_NAMES = (\n        helloworld_pb2.DESCRIPTOR.services_by_name['Greeter'].full_name,\n        reflection.SERVICE_NAME,\n    )\n    reflection.enable_server_reflection(SERVICE_NAMES, server)\n    server.add_insecure_port('[::]:50051')\n    server.start()\n```\n\n----------------------------------------\n\nTITLE: Cloning gRPC Repository (Cocoapods)\nDESCRIPTION: Clones the gRPC repository from GitHub using a specified release tag. Changes the current directory to the cloned repository root and initializes/updates its submodules. This is a prerequisite for accessing the example code.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ git clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc\n$ cd grpc\n$ git submodule update --init\n```\n\n----------------------------------------\n\nTITLE: Migrating Docker Images from Docker Hub using TRANSFER_FROM_DOCKERHUB Option (Bash)\nDESCRIPTION: This snippet enables quick migration of existing Docker images from Docker Hub to local builds. By setting the TRANSFER_FROM_DOCKERHUB environment variable to true, the push_testing_images.sh script attempts to pull prebuilt images from Docker Hub rather than building them from scratch. This is useful during repository transitions or to speed up local setup; it requires Internet connectivity to Docker Hub and the presence of the migration-supporting script.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/dockerfile/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nTRANSFER_FROM_DOCKERHUB=true tools/dockerfile/push_testing_images.sh\n```\n\n----------------------------------------\n\nTITLE: Cloning gRPC Repository at Release Tag - Shell Script\nDESCRIPTION: Clones the gRPC repository at a user-specified release tag, switching the working directory to the checked-out clone. This is required before building the gRPC extension and plugin tools from source code. Ensure git is installed and the specified tag is valid.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ git clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc\n$ cd grpc\n```\n\n----------------------------------------\n\nTITLE: Profiling Syscalls in gRPC-Go Server Benchmark Using perf (Shell)\nDESCRIPTION: Attaches a profiler to the gRPC-Go server process to count syscalls, specifically tracking 'sys_enter_write' events during benchmark execution. Requires root or appropriate permissions, the 'netstat' utility to obtain the target process PID, and 'perf' installed on the server machine. The driver port and worker PID must be substituted with runtime values; output will show aggregated syscall counts, aiding in performance debugging. This command should be run while the benchmark is active.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nnetstat -tulpn | grep <driver_port> # to get pid of worker\nperf stat -p <worker_pid> -e syscalls:sys_enter_write # stop after test complete\n```\n\n----------------------------------------\n\nTITLE: Testing Malformed UTF-8: Lonely 2-Byte Start Characters\nDESCRIPTION: Tests the decoder's response to receiving the first byte of potential 2-byte sequences (bytes 0xc0-0xdf) when they are not followed by a valid continuation byte (here, followed by a space). These start bytes are invalid without a subsequent continuation byte and should be treated as errors.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/utf8_corpus_dir/utf8_corpus_kuhn.txt#_snippet_5\n\nLANGUAGE: UTF-8\nCODE:\n```\n   \"À Á Â Ã Ä Å Æ Ç È É Ê Ë Ì Í Î Ï                                           |\n    Ð Ñ Ò Ó Ô Õ Ö × Ø Ù Ú Û Ü Ý Þ ß \"\n```\n\n----------------------------------------\n\nTITLE: Building Selected Docker Images for gRPC PHP Testing\nDESCRIPTION: Command to build only specific Docker images for testing the gRPC PHP extension, allowing developers to test against particular environments.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ ./src/php/bin/build_all_docker_images.sh grpc-ext php-src\n```\n\n----------------------------------------\n\nTITLE: Configuring C++ gRPC OpenTelemetry Example Project with CMake\nDESCRIPTION: This CMake snippet defines minimum CMake requirements, sets up the main project for C and C++ compilation, and includes shared build logic from an external file. It then locates the opentelemetry-cpp package, which must be pre-installed using CMake. The project name is set to 'grpc_opentelemetry_example', and the configuration expects gRPC, protobuf, absl, and prometheus-cpp as prerequisites. Designed for reproducible builds of a gRPC C++ example enhanced with OpenTelemetry tracing.\nKey parameters: C++ toolchain, location of common CMake logic, required package versions. Inputs: Project source tree and dependency installations. Outputs: Build configuration settings for subsequent targets.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/ostream/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(grpc_opentelemetry_example C CXX)\n\ninclude(../../cmake/common.cmake)\n\nfind_package(opentelemetry-cpp CONFIG REQUIRED)\n```\n\n----------------------------------------\n\nTITLE: Listing Python Package Requirements for gRPC Setup\nDESCRIPTION: This configuration snippet lists the Python package dependencies required for the gRPC project setup. It specifies version constraints: `coverage` version 4.0 or higher, `cython` version 3.0.0 or higher, `protobuf` version 6.30.0 or higher but less than 7.0.0, and `wheel` version 0.29 or higher. These packages are typically installed using pip via a requirements file (e.g., `pip install -r requirements.txt`).\nSOURCE: https://github.com/grpc/grpc/blob/master/requirements.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ncoverage>=4.0\ncython>=3.0.0\nprotobuf>=6.30.0,<7.0.0\nwheel>=0.29\n```\n\n----------------------------------------\n\nTITLE: Fetching and Unpacking Source Gem | RubyGems | bash\nDESCRIPTION: Provides the `bash` commands to download and extract the source `grpc` gem. This gem contains the actual source code files needed by `gdb` to display source listings during debugging.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/nativedebug/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd /home\ngem fetch grpc-1.60.1.gem\ngem unpack grpc-1.60.1.gem\n```\n\n----------------------------------------\n\nTITLE: Building gRPC HelloWorld Greeter Client and Server Executables Using CMake for C++\nDESCRIPTION: Defines executable targets for greeter_client and greeter_server, specifying their respective source files. Each executable is linked against the generated protobuf and gRPC libraries, absl flags, logging, reflection, and protobuf libraries to ensure proper functionality. This setup facilitates building and linking full client-server gRPC applications.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/error_details/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(_target\n  greeter_client greeter_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    status_proto\n    error_details_proto\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Keepalive Server (C++)\nDESCRIPTION: This command executes the gRPC keepalive server using Bazel. It demonstrates how to start the server component of the keepalive example.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/keepalive/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ tools/bazel run examples/cpp/keepalive:greeter_callback_server\n```\n\n----------------------------------------\n\nTITLE: Flaky Server Log Example\nDESCRIPTION: This shows an example server log, the flaky server randomly injects errors when a request is received. This is to show the retry behavior of the clients.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/retry/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ python3 flaky_server.py\nINFO:root:Starting flaky server on [::]:50051\nINFO:root:Injecting error to RPC from ipv6:[::1]:54471\nINFO:root:Successfully responding to RPC from ipv6:[::1]:54473\nINFO:root:Injecting error to RPC from ipv6:[::1]:54491\nINFO:root:Injecting error to RPC from ipv6:[::1]:54581\nINFO:root:Injecting error to RPC from ipv6:[::1]:54581\nINFO:root:Injecting error to RPC from ipv6:[::1]:54581\nINFO:root:Injecting error to RPC from ipv6:[::1]:54581\nINFO:root:Successfully responding to RPC from ipv6:[::1]:54581\nINFO:root:Injecting error to RPC from ipv6:[::1]:55474\nINFO:root:Injecting error to RPC from ipv6:[::1]:55474\nINFO:root:Injecting error to RPC from ipv6:[::1]:55474\nINFO:root:Injecting error to RPC from ipv6:[::1]:55474\nINFO:root:Successfully responding to RPC from ipv6:[::1]:55474\nINFO:root:Injecting error to RPC from ipv6:[::1]:55533\nINFO:root:Injecting error to RPC from ipv6:[::1]:55533\nINFO:root:Injecting error to RPC from ipv6:[::1]:55533\nINFO:root:Successfully responding to RPC from ipv6:[::1]:55533\n```\n\n----------------------------------------\n\nTITLE: Defining Project and Languages - CMake\nDESCRIPTION: Defines the CMake project with the name 'Cancellation' and specifies that the project will use C and C++ languages. This sets up the basic project configuration.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/cancellation/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(Cancellation C CXX)\n```\n\n----------------------------------------\n\nTITLE: Counting Scalable Scenarios with scenario_config_exporter.py (Bash)\nDESCRIPTION: This snippet demonstrates how to use the `scenario_config_exporter.py` script to count the number of scenarios in the `scalable` category. It executes the script with the `--count_scenarios` and `--category=scalable` flags. The output shows the count of scenarios for different languages within the specified category.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ ./tools/run_tests/performance/scenario_config_exporter.py --count_scenarios --category=scalable\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC C++ KeyValueStore Client (Bazel)\nDESCRIPTION: Command to build and run the gRPC C++ key-value store client example using Bazel. This client connects to the running server and demonstrates the client-side caching interceptor by potentially avoiding server requests for cached keys.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/interceptors/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ tools/bazel run examples/cpp/interceptors:keyvaluestore_client\n```\n\n----------------------------------------\n\nTITLE: Building Docker image for gRPC xDS client in C++\nDESCRIPTION: This snippet details the command to build a Docker image for the gRPC xDS client using a specified Dockerfile. The image is built from the gRPC workspace for deployment in containerized environments.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/xds/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ndocker build -f examples/cpp/xds/Dockerfile.client examples/cpp/xds\n```\n\n----------------------------------------\n\nTITLE: Printing Docker Build Commands Without Execution\nDESCRIPTION: Command to only display the Docker build commands without actually executing them, useful for inspection or manual execution.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ ./src/php/bin/build_all_docker_images.sh --cmds\n```\n\n----------------------------------------\n\nTITLE: Installing RVM and Ruby 2.x\nDESCRIPTION: Shell commands to install RVM and Ruby 2.x, which is required for building gRPC Ruby from source. This includes importing the RVM public key and installing a stable Ruby version.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ command curl -sSL https://rvm.io/mpapis.asc | gpg --import -\n$ \\curl -sSL https://get.rvm.io | bash -s stable --ruby=ruby-2\n$\n$ # follow the instructions to ensure that your're using the latest stable version of Ruby\n$ # and that the rvm command is installed\n```\n\n----------------------------------------\n\nTITLE: Installing RVM and Ruby 2.x via shell\nDESCRIPTION: This shell code installs RVM (Ruby Version Manager) and Ruby 2.x on the system, using GPG to retrieve the RVM signing key and the official RVM installation script. This setup enables using Ruby 2.x without modifying the system-wide Ruby installation, which is required for the gRPC Ruby client and server to work with keyword arguments. The user must then source the RVM script to activate the environment.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/ruby/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ # RVM installation as specified at https://rvm.io/rvm/install\n$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\n$ \\curl -sSL https://get.rvm.io | bash -s stable --ruby=ruby-2\n$\n```\n\n----------------------------------------\n\nTITLE: Combiner Class with Finally Queue\nDESCRIPTION: This code enhances the combiner by adding a 'finally' queue. Functions added to the `finally` queue are executed after the main queue is drained. This is useful for write-batching scenarios where final operations need to be performed after all other operations are completed. A loop is used to continuously process both queues.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/core/combiner-explainer.md#_snippet_3\n\nLANGUAGE: \nCODE:\n```\nclass combiner {\n  mpscq q; // multi-producer single-consumer queue can be made non-blocking\n  state s; // is it empty or executing\n  queue finally; // you can only do run_finally when you are already running something from the combiner\n\n  run(f) {\n    if (q.push(f)) {\n      // q.push returns true if it's the first thing\n      loop:\n      while (q.pop(&f)) { // modulo some extra work to avoid races\n        f();\n      }\n      while (finally.pop(&f)) {\n        f();\n      }\n      goto loop;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Navigating to the Example Directory (Shell)\nDESCRIPTION: Changes the current working directory to the specific C++ metadata example directory (`examples/cpp/metadata`) within the cloned gRPC repository.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ cd examples/cpp/metadata\n```\n\n----------------------------------------\n\nTITLE: Tagging Docker image for pushing to registry\nDESCRIPTION: This command tags the previously built Docker image with a specific tag or version identifier, preparing it for upload to a Docker registry via 'docker push'. It associates the image's SHA with a repository tag.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/xds/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ndocker image tag ${sha from build command above} ${tag}\n```\n\n----------------------------------------\n\nTITLE: Verifying Server-Side gRPC Metrics Output\nDESCRIPTION: This output example illustrates the metrics collected on the server side after running the server. It shows the server start message and a list of exported metrics related to gRPC calls, such as call counts and durations.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/observability/README.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Invoking protoc with C# and gRPC Options on the Command Line in Bash\nDESCRIPTION: This Bash command illustrates how to manually invoke the protoc compiler with the grpc_csharp_plugin. It specifies output directories (--csharp_out, --grpc_out), passes C#-specific options (--csharp_opt) like base_namespace, and gRPC-specific options (--grpc_opt) like no_server and base_namespace, along with include directories (-I) for resolving imports.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nprotoc --plugin=protoc-gen-grpc=grpc_csharp_plugin \\\n    --csharp_out=OUT_DIR \\\n    --csharp_opt=base_namespace=Example \\\n    --grpc_out=OUT_DIR \\\n    --grpc_opt=no_server,base_namespace=Example \\\n    -I INCLUDE_DIR foo.proto\n```\n\n----------------------------------------\n\nTITLE: Testing Specific UTF-8 Boundary Condition Codepoints\nDESCRIPTION: Tests specific Unicode code points near significant boundaries: just before the surrogate range (U+D7FF), just after the surrogate range (U+E000), the replacement character itself (U+FFFD), the last valid Unicode code point (U+10FFFF), and the first invalid code point after the valid range (U+110000).\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/utf8_corpus_dir/utf8_corpus_kuhn.txt#_snippet_3\n\nLANGUAGE: UTF-8\nCODE:\n```\n2.3.1  U-0000D7FF = ed 9f bf = \"íŸ¿\"                                            |\n2.3.2  U-0000E000 = ee 80 80 = \"î€€\"                                            |\n2.3.3  U-0000FFFD = ef bf bd = \"ï¿½\"                                            |\n2.3.4  U-0010FFFF = f4 8f bf bf = \"ô ¿¿\"                                         |\n2.3.5  U-00110000 = f4 90 80 80 = \"ô €€\"                                         |\n```\n\n----------------------------------------\n\nTITLE: Building and testing gRPC Ruby gem locally\nDESCRIPTION: Shell commands to install dependencies with Bundler and run tests using Rake, for building and verifying the gRPC Ruby gem locally.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/README.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n$ # from this directory\n$ bundle install  # creates the ruby bundle, including building the grpc extension\n$ rake  # runs the unit tests, see rake -T for other options\n```\n\n----------------------------------------\n\nTITLE: Installing Protobuf Extension from PECL - Shell Script\nDESCRIPTION: Installs the C implementation of the 'protobuf' runtime as a PHP extension using PECL, providing better performance for protobuf message handling. Optionally pins to a specific version. Requires PHP development environment and root access if needed.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\n$ [sudo] pecl install protobuf\n```\n\n----------------------------------------\n\nTITLE: NuGet Package Specification for Proto Files\nDESCRIPTION: XML configuration for creating a NuGet package that contains .proto files. The nuspec file defines package metadata and files to include, placing .proto files in a content/protos subdirectory and including a targets file for MSBuild integration.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_18\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\"?>\n<package xmlns=\"http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd\">\n  <metadata>\n    <id>My.Example.Protos</id>\n    <version>1.0.0</version>\n    <title>Example package containing proto files</title>\n    <authors>author</authors>\n    <owners>owner</owners>\n    <licenseUrl>license url</licenseUrl>\n    <projectUrl>project url</projectUrl>\n    <description>See project site for more info.</description>\n    <summary>Example package containing proto files.</summary>\n    <releaseNotes>Example package containing proto files</releaseNotes>\n    <copyright>Copyright 2023, My Company.</copyright>\n  </metadata>\n  \n  <files>\n    <!-- copy the My.Example.Protos.targets file for MSBuild integration -->\n    <file src=\"build\\**\" target=\"build\" />\n    <!-- copy the .proto files into the package -->\n    <file src=\"proto\\**\" target=\"content\\protos\" />\n  </files>\n</package>\n```\n\n----------------------------------------\n\nTITLE: Initializing & Updating Submodules\nDESCRIPTION: This Bash snippet navigates to the cloned gRPC repository and updates its submodules recursively. This command initializes and fetches the necessary dependencies for the project, ensuring all external components are available for building and testing. Submodules are handled within the gRPC repository.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd grpc\ngit submodule update --init --recursive\n```\n\n----------------------------------------\n\nTITLE: Handling Abseil Dependency using CMake\nDESCRIPTION: Checks if Abseil's strings library is already a known target. If not, it attempts to find the Abseil package using `find_package`. If `ABSL_ROOT_DIR` is set, it instead adds Abseil as a subdirectory, configuring its installation and C++ standard propagation.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif (NOT TARGET absl::strings)\n  if (NOT ABSL_ROOT_DIR)\n    find_package(absl REQUIRED CONFIG)\n  else ()\n    set(ABSL_ENABLE_INSTALL ${utf8_range_ENABLE_INSTALL})\n    set(ABSL_PROPAGATE_CXX_STD ON)\n    add_subdirectory(${ABSL_ROOT_DIR} third_party/abseil-cpp)\n  endif ()\nendif ()\n```\n\n----------------------------------------\n\nTITLE: Installing bundler and dependencies for gRPC Ruby example\nDESCRIPTION: This shell code installs the bundler gem if it is not already available, and then runs 'bundle install' to install all dependencies specified in the example project's Gemfile. This prepares the environment to run the gRPC Ruby client and server example applications.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/ruby/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ # from this directory\n$ gem install bundler # if you don't already have bundler available\n$ bundle install\n```\n\n----------------------------------------\n\nTITLE: Running Math Test Server with Node.js for Generated Code Tests - Shell Script\nDESCRIPTION: Installs npm dependencies and launches the math_server.js in the generated_code test directory. This server exposes a gRPC Math service, required to test the PHP-generated client and ensure protocol compatibility. Requires Node.js and npm installed.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_18\n\nLANGUAGE: sh\nCODE:\n```\n$ cd grpc/src/php/tests/generated_code\n$ npm install\n$ node math_server.js\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC C++ Code from Protobuf Using Make\nDESCRIPTION: Invokes make to generate the gRPC service and message source files (helloworld.grpc.pb.cc and helloworld.pb.cc) from protobuf definitions. This depends on having a proper Makefile and the protobuf compiler tools installed. The generated files contain both client and server interfaces used in the example.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/load_balancing/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ make helloworld.grpc.pb.cc helloworld.pb.cc\n```\n\n----------------------------------------\n\nTITLE: Responding to gRPC Client Cancellation Server-Side Python\nDESCRIPTION: Shows how a gRPC server implementation can detect and react to a client cancellation. It uses `ServicerContext.add_callback` to register a function that sets a `threading.Event` when the RPC is completed (including cancellation). The application code should poll this event periodically to interrupt long-running tasks gracefully. Requires the `threading` module and the `ServicerContext` object provided to the servicer method.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/cancellation/README.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nstop_event = threading.Event()\ndef on_rpc_done():\n    # Regain servicer thread.\n    stop_event.set()\ncontext.add_callback(on_rpc_done)\nsecret = _find_secret(stop_event)\n```\n\n----------------------------------------\n\nTITLE: Building gRPC C++ CSM Server Docker Image Instructions\nDESCRIPTION: This snippet provides the Docker command for building the gRPC C++ Server image for the CSM observability example using the Dockerfile.server file. Docker must be installed and the working directory set correctly to the gRPC workspace root. This image includes the server-specific application and its dependencies. After building, the image can be tagged and pushed to a Docker registry.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/csm/observability/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\ndocker build -f examples/cpp/csm/observability/Dockerfile.server\n```\n\n----------------------------------------\n\nTITLE: Running Selected Docker Test Images for gRPC PHP\nDESCRIPTION: Command to run only specific Docker images for testing the gRPC PHP extension, allowing focused testing on particular environments.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ ./src/php/bin/run_all_docker_images.sh grpc-ext php-src\n```\n\n----------------------------------------\n\nTITLE: Cancelling gRPC Server Streaming RPC Client-Side Python\nDESCRIPTION: Illustrates cancelling a server-side streaming gRPC call from the client. The default stub method for streaming returns an object that functions as both an iterator and a `grpc.Future`. Calling `.cancel()` on this object (e.g., from a signal handler) terminates the stream. Iterating the cancelled object will raise an `RpcError`. Requires `sys` and `signal` modules.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/cancellation/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nstub = hash_name_pb2_grpc.HashFinderStub(channel)\nresult_generator = stub.FindRange(hash_name_pb2.HashNameRequest(desired_name=name))\ndef cancel_request(unused_signum, unused_frame):\n    result_generator.cancel()\n    sys.exit(0)\nsignal.signal(signal.SIGINT, cancel_request)\nfor result in result_generator:\n    print(result)\n```\n\n----------------------------------------\n\nTITLE: Generating Example Load Test Configurations - Bash\nDESCRIPTION: This snippet shows how to use the 'loadtest_examples.sh' shell script to generate sample load test configuration YAML files for all supported languages. The script accepts a single argument: the output directory where configurations are created. Requires bash and execution permission for the script. It generates a set of basic and template configurations for benchmarking workflows, helping users to bootstrap test environments quickly.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ loadtest_examples.sh <output_directory>\n```\n\n----------------------------------------\n\nTITLE: Status Proto Definition\nDESCRIPTION: This code defines the structure of a `Status` message using Protocol Buffers. The `Status` message includes an error code, a developer-facing error message, and a list of details. This message is used to represent the error status of an RPC call.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/errors/README.md#_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\n// The `Status` type defines a logical error model that is suitable for different\n// programming environments, including REST APIs and RPC APIs. It is used by\n// [gRPC](https://github.com/grpc). The error model is designed to be:\n//\n// - Simple to use and understand for most users\n// - Flexible enough to meet unexpected needs\n//\n// # Overview\n//\n// The `Status` message contains three pieces of data: error code, error message,\n// and error details. The error code should be an enum value of\n// [google.rpc.Code][google.rpc.Code], but it may accept additional error codes if needed.  The\n// error message should be a developer-facing English message that helps\n// developers *understand* and *resolve* the error. If a localized user-facing\n// error message is needed, put the localized message in the error details or\n// localize it in the client. The optional error details may contain arbitrary\n// information about the error. There is a predefined set of error detail types\n// in the package `google.rpc` that can be used for common error conditions.\n//\n// # Language mapping\n//\n// The `Status` message is the logical representation of the error model, but it\n// is not necessarily the actual wire format. When the `Status` message is\n// exposed in different client libraries and different wire protocols, it can be\n// mapped differently. For example, it will likely be mapped to some exceptions\n// in Java, but more likely mapped to some error codes in C.\n//\n// # Other uses\n//\n// The error model and the `Status` message can be used in a variety of\n// environments, either with or without APIs, to provide a\n// consistent developer experience across different environments.\n//\n// Example uses of this error model include:\n//\n// - Partial errors. If a service needs to return partial errors to the client,\n//     it may embed the `Status` in the normal response to indicate the partial\n//     errors.\n//\n// - Workflow errors. A typical workflow has multiple steps. Each step may\n//     have a `Status` message for error reporting.\n//\n// - Batch operations. If a client uses batch request and batch response, the\n//     `Status` message should be used directly inside batch response, one for\n//     each error sub-response.\n//\n// - Asynchronous operations. If an API call embeds asynchronous operation\n//     results in its response, the status of those operations should be\n//     represented directly using the `Status` message.\n//\n// - Logging. If some API errors are stored in logs, the message `Status` could\n//     be used directly after any stripping needed for security/privacy reasons.\nmessage Status {\n  // The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].\n  int32 code = 1;\n\n  // A developer-facing error message, which should be in English. Any\n  // user-facing error message should be localized and sent in the\n  // [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.\n  string message = 2;\n\n  // A list of messages that carry the error details.  There is a common set of\n  // message types for APIs to use.\n  repeated google.protobuf.Any details = 3;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running Objective-C Helloworld on Simulator with Bazel\nDESCRIPTION: Executes the Bazel run command for the `HelloWorld` target, specifying the target iOS simulator runtime version and device using `--ios_simulator_version` and `--ios_simulator_device` flags. This launches the compiled Objective-C app on the chosen simulator instance.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/README.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\n$ bazel run :HelloWorld --ios_simulator_version='<runtime>' --ios_sumlator_device='<device>'\n```\n\n----------------------------------------\n\nTITLE: Creating Static Library for gRPC Proto\nDESCRIPTION: This snippet creates a static library named 'hw_grpc_proto' which contains generated source and header files from both protobuf and gRPC.  It links the library with required gRPC and protobuf libraries.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# hw_grpc_proto\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Building and Running the php-future Docker Image\nDESCRIPTION: Commands to build and run the php-future Docker image, which tests the gRPC extension against future PHP versions in alpha, beta, or release candidate stages.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ cd grpc\n$ docker build -t grpc-php/php-future -f ./src/php/docker/php-future/Dockerfile .\n$ docker run -it --rm grpc-php/php-future\n```\n\n----------------------------------------\n\nTITLE: Combiner Class with Multi-Producer Single-Consumer Queue\nDESCRIPTION: This snippet presents an improved combiner class that uses a multi-producer single-consumer queue (mpscq) to avoid blocking the calling thread. The `run()` method pushes the function onto the queue. If the queue was empty, it starts a loop to execute functions from the queue until it is drained. This allows functions to be executed serially on a different thread.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/core/combiner-explainer.md#_snippet_2\n\nLANGUAGE: \nCODE:\n```\nclass combiner {\n  mpscq q; // multi-producer single-consumer queue can be made non-blocking\n  state s; // is it empty or executing\n\n  run(f) {\n    if (q.push(f)) {\n      // q.push returns true if it's the first thing\n      while (q.pop(&f)) { // modulo some extra work to avoid races\n        f();\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Tagging and Pushing Docker Images for gRPC C++ CSM Example (Shell)\nDESCRIPTION: This snippet explains how to tag a built Docker image with a specified tag and push it to a container registry. The placeholder ${sha from build command above} represents the specific image hash obtained from the previous build command, and ${tag} is the desired tag name. Proper tagging is required for version control and deployment processes.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/csm/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ndocker image tag ${sha from build command above} ${tag}\ndocker push ${tag}\n```\n\n----------------------------------------\n\nTITLE: Creating client and server executables\nDESCRIPTION: Iterates through a list of target names (client and server implementations) and creates an executable for each.  Links each executable against the `hw_grpc_proto` library and other necessary dependencies (abseil, gRPC, protobuf).  This builds the various client and server examples.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(_target\n  greeter_client greeter_server\n  greeter_callback_client greeter_callback_server\n  greeter_async_client greeter_async_client2 greeter_async_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::check\n    absl::flags\n    absl::flags_parse\n    absl::log\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Building and Running Benchmark Worker for gRPC-Go - Bash\nDESCRIPTION: This snippet shows installation and execution of the gRPC-Go benchmark worker. The user must install the worker binary from the grpc-go repository's worker directory, optionally building with Go compiler flags to disable inlining (for profiling). The installed worker is run, specifying the driver port for test orchestration. Assumes Go toolchain installed and $GOPATH/bin in PATH.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ cd <grpc-go-repo>/benchmark/worker && go install\n$ # if profiling, it might be helpful to turn off inlining by building with \"-gcflags=-l\"\n$ $GOPATH/bin/worker --driver_port <driver_port>\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version - CMake\nDESCRIPTION: Specifies the minimum required version of CMake to build this project. This ensures compatibility with the CMake features used in the script.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/cancellation/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Manually Invoking Protobuf Compiler to Generate gRPC Code\nDESCRIPTION: Shows the direct protoc compiler commands that generate the gRPC service source file (helloworld.grpc.pb.cc) and the protobuf message source file (helloworld.pb.cc) from the helloworld.proto file. The --grpc_out flag generates gRPC-specific code with the grpc_cpp_plugin plugin. The --cpp_out flag generates standard protobuf C++ code. The -I flag specifies the proto include directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/load_balancing/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ protoc -I ../../protos/ --grpc_out=. --plugin=protoc-gen-grpc=grpc_cpp_plugin ../../protos/helloworld.proto\n$ protoc -I ../../protos/ --cpp_out=. ../../protos/helloworld.proto\n```\n\n----------------------------------------\n\nTITLE: Listing Method Details with gRPC CLI\nDESCRIPTION: Command to inspect a specific method in a service using the gRPC CLI tool.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_reflection_tutorial.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ grpc_cli ls localhost:50051 helloworld.Greeter.SayHello -l\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC HelloWorld Build with CMake - CMake\nDESCRIPTION: This CMake script configures the build for a C++ HelloWorld example using gRPC. It defines the required minimum CMake version, sets up the project, and includes necessary common settings. The script generates C++ source/header files from the helloworld.proto file and produces a shared library (hw_grpc_proto) containing both gRPC and protobuf-generated code. Executable targets for greeter_callback_client and greeter_callback_server are defined and linked against the generated library and required dependencies (absl, gRPC, protobuf). Users should ensure all dependencies are installed and available; paths to proto files and plugins may need adjustment based on the environment. Input is the proto file; outputs are the generated binaries for the client and server. Limitations include hardcoded paths and assumptions about dependency locations.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/keepalive/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(HelloWorld C CXX)\n\ninclude(../cmake/common.cmake)\n\n# Proto file\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n\n# Generated sources\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n\n# Include generated *.pb.h files\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n\n# hw_grpc_proto\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n\n# Targets greeter_[async_](client|server)\nforeach(_target\n  greeter_callback_client greeter_callback_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC EventEngine Test with Bazel BUILD\nDESCRIPTION: Defines a `grpc_cc_test` target for testing a custom EventEngine. It specifies the test name, source file, polling preference, and dependencies on specific test modules from the test suite. This configuration tells Bazel how to build and link the custom test executable.\nSOURCE: https://github.com/grpc/grpc/blob/master/test/core/event_engine/test_suite/README.md#_snippet_0\n\nLANGUAGE: Bazel BUILD\nCODE:\n```\ngrpc_cc_test(\n    name = \"my_custom_event_engine_test\",\n    srcs = [\"my_custom_event_engine_test.cc\"],\n    uses_polling = False,\n    deps = [\"//test/core/event_engine/test_suite/tests:timer\"],\n)\n```\n\n----------------------------------------\n\nTITLE: Installing grpcio-tools from PyPI (System-wide) - bash\nDESCRIPTION: Installs the `grpcio-tools` package system-wide from the Python Package Index (PyPI) using the pip package installer with administrator privileges (common on Linux/macOS).\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/distrib/python/grpcio_tools/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo pip install grpcio-tools\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project\nDESCRIPTION: Sets the minimum required CMake version for the project and defines the project name ('utf8_range') along with the programming languages used (C and C++). This is the standard starting point for a CMakeLists.txt file.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.16)\nproject (utf8_range C CXX)\n```\n\n----------------------------------------\n\nTITLE: Creating insecure and secure gRPC channels using AsyncIO in Python\nDESCRIPTION: This snippet covers functions for creating both insecure and secure channels in gRPC AsyncIO Python API. These channels facilitate client connections to gRPC servers, managing underlying network connections, name resolution, and load balancing. The functions enable applications to invoke remote procedures asynchronously.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. autofunction:: insecure_channel\n.. autofunction:: secure_channel\n```\n\n----------------------------------------\n\nTITLE: Installing protobuf with PyPI\nDESCRIPTION: This command installs the protobuf package for Python using pip (Python Package Index). It downloads and installs the protobuf library, allowing Python applications to serialize and deserialize data using the protobuf format.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/upb/upb/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ sudo pip install protobuf\n```\n\n----------------------------------------\n\nTITLE: Creating Executables for Client and Server\nDESCRIPTION: This snippet iterates through the target names (greeter_client and greeter_server) and creates executables for each. It then links these executables with the 'hw_grpc_proto' library and other necessary libraries (absl, gRPC, and protobuf).  It leverages a loop construct to minimize code duplication.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# Targets greeter_(client|server)\nforeach(_target\n  greeter_client greeter_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::flags_parse\n    absl::log_initialize\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Building gRPC C++ with CMake and Visual Studio on Windows - Batch\nDESCRIPTION: Generates Visual Studio solution files using CMake (`-G \"Visual Studio 17 2022\"`) and then builds the project in Release configuration. Specifies C++17 standard. Requires Visual Studio 2022 or later. Use `-DBUILD_SHARED_LIBS=ON` during the first `cmake` step to build DLLs (not recommended).\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_13\n\nLANGUAGE: batch\nCODE:\n```\n> @rem Run from grpc directory after cloning the repo with --recursive or updating submodules.\n> md .build\n> cd .build\n> cmake -G \"Visual Studio 17 2022\" -DCMAKE_CXX_STANDARD=17 ..\n> cmake --build . --config Release\n```\n\n----------------------------------------\n\nTITLE: Building gRPC Python CSM Server with Docker - Shell\nDESCRIPTION: This snippet shows how to build a Docker image for the gRPC Python CSM Hello World server by specifying Dockerfile.server. The build command is intended to be run from the root of the gRPC workspace, tagging the output image for use in a container registry. Docker must be available on the host, and the context should contain the full server code and its dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/observability/csm/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndocker build -f examples/python/observability/csm/Dockerfile.server -t \"us-docker.pkg.dev/grpc-testing/examples/csm-o11y-example-python-server\" .\n```\n\n----------------------------------------\n\nTITLE: Creating PHP gRPC Client with Custom User Agent - PHP\nDESCRIPTION: Illustrates instantiating a gRPC PHP client with a custom primary user agent string by setting 'grpc.primary_user_agent' in the channel options. Also demonstrates use of insecure channel credentials for non-production scenarios. Allows clients to be uniquely identified in server logs.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_24\n\nLANGUAGE: php\nCODE:\n```\n$client = new Helloworld\\GreeterClient('localhost:50051', [\n    'credentials' => Grpc\\ChannelCredentials::createInsecure(),\n    'grpc.primary_user_agent' => 'my-user-agent-identifier',\n]);\n```\n\n----------------------------------------\n\nTITLE: Building Docker image for gRPC xDS server in C++\nDESCRIPTION: This snippet specifies the command to build a Docker image for the gRPC xDS server from the designated Dockerfile, enabling containerized server deployment.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/xds/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ndocker build -f examples/cpp/xds/Dockerfile.server examples/cpp/xds\n```\n\n----------------------------------------\n\nTITLE: Printing Docker Run Commands Without Execution\nDESCRIPTION: Command to only display the Docker run commands without actually executing them, useful for inspection or manual execution.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ ./src/php/bin/run_all_docker_images.sh --cmds\n```\n\n----------------------------------------\n\nTITLE: Testing Malformed UTF-8: Lonely 3-Byte Start Characters\nDESCRIPTION: Tests the decoder's response to receiving the first byte of potential 3-byte sequences (bytes 0xe0-0xef) when they are not followed by the required two continuation bytes (here, followed by a space). These start bytes require two subsequent continuation bytes and should be treated as errors without them.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/utf8_corpus_dir/utf8_corpus_kuhn.txt#_snippet_6\n\nLANGUAGE: UTF-8\nCODE:\n```\n   \"à á â ã ä å æ ç è é ê ë ì í î ï \"\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Flow Control Server in Python\nDESCRIPTION: This command is used to start the gRPC flow control server written in Python. It assumes that the user is in the correct directory, which is `grpc/examples/python/flow_control`. The server will listen for incoming connections from the client.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/flow_control/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n$ python3 flow_control_server.py\n```\n\n----------------------------------------\n\nTITLE: Installing Bundler gem\nDESCRIPTION: Simple shell command to install the Bundler gem, which is needed for managing Ruby dependencies when building gRPC from source.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ gem install bundler\n```\n\n----------------------------------------\n\nTITLE: Configuring GrpcServices in MSBuild XML\nDESCRIPTION: This XML snippet demonstrates how to use the `GrpcServices` attribute in an MSBuild project file. It configures the generation of gRPC services and protocol buffer messages. The example shows how to set GrpcServices to 'None' for all .proto files and then update specific files to 'Both'.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_12\n\nLANGUAGE: XML\nCODE:\n```\n<ItemGroup>\n  <Protobuf Include=\"**/*.proto\" GrpcServices=\"None\" />\n  <Protobuf Update=\"**/hello/*.proto;**/bye/*.proto\" GrpcServices=\"Both\" />\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Cloning gRPC Repository Using Git Shell Command\nDESCRIPTION: Clones the gRPC GitHub repository at a specified release tag to the local machine to obtain example source code. This requires git to be installed and internet connectivity. The RELEASE_TAG_HERE placeholder should be replaced with the desired version tag to checkout. The command downloads all repository files including the examples directory used for the tutorial.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/load_balancing/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ git clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with Python\nDESCRIPTION: This script builds gRPC in a specified language and executes unit tests.  It requires the gRPC project to be present. The `--use_docker` option builds a Docker container with dependencies. Key parameters include language (-l) and build configuration (-c). The output is the result of running the unit tests. You may encounter module import errors, in which case, install the missing modules.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntools/run_tests/run_tests.py -l python -c dbg\n```\n\n----------------------------------------\n\nTITLE: Cloning gRPC Repository and Initializing Submodules on Unix - Shell\nDESCRIPTION: Clones the gRPC repository from GitHub for a specific release tag (`RELEASE_TAG_HERE`) and initializes its necessary submodules on a Unix-like system using `git`. This step is required before building from source with build systems like CMake.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\n $ git clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc\n $ cd grpc\n $ git submodule update --init\n```\n\n----------------------------------------\n\nTITLE: Pushing Changes (Git)\nDESCRIPTION: This git command pushes the local commits to the remote repository. It pushes the local commits to the specified origin and the branch containing the changes. The user should replace 'my-feature-branch' with the actual name of the branch.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngit push origin my-feature-branch\n```\n\n----------------------------------------\n\nTITLE: Printing Low-Level gRPC C Core API Invocations Using GRPC_TRACE in Bash\nDESCRIPTION: This example shows how to enable extra logging for the internal gRPC C core API by setting the `GRPC_TRACE` environment variable to `api`. The example also uses `--v=-1` and `--minloglevel=0` to configure absl log verbosity so that the trace logs are printed. This snippet requires gRPC built with absl logging and is useful for diagnosing low-level gRPC behaviour.\nSOURCE: https://github.com/grpc/grpc/blob/master/TROUBLESHOOTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nGRPC_TRACE=api ./helloworld_application_using_grpc --v=-1 --minloglevel=0\n```\n\n----------------------------------------\n\nTITLE: Configuring mTLS Channel Credentials in gRPC xDS Bootstrap (JSON)\nDESCRIPTION: Specifies the JSON configuration object for the `tls` channel credential type used within the `channel_creds` array of an `xds_servers` entry. It allows configuring TLS/mTLS connections to the xDS server. Key parameters include `ca_certificate_file` (optional path to CA cert, uses system roots if unset), `certificate_file` and `private_key_file` (required together for mTLS), and `refresh_interval` (optional duration string for certificate reload frequency, defaults to \"600s\").\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/grpc_xds_bootstrap_format.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  // Path to CA certificate file.\n  // If unset, system-wide root certs are used.\n  \"ca_certificate_file\": <string>,\n\n  // Paths to identity certificate file and private key file.\n  // If either of these fields are set, both must be set.\n  // If set, mTLS will be used; if unset, normal TLS will be used.\n  \"certificate_file\": <string>,\n  \"private_key_file\": <string>,\n\n  // How often to re-read the certificate files.\n  // Value is the JSON format described for a google.protobuf.Duration\n  // message in https://protobuf.dev/programming-guides/proto3/#json.\n  // If unset, defaults to \"600s\".\n  \"refresh_interval\": <string>\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Unary gRPC C++ Client with Mock Stub\nDESCRIPTION: Provides a Google Test example showing how to unit test the `DoEcho` method of the `FakeClient`. It initializes the client with a `MockEchoTestServiceStub`, sets expectations on the mock's `Echo` method using `EXPECT_CALL` and Google Mock actions (`DoAll`, `SetArgPointee`, `Return`), and then calls the client method to trigger the mock behavior.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/unit_testing.md#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nMockEchoTestServiceStub stub;\nEchoResponse resp;\nresp.set_message(\"hello world\");\nEXPECT_CALL(stub, Echo(_,_,_)).Times(AtLeast(1)).WillOnce(DoAll(SetArgPointee<2>(resp), Return(Status::OK)));\nFakeClient client(stub);\nclient.DoEcho();\n```\n\n----------------------------------------\n\nTITLE: Defining Client/Server Executables in CMake\nDESCRIPTION: Uses a `foreach` loop to efficiently define executable targets for `ssl_client` and `ssl_server`. Each executable is compiled from its corresponding `.cc` source file (e.g., `ssl_client.cc`) and linked against the `helper` library, the `hw_grpc_proto` library (containing generated proto/gRPC code), Abseil libraries (flags, flags_parse, log_initialize, strings), the core gRPC C++ library (`_GRPC_GRPCPP`), the Protobuf library (`_PROTOBUF_LIBPROTOBUF`), and the gRPC reflection library (`_REFLECTION`).\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/auth/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n# Targets greeter_(client|server)\nforeach(_target\n  ssl_client ssl_server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    helper\n    hw_grpc_proto\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    absl::strings\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Tagging and Pushing Docker Images for gRPC C++ CSM Components\nDESCRIPTION: These commands illustrate how to tag a Docker image created in the previous build step with a custom tag and push it to a Docker registry. Tagging requires the SHA from the built image and a chosen tag name. The push command uploads the tagged image to a configured Docker registry. These steps assume Docker authentication and network connectivity to the registry.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/csm/observability/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\ndocker image tag ${sha from build command above} ${tag}\n```\n\nLANGUAGE: Bash\nCODE:\n```\ndocker push ${tag}\n```\n\n----------------------------------------\n\nTITLE: Checking Source File Availability (Full) | gdb | gdb\nDESCRIPTION: Shows the result of using `gdb list` after adding the required source subdirectories. All relevant source files should now be found and displayed by `gdb`, enabling full source-level debugging.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/nativedebug/README.md#_snippet_10\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) list\nwarning: Source file is more recent than executable.\n658\t  gpr_mu_lock(&global_connection_polling_mu);\n659\t  gpr_cv_broadcast(&global_connection_polling_cv);\n660\t  gpr_mu_unlock(&global_connection_polling_mu);\n661\n662\t  for (;;) {\n663\t    event = grpc_completion_queue_next(\n664\t        g_channel_polling_cq, gpr_inf_future(GPR_CLOCK_REALTIME), NULL);\n665\t    if (event.type == GRPC_QUEUE_SHUTDOWN) {\n666\t      break;\n667\t    }\n(gdb)\n```\n\n----------------------------------------\n\nTITLE: Defining and Linking Library for Generated Sources - CMake\nDESCRIPTION: This snippet defines a static library named `hw_grpc_proto` that includes the generated source files from the proto definition. It then links this library to the required Protobuf, gRPC C++ (`_GRPC_GRPCPP`), Reflection (`_REFLECTION`), and Abseil libraries.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/retry/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# hw_grpc_proto\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  absl::check\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Generating C++ Source Files from HelloWorld Proto Definition\nDESCRIPTION: Defines the generated source file paths and adds a custom command to compile the HelloWorld proto file into C++ code using protoc with gRPC plugin.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/health/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Generated sources\nset(hw_proto_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.cc\")\nset(hw_proto_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.pb.h\")\nset(hw_grpc_srcs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.cc\")\nset(hw_grpc_hdrs \"${CMAKE_CURRENT_BINARY_DIR}/helloworld.grpc.pb.h\")\nadd_custom_command(\n      OUTPUT \"${hw_proto_srcs}\" \"${hw_proto_hdrs}\" \"${hw_grpc_srcs}\" \"${hw_grpc_hdrs}\"\n      COMMAND ${_PROTOBUF_PROTOC}\n      ARGS --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        --cpp_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${hw_proto_path}\"\n        --plugin=protoc-gen-grpc=\"${_GRPC_CPP_PLUGIN_EXECUTABLE}\"\n        \"${hw_proto}\"\n      DEPENDS \"${hw_proto}\")\n```\n\n----------------------------------------\n\nTITLE: Verifying service health with grpcurl (shell)\nDESCRIPTION: This command uses `grpcurl` to check the health status of the gRPC services.  It sends a Check request to the health service for a specific service (helloworld.Greeter) and then for all services.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/xds/README.md#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\n> grpcurl --plaintext -d '{\"service\": \"helloworld.Greeter\"}' localhost:50051\ngrpc.health.v1.Health/Check\n{\n  \"status\": \"SERVING\"\n}\n\n> grpcurl --plaintext -d '{\"service\": \"\"}' localhost:50051\ngrpc.health.v1.Health/Check\n{\n  \"status\": \"SERVING\"\n}\n```\n\n----------------------------------------\n\nTITLE: Example AuthContext Contents - TLS/SSL Authentication\nDESCRIPTION: This code block illustrates example contents within an AuthContext when using mutual TLS authentication.  It lists properties populated after a secure connection is established using test certificates. This snippet demonstrates the structure of the AuthContext, including keys like \"transport_security_type\", \"x509_common_name\", \"x509_pem_cert\" and \"x509_subject_alternative_name\", showing how information is stored for authentication purposes. It helps understand the data structure used by gRPC for authentication.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_side_auth.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n\"transport_security_type\": \"ssl\"  # connection is secured using TLS/SSL\n\"x509_common_name\": \"*.test.google.com\"  # from client's certificate\n\"x509_pem_cert\": \"-----BEGIN CERTIFICATE-----\\n...\"  # client's PEM encoded certificate\n\"x509_subject_alternative_name\": \"*.test.google.fr\"\n\"x509_subject_alternative_name\": \"waterzooi.test.google.be\"\n\"x509_subject_alternative_name\": \"*.test.youtube.com\"\n\"x509_subject_alternative_name\": \"192.168.1.3\"\n```\n\n----------------------------------------\n\nTITLE: Removing Carriage Returns (Bash)\nDESCRIPTION: This command is used to remove carriage return characters from a file which can cause problems with bash scripts on Windows VMs.  It uses `sed` to replace carriage returns at the end of lines.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/toolchains/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nsed -i 's/\n$//' third_party/toolchains/generate_windows_rbe_configs.sh\n```\n\n----------------------------------------\n\nTITLE: Installing google-protobuf with RubyGems\nDESCRIPTION: This command installs the google-protobuf gem, providing protobuf support for Ruby. It uses the RubyGems package manager to download and install the necessary files.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/upb/upb/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ gem install google-protobuf\n```\n\n----------------------------------------\n\nTITLE: Starting gRPC Interop Client with Bazel\nDESCRIPTION: Starts the gRPC interop client using Bazel.  This command sets GRPC_VERBOSITY to DEBUG, streams the test output, and executes the interop_client target with the specified server port and test case.\nSOURCE: https://github.com/grpc/grpc/blob/master/test/cpp/interop/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nGRPC_VERBOSITY=DEBUG ibazel run --test_output=streamed //test/cpp/interop:interop_client -- --server_port={port_number} --test_case={test_case}\n```\n\n----------------------------------------\n\nTITLE: Initiating gRPC Cancellation Server-Side Python\nDESCRIPTION: Demonstrates how a server can programmatically cancel an in-progress RPC using `ServicerContext.cancel()`. This is useful for enforcing server-side policies like resource limits. The example shows cancelling the RPC within an exception handler when a custom `ResourceLimitExceededError` is caught during processing. Requires access to the `ServicerContext` object.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/cancellation/README.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    for candidate in secret_generator:\n        yield candidate\nexcept ResourceLimitExceededError:\n    print(\"Cancelling RPC due to exhausted resources.\")\n    context.cancel()\n```\n\n----------------------------------------\n\nTITLE: Generating Proto Sources Without Compilation in C# Project\nDESCRIPTION: XML configuration for a .csproj file to generate C# sources from .proto files without compiling them. It sets up recursive inclusion of all .proto files, places output in the same directory as the input files, and prevents compilation into an assembly.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_14\n\nLANGUAGE: xml\nCODE:\n```\n<ItemGroup>\n  <Protobuf Include=\"**/*.proto\"\n      OutputDir=\"%(RelativeDir)\" CompileOutputs=\"false\"  />\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Applying DSCP in Node.js gRPC client\nDESCRIPTION: This snippet shows how to assign a DSCP value when creating a gRPC client in Node.js by including channel arguments with 'grpc.primary_user_agent' and 'grpc.dscp'. The DSCP value influences packet handling for QoS, with applicability on supported POSIX systems. The approach involves configuring client options accordingly.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/qos-dscp.md#_snippet_4\n\nLANGUAGE: Node.js\nCODE:\n```\nconst grpc = require('@grpc/grpc-js');\nconst client = new MyServiceClient('localhost:50051', grpc.credentials.createInsecure(), {\n  'grpc.dscp': 46,  // Set DSCP to EF\n  // other options\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying gRPC-Web Content-Types\nDESCRIPTION: Examples of `Content-Type` headers for gRPC-Web. `application/grpc-web` is used for binary formats, while `application/grpc-web-text` indicates Base64 encoded streams. The underlying message serialization format (e.g., proto, json) can be appended, defaulting to proto if unspecified.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md#_snippet_0\n\nLANGUAGE: HTTP Header Format\nCODE:\n```\napplication/grpc-web\n  * e.g. application/grpc-web+[proto, json, thrift]\n  * the sender should always specify the message format, e.g. +proto, +json\n  * the receiver should assume the default is \"+proto\" when the message format is missing in Content-Type (as \"application/grpc-web\")\n```\n\nLANGUAGE: HTTP Header Format\nCODE:\n```\napplication/grpc-web-text\n  * text-encoded streams of “application/grpc-web”\n  * e.g. application/grpc-web-text+[proto, thrift]\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Client using Shell Command\nDESCRIPTION: This shell snippet starts the sample gRPC client in a separate terminal, which will connect to the server started earlier. The client executable must have been built in advance, similarly to the server. Upon connection to the server, this client demonstrates the process of sending a sequence of messages and then handling an RPC cancellation.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/cancellation/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n./client\n```\n\n----------------------------------------\n\nTITLE: Invoking CMake and Make for Cross-Compilation of gRPC - Shell\nDESCRIPTION: These shell commands initiate a cross-compilation build of gRPC using CMake, specifying a toolchain file with the CMAKE_TOOLCHAIN_FILE variable, then build the project with make. A prerequisite is the creation and correct population of the toolchain file, and required host tools (protoc and grpc_cpp_plugin) must be available and built. The commands expect 'cmake' and 'make' to be installed and available in PATH. The first command configures the build with the appropriate compiler settings; the second actually starts the compilation process. Input: Path to toolchain file. Output: Compiled gRPC binaries.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_16\n\nLANGUAGE: sh\nCODE:\n```\n$ cmake ../.. -DCMAKE_TOOLCHAIN_FILE=path/to/file\n$ make\n```\n\n----------------------------------------\n\nTITLE: Client Compressed Streaming Test Procedure\nDESCRIPTION: This test verifies the client can compress requests on a per-message basis during a streaming call. It first probes for server support of CompressedRequest, then sends a compressed and an uncompressed message, asserting an INVALID_ARGUMENT status for the probe, successful subsequent calls, and the correct aggregated payload size.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n    {\n      expect_compressed:{\n        value: true\n      }\n      payload:{\n        body: 27182 bytes of zeros\n      }\n    }\n```\n\nLANGUAGE: text\nCODE:\n```\n    {\n      expect_compressed:{\n        value: true\n      }\n      payload:{\n        body: 27182 bytes of zeros\n      }\n    }\n```\n\nLANGUAGE: text\nCODE:\n```\n    {\n      expect_compressed:{\n        value: false\n      }\n      payload:{\n        body: 45904 bytes of zeros\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating and Linking gRPC/Protobuf Static Library in CMake\nDESCRIPTION: Defines a static library target named `hw_grpc_proto` composed of the generated gRPC and Protobuf C++ source and header files. Links this library against the required gRPC C++ (`_GRPC_GRPCPP`), Protobuf (`_PROTOBUF_LIBPROTOBUF`), and reflection (`_REFLECTION`) libraries.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/error_handling/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# hw_grpc_proto\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project for gRPC OpenTelemetry Example in C++\nDESCRIPTION: Initializes a CMake project for building a gRPC application with OpenTelemetry integration. Sets the minimum required CMake version and defines the project name with C and C++ language support.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(grpc_opentelemetry_example C CXX)\n\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Running Python Tooling Tests\nDESCRIPTION: This script runs tests for the Python tooling within the gRPC project. This includes a suite of tests to verify the correct functionality of various tools used for development, build, and other related tasks. It uses the \"run_python_tooling_tests.sh\" script.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n./tools/distrib/run_python_tooling_tests.sh\n```\n\n----------------------------------------\n\nTITLE: Updating boringssl Submodule and Syncing Across Build Systems using Shell Commands\nDESCRIPTION: This snippet provides step-by-step shell commands for updating the third_party/boringssl-with-bazel submodule to the latest state on the master-with-bazel branch. The process includes initializing submodules, fetching updates, checking out the desired state, and committing changes. Dependencies: a local git repository for grpc and access to the remote boringssl repository. Inputs: target branch or commit; Outputs: updated submodule and committed state. Key constraints include maintaining consistency across Bazel and other build systems and proper commit message conventions.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit submodule update --init      # just to start in a clean state\ncd third_party/boringssl-with-bazel\ngit fetch origin   # fetch what's new in the boringssl repository\ngit checkout origin/master-with-bazel  # checkout the current state of master-with-bazel branch in the boringssl repo\n# Note the latest commit SHA on master-with-bazel branch\ncd ../..   # go back to grpc repo root\ngit status   #  will show that there are new commits in third_party/boringssl-with-bazel\ngit add  third_party/boringssl-with-bazel     # we actually want to update the changes to the submodule\ngit commit -m \"update submodule boringssl-with-bazel with origin/master-with-bazel\"   # commit\n```\n\n----------------------------------------\n\nTITLE: Testing Malformed UTF-8: Unexpected Continuation Bytes\nDESCRIPTION: Tests the decoder's response to receiving UTF-8 continuation bytes (0x80-0xbf) without a preceding start byte. Includes single bytes, sequences of multiple continuation bytes, and the full range of all 64 possible continuation bytes. Each unexpected byte should ideally be signalled as a separate error.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/utf8_corpus_dir/utf8_corpus_kuhn.txt#_snippet_4\n\nLANGUAGE: UTF-8\nCODE:\n```\n3.1.1  First continuation byte 0x80: \"€\"                                      |\n3.1.2  Last  continuation byte 0xbf: \"¿\"                                      |\n\n3.1.3  2 continuation bytes: \"€¿\"                                             |\n3.1.4  3 continuation bytes: \"€¿€\"                                            |\n3.1.5  4 continuation bytes: \"€¿€¿\"                                           |\n3.1.6  5 continuation bytes: \"€¿€¿€\"                                          |\n3.1.7  6 continuation bytes: \"€¿€¿€¿\"                                         |\n3.1.8  7 continuation bytes: \"€¿€¿€¿€\"                                        |\n\n3.1.9  Sequence of all 64 possible continuation bytes (0x80-0xbf):            |\n                                                                              |\n   \"€ ‚ƒ„…†‡ˆ‰Š‹Œ Ž                                                           |\n     ‘’“”•–—˜™š›œ žŸ                                                          |\n     ¡¢£¤¥¦§¨©ª«¬­®¯                                                          |\n    °±²³´µ¶·¸¹º»¼½¾¿\"                                                         |\n```\n\n----------------------------------------\n\nTITLE: Defining and Linking Client/Server Executables - CMake\nDESCRIPTION: Uses a `foreach` loop to define executable targets for both the client and server. Each executable is defined using its corresponding source file (`client.cc` or `server.cc`) and then linked against the generated code library (`hw_grpc_proto`) and other required libraries including Abseil flags and logging, gRPC C++, and Protobuf.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/cancellation/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(_target\n  client server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    absl::strings\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Setting Compression for Individual RPC Method in gRPC Server Using Python\nDESCRIPTION: Shows how to disable compression on a per-RPC basis by calling context.set_compression with NoCompression inside the RPC implementation method SayHello. This overrides the server-level compression setting for this specific call. The method processes the request and returns a HelloReply message. Requires grpc and the relevant protobuf classes.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/compression/README.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef SayHello(self, request, context):\n    context.set_compression(grpc.Compression.NoCompression)\n    return helloworld_pb2.HelloReply(message='Hello, %s!' % request.name)\n```\n\n----------------------------------------\n\nTITLE: Compiling Protobuf and gRPC Stubs - protoc Command Line\nDESCRIPTION: Demonstrates how to invoke the `grpc_tools.protoc` module from the command line. This command compiles specified `.proto` files, generating Python code (`_pb2.py` and `_pb2_grpc.py`) into the output directory. Requires specifying include paths, output path, and input proto files.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/distrib/python/grpcio_tools/README.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npython -m grpc_tools.protoc -I$INCLUDE --python_out=$OUTPUT --grpc_python_out=$OUTPUT $PROTO_FILES\n```\n\n----------------------------------------\n\nTITLE: Configuring FullDuplexCall Request for Timeout Test (gRPC Interop Test, JSON Payload)\nDESCRIPTION: This snippet shows the request payload for the `FullDuplexCall` in the Timeout on Sleeping Server test. It includes a dummy payload body but notably lacks parameters to control the response size or speed, allowing the server to potentially delay and trigger the client's timeout.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"payload\":{\n    \"body\": \"27182 bytes of zeros\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example gRPC User-Agent Strings\nDESCRIPTION: Provides concrete examples of User-Agent strings conforming to the recommended format for different gRPC library implementations and platforms, such as grpc-java, grpc-ruby, and grpc-java-android with platform details.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#_snippet_3\n\nLANGUAGE: Examples\nCODE:\n```\ngrpc-java/1.2.3\ngrpc-ruby/1.2.3\ngrpc-ruby-jruby/1.3.4\ngrpc-java-android/0.9.1 (gingerbread/1.2.4; nexus5; tmobile)\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC SSL Server (Shell)\nDESCRIPTION: Executes the compiled `ssl_server` binary. This command starts the gRPC server, configured to use SSL/TLS credentials, which then listens for secure incoming connections on port 50051. It requires the server executable and the necessary credential files (`localhost.crt`, `localhost.key`, `root.crt`) to be present in the current directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/auth/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n./ssl_server\n```\n\n----------------------------------------\n\nTITLE: xDS bootstrap configuration (JSON)\nDESCRIPTION: This JSON configuration is required for xDS. It contains the URI of the xDS server and credentials configuration. The 'node' field should also be a valid JSON representation of the Node proto message.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/xds/README.md#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"xds_servers\": [\n    {\n      \"server_uri\": <string containing URI of xds server>,\n      \"channel_creds\": [\n        {\n          \"type\": <string containing channel cred type>,\n          \"config\": <JSON object containing config for the type>\n        }\n      ]\n    }\n  ],\n  \"node\": <JSON form of Node proto>\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting gRPC Client to Unix Domain Socket Server in Python\nDESCRIPTION: Command for running the synchronous greeter client that connects to the server via Unix Domain Sockets. The client demonstrates successful communication with both the relative and absolute socket paths.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/uds/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 greeter_client.py\nINFO:root:Received: Hello to unix:helloworld.sock!\nINFO:root:Received: Hello to unix:///tmp/helloworld.sock!\n```\n\n----------------------------------------\n\nTITLE: Building Objective-C Helloworld with Bazel\nDESCRIPTION: Runs the Bazel build command targeting the `HelloWorld` rule defined in the `examples/objective-c` BUILD file. This compiles the Objective-C helloworld project and its dependencies using the Bazel build system.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/README.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n$ bazel build :HelloWorld\n```\n\n----------------------------------------\n\nTITLE: Regenerate Health Check Service Definition - Bash\nDESCRIPTION: This command regenerates the health check service definition from the health.proto file. It requires protoc and the grpc_ruby_plugin to be installed and available in the PATH. The generated code is placed in the current directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/pb/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ # (from this directory)\n$ protoc -I ../../proto ../../proto/grpc/health/v1/health.proto \\\n    --grpc_out=. \\\n    --ruby_out=. \\\n    --plugin=protoc-gen-grpc=`which grpc_ruby_plugin`\n```\n\n----------------------------------------\n\nTITLE: Defining and Linking Generated Code Library - CMake\nDESCRIPTION: Defines a static library target named `hw_grpc_proto` containing the generated protobuf and gRPC source and header files. It then links this library against the necessary gRPC and protobuf libraries, which are expected to be found via the common CMake settings.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/cancellation/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Adding gRPC Proto Library to Podfile Using Local Path in Ruby\nDESCRIPTION: A snippet illustrating how to add a locally developed gRPC proto library specified by its Podspec file into an Xcode project's Podfile. The `pod` directive references the local path relative to the Podfile directory, allowing integration during `pod install` without requiring the library to be hosted in a remote source repository. This enables development and testing of proto libraries in local environments.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/objective-c/README.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\npod '<Podspec file name>', :path => 'path/to/the/directory/of/your/podspec'\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC SSL Client (Shell)\nDESCRIPTION: Executes the compiled `ssl_client` binary in a separate terminal after the server has started. This command initiates the gRPC client, which establishes a secure connection to the server at localhost:50051, using the `root.crt` file to verify the server's certificate. Successful execution results in the client printing a received message.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/auth/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n./ssl_client\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Logs Globally with absl Flags in Bash\nDESCRIPTION: This snippet enables verbose debug logging for the entire gRPC application by setting `--v=2` and `--minloglevel=0` flags. This increases the verbosity threshold to include INFO level logs and above, useful for extensive troubleshooting and debugging during development or problem diagnosis.\nSOURCE: https://github.com/grpc/grpc/blob/master/TROUBLESHOOTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./helloworld_application_using_grpc --v=2 --minloglevel=0\n```\n\n----------------------------------------\n\nTITLE: Custom setuptools Command for Protobuf Compilation (setup_requires workaround) - Python\nDESCRIPTION: Provides an example of creating a custom `setuptools.Command` class that wraps `grpc_tools.command.build_package_protos`. This pattern allows `grpcio-tools` to be specified in `setup_requires` and still be available for use by the build command during the setup process.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/distrib/python/grpcio_tools/README.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass BuildPackageProtos(setuptools.Command):\n  \"\"\"Command to generate project *_pb2.py modules from proto files.\"\"\"\n  # ...\n  def run(self):\n    from grpc_tools import command\n    command.build_package_protos(self.distribution.package_dir[''])\n```\n\n----------------------------------------\n\nTITLE: Initializing gRPC Client Channel with Gzip Compression in Python\nDESCRIPTION: Creates an insecure gRPC channel to a specified server address with Gzip compression enabled for all calls through this channel. Requires the grpc Python package. The channel object can then be used to make RPC calls that automatically use the chosen compression algorithm, reducing transmitted data size.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/compression/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nwith grpc.insecure_channel('foo.bar:1234', compression=grpc.Compression.Gzip) as channel:\n    use_channel(channel)\n```\n\n----------------------------------------\n\nTITLE: Bazel Remote Test Run on Linux with opt Configuration\nDESCRIPTION: This snippet shows the command to run Bazel tests remotely on a Linux machine using the specified bazelrc configuration for optimized builds. It requires the user to have set up prerequisites like Bazel installation and ADC credentials.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/remote_build/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbazel --bazelrc=tools/remote_build/linux.bazelrc test --config=opt //test/...\n```\n\n----------------------------------------\n\nTITLE: Building and Running the CentOS 7 Docker Image\nDESCRIPTION: Commands to build and run the CentOS 7 Docker image, which tests the gRPC extension against GCC 4.8.5 (default) and GCC 7.3.1 via devtoolset-7.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ cd grpc\n$ docker build -t grpc-gcc7/centos -f ./src/php/docker/centos7/Dockerfile .\n$ docker run -it --rm grpc-gcc7/centos\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Ruby client from shell\nDESCRIPTION: This shell command runs the gRPC Ruby client example, which initiates a connection to the running server and exercises the RPC calls defined in the gRPC service. The use of 'bundle exec' ensures the needed gems are loaded.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/ruby/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ # from this directory\n$ bundle exec ./greeter_client.rb\n```\n\n----------------------------------------\n\nTITLE: Creating Client and Server Executables for gRPC Application\nDESCRIPTION: Defines two executable targets, 'client' and 'server', each compiled from their respective source files. Both targets link against the gRPC proto library, Abseil flags, flags_parse, log initialization, strings, and other dependencies to enable gRPC client-server functionality.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/deadline/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(_target\n  client server)\n  add_executable(${_target} \"${_target}.cc\")\n  target_link_libraries(${_target}\n    hw_grpc_proto\n    absl::flags\n    absl::flags_parse\n    absl::log_initialize\n    absl::strings\n    ${_REFLECTION}\n    ${_GRPC_GRPCPP}\n    ${_PROTOBUF_LIBPROTOBUF})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC Code using Protoc (Shell)\nDESCRIPTION: Shows the underlying `protoc` commands invoked by the `make` target to generate the gRPC C++ code. The first command generates the gRPC service interface using the C++ plugin, and the second command generates the protocol buffer message classes.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ protoc -I ../../protos/ --grpc_out=. --plugin=protoc-gen-grpc=grpc_cpp_plugin ../../protos/helloworld.proto\n$ protoc -I ../../protos/ --cpp_out=. ../../protos/helloworld.proto\n```\n\n----------------------------------------\n\nTITLE: Creating CallCredentials from AuthMetadataPlugin in gRPC Python\nDESCRIPTION: Demonstrates how to create CallCredentials from an AuthMetadataPlugin instance using the grpc.metadata_call_credentials function. This CallCredentials object can then be used to add authentication metadata to individual RPC calls. The function takes the plugin instance and an optional name as input.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/auth/README.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef metadata_call_credentials(metadata_plugin, name=None):\n    \"\"\"Construct CallCredentials from an AuthMetadataPlugin.\n\n    Args:\n      metadata_plugin: An AuthMetadataPlugin to use for authentication.\n      name: An optional name for the plugin.\n\n    Returns:\n      A CallCredentials.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Verbose Tracing Logs in gRPC Python\nDESCRIPTION: Environment variable configuration for enabling the most verbose tracing logs in gRPC applications. This setting will output detailed debug information for all components, which is useful for comprehensive debugging but may impact performance.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/debug/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nGRPC_VERBOSITY=debug\nGRPC_TRACE=all\n```\n\n----------------------------------------\n\nTITLE: Installing Composer Dependencies for Generated Code Tests - Shell Script\nDESCRIPTION: Runs 'composer install' in the gRPC PHP source directory to resolve and install PHP dependencies necessary for tests that involve protocol buffer code generated from .proto files. Composer must be installed and available.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_17\n\nLANGUAGE: sh\nCODE:\n```\n$ cd grpc/src/php\n$ composer install\n```\n\n----------------------------------------\n\nTITLE: Fetching and Unpacking Debug Gem | RubyGems | bash\nDESCRIPTION: Provides the `bash` commands necessary to download (`gem fetch`) and extract (`gem unpack`) the `grpc-native-debug` gem. Ensure the gem version and platform match the `grpc` binary gem you are debugging.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/nativedebug/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd /home\ngem fetch grpc-native-debug-1.60.1.x86_64-linux.gem\ngem unpack grpc-native-debug-1.60.1.x86_64-linux.gem\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Project for Proto Files using .NET CLI\nDESCRIPTION: Bash commands to create a new, empty C# project for working with .proto files. Creates a class library, removes default C# files, and adds the Grpc.Tools package.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ndotnet new classlib\nrm *.cs              # remove .cs files - for Windows the command is: del *.cs /y\ndotnet add package Grpc.Tools\n```\n\n----------------------------------------\n\nTITLE: Defining Library for Generated Code and Linking Dependencies\nDESCRIPTION: This snippet defines a static or shared library target named `kvs_grpc_proto` using the generated C++ source and header files. It then links this library to necessary dependencies like Abseil check utilities, Protobuf reflection, gRPC C++ core (`_GRPC_GRPCPP`), and the core Protobuf library (`_PROTOBUF_LIBPROTOBUF`).\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/interceptors/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# kvs_grpc_proto\nadd_library(kvs_grpc_proto\n  ${kvs_grpc_srcs}\n  ${kvs_grpc_hdrs}\n  ${kvs_proto_srcs}\n  ${kvs_proto_hdrs})\ntarget_link_libraries(kvs_grpc_proto\n  absl::check\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Defining Protobuf File Paths\nDESCRIPTION: This block retrieves the absolute path to the helloworld.proto file and its directory. These paths are used later to generate the C++ source files from the protobuf definition. The `get_filename_component` command is used to extract the absolute path and the path component from the protobuf file.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/generic_api/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Proto files\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n```\n\n----------------------------------------\n\nTITLE: Combiner Class with Mutex\nDESCRIPTION: This snippet shows a basic combiner class that uses a mutex to serialize the execution of functions. The `run()` method locks the mutex, executes the provided function `f()`, and then unlocks the mutex. This ensures that functions passed to the combiner are executed serially.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/core/combiner-explainer.md#_snippet_1\n\nLANGUAGE: \nCODE:\n```\nclass combiner {\n  run(f) {\n    mu.lock()\n    f()\n    mu.unlock()\n  }\n  mutex mu;\n}\n\ncombiner.run(do_stuff)\n```\n\n----------------------------------------\n\nTITLE: Creating 'hw_grpc_proto' Library Target\nDESCRIPTION: Assembles a static library from the generated gRPC and protobuf source and header files, linking with reflection, gRPC++ library, and protobuf library variables for code reuse and dependency management.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/codelab/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(hw_grpc_proto\n  ${hw_grpc_srcs}\n  ${hw_grpc_hdrs}\n  ${hw_proto_srcs}\n  ${hw_proto_hdrs})\ntarget_link_libraries(hw_grpc_proto\n  ${_REFLECTION}\n  ${_GRPC_GRPCPP}\n  ${_PROTOBUF_LIBPROTOBUF})\n```\n\n----------------------------------------\n\nTITLE: Large Unary Call Test Procedure\nDESCRIPTION: This test verifies unary calls succeed in sending large messages and touches on flow control. The client calls UnaryCall with a specified response size and payload, asserting a successful call, the correct response payload size, and optionally verifying the response payload contents.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n    {\n      response_size: 314159\n      payload:{\n        body: 271828 bytes of zeros\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Enabling write batching in gRPC C++ streams\nDESCRIPTION: This snippet shows how to enable message write batching in gRPC C++ streams by passing a WriteOptions with buffer_hint set to optimize performance when message dependencies do not require immediate responses. It helps reduce syscall overhead and improve throughput for non-dependent message sequences.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/cpp/perf_notes.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstream_writer->Write(message, WriteOptions().set_buffer_hint());\n```\n\n----------------------------------------\n\nTITLE: Regenerate gRPC Interop Test Service Definition - Bash\nDESCRIPTION: This command regenerates the gRPC interop test service definition from the messages.proto, test.proto, and empty.proto files. It requires protoc, the grpc_ruby_plugin, and the gRPC repository to be checked out. The generated code is placed in the current directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/pb/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ # (from this directory within the grpc repo)\n$ protoc -I../../.. ../../../test/proto/{messages,test,empty}.proto \\\n    --grpc_out=. \\\n    --ruby_out=. \\\n    --plugin=protoc-gen-grpc=`which grpc_ruby_plugin`\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC C++ Code using Protoc (Shell)\nDESCRIPTION: Shows the underlying protoc commands used by 'make' to generate gRPC service and message code. It invokes the protocol buffer compiler (protoc) with the gRPC C++ plugin to generate code from the helloworld.proto definition. Requires protoc and the grpc_cpp_plugin.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/compression/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ protoc -I ../../protos/ --grpc_out=. --plugin=protoc-gen-grpc=grpc_cpp_plugin ../../protos/helloworld.proto\n$ protoc -I ../../protos/ --cpp_out=. ../../protos/helloworld.proto\n```\n\n----------------------------------------\n\nTITLE: Adding Build Directory to Include Paths - CMake\nDESCRIPTION: This command adds the CMake binary/build directory to the list of directories searched for include files. This is necessary so that source files can include the generated header files (`.pb.h`, `.grpc.pb.h`).\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/retry/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Alternative gpr_free implementation using reference parameters\nDESCRIPTION: Another considered but rejected solution for GRP-01-002 that would use C++ reference parameters to automatically null pointers, which was deemed non-compliant with C89 and against Google's style guide.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/security_audit.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\ngpr_free (void*& ptr) {\n  ...\n  ptr = nullptr;\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP/2 Framing for gRPC Unary Response\nDESCRIPTION: Illustrates the structure of an HTTP/2 response for a gRPC unary call. Includes initial headers (:status, grpc-encoding, content-type), one or more DATA frames, and trailing headers (grpc-status, trace-proto-bin) which indicate the RPC result and metadata.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#_snippet_1\n\nLANGUAGE: HTTP/2\nCODE:\n```\nHEADERS (flags = END_HEADERS)\n:status = 200\ngrpc-encoding = gzip\ncontent-type = application/grpc+proto\n\nDATA\n<Length-Prefixed Message>\n\nHEADERS (flags = END_STREAM, END_HEADERS)\ngrpc-status = 0 # OK\ntrace-proto-bin = jher831yy13JHy3hc\n```\n\n----------------------------------------\n\nTITLE: Server Compressed Unary Call Test Procedure\nDESCRIPTION: This test verifies the server can compress unary messages by sending two requests and expecting the server's response to be compressed based on the `response_compressed` boolean. It asserts the correct compression flag in the response and the expected response payload size.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n    {\n      response_compressed:{\n        value: true\n      }\n      response_size: 314159\n      payload:{\n        body: 271828 bytes of zeros\n      }\n    }\n```\n\nLANGUAGE: text\nCODE:\n```\n    {\n      response_compressed:{\n        value: false\n      }\n      response_size: 314159\n      payload:{\n        body: 271828 bytes of zeros\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Detecting CPU Count for Multiprocessing with Python\nDESCRIPTION: This code snippet uses the `multiprocessing` module to detect the number of CPUs available on the system. It stores the result in the `_PROCESS_COUNT` variable. This information is then leveraged to spawn the appropriate number of child processes, which helps maximize the utilization of available hardware resources.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/multiprocessing/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n_PROCESS_COUNT = multiprocessing.cpu_count()\n```\n\n----------------------------------------\n\nTITLE: Disabling Protobuf Compilation During Design-Time Builds in C# Projects\nDESCRIPTION: XML configuration that disables protobuf compilation during Visual Studio design-time builds. This can be added to project files to revert to the old behavior where protobuf files aren't compiled during design-time builds.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/Grpc.Tools/implementation_notes.md#_snippet_0\n\nLANGUAGE: XML\nCODE:\n```\n<PropertyGroup Condition=\"'$(DesignTimeBuild)' == 'true' \">\n    <DisableProtobufDesignTimeBuild>true</DisableProtobufDesignTimeBuild>\n</PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: gRPC Error Classes in AsyncIO Python API\nDESCRIPTION: This snippet lists the exception classes used for error handling in gRPC AsyncIO Python API, including general base errors, usage errors, aborts, internal errors, and RPC-specific errors. These exceptions help manage and debug RPC lifecycle issues.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n.. autoexception:: BaseError\n.. autoexception:: UsageError\n.. autoexception:: AbortError\n.. autoexception:: InternalError\n.. autoexception:: AioRpcError\n```\n\n----------------------------------------\n\nTITLE: Inspecting message types on gRPC server using grpc_cli in Shell\nDESCRIPTION: Command to display the protobuf definition of a message type by specifying its fully qualified name using grpc_cli type. This queries the server’s reflection service to show the structure of request or response message types used by gRPC services.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$ grpc_cli type localhost:50051 helloworld.HelloRequest\n```\n\n----------------------------------------\n\nTITLE: Installing From PyPI\nDESCRIPTION: This command is used to install the grpcio-csm-observability package from the Python Package Index (PyPI).  It leverages the pip package installer to download and install the specified package and its dependencies. This installation method assumes that pip is correctly configured and available in the system's PATH.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/grpcio_csm_observability/README.rst#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ pip install grpcio-csm-observability\n```\n\n----------------------------------------\n\nTITLE: Setting Target Properties using CMake\nDESCRIPTION: Sets common properties for the created library targets (`utf8_range` and `utf8_validity`). The `VERSION` property sets the library version, and `OUTPUT_NAME` allows specifying a custom output filename, incorporating a potential `LIB_PREFIX` variable.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(utf8_range PROPERTIES\n  VERSION ${protobuf_VERSION}\n  OUTPUT_NAME ${LIB_PREFIX}utf8_range\n)\nset_target_properties(utf8_validity PROPERTIES\n  VERSION ${protobuf_VERSION}\n  OUTPUT_NAME ${LIB_PREFIX}utf8_validity\n)\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Alpine Docker Image\nDESCRIPTION: Commands to build and run the Alpine Docker image, which builds the gRPC extension in an Alpine Linux environment to test compatibility with this lightweight distribution.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ cd grpc\n$ docker build -t grpc-php/alpine -f ./src/php/docker/alpine/Dockerfile .\n$ docker run -it --rm grpc-php/alpine\n```\n\n----------------------------------------\n\nTITLE: Installing NASM Prerequisite on Windows (Chocolatey) - Batch\nDESCRIPTION: Installs the NASM assembler using the Chocolatey package manager (`choco`) on Windows. NASM is a required dependency for BoringSSL, which is used by gRPC.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_6\n\nLANGUAGE: batch\nCODE:\n```\nchoco install nasm\n```\n\n----------------------------------------\n\nTITLE: Running C++ Server with Bazel\nDESCRIPTION: Runs the Bazel run command targeting the `greeter_server` rule in the C++ helloworld example. This builds the C++ server if necessary and then executes it, providing the required server endpoint for the Objective-C client.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/README.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$ bazel run //examples/cpp/helloworld:greeter_server\n```\n\n----------------------------------------\n\nTITLE: Installing CMake Prerequisite on Linux (apt) - Shell\nDESCRIPTION: Installs the `cmake` build tool on Debian-based Linux distributions using `apt-get`. This is required if planning to build gRPC C++ using CMake.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n $ [sudo] apt-get install cmake\n```\n\n----------------------------------------\n\nTITLE: Installing Python Headers (Fix for Python.h error) - apt-get\nDESCRIPTION: Provides a shell command using apt-get to install the `python-dev` package, which typically contains the `Python.h` header file needed to resolve compiler errors during source installation or building from source distributions.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/distrib/python/grpcio_tools/README.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install python-dev\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version and Project\nDESCRIPTION: This snippet sets the minimum required version of CMake and defines the project name and the languages used (C and CXX). It also includes a common CMake configuration file, likely containing shared settings or helper functions.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/interceptors/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(KeyValueStore C CXX)\n\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Client Streaming Test Procedure\nDESCRIPTION: This test verifies that client-only streaming succeeds.  The client calls StreamingInputCall and sends multiple messages with varying payload sizes, then half-closes. It asserts a successful call and the expected aggregated payload size in the response.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n    {\n      payload:{\n        body: 27182 bytes of zeros\n      }\n    }\n```\n\nLANGUAGE: text\nCODE:\n```\n    {\n      payload:{\n        body: 8 bytes of zeros\n      }\n    }\n```\n\nLANGUAGE: text\nCODE:\n```\n    {\n      payload:{\n        body: 1828 bytes of zeros\n      }\n    }\n```\n\nLANGUAGE: text\nCODE:\n```\n    {\n      payload:{\n        body: 45904 bytes of zeros\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Description of Utility Code Directory in Markdown\nDESCRIPTION: A markdown document explaining the purpose and content of the utility code directory, which contains C++ utility libraries and platform abstractions that are not gRPC-specific.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/core/util/README.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# Utility Code\n\nThe files in this directory contain various utility libraries and platform\nabstractions for C++ code.  None of this code is gRPC-specific; anything\nhere may also be useful for other open source projects written in C++.\nIn principle, any library here could be replaced with an external\ndependency that provides the same functionality if such an external\nlibrary should become available.\n\nNote that this is one of the few places in src/core where we allow\nthe use of portability macros.\n```\n\n----------------------------------------\n\nTITLE: Listing iOS Simulator Runtimes\nDESCRIPTION: Executes the `xcrun simctl list` command to show a list of available devices and runtimes that can be used with the iOS simulator on the current machine. This information is needed to specify the target simulator when running the Bazel-built iOS app.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/objective-c/helloworld/README.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n$ xcrun simctl list\n```\n\n----------------------------------------\n\nTITLE: Bazel Remote Test Run with Sanitizer on Linux\nDESCRIPTION: This command allows running Bazel tests remotely with specific sanitizers like ASAN, MSAN, TSAN, or UBSAN, on a Linux platform. Proper configuration of Bazel and remote credentials is required.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/remote_build/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbazel --bazelrc=tools/remote_build/linux.bazelrc test --config=asan //test/...\n```\n\n----------------------------------------\n\nTITLE: Including Generated Header Directory\nDESCRIPTION: This command adds the directory where the Protobuf and gRPC C++ headers are generated to the list of directories searched for header files. This ensures that source files can include the generated `.pb.h` and `.grpc.pb.h` files.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/interceptors/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Include generated *.pb.h files\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Listing gRPC Servers with grpcdebug (Bash)\nDESCRIPTION: Uses the `grpcdebug` tool to connect to a running gRPC server at a specified address (`localhost:50051`) and execute the `channelz servers` command. This command queries and displays a list of active servers and their basic statistics.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/debugging/README.md#_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\ngrpcdebug localhost:50051 channelz servers\n```\n\n----------------------------------------\n\nTITLE: Installing Build Tool Prerequisites on macOS (Homebrew) - Shell\nDESCRIPTION: Installs required build tools (`autoconf`, `automake`, `libtool`, `shtool`) using the Homebrew package manager on macOS. These are needed for building gRPC C++ from source using Make.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n $ brew install autoconf automake libtool shtool\n```\n\n----------------------------------------\n\nTITLE: Verifying Server Reflection using grpc_cli\nDESCRIPTION: A shell command using `grpc_cli` to list the services available on a gRPC server running locally on port 50051. This command is used to verify that server reflection has been enabled correctly and that the expected services (including the reflection service itself) are discoverable.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/server_reflection.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngrpc_cli ls localhost:50051\n```\n\n----------------------------------------\n\nTITLE: Building gRPC C++ CSM Server Docker Image Using Dockerfile (Shell)\nDESCRIPTION: This snippet shows the command to build the Docker image for the gRPC C++ CSM server using the Dockerfile located at examples/cpp/csm/Dockerfile.server. Executing this command packages the server service into a container image for deployment or testing in environments supporting Docker containers.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/csm/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ndocker build -f examples/cpp/csm/Dockerfile.server\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Minimum Version and Project\nDESCRIPTION: Sets the minimum required CMake version to 3.16 and defines the project name as 'grpc_opentelemetry_example' with C and C++ as language components. Includes common configuration via an external CMake script.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/otel/codelab/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(grpc_opentelemetry_example C CXX)\n\ninclude(../../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Directory Path Reference in Markdown\nDESCRIPTION: Shows the path to the codegen directory being documented, written in Markdown heading format.\nSOURCE: https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/README.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# Welcome to `include/grpc/impl/codegen`\n```\n\n----------------------------------------\n\nTITLE: Building and Running the php-src Docker Image\nDESCRIPTION: Commands to build and run the php-src Docker image, which compiles PHP from source with custom configure options like --enable-debug before building the gRPC extension.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ cd grpc\n$ docker build -t grpc-php/php-src -f ./src/php/docker/php-src/Dockerfile .\n$ docker run -it --rm grpc-php/php-src\n```\n\n----------------------------------------\n\nTITLE: Starting the gRPC Server with Unix Domain Sockets in Python\nDESCRIPTION: Command for running the synchronous greeter server that listens on Unix Domain Socket paths. The server binds to both a relative path 'helloworld.sock' and an absolute path '/tmp/helloworld.sock'.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/uds/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 greeter_server.py\nINFO:root:Server listening on: unix:helloworld.sock\nINFO:root:Server listening on: unix:///tmp/helloworld.sock\n...\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC Code using Make (Shell)\nDESCRIPTION: Uses the `make` command to generate the necessary C++ gRPC interface code (`helloworld.grpc.pb.cc` and `helloworld.pb.cc` files) from the `helloworld.proto` definition located in the `protos` directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/metadata/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ make helloworld.grpc.pb.cc helloworld.pb.cc\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Ruby server from shell\nDESCRIPTION: This snippet runs the gRPC Ruby server example in the background, allowing it to listen for client requests. The command uses 'bundle exec' to execute the server script within the bundle environment to ensure correct dependencies are loaded.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/ruby/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ # from this directory\n$ bundle exec ./greeter_server.rb &\n```\n\n----------------------------------------\n\nTITLE: Recommended gRPC User-Agent Format\nDESCRIPTION: Specifies the recommended format for the User-Agent header in gRPC client implementations. The format includes a 'grpc-' prefix, the programming language, an optional variant, the version, and optional additional properties within parentheses.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#_snippet_2\n\nLANGUAGE: Pseudocode\nCODE:\n```\nUser-Agent → \"grpc-\" Language ?(\"-\" Variant) \"/\" Version ?( \" (\"  *(AdditionalProperty \";\") \")\" )\n```\n\n----------------------------------------\n\nTITLE: Reporting Out-of-Band gRPC Metrics in C++\nDESCRIPTION: Shows how to report metrics that are not associated with a specific ongoing request (out-of-band). This uses the `ServerMetricRecorder` instance created during server initialization directly to set metrics like overall server CPU utilization.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/orca/README.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nserver_metric_recorder->SetCpuUtilization(0.75);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Absolute Path for Proto File\nDESCRIPTION: Calculates the absolute path of the 'helloworld.proto' proto file, which is needed for protobuf code generation. Ensures correct referencing regardless of execution directory.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/deadline/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(hw_proto \"../../protos/helloworld.proto\" ABSOLUTE)\nget_filename_component(hw_proto_path \"${hw_proto}\" PATH)\n```\n\n----------------------------------------\n\nTITLE: Local Bazel Test Run on MacOS\nDESCRIPTION: This command executes Bazel tests on a Mac locally, mimicking remote build behavior by uploading results to the ResultStore. It requires starting the port server before running tests.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/remote_build/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbazel --bazelrc=tools/remote_build/mac.bazelrc test --config=opt //test/...\n```\n\n----------------------------------------\n\nTITLE: Setting minimum CMake version\nDESCRIPTION: Specifies the minimum required version of CMake for the project. This ensures that the CMake version used is compatible with the commands and features used in the build file. It prevents errors due to outdated CMake versions.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Building Windows RBE Docker Image\nDESCRIPTION: This snippet demonstrates how to build the Windows RBE Docker image using the Docker command. It specifies the tag for the image and the path to the Dockerfile. The image is built on a Kokoro debug windows VM.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/toolchains/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ndocker build -t us-docker.pkg.dev/grpc-testing/testing-images-public/rbe_windows2019 third_party/toolchains/dockerfile/rbe_windows2019\n```\n\n----------------------------------------\n\nTITLE: Generating gRPC C++ Code using Make (Shell)\nDESCRIPTION: Uses the 'make' command to compile the .proto file and generate the necessary gRPC C++ client and server interface code (helloworld.grpc.pb.cc and helloworld.pb.cc). Requires make and the necessary gRPC C++ build dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/compression/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ make helloworld.grpc.pb.cc helloworld.pb.cc\n```\n\n----------------------------------------\n\nTITLE: Stream-Stream Pattern in gRPC Python\nDESCRIPTION: In this bidirectional streaming pattern, both client and server can send multiple messages to each other in a single call. Implemented through bidirectional_streaming_method in client.py and BidirectionalStreamingMethod in server.py.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/data_transmission/README.en.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nbidirectional_streaming_method\nBidirectionalStreamingMethod\n```\n\n----------------------------------------\n\nTITLE: Suppressing BoringSSL Memory Leaks in Configuration\nDESCRIPTION: A list of function names in BoringSSL that have known memory leaks which should be suppressed by memory testing tools. Each line specifies a function with the 'leak:' prefix to indicate it should be ignored during memory leak detection.\nSOURCE: https://github.com/grpc/grpc/blob/master/test/core/test_util/lsan_suppressions.txt#_snippet_0\n\nLANGUAGE: configuration\nCODE:\n```\n# this is busted in BoringSSL\nleak:CRYPTO_set_thread_local\nleak:err_get_state\nleak:ERR_add_error_dataf\nleak:err_add_error_vdata\nleak:RAND_bytes_with_additional_data\n```\n\n----------------------------------------\n\nTITLE: Setting gRPC Trace Flags (Shell)\nDESCRIPTION: Demonstrates how to set the GRPC_TRACE environment variable in a shell environment to enable a specific set of trace flags. This example enables all available traces ('*') but explicitly disables the 'pending_tags' trace.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/trace_flags.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nexport GRPC_TRACE=*,-pending_tags\n```\n\n----------------------------------------\n\nTITLE: Authenticating for Docker Push\nDESCRIPTION: This command configures Docker to authenticate with Google Artifact Registry (GAR). This is a prerequisite for pushing the built Docker image to GAR. The command uses the gcloud CLI tool.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/toolchains/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ngcloud auth configure-docker us-docker.pkg.dev\n```\n\n----------------------------------------\n\nTITLE: Starting the Flaky Server\nDESCRIPTION: This shell command starts the flaky server, written in Python, which simulates errors during RPC calls. The server listens on port 50051. This script is a prerequisite for testing the retry client.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/retry/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npython3 flaky_server.py\n```\n\n----------------------------------------\n\nTITLE: Navigating to the PHP Example Directory\nDESCRIPTION: Changes the current working directory to the specific gRPC PHP echo example directory (`grpc/examples/php/echo`). This is a prerequisite step before running the commands to build and execute the PHP client examples.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/php/echo/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ cd grpc/examples/php/echo\n```\n\n----------------------------------------\n\nTITLE: Cloning gRPC Repository and Initializing Submodules on Windows - Batch\nDESCRIPTION: Clones the gRPC repository from GitHub for a specific release tag (`RELEASE_TAG_HERE`) and initializes its necessary submodules on Windows using `git` commands in the command prompt. This step is required before building from source with build systems like CMake.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_9\n\nLANGUAGE: batch\nCODE:\n```\n> git clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc\n> cd grpc\n> git submodule update --init\n```\n\n----------------------------------------\n\nTITLE: Bazel Remote Test Run on Windows\nDESCRIPTION: This snippet runs Bazel tests remotely on a Windows machine using a specific bazelrc configuration for Windows. Ensure executing from a Windows environment and using the correct Bazel version.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/remote_build/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbazel --bazelrc=tools/remote_build/windows.bazelrc test --config=windows_opt //test/...\n```\n\n----------------------------------------\n\nTITLE: Enabling gRPC Extension in php.ini - Shell Script\nDESCRIPTION: Adds or ensures the 'extension=grpc.so' directive is present in the php.ini file, enabling the PHP runtime to load the gRPC extension at startup. The php.ini file location depends on OS and PHP configuration.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nextension=grpc.so\n```\n\n----------------------------------------\n\nTITLE: Testing Malformed UTF-8: Lonely 4-Byte Start Characters\nDESCRIPTION: Tests the decoder's response to receiving the first byte of potential 4-byte sequences (bytes 0xf0-0xf7) when they are not followed by the required three continuation bytes (here, followed by a space). These start bytes require three subsequent continuation bytes and should be treated as errors without them.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/utf8_corpus_dir/utf8_corpus_kuhn.txt#_snippet_7\n\nLANGUAGE: UTF-8\nCODE:\n```\n   \"ð ñ ò ó ô õ ö ÷ \"\n```\n\n----------------------------------------\n\nTITLE: Creating gRPC server in AsyncIO Python API\nDESCRIPTION: This snippet highlights the function for creating a gRPC server instance in the AsyncIO Python API. The server object handles incoming RPC requests, manages server lifecycle, and supports registering service implementations.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n.. autofunction:: server\n```\n\n----------------------------------------\n\nTITLE: Including Common CMake Settings - CMake\nDESCRIPTION: Includes a common CMake configuration file located in the parent directory's 'cmake' folder. This allows sharing common build settings and macros across different gRPC examples.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/cancellation/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Installing grpcio-tools from PyPI (Windows) - cmd\nDESCRIPTION: Installs the `grpcio-tools` package on Windows from the Python Package Index (PyPI) using the pip executable. May require running the command prompt as administrator.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/distrib/python/grpcio_tools/README.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip.exe install grpcio-tools\n```\n\n----------------------------------------\n\nTITLE: Install gRPC Dependency with npm\nDESCRIPTION: Use this command to install the official gRPC package for Node.js projects. It adds the @grpc/grpc-js package to the project's dependencies via the Node Package Manager (npm).\nSOURCE: https://github.com/grpc/grpc/blob/master/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install @grpc/grpc-js\n```\n\n----------------------------------------\n\nTITLE: Including Generated *.pb.h Files Directory\nDESCRIPTION: Adds the directory containing the generated protobuf header files to the include path, ensuring the compiler can locate the headers during build.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/deadline/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Running gRPC Keepalive Client (C++)\nDESCRIPTION: This command executes the gRPC keepalive client using Bazel. It demonstrates how to start the client component of the keepalive example.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/keepalive/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ tools/bazel run examples/cpp/keepalive:greeter_callback_client\n```\n\n----------------------------------------\n\nTITLE: Requesting Text-Encoded gRPC-Web Responses\nDESCRIPTION: Shows how a gRPC-Web client uses the `Accept` HTTP header to request a text-encoded (Base64) response stream. This is often necessary when using technologies like XHR or due to security policies that restrict binary streaming.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md#_snippet_4\n\nLANGUAGE: HTTP Header Format\nCODE:\n```\nAccept: application/grpc-web-text\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC to use OpenSSL in Podfile\nDESCRIPTION: This snippet shows how to include a modified gRPC-Core podspec in your Podfile.  It assumes that you have copied the gRPC-Core.podspec file into your app's repository.  This setup allows you to customize gRPC's dependencies. It adds a custom podspec which allows overriding the default BoringSSL dependency. The `:podspec => \".\"` option specifies the location of the modified podspec.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/objective-c/README.md#_snippet_5\n\nLANGUAGE: Ruby\nCODE:\n```\npod `gRPC-Core`, :podspec => \".\" # assuming gRPC-Core.podspec is in the same directory as your Podfile\n```\n\n----------------------------------------\n\nTITLE: Referencing clang-format script path in Markdown\nDESCRIPTION: A Markdown link that references the location of the clang-format script in the tools/distrib directory, which is used to format C++ code according to the project's style requirements.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/cpp-style-guide.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n[tools/distrib/clang_format_code.sh](../tools/distrib/clang_format_code.sh)\n```\n\n----------------------------------------\n\nTITLE: Install gRPC Dependency with gem\nDESCRIPTION: Add the gRPC runtime library to a Ruby project using the RubyGems package manager. This command fetches and installs the grpc gem and its required dependencies.\nSOURCE: https://github.com/grpc/grpc/blob/master/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\ngem install grpc\n```\n\n----------------------------------------\n\nTITLE: Verifying application-layer service with grpcurl (shell)\nDESCRIPTION: This command uses `grpcurl` to send a request to the gRPC server and verify the response.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/xds/README.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n> grpcurl --plaintext -d '{\"name\": \"you\"}' localhost:50051\n{\n  \"message\": \"Hello you from rbell.svl.corp.google.com!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Installing grpcio-tools from PyPI (Local User) - bash\nDESCRIPTION: Installs the `grpcio-tools` package locally for the current user from the Python Package Index (PyPI) using the pip package installer.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/distrib/python/grpcio_tools/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install grpcio-tools\n```\n\n----------------------------------------\n\nTITLE: Multi-Callable Interface classes in AsyncIO Python API\nDESCRIPTION: This snippet includes classes for different RPC call types, such as UnaryUnaryMultiCallable, UnaryStreamMultiCallable, StreamUnaryMultiCallable, and StreamStreamMultiCallable. These classes represent the primary interfaces for invoking RPCs with various streaming patterns asynchronously.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: UnaryUnaryMultiCallable\n.. autoclass:: UnaryStreamMultiCallable\n.. autoclass:: StreamUnaryMultiCallable\n.. autoclass:: StreamStreamMultiCallable\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC Generic API Client (Shell)\nDESCRIPTION: Command to run the example gRPC client (`greeter_client`) which connects to the running server (expected on localhost:50051) and sends requests using the generic API implementation.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/generic_api/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ ./greeter_client\n```\n\n----------------------------------------\n\nTITLE: Getting Service and Method Descriptors in C++\nDESCRIPTION: Code to retrieve service and method descriptors from a DescriptorPool in a C++ client using Server Reflection.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_reflection_tutorial.md#_snippet_9\n\nLANGUAGE: c++\nCODE:\n```\nconst google::protobuf::ServiceDescriptor* service_desc =\n    desc_pool->FindServiceByName(\"helloworld.Greeter\");\nconst google::protobuf::MethodDescriptor* method_desc =\n    desc_pool->FindMethodByName(\"helloworld.Greeter.SayHello\");\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake to build the project. This ensures that necessary CMake features are available.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/multiplex/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Building and Testing gRPC for a Specific Language\nDESCRIPTION: Builds the gRPC library for a specified target language and then runs all associated unit tests. Replace `YOUR_LANGUAGE` with the desired language identifier (e.g., `c++`, `ruby`). Requires Python and necessary language-specific build/test environments.\nSOURCE: https://github.com/grpc/grpc/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\npython tools/run_tests/run_tests.py -l YOUR_LANGUAGE\n```\n\n----------------------------------------\n\nTITLE: Installing gRPC Protoc Plugin Using Shell Script in macOS Terminal\nDESCRIPTION: This shell command downloads and installs the Protocol Buffers compiler (_protoc_) along with the gRPC Objective-C plugin using a convenience install script tailored for macOS and later systems with Homebrew installed. It ensures the correct versions of protoc and the gRPC plugin are installed on the development machine. Caution is advised as manual installations can cause version conflicts especially if Cocoapods is also used to manage plugin versions.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/objective-c/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ curl -fsSL https://goo.gl/getgrpc | bash -\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project for HelloWorld Example\nDESCRIPTION: Sets up the CMake project with minimum required version and project name for the HelloWorld example.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/health/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(HelloWorld C CXX)\n\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC server with secure credentials (shell)\nDESCRIPTION: This command runs the gRPC server with the `--secure true` flag, enabling secure communication.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/xds/README.md#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\npython server.py --secure true\n```\n\n----------------------------------------\n\nTITLE: Configuring Request for Special Status Message Echo (gRPC Interop Test, JSON Payload)\nDESCRIPTION: This snippet defines the payload for the `UnaryCall` in the Special Status Message test. It includes a status `code` (UNAVAILABLE, 2) and a `message` containing various whitespace and Unicode characters to be echoed by the server.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"response_status\":{\n    \"code\": 2,\n    \"message\": \"\\t\\ntest with whitespace\\r\\nand Unicode BMP ☺ and non-BMP 😈\\t\\n\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running the gRPC C++ Client (Shell)\nDESCRIPTION: Executes the compiled client binary (greeter_client) to send requests to the running server. Assumes the code has been built and the server is running.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/compression/README.md#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\n./greeter_client\n```\n\n----------------------------------------\n\nTITLE: Building gRPC CLI Tool\nDESCRIPTION: Commands to build the gRPC CLI tool which can be used to test services with Server Reflection.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_reflection_tutorial.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nmake grpc_cli\ncd bins/opt\n```\n\n----------------------------------------\n\nTITLE: Inspecting Message Types with gRPC CLI\nDESCRIPTION: Command to inspect the structure of a message type using the gRPC CLI tool.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/server_reflection_tutorial.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n$ grpc_cli type localhost:50051 helloworld.HelloRequest\n```\n\n----------------------------------------\n\nTITLE: Server Interceptor class in AsyncIO Python API\nDESCRIPTION: This snippet details the ServerInterceptor class, which allows interception and modification of server-side RPC handling, enabling functionalities such as authorization, logging, or request/response transformations.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: ServerInterceptor\n```\n\n----------------------------------------\n\nTITLE: Server-Side Context class in AsyncIO Python API\nDESCRIPTION: This snippet introduces the ServicerContext class, which manages the context for server-side RPC handlers, including details of the RPC lifecycle, metadata, status codes, and methods for controlling RPC responses.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/python/sphinx/grpc_asyncio.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n.. autoclass:: ServicerContext\n```\n\n----------------------------------------\n\nTITLE: Enabling pcntl_fork Support in gRPC Extension - Shell Script\nDESCRIPTION: Adjusts php.ini settings to enable fork support and sets poll strategy for the gRPC extension when using pcntl_fork or related process control functions. Ensures stable operation of forked PHP gRPC clients under UNIX environments.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_21\n\nLANGUAGE: sh\nCODE:\n```\ngrpc.enable_fork_support = 1\ngrpc.poll_strategy = epoll1\n```\n\n----------------------------------------\n\nTITLE: Importing well-known types in Protobuf\nDESCRIPTION: This snippet shows importing well-known types in a .proto file. The path for protobuf's well-known types is automatically included, so explicit specification in `AdditionalImportDirs` is not required.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_11\n\nLANGUAGE: Protobuf\nCODE:\n```\nimport \"google/protobuf/wrappers.proto\";\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Bazel Test Target - Bazel CLI - Bash\nDESCRIPTION: This command executes a specific target test within the Bazel environment for gRPC Python. It runs the logging_pool_test located in the specified path using standalone execution strategies for reliability. Dependencies include a Bazel-enabled workspace with the necessary Python test targets available. The parameter after 'bazel test' specifies the Bazel test target, while optional flags (not shown) may control output verbosity. Input: none. Output: test result summary for the specified test target.\nSOURCE: https://github.com/grpc/grpc/blob/master/summerofcode/2018/naresh.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbazel test --spawn_strategy=standalone --genrule_strategy=standalone //src/python/grpcio_tests/tests/unit/framework/foundation:logging_pool_test\n```\n\n----------------------------------------\n\nTITLE: Running gRPC C/C++ Tests with Bazel - Shell\nDESCRIPTION: Executes all C/C++ tests within the gRPC repository using Bazel with the debug configuration (`--config=dbg`). This command should be run from the root of the cloned gRPC repository. Note: May require `--enable_bzlmod=false` for Bazel 7+.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\n# Run all the C/C++ tests\n$ bazel test --config=dbg //test/...\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Test Method with Arguments - Bazel CLI - Bash\nDESCRIPTION: This command enables the execution of a particular test method in a Bazel-targeted Python test file by passing an additional test argument specifying the method name. It requires a workspace with Bazel, the designated Python test, and command-line access. The '--test_arg' parameter is used to pass down the desired method to be invoked within the selected Bazel target. Inputs: none; Outputs: outputs from the specified test method execution.\nSOURCE: https://github.com/grpc/grpc/blob/master/summerofcode/2018/naresh.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbazel test --spawn_strategy=standalone --genrule_strategy=standalone //src/python/grpcio_tests/tests/unit/_rpc_test --test_arg=RPCTest.testUnrecognizedMethod\n```\n\n----------------------------------------\n\nTITLE: TSAN Suppression Configuration for OpenSSL and Protocol Buffers\nDESCRIPTION: Configuration directives for Thread Sanitizer (TSAN) to suppress known benign race conditions in external dependencies. The suppression rules target specific functions in OpenSSL (cleansing and random number generation) and Protocol Buffers (size calculation methods) that have known race conditions that are either being addressed or are benign by design.\nSOURCE: https://github.com/grpc/grpc/blob/master/test/core/test_util/tsan_suppressions.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# OPENSSL_cleanse does racy access to a global\nrace:OPENSSL_cleanse\nrace:cleanse_ctr\n# these are legitimate races in OpenSSL, and it appears those folks are looking at it\n# https://www.mail-archive.com/openssl-dev@openssl.org/msg09019.html\nrace:ssleay_rand_add\nrace:ssleay_rand_bytes\nrace:__sleep_for\n# protobuf has an idempotent write race in ByteSize/GetCachedSize\n# https://github.com/protocolbuffers/protobuf/issues/2169\nrace:ByteSize\nrace:ByteSizeLong\nrace:GetCachedSize\n```\n\n----------------------------------------\n\nTITLE: Building gRPC Python from Source - Shell\nDESCRIPTION: Step-by-step commands for cloning the gRPC repository, initializing submodules, setting optional build flags, and installing required dependencies before building gRPC Python from source. It requires Python development headers (e.g., python-dev) and may involve setting environment variables to include features like systemd socket activation or build with Cython. Users are cautioned that building from source on Windows is not officially supported.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/grpcio/README.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ export REPO_ROOT=grpc  # REPO_ROOT can be any directory of your choice\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ git clone -b RELEASE_TAG_HERE https://github.com/grpc/grpc $REPO_ROOT\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ cd $REPO_ROOT\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ git submodule update --init\n```\n\nLANGUAGE: shell\nCODE:\n```\n# To include systemd socket-activation feature in the build,\\n# first install the `libsystemd-dev` package, then :\\n$ export GRPC_PYTHON_BUILD_WITH_SYSTEMD=1\n```\n\nLANGUAGE: shell\nCODE:\n```\n# For the next two commands do `sudo pip install` if you get permission-denied errors\\n$ pip install -r requirements.txt\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ GRPC_PYTHON_BUILD_WITH_CYTHON=1 pip install .\n```\n\n----------------------------------------\n\nTITLE: Building gRPC Library with ExternalProject\nDESCRIPTION: Configures the build for the gRPC library with all its dependencies. Sets package providers for dependencies and configures installation paths.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/cmake_externalproject/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nExternalProject_Add(grpc\n  PREFIX grpc\n  SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../../../..\"\n  CMAKE_CACHE_ARGS\n        -DCMAKE_INSTALL_PREFIX:PATH=${CMAKE_CURRENT_BINARY_DIR}/grpc\n        -DCMAKE_CXX_STANDARD:STRING=17\n        -DgRPC_INSTALL:BOOL=ON\n        -DgRPC_BUILD_TESTS:BOOL=OFF\n        -DgRPC_BUILD_MSVC_MP_COUNT:STRING=-1\n        -Dutf8_range_DIR:STRING=${CMAKE_CURRENT_BINARY_DIR}/utf8_range/lib/cmake/utf8_range\n        -DgRPC_PROTOBUF_PROVIDER:STRING=package\n        -DProtobuf_DIR:PATH=${CMAKE_CURRENT_BINARY_DIR}/protobuf/lib/cmake/protobuf\n        -DgRPC_RE2_PROVIDER:STRING=package\n        -Dre2_DIR:STRING=${CMAKE_CURRENT_BINARY_DIR}/re2/lib/cmake/re2\n        -DgRPC_ZLIB_PROVIDER:STRING=package\n        -DZLIB_ROOT:STRING=${CMAKE_CURRENT_BINARY_DIR}/zlib\n        -DgRPC_ABSL_PROVIDER:STRING=package\n        -Dabsl_DIR:STRING=${CMAKE_CURRENT_BINARY_DIR}/absl/lib/cmake/absl\n        -DgRPC_CARES_PROVIDER:STRING=package\n        -Dc-ares_DIR:PATH=${CMAKE_CURRENT_BINARY_DIR}/c-ares/lib/cmake/c-ares\n        -DgRPC_SSL_PROVIDER:STRING=package\n        ${_CMAKE_ARGS_OPENSSL_ROOT_DIR}\n  DEPENDS c-ares protobuf re2 zlib absl\n)\n```\n\n----------------------------------------\n\nTITLE: Building gRPC C++ with Bazel - Shell\nDESCRIPTION: Builds all gRPC C++ targets using the Bazel build system. This command should be run from the root of the cloned gRPC repository. Bazel is the recommended build system. Note: Requires Bazel 1.0.0+ and may require `--enable_bzlmod=false` for Bazel 7+.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\n# Build gRPC C++\n$ bazel build :all\n```\n\n----------------------------------------\n\nTITLE: Setting Custom EventEngine Factory in C++ Test Main\nDESCRIPTION: Provides the `main` function entry point for the custom EventEngine test executable. It initializes the Google Test framework, sets a global factory function that creates instances of the custom `MyCustomEventEngine`, and then runs all defined tests. This allows the test framework to use the custom engine implementation during execution.\nSOURCE: https://github.com/grpc/grpc/blob/master/test/core/event_engine/test_suite/README.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include \"path/to/my_custom_event_engine.h\"\n#include \"test/core/event_engine/test_suite/event_engine_test_framework.h\"\n\nint main(int argc, char** argv) {\n  testing::InitGoogleTest(&argc, argv);\n  SetEventEngineFactory(\n      []() { return absl::make_unique<MyCustomEventEngine>(); });\n  auto result = RUN_ALL_TESTS();\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Building All Docker Images for gRPC PHP Testing\nDESCRIPTION: Command to build all Docker images for testing the gRPC PHP extension. It can be run from the root directory of the gRPC project. Optional parameters allow building selected images or just printing the commands.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cd grpc\n$ ./src/php/bin/build_all_docker_images.sh\n```\n\n----------------------------------------\n\nTITLE: Building and Running the grpc-ext Docker Image\nDESCRIPTION: Commands to build and run the grpc-ext Docker image, which builds the full gRPC PECL extension and runs unit tests against the current PHP version.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/docker/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ cd grpc\n$ docker build -t grpc-php/grpc-ext -f ./src/php/docker/grpc-ext/Dockerfile .\n$ docker run -it --rm grpc-php/grpc-ext\n```\n\n----------------------------------------\n\nTITLE: Generating Project Files using generate_projects.sh\nDESCRIPTION: This command regenerates the project files and other generated files using templates defined in the project. It utilizes the `tools/buildgen/generate_projects.sh` script to process the `build.yaml` file and generate project files based on templates. This action is essential for maintaining the project files and updating them when code is added, removed or modified.\nSOURCE: https://github.com/grpc/grpc/blob/master/templates/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntools/buildgen/generate_projects.sh\n```\n\n----------------------------------------\n\nTITLE: Defining Helper Library in CMake\nDESCRIPTION: Creates a CMake library target named `helper` from the source files `helper.h` and `helper.cc`. This library likely contains shared utility functions or common code used by both the client and server executables within the example.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/auth/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# example helper\nadd_library(helper\n  \"helper.h\"\n  \"helper.cc\")\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC-Web Message Frame Type using MSB\nDESCRIPTION: Specifies how the Most Significant Bit (MSB) of the first byte in a gRPC-Web message frame distinguishes between data frames (MSB=0) and trailer frames (MSB=1). A trailer frame can be uncompressed (byte value 10000000b) or compressed (byte value 10000001b). Trailers must be the last message.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md#_snippet_2\n\nLANGUAGE: Binary Format\nCODE:\n```\n10000000b: an uncompressed trailer (as part of the body)\n10000001b: a compressed trailer\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for gRPC Helloworld Example in CMake\nDESCRIPTION: This snippet specifies the minimum CMake version, defines the project name with language support, and includes common CMake configuration files necessary for a gRPC C++ project. Dependencies like gRPC and Protobuf are assumed to be available and installed. The project accommodates both C and C++ codebases as indicated by the languages listed.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/load_balancing/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nproject(LoadBalancing C CXX)\n\ninclude(../cmake/common.cmake)\n```\n\n----------------------------------------\n\nTITLE: Workqueue Run Function\nDESCRIPTION: This snippet shows the `run` function of the `workqueue`. It pushes the function onto a queue and then wakes up an eventfd to signal that there is work to be done.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/core/combiner-explainer.md#_snippet_6\n\nLANGUAGE: \nCODE:\n```\nworkqueue::run(f) {\n  q.push(f)\n  eventfd.wakeup()\n}\n```\n\n----------------------------------------\n\nTITLE: Workqueue Readable Function\nDESCRIPTION: This code demonstrates the `readable` function of the `workqueue`. It consumes the eventfd, pops a function from the queue, and executes it. If the queue is not empty, it wakes up the eventfd again to spray the event across multiple threads.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/core/combiner-explainer.md#_snippet_7\n\nLANGUAGE: \nCODE:\n```\nworkqueue::readable() {\n  eventfd.consume();\n  q.pop(&f);\n  f();\n  if (!q.empty()) {\n    eventfd.wakeup(); // spray across as many threads as are waiting on this workqueue\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling OpenSSL Root Directory for External Projects\nDESCRIPTION: Sets up OpenSSL root directory configuration to propagate to external projects that have an OpenSSL dependency.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/cmake_externalproject/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nset(_CMAKE_ARGS_OPENSSL_ROOT_DIR \"\")\nif (OPENSSL_ROOT_DIR)\n  set(_CMAKE_ARGS_OPENSSL_ROOT_DIR \"-DOPENSSL_ROOT_DIR:PATH=${OPENSSL_ROOT_DIR}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Listing Debug Symbol Files | grpc-native-debug Gem | Filesystem\nDESCRIPTION: Illustrates the directory structure and naming convention of `.dbg` symbol files found within an unpacked `grpc-native-debug` gem. Each file corresponds to a specific Ruby minor version supported by the corresponding `grpc` binary gem.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/nativedebug/README.md#_snippet_0\n\nLANGUAGE: filesystem\nCODE:\n```\ngrpc-native-debug-1.60.1-x86_64-linux/symbols/grpc-1.60.1-x86_64-linux-ruby-3.0.dbg\ngrpc-native-debug-1.60.1-x86_64-linux/symbols/grpc-1.60.1-x86_64-linux-ruby-2.7.dbg\ngrpc-native-debug-1.60.1-x86_64-linux/symbols/grpc-1.60.1-x86_64-linux-ruby-3.2.dbg\ngrpc-native-debug-1.60.1-x86_64-linux/symbols/grpc-1.60.1-x86_64-linux-ruby-3.1.dbg\n```\n\n----------------------------------------\n\nTITLE: Defining Project\nDESCRIPTION: Defines the project name and supported languages (C and C++). This allows CMake to properly configure the build system for the HelloWorld project, identifying it and setting up the necessary compiler flags for C and C++.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nproject(HelloWorld C CXX)\n```\n\n----------------------------------------\n\nTITLE: Installing Ninja Prerequisite on Windows (Chocolatey) - Batch\nDESCRIPTION: Optionally installs the Ninja build system using the Chocolatey package manager (`choco`) on Windows. Ninja can provide faster builds when used with CMake.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_7\n\nLANGUAGE: batch\nCODE:\n```\nchoco install ninja\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Project\nDESCRIPTION: Defines the project name 'Multiplex' and specifies the programming languages used in the project (C and C++).\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/multiplex/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(Multiplex C CXX)\n```\n\n----------------------------------------\n\nTITLE: Regenerating gRPC Project Files\nDESCRIPTION: Executes a script to regenerate language- and platform-specific build system project files based on templates. This is necessary after modifying template files or when build sanity checks fail. Requires Python packages `pyyaml` and `mako`, and a recent Go installation.\nSOURCE: https://github.com/grpc/grpc/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ntools/buildgen/generate_projects.sh\n```\n\n----------------------------------------\n\nTITLE: Creating Writable gRPC Log File via Shell Script\nDESCRIPTION: Creates a log file with writable permissions using sudo and chmod. Ensures that the process running the PHP gRPC client can write logs for debugging or troubleshooting purposes. Should be executed in a directory appropriate for logs, such as /var/log.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_23\n\nLANGUAGE: sh\nCODE:\n```\n$ sudo touch /var/log/grpc.log\n$ sudo chmod 666 /var/log/grpc.log\n```\n\n----------------------------------------\n\nTITLE: Installing Contributor Prerequisites for Sanitizer Builds on Linux (apt) - Shell\nDESCRIPTION: Installs `clang` and `libc++-dev` on Debian-based Linux distributions using `apt-get`. These are needed by contributors who intend to build and run tests, specifically for sanitizer builds.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n $ # clang and LLVM C++ lib is only required for sanitizer builds\n $ [sudo] apt-get install clang libc++-dev\n```\n\n----------------------------------------\n\nTITLE: Building the Benchmark Driver - Bash\nDESCRIPTION: This snippet shows the build step for the benchmark driver executable using the 'build_performance.sh' script from the gRPC root repository. The driver must be built prior to running distributed or local benchmarks. Requires all driver and worker dependencies already installed and build tools available in the environment.\nSOURCE: https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ tools/run_tests/performance/build_performance.sh\n```\n\n----------------------------------------\n\nTITLE: Setting LIBTOOL Environment Variables for Make on macOS - Shell\nDESCRIPTION: Demonstrates how to explicitly set the `LIBTOOL` and `LIBTOOLIZE` environment variables when running `make` on macOS to ensure the versions installed by Homebrew (`glibtool`, `glibtoolize`) are used instead of the system defaults.\nSOURCE: https://github.com/grpc/grpc/blob/master/BUILDING.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n $ LIBTOOL=glibtool LIBTOOLIZE=glibtoolize make\n```\n\n----------------------------------------\n\nTITLE: Setup for Using Grpc.Tools on Alpine Linux\nDESCRIPTION: Bash commands for using Grpc.Tools with Alpine Linux, which is an unsupported architecture in the package. Installs community-provided packages and sets environment variables to tell Grpc.Tools where to find the protocol compiler and plugin.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n# Build or install the binaries for your architecture.\n\n# e.g. for Alpine Linux the grpc-plugins package can be used\n#  See https://pkgs.alpinelinux.org/package/edge/community/x86_64/grpc-plugins\napk add grpc-plugins  # Alpine Linux specific package installer\n\n# Set environment variables for the built/installed protoc\n# and grpc_csharp_plugin binaries\nexport PROTOBUF_PROTOC=/usr/bin/protoc\nexport GRPC_PROTOC_PLUGIN=/usr/bin/grpc_csharp_plugin\n\n# When the dotnet build runs the Grpc.Tools NuGet package will\n# use the binaries pointed to by the environment variables\ndotnet build\n```\n\n----------------------------------------\n\nTITLE: Running Generated Code Tests Client - Shell Script\nDESCRIPTION: Runs the script 'run_gen_code_test.sh' to execute integration tests using generated PHP gRPC clients and stubs against running test servers. Assumes all dependencies, including node-based test servers, are running.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/php/README.md#_snippet_19\n\nLANGUAGE: sh\nCODE:\n```\n$ cd grpc/src/php\n$ ./bin/run_gen_code_test.sh\n```\n\n----------------------------------------\n\nTITLE: Expected Client Output for gRPC Deadline Example\nDESCRIPTION: Sample output showing the results of the deadline tests, including successful requests, exceeded deadlines, and the propagation of deadlines between service calls.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/deadline/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n[Successful request] wanted = 0, got = 0\n[Exceeds deadline] wanted = 4, got = 4\n[Successful request with propagated deadline] wanted = 0, got = 0\n[Exceeds propagated deadline] wanted = 4, got = 4\n```\n\n----------------------------------------\n\nTITLE: Running All Python Unit Tests (Bazel)\nDESCRIPTION: This Bazel command runs all Python unit tests within the gRPC project.  It utilizes the bazel test command with a wildcard to select all tests under the specified directory. The \"--cache_test_results=no\" flag ensures that the tests are run without using cached results. This is useful for verifying all test cases pass.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/python/CONTRIBUTING.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nbazel test --cache_test_results=no \"//src/python/...\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom EventEngine Factory Function in C++\nDESCRIPTION: Implements the `CustomEventEngineFactory` function required by standalone tools like the echo client. This function returns an `absl::AnyInvocable` that, when called, produces a `std::unique_ptr` to an `EventEngine` instance, demonstrating the instantiation of a specific engine like `WindowsEventEngine`. This provides the tool with a way to obtain instances of the custom engine it needs to operate.\nSOURCE: https://github.com/grpc/grpc/blob/master/test/core/event_engine/test_suite/README.md#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n# tools/my_event_engine_factory.cc: an implementation of CustomEventEngineFactory\nabsl::AnyInvocable<\n    std::unique_ptr<grpc_event_engine::experimental::EventEngine>(void)>\nCustomEventEngineFactory() {\n  return []() {\n    return std::make_unique<\n        grpc_event_engine::experimental::WindowsEventEngine>();\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Updating utf8_range Dependency using Shell Instructions\nDESCRIPTION: This snippet demonstrates how to manually replace and update the utf8_range dependency with the current version from its upstream repository using shell commands. The commands set up the root path, download the zip archive, remove the old content, unzip, and rename the directory. Dependencies: wget, unzip, and suitable permissions. Inputs: zip file URL; Outputs: refreshed utf8_range directory. This process is necessary to ensure the latest upstream changes are incorporated.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nexport GRPC_ROOT=~/git/grpc\nwget https://github.com/protocolbuffers/utf8_range/archive/refs/heads/main.zip\nrm -rf $GRPC_ROOT/third_party/utf8_range\nunzip main.zip -d $GRPC_ROOT/third_party\nmv $GRPC_ROOT/third_party/utf8_range-main $GRPC_ROOT/third_party/utf8_range\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC EventEngine Tool with Bazel BUILD\nDESCRIPTION: Defines a `grpc_cc_binary` target for building a standalone tool (like the echo client) that utilizes a custom EventEngine. It specifies the binary name, the source file containing the custom factory, and depends on the specific tool library (\"echo_client\"). This configuration enables Bazel to build an executable version of the tool linked against the custom engine factory.\nSOURCE: https://github.com/grpc/grpc/blob/master/test/core/event_engine/test_suite/README.md#_snippet_2\n\nLANGUAGE: Bazel BUILD\nCODE:\n```\n# tools/BUILD:\ngrpc_cc_binary(\n    name = \"my_event_engine_echo_client\",\n    srcs = [\"my_event_engine_factory.cc\"],\n    deps = [\"echo_client\"],\n)\n```\n\n----------------------------------------\n\nTITLE: Updating upb Dependency using Shell Instructions\nDESCRIPTION: This set of shell commands details the manual update procedure for the upb dependency, which is vendored in the repository and cannot be managed as a submodule. The steps include downloading the protobuf release, clearing the previous version, unzipping, copying directories, and preparing regenerated files. Required dependencies: curl/wget, unzip, and access to the protobuf release. Inputs: target protobuf release archive; Outputs: updated upb directory. This process assumes sufficient filesystem permissions.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nexport GRPC_ROOT=~/git/grpc\nwget https://github.com/protocolbuffers/protobuf/releases/download/v25.1/protobuf-25.1.zip\nrm -rf $GRPC_ROOT/third_party/upb\nunzip protobuf-25.1.zip -d /tmp/protobuf\ncp -r /tmp/protobuf/protobuf-25.1/upb $GRPC_ROOT/third_party/upb\n```\n\n----------------------------------------\n\nTITLE: Checking Source File Availability (Initial) | gdb | gdb\nDESCRIPTION: Shows that even after loading symbols, `gdb` may still report that source files are missing or cannot be found at the paths compiled into the symbols. This requires adding the source directories to `gdb`'s search path.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/nativedebug/README.md#_snippet_5\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) up\n#1  0x00007ffff383eb9e in do_epoll_wait (ps=0x555555ad1690, deadline=...) at src/core/lib/iomgr/ev_epoll1_linux.cc:723\n723\tsrc/core/lib/iomgr/ev_epoll1_linux.cc: No such file or directory.\n(gdb) list\n718\tin src/core/lib/iomgr/ev_epoll1_linux.cc\n(gdb)\n```\n\n----------------------------------------\n\nTITLE: UnaryCall Request Payload Structure\nDESCRIPTION: This JSON snippet represents the payload structure of a UnaryCall request used in various test cases. It specifies the `response_size` and the payload `body`, filled with a specific number of zero bytes. This is used as a standard request for testing different HTTP/2 behaviors.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/http2-interop-test-descriptions.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"response_size\": 314159,\n  \"payload\":{\n    \"body\": 271828 bytes of zeros\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Source File Availability (Partial) | gdb | gdb\nDESCRIPTION: Shows the result of using `gdb list` after adding the base source directory. Some source files may now be found and displayed, but others located in subdirectories might still be reported as missing.\nSOURCE: https://github.com/grpc/grpc/blob/master/src/ruby/nativedebug/README.md#_snippet_8\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) list\nwarning: Source file is more recent than executable.\n718\t  int timeout = poll_deadline_to_millis_timeout(deadline);\n719\t  if (timeout != 0) {\n720\t    GRPC_SCHEDULING_START_BLOCKING_REGION;\n721\t  }\n722\t  do {\n723\t    r = epoll_wait(g_epoll_set.epfd, g_epoll_set.events, MAX_EPOLL_EVENTS,\n724\t                   timeout);\n725\t  } while (r < 0 && errno == EINTR);\n726\t  if (timeout != 0) {\n727\t    GRPC_SCHEDULING_END_BLOCKING_REGION;\n(gdb)\n```\n\n----------------------------------------\n\nTITLE: Navigating to the Compression Example Directory (Shell)\nDESCRIPTION: Changes the current working directory to the C++ compression example within the cloned gRPC repository. This command should be run after successfully cloning the repository.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/cpp/compression/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ cd examples/cpp/compression/\n```\n\n----------------------------------------\n\nTITLE: Testing Malformed UTF-8: Lonely 6-Byte Start Characters\nDESCRIPTION: Tests the decoder's response to receiving the first byte of potential 6-byte sequences (bytes 0xfc-0xfd) when they are not followed by the required five continuation bytes (here, followed by a space). These start bytes are invalid according to modern UTF-8 standards (RFC 3629) regardless of following bytes and should always be treated as errors.\nSOURCE: https://github.com/grpc/grpc/blob/master/third_party/utf8_range/utf8_corpus_dir/utf8_corpus_kuhn.txt#_snippet_9\n\nLANGUAGE: UTF-8\nCODE:\n```\n   \"ü ý \"\n```\n\n----------------------------------------\n\nTITLE: Configuring Request for Username Echo (gRPC Interop Test, JSON Payload)\nDESCRIPTION: This snippet shows the payload for a `UnaryCall` in the Compute Engine Channel Credentials test. Setting `fill_username` to `true` instructs the server to echo the authenticated username in the response.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"fill_username\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Request for Status Echo (gRPC Interop Test, JSON Payload)\nDESCRIPTION: This snippet shows the payload used in the Status Code and Message test for both `UnaryCall` and `FullDuplexCall`. It specifies a desired status `code` (UNAVAILABLE, 2) and `message` for the server to echo back.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"response_status\":{\n    \"code\": 2,\n    \"message\": \"test status message\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Initial FullDuplexCall Request for Cancellation Test (gRPC Interop Test, JSON Payload)\nDESCRIPTION: This snippet shows the initial request payload for the `FullDuplexCall` in the Cancel After First Response test. It requests a response of a specific size and includes a dummy payload.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"response_parameters\":{\n    \"size\": 31415\n  },\n  \"payload\":{\n    \"body\": \"27182 bytes of zeros\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Empty Request (gRPC Interop Test, JSON Payload)\nDESCRIPTION: This snippet represents the empty request payload used when calling a method on an unimplemented service. It corresponds to the `grpc.testing.Empty` message type, indicating no input parameters are required.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{}\n```\n\n----------------------------------------\n\nTITLE: Modifying gpr_free to automatically null pointers\nDESCRIPTION: A considered but rejected solution for GRP-01-002 where gpr_free would be modified to take a pointer to a pointer and automatically null it after freeing the memory.\nSOURCE: https://github.com/grpc/grpc/blob/master/doc/security_audit.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\ngpr_free (void** ptr) {\n  ...\n  *ptr = nullptr;\n}\n```\n\n----------------------------------------\n\nTITLE: No code snippets provided\nDESCRIPTION: The provided text does not contain any explicit code snippets to document.\nSOURCE: https://github.com/grpc/grpc/blob/master/examples/python/async_streaming/README.md#_snippet_0\n\n"
  }
]