[
  {
    "owner": "gorilla",
    "repo": "mux",
    "content": "TITLE: Basic Router Setup in Go with Gorilla Mux\nDESCRIPTION: Basic example of creating a router and registering route handlers for different URL paths.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/\", HomeHandler)\n    r.HandleFunc(\"/products\", ProductsHandler)\n    r.HandleFunc(\"/articles\", ArticlesHandler)\n    http.Handle(\"/\", r)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Full Basic Gorilla Mux Server Example in Go\nDESCRIPTION: This complete, runnable Go example demonstrates the minimal setup for a `mux`-based HTTP server. It initializes a router, registers a simple handler (`YourHandler`) for the root path (`/`), and starts the server listening on port 8000.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_35\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    \"net/http\"\n    \"log\"\n    \"github.com/gorilla/mux\"\n)\n\nfunc YourHandler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Gorilla!\\n\"));\n}\n\nfunc main() {\n    r := mux.NewRouter();\n    // Routes consist of a path and a handler function.\n    r.HandleFunc(\"/\", YourHandler);\n\n    // Bind to a port and pass our router in\n    log.Fatal(http.ListenAndServe(\":8000\", r));\n}\n```\n\n----------------------------------------\n\nTITLE: Using URL Path Variables in Gorilla Mux Routes\nDESCRIPTION: Example of defining routes with URL path variables using the {name} or {name:pattern} syntax, including regex pattern matching.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nr := mux.NewRouter()\nr.HandleFunc(\"/products/{key}\", ProductHandler)\nr.HandleFunc(\"/articles/{category}/\", ArticlesCategoryHandler)\nr.HandleFunc(\"/articles/{category}/{id:[0-9]+}\", ArticleHandler)\n```\n\n----------------------------------------\n\nTITLE: Accessing URL Variables in Request Handlers with Gorilla Mux\nDESCRIPTION: Example of retrieving URL path variables from the request using the mux.Vars() function.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc ArticlesCategoryHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    w.WriteHeader(http.StatusOK)\n    fmt.Fprintf(w, \"Category: %v\\n\", vars[\"category\"])\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Method Matching in Gorilla Mux\nDESCRIPTION: Restricting routes to specific HTTP methods (GET, POST, etc.).\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nr.Methods(\"GET\", \"POST\")\n```\n\n----------------------------------------\n\nTITLE: Adding Middleware to gorilla/mux Router\nDESCRIPTION: Defines middleware functions conforming to the standard type that wrap request handlers, allowing tasks like logging, authentication, and other preprocessing. Middlewares are added to routers using the Use() method and execute in order for matching routes.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_27\n\nLANGUAGE: Go\nCODE:\n```\nfunc loggingMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        log.Println(r.RequestURI)\n        next.ServeHTTP(w, r)\n    })\n}\n\n// Usage:\nr := mux.NewRouter()\nr.HandleFunc(\"/\", handler)\nr.Use(loggingMiddleware)\n\n// Authentication middleware example:\ntype authenticationMiddleware struct {\n    tokenUsers map[string]string\n}\n\nfunc (amw *authenticationMiddleware) Populate() {\n    amw.tokenUsers[\"00000000\"] = \"user0\"\n    amw.tokenUsers[\"aaaaaaaa\"] = \"userA\"\n    amw.tokenUsers[\"05f717e5\"] = \"randomUser\"\n    amw.tokenUsers[\"deadbeef\"] = \"user0\"\n}\n\nfunc (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        token := r.Header.Get(\"X-Session-Token\")\n        if user, found := amw.tokenUsers[token]; found {\n            log.Printf(\"Authenticated user %s\\n\", user)\n            next.ServeHTTP(w, r)\n        } else {\n            http.Error(w, \"Forbidden\", http.StatusForbidden)\n        }\n    })\n}\n\n// Usage:\nr := mux.NewRouter()\nr.HandleFunc(\"/\", handler)\n\namw := authenticationMiddleware{tokenUsers: make(map[string]string)}\namw.Populate()\nr.Use(amw.Middleware)\n```\n\n----------------------------------------\n\nTITLE: Serving Static Files with Gorilla Mux\nDESCRIPTION: Complete example of setting up a server to serve static files from a directory using PathPrefix and http.FileServer.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n    var dir string\n\n    flag.StringVar(&dir, \"dir\", \".\", \"the directory to serve files from. Defaults to the current dir\")\n    flag.Parse()\n    r := mux.NewRouter()\n\n    // This will serve files under http://localhost:8000/static/<filename>\n    r.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(dir))))\n\n    srv := &http.Server{\n        Handler:      r,\n        Addr:         \"127.0.0.1:8000\",\n        // Good practice: enforce timeouts for servers you create!\n        WriteTimeout: 15 * time.Second,\n        ReadTimeout:  15 * time.Second,\n    }\n\n    log.Fatal(srv.ListenAndServe())\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Matchers in Gorilla Mux\nDESCRIPTION: Example of chaining multiple matchers to create a route with specific requirements.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nr.HandleFunc(\"/products\", ProductsHandler).\n  Host(\"www.example.com\").\n  Methods(\"GET\").\n  Schemes(\"http\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Graceful Shutdown of an HTTP Server with gorilla/mux\nDESCRIPTION: Sets up an HTTP server with timeouts and listens for termination signals (like SIGINT). Upon receiving a signal, it gracefully shuts down the server by allowing ongoing connections to complete within a specified timeout period.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_26\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"os/signal\"\n    \"time\"\n\n    \"github.com/gorilla/mux\"\n)\n\nfunc main() {\n    var wait time.Duration\n    flag.DurationVar(&wait, \"-graceful-timeout\", time.Second * 15, \"the duration for which the server gracefully waits for existing connections to finish\")\n    flag.Parse()\n\n    r := mux.NewRouter()\n    // Add routes here\n\n    srv := &http.Server{\n        Addr: \"0.0.0.0:8080\",\n        WriteTimeout: time.Second * 15,\n        ReadTimeout: time.Second * 15,\n        IdleTimeout: time.Second * 60,\n        Handler: r,\n    }\n\n    go func() {\n        if err := srv.ListenAndServe(); err != nil {\n            log.Println(err)\n        }\n    }()\n\n    c := make(chan os.Signal, 1)\n    signal.Notify(c, os.Interrupt)\n    <-c\n\n    ctx, cancel := context.WithTimeout(context.Background(), wait)\n    defer cancel()\n    srv.Shutdown(ctx)\n    log.Println(\"shutting down\")\n    os.Exit(0)\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Named Route with HandleFunc in gorilla/mux\nDESCRIPTION: Defines a route with a URL pattern including variables, assigning it a name for URL reversing. Uses mux.NewRouter() to create a router, then maps the pattern '/articles/{category}/{id:[0-9]+}' to a handler function, naming it 'article'.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_18\n\nLANGUAGE: Go\nCODE:\n```\nr := mux.NewRouter()\n r.HandleFunc(\"/articles/{category}/{id:[0-9]+}\", ArticleHandler).\n   Name(\"article\")\n```\n\n----------------------------------------\n\nTITLE: Building a URL from a Named Route with Parameters in gorilla/mux\nDESCRIPTION: Fetches a route by its name and generates a URL by passing key-value pairs for variables such as 'category' and 'id'. Returns a url.URL object with the constructed path '/articles/technology/42'.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_19\n\nLANGUAGE: Go\nCODE:\n```\nurl, err := r.Get(\"article\").URL(\"category\", \"technology\", \"id\", \"42\")\n```\n\n----------------------------------------\n\nTITLE: Path Prefix Subrouters in Gorilla Mux\nDESCRIPTION: Creating a subrouter with a path prefix where inner routes inherit the prefix path.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nr := mux.NewRouter()\ns := r.PathPrefix(\"/products\").Subrouter()\n// \"/products/\"\ns.HandleFunc(\"/\", ProductsHandler)\n// \"/products/{key}/\"\ns.HandleFunc(\"/{key}/\", ProductHandler)\n// \"/products/{key}/details\"\ns.HandleFunc(\"/{key}/details\", ProductDetailsHandler)\n```\n\n----------------------------------------\n\nTITLE: Path Prefix Matching in Gorilla Mux\nDESCRIPTION: Using PathPrefix matcher to match the beginning of URL paths.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nr.PathPrefix(\"/products/\")\n```\n\n----------------------------------------\n\nTITLE: Serving Single Page Applications with Gorilla Mux\nDESCRIPTION: Complete example of creating a server that serves both an API and a Single Page Application (SPA) using a custom handler.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_17\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n)\n\n// spaHandler implements the http.Handler interface, so we can use it\n// to respond to HTTP requests. The path to the static directory and\n// path to the index file within that static directory are used to\n// serve the SPA in the given static directory.\ntype spaHandler struct {\n\tstaticPath string\n\tindexPath  string\n}\n\n// ServeHTTP inspects the URL path to locate a file within the static dir\n// on the SPA handler. If a file is found, it will be served. If not, the\n// file located at the index path on the SPA handler will be served. This\n// is suitable behavior for serving an SPA (single page application).\nfunc (h spaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Join internally call path.Clean to prevent directory traversal\n\tpath := filepath.Join(h.staticPath, r.URL.Path)\n\n\t// check whether a file exists or is a directory at the given path\n\tfi, err := os.Stat(path)\n\tif os.IsNotExist(err) || fi.IsDir() {\n\t\t// file does not exist or path is a directory, serve index.html\n\t\thttp.ServeFile(w, r, filepath.Join(h.staticPath, h.indexPath))\n\t\treturn\n\t}\n\n\tif err != nil {\n\t\t// if we got an error (that wasn't that the file doesn't exist) stating the\n\t\t// file, return a 500 internal server error and stop\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n\t}\n\n\t// otherwise, use http.FileServer to serve the static file\n\thttp.FileServer(http.Dir(h.staticPath)).ServeHTTP(w, r)\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(\"/api/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// an example API handler\n\t\tjson.NewEncoder(w).Encode(map[string]bool{\"ok\": true})\n\t})\n\n\tspa := spaHandler{staticPath: \"build\", indexPath: \"index.html\"}\n\trouter.PathPrefix(\"/\").Handler(spa)\n\n\tsrv := &http.Server{\n\t\tHandler: router,\n\t\tAddr:    \"127.0.0.1:8000\",\n\t\t// Good practice: enforce timeouts for servers you create!\n\t\tWriteTimeout: 15 * time.Second,\n\t\tReadTimeout:  15 * time.Second,\n\t}\n\n\tlog.Fatal(srv.ListenAndServe())\n}\n```\n\n----------------------------------------\n\nTITLE: Domain and Subdomain Matching with Gorilla Mux\nDESCRIPTION: Example of restricting routes to specific domains or dynamic subdomains using the Host matcher.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nr := mux.NewRouter()\n// Only matches if domain is \"www.example.com\".\nr.Host(\"www.example.com\")\n// Matches a dynamic subdomain.\nr.Host(\"{subdomain:[a-z]+}.example.com\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Route with a Path Variable in Gorilla Mux (Go)\nDESCRIPTION: This Go snippet updates the `main` function from `endpoints.go` to include a route `/metrics/{type}` which utilizes a path variable named `type`. This demonstrates how to capture parts of the URL path using variables defined within the route pattern.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_33\n\nLANGUAGE: go\nCODE:\n```\n// endpoints.go\nfunc main() {\n    r := mux.NewRouter()\n    // A route with a route variable:\n    r.HandleFunc(\"/metrics/{type}\", MetricsHandler)\n\n    log.Fatal(http.ListenAndServe(\"localhost:8080\", r))\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Handlers with Path Variables in Gorilla Mux (Go)\nDESCRIPTION: This Go test function from `endpoints_test.go` tests a handler (`MetricsHandler`) that expects a path variable using a table-driven approach. It shows how to correctly set up the test by creating a `mux.Router` instance and routing the test request through it (`router.ServeHTTP`) so that the path variables are correctly parsed and added to the request context, accessible via `mux.Vars`.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_34\n\nLANGUAGE: go\nCODE:\n```\n// endpoints_test.go\nfunc TestMetricsHandler(t *testing.T) {\n    tt := []struct{\n        routeVariable string\n        shouldPass bool\n    }{\n        {\"goroutines\", true},\n        {\"heap\", true},\n        {\"counters\", true},\n        {\"queries\", true},\n        {\"adhadaeqm3k\", false},\n    }\n\n    for _, tc := range tt {\n        path := fmt.Sprintf(\"/metrics/%s\", tc.routeVariable);\n        req, err := http.NewRequest(\"GET\", path, nil);\n        if err != nil {\n            t.Fatal(err);\n        }\n\n        rr := httptest.NewRecorder();\n\t\n\t// To add the vars to the context, \n\t// we need to create a router through which we can pass the request.\n\trouter := mux.NewRouter();\n        router.HandleFunc(\"/metrics/{type}\", MetricsHandler);\n        router.ServeHTTP(rr, req);\n\n        // In this case, our MetricsHandler returns a non-200 response\n        // for a route variable it doesn't know about.\n        if rr.Code == http.StatusOK && !tc.shouldPass {\n            t.Errorf(\"handler should have failed on routeVariable %s: got %v want %v\",\n                tc.routeVariable, rr.Code, http.StatusOK);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Health Check Handler and Router in Go\nDESCRIPTION: This Go snippet from `endpoints.go` defines a simple HTTP handler (`HealthCheckHandler`) that returns a JSON response with a 200 status code. The `main` function sets up a `mux.Router` and registers this handler for the `/health` route before starting the server.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_31\n\nLANGUAGE: go\nCODE:\n```\n// endpoints.go\npackage main\n\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n    // A very simple health check.\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusOK)\n\n    // In the future we could report back on the status of our DB, or our cache\n    // (e.g. Redis) by performing a simple PING, and include them in the response.\n    io.WriteString(w, `{\"alive\": true}`)\n}\n\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/health\", HealthCheckHandler)\n\n    log.Fatal(http.ListenAndServe(\"localhost:8080\", r))\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a Basic HTTP Handler in Go\nDESCRIPTION: This Go test function from `endpoints_test.go` demonstrates how to test an `http.Handler` using `net/http/httptest`. It creates a test request (`http.NewRequest`), a response recorder (`httptest.NewRecorder`), calls the handler's `ServeHTTP` method directly, and then asserts the response's status code and body.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_32\n\nLANGUAGE: go\nCODE:\n```\n// endpoints_test.go\npackage main\n\nimport (\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n)\n\nfunc TestHealthCheckHandler(t *testing.T) {\n    // Create a request to pass to our handler. We don't have any query parameters for now, so we'll\n    // pass 'nil' as the third parameter.\n    req, err := http.NewRequest(\"GET\", \"/health\", nil)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    // We create a ResponseRecorder (which satisfies http.ResponseWriter) to record the response.\n    rr := httptest.NewRecorder()\n    handler := http.HandlerFunc(HealthCheckHandler);\n\n    // Our handlers satisfy http.Handler, so we can call their ServeHTTP method\n    // directly and pass in our Request and ResponseRecorder.\n    handler.ServeHTTP(rr, req)\n\n    // Check the status code is what we expect.\n    if status := rr.Code; status != http.StatusOK {\n        t.Errorf(\"handler returned wrong status code: got %v want %v\",\n            status, http.StatusOK)\n    }\n\n    // Check the response body is what we expect.\n    expected := `{\"alive\": true}`;\n    if rr.Body.String() != expected {\n        t.Errorf(\"handler returned unexpected body: got %v want %v\",\n            rr.Body.String(), expected)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CORS with gorilla/mux Middleware in Go\nDESCRIPTION: This Go snippet demonstrates how to use `mux.CORSMethodMiddleware` to automatically set the `Access-Control-Allow-Methods` header based on the route's method matchers. It also includes a custom handler to manually set `Access-Control-Allow-Origin` and handle `OPTIONS` requests. An `OPTIONS` method matcher is required for the middleware to function correctly.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_28\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n    r := mux.NewRouter()\n\n    // IMPORTANT: you must specify an OPTIONS method matcher for the middleware to set CORS headers\n    r.HandleFunc(\"/foo\", fooHandler).Methods(http.MethodGet, http.MethodPut, http.MethodPatch, http.MethodOptions)\n    r.Use(mux.CORSMethodMiddleware(r))\n    \n    http.ListenAndServe(\":8080\", r);\n}\n\nfunc fooHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n    if r.Method == http.MethodOptions {\n        return\n    }\n\n    w.Write([]byte(\"foo\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Route Ordering in Gorilla Mux\nDESCRIPTION: Example showing how route order matters when multiple routes could match the same request.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nr := mux.NewRouter()\nr.HandleFunc(\"/specific\", specificHandler)\nr.PathPrefix(\"/\").Handler(catchAllHandler)\n```\n\n----------------------------------------\n\nTITLE: Registering Routes on a Subrouter in Gorilla Mux\nDESCRIPTION: Example of adding routes to a subrouter that inherits the parent router's constraints.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_14\n\nLANGUAGE: go\nCODE:\n```\ns.HandleFunc(\"/products/\", ProductsHandler)\ns.HandleFunc(\"/products/{key}\", ProductHandler)\ns.HandleFunc(\"/articles/{category}/{id:[0-9]+}\", ArticleHandler)\n```\n\n----------------------------------------\n\nTITLE: Creating Subrouters with Host Matching in Gorilla Mux\nDESCRIPTION: Creating a subrouter for routes that share a common host constraint.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nr := mux.NewRouter()\ns := r.Host(\"www.example.com\").Subrouter()\n```\n\n----------------------------------------\n\nTITLE: Custom Matcher Function in Gorilla Mux\nDESCRIPTION: Creating a custom matcher function to determine if a route should match a request.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nr.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {\n    return r.ProtoMajor == 0\n})\n```\n\n----------------------------------------\n\nTITLE: Walking All Registered Routes with mux.Router.Walk\nDESCRIPTION: Iterates through all registered routes, retrieving and printing details such as path templates, regex patterns, query templates, regex patterns, and supported methods, useful for route introspection and debugging.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_25\n\nLANGUAGE: Go\nCODE:\n```\nerr := r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {\n pathTemplate, err := route.GetPathTemplate()\n if err == nil {\n  fmt.Println(\"ROUTE:\", pathTemplate)\n }\n pathRegexp, err := route.GetPathRegexp()\n if err == nil {\n  fmt.Println(\"Path regexp:\", pathRegexp)\n }\n queriesTemplates, err := route.GetQueriesTemplates()\n if err == nil {\n  fmt.Println(\"Queries templates:\", strings.Join(queriesTemplates, \",\"))\n }\n queriesRegexps, err := route.GetQueriesRegexp()\n if err == nil {\n  fmt.Println(\"Queries regexps:\", strings.Join(queriesRegexps, \",\"))\n }\n methods, err := route.GetMethods()\n if err == nil {\n  fmt.Println(\"Methods:\", strings.Join(methods, \",\"))\n }\n fmt.Println()\n return nil\n})\n```\n\n----------------------------------------\n\nTITLE: Building a Full URL with Host and Path Variables\nDESCRIPTION: Creates a URL with full components, including host and query parameters, by retrieving the route named 'article' and passing relevant variable values, resulting in a complete URL string.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_20\n\nLANGUAGE: Go\nCODE:\n```\nr := mux.NewRouter()\nr.Host(\"{subdomain}.example.com\").\n  Path(\"/articles/{category}/{id:[0-9]+}\").\n  Queries(\"filter\", \"{filter}\").\n  HandlerFunc(ArticleHandler).\n  Name(\"article\")\n\n// url.String() will be \"http://news.example.com/articles/technology/42?filter=gorilla\"\nurl, err := r.Get(\"article\").URL(\"subdomain\", \"news\",\n                                 \"category\", \"technology\",\n                                 \"id\", \"42\",\n                                 \"filter\", \"gorilla\")\n```\n\n----------------------------------------\n\nTITLE: HTTP Header Matching in Gorilla Mux\nDESCRIPTION: Matching routes based on HTTP header values.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nr.Headers(\"X-Requested-With\", \"XMLHttpRequest\")\n```\n\n----------------------------------------\n\nTITLE: Query Parameter Matching in Gorilla Mux\nDESCRIPTION: Matching routes based on URL query parameter values.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nr.Queries(\"key\", \"value\")\n```\n\n----------------------------------------\n\nTITLE: URL Scheme Matching in Gorilla Mux\nDESCRIPTION: Matching routes based on URL schemes (http, https).\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nr.Schemes(\"https\")\n```\n\n----------------------------------------\n\nTITLE: Building URL Host and Path Separately for a Route\nDESCRIPTION: Uses URLHost() and URLPath() methods to generate only the host or path part of the URL for a specific route, providing flexibility in URL construction.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_22\n\nLANGUAGE: Go\nCODE:\n```\n// \"http://news.example.com/\"\nhost, err := r.Get(\"article\").URLHost(\"subdomain\", \"news\")\n\n// \"/articles/technology/42\"\npath, err := r.Get(\"article\").URLPath(\"category\", \"technology\", \"id\", \"42\")\n```\n\n----------------------------------------\n\nTITLE: Subrouter URL Building with Host and Path\nDESCRIPTION: Demonstrates creating a subrouter with separate host and path templates, and then generating a full URL for a specific route called 'article' by providing variable values.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_23\n\nLANGUAGE: Go\nCODE:\n```\nr := mux.NewRouter()\ns := r.Host(\"{subdomain}.example.com\").Subrouter()\ns.Path(\"/articles/{category}/{id:[0-9]+}\").\n  HandlerFunc(ArticleHandler).\n  Name(\"article\")\n\n// \"http://news.example.com/articles/technology/42\"\nurl, err := r.Get(\"article\").URL(\"subdomain\", \"news\",\n                                 \"category\", \"technology\",\n                                 \"id\", \"42\")\n```\n\n----------------------------------------\n\nTITLE: Regex Support for Header Matching in Routes\nDESCRIPTION: Configures a route to match requests with 'Content-Type' headers following a regex pattern, matching both 'application/json' and 'application/text' content types.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_21\n\nLANGUAGE: Go\nCODE:\n```\nr.HeadersRegexp(\"Content-Type\", \"application/(text|json)\")\n```\n\n----------------------------------------\n\nTITLE: Retrieving Variables for a Route using GetVarNames()\nDESCRIPTION: Fetches all variable names required for a specific route, such as 'domain', 'group', 'item_id', and query variables, useful for understanding what data to supply when building URLs.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_24\n\nLANGUAGE: Go\nCODE:\n```\nr := mux.NewRouter()\nr.Host(\"{domain}\").\n    Path(\"/{group}/{item_id}\").\n    Queries(\"some_data1\", \"{some_data1}\").\n    Queries(\"some_data2\", \"{some_data2}\").\n    Name(\"article\")\n\n// Will print [domain group item_id some_data1 some_data2] <nil>\nfmt.Println(r.Get(\"article\").GetVarNames())\n```\n\n----------------------------------------\n\nTITLE: Installing Gorilla Mux with Go Get\nDESCRIPTION: Command to install the gorilla/mux package using Go's package manager.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngo get -u github.com/gorilla/mux\n```\n\n----------------------------------------\n\nTITLE: Requesting CORS-Enabled Endpoint with Curl in Bash\nDESCRIPTION: This bash command uses `curl` to send a GET request to the `/foo` endpoint of the local server running on port 8080. The `-v` flag provides verbose output, including request and response headers, which is useful for inspecting CORS headers.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\ncurl localhost:8080/foo -v\n```\n\n----------------------------------------\n\nTITLE: Examining CORS Response Headers from Curl in Bash\nDESCRIPTION: This bash output shows the response received from the server after making a `curl` request to the `/foo` endpoint. It highlights the presence and values of the `Access-Control-Allow-Methods` and `Access-Control-Allow-Origin` headers, demonstrating the effect of the `CORSMethodMiddleware` and the custom handler.\nSOURCE: https://github.com/gorilla/mux/blob/main/README.md#_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8080 (#0)\n> GET /foo HTTP/1.1\n> Host: localhost:8080\n> User-Agent: curl/7.59.0\n> Accept: */*\n> \n< HTTP/1.1 200 OK\n< Access-Control-Allow-Methods: GET,PUT,PATCH,OPTIONS\n< Access-Control-Allow-Origin: *\n< Date: Fri, 28 Jun 2019 20:13:30 GMT\n< Content-Length: 3\n< Content-Type: text/plain; charset=utf-8\n< \n* Connection #0 to host localhost left intact\nfoo\n```"
  }
]