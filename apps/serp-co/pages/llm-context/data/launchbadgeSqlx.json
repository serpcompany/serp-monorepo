[
  {
    "owner": "launchbadge",
    "repo": "sqlx",
    "content": "TITLE: Initializing SQLx Connection Pool and Executing Query in Rust\nDESCRIPTION: This code snippet demonstrates how to create a connection pool using SQLx, execute a simple query, and handle the result. It shows the basic setup for different database types and asynchronous runtimes.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/README.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse sqlx::postgres::PgPoolOptions;\n// use sqlx::mysql::MySqlPoolOptions;\n// etc.\n\n#[async_std::main] // Requires the `attributes` feature of `async-std`\n// or #[tokio::main]\n// or #[actix_web::main]\nasync fn main() -> Result<(), sqlx::Error> {\n    // Create a connection pool\n    //  for MySQL/MariaDB, use MySqlPoolOptions::new()\n    //  for SQLite, use SqlitePoolOptions::new()\n    //  etc.\n    let pool = PgPoolOptions::new()\n        .max_connections(5)\n        .connect(\"postgres://postgres:password@localhost/test\").await?;\n\n    // Make a simple query to return the given parameter (use a question mark `?` instead of `$1` for MySQL/MariaDB)\n    let row: (i64,) = sqlx::query_as(\"SELECT $1\")\n        .bind(150_i64)\n        .fetch_one(&pool).await?;\n\n    assert_eq!(row.0, 150);\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Database Connection Pool in SQLx with Rust\nDESCRIPTION: This code example illustrates how to create a connection pool for MySQL using SQLx. Connection pools are generally preferred for regulating server-side connections in applications.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/README.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet pool = MySqlPool::connect(\"mysql://user:pass@host/database\").await?;\n```\n\n----------------------------------------\n\nTITLE: Using High-Level Query Interface in SQLx with Rust\nDESCRIPTION: This code shows how to use the high-level query interface in SQLx, which is preferred for most operations. It demonstrates query execution on both a connection and a pool.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/README.md#2025-04-19_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nsqlx::query(\"DELETE FROM table\").execute(&mut conn).await?;\nsqlx::query(\"DELETE FROM table\").execute(&pool).await?;\n```\n\n----------------------------------------\n\nTITLE: Mapping Query Results to Domain Types in SQLx with Rust\nDESCRIPTION: These snippets show two different approaches to mapping query results to domain types in SQLx: using a closure and using a derive macro.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/README.md#2025-04-19_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet mut stream = sqlx::query(\"SELECT * FROM users\")\n    .map(|row: PgRow| {\n        // map the row into a user-defined domain type\n    })\n    .fetch(&mut conn);\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(sqlx::FromRow)]\nstruct User { name: String, id: i64 }\n\nlet mut stream = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE email = ? OR name = ?\")\n    .bind(user_email)\n    .bind(user_name)\n    .fetch(&mut conn);\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Query Verification in SQLx with Rust\nDESCRIPTION: This code demonstrates the use of the sqlx::query! macro for compile-time syntactic and semantic verification of SQL queries. It shows how to execute a query and work with the resulting anonymous record type.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/README.md#2025-04-19_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet countries = sqlx::query!(\n        \"\nSELECT country, COUNT(*) as count\nFROM users\nGROUP BY country\nWHERE organization = ?\n        \",\n        organization\n    )\n    .fetch_all(&pool) // -> Vec<{ country: String, count: i64 }>\n    .await?;\n\n// countries[0].country\n// countries[0].count\n```\n\n----------------------------------------\n\nTITLE: Named Output Types with Compile-Time Verification in SQLx\nDESCRIPTION: This snippet shows how to use the sqlx::query_as! macro to achieve compile-time query verification with named output types. It demonstrates defining a struct and using it as the output type for a query.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/README.md#2025-04-19_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// no traits are needed\nstruct Country { country: String, count: i64 }\n\nlet countries = sqlx::query_as!(Country,\n        \"\nSELECT country, COUNT(*) as count\nFROM users\nGROUP BY country\nWHERE organization = ?\n        \",\n        organization\n    )\n    .fetch_all(&pool) // -> Vec<Country>\n    .await?;\n\n// countries[0].country\n// countries[0].count\n```\n\n----------------------------------------\n\nTITLE: Fetching and Processing Query Results in SQLx with Rust\nDESCRIPTION: This snippet illustrates how to fetch and process query results using SQLx. It demonstrates streaming rows, accessing column values, and mapping rows to domain types.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/README.md#2025-04-19_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// provides `try_next`\nuse futures::TryStreamExt;\n// provides `try_get`\nuse sqlx::Row;\n\nlet mut rows = sqlx::query(\"SELECT * FROM users WHERE email = ?\")\n    .bind(email)\n    .fetch(&mut conn);\n\nwhile let Some(row) = rows.try_next().await? {\n    // map the row into a user-defined domain type\n    let email: &str = row.try_get(\"email\")?;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up database connection with environment variables\nDESCRIPTION: Example of configuring the database connection URL in an environment file (.env) for PostgreSQL.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_1\n\nLANGUAGE: dotenv\nCODE:\n```\n# Postgres\nDATABASE_URL=postgres://postgres@localhost/my_database\n```\n\n----------------------------------------\n\nTITLE: Executing Prepared and Unprepared Queries in SQLx with Rust\nDESCRIPTION: This snippet demonstrates how to execute both prepared (parameterized) and unprepared (simple) queries using SQLx. It shows the low-level usage of the Executor trait.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/README.md#2025-04-19_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// low-level, Executor trait\nconn.execute(\"BEGIN\").await?; // unprepared, simple query\nconn.execute(sqlx::query(\"DELETE FROM table\")).await?; // prepared, cached query\n```\n\n----------------------------------------\n\nTITLE: Automatic Test Database Management with SQLx in Rust\nDESCRIPTION: This snippet shows how to use #[sqlx::test] with a PgPool parameter to get a test database automatically created and provided to the test. The test makes a query to a table and verifies its contents.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/src/macros/test.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(all(feature = \"migrate\", feature = \"postgres\"))]\n# mod example { \nuse sqlx::{PgPool, Row};\n\n#[sqlx::test]\nasync fn basic_test(pool: PgPool) -> sqlx::Result<()> {\n    let mut conn = pool.acquire().await?;\n\n    let foo = sqlx::query(\"SELECT * FROM foo\")\n        .fetch_one(&mut conn)\n        .await?;\n\n    assert_eq!(foo.get::<String, _>(\"bar\"), \"foobar!\");\n    \n    Ok(())\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Transaction Wrapper Example in Rust\nDESCRIPTION: Demonstrates how to use the connection transaction wrapper to execute operations within a database transaction context using a closure.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/CHANGELOG.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nconn.transaction(|transaction: &mut Transaction<Database> | {\n    // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Installing SQLx with Cargo Dependencies\nDESCRIPTION: Configuration options for adding SQLx as a dependency in Cargo.toml, showing different runtime and TLS backend combinations including tokio and async-std with various TLS options.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/README.md#2025-04-19_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# Cargo.toml\n[dependencies]\n# PICK ONE OF THE FOLLOWING:\n\n# tokio (no TLS)\nsqlx = { version = \"0.8\", features = [ \"runtime-tokio\" ] }\n# tokio + native-tls\nsqlx = { version = \"0.8\", features = [ \"runtime-tokio\", \"tls-native-tls\" ] }\n# tokio + rustls with ring and WebPKI CA certificates\nsqlx = { version = \"0.8\", features = [ \"runtime-tokio\", \"tls-rustls-ring-webpki\" ] }\n# tokio + rustls with ring and platform's native CA certificates\nsqlx = { version = \"0.8\", features = [ \"runtime-tokio\", \"tls-rustls-ring-native-roots\" ] }\n# tokio + rustls with aws-lc-rs\nsqlx = { version = \"0.8\", features = [ \"runtime-tokio\", \"tls-rustls-aws-lc-rs\" ] }\n\n# async-std (no TLS)\nsqlx = { version = \"0.8\", features = [ \"runtime-async-std\" ] }\n# async-std + native-tls\nsqlx = { version = \"0.8\", features = [ \"runtime-async-std\", \"tls-native-tls\" ] }\n# async-std + rustls with ring and WebPKI CA certificates\nsqlx = { version = \"0.8\", features = [ \"runtime-async-std\", \"tls-rustls-ring-webpki\" ] }\n# async-std + rustls with ring and platform's native CA certificates\nsqlx = { version = \"0.8\", features = [ \"runtime-async-std\", \"tls-rustls-ring-native-roots\" ] }\n# async-std + rustls with aws-lc-rs\nsqlx = { version = \"0.8\", features = [ \"runtime-async-std\", \"tls-rustls-aws-lc-rs\" ] }\n```\n\n----------------------------------------\n\nTITLE: Establishing Single Database Connection in SQLx with Rust\nDESCRIPTION: This snippet shows how to establish a single database connection using SQLx. It demonstrates the use of the Connection trait for creating a SQLite connection.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/README.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse sqlx::Connection;\n\nlet conn = SqliteConnection::connect(\"sqlite::memory:\").await?;\n```\n\n----------------------------------------\n\nTITLE: Creating a new migration file\nDESCRIPTION: Command to create a new migration file with a specific name. This generates a timestamped SQL file in the migrations directory.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsqlx migrate add <name>\n```\n\n----------------------------------------\n\nTITLE: Executing Raw SQL Queries with Executor in Rust\nDESCRIPTION: Demonstrates how to execute raw SQL queries using the Executor trait, including setting timezone parameters and fetching multiple result sets sequentially.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/CHANGELOG.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse sqlx::Executor;\n\n// Set the time zone parameter\nconn.execute(\"SET TIME ZONE LOCAL;\").await\n\n// Demonstrate two queries at once with the raw API\nlet mut cursor = conn.fetch(\"SELECT 1; SELECT 2\");\nlet row = cursor.next().await?.unwrap();\nlet value: i32 = row.get(0); // 1\nlet row = cursor.next().await?.unwrap();\nlet value: i32 = row.get(0); // 2\n```\n\n----------------------------------------\n\nTITLE: Creating and dropping a database with SQLx CLI\nDESCRIPTION: Commands to create or drop the database specified by the DATABASE_URL environment variable.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsqlx database create\nsqlx database drop\n```\n\n----------------------------------------\n\nTITLE: Mapping Query Results with Chained Methods in Rust\nDESCRIPTION: Example showing how to use chained map operations with sqlx query macros to transform query results. Demonstrates fetching and mapping a single column from query results into a vector.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/CHANGELOG.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet ones: Vec<i32> = query!(\"SELECT 1 as foo\")\n    .map(|row| row.foo)\n    .fetch_all(&mut conn).await?;\n```\n\n----------------------------------------\n\nTITLE: Executing DDL Statements in SQLx\nDESCRIPTION: Example showing how to execute DDL statements using the Executor trait in SQLx, demonstrating table creation, data migration, and schema modification.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/FAQ.md#2025-04-19_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nuse sqlx::postgres::PgConnection;\nuse sqlx::Executor;\n\nlet mut conn: PgConnection = connect().await?;\n\nconn\n    .execute(\n        \"CREATE TABLE IF NOT EXISTS StudentContactInfo (student_id INTEGER, person_name TEXT, relation TEXT, phone TEXT);\\         INSERT INTO StudentContactInfo (student_id, person_name, relation, phone) \\\n             SELECT student_id, guardian_name, guardian_relation, guardian_phone FROM Students;\\         ALTER TABLE Students DROP guardian_name, guardian_relation, guardian_phone;\"\n    )\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Postgres Bulk Insert with Single Array Using UNNEST\nDESCRIPTION: Demonstrates how to perform a bulk insert operation in Postgres using UNNEST to convert a vector into a temporary table for insertion. Requires type casting for proper query preparation.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/FAQ.md#2025-04-19_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet foo_texts: Vec<String> = vec![/* ... */];\n\nsqlx::query!(\n    \"INSERT INTO foo(text_column) SELECT * FROM UNNEST($1::text[])\",\n    &foo_texts[..]\n)\n    .execute(&db)\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Enabling TLS Features in SQLx\nDESCRIPTION: Shows how to enable TLS support in SQLx. Users can choose between native-tls and rustls backends by enabling specific features in their Cargo.toml file.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/src/lib.md#2025-04-19_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n* `tls-native-tls`: Enables the [`native-tls`] backend which uses the OS-native TLS capabilities:\n  * SecureTransport on macOS.\n  * SChannel on Windows.\n  * OpenSSL on all other platforms.\n* `tls-rustls`: Enables the [rustls] backend, a cross-platform TLS library.\n  * Only supports TLS revisions 1.2 and 1.3.\n  * If you get `HandshakeFailure` errors when using this feature, it likely means your database server does not support\n    these newer revisions. This might be resolved by enabling or switching to the `tls-native-tls` feature.\n  * rustls supports several providers of cryptographic primitives. The default\n    (enabled when you use the `tls-rustls` feature or `tls-rustls-ring`) is the\n    `ring` provider, which has fewer build-time dependencies but also has fewer\n    features. Alternatively, you can use `tls-rustls-aws-lc-rs` to use the\n    `aws-lc-rs` provider, which enables additional cipher suite support at the cost\n    of more onerous build requirements (depending on platform support).\n```\n\n----------------------------------------\n\nTITLE: Postgres Multi-Column Bulk Insert with UNNEST\nDESCRIPTION: Shows how to perform bulk inserts with multiple columns using UNNEST, handling different data types including optional values. Demonstrates type casting and parameter binding for complex inserts.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/FAQ.md#2025-04-19_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet foo_texts: Vec<String> = vec![/* ... */];\nlet foo_bools: Vec<bool> = vec![/* ... */];\nlet foo_ints: Vec<i64> = vec![/* ... */];\nlet foo_opt_texts: Vec<Option<String>> = vec![/* ... */];\nlet foo_opt_naive_dts: Vec<Option<NaiveDateTime>> = vec![/* ... */]\n\n\nsqlx::query!(\n    \"\n        INSERT INTO foo(text_column, bool_column, int_column, opt_text_column, opt_naive_dt_column) \n        SELECT * FROM UNNEST($1::text[], $2::bool[], $3::int8[], $4::text[], $5::timestamp[])\n    \",\n    &foo_texts[..],\n    &foo_bools[..],\n    &foo_ints[..],\n    &foo_opt_texts as &[Option<String>],\n    &foo_opt_naive_dts as &[Option<NaiveDateTime>]\n)\n    .execute(&db)\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Adding a Todo Item with Rust CLI\nDESCRIPTION: Demonstrates how to add a new todo item using the Rust CLI application.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/todos/README.md#2025-04-19_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo run -- add \"todo description\"\n```\n\n----------------------------------------\n\nTITLE: Mapping Query Results in SQLx\nDESCRIPTION: Shows how to map database query results to Rust types using the map() function with fetch_all() to collect results into a vector.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/CHANGELOG.md#2025-04-19_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet values: Vec<i32> = sqlx::query(\"SELECT 1\")\n    .map(|row: PgRow| row.get(0))\n    .fetch_all(&mut conn).await?\n```\n\n----------------------------------------\n\nTITLE: Running SQL Migrations with SQLx CLI\nDESCRIPTION: Executes SQL migration files to set up the database schema using the SQLx migrate command. This establishes the required tables and structures for the todos application.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/mysql/todos/README.md#2025-04-19_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sqlx migrate run\n```\n\n----------------------------------------\n\nTITLE: Basic SQLx Test Annotation Usage in Rust\nDESCRIPTION: This snippet demonstrates the basic usage of the #[sqlx::test] annotation for an async test function, which behaves similarly to #[tokio::test] or #[async_std::test].\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/src/macros/test.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# // Note if reading these examples directly in `test.md`:\n# // lines prefixed with `#` are not meant to be shown;\n# // they are supporting code to help the examples to compile successfully.\n# #[cfg(feature = \"_rt-tokio\")]\n#[sqlx::test]\nasync fn test_async_fn() {\n    tokio::task::yield_now().await;\n}\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Array Query Using ANY Operator\nDESCRIPTION: Example of performing an IN-style query in PostgreSQL using arrays and the ANY operator, which provides better performance than comma-separated lists.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/FAQ.md#2025-04-19_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nlet db: PgPool = /* ... */;\nlet foo_ids: Vec<i64> = vec![/* ... */];\n\nlet foos = sqlx::query!(\n    \"SELECT * FROM foo WHERE id = ANY($1)\",\n    // a bug of the parameter typechecking code requires all array parameters to be slices\n    &foo_ids[..]\n)\n    .fetch_all(&db)\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Database-specific Prepared Statement Syntax\nDESCRIPTION: Examples of prepared statement syntax for different databases, showing parameter placeholders for MySQL ($?) and Postgres/SQLite ($1).\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/FAQ.md#2025-04-19_snippet_4\n\nLANGUAGE: SQL\nCODE:\n```\n-- MySQL\nINSERT INTO Students (name) VALUES(?);\n-- Postgres and SQLite\nINSERT INTO Students (name) VALUES($1);\n```\n\n----------------------------------------\n\nTITLE: Running pending migrations\nDESCRIPTION: Command to run any pending migration scripts by comparing the database migration history against the scripts in the migrations directory.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsqlx migrate run\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Connection URL Examples\nDESCRIPTION: Various examples of valid PostgreSQL connection URLs showing different combinations of connection parameters.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-postgres/src/options/doc.md#2025-04-19_snippet_1\n\nLANGUAGE: text\nCODE:\n```\npostgresql://\npostgresql://:5433\npostgresql://localhost\npostgresql://localhost:5433\npostgresql://localhost/mydb\npostgresql://user@localhost\npostgresql://user:secret@localhost\npostgresql://user:correct%20horse%20battery%20staple@localhost\npostgresql://localhost?dbname=mydb&user=postgres&password=postgres\n```\n\n----------------------------------------\n\nTITLE: Installing SQLx CLI with Rust toolchain\nDESCRIPTION: Various installation options for the SQLx CLI using cargo, including options for specific databases, OpenSSL configuration, and using Rustls instead of OpenSSL.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# supports all databases supported by SQLx\n$ cargo install sqlx-cli\n\n# only for postgres\n$ cargo install sqlx-cli --no-default-features --features native-tls,postgres\n\n# use vendored OpenSSL (build from source)\n$ cargo install sqlx-cli --features openssl-vendored\n\n# use Rustls rather than OpenSSL (be sure to add the features for the databases you intend to use!)\n$ cargo install sqlx-cli --no-default-features --features rustls\n\n# only for sqlite and use the system sqlite library\n$ cargo install sqlx-cli --no-default-features --features sqlite-unbundled\n```\n\n----------------------------------------\n\nTITLE: Using SQLx Test Attribute for API Integration Testing\nDESCRIPTION: This code snippet shows the usage of the #[sqlx::test] attribute for writing integration tests. It's a key part of the testing setup for an API built with Axum and SQLx.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/axum-social-with-tests/README.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[sqlx::test]\n```\n\n----------------------------------------\n\nTITLE: Creating reversible migrations\nDESCRIPTION: Command to create reversible migrations with both 'up' and 'down' scripts using the -r flag.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ sqlx migrate add -r <name>\nCreating migrations/20211001154420_<name>.up.sql\nCreating migrations/20211001154420_<name>.down.sql\n```\n\n----------------------------------------\n\nTITLE: Custom Migration Path in SQLx Test Annotation\nDESCRIPTION: This snippet demonstrates how to override the default migrations path by specifying a custom path in the #[sqlx::test] attribute. This allows using migrations from a non-standard location.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/src/macros/test.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(all(feature = \"migrate\", feature = \"postgres\"))]\n# mod example { \nuse sqlx::{PgPool, Row};\n\n#[sqlx::test(migrations = \"foo_migrations\")]\nasync fn basic_test(pool: PgPool) -> sqlx::Result<()> {\n    let mut conn = pool.acquire().await?;\n\n    let foo = sqlx::query(\"SELECT * FROM foo\")\n        .fetch_one(&mut conn)\n        .await?;\n\n    assert_eq!(foo.get::<String, _>(\"bar\"), \"foobar!\");\n    \n    Ok(())\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Adding Complex JSON Data with Nested Arrays\nDESCRIPTION: Adds a JSON object containing a nested array with multiple data types to the database.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/json/README.md#2025-04-19_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\necho '{ \"name\": \"Jane Doe\", \"age\": 25, \"array\": [\"string\", true, 0] }' | cargo run -- add\n```\n\n----------------------------------------\n\nTITLE: Using Fixtures with SQLx Test Annotation in Rust\nDESCRIPTION: This example shows how to apply fixtures (SQL scripts for test data) with the #[sqlx::test] annotation. Fixtures are applied in the specified order to set up test data before the test runs.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/src/macros/test.md#2025-04-19_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(all(feature = \"migrate\", feature = \"postgres\"))]\n# mod example { \n# struct App {}\n# fn create_app(pool: PgPool) -> App { App {} }\nuse sqlx::PgPool;\nuse serde_json::json;\n\n// Alternatives:\n// #[sqlx::test(fixtures(\"./fixtures/users.sql\", \"./fixtures/posts.sql\"))]\n// or\n// #[sqlx::test(fixtures(path = \"./fixtures\", scripts(\"users\", \"posts\")))]\n#[sqlx::test(fixtures(\"users\", \"posts\"))]\nasync fn test_create_comment(pool: PgPool) -> sqlx::Result<()> {\n    // See examples/postgres/social-axum-with-tests for a more in-depth example. \n    let mut app = create_app(pool);     \n    \n    let comment = test_request(\n        &mut app, \"POST\", \"/v1/comment\", json! { \"postId\": \"1234\" }\n    ).await?;\n    \n    assert_eq!(comment[\"postId\"], \"1234\");\n    \n    Ok(())\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Checking offline mode data for CI integration\nDESCRIPTION: Commands to verify if the data in .sqlx is up to date with the current database schema and project queries, intended for Continuous Integration.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncargo sqlx prepare --check\n# OR\ncargo sqlx prepare --check --workspace\n```\n\n----------------------------------------\n\nTITLE: Adding Basic JSON Data to Database\nDESCRIPTION: Adds a simple JSON object with name and age fields to the database using a CLI command.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/json/README.md#2025-04-19_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\necho '{ \"name\": \"John Doe\", \"age\": 30 }' | cargo run -- add\n```\n\n----------------------------------------\n\nTITLE: Using Embedded Migrator with SQLx Test Annotation\nDESCRIPTION: This example shows how to reference a Migrator instance embedded in your main crate for use in tests. This is useful if you're already embedding migrations in your application code.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/src/macros/test.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(all(feature = \"migrate\", feature = \"postgres\"))]\n# mod example { \nuse sqlx::{PgPool, Row};\n\n# // This is standing in for the main crate since doc examples don't support multiple crates.\n# mod foo_crate { \n#   use std::borrow::Cow;\n#   static MIGRATOR: sqlx::migrate::Migrator = sqlx::migrate::Migrator {\n#       migrations: Cow::Borrowed(&[]),\n#       ignore_missing: false,\n#       locking: true,\n#       no_tx: false\n#   };\n# } \n\n// You could also do `use foo_crate::MIGRATOR` and just refer to it as `MIGRATOR` here.\n#[sqlx::test(migrator = \"foo_crate::MIGRATOR\")]\nasync fn basic_test(pool: PgPool) -> sqlx::Result<()> {\n    let mut conn = pool.acquire().await?;\n\n    let foo = sqlx::query(\"SELECT * FROM foo\")\n        .fetch_one(&mut conn)\n        .await?;\n\n    assert_eq!(foo.get::<String, _>(\"bar\"), \"foobar!\");\n    \n    Ok(())\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Connection URL Format\nDESCRIPTION: Standard format for PostgreSQL connection URLs with optional components for user, password, host, port, database name, and additional parameters.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-postgres/src/options/doc.md#2025-04-19_snippet_0\n\nLANGUAGE: text\nCODE:\n```\npostgresql://[user[:password]@][host][:port][/dbname][?param1=value1&...]\n```\n\n----------------------------------------\n\nTITLE: Running SQL Migrations with SQLx CLI\nDESCRIPTION: Executes SQL migrations using the SQLx CLI to set up the database schema.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/todos/README.md#2025-04-19_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ sqlx migrate run\n```\n\n----------------------------------------\n\nTITLE: Running reversible migrations\nDESCRIPTION: Example of running a reversible migration which applies the 'up' script to the database.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ sqlx migrate run\nApplied migrations/20211001154420 <name> (32.517835ms)\n```\n\n----------------------------------------\n\nTITLE: Running SQLx Migrations\nDESCRIPTION: Executes all SQL migrations to set up the database schema for the TODOs application using the SQLx CLI.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/sqlite/todos/README.md#2025-04-19_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sqlx migrate run\n```\n\n----------------------------------------\n\nTITLE: Reverting migrations\nDESCRIPTION: Example of reverting a migration which applies the 'down' script to undo database changes.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ sqlx migrate revert\nApplied 20211001154420/revert <name>\n```\n\n----------------------------------------\n\nTITLE: Pinning SQLx and Related Dependencies in Cargo.toml\nDESCRIPTION: Example of how to pin SQLx and related crates like rusqlite to specific versions to avoid breakages from cargo update. This is recommended since the linkage to libsqlite3-sys is now considered semver-exempt.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/CHANGELOG.md#2025-04-19_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nsqlx = { version = \"=0.7.0\", features = [\"sqlite\"] }\nrusqlite = \"=0.29.0\"\n```\n\n----------------------------------------\n\nTITLE: Adding a New Todo Item\nDESCRIPTION: CLI command to add a new todo item to the database with a specified description.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/sqlite/todos/README.md#2025-04-19_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -- add \"todo description\"\n```\n\n----------------------------------------\n\nTITLE: Running SQL Migrations with SQLx CLI\nDESCRIPTION: Executes SQL migrations to set up the database schema using the SQLx CLI.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/json/README.md#2025-04-19_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ sqlx migrate run\n```\n\n----------------------------------------\n\nTITLE: Running Specific SQLx Tests with Custom Database URL\nDESCRIPTION: This command demonstrates how to run a specific set of SQLx tests against a MySQL database, specifying the database URL and required features.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/tests/README.md#2025-04-19_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ DATABASE_URL=mysql://root:password@127.0.0.1:49183/sqlx cargo test --no-default-features --features macros,offline,any,all-types,mysql,runtime-async-std-native-tls\n```\n\n----------------------------------------\n\nTITLE: Enabling Runtime Features in SQLx\nDESCRIPTION: Demonstrates how to enable runtime features in SQLx. Users can choose between Tokio and async-std runtimes by enabling specific features in their Cargo.toml file.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/src/lib.md#2025-04-19_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* `runtime-async-std`\n* `runtime-tokio`\n```\n\n----------------------------------------\n\nTITLE: Preparing for offline mode\nDESCRIPTION: Command to save query metadata to the .sqlx directory for offline usage, enabling builds without an active database connection.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncargo sqlx prepare\n```\n\n----------------------------------------\n\nTITLE: Running SQLX Migrations\nDESCRIPTION: Command to execute SQL migrations using SQLX CLI tool.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/files/README.md#2025-04-19_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ sqlx migrate run\n```\n\n----------------------------------------\n\nTITLE: Marking a Todo Item as Complete\nDESCRIPTION: Executes the application to mark a specific todo item as complete by providing its ID. This updates the item's status in the database.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/mysql/todos/README.md#2025-04-19_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -- done <todo id>\n```\n\n----------------------------------------\n\nTITLE: Adding a Todo Item with Cargo\nDESCRIPTION: Runs the Rust application with cargo to add a new todo item to the database. The command takes a description string as an argument.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/mysql/todos/README.md#2025-04-19_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -- add \"todo description\"\n```\n\n----------------------------------------\n\nTITLE: Completing a Todo Item with Rust CLI\nDESCRIPTION: Shows the command to mark a todo item as completed using its ID in the Rust CLI application.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/todos/README.md#2025-04-19_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo run -- done <todo id>\n```\n\n----------------------------------------\n\nTITLE: Creating Database with SQLx CLI\nDESCRIPTION: Uses the SQLx CLI to create the database specified in the DATABASE_URL.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/todos/README.md#2025-04-19_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sqlx db create\n```\n\n----------------------------------------\n\nTITLE: Marking a Todo as Complete\nDESCRIPTION: CLI command to mark a specific todo item as complete by providing its ID.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/sqlite/todos/README.md#2025-04-19_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -- done <todo id>\n```\n\n----------------------------------------\n\nTITLE: Creating Database with SQLx CLI\nDESCRIPTION: Uses the SQLx CLI tool to create a new database according to the configuration specified in the DATABASE_URL environment variable.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/mysql/todos/README.md#2025-04-19_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ sqlx db create\n```\n\n----------------------------------------\n\nTITLE: Disabling Migrations in SQLx Test Annotation\nDESCRIPTION: This snippet demonstrates how to disable automatic migrations by setting the migrations parameter to false. This allows the test to set up its own schema directly.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/src/macros/test.md#2025-04-19_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# #[cfg(all(feature = \"migrate\", feature = \"postgres\"))]\n# mod example { \nuse sqlx::{PgPool, Row};\n\n#[sqlx::test(migrations = false)]\nasync fn basic_test(pool: PgPool) -> sqlx::Result<()> {\n    let mut conn = pool.acquire().await?;\n    \n    conn.execute(\"CREATE TABLE foo(bar text)\").await?;\n\n    let foo = sqlx::query(\"SELECT * FROM foo\")\n        .fetch_one(&mut conn)\n        .await?;\n\n    assert_eq!(foo.get::<String, _>(\"bar\"), \"foobar!\");\n    \n    Ok(())\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Creating Database with SQLx CLI\nDESCRIPTION: Uses the SQLx CLI to create a new database based on the configured DATABASE_URL.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/json/README.md#2025-04-19_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sqlx db create\n```\n\n----------------------------------------\n\nTITLE: Preparing offline mode with feature flags and tests\nDESCRIPTION: Command to prepare offline mode data that includes queries behind feature flags or in test code by enabling all targets and features.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ncargo sqlx prepare -- --all-targets --all-features\n```\n\n----------------------------------------\n\nTITLE: Creating SQLX Database\nDESCRIPTION: Command to create a new database using SQLX CLI tool.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/files/README.md#2025-04-19_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sqlx db create\n```\n\n----------------------------------------\n\nTITLE: Listing All Todo Items with Rust CLI\nDESCRIPTION: Executes the Rust CLI application to list all todo items in the database.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/todos/README.md#2025-04-19_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Specifying custom migration directory\nDESCRIPTION: Example of using the --source flag to specify a custom directory for migration scripts.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsqlx migrate info --source ../relative/migrations\n```\n\n----------------------------------------\n\nTITLE: Listing All Todo Items\nDESCRIPTION: CLI command to display all todo items in the database.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/sqlite/todos/README.md#2025-04-19_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Setting Database URL Environment Variable for PostgreSQL Connection\nDESCRIPTION: Sets the DATABASE_URL environment variable required for connecting to a PostgreSQL database. This example uses a local PostgreSQL instance with default credentials.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/transaction/README.md#2025-04-19_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nexport DATABASE_URL=\"postgres://postgres@localhost/postgres\"\n```\n\n----------------------------------------\n\nTITLE: Listing All Todo Items\nDESCRIPTION: Runs the application without additional arguments to display all todo items currently stored in the database.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/mysql/todos/README.md#2025-04-19_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Running the PostgreSQL Transaction Example\nDESCRIPTION: Command to execute the example application that demonstrates PostgreSQL transaction handling with Sqlx.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/transaction/README.md#2025-04-19_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Starting Databases for SQLx Testing with Docker Compose\nDESCRIPTION: This command uses Docker Compose to start the necessary database systems for SQLx integration testing.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/tests/README.md#2025-04-19_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Setting Database URL Environment Variable for SQLx\nDESCRIPTION: Sets the DATABASE_URL environment variable to point to a SQLite database file named 'todos.db'. This environment variable is required by SQLx to establish a database connection.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/sqlite/todos/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport DATABASE_URL=\"sqlite:todos.db\"\n```\n\n----------------------------------------\n\nTITLE: Unix Domain Socket Connection URLs\nDESCRIPTION: Examples of PostgreSQL connection URLs using Unix domain sockets with percent-encoded paths and query parameters.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-postgres/src/options/doc.md#2025-04-19_snippet_2\n\nLANGUAGE: text\nCODE:\n```\npostgres://%2Fvar%2Frun%2Fpostgresql/dbname\n\nDifferent port:\npostgres://%2Fvar%2Frun%2Fpostgresql:5433/dbname\n\nWith username and password:\npostgres://user:password@%2Fvar%2Frun%2Fpostgresql/dbname\n\nWith username and password, and different port:\npostgres://user:password@%2Fvar%2Frun%2Fpostgresql:5432/dbname\n```\n\n----------------------------------------\n\nTITLE: Setting Database URL Environment Variable for SQLx Postgres Connection\nDESCRIPTION: Sets the DATABASE_URL environment variable to connect to a PostgreSQL database for the TODOs example.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/todos/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport DATABASE_URL=\"postgres://postgres:password@localhost/todos\"\n```\n\n----------------------------------------\n\nTITLE: Running the LISTEN/NOTIFY Example\nDESCRIPTION: Executes the example program using Cargo, which will establish connections to Postgres, set up listeners on predefined channels, and spawn a notification sender task.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/listen/README.md#2025-04-19_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Setting Database URL Environment Variable for SQLx\nDESCRIPTION: Sets the DATABASE_URL environment variable to connect to a PostgreSQL database named 'json'.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/json/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport DATABASE_URL=\"postgres://postgres:password@localhost/json\"\n```\n\n----------------------------------------\n\nTITLE: Creating SQLx Database\nDESCRIPTION: Uses the SQLx CLI to create a new database based on the connection string specified in the DATABASE_URL environment variable.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/sqlite/todos/README.md#2025-04-19_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ sqlx db create\n```\n\n----------------------------------------\n\nTITLE: Setting Database URL for Postgres Connection\nDESCRIPTION: Exports the database URL environment variable that will be used to connect to the local Postgres database. This connection will be used for both listening to and sending notifications.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/listen/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport DATABASE_URL=\"postgres://postgres@localhost/postgres\"\n```\n\n----------------------------------------\n\nTITLE: Creating subsequent reversible migrations\nDESCRIPTION: Example showing that subsequent migrations will also be reversible after the first reversible migration is created.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ sqlx migrate add <name1>\nCreating migrations/20211001154420_<name>.up.sql\nCreating migrations/20211001154420_<name>.down.sql\n```\n\n----------------------------------------\n\nTITLE: Setting Database URL Environment Variable\nDESCRIPTION: Sets the PostgreSQL database connection string as an environment variable.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/files/README.md#2025-04-19_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nexport DATABASE_URL=\"postgres://postgres:password@localhost/files\"\n```\n\n----------------------------------------\n\nTITLE: Preparing for offline mode in a workspace\nDESCRIPTION: Command to generate a single .sqlx directory at the root of a workspace for projects with multiple crates using query macros.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-cli/README.md#2025-04-19_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncargo sqlx prepare --workspace\n```\n\n----------------------------------------\n\nTITLE: Setting Database URL Environment Variable for SQLx\nDESCRIPTION: Sets the DATABASE_URL environment variable which SQLx uses to connect to the MySQL database for the todos application.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/mysql/todos/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport DATABASE_URL=\"mysql://root:password@localhost/todos\"\n```\n\n----------------------------------------\n\nTITLE: Comparing NUMERIC and rust_decimal::Decimal Range Limitations\nDESCRIPTION: Demonstrates the range differences between PostgreSQL's NUMERIC type and Rust's Decimal implementation. PostgreSQL NUMERIC supports up to 131,072 digits before decimal and 16,384 after, while rust_decimal::Decimal is limited to 96-bit magnitude (67 decimal digits) and minimum magnitude of 10^-28.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-postgres/src/types/rust_decimal-range.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nrust_decimal::Decimal\n```\n\nLANGUAGE: sql\nCODE:\n```\nNUMERIC\n```\n\n----------------------------------------\n\nTITLE: Setting Database URL for SQLX PostgreSQL Chat Example\nDESCRIPTION: Exports the DATABASE_URL environment variable with PostgreSQL connection details for the chat example.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/chat/README.md#2025-04-19_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nexport DATABASE_URL=\"postgres://postgres:password@localhost/files\"\n```\n\n----------------------------------------\n\nTITLE: Running PostgreSQL Pool Benchmarks with Tokio Runtime\nDESCRIPTION: Command used to run the PostgreSQL pool benchmarks using Tokio runtime with a 30-second measurement time.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-bench/results/2020-07-01-bench_pgpool_acquire/REPORT.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo bench --features runtime-tokio,postgres -- --measurement-time 30\n```\n\n----------------------------------------\n\nTITLE: Git Pre-commit Hook for SQLx Offline Mode\nDESCRIPTION: Shell script to automatically prepare SQLx queries for offline mode before each commit. Creates a pre-commit hook that runs cargo sqlx prepare and stages the changes.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/FAQ.md#2025-04-19_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ echo \"cargo sqlx prepare > /dev/null 2>&1; git add .sqlx > /dev/null\" > .git/hooks/pre-commit\n```\n\n----------------------------------------\n\nTITLE: SQL Injection Attack Example in PHP\nDESCRIPTION: Shows how maliciously crafted input can exploit vulnerable SQL query construction to execute unauthorized commands.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/FAQ.md#2025-04-19_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n$student_name = \"Robert');DROP TABLE Students;--\"\n\n$query = sprintf(\"INSERT INTO Students (name) VALUES ('%s')\", $student_name);\n$result = $mysqli->query($query);\n```\n\n----------------------------------------\n\nTITLE: Docs.rs Build Script for SQLx Offline Mode\nDESCRIPTION: Build script to enable SQLx offline mode when building documentation on docs.rs. Ensures documentation can be built without database access.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/FAQ.md#2025-04-19_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // When building in docs.rs, we want to set SQLX_OFFLINE mode to true\n    if std::env::var_os(\"DOCS_RS\").is_some() {\n        println!(\"cargo:rustc-env=SQLX_OFFLINE=true\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing All JSON Records\nDESCRIPTION: Runs the application without arguments to list all records stored in the database.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/json/README.md#2025-04-19_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Running the Project\nDESCRIPTION: Command to execute the project with the 'files' argument using Cargo.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/files/README.md#2025-04-19_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo run files\n```\n\n----------------------------------------\n\nTITLE: Running SQLX PostgreSQL Chat Example Project\nDESCRIPTION: Executes the cargo run command to start the SQLX PostgreSQL chat example project.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/examples/postgres/chat/README.md#2025-04-19_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -p sqlx-examples-postgres-chat\n```\n\n----------------------------------------\n\nTITLE: Running All SQLx Tests Against Supported Databases\nDESCRIPTION: This command executes the x.py script to run all tests for SQLx against all supported database systems.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/tests/README.md#2025-04-19_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ ./x.py\n```\n\n----------------------------------------\n\nTITLE: Validating Docker Installation for SQLx Testing\nDESCRIPTION: This command verifies that Docker is correctly installed and functioning by running the 'hello-world' container.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/tests/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ docker run hello-world\n```\n\n----------------------------------------\n\nTITLE: SQL Injection Prevention with String Escaping in PHP\nDESCRIPTION: Shows how to use mysqli::real_escape_string() to escape special characters in user input, though this approach is not the most robust solution.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/FAQ.md#2025-04-19_snippet_3\n\nLANGUAGE: php\nCODE:\n```\n$student_name = $mysqli->real_escape_string(\"Robert');DROP TABLE Students;--\");\n\n/*\n    Everything is okay now as the dastardly single-quote has been inactivated by the backslash:\n    \"INSERT INTO Students (name) VALUES ('Robert\\');DROP TABLE Students;--');\"\n*/\n$query = sprintf(\"INSERT INTO Students (name) VALUES ('%s')\", $student_name);\n```\n\n----------------------------------------\n\nTITLE: Vulnerable SQL Query Construction in PHP\nDESCRIPTION: Demonstrates unsafe direct string interpolation in SQL queries that makes the code vulnerable to SQL injection attacks.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/FAQ.md#2025-04-19_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n/* Imagine this is user input */\n$city = \"Munich\";\n\n/* $query = \"SELECT country FROM city WHERE name='Munich'\" */\n$query = sprintf(\"SELECT country FROM city WHERE name='%s'\", $city);\n$result = $mysqli->query($query);\n```\n\n----------------------------------------\n\nTITLE: Resulting Malicious SQL Statements\nDESCRIPTION: Demonstrates how the injected SQL code gets parsed into multiple valid SQL statements that will be executed by the database.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/FAQ.md#2025-04-19_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nINSERT INTO Students(firstname) VALUES ('Robert');\nDROP TABLE Students;\n--');\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Connection Code Examples\nDESCRIPTION: Rust code examples demonstrating different ways to establish PostgreSQL connections using SQLx, including URL strings and manual configuration.\nSOURCE: https://github.com/launchbadge/sqlx/blob/main/sqlx-postgres/src/options/doc.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse sqlx::{Connection, ConnectOptions};\nuse sqlx::postgres::{PgConnectOptions, PgConnection, PgPool, PgSslMode};\n\n# async fn example() -> sqlx::Result<()> {\n// URL connection string\nlet conn = PgConnection::connect(\"postgres://localhost/mydb\").await?;\n\n// Manually-constructed options\nlet conn = PgConnectOptions::new()\n    .host(\"secret-host\")\n    .port(2525)\n    .username(\"secret-user\")\n    .password(\"secret-password\")\n    .ssl_mode(PgSslMode::Require)\n    .connect()\n    .await?;\n\n// Modifying options parsed from a string\nlet mut opts: PgConnectOptions = \"postgres://localhost/mydb\".parse()?;\n\n// Change the log verbosity level for queries.\n// Information about SQL queries is logged at `DEBUG` level by default.\nopts = opts.log_statements(log::LevelFilter::Trace);\n\nlet pool = PgPool::connect_with(opts).await?;\n# Ok(())\n# }\n```"
  }
]