[
  {
    "owner": "espressif",
    "repo": "arduino-esp32",
    "content": "TITLE: WiFi Begin - Arduino\nDESCRIPTION: This code snippet initializes the WiFi connection in station mode, connecting to a specified network. It takes the SSID and password of the target network as input.  It's a blocking call that attempts to establish a WiFi connection using provided credentials.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_23\n\nLANGUAGE: arduino\nCODE:\n```\nWiFi.begin(ssid, password);\n```\n\n----------------------------------------\n\nTITLE: Blinking LED on ESP32 using Arduino\nDESCRIPTION: This code snippet is a basic \"blink\" example for the Arduino environment, specifically targeting ESP32 boards. It configures the built-in LED pin as an output and toggles it on and off with a one-second delay. The setup() function initializes the LED pin, and the loop() function repeatedly sets the pin HIGH (on) and LOW (off) with a delay in between. It depends on the Arduino core library for pin manipulation and timing functions. The LED_BUILTIN constant represents the pin number connected to the on-board LED.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/basic.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\n/*\nBlink\n\nTurns an LED on for one second, then off for one second, repeatedly.\n\nMost Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO\nit is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to\nthe correct LED pin independent of which board is used.\nIf you want to know what pin the on-board LED is connected to on your Arduino\nmodel, check the Technical Specs of your board at:\nhttps://www.arduino.cc/en/Main/Products\n\nmodified 8 May 2014\nby Scott Fitzgerald\nmodified 2 Sep 2016\nby Arturo Guadalupi\nmodified 8 Sep 2016\nby Colby Newman\n\nThis example code is in the public domain.\n\nhttp://www.arduino.cc/en/Tutorial/Blink\n*/\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n// initialize digital pin LED_BUILTIN as an output.\npinMode(LED_BUILTIN, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\ndigitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)\ndelay(1000);                       // wait for a second\ndigitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW\ndelay(1000);                       // wait for a second\n}\n```\n\n----------------------------------------\n\nTITLE: Set GPIO Mode using pinMode - Arduino\nDESCRIPTION: Configures the GPIO pin's operation mode.  The `pinMode` function sets the specified pin to either input or output mode, with optional pull-up or pull-down resistors. It takes the pin number and mode as input. Supported modes are INPUT, OUTPUT, INPUT_PULLDOWN, and INPUT_PULLUP.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/gpio.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nvoid pinMode(uint8_t pin, uint8_t mode);\n```\n\n----------------------------------------\n\nTITLE: Initializing ESP-NOW Communication - begin()\nDESCRIPTION: Initializes ESP-NOW communication. This function must be called before using any other ESP-NOW functionalities. The optional `pmk` parameter allows for passing a pairwise master key (PMK) if encryption is enabled. Returns `true` if initialization is successful, `false` otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nbool begin(const uint8_t *pmk = NULL);\n```\n\n----------------------------------------\n\nTITLE: Starting I2C Transmission to Address - Arduino\nDESCRIPTION: Begins an I2C transmission to the specified slave address. This must be called before writing data using the `write` function.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_16\n\nLANGUAGE: arduino\nCODE:\n```\nvoid beginTransmission(uint16_t address)\n```\n\n----------------------------------------\n\nTITLE: Initializing I2C Peripheral - Default Configuration - Arduino\nDESCRIPTION: Initializes the I2C peripheral with default configurations. It returns a boolean indicating the success of the initialization. This function is used in both master and slave modes.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nbool begin();\n```\n\n----------------------------------------\n\nTITLE: Initializing Preferences Object in Arduino\nDESCRIPTION: This snippet declares a `Preferences` object named `mySketchPrefs`. This object will be used to interact with the Preferences library and manage namespaces and key-value pairs within the ESP32's NVS. You must include this declaration in your Arduino sketch to utilize the library's functionalities.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nPreferences mySketchPrefs;    // \"mySketchPrefs\" is the name of the Preferences object.\n                                 //  Can be whatever you want.\n```\n\n----------------------------------------\n\nTITLE: Arduino I2C Slave Example using Wire Library\nDESCRIPTION: This snippet represents a complete Arduino example, 'WireSlave.ino', which showcases how to use the I2C interface in slave mode. The example, which can be found under the provided link, demonstrates setting up the I2C slave and handling communication with a master device. The Wire library is used for I2C communication.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_27\n\nLANGUAGE: arduino\nCODE:\n```\n.. literalinclude:: ../../../libraries/Wire/examples/WireSlave/WireSlave.ino\n    :language: arduino\n```\n\n----------------------------------------\n\nTITLE: Configuring Timer Alarm - timerAlarm (Arduino)\nDESCRIPTION: This function configures the timer's alarm.  When the timer counter reaches the alarm value, an event can be generated.  It allows to set alarm value, autoreload and reload counter. The function takes the timer structure, the alarm value, autoreload flag, and reload count as parameters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_14\n\nLANGUAGE: arduino\nCODE:\n```\nvoid timerAlarm(hw_timer_t * timer, uint64_t alarm_value, bool autoreload, uint64_t reload_count);\n```\n\n----------------------------------------\n\nTITLE: WiFi Begin - Arduino\nDESCRIPTION: This function starts the Wi-Fi connection after being configured. It initiates the Wi-Fi process based on the previously configured settings. A successful configuration will return a `wl_status_t`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_27\n\nLANGUAGE: arduino\nCODE:\n```\nwl_status_t begin();\n```\n\n----------------------------------------\n\nTITLE: Write Digital Value to GPIO - Arduino\nDESCRIPTION: Sets the digital state of a GPIO pin configured as output. The `digitalWrite` function sets the specified pin to HIGH or LOW. It requires the pin number and the desired digital value as input and operates only on pins configured as OUTPUT.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/gpio.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nvoid digitalWrite(uint8_t pin, uint8_t val);\n```\n\n----------------------------------------\n\nTITLE: WiFi setAutoReconnect - Arduino\nDESCRIPTION: This function sets the automatic reconnection option. If enabled, the device will automatically attempt to reconnect if the connection is lost. Setting `autoReconnect` to `true` enables the auto-reconnect feature. A successful configuration will return `true`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_33\n\nLANGUAGE: arduino\nCODE:\n```\nbool setAutoReconnect(bool autoReconnect);\n```\n\n----------------------------------------\n\nTITLE: Attach Interrupt to GPIO - Arduino\nDESCRIPTION: Attaches an interrupt to a specified GPIO pin. The `attachInterrupt` function sets up an interrupt on the given pin, triggering a handler function based on the specified mode (e.g., RISING, FALLING, CHANGE). It requires the pin number, the handler function, and the interrupt mode as input.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/gpio.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nattachInterrupt(uint8_t pin, voidFuncPtr handler, int mode);\n```\n\n----------------------------------------\n\nTITLE: Put Int Value Arduino\nDESCRIPTION: This function stores an `int` value (int32_t) associated with a given key in the currently open namespace. If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putInt(const char* key, int32_t value)\n```\n\n----------------------------------------\n\nTITLE: Starting Wi-Fi in Access Point Mode\nDESCRIPTION: Starts the Wi-Fi module in Access Point (AP) mode, creating a Wi-Fi network that other devices can connect to.  Requires SSID and password parameters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nWiFi.softAP(ssid, password);\n```\n\n----------------------------------------\n\nTITLE: GPIO Input and Output Example - Arduino\nDESCRIPTION: Illustrates a basic GPIO input and output example, controlling an LED based on button input. The code configures an LED pin as output and a button pin as input with a pull-up resistor.  It reads the button state and toggles the LED accordingly.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/gpio.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\n#define LED    12\n#define BUTTON 2\n\nuint8_t stateLED = 0;\n\n  void setup() {\n      pinMode(LED, OUTPUT);\n      pinMode(BUTTON,INPUT_PULLUP);\n  }\n\n  void loop() {\n\n     if(!digitalRead(BUTTON)){\n       stateLED = stateLED^1;\n      digitalWrite(LED,stateLED);\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Full Blink Code - C++\nDESCRIPTION: This code combines all the snippets into a complete blink program. It includes the definition of the LED pin, the initialization in the ``setup()`` function, and the blinking logic in the ``loop()`` function. This example demonstrates the basic structure of an Arduino program and how to control GPIO pins to interact with external hardware like an LED.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/blink.rst#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#define LED 2\n\nvoid setup() {\n    pinMode(LED, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(LED, HIGH);\n    delay(100);\n    digitalWrite(LED, LOW);\n    delay(100);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting ADC Pin Attenuation Using analogSetPinAttenuation (Arduino)\nDESCRIPTION: This snippet shows how to configure attenuation for a specific ADC pin using `analogSetPinAttenuation`.  It takes a pin number and an `adc_attenuation_t` value as input. This allows for different attenuation settings on different pins.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nvoid analogSetPinAttenuation(uint8_t pin, adc_attenuation_t attenuation);\n```\n\n----------------------------------------\n\nTITLE: Put UChar Value Arduino\nDESCRIPTION: This function stores an `unsigned char` value (uint8_t) associated with a given key in the currently open namespace. If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putUChar(const char* key, uint8_t value)\n```\n\n----------------------------------------\n\nTITLE: Example Log Output (Unprotected Access)\nDESCRIPTION: Demonstrates the output when accessing shared variables without mutex protection, resulting in frequent data corruption and mismatches due to task interruption and overwriting of values.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/ESP32/examples/FreeRTOS/Mutex/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n Task 0          | Task 1\n                 | Starting\n                 | 0 <- 333\n Starting        |\n 333 <- 620      |\n R: 620          |\n 620 <- 244      |\n                 | R: 244\n                 | Mismatch!\n                 | 244 <- 131\n R: 131          |\n Mismatch!       |\n 131 <- 584      |\n                 | R: 584\n                 | Mismatch!\n                 | 584 <- 134\n                 | R: 134\n                 | 134 <- 554\n R: 554          |\n Mismatch!       |\n 554 <- 313      |\n```\n\n----------------------------------------\n\nTITLE: Registering Function for Root URL Handling\nDESCRIPTION: Registers the `handleRoot` function to handle requests to the server's base URL (`/`). The `handleRoot` function checks for the existence of `/index.htm` in the file system and redirects to it if it exists, otherwise, it redirects to the built-in `/$upload.htm` web page.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/WebServer/README.md#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nserver.on(\"/$upload.htm\", handleRoot);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Long/ULong Values from Preferences - Arduino\nDESCRIPTION: This code snippet illustrates how to retrieve a long or unsigned long value associated with a given key from the currently open namespace using `getLong` and `getULong` functions. It accepts a key and an optional default value. It returns the stored value or the default value if the key is not found or if there are any failures, similar to `getChar`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_24\n\nLANGUAGE: arduino\nCODE:\n```\nint32_t getLong(const char* key, int32_t defaultValue = 0)\nuint32_t getULong(const char* key, uint32_t defaultValue = 0)\n```\n\n----------------------------------------\n\nTITLE: Print Local IP Address - Arduino\nDESCRIPTION: This code snippet prints the local IP address of the ESP32 after a successful WiFi connection. It uses `WiFi.localIP()` to obtain the IP address and then prints it to the serial monitor.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_25\n\nLANGUAGE: arduino\nCODE:\n```\nSerial.println(\"IP address: \");\n    Serial.println(WiFi.localIP());\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Parameter (Param constructor)\nDESCRIPTION: This function creates a custom parameter for devices. It requires the parameter's name, type (optional), default value, and properties. The value should be defined using `value(int ival)`, `value(bool bval)`, `value(float fval)`, or `value(char *sval)`. The properties are a logical OR of flags such as `PROP_FLAG_WRITE`, `PROP_FLAG_READ`, `PROP_FLAG_TIME_SERIES`, and `PROP_FLAG_PERSIST`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_25\n\nLANGUAGE: C\nCODE:\n```\nParam my_param(const char *param_name, const char *param_type, param_val_t val, uint8_t properties);\n```\n\n----------------------------------------\n\nTITLE: Writing LEDC Tone - Arduino\nDESCRIPTION: Sets up an LEDC pin to a 50% PWM tone at a selected frequency. It accepts the pin number and frequency as input and returns the frequency set for the LEDC pin. If frequency is 0, duty will be set to 0.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\nuint32_t ledcWriteTone(uint8_t pin, uint32_t freq);\n```\n\n----------------------------------------\n\nTITLE: Storing a Boolean Value in Preferences - Arduino\nDESCRIPTION: This code snippet demonstrates how to store a boolean value associated with a given key in the currently open Preferences namespace using the `putBool` function. It requires a key and a boolean value as input and returns true on success, false otherwise. A failure will also trigger a log message to the arduino-esp32 `log_e` facility.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_18\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putBool(const char* key, bool value)\n```\n\n----------------------------------------\n\nTITLE: Configuring Static IP Address for AP\nDESCRIPTION: Configures a static (fixed) IP address, gateway, and subnet mask for the Wi-Fi Access Point (AP).  This allows the AP to have a predictable IP address.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\nbool softAPConfig(IPAddress local_ip, IPAddress gateway, IPAddress subnet);\n```\n\n----------------------------------------\n\nTITLE: Initializing I2C Master with Pins & Frequency - Arduino\nDESCRIPTION: Initializes the I2C peripheral in master mode, allowing custom specification of SDA and SCL pins, along with the bus frequency. Returns true if successful.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_15\n\nLANGUAGE: arduino\nCODE:\n```\nbool begin(int sdaPin, int sclPin, uint32_t frequency)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Int/UInt Values from Preferences - Arduino\nDESCRIPTION: This code snippet describes how to retrieve an int or unsigned int value associated with a given key from the currently open namespace using `getInt` and `getUInt` functions. It takes a key and an optional default value. It returns the stored value or the default value if the key is not found or if there are any failures. It operates similarly to `getChar`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_23\n\nLANGUAGE: arduino\nCODE:\n```\nint32_t getInt(const char* key, int32_t defaultValue = 0)\nuint32_t getUInt(const char* key, uint32_t defaultValue = 0)\n```\n\n----------------------------------------\n\nTITLE: Retrieving String (Arduino String) from Preferences - Arduino\nDESCRIPTION: This code snippet demonstrates how to retrieve an Arduino String value associated with a given key from the currently open namespace using the `getString` function. It takes a key and an optional default value (an empty String by default). It returns the stored String or the default value if the key is not found or if there are any failures.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_30\n\nLANGUAGE: arduino\nCODE:\n```\nString getString(const char* key, String defaultValue = String());\n```\n\n----------------------------------------\n\nTITLE: Setting I2C Pins - Arduino\nDESCRIPTION: Configures the SDA and SCL pins for the I2C peripheral. This function must be called before `begin()` to override the default pin assignments. Returns true if configuration was successful.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nbool setPins(int sdaPin, int sclPin);\n```\n\n----------------------------------------\n\nTITLE: Timer Wake Up - Deep Sleep - Arduino\nDESCRIPTION: This example demonstrates how to wake up the ESP32 from deep sleep using a timer.  The code sets a timer that will wake up the ESP32 after a specified duration. Upon waking up, the ESP32 prints a message to the serial monitor. It depends on the ESP32 Arduino core library.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/deepsleep.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\n.. literalinclude:: ../../../libraries/ESP32/examples/DeepSleep/TimerWakeUp/TimerWakeUp.ino\n    :language: arduino\n```\n\n----------------------------------------\n\nTITLE: Setting ADC Read Resolution Using analogReadResolution (Arduino)\nDESCRIPTION: This code shows how to set the resolution of the `analogRead` function using `analogReadResolution`. The function takes the desired bit resolution as input. The range is 1-16. For ESP32 the hardware resolution is 9-12, else the value will be shifted.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nvoid analogReadResolution(uint8_t bits);\n```\n\n----------------------------------------\n\nTITLE: Writing LEDC Duty Cycle - Arduino\nDESCRIPTION: Sets the duty cycle for a given LEDC pin. It takes the pin number and the duty cycle value as input and returns a boolean indicating success.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nbool ledcWrite(uint8_t pin, uint32_t duty);\n```\n\n----------------------------------------\n\nTITLE: Put UInt Value Arduino\nDESCRIPTION: This function stores an `unsigned int` value (uint32_t) associated with a given key in the currently open namespace. If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putUInt(const char* key, uint32_t value)\n```\n\n----------------------------------------\n\nTITLE: Setting DAC Value on a Pin (dacWrite) - Arduino\nDESCRIPTION: The `dacWrite` function sets the DAC output value for a specified GPIO pin. It takes the pin number and the desired output value (0-255, corresponding to 0V-3.3V) as input. This function enables the specified DAC channel with the given voltage.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/dac.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nvoid dacWrite(uint8_t pin, uint8_t value);\n```\n\n----------------------------------------\n\nTITLE: Updating and Reporting Param in Arduino\nDESCRIPTION: Updates the parameter's value and reports it to the ESP RainMaker cloud. This function should be called within the device write callback to propagate changes. It takes the new value of the parameter as input. Returns ESP_OK on success, or an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_28\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t updateAndReport(param_val_t val);\n```\n\n----------------------------------------\n\nTITLE: Starting USB CDC Peripheral - Arduino\nDESCRIPTION: Initializes and starts the USB CDC peripheral with a specified baud rate. This enables the ESP32 to communicate with a host device over USB as a serial port. The baud rate is an unsigned long integer.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nvoid begin(unsigned long baud);\n```\n\n----------------------------------------\n\nTITLE: Reading Analog Value Using analogRead (Arduino)\nDESCRIPTION: This snippet shows how to use the `analogRead` function to get the ADC raw value for a given pin on an ESP32 board. It takes a GPIO pin as input and returns the raw analog value (non-calibrated). The resolution is configurable using `analogReadResolution` function. The default resolution is 12 bits except for ESP32-S3 which is 13 bits.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nuint16_t analogRead(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: WiFi Disconnect - Arduino\nDESCRIPTION: This function disconnects the Wi-Fi connection. It can optionally turn off the Wi-Fi radio and erase the AP configuration from the NVS memory. The `wifioff` parameter controls whether the Wi-Fi radio is turned off, and the `eraseap` parameter controls whether the AP configuration is erased. A successful configuration will return `true`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_31\n\nLANGUAGE: arduino\nCODE:\n```\nbool disconnect(bool wifioff = false, bool eraseap = false);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Bytes from Preferences - Arduino\nDESCRIPTION: This code snippet shows how to retrieve a sequence of bytes associated with a given key from the currently open namespace using the `getBytes` function. It requires a key, a buffer to store the bytes, and the number of bytes to retrieve. It returns the number of bytes read (equal to len) on success, writing the bytes to the buffer, and 0 on failure, leaving the buffer untouched. The provided `len` must match the stored byte length to succeed. A failure will also trigger a log message to the arduino-esp32 `log_e` facility.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_31\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t getBytes(const char* key, void * buf, size_t len);\n```\n\n----------------------------------------\n\nTITLE: Retrieving String (Char Buffer) from Preferences - Arduino\nDESCRIPTION: This code snippet outlines how to retrieve a string (as a char buffer) associated with a given key from the currently open namespace using the `getString` function. It requires a key, a char buffer to store the string, and the length of the buffer. It returns 1 on success, writing the string to the buffer, and 0 on failure, leaving the buffer untouched. `len` must equal the stored string length. A failure will also trigger a log message to the arduino-esp32 `log_e` facility.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_29\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t getString(const char* key, char* value, size_t len);\n```\n\n----------------------------------------\n\nTITLE: Opening or Creating a Preferences Namespace in Arduino\nDESCRIPTION: This snippet demonstrates how to open or create a namespace using the `begin()` method.  The first argument specifies the namespace name (\"myPrefs\"), and the second argument determines the access mode (read-write if `false`, read-only if `true`).  If the namespace doesn't exist, it will be created. If it exists, it will be opened in the specified mode.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nmySketchPrefs.begin(\"myPrefs\", false)\n```\n\n----------------------------------------\n\nTITLE: Setting I2C Timeout - Arduino\nDESCRIPTION: Sets the timeout in milliseconds for the I2C bus. The default value is 50 ms.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nvoid setTimeOut(uint16_t timeOutMillis);\n```\n\n----------------------------------------\n\nTITLE: Configuring WiFi and ThingSpeak Credentials in C++\nDESCRIPTION: This code snippet shows how to define variables for Wi-Fi SSID, password, ThingSpeak channel ID, and API keys. These values are used to connect to the Wi-Fi network and authenticate with the ThingSpeak service.  The host and port are also defined.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WiFiClient/README.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconst char* ssid     = \"your-ssid\"; // Change this to your WiFi SSID\nconst char* password = \"your-password\"; // Change this to your WiFi password\n\nconst char* host = \"api.thingspeak.com\"; // This should not be changed\nconst int httpPort = 80; // This should not be changed\nconst String channelID   = \"2005329\"; // Change this to your channel ID\nconst String writeApiKey = \"V6YOTILH9I7D51F9\"; // Change this to your Write API key\nconst String readApiKey = \"34W6LGLIFXD56MPM\"; // Change this to your Read API key\n\n// The default example accepts one data filed named \"field1\"\n// For your own server you can ofcourse create more of them.\nint field1 = 0;\n\nint numberOfResults = 3; // Number of results to be read\nint fieldNumber = 1; // Field number which will be read out\n```\n\n----------------------------------------\n\nTITLE: Put Short Value Arduino\nDESCRIPTION: This function stores a `short` value (int16_t) associated with a given key in the currently open namespace. If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putShort(const char* key, int16_t value)\n```\n\n----------------------------------------\n\nTITLE: Starting Timer Counter - timerStart (Arduino)\nDESCRIPTION: This function starts the counter of the given timer. It enables the timer to begin counting based on the configured frequency. It accepts timer struct as parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nvoid timerStart(hw_timer_t * timer);\n```\n\n----------------------------------------\n\nTITLE: Reading Bytes from I2C - Arduino\nDESCRIPTION: Reads bytes from the I2C bus after a `requestFrom` call. Stores the received data in the provided buffer.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_14\n\nLANGUAGE: arduino\nCODE:\n```\nWire.readBytes(temp, error);\n```\n\n----------------------------------------\n\nTITLE: Attaching LEDC Channel - Arduino\nDESCRIPTION: Sets up an LEDC pin with a given frequency, resolution, and channel. Multiple pins attached to the same channel share the same duty cycle. It accepts the pin number, frequency, resolution (1-14 bits, 1-20 bits for ESP32), and channel number as input and returns a boolean indicating success.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nbool ledcAttachChannel(uint8_t pin, uint32_t freq, uint8_t resolution, int8_t channel);\n```\n\n----------------------------------------\n\nTITLE: Reading Timer Counter Value - timerRead (Arduino)\nDESCRIPTION: This function reads the current counter value of the given timer. It provides access to the current count for monitoring or calculation. It accepts timer struct as parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nuint64_t timerRead(hw_timer_t * timer);\n```\n\n----------------------------------------\n\nTITLE: Setting RX Buffer Size - Arduino\nDESCRIPTION: Sets the size of the receive (RX) buffer for the USB CDC interface.  The function returns the actual size of the buffer set. Larger buffers may be needed for high-throughput applications to avoid data loss.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t setRxBufferSize(size_t size);\n```\n\n----------------------------------------\n\nTITLE: Changing LEDC Frequency - Arduino\nDESCRIPTION: Sets the frequency for a LEDC pin. It accepts the pin number, frequency, and resolution (1-14 bits, 1-20 bits for ESP32) as input and returns the configured frequency.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\nuint32_t ledcChangeFrequency(uint8_t pin, uint32_t freq, uint8_t resolution);\n```\n\n----------------------------------------\n\nTITLE: Put Float Value Arduino\nDESCRIPTION: This function stores a `float` value associated with a given key in the currently open namespace. If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_14\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putFloat(const char* key, float_t value)\n```\n\n----------------------------------------\n\nTITLE: Writing Analog Value (PWM) - Arduino\nDESCRIPTION: Writes an analog value (PWM wave) to a pin. Compatible with Arduino's analogWrite function. Takes the pin number and a value between 0 (always off) and 255 (always on) as input.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_16\n\nLANGUAGE: arduino\nCODE:\n```\nvoid analogWrite(uint8_t pin, int value);\n```\n\n----------------------------------------\n\nTITLE: WiFi isConnected - Arduino\nDESCRIPTION: This function returns the current connection state of the WiFi. It returns true if the device is currently connected to a WiFi network.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_32\n\nLANGUAGE: arduino\nCODE:\n```\nbool isConnected();\n```\n\n----------------------------------------\n\nTITLE: Adding Standard Parameters to a Device (addXParam)\nDESCRIPTION: These functions allow adding standard parameters to an ESP RainMaker device. Each function adds a specific parameter type (Name, Power, Brightness, Hue, Saturation, Intensity, CCT, Direction, Speed, Temperature) with an optional custom parameter name. The default parameter name is used if no custom name is provided. These functions return an `esp_err_t` indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_19\n\nLANGUAGE: C\nCODE:\n```\nesp_err_t addNameParam(const char *param_name = ESP_RMAKER_DEF_NAME_PARAM);\nesp_err_t addPowerParam(bool val, const char *param_name = ESP_RMAKER_DEF_POWER_NAME);\nesp_err_t addBrightnessParam(int val, const char *param_name = ESP_RMAKER_DEF_BRIGHTNESS_NAME);\nesp_err_t addHueParam(int val, const char *param_name = ESP_RMAKER_DEF_HUE_NAME);\nesp_err_t addSaturationParam(int val, const char *param_name = ESP_RMAKER_DEF_SATURATION_NAME);\nesp_err_t addIntensityParam(int val, const char *param_name = ESP_RMAKER_DEF_INTENSITY_NAME);\nesp_err_t addCCTParam(int val, const char *param_name = ESP_RMAKER_DEF_CCT_NAME);\nesp_err_t addDirectionParam(int val, const char *param_name = ESP_RMAKER_DEF_DIRECTION_NAME);\nesp_err_t addSpeedParam(int val, const char *param_name = ESP_RMAKER_DEF_SPEED_NAME);\nesp_err_t addTemperatureParam(float val, const char *param_name = ESP_RMAKER_DEF_TEMPERATURE_NAME);\n```\n\n----------------------------------------\n\nTITLE: Reading ADC Continuous Data Using analogContinuousRead (Arduino)\nDESCRIPTION: This snippet shows how to read ADC continuous data to a buffer using `analogContinuousRead`. It takes a pointer to a buffer (of type `adc_continuous_data_t`) and a timeout in milliseconds as input. It returns true on success and false on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\nbool analogContinuousRead(adc_continuous_data_t ** buffer, uint32_t timeout_ms);\n```\n\n----------------------------------------\n\nTITLE: External Wake Up - Deep Sleep - Arduino\nDESCRIPTION: This example demonstrates how to wake up the ESP32 from deep sleep using an external signal.  The code configures a GPIO pin as an external interrupt source. When the pin is triggered, the ESP32 wakes up and prints a message to the serial monitor. It relies on the ESP32 Arduino core library.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/deepsleep.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\n.. literalinclude:: ../../../libraries/ESP32/examples/DeepSleep/ExternalWakeUp/ExternalWakeUp.ino\n    :language: arduino\n```\n\n----------------------------------------\n\nTITLE: Initializing I2S in Master Mode - Arduino\nDESCRIPTION: This function initializes the I2S peripheral in master mode. It configures the operation mode, sampling rate, data bit width, and slot mode. It returns true on success and false on failure, printing an error message if logging is enabled. It requires the i2s_mode_t, uint32_t, i2s_data_bit_width_t, and i2s_slot_mode_t parameters to be defined.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nbool begin(i2s_mode_t mode, uint32_t rate, i2s_data_bit_width_t bits_cfg, i2s_slot_mode_t ch, int8_t slot_mask=-1)\n```\n\n----------------------------------------\n\nTITLE: Performing Factory Reset (RMakerFactoryReset)\nDESCRIPTION: This function resets the device to its factory defaults. It takes the time in seconds after which the chip should reboot after doing a factory reset as a parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_30\n\nLANGUAGE: C\nCODE:\n```\nRMakerFactoryReset(2);\n```\n\n----------------------------------------\n\nTITLE: Example Log Output (Mutex Protected)\nDESCRIPTION: Illustrates the expected output when shared variables are protected by a mutex, showing mutually exclusive access from the tasks, preventing interruption and data corruption.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/ESP32/examples/FreeRTOS/Mutex/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n Task 0          | Task 1\n                 | Starting\n                 | 0 <- 227\n Starting        |\n                 | R: 227\n 227 <- 737      |\n R: 737          |\n                 | 737 <- 282\n                 | R: 282\n 282 <- 267      |\n```\n\n----------------------------------------\n\nTITLE: Begin Preferences Namespace Arduino\nDESCRIPTION: This function opens a namespace within the non-volatile storage (NVS) for storing and retrieving key-value pairs. It takes the namespace name, read-only flag and partition label as parameters and returns a boolean indicating success. A new namespace is created if it does not exist.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nbool begin(const char * name, bool readOnly=false, const char* partition_label=NULL)\n```\n\n----------------------------------------\n\nTITLE: Configuring I2S TX - Arduino\nDESCRIPTION: This function configures the I2S TX (transmit) channel. It sets the sampling rate, data bit width, slot mode, and slot mask.  It returns true on success and false on failure, with an error message printed if logging is enabled.  This function allows dynamic adjustment of TX channel parameters during operation.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nbool configureTX(uint32_t rate, i2s_data_bit_width_t bits_cfg, i2s_slot_mode_t ch, int8_t slot_mask=-1)\n```\n\n----------------------------------------\n\nTITLE: Checking Available Data - Arduino\nDESCRIPTION: Checks if there are any messages available in the receive queue. Returns the number of bytes available to be read.  This allows the program to avoid blocking when reading from the USB CDC interface.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nint available(void);\n```\n\n----------------------------------------\n\nTITLE: Registering Wi-Fi Event Callback Function\nDESCRIPTION: Registers a function to be called when Wi-Fi events occur, allowing for event-driven programming. Several function signature options are provided for different use cases. The callback is invoked on a separate thread and should be thread-safe.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\ntypedef void (*WiFiEventCb)(arduino_event_id_t);\n    wifi_event_id_t onEvent(WiFiEventCb, arduino_event_id_t = ARDUINO_EVENT_MAX);\n```\n\nLANGUAGE: arduino\nCODE:\n```\ntypedef struct{\n        arduino_event_id_t event_id;\n        arduino_event_info_t event_info;\n    } arduino_event_t;\n\n    typedef void (*WiFiEventSysCb)(arduino_event_t *);\n    wifi_event_id_t onEvent(WiFiEventSysCb, arduino_event_id_t = ARDUINO_EVENT_MAX);\n```\n\nLANGUAGE: arduino\nCODE:\n```\ntypedef std::function<void(arduino_event_id_t, arduino_event_info_t)> WiFiEventFuncCb;\n    wifi_event_id_t onEvent(WiFiEventFuncCb, arduino_event_id_t = ARDUINO_EVENT_MAX);\n```\n\n----------------------------------------\n\nTITLE: Initializing I2C Slave with Address - Arduino\nDESCRIPTION: Initializes the I2C peripheral in slave mode, specifying the slave address. Uses default settings for pins and frequency.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_21\n\nLANGUAGE: arduino\nCODE:\n```\nWire.begin((uint8_t)I2C_DEV_ADDR);\n```\n\n----------------------------------------\n\nTITLE: Assigning a Primary Parameter (assignPrimaryParam)\nDESCRIPTION: This function assigns a parameter as the primary parameter for a device, which is used by clients to give it prominence. It requires the handle of the parameter, which can be obtained using `my_device.getParamByName()`. It returns an `esp_err_t` indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_20\n\nLANGUAGE: C\nCODE:\n```\nesp_err_t assignPrimaryParam(param_handle_t *param);\n```\n\n----------------------------------------\n\nTITLE: Attaching LEDC Pin - Arduino\nDESCRIPTION: Sets up an LEDC pin with a given frequency and resolution, automatically selecting an available LEDC channel. The function takes the pin number, frequency, and resolution (1-14 bits, 1-20 bits for ESP32) as input and returns a boolean indicating success.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nbool ledcAttach(uint8_t pin, uint32_t freq, uint8_t resolution);\n```\n\n----------------------------------------\n\nTITLE: Checking Key Existence in Arduino Preferences and Handling First Run\nDESCRIPTION: This code segment demonstrates a typical use case of the Preferences library: determining if a key exists to differentiate between the first run of the sketch and subsequent runs. It opens a namespace, checks for the existence of a key, and executes different code blocks based on the result, handling both first-time initialization and subsequent startup scenarios.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nPreferences mySketchPrefs;\n   String doesExist;\n\n   mySketchPrefs.begin(\"myPrefs\", false);   // open (or create and then open if it does not\n                                            //  yet exist) the namespace \"myPrefs\" in RW mode.\n\n   bool doesExist = mySketchPrefs.isKey(\"myTestKey\");\n\n   if (doesExist == false) {\n       /*\n          If doesExist is false, we will need to create our\n           namespace key(s) and store a value into them.\n      */\n\n      // Insert your \"first time run\" code to create your keys & assign their values below here.\n   }\n   else {\n      /*\n          If doesExist is true, the key(s) we need have been created before\n           and so we can access their values as needed during startup.\n      */\n\n      // Insert your \"we've been here before\" startup code below here.\n   }\n```\n\n----------------------------------------\n\nTITLE: Configuring SPI pins with SPI.begin() - Arduino\nDESCRIPTION: This code shows how to configure the SPI pins for the SD card using the SPI.begin() function. It allows you to specify the SCK, MISO, MOSI, and CS pins. This is an alternative to using the default SPI pins or only changing the CS pin.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/SD/README.md#_snippet_0\n\nLANGUAGE: Arduino\nCODE:\n```\nSPI.begin(sck, miso, mosi, cs);\n```\n\n----------------------------------------\n\nTITLE: Put ULong64 Value Arduino\nDESCRIPTION: This function stores an `unsigned long long` or `uint64_t` value associated with a given key in the currently open namespace. If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_16\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putULong64(const char* key, uint64_t value)\n```\n\n----------------------------------------\n\nTITLE: Sending Data to a Peer - send()\nDESCRIPTION: Sends data to the peer. Takes a pointer to the data (`data`) and the length of the data in bytes (`len`). Returns the number of bytes sent, or `0` if an error occurs.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nsize_t send(const uint8_t *data, int len);\n```\n\n----------------------------------------\n\nTITLE: Check WiFi Connection Status - Arduino\nDESCRIPTION: This code snippet checks the status of the WiFi connection. It loops until the WiFi status is equal to `WL_CONNECTED`, indicating a successful connection. During the loop, it prints a period to the serial monitor every 500 milliseconds.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_24\n\nLANGUAGE: arduino\nCODE:\n```\nwhile (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n```\n\n----------------------------------------\n\nTITLE: Adding a Peer to ESP-NOW Network - add()\nDESCRIPTION: Adds the peer to the ESP-NOW network.  Returns `true` if the peer is added successfully, `false` otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nbool add();\n```\n\n----------------------------------------\n\nTITLE: Configuring serveStatic Plugin\nDESCRIPTION: Configures the `serveStatic` plugin to serve files from the LittleFS filesystem. It also enables CORS (Cross-Origin Resource Sharing) and ETag support for client-side caching. These configurations enhance the web server's functionality by allowing cross-origin requests and improving caching efficiency.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/WebServer/README.md#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nserver.enableCORS(true);\nserver.enableETag(true);\nserver.serveStatic(\"/\", LittleFS, \"/\");\n```\n\n----------------------------------------\n\nTITLE: Writing Data to USB CDC - Arduino\nDESCRIPTION: Writes a specified number of bytes from a provided buffer to the USB CDC transmit buffer. Returns the number of bytes actually written. The function requires a pointer to the buffer containing the data to be written and the number of bytes to be written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t write(const uint8_t *buffer, size_t size);\n```\n\n----------------------------------------\n\nTITLE: Storing Value in Arduino Preferences\nDESCRIPTION: This snippet shows the general form of storing a value in Preferences using the `putX` method, where X represents the data type. Requires namespace to be opened in read-write mode.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nmyPreferences.putX(\"myKeyName\", value)\n```\n\n----------------------------------------\n\nTITLE: Initializing USB MSC\nDESCRIPTION: This function initializes the USB MSC peripheral with a specified block count and block size. It sets up the device to be recognized as a mass storage device by the host computer. It returns true if the configuration was successful.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_msc.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nbool begin(uint32_t block_count, uint16_t block_size);\n```\n\n----------------------------------------\n\nTITLE: Updating and Reporting Parameter Value (updateAndReportParam)\nDESCRIPTION: This function updates the value of a parameter associated with a device and reports the change to the ESP RainMaker cloud. It requires the parameter name and the new value. The value can be an integer, boolean, character string, or float. It returns an `esp_err_t` indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_23\n\nLANGUAGE: C\nCODE:\n```\nesp_err_t updateAndReportParam(const char *param_name, value);\n```\n\n----------------------------------------\n\nTITLE: Writing Data to I2C Buffer - Arduino\nDESCRIPTION: Writes data to the internal I2C buffer. The data is not immediately transmitted but is buffered for later transmission using `endTransmission`. Returns the number of bytes added to the buffer.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t write(uint8_t);\n```\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t write(const uint8_t *, size_t);\n```\n\n----------------------------------------\n\nTITLE: Compile with Arduino CLI\nDESCRIPTION: This command compiles the Arduino sketch using the Arduino CLI and exports the resulting binary to the `build` directory using the `-e` switch. This is useful for preparing the binary for later flashing.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/variants/arduino_nano_nora/extra/nora_recovery/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\narduino-cli compile -u --programmer esptool\n```\n\n----------------------------------------\n\nTITLE: Updating and Reporting Parameter in Arduino\nDESCRIPTION: Updates the parameter associated with a specific device on the ESP RainMaker cloud. It takes the parameter name and the new value as input.  The value can be of type int, bool, char *, or float. Returns ESP_OK on success, or an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_23\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t updateAndReportParam(const char *param_name, value);\n```\n\n----------------------------------------\n\nTITLE: Initializing RainMaker Node - C++\nDESCRIPTION: This snippet shows how to initialize the ESP RainMaker agent, Wi-Fi, and create a node. The function takes the node's name and type as input and returns a Node object. It's important to set any node configurations before calling this function.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nNode initNode(const char *name, const char *type);\n```\n\n----------------------------------------\n\nTITLE: Enabling OTA Updates - C++\nDESCRIPTION: This snippet shows how to enable Over-The-Air (OTA) updates as per the ESP RainMaker specification. It takes an ota_type_t as input, specifying the OTA workflow type, and returns ESP_OK on success and an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nesp_err_t enableOTA(ota_type_t type);\n```\n\n----------------------------------------\n\nTITLE: Serial Communication via Bluetooth Arduino\nDESCRIPTION: This example demonstrates serial communication over Bluetooth using the BluetoothSerial library. It allows data to be sent and received between an ESP32 and a Bluetooth-enabled device. The example is located in the BluetoothSerial library examples folder.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/bluetooth.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\n#include \"BluetoothSerial.h\"\n\n#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BT_SPP_ENABLED)\n#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it\n#endif\n\nBluetoothSerial SerialBT;\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin(\"ESP32test\"); //Bluetooth device name\n  Serial.println(\"The device started, now you can pair it with bluetooth!\");\n}\n\nvoid loop() {\n  if (Serial.available()) {\n    SerialBT.write(Serial.read());\n  }\n  if (SerialBT.available()) {\n    Serial.write(SerialBT.read());\n  }\n  delay(20);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting I2C Clock Frequency - Arduino\nDESCRIPTION: Sets the clock frequency for the I2C bus. If not set, the default frequency is used. Returns true if the clock was configured correctly.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nbool setClock(uint32_t frequency);\n```\n\n----------------------------------------\n\nTITLE: Stopping ADC Continuous Conversion Using analogContinuousStop (Arduino)\nDESCRIPTION: This snippet illustrates stopping ADC continuous conversions using `analogContinuousStop`.  It returns true on successful stop and false on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\nbool analogContinuousStop();\n```\n\n----------------------------------------\n\nTITLE: Reading LEDC Duty Cycle - Arduino\nDESCRIPTION: Gets the configured duty cycle for a given LEDC pin. It takes the pin number as input and returns the duty cycle value.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nuint32_t ledcRead(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: Adding Standard Parameter to Device in Arduino\nDESCRIPTION: Adds a standard parameter (Name, Power, Brightness, Hue, Saturation, Intensity, CCT, Direction, Speed, Temperature) to the device.  Takes the value and optional parameter name as input.  Returns ESP_OK on success, or an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_19\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t addNameParam(const char *param_name = ESP_RMAKER_DEF_NAME_PARAM);\n    esp_err_t addPowerParam(bool val, const char *param_name = ESP_RMAKER_DEF_POWER_NAME);\n    esp_err_t addBrightnessParam(int val, const char *param_name = ESP_RMAKER_DEF_BRIGHTNESS_NAME);\n    esp_err_t addHueParam(int val, const char *param_name = ESP_RMAKER_DEF_HUE_NAME);\n    esp_err_t addSaturationParam(int val, const char *param_name = ESP_RMAKER_DEF_SATURATION_NAME);\n    esp_err_t addIntensityParam(int val, const char *param_name = ESP_RMAKER_DEF_INTENSITY_NAME);\n    esp_err_t addCCTParam(int val, const char *param_name = ESP_RMAKER_DEF_CCT_NAME);\n    esp_err_t addDirectionParam(int val, const char *param_name = ESP_RMAKER_DEF_DIRECTION_NAME);\n    esp_err_t addSpeedParam(int val, const char *param_name = ESP_RMAKER_DEF_SPEED_NAME);\n    esp_err_t addTempratureParam(float val, const char *param_name = ESP_RMAKER_DEF_TEMPERATURE_NAME);\n```\n\n----------------------------------------\n\nTITLE: Setting ADC Attenuation Using analogSetAttenuation (Arduino)\nDESCRIPTION: This snippet illustrates how to set the attenuation for all ADC channels using the `analogSetAttenuation` function. Attenuation allows adjusting the measurable input voltage range of the ADC. It accepts an `adc_attenuation_t` enum value to specify the attenuation level.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nvoid analogSetAttenuation(adc_attenuation_t attenuation);\n```\n\n----------------------------------------\n\nTITLE: ESP-NOW Peer Constructor\nDESCRIPTION: Creates an instance of the `ESP_NOW_Peer` class. Requires the MAC address of the peer device (`mac_addr`), the communication channel (`channel`), the Wi-Fi interface (`iface`), and optionally the local master key (LMK) if encryption is enabled.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nESP_NOW_Peer(const uint8_t *mac_addr, uint8_t channel, wifi_interface_t iface, const uint8_t *lmk);\n```\n\n----------------------------------------\n\nTITLE: Creating Device\nDESCRIPTION: This code snippet creates a virtual device on the node using the `Device` class. The constructor takes the device name, type, and private data as parameters. The created device must be added to the node using `my_node.addDevice(my_device);`\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_14\n\nLANGUAGE: arduino\nCODE:\n```\nDevice my_device(const char *dev_name, const char *dev_type, void *priv_data);\n```\n\nLANGUAGE: arduino\nCODE:\n```\nDevice my_device(\"Switch\");\n```\n\nLANGUAGE: arduino\nCODE:\n```\nDevice my_device(\"Switch1\", NULL, NULL);\n```\n\n----------------------------------------\n\nTITLE: Read Digital Value from GPIO - Arduino\nDESCRIPTION: Reads the digital state of a GPIO pin configured as input.  The `digitalRead` function returns the logical state of the selected pin as HIGH or LOW. The function requires the pin number as input and only works if the pin has been configured as INPUT.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/gpio.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nint digitalRead(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: Project Definition - CMake\nDESCRIPTION: Defines the name of the project within the CMake build system. This name is used to identify the project during the build process and in generated files. It is a fundamental setting that helps organize the project structure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/hw_cdc_hello_world/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nproject(hw_cdc_hello_world)\n```\n\n----------------------------------------\n\nTITLE: Opening Zigbee Network in Arduino-ESP32 Application\nDESCRIPTION: This code snippet demonstrates how to open the Zigbee network within the application using the Arduino-ESP32 library. This allows devices to join the network dynamically. The `Zigbee.openNetwork(time);` function is called to open the network for a specified duration (`time`) to allow devices to join.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Color_Dimmer_Switch/README.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nZigbee.openNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Opening Zigbee Network Arduino\nDESCRIPTION: This code snippet illustrates how to open the Zigbee network for a specified duration to allow other devices to join. `time` is the duration for which the network is open in seconds. This function can be called at any time from the application.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_CarbonDioxide_Sensor/README.md#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.openNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Float Value from Preferences - Arduino\nDESCRIPTION: This code snippet describes how to retrieve a float value associated with a given key from the currently open namespace using the `getFloat` function. It takes a key and an optional default value, which defaults to NAN (Not a Number). The function returns the stored value or the default value if the key is not found or if there are any failures, operating similarly to `getChar` but with a float return type.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_26\n\nLANGUAGE: arduino\nCODE:\n```\nfloat_t getFloat(const char* key, float_t defaultValue = NAN)\n```\n\n----------------------------------------\n\nTITLE: Inverting LEDC Output - Arduino\nDESCRIPTION: Sets the inverting output for a LEDC pin. It accepts the pin number and a boolean to enable or disable output inversion and returns a boolean indicating success.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\nbool ledcOutputInvert(uint8_t pin, bool out_invert);\n```\n\n----------------------------------------\n\nTITLE: Remove Key-Value Pair Arduino\nDESCRIPTION: This function deletes a specific key-value pair from the currently open namespace. It takes the key name as a parameter and returns a boolean indicating whether the deletion was successful.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nbool remove(const char * key)\n```\n\n----------------------------------------\n\nTITLE: Configuring Wi-Fi Buffer Memory Allocation\nDESCRIPTION: Sets the memory allocation mode for Wi-Fi buffers to either static or dynamic. Dynamic allocation saves memory but might be slightly slower. Static allocation provides better performance, especially in multi-tasking applications.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nstatic void useStaticBuffers(bool bufferMode);\n```\n\n----------------------------------------\n\nTITLE: Detaching Touch Interrupt with touchDetachInterrupt in Arduino\nDESCRIPTION: This function detaches an interrupt from the touch pad, disabling interrupt triggers.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/touch.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nvoid touchDetachInterrupt(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: Installing Python: Executable Not Found Fix (Ubuntu)\nDESCRIPTION: This snippet resolves the \"python: executable file not found in $PATH\" error during the build process on Ubuntu by installing the `python-is-python3` package. This creates the necessary symbolic link.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/troubleshooting.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt install python-is-python3\n```\n\n----------------------------------------\n\nTITLE: Initializing I2C Master - Arduino\nDESCRIPTION: Initializes the I2C peripheral in master mode with default settings. This is a basic initialization for master mode.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\nWire.begin();\n```\n\n----------------------------------------\n\nTITLE: Debian/Ubuntu Installation - Bash\nDESCRIPTION: This script installs the necessary dependencies for Arduino-ESP32 on Debian/Ubuntu systems. It updates the user's dialout group, installs Git, downloads and installs pip for Python, installs the pyserial library, clones the Arduino-ESP32 repository, and runs the get.py script to download additional tools.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/installing.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo usermod -a -G dialout $USER && \\\nsudo apt-get install git && \\\nwget https://bootstrap.pypa.io/get-pip.py && \\\nsudo python3 get-pip.py && \\\nsudo pip3 install pyserial && \\\nmkdir -p ~/Arduino/hardware/espressif && \\\ncd ~/Arduino/hardware/espressif && \\\ngit clone https://github.com/espressif/arduino-esp32.git esp32 && \\\ncd esp32/tools && \\\npython3 get.py\n```\n\n----------------------------------------\n\nTITLE: Setting Reboot Open Network Arduino\nDESCRIPTION: This code snippet demonstrates how to configure the Zigbee device to automatically open the network for a specified duration after rebooting. This allows other devices to join the network without manual intervention. `time` is the duration for which network is open in seconds.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_CarbonDioxide_Sensor/README.md#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.setRebootOpenNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Factory Reset Zigbee Device (Arduino)\nDESCRIPTION: This snippet shows how to add the `Zigbee.factoryReset();` call to your Arduino sketch in order to reset the Zigbee device and Zigbee stack to its factory defaults. It is used for troubleshooting connection issues, especially after re-flashing the coordinator. This ensures a clean slate for the Zigbee configuration.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Range_Extender/README.md#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.factoryReset();\n```\n\n----------------------------------------\n\nTITLE: Registering USB CDC Event Handler (onEvent) - Arduino\nDESCRIPTION: Registers a callback function to handle specific USB CDC events. The callback is triggered when the specified event occurs. The first version takes a generic event handler, while the second takes a specific event type and a handler. Events include connection, disconnection, line state, data reception, and transmission.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nvoid onEvent(esp_event_handler_t callback);\n```\n\nLANGUAGE: arduino\nCODE:\n```\nvoid onEvent(arduino_usb_cdc_event_t event, esp_event_handler_t callback);\n```\n\n----------------------------------------\n\nTITLE: Ethernet LAN8720 Initialization Arduino\nDESCRIPTION: This Arduino sketch demonstrates how to initialize and use the LAN8720 Ethernet module with the ESP32. It includes the necessary Ethernet library and configures the Ethernet connection using specific pin configurations suitable for LAN8720. The code sets up the Ethernet connection and prints the assigned IP address to the serial monitor.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ethernet.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\n#include <ETH.h>\n\nstatic bool eth_connected = false;\n\nvoid WiFiEvent(WiFiEvent_t event)\n{\n  switch (event) {\n    case SYSTEM_EVENT_ETH_START:\n      Serial.println(\"ETH Started\");\n      //set eth hostname here\n      ETH.setHostname(\"esp32-ethernet\");\n      break;\n    case SYSTEM_EVENT_ETH_CONNECTED:\n      Serial.println(\"ETH Connected\");\n      break;\n    case SYSTEM_EVENT_ETH_GOT_IP:\n      Serial.print(\"ETH MAC: \");\n      Serial.print(ETH.macAddress());\n      Serial.print(\", IPv4: \");\n      Serial.print(ETH.localIP());\n      if (ETH.fullDuplex()) {\n        Serial.println(\", FULL_DUPLEX\");\n      } else {\n        Serial.println(\", HALF_DUPLEX\");\n      }\n      eth_connected = true;\n      break;\n    case SYSTEM_EVENT_ETH_DISCONNECTED:\n      Serial.println(\"ETH Disconnected\");\n      eth_connected = false;\n      break;\n    case SYSTEM_EVENT_ETH_STOP:\n      Serial.println(\"ETH Stopped\");\n      eth_connected = false;\n      break;\n    default:\n      break;\n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"Starting Ethernet...\");\n  WiFi.onEvent(WiFiEvent);\n  ETH.begin();\n}\n\nvoid loop() {\n  if (eth_connected) {\n    // Do your thing here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Bytes Length from Preferences - Arduino\nDESCRIPTION: This code snippet gets the length (in bytes) of a value stored under a given key in the currently open namespace, specifically when the stored value is of type `Bytes`. It takes the key as input and returns the number of bytes stored or 0 if the operation fails. It is crucial that the stored value is actually of type `Bytes`. A failure will also trigger a log message to the arduino-esp32 `log_e` facility.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_32\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t getBytesLength(const char* key)\n```\n\n----------------------------------------\n\nTITLE: Getting Parameter Handle by Name (getParamByName)\nDESCRIPTION: This function retrieves the handle of a parameter based on its name. The parameter name should match the name used when adding the parameter using `addXparam()` or `addParam()`. It returns a `param_handle_t` pointer or NULL if the parameter is not found.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_21\n\nLANGUAGE: C\nCODE:\n```\nparam_handle_t * getParamByName(const char *param_name);\n```\n\n----------------------------------------\n\nTITLE: Getting Baud Rate - Arduino\nDESCRIPTION: Retrieves the current baud rate setting of the USB CDC interface. This is useful for verifying the communication speed or for synchronizing with the host device. The function returns the baud rate as an unsigned 32-bit integer.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\nuint32_t baudRate();\n```\n\n----------------------------------------\n\nTITLE: Reading Timer Counter Value in Microseconds - timerReadMicros (Arduino)\nDESCRIPTION: This function reads the current counter value of the timer in microseconds. It provides a convenient way to get time elapsed in microseconds. It accepts timer struct as parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nuint64_t timerReadMicros(hw_timer_t * timer);\n```\n\n----------------------------------------\n\nTITLE: Starting I2C Transmission - Arduino\nDESCRIPTION: Initiates a transmission to a specific I2C slave device, identified by its address. Must be called before writing data to the slave.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\nWire.beginTransmission(I2C_DEV_ADDR);\n```\n\n----------------------------------------\n\nTITLE: Getting Parameter by Name in Arduino\nDESCRIPTION: Retrieves a parameter handle by its name.  The name corresponds to the one used when adding the parameter with addXparam() or addParam(). It returns a pointer to the parameter handle.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_21\n\nLANGUAGE: arduino\nCODE:\n```\nparam_handle_t * getParamByName(const char *param_name);\n```\n\n----------------------------------------\n\nTITLE: Starting RainMaker Agent - C++\nDESCRIPTION: This snippet shows how to start the ESP RainMaker agent after it has been initialized. It returns ESP_OK on success and an error code on failure. The Wi-Fi.beginProvision() API must be called after starting the RainMaker agent.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nesp_err_t start()\n```\n\n----------------------------------------\n\nTITLE: Getting Timer Frequency - timerGetFrequency (Arduino)\nDESCRIPTION: This function returns the configured frequency (resolution in Hz) of the timer. It provides information about the timer's counting speed. It accepts timer struct as parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\nuint16_t timerGetFrequency(hw_timer_t * timer);\n```\n\n----------------------------------------\n\nTITLE: Handling 'File Not Found' Errors\nDESCRIPTION: This snippet demonstrates how to register a handler to manage scenarios where a requested file is not found on the server. It uses `server.onNotFound()` to define a callback function that sends a custom 404 error response with HTML content to the browser. The HTML content is read from `notFoundContent`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/WebServer/README.md#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n// handle cases when file is not found\nserver.onNotFound([]() {\n  // standard not found in browser.\n  server.send(404, \"text/html\", FPSTR(notFoundContent));\n});\n```\n\n----------------------------------------\n\nTITLE: Set LED GPIO pin Arduino\nDESCRIPTION: Defines the LED GPIO pin by changing the `LED_PIN` definition. The default pin is `RGB_BUILTIN`. The `rgbLedWrite` function is used by default to control the LED, but it can be changed to `digitalWrite` for a simple LED.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_OTA_Client/README.md#_snippet_0\n\nLANGUAGE: Arduino\nCODE:\n```\nSet the LED GPIO by changing the `LED_PIN` definition. By default, the LED_PIN is `RGB_BUILTIN`.\nBy default, the `rgbLedWrite` function is used to control the LED. You can change it to digitalWrite to control a simple LED.\n```\n\n----------------------------------------\n\nTITLE: Write Bytes to I2S Interface (Arduino)\nDESCRIPTION: This snippet shows how to write a buffer of bytes to the I2S interface using the `write()` method. It takes a buffer and the number of bytes to write as input and returns the number of bytes written. It writes a certain amount of data bytes to the I2S interface.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_19\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t write(uint8_t *buffer, size_t size)\n```\n\n----------------------------------------\n\nTITLE: Setting ADC Width Using analogSetWidth (Arduino)\nDESCRIPTION: This code shows how to set the hardware sample bits using the `analogSetWidth` function. The function takes the desired bit width as input.  This function is only available for the ESP32 chip, and the range is 9-12 bits.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nvoid analogSetWidth(uint8_t bits);\n```\n\n----------------------------------------\n\nTITLE: Opening Zigbee Network on Reboot in Arduino\nDESCRIPTION: This code snippet demonstrates how to open the Zigbee network after rebooting the device by using the `Zigbee.setRebootOpenNetwork(time);` function before `Zigbee.begin();`. The `time` parameter specifies how long the network remains open.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Temp_Hum_Sensor_Sleepy/README.md#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.setRebootOpenNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Zigbee Factory Reset in Arduino\nDESCRIPTION: This code snippet demonstrates how to perform a factory reset on the Zigbee device using the `Zigbee.factoryReset()` function within an Arduino sketch. This resets the device and its Zigbee stack, which can be useful for troubleshooting connection issues, particularly when re-flashing the coordinator. It's recommended to call this function if the end device is not connecting to the coordinator.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Temperature_Sensor/README.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nZigbee.factoryReset();\n```\n\n----------------------------------------\n\nTITLE: Reading Timer Counter Value in Milliseconds - timerReadMillis (Arduino)\nDESCRIPTION: This function reads the current counter value of the timer in milliseconds. It provides a convenient way to get time elapsed in milliseconds. It accepts timer struct as parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\nuint64_t timerReadMillis(hw_timer_t * timer);\n```\n\n----------------------------------------\n\nTITLE: Initializing I2C Slave with Full Configuration - Arduino\nDESCRIPTION: Initializes the I2C peripheral in slave mode, allowing specification of the slave address, SDA and SCL pins, and the bus frequency. Returns true if successful.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_23\n\nLANGUAGE: arduino\nCODE:\n```\nbool Wire.begin(uint8_t addr, int sdaPin, int sclPin, uint32_t frequency)\n```\n\n----------------------------------------\n\nTITLE: Set SoftAP MAC Address - Arduino\nDESCRIPTION: This function sets the MAC address for the ESP32 access point (AP).  It takes a uint8_t* as input, representing the new MAC address. It returns a `uint8_t*` representing the new MAC address.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_20\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t* softAPmacAddress(uint8_t* mac);\n```\n\n----------------------------------------\n\nTITLE: Opening Zigbee Network on Reboot in Arduino-ESP32\nDESCRIPTION: This code snippet demonstrates how to configure the Zigbee network to automatically open after a reboot using the Arduino-ESP32 library. This allows devices to rejoin the network without manual intervention. The `Zigbee.setRebootOpenNetwork(time);` function is called before `Zigbee.begin();` to enable this behavior, where `time` specifies the duration for which the network remains open.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Color_Dimmer_Switch/README.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nZigbee.setRebootOpenNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Setting Pins for Standard/TDM I2S - Arduino\nDESCRIPTION: This function sets the pins for the I2S interface when using the standard or TDM mode.  It defines the bit clock (bclk), word select (ws), data output (dout), data input (din), and master clock (mclk) pins. Unused pins can be set to -1.  This allows flexible assignment of I2S signals to available GPIO pins.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nvoid setPins(int8_t bclk, int8_t ws, int8_t dout, int8_t din=-1, int8_t mclk=-1)\n```\n\n----------------------------------------\n\nTITLE: Param Constructor in Arduino\nDESCRIPTION: Constructs a custom parameter using the `Param` class. It takes the parameter name, type, default value, and properties (read, write, time series, persist) as input. The default value needs to be defined using `value(int ival)`, `value(bool bval)`, `value(float fval)`, or `value(char *sval)`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_25\n\nLANGUAGE: arduino\nCODE:\n```\nParam my_param(const char *param_name, const char *param_type, param_val_t val, uint8_t properties);\n```\n\n----------------------------------------\n\nTITLE: Removing a Peer from ESP-NOW - remove()\nDESCRIPTION: Removes the peer from the ESP-NOW network. Returns `true` if the peer is removed successfully, `false` otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nbool remove();\n```\n\n----------------------------------------\n\nTITLE: Adding UI Type to a Parameter (addUIType)\nDESCRIPTION: This function adds a UI type to a parameter, which is used by clients (like phone apps) to render the appropriate UI element. It takes a string describing the UI type as a parameter. Standard UI Types include `ESP_RMAKER_UI_TOGGLE`, `ESP_RMAKER_UI_SLIDER`, `ESP_RMAKER_UI_DROPDOWN`, and `ESP_RMAKER_UI_TEXT`.  It returns an `esp_err_t` indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_26\n\nLANGUAGE: C\nCODE:\n```\nesp_err_t addUIType(const char *ui_type);\n```\n\n----------------------------------------\n\nTITLE: Configuring ADC Continuous Mode Using analogContinuous (Arduino)\nDESCRIPTION: This snippet demonstrates configuring the ADC continuous mode on selected pins using `analogContinuous`. It takes an array of pins, the number of pins, conversions per pin, sampling frequency, and a callback function as input. It returns true on successful configuration and false on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nbool analogContinuous(const uint8_t pins[], size_t pins_count, uint32_t conversions_per_pin, uint32_t sampling_freq_hz, void (*userFunc)(void));\n```\n\n----------------------------------------\n\nTITLE: Initializing SD_MMC in 1-bit line mode\nDESCRIPTION: This code snippet demonstrates how to initialize the SD_MMC library in 1-bit line mode. The `SD_MMC.begin()` function is used with the `mode1bit` parameter set to `true`. This reduces the number of required data lines but also lowers performance.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/SD_MMC/README.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n  SD_MMC.begin(\"/sdcard\", true);\n```\n\n----------------------------------------\n\nTITLE: FreeRTOS Task Creation Parameters\nDESCRIPTION: This code snippet illustrates the parameters required to create a FreeRTOS task using the xTaskCreate function. It details the purpose of each parameter, including the task function, name, stack depth, parameters passed to the task, priority, and task handle. Understanding these parameters is crucial for effectively managing tasks within a FreeRTOS environment.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/ESP32/examples/FreeRTOS/BasicMultiThreading/README.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nxTaskCreate(TaskFunction_t pxTaskCode,\n              const char * const pcName,\n              const uint16_t usStackDepth,\n              void * const pvParameters,\n              UBaseType_t uxPriority,\n              TaskHandle_t * const pxCreatedTask )\n```\n\n----------------------------------------\n\nTITLE: Attaching Touch Interrupt with touchAttachInterrupt in Arduino\nDESCRIPTION: This function attaches an interrupt to a touch pad. The specified function is called when the touch sensor value falls below the given threshold for ESP32 or rises above the given threshold for ESP32-S2/S3.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/touch.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nvoid touchAttachInterrupt(uint8_t pin, void (*userFunc)(void), touch_value_t threshold);\n```\n\n----------------------------------------\n\nTITLE: Getting Node ID\nDESCRIPTION: This code snippet retrieves the unique Node ID assigned to the node, which is typically the MAC address of the board. It returns a pointer to a null-terminated string.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\nchar * getNodeID()\n```\n\n----------------------------------------\n\nTITLE: Resetting Zigbee Device to Factory Defaults in Arduino-ESP32\nDESCRIPTION: This code snippet demonstrates how to reset the Zigbee device to its factory defaults using the Arduino-ESP32 library. This is useful for troubleshooting connection issues or when re-flashing the coordinator. It adds the `Zigbee.factoryReset();` call to the sketch to perform the reset.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Color_Dimmer_Switch/README.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nZigbee.factoryReset();\n```\n\n----------------------------------------\n\nTITLE: Configuring GPIO pins for SDMMC on ESP32-S3 (setPins)\nDESCRIPTION: The `setPins` function allows configuring custom GPIO pins for the SDMMC peripheral on the ESP32-S3. It supports setting pins for both 1-line and 4-line SD modes. It's crucial when default pins conflict with other hardware (e.g., on-board flash).\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/SD_MMC/README.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n  setPins(int clk, int cmd, int d0))\n  setPins(int clk, int cmd, int d0, int d1, int d2, int d3))\n```\n\n----------------------------------------\n\nTITLE: Setting ALPN Protocols for TLS Connection\nDESCRIPTION: This code snippet demonstrates how to set the Application-Layer Protocol Negotiation (ALPN) protocols for a TLS connection. This is necessary for protocols like MQTT when used with AWS IoT Custom Authorizers. The `setAlpnProtocols` method is used to specify the supported protocols.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/NetworkClientSecure/README.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nconst char *aws_protos[] = {\"mqtt\", NULL};\n...\nwiFiClient.setAlpnProtocols(aws_protos);\n```\n\n----------------------------------------\n\nTITLE: Getting Peer MAC Address - addr() const\nDESCRIPTION: Retrieves the MAC address of the peer.  Returns a pointer to the MAC address.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nconst uint8_t * addr() const;\n```\n\n----------------------------------------\n\nTITLE: Enabling Custom ETag Calculation\nDESCRIPTION: Enables custom ETag calculation by providing a lambda function that computes the ETag based on the file's last write timestamp. This allows for more efficient caching by using a custom logic for determining if a file has changed.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/WebServer/README.md#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nserver.enableETag(true, [](FS &fs, const String &path) -> String {\n  File f = fs.open(path, \"r\");\n  String eTag = String(f.getLastWrite(), 16);  // use file modification timestamp to create ETag\n  f.close();\n  return (eTag);\n});\n```\n\n----------------------------------------\n\nTITLE: Storing a Float Value in Arduino Preferences\nDESCRIPTION: This snippet demonstrates how to store a float value in a Preferences namespace using the `putFloat()` method. The first argument is the key name (\"pi\"), and the second argument is the value to store (3.14159265359). The namespace must be open in read-write mode for this operation to succeed.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nmyPreferences.putFloat(\"pi\", 3.14159265359);    // stores an float_t data type\n                                                   //  against the key \"pi\".\n```\n\n----------------------------------------\n\nTITLE: Retrieving Float Value from Preferences - Arduino\nDESCRIPTION: This code snippet retrieves a float value associated with the key \"pi\" from the \"myPreferences\" namespace and assigns it to the \"myFloat\" variable. It demonstrates a simple read operation using the Preferences library.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nfloat_t myFloat = myPreferences.getFloat(\"pi\");\n```\n\n----------------------------------------\n\nTITLE: Requesting Data from I2C Slave - Arduino\nDESCRIPTION: Requests a specified number of bytes from the I2C slave device. The data must be read using `readBytes` after this call.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\nWire.requestFrom(I2C_DEV_ADDR, SIZE);\n```\n\n----------------------------------------\n\nTITLE: Opening Zigbee Network Manually\nDESCRIPTION: This snippet allows the application to manually open the Zigbee network at any time, enabling new devices to join. The `time` parameter specifies the duration (in seconds) for which the network will remain open. This is useful for allowing devices to join after the initial network setup.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_On_Off_Light/README.md#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nZigbee.openNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Resetting the Zigbee device to factory defaults\nDESCRIPTION: To reset the device and Zigbee stack, add `Zigbee.factoryReset();` to the sketch. This is useful if the end device is not connecting to the coordinator, particularly after re-flashing the coordinator.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_PM25_Sensor/README.md#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.factoryReset();\n```\n\n----------------------------------------\n\nTITLE: cURL HTTP PUT File Upload\nDESCRIPTION: This cURL command demonstrates how to upload a local file to an HTTP server using the PUT method. The `-X PUT` option specifies the HTTP method, and `-T` specifies the file to upload. The URL points to the server endpoint where the file will be stored.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/UploadHugeFile/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X PUT -T ./my-file.mp3 http://esp-ip/upload/my-file.mp3\n```\n\n----------------------------------------\n\nTITLE: Beginning USB - Arduino\nDESCRIPTION: This code snippet shows how to start the USB peripheral with the default configuration using the `begin` function. It initializes the USB stack and starts the USB device. It returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_31\n\nLANGUAGE: arduino\nCODE:\n```\nbool begin();\n```\n\n----------------------------------------\n\nTITLE: Registering Read/Write Callbacks for a Device (addCb)\nDESCRIPTION: This function registers read and write callbacks for a device. These callbacks are invoked when requests are received from the cloud (or other paths). It takes two function pointers, `write_cb` and `read_cb`, as parameters. The write callback is invoked when a parameter needs to be written and the read callback when it needs to be read.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_24\n\nLANGUAGE: C\nCODE:\n```\nvoid addCb(deviceWriteCb write_cb, deviceReadCb read_cb);\n```\n\n----------------------------------------\n\nTITLE: Adding Bounds to an Integer/Float Parameter (addBounds)\nDESCRIPTION: This function adds bounds (min/max values) to an integer/float parameter. It takes the minimum value, maximum value, and step as parameters. The parameters' types should be `param_val_t`. It returns an `esp_err_t` indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_27\n\nLANGUAGE: C\nCODE:\n```\nesp_err_t addBounds(param_val_t min, param_val_t max, param_val_t step);\n```\n\n----------------------------------------\n\nTITLE: Open Zigbee Network in Arduino\nDESCRIPTION: This code snippet demonstrates how to open the Zigbee network for a specified duration using the `Zigbee.openNetwork(time)` function within an Arduino sketch. The `time` parameter defines the duration (in seconds) for which the network will be open, allowing other devices to join. This function can be called at any time during the application's execution to temporarily allow devices to join the network.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Temperature_Sensor/README.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nZigbee.openNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: ESP32 Toolchain and Debug API Configuration\nDESCRIPTION: This snippet configures the toolchain and debug API settings, specifying the path to the GCC compiler, the OpenOCD server, and the SVD file for debugging.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_27\n\nLANGUAGE: text\nCODE:\n```\ndebug.executable={build.path}/{build.project_name}.elf\ndebug.toolchain=gcc\ndebug.toolchain.path={tools.{build.tarch}-esp-elf-gdb.path}/bin/\ndebug.toolchain.prefix={build.tarch}-{build.target}-elf\ndebug.server=openocd\ndebug.server.openocd.path={runtime.platform.path}/tools/openocd-esp32/bin/openocd\ndebug.server.openocd.scripts_dir={runtime.platform.path}/tools/openocd-esp32/share/openocd/scripts/\ndebug.server.openocd.scripts_dir.windows={runtime.platform.path}\\tools\\openocd-esp32\\share\\openocd\\scripts\\\ndebug.server.openocd.scripts.0=board/{debug_script.{build.mcu}}\ndebug.svd_file={runtime.platform.path}/tools/ide-debug/svd/{build.mcu}.svd\n\ndebug.cortex-debug.custom.objdumpPath={compiler.path}{compiler.prefix}objdump\ndebug.cortex-debug.custom.request=attach\ndebug.additional_config=debug_config.{build.mcu}\n```\n\n----------------------------------------\n\nTITLE: Initializing Timer with Frequency - timerBegin (Arduino)\nDESCRIPTION: This function configures the timer with the specified frequency in Hz. It sets the timer's counting speed. The function returns a pointer to the timer structure if successful, otherwise returns NULL.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nhw_timer_t * timerBegin(uint32_t frequency);\n```\n\n----------------------------------------\n\nTITLE: Preferences getString with Default Value in Arduino\nDESCRIPTION: This code demonstrates how to retrieve a string from Preferences using the `getString()` method, providing a default value to return in case the key is not found or an error occurs. This allows error detection when retrieving preference values.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_18\n\nLANGUAGE: arduino\nCODE:\n```\n  dessert = mySketchPrefs.getString(\"favorites\", \"gravel\");\n```\n\n----------------------------------------\n\nTITLE: Adding Bounds to Parameter in Arduino\nDESCRIPTION: Adds bounds (min, max, step) to an integer/float parameter. This allows defining the valid range for the parameter. It takes minimum value, maximum value and step as input. Returns ESP_OK on success, or an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_27\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t addBounds(param_val_t min, param_val_t max, param_val_t step);\n```\n\n----------------------------------------\n\nTITLE: Zigbee Open Network Arduino\nDESCRIPTION: Opens the Zigbee network for devices to join at any time by calling `Zigbee.openNetwork(time);`. This allows devices to join the network during application runtime.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_OTA_Client/README.md#_snippet_3\n\nLANGUAGE: Arduino\nCODE:\n```\nZigbee.openNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Flushing USB CDC Data - Arduino\nDESCRIPTION: Flushes any remaining data in the USB CDC transmit buffer. This ensures that all data written to the buffer is sent to the host device before proceeding. This function does not take any parameters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\nvoid flush(void);\n```\n\n----------------------------------------\n\nTITLE: Opening the Zigbee Network - Arduino\nDESCRIPTION: To open the Zigbee network for devices to join, call `Zigbee.openNetwork(time);` in the application. This allows devices to connect to the network at any time.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_PM25_Sensor/README.md#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.openNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Setting Peer Wi-Fi Interface - setInterface()\nDESCRIPTION: Sets the Wi-Fi interface of the peer. Takes the Wi-Fi interface as a parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nvoid setInterface(wifi_interface_t iface);\n```\n\n----------------------------------------\n\nTITLE: Adding Device Callbacks in Arduino\nDESCRIPTION: Registers read and write callbacks for the device. These callbacks are invoked based on requests received from the cloud. It requires a write callback function (`deviceWriteCb`) and a read callback function (`deviceReadCb`).  The callback signatures are provided in the description.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_24\n\nLANGUAGE: arduino\nCODE:\n```\nvoid addCb(deviceWriteCb write_cb, deviceReadCb read_cb);\n```\n\n----------------------------------------\n\nTITLE: OpenThreadCLI Class Definition in C++\nDESCRIPTION: Defines the `OpenThreadCLI` class, inheriting from the Arduino `Stream` class. It includes methods for managing the OpenThread CLI, configuring buffer sizes, and handling data streams. This class provides an interface to the OpenThread command-line interface.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/OpenThread/README.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nclass OpenThreadCLI : public Stream {\nprivate:\n  static size_t setBuffer(QueueHandle_t &queue, size_t len);\n  bool otStarted = false;\n\npublic:\n  OpenThreadCLI();\n  ~OpenThreadCLI();\n  operator bool() const;\n\n  // Starts a task to read/write otStream. Default prompt is \"ot> \". Set it to NULL to make it invisible.\n  void startConsole(Stream& otStream, bool echoback = true, const char* prompt = \"ot> \");\n  void stopConsole();\n  void setPrompt(char* prompt);      // Changes the console prompt. NULL is an empty prompt.\n  void setEchoBack(bool echoback);   // Changes the console echoback option\n  void setStream(Stream& otStream);  // Changes the console Stream object\n  void onReceive(OnReceiveCb_t func);  // Called on a complete line of output from OT CLI, as OT Response\n\n  void begin(bool OThreadAutoStart = true);\n  void end();\n\n  // Default size is 256 bytes\n  size_t setTxBufferSize(size_t tx_queue_len);\n  // Default size is 1024 bytes\n  size_t setRxBufferSize(size_t rx_queue_len);\n\n  size_t write(uint8_t);\n  int available();\n  int read();\n  int peek();\n  void flush();\n};\n\nextern OpenThreadCLI OThreadCLI;\n```\n\n----------------------------------------\n\nTITLE: Reading a Value from Arduino Preferences\nDESCRIPTION: This snippet shows the general form of retrieving a value from Preferences using the `getX` method, where X represents the data type. Requires namespace and key to exist.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nmyPreferences.getX(\"myKeyName\")\n```\n\n----------------------------------------\n\nTITLE: Opening Zigbee Network for Devices to Join\nDESCRIPTION: This snippet shows how to use `Zigbee.openNetwork(time);` in the application to open the network for devices to join. This allows new devices to connect to the Zigbee network.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Color_Dimmable_Light/README.md#_snippet_3\n\nLANGUAGE: Arduino\nCODE:\n```\n`Zigbee.openNetwork(time);`\n```\n\n----------------------------------------\n\nTITLE: Checking if Peer Uses Encryption - isEncrypted()\nDESCRIPTION: Checks if the peer is using encryption. Returns `true` if the peer is using encryption, `false` otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\nbool isEncrypted() const;\n```\n\n----------------------------------------\n\nTITLE: Opening Zigbee network manually\nDESCRIPTION: This snippet demonstrates how to manually open the Zigbee network within the application for a set amount of time, enabling devices to join the network when needed. The `time` parameter specifies the duration the network will be open.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Gateway/README.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nZigbee.openNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Unregistering All Metrics in Arduino\nDESCRIPTION: Unregisters all previously registered metrics. The function returns a boolean indicating success or failure. This API is available via the `Insights.metrics` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nbool removeAll();\n```\n\n----------------------------------------\n\nTITLE: Setting Time Zone - C++\nDESCRIPTION: This snippet shows how to set the timezone for the node. It takes a timezone string (e.g., \"Asia/Shanghai\") as input and returns ESP_OK on success and an error code on failure. This API is used when working with scheduling.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nesp_err_t setTimeZone(const char *tz);\n```\n\n----------------------------------------\n\nTITLE: Setting Request Callback - Arduino\nDESCRIPTION: Sets the callback function that will be executed when the master requests data from the slave. Used in I2C slave mode.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_20\n\nLANGUAGE: arduino\nCODE:\n```\nWire.onRequest(onRequest);\n```\n\n----------------------------------------\n\nTITLE: Getting LEDC Clock Source - Arduino\nDESCRIPTION: Gets the currently configured clock source for the LEDC peripheral. It takes no arguments and returns a ledc_clk_cfg_t enum representing the clock source.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nledc_clk_cfg_t ledcGetClockSource(void);\n```\n\n----------------------------------------\n\nTITLE: Open Zigbee Network Manually\nDESCRIPTION: The `Zigbee.openNetwork(time);` function is used to manually open the Zigbee network for a specified duration (`time`). This allows devices to join the network at any time after the application is running. The time parameter specifies how long the network will be open for joining.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Dimmable_Light/README.md#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.openNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Short/UShort Values from Preferences - Arduino\nDESCRIPTION: This code snippet shows how to retrieve a short or unsigned short value associated with a given key from the currently open namespace using `getShort` and `getUShort` functions. It accepts a key and an optional default value. It returns the stored value or the default value if the key is not found or if there are any failures. It is similar to `getChar` in its operation.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_22\n\nLANGUAGE: arduino\nCODE:\n```\nint16_t getShort(const char* key, int16_t defaultValue = 0)\nuint16_t getUShort(const char* key, uint16_t defaultValue = 0)\n```\n\n----------------------------------------\n\nTITLE: Example of Using freeEntries() Method - Arduino\nDESCRIPTION: This is a complete example demonstrating how to use the `freeEntries()` method to get the number of available entries in the key table of a Preferences namespace and print it to the serial monitor. It initializes the Preferences library and uses Serial.printf.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\nPreferences mySketchPrefs;\n\nmySketchPrefs.begin(\"myPrefs\", true);\nsize_t whatsLeft = freeEntries();    // this method works regardless of the mode in which the namespace is opened.\nSerial.printf(\"There are: %u entries available in the namespace table.\\n, whatsLeft);\nmySketchPrefs.end();\n```\n\n----------------------------------------\n\nTITLE: Enabling DFU - Arduino\nDESCRIPTION: This code snippet demonstrates how to enable the Device Firmware Upgrade (DFU) capability using the `enableDFU` function. DFU allows updating the device's firmware over USB.  It returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_30\n\nLANGUAGE: arduino\nCODE:\n```\nbool enableDFU();\n```\n\n----------------------------------------\n\nTITLE: Attaching Interrupt with Arguments - timerAttachInterruptArg (Arduino)\nDESCRIPTION: This function attaches an interrupt to the timer, passing an argument to the user function. When the timer triggers, the specified user function is called with the provided argument. The function takes the timer structure, a pointer to the user function, and a pointer to the argument as parameters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\nvoid timerAttachInterruptArg(hw_timer_t * timer, void (*userFunc)(void*), void * arg);\n```\n\n----------------------------------------\n\nTITLE: Detaching LEDC Pin - Arduino\nDESCRIPTION: Detaches a pin from the LEDC. It accepts the pin number as input and returns a boolean indicating success.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\nbool ledcDetach(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: IPAddress Constructor - Arduino\nDESCRIPTION: This code snippet shows how to define an IP address using the `IPAddress` constructor. It takes four uint8_t values, representing the four octets of the IP address.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_29\n\nLANGUAGE: arduino\nCODE:\n```\nIPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);\n```\n\n----------------------------------------\n\nTITLE: Getting USB Class - Arduino\nDESCRIPTION: This code snippet demonstrates how to retrieve the currently configured USB class using the `usbClass` function. This determines the functional category to which the USB device belongs.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t usbClass(void);\n```\n\n----------------------------------------\n\nTITLE: Enabling Touch Sleep Wake Up with touchSleepWakeUpEnable in Arduino\nDESCRIPTION: This function sets up a touch pad as a wake-up source from deep sleep. ESP32-S2 and ESP32-S3 only support one sleep wake up touch pad.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/touch.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nvoid touchSleepWakeUpEnable(uint8_t pin, touch_value_t threshold);\n```\n\n----------------------------------------\n\nTITLE: Initializing ESP RainMaker Node\nDESCRIPTION: This code snippet initializes an ESP RainMaker node with a given name and type. It returns a Node object that can be used for further configuration and management.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nNode initNode(const char *name, const char *type);\n```\n\n----------------------------------------\n\nTITLE: Resetting Zigbee Configuration\nDESCRIPTION: This snippet demonstrates how to perform a factory reset on the Zigbee device. This can be useful when troubleshooting connectivity issues or when re-flashing the coordinator. Adding this line to the sketch will reset the Zigbee stack and clear all stored network settings.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_On_Off_Light/README.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nZigbee.factoryReset();\n```\n\n----------------------------------------\n\nTITLE: Defining onRequest Callback Function - Arduino\nDESCRIPTION: Defines the structure for the callback function that handles requests from the I2C master. This function is invoked when the master requests data from the slave.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_25\n\nLANGUAGE: arduino\nCODE:\n```\nvoid onRequest( void (*)(void) );\n```\n\n----------------------------------------\n\nTITLE: Detaching Interrupt from Timer - timerDetachInterrupt (Arduino)\nDESCRIPTION: This function detaches an interrupt from the timer. It prevents the user function from being called when the timer triggers. It accepts timer struct as parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\nvoid timerDetachInterrupt(hw_timer_t * timer);\n```\n\n----------------------------------------\n\nTITLE: Getting USB Sub-Class - Arduino\nDESCRIPTION: This code snippet demonstrates how to retrieve the currently configured USB sub-class using the `usbSubClass` function. It refines the classification of the USB device beyond the general class.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_15\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t usbSubClass(void);\n```\n\n----------------------------------------\n\nTITLE: Ending I2C Communication - Arduino\nDESCRIPTION: Terminates the I2C communication and releases allocated resources. The I2C driver needs to be re-initialized using `begin()` after calling `end()`. Returns true if successful.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nbool end();\n```\n\n----------------------------------------\n\nTITLE: SPIFFS Begin with Format: Handling Mount Fail (C++)\nDESCRIPTION: This code snippet demonstrates how to enforce formatting on fail when mounting SPIFFS. Passing `true` to `SPIFFS.begin()` will format the filesystem if mounting fails.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/troubleshooting.rst#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nSPIFFS.begin(true);\n```\n\n----------------------------------------\n\nTITLE: Starting LEDC Fade with Interrupt and Arguments - Arduino\nDESCRIPTION: Sets up and starts a fade effect for a LEDC pin with an interrupt, passing arguments to the interrupt handler. It accepts the pin number, starting duty, target duty, maximum fade time in milliseconds, a function pointer for the interrupt handler and a pointer to the arguments as input and returns a boolean indicating success.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_15\n\nLANGUAGE: arduino\nCODE:\n```\nbool ledcFadeWithInterruptArg(uint8_t pin, uint32_t start_duty, uint32_t target_duty, int max_fade_time_ms, void (*userFunc)(void*), void * arg);\n```\n\n----------------------------------------\n\nTITLE: Configuring HW USB CDC Serial in CMake\nDESCRIPTION: This snippet demonstrates how to configure the Arduino-ESP32 project to use the HW USB CDC Serial port instead of the default UART0.  It achieves this by defining two symbols, `ARDUINO_USB_CDC_ON_BOOT` and `ARDUINO_USB_MODE`, to `1` using CMake's `list(APPEND compile_definitions ...)` command. This adds compiler definitions that activate the USB CDC functionality during the boot process and sets the USB mode.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/hw_cdc_hello_world/README.md#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Adds necessary definitions for compiling it using Serial symbol attached to the HW USB CDC port\nlist(APPEND compile_definitions \"ARDUINO_USB_CDC_ON_BOOT=1\")\nlist(APPEND compile_definitions \"ARDUINO_USB_MODE=1\")\n```\n\n----------------------------------------\n\nTITLE: Factory Reset Zigbee Device\nDESCRIPTION: The `Zigbee.factoryReset();` function call is used to reset the Zigbee device to its factory default settings. This is useful for resolving connection issues and ensuring a clean state before pairing with a coordinator, especially after reflashing the coordinator.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Dimmable_Light/README.md#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.factoryReset();\n```\n\n----------------------------------------\n\nTITLE: Setting Serial Number - Arduino\nDESCRIPTION: This code snippet demonstrates how to set the serial number for the USB device using the `serialNumber` function. The serial number is a string that uniquely identifies the device. It takes a constant character pointer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_26\n\nLANGUAGE: arduino\nCODE:\n```\nbool serialNumber(const char * name);\n```\n\n----------------------------------------\n\nTITLE: Enabling Scenes Service\nDESCRIPTION: This code snippet enables the Scenes service for the node. It allows grouping multiple device states into a single scene, which can then be activated with a single command. This must be called after `RMaker.initNode()` and before `RMaker.start()`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t enableScenes()\n```\n\n----------------------------------------\n\nTITLE: Zigbee Factory Reset\nDESCRIPTION: This snippet shows how to add `Zigbee.factoryReset();` to the sketch to reset the device and Zigbee stack. This is useful for troubleshooting connection issues, especially after reflashing the coordinator.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Color_Dimmable_Light/README.md#_snippet_1\n\nLANGUAGE: Arduino\nCODE:\n```\n`Zigbee.factoryReset();`\n```\n\n----------------------------------------\n\nTITLE: Getting Product Name - Arduino\nDESCRIPTION: This code snippet demonstrates how to get the product name of the USB device using the `productName` function. It retrieves the currently configured product name as a constant character pointer.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_23\n\nLANGUAGE: arduino\nCODE:\n```\nconst char * productName(void);\n```\n\n----------------------------------------\n\nTITLE: Setting Write Callback\nDESCRIPTION: This function sets the callback function to be executed when a write request is received from the host. This callback is responsible for handling data written by the host.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_msc.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\nvoid onWrite(msc_write_cb cb);\n```\n\n----------------------------------------\n\nTITLE: Changing CS pin with SD.begin() - Arduino\nDESCRIPTION: This code demonstrates how to change only the Chip Select (CS) pin when initializing the SD card. It's useful when you want to use non-default CS pin for the SD card communication.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/SD/README.md#_snippet_1\n\nLANGUAGE: Arduino\nCODE:\n```\nSD.begin(CSpin)\n```\n\n----------------------------------------\n\nTITLE: Deleting Device - C++\nDESCRIPTION: This snippet demonstrates how to delete a device created using the parameterized constructor. The device should first be removed from the node using `my_node.removeDevice(my_device)`. Returns ESP_OK on success, error otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nesp_err_t deleteDevice();\n```\n\n----------------------------------------\n\nTITLE: Define ESP Insights Auth Key\nDESCRIPTION: This code snippet defines a constant character array to store the ESP Insights authentication key.  The user needs to replace the placeholder with their actual auth key obtained during ESP Insights account setup. This key is essential for the device to authenticate with the ESP Insights service.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Insights/examples/DiagnosticsSmokeTest/README.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char insights_auth_key[] = \"<ENTER YOUR AUTH KEY>\";\n```\n\n----------------------------------------\n\nTITLE: 2MB No OTA Partition Table Example\nDESCRIPTION: This code snippet shows an example of a partition table configuration for a 2MB flash without OTA support. It defines partitions for NVS and a factory application.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/partition_table.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n# Name,   Type, SubType, Offset,  Size, Flags\nnvs,      data, nvs,     36K,     20K,\nfactory,  app,  factory, 64K,     1900K,\n```\n\n----------------------------------------\n\nTITLE: Record WAV to Memory (Arduino)\nDESCRIPTION: This snippet demonstrates how to record a short PCM WAV to memory using the `recordWAV()` method. It takes the recording duration in seconds as input and outputs the size of the returned buffer. The returned buffer containing the recorded WAV data must be freed by the user.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_24\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t * recordWAV(size_t rec_seconds, size_t * out_size)\n```\n\n----------------------------------------\n\nTITLE: Ethernet TLK110 Initialization Arduino\nDESCRIPTION: This Arduino sketch configures and initializes the TLK110 Ethernet module with ESP32. It leverages the Ethernet library to establish a network connection using configurations specific to the TLK110 PHY. The sketch includes event handling for Ethernet connection states and prints relevant information like MAC address and IP address via the serial monitor. It also sets the hostname for the Ethernet interface.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ethernet.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\n#include <ETH.h>\n\nstatic bool eth_connected = false;\n\nvoid WiFiEvent(WiFiEvent_t event)\n{\n  switch (event) {\n    case SYSTEM_EVENT_ETH_START:\n      Serial.println(\"ETH Started\");\n      //set eth hostname here\n      ETH.setHostname(\"esp32-ethernet\");\n      break;\n    case SYSTEM_EVENT_ETH_CONNECTED:\n      Serial.println(\"ETH Connected\");\n      break;\n    case SYSTEM_EVENT_ETH_GOT_IP:\n      Serial.print(\"ETH MAC: \");\n      Serial.print(ETH.macAddress());\n      Serial.print(\", IPv4: \");\n      Serial.print(ETH.localIP());\n      if (ETH.fullDuplex()) {\n        Serial.println(\", FULL_DUPLEX\");\n      } else {\n        Serial.println(\", HALF_DUPLEX\");\n      }\n      eth_connected = true;\n      break;\n    case SYSTEM_EVENT_ETH_DISCONNECTED:\n      Serial.println(\"ETH Disconnected\");\n      eth_connected = false;\n      break;\n    case SYSTEM_EVENT_ETH_STOP:\n      Serial.println(\"ETH Stopped\");\n      eth_connected = false;\n      break;\n    default:\n      break;\n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"Starting Ethernet...\");\n  WiFi.onEvent(WiFiEvent);\n  ETH.begin(ETH_ADDR, ETH_POWER_PIN, ETH_MDC_PIN, ETH_MDIO_PIN, ETH_TYPE, ETH_CLK_MODE);\n}\n\nvoid loop() {\n  if (eth_connected) {\n    // Do your thing here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Sent Data Completion - onSent()\nDESCRIPTION: Callback function to handle the completion of sending data to the peer. This is a virtual method and can be implemented by the upper class for custom handling. Provides a boolean indicating if the data was sent successfully.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\nvoid onSent(bool success);\n```\n\n----------------------------------------\n\nTITLE: Open Zigbee Network on Reboot\nDESCRIPTION: The `Zigbee.setRebootOpenNetwork(time);` function sets the device to open the Zigbee network for a specified duration (`time`) after a reboot. This allows other devices to join the network automatically after the device restarts.  It is called before `Zigbee.begin();`\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Dimmable_Light/README.md#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.setRebootOpenNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Long64/ULong64 Values from Preferences - Arduino\nDESCRIPTION: This code snippet showcases how to retrieve a long long or unsigned long long value associated with a given key from the currently open namespace using `getLong64` and `getULong64` functions. It accepts a key and an optional default value. It returns the stored value or the default value if the key is not found or if there are any failures, similar to `getChar`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_25\n\nLANGUAGE: arduino\nCODE:\n```\nint64_t getLong64(const char* key, int64_t defaultValue = 0)\nuint64_t getULong64(const char* key, uint64_t defaultValue = 0)\n```\n\n----------------------------------------\n\nTITLE: Starting ESP RainMaker Agent\nDESCRIPTION: This code snippet starts the ESP RainMaker agent. It assumes that the agent has been initialized beforehand. After starting the agent, it's necessary to call `WiFi.beginProvision()`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t start();\n```\n\n----------------------------------------\n\nTITLE: Getting AP IPv4 Broadcast Address\nDESCRIPTION: Returns the IPv4 broadcast address of the Wi-Fi Access Point (AP). The address is returned in IPAddress format.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\nIPAddress softAPBroadcastIP();\n```\n\n----------------------------------------\n\nTITLE: Setting LEDC Clock Source - Arduino\nDESCRIPTION: Sets the clock source for the LEDC peripheral. This must be called before any LEDC channel is used. It accepts a ledc_clk_cfg_t enum as input and returns a boolean indicating success. Available clock sources are LEDC_APB_CLK and LEDC_REF_CLK.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nbool ledcSetClockSource(ledc_clk_cfg_t source);\n```\n\n----------------------------------------\n\nTITLE: Setting Compile Options - CMake\nDESCRIPTION: Sets compiler options for C++ and C using CMake's `idf_build_set_property` command. These options include standard versions, optimization levels, and specific defines. Dependencies: idf_build_set_property is defined in ESP-IDF build system.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nidf_build_set_property(CXX_COMPILE_OPTIONS \"-std=gnu++17;-Os;-DCHIP_HAVE_CONFIG_H\" APPEND)\nidf_build_set_property(C_COMPILE_OPTIONS \"-Os\" APPEND)\n# For RISCV chips, project_include.cmake sets -Wno-format, but does not clear various\n# flags that depend on -Wformat\nidf_build_set_property(COMPILE_OPTIONS \"-Wno-format-nonliteral;-Wno-format-security\" APPEND)\n```\n\n----------------------------------------\n\nTITLE: Configuring Wi-Fi AP Characteristics\nDESCRIPTION: Configures the Wi-Fi Access Point (AP) settings such as SSID, passphrase, channel, hidden status, maximum connections and FTM responder feature (ESP32-S2 and ESP32-C3 only).\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nbool softAP(const char* ssid, const char* passphrase = NULL, int channel = 1, int ssid_hidden = 0, int max_connection = 4, bool ftm_responder = false);\n```\n\n----------------------------------------\n\nTITLE: Setting USB Sub-Class - Arduino\nDESCRIPTION: This code snippet demonstrates how to set the USB sub-class using the `usbSubClass` function.  The sub-class provides further specificity within a given USB class. It takes an 8-bit unsigned integer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_14\n\nLANGUAGE: arduino\nCODE:\n```\nbool usbSubClass(uint8_t subClass);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Char/UChar Values from Preferences - Arduino\nDESCRIPTION: This code snippet demonstrates how to retrieve a char or unsigned char value associated with a given key from the currently open namespace using `getChar` and `getUChar` functions. It takes a key and an optional default value. It returns the stored value or the default value if the key is not found or if there are any failures. Retrieving a value requires a namespace to be open and the key to exist, otherwise, a log message will be added to the `log_e` facility.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_21\n\nLANGUAGE: arduino\nCODE:\n```\nint8_t getChar(const char* key, int8_t defaultValue = 0)\nuint8_t getUChar(const char* key, uint8_t defaultValue = 0)\n```\n\n----------------------------------------\n\nTITLE: Initializing LED Pin as Output - C++\nDESCRIPTION: This code snippet initializes the LED pin as an output within the ``setup()`` function. The ``pinMode()`` function is used to configure the pin's behavior. It takes two arguments: the pin number (``LED``, defined earlier) and the mode (``OUTPUT``). This configuration ensures that the ESP32 can control the voltage level of the LED pin, enabling it to turn the LED on and off.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/blink.rst#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid setup() {\n    pinMode(LED, OUTPUT);\n}\n```\n\n----------------------------------------\n\nTITLE: Deinitializing ADC Continuous Mode Using analogContinuousDeinit (Arduino)\nDESCRIPTION: This snippet demonstrates deinitializing the ADC continuous peripheral using `analogContinuousDeinit`. It returns true if successfully deinitialized and false otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\nbool analogContinuousDeinit();\n```\n\n----------------------------------------\n\nTITLE: Ending ESP-NOW Communication - end()\nDESCRIPTION: Ends ESP-NOW communication. This function releases all resources used by the ESP-NOW library. Returns `true` if the operation is successful, `false` otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nbool end();\n```\n\n----------------------------------------\n\nTITLE: WiFiMulti Add AP - Arduino\nDESCRIPTION: This function adds an AP to the list of APs managed by WiFiMulti. It takes the SSID and passphrase of the AP as input, allowing the device to connect to multiple networks. A successful operation will return `true`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_36\n\nLANGUAGE: arduino\nCODE:\n```\nbool addAP(const char* ssid, const char *passphrase = NULL);\n```\n\n----------------------------------------\n\nTITLE: Setting WiFi Metrics Period in Arduino\nDESCRIPTION: Resets the periodic interval for collecting Wi-Fi metrics. Setting the interval to 0 disables Wi-Fi metrics collection. This API is available via the `Insights.metrics` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\nvoid setHeapPeriod(uint32_t period);\n```\n\n----------------------------------------\n\nTITLE: Open Zigbee Network on Reboot in Arduino\nDESCRIPTION: This code snippet shows how to configure the Zigbee network to automatically open for a specified time period after a reboot using `Zigbee.setRebootOpenNetwork(time);`. This allows devices to rejoin the network without manual intervention. The time parameter specifies how long the network will remain open, measured in seconds.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Window_Covering/README.md#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.setRebootOpenNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Getting USB Version - Arduino\nDESCRIPTION: This code snippet shows how to get the USB version using the `usbVersion` function. It retrieves the currently configured USB specification version.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\nuint16_t usbVersion(void);\n```\n\n----------------------------------------\n\nTITLE: Setting Peer MAC Address - addr()\nDESCRIPTION: Sets the MAC address of the peer. Takes the MAC address as a parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nvoid addr(const uint8_t *mac_addr);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Boolean Value from Preferences - Arduino\nDESCRIPTION: This code snippet illustrates how to retrieve a boolean value associated with a given key from the currently open namespace using the `getBool` function. It takes a key and an optional default value. It returns the stored value or the default value if the key is not found or if there are any failures, similar to `getChar`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_28\n\nLANGUAGE: arduino\nCODE:\n```\nbool getBool(const char* key, bool defaultValue = false);\n```\n\n----------------------------------------\n\nTITLE: Setting Product ID\nDESCRIPTION: This function sets the product ID (PID) for the USB device. The PID is a string that identifies the specific product model. The maximum length of the PID string is 16 characters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_msc.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nvoid productID(const char * pid);//max 16 chars\n```\n\n----------------------------------------\n\nTITLE: Reading LEDC Frequency - Arduino\nDESCRIPTION: Gets the configured frequency for a given LEDC pin. It takes the pin number as input and returns the frequency value.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nuint32_t ledcReadFreq(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: Disconnecting Wi-Fi AP\nDESCRIPTION: Forces the Wi-Fi Access Point (AP) to disconnect. Optionally, it can also turn off the Wi-Fi module.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\nbool softAPdisconnect(bool wifioff = false);\n```\n\n----------------------------------------\n\nTITLE: Getting Data Type from Preferences - Arduino\nDESCRIPTION: This code snippet retrieves the Preferences data type of the value associated with a given key in the currently open namespace using the `getType` function. It takes the key as input and returns an integer representing the data type according to a predefined table. It returns `10` (PT_INVALID) if the call fails. It can fail if the namespace isn't open, the key doesn't exist, or if the key exceeds 15 characters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_33\n\nLANGUAGE: arduino\nCODE:\n```\nPreferenceType getType(const char* key)\n```\n\n----------------------------------------\n\nTITLE: Setting Variable Value in Arduino\nDESCRIPTION: Adds a variable of a specified type (Bool, Int, Uint, Float, String, IPv4, or MAC) to storage with the given key and value. The function returns true on success. This API is available via the `Insights.variables` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_15\n\nLANGUAGE: arduino\nCODE:\n```\nbool setX(const char *key, const void val);\n```\n\n----------------------------------------\n\nTITLE: Setting Time Zone\nDESCRIPTION: This code snippet sets the timezone for the device. It is relevant when scheduling is enabled.  A user-friendly location string is used to specify the timezone.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t setTimeZone(const char *tz);\n```\n\n----------------------------------------\n\nTITLE: Sending Insights Data Asynchronously in Arduino\nDESCRIPTION: Reads insights data from buffers and sends it to the cloud asynchronously. This function facilitates the transmission of diagnostic information to a remote server for analysis and monitoring. It returns a boolean to indicate success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nbool sendData()\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation for ESP32 Arduino Core Versions in C++\nDESCRIPTION: This code snippet demonstrates how to use conditional compilation directives to include code based on the ESP32 Arduino core version. It checks the `ESP_ARDUINO_VERSION_MAJOR` macro and the `ESP_ARDUINO_VERSION` macro against `ESP_ARDUINO_VERSION_VAL(3, 0, 0)` to determine which version of the core is being used. This allows developers to write code that is compatible with both 2.x, 3.x and potentially older versions of the ESP32 Arduino core.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/core_compatibility.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#ifdef ESP_ARDUINO_VERSION_MAJOR\n#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)\n    // Code for version 3.x\n#else\n    // Code for version 2.x\n#endif\n#else\n    // Code for version 1.x\n#endif\n```\n\n----------------------------------------\n\nTITLE: Starting WiFi Provisioning with beginProvision\nDESCRIPTION: This code snippet shows the signature of the `WiFi.beginProvision` function in the Arduino ESP32 library, which is used to initiate the WiFi provisioning process. It takes a function pointer for the provisioning scheme callback, an event handler, security type, proof-of-possession (pop), service name, service key, and a UUID as parameters. The provisioning scheme callback chooses either BLE or SoftAP mode.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFiProv/examples/WiFiProv/README.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nWiFi.beginProvision(void (*scheme_cb)(), wifi_prov_scheme_event_handler_t scheme_event_handler, wifi_prov_security_t security, char *pop, char *service_name, char *service_key, uint8_t *uuid);\n```\n\n----------------------------------------\n\nTITLE: Setting Media Present Status\nDESCRIPTION: This function sets the media present status. This determines whether the host computer should see the device as having media present or not.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_msc.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nvoid mediaPresent(bool media_present);\n```\n\n----------------------------------------\n\nTITLE: Getting Free Key Table Entries in Arduino\nDESCRIPTION: This code snippet shows how to retrieve the number of available key table entries within the currently open namespace using the `freeEntries()` method in Arduino. The function returns the number of free entries or 0 if it fails.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_34\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t freeEntries()\n```\n\n----------------------------------------\n\nTITLE: Building a Custom Docker Image\nDESCRIPTION: This command builds a custom Docker image for the ESP32 Arduino Lib Builder, using build arguments to customize the Lib Builder repository URL, branch, and clone method.  Requires Docker Buildx.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ndocker buildx build -t lib-builder-custom:master \\\n    --build-arg LIBBUILDER_CLONE_BRANCH_OR_TAG=master \\\n    --build-arg LIBBUILDER_CLONE_SHALLOW=1 \\\n    --build-arg LIBBUILDER_CLONE_URL=https://github.com/espressif/esp32-arduino-lib-builder \\\n    tools/docker\n```\n\n----------------------------------------\n\nTITLE: Getting Vendor ID - Arduino\nDESCRIPTION: This code snippet shows how to get the Vendor ID (VID) for the USB device using the `VID` function. It retrieves the current VID, which is a 16-bit identifier representing the device's vendor.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nuint16_t VID(void);\n```\n\n----------------------------------------\n\nTITLE: Setting WebUSB URL - Arduino\nDESCRIPTION: This code snippet demonstrates how to set the WebUSB URL using the `webUSBURL` function. This URL points to a web page that can interact with the USB device when WebUSB is enabled. It takes a constant character pointer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_28\n\nLANGUAGE: arduino\nCODE:\n```\nbool webUSBURL(const char * name);\n```\n\n----------------------------------------\n\nTITLE: Enabling Scheduling Service - C++\nDESCRIPTION: This snippet shows how to enable the scheduling service for the node. It returns ESP_OK on success and an error code on failure. This allows the device to execute scheduled tasks.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nesp_err_t enableSchedule();\n```\n\n----------------------------------------\n\nTITLE: Defining onReceive Callback Function - Arduino\nDESCRIPTION: Defines the structure for the callback function that handles data received from the I2C master.  This function is invoked when the slave receives data.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_24\n\nLANGUAGE: arduino\nCODE:\n```\nvoid onReceive( void (*)(int) );\n```\n\n----------------------------------------\n\nTITLE: Analyzing WPS Push Button Successful Log - ESP32\nDESCRIPTION: This log demonstrates a successful WPS Push Button connection. After initializing, the ESP32 successfully connects to the specified router SSID and obtains an IP address. The log includes messages indicating a successful WPS negotiation, disconnection, and reconnection to the network.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WPS/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nets Jun  8 2016 00:22:57\n\nrst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)\nets Jun  8 2016 00:22:57\n\nrst:0x10 (RTCWDT_RTC_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)\nconfigsip: 0, SPIWP:0xee\nclk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00\nmode:DIO, clock div:1\nload:0x3fff0010,len:4\nload:0x3fff0014,len:732\nload:0x40078000,len:0\nload:0x40078000,len:11572\nentry 0x40078a14\n\nStarting WPS\nStation Mode Started\nWPS Successful, stopping WPS and connecting to: < Your Router SSID >\nDisconnected from station, attempting reconnection\nConnected to : < Your Router SSID >\nGot IP: 192.168.1.100\n```\n\n----------------------------------------\n\nTITLE: Play WAV from Memory (Arduino)\nDESCRIPTION: This snippet shows how to play a PCM WAV from memory using the `playWAV()` method. It takes a buffer containing the WAV data and the size of the buffer as input. It uses the current TX settings for playback.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_25\n\nLANGUAGE: arduino\nCODE:\n```\nvoid playWAV(uint8_t * data, size_t len)\n```\n\n----------------------------------------\n\nTITLE: Setting BLE Library Sources - CMake\nDESCRIPTION: This snippet defines a CMake variable `ARDUINO_LIBRARY_BLE_SRCS` containing a list of source files for the BLE library. These source files will be compiled and linked as part of the Arduino-ESP32 project if the BLE library is included in the build.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(ARDUINO_LIBRARY_BLE_SRCS\n  libraries/BLE/src/BLE2901.cpp\n  libraries/BLE/src/BLE2902.cpp\n  libraries/BLE/src/BLE2904.cpp\n  libraries/BLE/src/BLEAddress.cpp\n  libraries/BLE/src/BLEAdvertisedDevice.cpp\n  libraries/BLE/src/BLEAdvertising.cpp\n  libraries/BLE/src/BLEBeacon.cpp\n  libraries/BLE/src/BLECharacteristic.cpp\n  libraries/BLE/src/BLECharacteristicMap.cpp\n  libraries/BLE/src/BLEClient.cpp\n  libraries/BLE/src/BLEDescriptor.cpp\n  libraries/BLE/src/BLEDescriptorMap.cpp\n  libraries/BLE/src/BLEDevice.cpp\n  libraries/BLE/src/BLEEddystoneTLM.cpp\n  libraries/BLE/src/BLEEddystoneURL.cpp\n  libraries/BLE/src/BLEExceptions.cpp\n  libraries/BLE/src/BLEHIDDevice.cpp\n  libraries/BLE/src/BLERemoteCharacteristic.cpp\n  libraries/BLE/src/BLERemoteDescriptor.cpp\n  libraries/BLE/src/BLERemoteService.cpp\n  libraries/BLE/src/BLEScan.cpp\n  libraries/BLE/src/BLESecurity.cpp\n  libraries/BLE/src/BLEServer.cpp\n  libraries/BLE/src/BLEService.cpp\n  libraries/BLE/src/BLEServiceMap.cpp\n  libraries/BLE/src/BLEUtils.cpp\n  libraries/BLE/src/BLEUUID.cpp\n  libraries/BLE/src/BLEValue.cpp\n  libraries/BLE/src/FreeRTOS.cpp\n  libraries/BLE/src/GeneralUtils.cpp\n  )\n```\n\n----------------------------------------\n\nTITLE: Setting Metric Value in Arduino\nDESCRIPTION: Adds a metric of a specified type (Bool, Int, Uint, Float, String, IPv4, or MAC) to storage with the given key and value.  The function returns ESP_OK on success. This API is available via the `Insights.metrics` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nbool setX(const char *key, const void val);\n```\n\n----------------------------------------\n\nTITLE: Specifying SPI Pins: SD Card Mount Fail (C++)\nDESCRIPTION: This code snippet demonstrates how to manually specify the SPI pins when initializing the SD card. This can help resolve SD card mount failures due to connection issues. `SD_CS_PIN` is the chip select pin.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/troubleshooting.rst#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\nint SD_CS_PIN = 19;\nSPI.begin(18, 36, 26, SD_CS_PIN);\nSPI.setDataMode(SPI_MODE0);\nSD.begin(SD_CS_PIN);\n```\n\n----------------------------------------\n\nTITLE: macOS Installation - Bash\nDESCRIPTION: This script installs the Arduino-ESP32 core on macOS by creating the necessary directories in the Arduino sketchbook location, cloning the Arduino-ESP32 repository, and running the get.py script to download tools.  It assumes the standard sketchbook location within the Documents folder.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/installing.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/Documents/Arduino/hardware/espressif && \\\ncd ~/Documents/Arduino/hardware/espressif && \\\ngit clone https://github.com/espressif/arduino-esp32.git esp32 && \\\ncd esp32/tools && \\\npython get.py\n```\n\n----------------------------------------\n\nTITLE: Getting AP IPv4 Address\nDESCRIPTION: Returns the IPv4 address of the Wi-Fi Access Point (AP).  The address is returned in IPAddress format.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\nIPAddress softAPIP();\n```\n\n----------------------------------------\n\nTITLE: Put UShort Value Arduino\nDESCRIPTION: This function stores an `unsigned short` value (uint16_t) associated with a given key in the currently open namespace. If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putUShort(const char* key, uint16_t value)\n```\n\n----------------------------------------\n\nTITLE: Get TX Data Width (Arduino)\nDESCRIPTION: This snippet illustrates how to obtain the transmit (TX) data width using the `txDataWidth()` method of the I2SClass. The data width represents the number of bits used to represent each sample (e.g., 8, 16, or 32 bits). No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\ni2s_data_bit_width_t txDataWidth()\n```\n\n----------------------------------------\n\nTITLE: Switch Constructor - C++\nDESCRIPTION: This snippet demonstrates the Switch class constructor for creating a standard switch device. It takes the device name, private data, and initial power state as parameters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nSwitch my_switch(const char *dev_name, void *priv_data, bool power);\n```\n\n----------------------------------------\n\nTITLE: JSON Configuration with Target Exclusion\nDESCRIPTION: This snippet showcases a `ci.json` file configuration for CI testing. It defines required configurations for Wi-Fi support and specifies targets to be excluded from testing. This ensures that tests are skipped for targets that are not supported, such as ESP32-S2 in this example.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"requires\": [\n    \"CONFIG_SOC_WIFI_SUPPORTED=y\"\n  ],\n  \"targets\": {\n    \"esp32s2\": false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Attaching Touch Interrupt with Argument in Arduino\nDESCRIPTION: This function attaches an interrupt to a touch pad. The function that is called by ISR has access to the given arguments.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/touch.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nvoid touchAttachInterruptArg(uint8_t pin, void (*userFunc)(void*), void *arg, touch_value_t threshold);\n```\n\n----------------------------------------\n\nTITLE: Setting Manufacturer Name - Arduino\nDESCRIPTION: This code snippet demonstrates how to set the manufacturer name for the USB device using the `manufacturerName` function. The manufacturer name is a string that identifies the device's manufacturer. It takes a constant character pointer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_24\n\nLANGUAGE: arduino\nCODE:\n```\nbool manufacturerName(const char * name);\n```\n\n----------------------------------------\n\nTITLE: Configuring Wi-Fi FTM Parameters in C\nDESCRIPTION: This code snippet demonstrates how to configure Wi-Fi Fine Timing Measurement (FTM) parameters, including the Wi-Fi SSID, password, the number of FTM frames, and the burst period between frames. These parameters are crucial for establishing a successful FTM session with a responder or Wi-Fi router with FTM capabilities.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/FTM/FTM_Initiator/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n// Change the SSID and PASSWORD here if needed\nconst char * WIFI_FTM_SSID = \"WiFi_FTM_Responder\"; // SSID of AP that has FTM Enabled\nconst char * WIFI_FTM_PASS = \"ftm_responder\"; // STA Password\n\n// FTM settings\n// Number of FTM frames requested in terms of 4 or 8 bursts (allowed values - 0 (No pref), 16, 24, 32, 64)\nconst uint8_t FTM_FRAME_COUNT = 16;\n// Requested time period between consecutive FTM bursts in 100s of milliseconds (allowed values - 0 (No pref) or 2-255)\nconst uint16_t FTM_BURST_PERIOD = 2;\n```\n\n----------------------------------------\n\nTITLE: Put Long Value Arduino\nDESCRIPTION: This function stores a `long` value (int32_t) associated with a given key in the currently open namespace. If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putLong(const char* key, int32_t value)\n```\n\n----------------------------------------\n\nTITLE: Getting AP Subnet CIDR\nDESCRIPTION: Gets the subnet CIDR of the softAP.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_14\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t softAPSubnetCIDR();\n```\n\n----------------------------------------\n\nTITLE: Open Zigbee Network Manually in Arduino\nDESCRIPTION: This code snippet demonstrates how to manually open the Zigbee network for a specified duration using the `Zigbee.openNetwork(time);` function. This allows new devices to join the network. The time parameter specifies how long the network will remain open, measured in seconds.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Window_Covering/README.md#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.openNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Updating and Reporting Parameter Value (updateAndReport)\nDESCRIPTION: This function updates the parameter and reports it to the ESP RainMaker cloud. This is typically called within a device write callback. It takes the new value of the parameter as input. It returns an `esp_err_t` indicating success or failure. The parameter's type should be `param_val_t`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_28\n\nLANGUAGE: C\nCODE:\n```\nesp_err_t updateAndReport(param_val_t val);\n```\n\n----------------------------------------\n\nTITLE: ESP32-S3 Debug Configuration (OpenOCD)\nDESCRIPTION: Defines debug configurations for ESP32-S3 using OpenOCD. Includes configurations for attaching and restarting the target device.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_25\n\nLANGUAGE: text\nCODE:\n```\ndebug_script.esp32s3=esp32s3-builtin.cfg\ndebug_config.esp32s3.cortex-debug.custom.name=Arduino on ESP32-S3\ndebug_config.esp32s3.cortex-debug.custom.overrideAttachCommands.0=set remote hardware-watchpoint-limit 2\ndebug_config.esp32s3.cortex-debug.custom.overrideAttachCommands.1=monitor reset halt\ndebug_config.esp32s3.cortex-debug.custom.overrideAttachCommands.2=monitor gdb_sync\ndebug_config.esp32s3.cortex-debug.custom.overrideAttachCommands.3=thb setup\ndebug_config.esp32s3.cortex-debug.custom.overrideAttachCommands.4=c\ndebug_config.esp32s3.cortex-debug.custom.overrideRestartCommands.0=monitor reset halt\ndebug_config.esp32s3.cortex-debug.custom.overrideRestartCommands.1=monitor gdb_sync\n```\n\n----------------------------------------\n\nTITLE: Get TX Sample Rate (Arduino)\nDESCRIPTION: This snippet demonstrates how to retrieve the transmit (TX) sample rate using the `txSampleRate()` method of the I2SClass. The sample rate indicates how many samples per second are being transmitted. No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\nuint32_t txSampleRate()\n```\n\n----------------------------------------\n\nTITLE: Disabling ESP Insights in Arduino\nDESCRIPTION: Disables the ESP Insights agent without deinitializing it, potentially allowing for later re-enablement. It allows you to temporary stop the service. There are no parameters and no return value.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nvoid disable();\n```\n\n----------------------------------------\n\nTITLE: Get SoftAP MAC Address - Arduino\nDESCRIPTION: This function retrieves the MAC address of the ESP32 access point (AP).  It returns a String representing the AP's MAC address.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_21\n\nLANGUAGE: arduino\nCODE:\n```\nString softAPmacAddress(void);\n```\n\n----------------------------------------\n\nTITLE: Getting Total Peer Count - getTotalPeerCount()\nDESCRIPTION: Retrieves the total number of peers currently added to the ESP-NOW network. Returns the total number of peers, or `-1` if an error occurs.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint getTotalPeerCount();\n```\n\n----------------------------------------\n\nTITLE: Setting Pins for PDM RX I2S - Arduino\nDESCRIPTION: This function sets the pins for the I2S interface when using the PDM RX mode. It configures the clock (clk) and data input pins (din0, din1, din2, din3). The din1, din2, and din3 parameters are optional and default to -1 if not used. The function enables configuration of up to four data input pins for PDM RX operation.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nvoid setPinsPdmRx(int8_t clk, int8_t din0, int8_t din1=-1, int8_t din2=-1, int8_t din3=-1)\n```\n\n----------------------------------------\n\nTITLE: WiFi Scan Networks - Arduino\nDESCRIPTION: This function starts scanning for available Wi-Fi networks.  It allows setting the scan mode, hidden network visibility, passive scanning, maximum channel scan time, and specific channel. A successful operation will return a `int16_t`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_38\n\nLANGUAGE: arduino\nCODE:\n```\nint16_t scanNetworks(bool async = false, bool show_hidden = false, bool passive = false, uint32_t max_ms_per_chan = 300, uint8_t channel = 0);\n```\n\n----------------------------------------\n\nTITLE: Arduino setPins Function Example\nDESCRIPTION: This code snippet demonstrates how to use the `setPins` function within the Arduino environment. This function is used to configure the SDA and SCL pins for the I2C interface, and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/docs_contributing.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nbool setPins(int sdaPin, int sclPin);\n```\n\n----------------------------------------\n\nTITLE: Enabling Scheduling Service\nDESCRIPTION: This code snippet enables the scheduling service for the node. This allows the device to execute actions based on a schedule.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t enableSchedule();\n```\n\n----------------------------------------\n\nTITLE: Blinking LED - C++\nDESCRIPTION: This code snippet implements the main loop that controls the blinking of the LED. It uses the ``digitalWrite()`` function to set the LED pin to ``HIGH`` (turning the LED on) and ``LOW`` (turning the LED off). The ``delay()`` function is used to introduce pauses between the state changes, creating the blinking effect. The delay is specified in milliseconds, controlling the blink frequency.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/blink.rst#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid loop() {\n    digitalWrite(LED, HIGH);\n    delay(100);\n    digitalWrite(LED, LOW);\n    delay(100);\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Wi-Fi Event Callback Function\nDESCRIPTION: Removes a previously registered Wi-Fi event callback function. This prevents the function from being called when Wi-Fi events occur. Different function signatures correspond to those used in registering the callback.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nvoid removeEvent(WiFiEventCb, arduino_event_id_t = ARDUINO_EVENT_MAX);\n    void removeEvent(WiFiEventSysCb, arduino_event_id_t = ARDUINO_EVENT_MAX);\n    void removeEvent(wifi_event_id_t = ARDUINO_EVENT_MAX);\n```\n\n----------------------------------------\n\nTITLE: Registering a Metric in Arduino\nDESCRIPTION: Registers a metric with a specified type (Bool, Int, Uint, Float, String, IPv4, or MAC), tag, key, label, and hierarchical path. The function returns a boolean indicating success or failure. This API is available via the `Insights.metrics` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nbool addX(const char *tag, const char *key, const char *label, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Reading Touch Sensor Value with touchRead in Arduino\nDESCRIPTION: This function reads the touch sensor value from a specified GPIO pin. The returned value represents the number of charge/discharge cycles. The change in this value indicates if the pad has been touched.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/touch.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\ntouch_value_t touchRead(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: Opening Zigbee network after reboot\nDESCRIPTION: This snippet shows how to open the Zigbee network for a specified duration after the device reboots, allowing devices to join the network without manual intervention. The `time` parameter defines the duration for which the network remains open.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Gateway/README.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nZigbee.setRebootOpenNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Adding Device to Node\nDESCRIPTION: This code snippet adds a device to the node. Each node can have multiple devices, and each device must have a unique name.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t addDevice(Device device);\n```\n\n----------------------------------------\n\nTITLE: Put Double Value Arduino\nDESCRIPTION: This function stores a `double` value associated with a given key in the currently open namespace. If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_17\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putDouble(const char* key, double_t value)\n```\n\n----------------------------------------\n\nTITLE: I2S Example Code (Arduino)\nDESCRIPTION: This code demonstrates the usage of the I2SClass to configure, read from, and write to the I2S interface. It sets pins, begins I2S, reads available bytes, reads bytes into a buffer, writes the buffer to I2S, and ends I2S.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_27\n\nLANGUAGE: arduino\nCODE:\n```\n#include <ESP_I2S.h>\n\n  const int buff_size = 128;\n  int available_bytes, read_bytes;\n  uint8_t buffer[buff_size];\n  I2SClass I2S;\n\n  void setup() {\n    I2S.setPins(5, 25, 26, 35, 0); //SCK, WS, SDOUT, SDIN, MCLK\n    I2S.begin(I2S_MODE_STD, 16000, I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO);\n    I2S.read();\n    available_bytes = I2S.available();\n    if(available_bytes < buff_size) {\n      read_bytes = I2S.readBytes(buffer, available_bytes);\n    } else {\n      read_bytes = I2S.readBytes(buffer, buff_size);\n    }\n    I2S.write(buffer, read_bytes);\n    I2S.end();\n  }\n\n  void loop() {}\n```\n\n----------------------------------------\n\nTITLE: Setting Peer Local Master Key - setKey()\nDESCRIPTION: Sets the local master key (LMK) for the peer. Takes the LMK as a parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nvoid setKey(const uint8_t *lmk);\n```\n\n----------------------------------------\n\nTITLE: Compiling C Files for Arduino ESP32\nDESCRIPTION: This snippet defines the recipe for compiling C source files using the specified compiler and flags. It includes definitions for CPU frequency, Arduino version, board type, architecture, variant, and partition scheme. The command compiles the source file and outputs an object file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nrecipe.c.o.pattern=\"{compiler.path}{compiler.c.cmd}\" {compiler.c.extra_flags} {compiler.c.flags} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=\"{build.board}\" -DARDUINO_VARIANT=\"{build.variant}\" -DARDUINO_PARTITION_{build.partitions} {build.extra_flags} {compiler.cpreprocessor.flags} {includes} \"@{build.opt.path}\" \"@{file_opts.path}\" \"{source_file}\" -o \"{object_file}\"\n```\n\n----------------------------------------\n\nTITLE: Adding Arduino component using IDF Component Manager (Bash)\nDESCRIPTION: This command adds the Arduino ESP32 component to your ESP-IDF project using the IDF Component Manager. This method simplifies the integration process by automatically downloading and installing the necessary dependencies.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nidf.py add-dependency \"espressif/arduino-esp32^3.0.2\"\n```\n\n----------------------------------------\n\nTITLE: SigmaDelta example application - Arduino\nDESCRIPTION: This code snippet refers to an example application demonstrating the use of the SigmaDelta module. The example is located in the Arduino-ESP32 libraries at `libraries/ESP32/examples/AnalogOut/SigmaDelta/SigmaDelta.ino`. It provides a practical demonstration of how to use the SigmaDelta API.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/sigmadelta.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\n../../../libraries/ESP32/examples/AnalogOut/SigmaDelta/SigmaDelta.ino\n```\n\n----------------------------------------\n\nTITLE: Storing Bytes in Preferences - Arduino\nDESCRIPTION: This code snippet illustrates how to store a sequence of bytes associated with a given key in the currently open Preferences namespace using the `putBytes` function. It accepts a key, a pointer to the data to be stored, and the number of bytes to store. It returns the number of bytes stored, or 0 on failure. This function needs a namespace to be open in read-write mode and stores the raw bytes without retaining type information, and logs errors to `log_e`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_20\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putBytes(const char* key, const void* value, size_t len);\n```\n\n----------------------------------------\n\nTITLE: Lowering Wi-Fi Security: WEP/WPA (Arduino)\nDESCRIPTION: This code snippet allows connecting to WEP or WPA \"encrypted\" Wi-Fi networks by lowering the security requirements of the ESP32.  It's crucial to understand the security risks of using WEP/WPA before implementing this.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/troubleshooting.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nWiFi.setMinSecurity(WIFI_AUTH_WEP); // Lower min security to WEP.\n// or\nWiFi.setMinSecurity(WIFI_AUTH_WPA_PSK); // Lower min security to WPA.\n```\n\n----------------------------------------\n\nTITLE: Peeking at Incoming Data - Arduino\nDESCRIPTION: Allows peeking at the next available byte in the receive queue without removing it. This enables inspection of the data before reading it, which can be useful for parsing protocols or determining the type of incoming data. Returns the value of the next byte as an int.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nint peek(void);\n```\n\n----------------------------------------\n\nTITLE: Flashing ESP32-C6 via Thread\nDESCRIPTION: This command flashes the ESP32-C6 device using Thread with the specified serial port. It sets the default SDK configuration file for ESP32-C6 to use Thread networking.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nidf.py -D SDKCONFIG_DEFAULTS=\"sdkconfig.defaults.c6_thread\" -p /dev/ttyACM0 flash monitor\n```\n\n----------------------------------------\n\nTITLE: Resetting Wi-Fi Credentials (RMakerWiFiReset)\nDESCRIPTION: This function resets the Wi-Fi credentials of the device. It takes the time in seconds after which the chip should reboot after doing a Wi-Fi reset as a parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_31\n\nLANGUAGE: C\nCODE:\n```\nRMakerWiFiReset(2);\n```\n\n----------------------------------------\n\nTITLE: Adding LGPL Notices to Library Source Files\nDESCRIPTION: This code snippet demonstrates the required notices to include at the beginning of each source file in a library licensed under the GNU Lesser General Public License (LGPL).  It includes the library's name, copyright information, and a reference to the LGPL terms. This helps to ensure proper licensing and attribution.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/LICENSE.md#_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n    one line to give the library's name and an idea of what it does.\n    Copyright (C) year  name of author\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n```\n\n----------------------------------------\n\nTITLE: Defining LED Pin - C++\nDESCRIPTION: This code snippet defines the GPIO pin to which the LED is connected. It uses the ``#define`` preprocessor directive to assign the value ``2`` to the symbolic constant ``LED``. This allows for easy modification of the LED pin without changing the code in multiple places. The defined constant is used later in the ``setup()`` and ``loop()`` functions.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/blink.rst#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#define LED 2\n```\n\n----------------------------------------\n\nTITLE: Configuring Wi-Fi SSID and Password for FTM Responder in C\nDESCRIPTION: This code snippet demonstrates how to configure the Wi-Fi SSID and password for the FTM Responder example. The SSID and password should match the initiator's settings for successful communication. These values are defined as constant character pointers in C.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/FTM/FTM_Responder/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n// Change the SSID and PASSWORD here if needed\nconst char * WIFI_FTM_SSID = \"WiFi_FTM_Responder\";\nconst char * WIFI_FTM_PASS = \"ftm_responder\";\n```\n\n----------------------------------------\n\nTITLE: Applying Additional Configuration in Bash\nDESCRIPTION: This command applies additional configurations like `qio 80m` when building the libraries. It requires the `-b` option to work properly and the `-t` option.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh -t esp32 -b idf_libs qio 80m\n```\n\n----------------------------------------\n\nTITLE: Preferences Byte Array Example - Arduino\nDESCRIPTION: This complete example demonstrates how to use the `putBytes` and `getBytes` methods to store and retrieve an array of int16_t values in the Preferences namespace.  It also showcases clearing the namespace and using Serial.print/println for debugging.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_16\n\nLANGUAGE: arduino\nCODE:\n```\n/*\n *  An example sketch using the Preferences \"Bytes\" methods\n *   to store and retrieve an arbitrary number of bytes in\n *   a namespace.\n */\n\n#include <Preferences.h>\n\n#define RO_MODE true\n#define RW_MODE false\n\nvoid setup() {\n\n    Preferences mySketchPrefs;\n\n    Serial.begin(115200);\n    delay(250);\n\n    mySketchPrefs.begin(\"myPrefs\", RW_MODE);   // open (or create) the namespace\n                                               //  \"myPrefs\" in RW mode\n    mySketchPrefs.clear();                     // delete any previous keys in this namespace\n\n    // Create an array of test values. We're using hex numbers\n    //  throughout to better show how the bytes move around.\n    int16_t myArray[] = { 0x1112, 0x2122, 0x3132, 0x4142, 0x5152, 0x6162, 0x7172 };\n\n    Serial.println(\"Printing myArray...\");\n    for (int i = 0; i < sizeof(myArray) / sizeof(int16_t); i++) {\n        Serial.print(myArray[i], HEX); Serial.print(\", \");\n    }\n    Serial.println(\"\\r\\n\");\n\n    // In the next statement, the second sizeof()\n```\n\n----------------------------------------\n\nTITLE: Defining SPI Constants Keywords for Syntax Coloring\nDESCRIPTION: This snippet defines SPI-related constants for syntax coloring. The listed constants, such as clock dividers ('SPI_CLOCK_DIV4', 'SPI_CLOCK_DIV16', etc.) and modes ('SPI_MODE0', 'SPI_MODE1', etc.), are marked as keywords, allowing the IDE to highlight them appropriately. This helps to improve code understanding by visually distinguishing SPI constants.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/SPI/keywords.txt#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nSPI_CLOCK_DIV4\tLITERAL1\nSPI_CLOCK_DIV16\tLITERAL1\nSPI_CLOCK_DIV64\tLITERAL1\nSPI_CLOCK_DIV128\tLITERAL1\nSPI_CLOCK_DIV2\tLITERAL1\nSPI_CLOCK_DIV8\tLITERAL1\nSPI_CLOCK_DIV32\tLITERAL1\nSPI_CLOCK_DIV64\tLITERAL1\nSPI_MODE0\tLITERAL1\nSPI_MODE1\tLITERAL1\nSPI_MODE2\tLITERAL1\nSPI_MODE3\tLITERAL1\n```\n\n----------------------------------------\n\nTITLE: Read a Byte from I2S Interface (Arduino)\nDESCRIPTION: This snippet shows how to read the next available byte from the I2S interface using the `read()` method. It returns the byte if available, or -1 if no data is present or an error occurs. No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_18\n\nLANGUAGE: arduino\nCODE:\n```\nint read()\n```\n\n----------------------------------------\n\nTITLE: Setting Debug Output - Arduino\nDESCRIPTION: Enables or disables debug output from UART0 to the USB CDC interface.  When enabled, debug messages will be redirected to the USB serial port, allowing for easier debugging.  Takes a boolean parameter to enable or disable the output.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\nvoid setDebugOutput(bool);\n```\n\n----------------------------------------\n\nTITLE: Setting Compile Options - CMake\nDESCRIPTION: This snippet sets compile options for the component based on the Arduino version, architecture, board, and variant. It converts the Arduino variant to uppercase and replaces hyphens with underscores to create a macro name. Then, it sets preprocessor definitions using target_compile_options.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nstring(TOUPPER ${CONFIG_ARDUINO_VARIANT} idf_target_caps)\nstring(REPLACE \"-\" \"_\" idf_target_for_macro \"${idf_target_caps}\")\ntarget_compile_options(${COMPONENT_TARGET} PUBLIC\n    -DARDUINO=10812\n    -DARDUINO_${idf_target_for_macro}_DEV\n    -DARDUINO_ARCH_ESP32\n    -DARDUINO_BOARD=\"${idf_target_caps}_DEV\"\n    -DARDUINO_VARIANT=\"${CONFIG_ARDUINO_VARIANT}\"\n    -DESP32=ESP32)\n```\n\n----------------------------------------\n\nTITLE: 8MB No OTA with Storage Partition Table Example\nDESCRIPTION: This code snippet shows an example of a partition table configuration for an 8MB flash without OTA support but with storage. It defines partitions for NVS, a factory application, and a SPIFFS partition for file storage.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/partition_table.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n# Name,   Type, SubType, Offset,  Size, Flags\nnvs,      data, nvs,     36K,     20K,\nfactory,  app,  factory, 64K,     2M,\nspiffs,   data, spiffs,  ,        5M,\n```\n\n----------------------------------------\n\nTITLE: Defining Pre-Build Hooks (Core Build Flag)\nDESCRIPTION: These bash/cmd scripts manage the `-DARDUINO_CORE_BUILD` flag.  Before core file compilation, the flag is written to `file_opts.path`. After core compilation, the file is emptied. This flag is intended to be used only during the compilation of core files.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_6\n\nLANGUAGE: properties\nCODE:\n```\nfile_opts.path={build.path}/file_opts\nrecipe.hooks.prebuild.7.pattern=/usr/bin/env bash -c \": > '{file_opts.path}'\"\nrecipe.hooks.core.prebuild.1.pattern=/usr/bin/env bash -c \"echo -DARDUINO_CORE_BUILD > '{file_opts.path}'\"\nrecipe.hooks.core.postbuild.1.pattern=/usr/bin/env bash -c \": > '{file_opts.path}'\"\n\nrecipe.hooks.prebuild.7.pattern.windows=cmd /c type nul > \"{file_opts.path}\"\nrecipe.hooks.core.prebuild.1.pattern.windows=cmd /c echo \"-DARDUINO_CORE_BUILD\" > \"{file_opts.path}\"\nrecipe.hooks.core.postbuild.1.pattern.windows=cmd /c type nul > \"{file_opts.path}\"\n```\n\n----------------------------------------\n\nTITLE: Checking Reboot Enabled Status - Arduino\nDESCRIPTION: Determines whether the reboot-via-DTR/RTS functionality is currently enabled. Returns true if rebooting via DTR/RTS is enabled; otherwise, returns false. This function allows the application to check the current reboot configuration.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_14\n\nLANGUAGE: arduino\nCODE:\n```\nbool rebootEnabled(void);\n```\n\n----------------------------------------\n\nTITLE: WiFi getAutoReconnect - Arduino\nDESCRIPTION: This function retrieves the automatic reconnection setting. It returns true if the automatic reconnection option is enabled.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_34\n\nLANGUAGE: arduino\nCODE:\n```\nbool getAutoReconnect();\n```\n\n----------------------------------------\n\nTITLE: SPI Multiple Buses Example - Arduino\nDESCRIPTION: This Arduino sketch demonstrates the configuration and usage of multiple SPI buses on the ESP32 platform. It includes the necessary header files, defines the pin configurations for each SPI bus, and performs data transmission/reception using the SPI protocol. The sketch is located in the SPI library examples folder.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/spi.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nnot provided, see file path: ../../../libraries/SPI/examples/SPI_Multiple_Buses/SPI_Multiple_Buses.ino\n```\n\n----------------------------------------\n\nTITLE: Getting Hostname of DHCP Client\nDESCRIPTION: Retrieves the currently configured hostname of the DHCP client. This can be either the default hostname or a custom hostname set using setHostname().\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nconst char *getHostname();\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project - CMake\nDESCRIPTION: Includes the necessary definitions and functions from the ESP-IDF (Espressif IoT Development Framework) to build the project. It relies on the IDF_PATH environment variable, which should point to the location of the ESP-IDF installation. This step is essential for integrating the project with the ESP32 hardware and software ecosystem.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/hw_cdc_hello_world/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: WiFi Config - Arduino\nDESCRIPTION: This function configures the Wi-Fi settings, including the local IP address, gateway, subnet mask, and DNS servers. It allows for static IP configuration.  A successful configuration will return `true`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_28\n\nLANGUAGE: arduino\nCODE:\n```\nbool config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1 = (uint32_t)0x00000000, IPAddress dns2 = (uint32_t)0x00000000);\n```\n\n----------------------------------------\n\nTITLE: Defining Pre-Build Hooks (Bootloader)\nDESCRIPTION: These bash/cmd scripts are executed before the build process to handle the bootloader. They check for custom bootloader binaries in the source or variant directories and copy them to the build directory. If no custom bootloader is found, it uses esptool.py to generate a bootloader based on the specified chip, flash mode, flash frequency, and flash size.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_4\n\nLANGUAGE: properties\nCODE:\n```\nrecipe.hooks.prebuild.4.pattern_args=--chip {build.mcu} elf2image --flash_mode {build.flash_mode} --flash_freq {build.img_freq} --flash_size {build.flash_size} -o\nrecipe.hooks.prebuild.4.pattern=/usr/bin/env bash -c \"[ -f \\\"{build.source.path}\\\"/bootloader.bin ] && cp -f \\\"{build.source.path}\\\"/bootloader.bin \\\"{build.path}\\\"/\\\"{build.project_name}\\\".bootloader.bin || ( [ -f \\\"{build.variant.path}\\\"/\\\"{build.custom_bootloader}\\\".bin ] && cp \\\"{build.variant.path}\\\"/\\\"{build.custom_bootloader}\\\".bin \\\"{build.path}\\\"/\\\"{build.project_name}\\\".bootloader.bin || \\\"{tools.esptool_py.path}\\\"/\\\"{tools.esptool_py.cmd}\\\" {recipe.hooks.prebuild.4.pattern_args} \\\"{build.path}\\\"/\\\"{build.project_name}\\\".bootloader.bin \\\"{compiler.sdk.path}\\\"/bin/bootloader_{build.boot}_{build.boot_freq}.elf )\"\nrecipe.hooks.prebuild.4.pattern.windows=cmd /c IF EXIST \"{build.source.path}\\bootloader.bin\" ( COPY /y \"{build.source.path}\\bootloader.bin\" \"{build.path}\\{build.project_name}.bootloader.bin\" ) ELSE ( IF EXIST \"{build.variant.path}\\{build.custom_bootloader}.bin\" ( COPY \"{build.variant.path}\\{build.custom_bootloader}.bin\" \"{build.path}\\{build.project_name}.bootloader.bin\" ) ELSE ( \"{tools.esptool_py.path}\\{tools.esptool_py.cmd}\" {recipe.hooks.prebuild.4.pattern_args} \"{build.path}\\{build.project_name}.bootloader.bin\" \"{compiler.sdk.path}\\bin\\bootloader_{build.boot}_{build.boot_freq}.elf\" ) )\n```\n\n----------------------------------------\n\nTITLE: Adding Library from Arduino Library Manager (JSON)\nDESCRIPTION: This JSON snippet demonstrates how to add a library from the Arduino Library Manager to the external libraries test. It includes the library's name, a list of excluded targets (SoCs), and the path to the sketch to be tested.  The `exclude_targets` parameter is used to specify which SoCs should be excluded from testing due to incompatibility or unsupported peripherals.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/external_libraries_test.rst#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"ArduinoBLE\",\n    \"exclude_targets\": [\n        \"esp32s2\"\n    ],\n    \"sketch_path\": [\n        \"~/Arduino/libraries/ArduinoBLE/examples/Central/Scan/Scan.ino\"\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with CMake\nDESCRIPTION: This snippet registers an ESP-IDF component by specifying the source directories (SRC_DIRS) and include directories (INCLUDE_DIRS). This tells the ESP-IDF build system where to find the component's source code and header files.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRC_DIRS          \".\"\n                       INCLUDE_DIRS      \".\")\n```\n\n----------------------------------------\n\nTITLE: FreeRTOS Tick Check - CMake\nDESCRIPTION: This snippet checks if the FreeRTOS tick rate (`CONFIG_FREERTOS_HZ`) is equal to 1000. If not, and the environment variable `ARDUINO_SKIP_TICK_CHECK` is not set, it generates a fatal error, indicating that the Arduino-ESP32 environment requires a specific FreeRTOS tick rate.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CONFIG_FREERTOS_HZ EQUAL 1000 AND NOT \"$ENV{ARDUINO_SKIP_TICK_CHECK}\")\n    # See delay() in cores/esp32/esp32-hal-misc.c.\n    message(FATAL_ERROR \"esp32-arduino requires CONFIG_FREERTOS_HZ=1000 \"\n                        \"(currently ${CONFIG_FREERTOS_HZ})\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Analog Write Frequency - Arduino\nDESCRIPTION: Sets the frequency for a selected analogWrite pin. It accepts the pin number and the frequency value as input.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_18\n\nLANGUAGE: arduino\nCODE:\n```\nvoid analogWriteFrequency(uint8_t pin, uint32_t freq);\n```\n\n----------------------------------------\n\nTITLE: Creating Standard Device (Switch)\nDESCRIPTION: This code snippet demonstrates creating a standard `Switch` device. The constructor takes the device name, private data, and initial power state as parameters. No parameters are compulsory for standard devices, however if you are creating two objects of same standard class then in that case you will have to set the device name, if not then both devices will have the same default name, hence device will not get created. Device name should be unique for each device.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_15\n\nLANGUAGE: arduino\nCODE:\n```\nSwitch my_switch(const char *dev_name, void *priv_data, bool power);\n```\n\nLANGUAGE: arduino\nCODE:\n```\nSwitch switch1;\n```\n\nLANGUAGE: arduino\nCODE:\n```\nSwitch switch2(\"switch2\", NULL, true);\n```\n\n----------------------------------------\n\nTITLE: Defining Pre-Build Hooks (Build Options)\nDESCRIPTION: These bash/cmd scripts are executed before the build process to handle custom build options. They check for a custom build_opt.h file in the source directory and copy it to the build directory. If no such file is found, an empty build_opt.h file is created in the build directory. This allows for project-specific build configurations.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_5\n\nLANGUAGE: properties\nCODE:\n```\nrecipe.hooks.prebuild.5.pattern=/usr/bin/env bash -c \"[ ! -f \\\"{build.source.path}\\\"/build_opt.h ] || cp -f \\\"{build.source.path}\\\"/build_opt.h \\\"{build.path}\\\"/build_opt.h\"\nrecipe.hooks.prebuild.6.pattern=/usr/bin/env bash -c \"[ -f \\\"{build.path}\\\"/build_opt.h ] || : > \\\"{build.path}\\\"/build_opt.h\"\n\nrecipe.hooks.prebuild.5.pattern.windows=cmd /c if exist \"{build.source.path}\\build_opt.h\" COPY /y \"{build.source.path}\\build_opt.h\" \"{build.path}\\build_opt.h\"\nrecipe.hooks.prebuild.6.pattern.windows=cmd /c if not exist \"{build.path}\\build_opt.h\" type nul > \"{build.path}\\build_opt.h\"\n```\n\n----------------------------------------\n\nTITLE: Custom Partition Table Example\nDESCRIPTION: This code snippet shows an example of a custom partition table. It defines partitions for NVS, OTA data, two application partitions for OTA updates (app0, app1), and a SPIFFS partition for file storage. The offset for app1 and spiffs are left blank to be automatically calculated.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/partition_table.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n# Name,   Type, SubType, Offset,  Size, Flags\nnvs,      data, nvs,     36K,     20K,\notadata,  data, ota,     56K,     8K,\napp0,     app,  ota_0,   64K,     2M,\napp1,     app,  ota_1,   ,        2M,\nspiffs,   data, spiffs,  ,        8M,\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Paths for ESP32 Arduino\nDESCRIPTION: Defines the paths to the compiler executables used for building ESP32 Arduino projects. It specifies the location of the GCC compiler for different architectures and tools like ar and size. The paths are constructed based on the runtime platform and build target architecture.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_0\n\nLANGUAGE: properties\nCODE:\n```\ncompiler.path={tools.{build.tarch}-esp-elf-gcc.path}/bin/\ncompiler.prefix={build.tarch}-{build.target}-elf-\n\ncompiler.sdk.path={tools.esp32-arduino-libs.path}/{build.mcu}\ncompiler.sdk.path.windows={tools.esp32-arduino-libs.path}\\{build.mcu}\n\ncompiler.c.cmd={compiler.prefix}gcc\ncompiler.cpp.cmd={compiler.prefix}g++\ncompiler.S.cmd={compiler.prefix}gcc\ncompiler.c.elf.cmd={compiler.prefix}g++\ncompiler.as.cmd={compiler.prefix}as\ncompiler.ar.cmd={compiler.prefix}gcc-ar\ncompiler.size.cmd={compiler.prefix}size\n```\n\n----------------------------------------\n\nTITLE: Setting Analog Write Resolution - Arduino\nDESCRIPTION: Sets the resolution for a selected analogWrite pin. It accepts the pin number and the resolution value as input.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_17\n\nLANGUAGE: arduino\nCODE:\n```\nvoid analogWriteResolution(uint8_t pin, uint8_t resolution);\n```\n\n----------------------------------------\n\nTITLE: Adding Device Attribute - C++\nDESCRIPTION: This snippet demonstrates how to add an attribute to the device. Device attributes are reported only once after a boot-up as part of the node configuration, such as a serial number. Returns ESP_OK on success, error otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nesp_err_t addDeviceAttr(const char *attr_name, const char *val);\n```\n\n----------------------------------------\n\nTITLE: Getting USB Power - Arduino\nDESCRIPTION: This code snippet shows how to get the USB power configuration using the `usbPower` function. It retrieves the currently configured USB power, represented in milliamperes (mA).\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\nuint16_t usbPower(void);\n```\n\n----------------------------------------\n\nTITLE: Setting the duty cycle for SigmaDelta pin - Arduino\nDESCRIPTION: This code snippet demonstrates how to set the duty cycle for a SigmaDelta pin using the `sigmaDeltaWrite` function. It takes the GPIO pin and the desired duty cycle as input.  The function returns true if setting the duty was successful, and false otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/sigmadelta.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nbool sigmaDeltaWrite(uint8_t pin, uint8_t duty);\n```\n\n----------------------------------------\n\nTITLE: JSON Configuration for CI Testing\nDESCRIPTION: This snippet demonstrates a `ci.json` file used to configure Continuous Integration (CI) testing for Arduino examples.  It specifies required configurations from `sdkconfig` to ensure that the tests are run only on targets that have the necessary features, like Wi-Fi support.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"requires\": [\n    \"CONFIG_SOC_WIFI_SUPPORTED=y\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Opening the Zigbee Network on Reboot - Arduino\nDESCRIPTION: To open the Zigbee network after rebooting or flashing new firmware, set `Zigbee.setRebootOpenNetwork(time);` before calling `Zigbee.begin();`. This ensures that the network is available for devices to join after a restart.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_PM25_Sensor/README.md#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.setRebootOpenNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Storing a String Value in Preferences - Arduino\nDESCRIPTION: This code snippet shows how to store a string value (either a C-style string or an Arduino String object) associated with a given key in the current namespace using the `putString` function. It accepts a key and either a `const char*` or `String` value. It returns the number of bytes stored, or 0 on failure. The function requires a namespace to be open in read-write mode to function correctly, and failures generate log messages to `log_e`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_19\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putString(const char* key, const char* value);\nsize_t putString(const char* key, String value);\n```\n\n----------------------------------------\n\nTITLE: ESP32 Debug Configuration (OpenOCD)\nDESCRIPTION: Defines debug configurations for ESP32 using OpenOCD. Specifies custom commands for attaching to and restarting the target device, as well as the debug script to use.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_23\n\nLANGUAGE: text\nCODE:\n```\ndebug_script.esp32=esp32-wrover-kit-3.3v.cfg\ndebug_config.esp32.cortex-debug.custom.name=Arduino on ESP32\ndebug_config.esp32.cortex-debug.custom.postAttachCommands.0=set remote hardware-watchpoint-limit 2\ndebug_config.esp32.cortex-debug.custom.postAttachCommands.1=monitor reset halt\ndebug_config.esp32.cortex-debug.custom.postAttachCommands.2=monitor gdb_sync\ndebug_config.esp32.cortex-debug.custom.postAttachCommands.3=thb setup\ndebug_config.esp32.cortex-debug.custom.postAttachCommands.4=c\ndebug_config.esp32.cortex-debug.custom.overrideRestartCommands.0=monitor reset halt\ndebug_config.esp32.cortex-debug.custom.overrideRestartCommands.1=monitor gdb_sync\ndebug_config.esp32.cortex-debug.custom.overrideRestartCommands.2=thb setup\ndebug_config.esp32.cortex-debug.custom.overrideRestartCommands.3=c\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies\nDESCRIPTION: This snippet defines the Python packages required for the project along with their specific versions. These packages are likely used for documentation generation and related tasks. Common packages are esp-docs, sphinx-copybutton, sphinx-tabs, numpydoc and standard-imghdr.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/requirements.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nesp-docs>=1.4.0\nsphinx-copybutton==0.5.0\nsphinx-tabs==3.2.0\nnumpydoc==1.5.0\nstandard-imghdr==3.13.0\n```\n\n----------------------------------------\n\nTITLE: JSON Configuration for FQBN Append\nDESCRIPTION: This snippet illustrates a `ci.json` configuration for appending a string to the default Fully Qualified Board Names (FQBNs) used in CI testing. It demonstrates how to add build options such as `DebugLevel=debug` to the FQBNs.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"fqbn_append\": \"DebugLevel=debug\"\n}\n```\n\n----------------------------------------\n\nTITLE: Arduino I2C Slave Mode Callbacks\nDESCRIPTION: This code snippet illustrates how to set up callback functions for handling I2C communication in slave mode using the Arduino environment. It shows how to register `onReceive` and `onRequest` functions to respond to master device requests.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/docs_contributing.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nWire.onReceive(onReceive);\n\nand\n\nWire.onRequest(onRequest);\n```\n\n----------------------------------------\n\nTITLE: ESP32-S2 Debug Configuration (OpenOCD)\nDESCRIPTION: Defines debug configurations for ESP32-S2 using OpenOCD. Specifies custom commands for attaching to and restarting the target device, along with the debug script.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_24\n\nLANGUAGE: text\nCODE:\n```\ndebug_script.esp32s2=esp32s2-kaluga-1.cfg\ndebug_config.esp32s2.cortex-debug.custom.name=Arduino on ESP32-S2\ndebug_config.esp32s2.cortex-debug.custom.postAttachCommands.0=set remote hardware-watchpoint-limit 2\ndebug_config.esp32s2.cortex-debug.custom.postAttachCommands.1=monitor reset halt\ndebug_config.esp32s2.cortex-debug.custom.postAttachCommands.2=monitor gdb_sync\ndebug_config.esp32s2.cortex-debug.custom.postAttachCommands.3=thb setup\ndebug_config.esp32s2.cortex-debug.custom.postAttachCommands.4=c\ndebug_config.esp32s2.cortex-debug.custom.overrideRestartCommands.0=monitor reset halt\ndebug_config.esp32s2.cortex-debug.custom.overrideRestartCommands.1=monitor gdb_sync\ndebug_config.esp32s2.cortex-debug.custom.overrideRestartCommands.2=thb setup\ndebug_config.esp32s2.cortex-debug.custom.overrideRestartCommands.3=c\n```\n\n----------------------------------------\n\nTITLE: Get Last Error Code from I2S Interface (Arduino)\nDESCRIPTION: This snippet illustrates how to retrieve the last error code for an I/O operation on the I2S interface using the `lastError()` method. No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_23\n\nLANGUAGE: arduino\nCODE:\n```\nint lastError()\n```\n\n----------------------------------------\n\nTITLE: Flashing ESP32-S3 via Wi-Fi\nDESCRIPTION: This command flashes the ESP32-S3 device using Wi-Fi with the specified serial port. It also sets the default SDK configuration file for ESP32-S3.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nidf.py -D SDKCONFIG_DEFAULTS=\"sdkconfig.defaults.esp32s3\" -p /dev/ttyACM0 flash monitor\n```\n\n----------------------------------------\n\nTITLE: Registering a Variable in Arduino\nDESCRIPTION: Registers a variable with a specified type (Bool, Int, Uint, Float, String, IPv4, or MAC), tag, key, label, and hierarchical path. The function returns a boolean indicating success or failure. This API is available via the `Insights.variables` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\nbool addX(const char *tag, const char *key, const char *label, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Double Value from Preferences - Arduino\nDESCRIPTION: This code snippet demonstrates how to retrieve a double value associated with a given key from the currently open namespace using the `getDouble` function. It takes a key and an optional default value, which defaults to NAN (Not a Number). It returns the stored value or the default value if the key is not found or if there are any failures, operating similarly to `getChar` but returning a double.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_27\n\nLANGUAGE: arduino\nCODE:\n```\ndouble_t getDouble(const char* key, double_t defaultValue = NAN)\n```\n\n----------------------------------------\n\nTITLE: Dumping WiFi Metrics in Arduino\nDESCRIPTION: Dumps Wi-Fi metrics and prints them to the console, providing information about the device's Wi-Fi connection at a specific point in time.  The function returns a boolean indicating success or failure. This API is available via the `Insights.metrics` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\nbool dumpWiFi();\n```\n\n----------------------------------------\n\nTITLE: Displaying QR Code for Provisioning (printQR)\nDESCRIPTION: This function displays a QR code used for provisioning devices. It takes the service name, proof of possession (pop), and transport type (softap or ble) as parameters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_29\n\nLANGUAGE: C\nCODE:\n```\nprintQR(const char *serv_name, const char *pop, const char *transport);\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies (Ubuntu) in Bash\nDESCRIPTION: This command installs the required dependencies on Ubuntu using `apt-get`. These dependencies are necessary for building the ESP32 Arduino libraries.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install git wget curl libssl-dev libncurses-dev flex bison gperf cmake ninja-build ccache jq\n```\n\n----------------------------------------\n\nTITLE: Factory Reset Zigbee Device in Arduino\nDESCRIPTION: This code snippet demonstrates how to reset the Zigbee device and its stack using the `Zigbee.factoryReset()` function. This can be useful for troubleshooting connection issues, especially after re-flashing the coordinator. This function should be added to the Arduino sketch.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Window_Covering/README.md#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.factoryReset();\n```\n\n----------------------------------------\n\nTITLE: Switch Constructor Sample - C++\nDESCRIPTION: These snippets provide examples of how to create Switch objects. If creating multiple objects of the same standard device, you need to set the device name to ensure uniqueness.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nSwitch switch1;\nSwitch switch2(\"switch2\", NULL, true);\n```\n\n----------------------------------------\n\nTITLE: Setting PowerShell Execution Policy\nDESCRIPTION: This command sets the PowerShell execution policy to Bypass for the current process. This is required to execute unsigned scripts like the Docker run script. Use with caution and understand the security implications.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_20\n\nLANGUAGE: powershell\nCODE:\n```\nSet-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass\n```\n\n----------------------------------------\n\nTITLE: Creating Partitions Binary for Arduino ESP32\nDESCRIPTION: This snippet creates a binary file containing partition information from a CSV file.  It uses the `gen_esp32part` tool to generate a partitions binary.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\nrecipe.objcopy.partitions.bin.pattern={tools.gen_esp32part.cmd} -q \"{build.path}/partitions.csv\" \"{build.path}/{build.project_name}.partitions.bin\"\n```\n\n----------------------------------------\n\nTITLE: Executing Docker Run Script (Windows PowerShell)\nDESCRIPTION: This command downloads and executes a PowerShell script for running the ESP32 Arduino Lib Builder Docker image in Windows. It uses Invoke-WebRequest to download the script and then executes it. Requires PowerShell.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_19\n\nLANGUAGE: powershell\nCODE:\n```\nInvoke-WebRequest -Uri \"https://raw.githubusercontent.com/espressif/esp32-arduino-lib-builder/refs/heads/release/v5.1/tools/docker/run.ps1\" -OutFile \"run.ps1\"\n.\\run.ps1 $pwd\n```\n\n----------------------------------------\n\nTITLE: Get RX Slot Mode (Arduino)\nDESCRIPTION: This snippet shows how to retrieve the receive (RX) slot mode using the `rxSlotMode()` method of the I2SClass. This function returns whether the incoming audio is stereo or mono. No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_16\n\nLANGUAGE: arduino\nCODE:\n```\ni2s_slot_mode_t rxSlotMode()\n```\n\n----------------------------------------\n\nTITLE: ZHA Toolkit: Read Attribute Action - YAML\nDESCRIPTION: This YAML snippet defines an action for an automation in Home Assistant that uses the ZHA Toolkit to read a specific attribute from a Zigbee device. It reads the wind speed from a Zigbee sensor, converts the raw value, and stores it in a helper variable. It requires the ZHA Toolkit integration and a properly configured Zigbee device.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Wind_Speed_Sensor/README.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\naction: zha_toolkit.attr_read\nmetadata: {}\ndata:\n    ieee: f0:f5:bd:ff:fe:0e:61:30 #set device IEEE address\n    endpoint: 10 #set windspeed device endpoint\n    cluster: 1035 #use this windspeed cluster\n    attribute: 0 #read measurement value\n    state_id: input_number.wind_speed #save to created helper variable\n    state_value_template: value/100 #use correct value format (convert u16 to float)\n```\n\n----------------------------------------\n\nTITLE: Default 8MB Partition Table Example\nDESCRIPTION: This code snippet shows an example of a default partition table configuration for an 8MB flash. It defines partitions for NVS, OTA data, two application partitions for OTA updates (app0, app1), and a SPIFFS partition for file storage. The offset and size of each partition are specified in hexadecimal format.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/partition_table.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n# Name,   Type, SubType, Offset,  Size, Flags\nnvs,      data, nvs,     0x9000,  0x5000,\notadata,  data, ota,     0xe000,  0x2000,\napp0,     app,  ota_0,   0x10000, 0x330000,\napp1,     app,  ota_1,   0x340000,0x330000,\nspiffs,   data, spiffs,  0x670000,0x190000,\n```\n\n----------------------------------------\n\nTITLE: Get RX Sample Rate (Arduino)\nDESCRIPTION: This snippet shows how to retrieve the receive (RX) sample rate using the `rxSampleRate()` method of the I2SClass. This indicates the number of samples per second being received. No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_14\n\nLANGUAGE: arduino\nCODE:\n```\nuint32_t rxSampleRate()\n```\n\n----------------------------------------\n\nTITLE: Analyzing WPS Push Button Failure Log - ESP32\nDESCRIPTION: This log shows a failed WPS Push Button connection attempt. The log output indicates that WPS has started, but then times out and retries multiple times without successfully connecting to the network. This suggests a problem with the WPS push button process on the router or interference during the connection attempt.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WPS/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nets Jun  8 2016 00:22:57\n\nrst:0x10 (RTCWDT_RTC_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)\nconfigsip: 0, SPIWP:0xee\nclk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00\nmode:DIO, clock div:1\nload:0x3fff0010,len:4\nload:0x3fff0014,len:732\nload:0x40078000,len:0\nload:0x40078000,len:11572\nentry 0x40078a14\n\nStarting WPS\nStation Mode Started\nWPS Timedout, retrying\nWPS Timedout, retrying\n```\n\n----------------------------------------\n\nTITLE: Dumping Heap Metrics in Arduino\nDESCRIPTION: Dumps heap metrics and prints them to the console, providing a snapshot of memory usage at a specific point in time.  The function returns a boolean indicating success or failure. This API is available via the `Insights.metrics` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\nbool dumpHeap();\n```\n\n----------------------------------------\n\nTITLE: Put ULong Value Arduino\nDESCRIPTION: This function stores an `unsigned long` value (uint32_t) associated with a given key in the currently open namespace. If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putULong(const char* key, uint32_t value)\n```\n\n----------------------------------------\n\nTITLE: Executing Docker Run Script (Linux/macOS)\nDESCRIPTION: This series of commands downloads and executes a shell script for running the ESP32 Arduino Lib Builder Docker image in Linux or macOS environments. It requires curl and chmod to be available.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LJO https://raw.githubusercontent.com/espressif/esp32-arduino-lib-builder/refs/heads/release/v5.1/tools/docker/run.sh\nchmod +x run.sh\n./run.sh $PWD\n```\n\n----------------------------------------\n\nTITLE: Adding Compile Definitions for USB CDC - CMake\nDESCRIPTION: Appends compile definitions related to USB CDC (Communication Device Class) for enabling serial communication over the hardware USB CDC port. ARDUINO_USB_CDC_ON_BOOT enables CDC on boot, and ARDUINO_USB_MODE sets the USB mode. These definitions are crucial for using the USB port for serial communication.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/hw_cdc_hello_world/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND compile_definitions \"ARDUINO_USB_CDC_ON_BOOT=1\")\nlist(APPEND compile_definitions \"ARDUINO_USB_MODE=1\")\n```\n\n----------------------------------------\n\nTITLE: Defining WiFi Constants\nDESCRIPTION: Defines WiFi constants as LITERAL1. These constants are likely predefined values used for configuring WiFi modes (AP, STA, AP_STA).\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/keywords.txt#_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\nWIFI_AP\tLITERAL1\nWIFI_STA\tLITERAL1\nWIFI_AP_STA\tLITERAL1\n```\n\n----------------------------------------\n\nTITLE: Setting Insights Auth Key in Arduino\nDESCRIPTION: This code snippet demonstrates how to define the authentication key required for ESP Insights in an Arduino sketch. The auth key obtained from the ESP Insights account setup must be placed between the double quotes to enable secure communication with the ESP Insights cloud service.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Insights/examples/MinimalDiagnostics/README.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nconst char insights_auth_key[] = \"<ENTER YOUR AUTH KEY>\";\n```\n\n----------------------------------------\n\nTITLE: Including IDF Project Configuration - CMake\nDESCRIPTION: Includes the standard ESP-IDF project configuration file using the `include` command. This file is located within the ESP-IDF directory, accessed through the environment variable `IDF_PATH`.  It's crucial for setting up the build environment. Requires IDF_PATH to be set.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Setting Read Callback\nDESCRIPTION: This function sets the callback function to be executed when a read request is received from the host. This callback is responsible for providing data to the host.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_msc.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nvoid onRead(msc_read_cb cb);\n```\n\n----------------------------------------\n\nTITLE: Include Arduino Wire Library (Option 1) reStructuredText\nDESCRIPTION: This snippet demonstrates the first method of including a reference to the Arduino Wire Library in reStructuredText documentation.  It uses the ```Arduino Wire Library`_`` syntax where the underscore indicates a reference. The reference target is defined elsewhere using ``_Arduino Wire Library: https://www.arduino.cc/en/reference/wire``.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/docs_contributing.rst#_snippet_7\n\nLANGUAGE: reStructuredText\nCODE:\n```\n`Arduino Wire Library`_\n\n_Arduino Wire Library: https://www.arduino.cc/en/reference/wire\n```\n\n----------------------------------------\n\nTITLE: Setting ESP-IDF Branch with Build Script in Bash\nDESCRIPTION: This command executes the `build.sh` script with the `-I` option, which sets the ESP-IDF branch to be used for compilation. Replace `<idf_branch>` with the desired branch name.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh -I <idf_branch>\n```\n\n----------------------------------------\n\nTITLE: Setting ESP_LOGx Level\nDESCRIPTION: This code snippet demonstrates how to set the desired log level for ESP_LOGx by modifying the `CONFIG_LOG_DEFAULT_LEVEL` setting in the `configs/defconfig.common` file. This allows you to control the verbosity of the log output during development and debugging. Options include NONE, ERROR, WARN, INFO, DEBUG, and VERBOSE. The default level is ERROR.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/core_debug.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nCONFIG_LOG_DEFAULT_LEVEL_NONE=y # No output\nCONFIG_LOG_DEFAULT_LEVEL_ERROR=y # Errors - default\nCONFIG_LOG_DEFAULT_LEVEL_WARN=y # Warnings\nCONFIG_LOG_DEFAULT_LEVEL_INFO=y # Info\nCONFIG_LOG_DEFAULT_LEVEL_DEBUG=y # Debug\nCONFIG_LOG_DEFAULT_LEVEL_VERBOSE=y # Verbose\n```\n\n----------------------------------------\n\nTITLE: Set Zigbee Network to Open on Reboot in Arduino\nDESCRIPTION: This code snippet shows how to configure the Zigbee network to automatically open for a specified duration after the device reboots. The `Zigbee.setRebootOpenNetwork(time)` function is used to enable this feature. The time parameter determines how long the network will remain open for new devices to join. This configuration must be set before calling `Zigbee.begin()` to initialize the Zigbee stack.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Temperature_Sensor/README.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nZigbee.setRebootOpenNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Creating Binary Image for Arduino ESP32\nDESCRIPTION: This snippet converts the ELF file into a binary image suitable for flashing onto the ESP32. It uses the `esptool_py` tool with arguments specifying the chip, flash mode, frequency, and size. It calculates the SHA256 hash offset and outputs a binary file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\nrecipe.objcopy.bin.pattern_args=--chip {build.mcu} elf2image --flash_mode \"{build.flash_mode}\" --flash_freq \"{build.img_freq}\" --flash_size \"{build.flash_size}\" --elf-sha256-offset 0xb0 -o \"{build.path}/{build.project_name}.bin\" \"{build.path}/{build.project_name}.elf\"\nrecipe.objcopy.bin.pattern=\"{tools.esptool_py.path}/{tools.esptool_py.cmd}\" {recipe.objcopy.bin.pattern_args}\n```\n\n----------------------------------------\n\nTITLE: JSON Configuration for Overriding FQBN\nDESCRIPTION: This snippet demonstrates a `ci.json` file configuration that overrides the default FQBNs for specific targets. It defines a dictionary where keys are target names, and values are lists of FQBNs. This allows compiling sketches for a target with multiple configurations, such as enabling/disabling PSRAM.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"fqbn\": {\n    \"esp32s2\": [\n      \"espressif:esp32:esp32s2:PSRAM=enabled,FlashMode=dio\",\n      \"espressif:esp32:esp32s2:PSRAM=disabled,FlashMode=dio\"\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Project Name - CMake\nDESCRIPTION: Defines the project name using CMake's `project` command.  This sets the name of the project, which is used for output file naming and other build-related tasks. No dependencies.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(arduino_managed_component_light)\n```\n\n----------------------------------------\n\nTITLE: Stopping Timer Counter - timerStop (Arduino)\nDESCRIPTION: This function stops the counter of the given timer. It pauses the timer, preserving the current count. It accepts timer struct as parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nvoid timerStop(hw_timer_t * timer);\n```\n\n----------------------------------------\n\nTITLE: SPIFFS mount failed error message\nDESCRIPTION: Example output of a SPIFFS mount failed error.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/troubleshooting.rst#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nE (588) SPIFFS: mount failed, -10025\n[E][SPIFFS.cpp:47] begin(): Mounting SPIFFS failed! Error: -1\n```\n\n----------------------------------------\n\nTITLE: Deleting Device in Arduino\nDESCRIPTION: Deletes the device created using a parameterized constructor. The device must first be removed from the node using `my_node.removeDevice(my_device)`. It returns ESP_OK on success, or an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_18\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t deleteDevice();\n```\n\n----------------------------------------\n\nTITLE: Detaching a pin from SigmaDelta - Arduino\nDESCRIPTION: This code snippet shows how to detach a pin from the SigmaDelta module and deinitialize the associated channel using the `sigmaDeltaDetach` function. It takes the GPIO pin as input.  The function returns true if detaching was successful, and false otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/sigmadelta.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nbool sigmaDeltaDetach(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: Setting Zigbee Network Open on Reboot\nDESCRIPTION: This snippet demonstrates setting the coordinator network to open after reboot using `Zigbee.setRebootOpenNetwork(time);` before calling `Zigbee.begin();`. This configuration makes it easier for end devices to rejoin the network after the coordinator restarts.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Color_Dimmable_Light/README.md#_snippet_2\n\nLANGUAGE: Arduino\nCODE:\n```\n`Zigbee.setRebootOpenNetwork(time);`\n```\n\n----------------------------------------\n\nTITLE: Inverting Logic for PDM I2S Pins - Arduino\nDESCRIPTION: This function sets the inverted logic for the clock (clk) pin when using the PDM mode. Data pins cannot be inverted. It allows for customizing the polarity of the PDM clock signal.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nvoid setInvertedPdm(bool clk)\n```\n\n----------------------------------------\n\nTITLE: Include ESP-IDF Project Tools\nDESCRIPTION: Includes the necessary CMake project tools from the ESP-IDF framework. This line utilizes the IDF_PATH environment variable to locate the ESP-IDF tools and include them in the build process. This is essential for building ESP32 projects.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/hello_world/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Bluetooth Classic Device Discovery Arduino\nDESCRIPTION: This example demonstrates how to discover Bluetooth Classic devices using the BluetoothSerial library. It scans for nearby Bluetooth devices and prints their information. The example can be found in the BluetoothSerial library examples folder.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/bluetooth.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\n#include \"BluetoothSerial.h\"\n\n#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BT_CLASSIC_ENABLED)\n#error Bluetooth Classic is not enabled! Please run `make menuconfig` to and enable it\n#endif\n\nBluetoothSerial SerialBT;\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin();\n  Serial.println(\"Starting device discovery...\");\n  SerialBT.discoverAsync([](const char* deviceName, const uint8_t* deviceAddress) {\n    Serial.print(\"Found device: \");\n    Serial.print(deviceName);\n    Serial.print(\" - \");\n    for (int i = 0; i < 6; ++i) {\n      Serial.printf(\"%02X\", deviceAddress[i]);\n      if (i < 5) Serial.print(\":\");\n    }\n    Serial.println();\n  });\n}\n\nvoid loop() {\n  delay(1000);\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Run UART Test on ESP32-C3\nDESCRIPTION: This command runs the UART test on the ESP32-C3 target board using the `tests_run.sh` script. The board must be connected to the computer.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n./.github/scripts/tests_run.sh -s uart -t esp32c3\n```\n\n----------------------------------------\n\nTITLE: Arduino Variable Declaration Example\nDESCRIPTION: This snippet demonstrates how to declare variables with inline comments explaining their purpose in an Arduino sketch.  It shows the declaration of SSID and password for WiFi FTM responder functionality and provides clarity about the purpose of the declared constants.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nconst char * WIFI_FTM_SSID = \"WiFi_FTM_Responder\"; // SSID of AP that has FTM Enabled\nconst char * WIFI_FTM_PASS = \"ftm_responder\"; // STA Password\n```\n\n----------------------------------------\n\nTITLE: Restarting Timer Counter - timerRestart (Arduino)\nDESCRIPTION: This function restarts the counter of the given timer. It resets the counter to its initial value and restarts the counting process. It accepts timer struct as parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nvoid timerRestart(hw_timer_t * timer);\n```\n\n----------------------------------------\n\nTITLE: Erasing NVS Flash Partition in Arduino\nDESCRIPTION: This code snippet demonstrates how to completely erase and reformat the NVS memory used by the Preferences library. It uses the `nvs_flash_erase()` and `nvs_flash_init()` functions. This is an advanced item, and a new sketch should be uploaded immediately after running this to avoid reformatting on every boot.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_19\n\nLANGUAGE: arduino\nCODE:\n```\n   #include <nvs_flash.h>\n\n   void setup() {\n\n       nvs_flash_erase();      // erase the NVS partition and...\n       nvs_flash_init();       // initialize the NVS partition.\n       while (true);\n\n   }\n\n   void loop() {\n      ;\n   }\n```\n\n----------------------------------------\n\nTITLE: Compiling C++ Files for Arduino ESP32\nDESCRIPTION: This snippet defines the recipe for compiling C++ source files using the specified compiler and flags. Similar to C compilation, it includes definitions for various board configurations and preprocesses the source before compilation, outputting an object file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nrecipe.cpp.o.pattern=\"{compiler.path}{compiler.cpp.cmd}\" {compiler.cpp.extra_flags} {compiler.cpp.flags} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=\"{build.board}\" -DARDUINO_VARIANT=\"{build.variant}\" -DARDUINO_PARTITION_{build.partitions} {build.extra_flags} {compiler.cpreprocessor.flags} {includes} \"@{build.opt.path}\" \"@{file_opts.path}\" \"{source_file}\" -o \"{object_file}\"\n```\n\n----------------------------------------\n\nTITLE: Navigating to the Library Builder Directory in Bash\nDESCRIPTION: This command changes the current directory to the `esp32-arduino-lib-builder` folder. This step is necessary to execute the build script.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd esp32-arduino-lib-builder\n```\n\n----------------------------------------\n\nTITLE: 4MB No OTA Partition Table Example\nDESCRIPTION: This code snippet shows an example of a partition table configuration for a 4MB flash without OTA support. It defines partitions for NVS and a factory application.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/partition_table.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n# Name,   Type, SubType, Offset,  Size, Flags\nnvs,      data, nvs,     36K,     20K,\nfactory,  app,  factory, 64K,     4000K,\n```\n\n----------------------------------------\n\nTITLE: Setting USB Class - Arduino\nDESCRIPTION: This code snippet demonstrates how to set the USB class using the `usbClass` function. The USB class defines the type of device, such as a mass storage device or a human interface device. It takes an 8-bit unsigned integer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\nbool usbClass(uint8_t _class);\n```\n\n----------------------------------------\n\nTITLE: Setting LED GPIO Pin\nDESCRIPTION: This step involves setting the LED GPIO pin by modifying the `LED_PIN` definition within the Arduino sketch. The default LED_PIN is `RGB_BUILTIN`, but it can be changed to a different GPIO pin based on the hardware setup.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Dimmable_Light/README.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Open Zigbee Network After Reboot (Arduino)\nDESCRIPTION: This snippet shows how to set the `Zigbee.setRebootOpenNetwork(time);` function to open the network after rebooting by setting it before calling `Zigbee.begin();`. This ensures that the Zigbee network is open for new devices to join after a reboot of the coordinator.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Range_Extender/README.md#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.setRebootOpenNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Unregistering All Variables in Arduino\nDESCRIPTION: Unregisters all previously registered variables. The function returns a boolean indicating success or failure. This API is available via the `Insights.variables` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_14\n\nLANGUAGE: arduino\nCODE:\n```\nbool unregisterAll();\n```\n\n----------------------------------------\n\nTITLE: Setting Product ID - Arduino\nDESCRIPTION: This code snippet shows how to set the Product ID (PID) for the USB device using the `PID` function. The PID is a 16-bit identifier that identifies the specific product. It takes a 16-bit unsigned integer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nbool PID(uint16_t p);\n```\n\n----------------------------------------\n\nTITLE: Using putBytes, getBytes, and getBytesLength - Arduino\nDESCRIPTION: These methods allow storing and retrieving variable-length byte arrays (blobs) in the Preferences namespace.  `putBytes` stores the data, `getBytes` retrieves it, and `getBytesLength` provides the size of the stored data.  Data types are not preserved and are treated as a series of uint8_t bytes.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_15\n\nLANGUAGE: arduino\nCODE:\n```\nputBytes(\"myBytesKey\", value, valueLen)\ngetBytes(\"myBytesKey\", buffer, valueLen)\ngetBytesLength(\"myBytesKey\")\n```\n\n----------------------------------------\n\nTITLE: Manual Installation of Arduino framework (Bash)\nDESCRIPTION: These commands manually install the Arduino framework as an ESP-IDF component.  It involves creating a 'components' directory, cloning the Arduino ESP32 repository, initializing submodules, and configuring the project using menuconfig.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p components && \\\ncd components && \\\ngit clone https://github.com/espressif/arduino-esp32.git arduino && \\\ncd arduino && \\\ngit submodule update --init --recursive && \\\ncd ../.. && \\\nidf.py menuconfig\n```\n\n----------------------------------------\n\nTITLE: Arduino Inline Comment Example\nDESCRIPTION: This snippet illustrates the use of inline comments within Arduino code for the ESP32.  It shows how to explain complex algorithms or specific configurations that users may need to modify. Clear comments are crucial for understanding and effectively using the example.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\n// Number of FTM frames requested in terms of 4 or 8 bursts (allowed values - 0 (No pref), 16, 24, 32, 64)\n```\n\n----------------------------------------\n\nTITLE: Configuring I2S RX - Arduino\nDESCRIPTION: This function configures the I2S RX (receive) channel. It sets the sampling rate, data bit width, slot mode, and transform mode. It returns true on success and false on failure. This function allows dynamic adjustment of RX channel parameters during operation, and also enables transforming received data.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\nbool configureRX(uint32_t rate, i2s_data_bit_width_t bits_cfg, i2s_slot_mode_t ch, i2s_rx_transform_t transform=I2S_RX_TRANSFORM_NONE)\n```\n\n----------------------------------------\n\nTITLE: Checking Key Existence in Arduino Preferences\nDESCRIPTION: This snippet shows how to check if a key exists within the currently open namespace using the `isKey()` method.  It takes the key name as an argument (\"myTestKey\") and returns `true` if the key exists, `false` otherwise. This is commonly used to determine if the namespace has been initialized during a previous run.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nisKey(\"myTestKey\")\n```\n\n----------------------------------------\n\nTITLE: Include Arduino Wire Library (Option 2) reStructuredText\nDESCRIPTION: This snippet demonstrates an alternative method of including a reference to the Arduino Wire Library in reStructuredText documentation. It directly embeds the URL within the reference using ```Arduino Wire Library <https://www.arduino.cc/en/reference/wire>`_``.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/docs_contributing.rst#_snippet_8\n\nLANGUAGE: reStructuredText\nCODE:\n```\n`Arduino Wire Library <https://www.arduino.cc/en/reference/wire>`_\n```\n\n----------------------------------------\n\nTITLE: Cloning a new Arduino library (Bash)\nDESCRIPTION: This command clones a new Arduino library into the components/arduino/libraries directory of the esp-idf project.  This assumes you are adding the library as a global library to the Arduino component.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/esp/esp-idf/components/arduino/\ngit clone --recursive git@github.com:Author/new_library.git libraries/new_library\n```\n\n----------------------------------------\n\nTITLE: Get TX Slot Mode (Arduino)\nDESCRIPTION: This snippet shows how to retrieve the transmit (TX) slot mode using the `txSlotMode()` method of the I2SClass. The slot mode indicates whether the audio is stereo or mono. No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\ni2s_slot_mode_t txSlotMode()\n```\n\n----------------------------------------\n\nTITLE: WiFi Scan Output\nDESCRIPTION: This code snippet represents the example output after a Wi-Fi scan. It shows the list of available networks along with their SSID, RSSI, channel, and encryption type.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WiFiScanAsync/README.md#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nSetup done\nScan start\nLoop running...\nLoop running...\nLoop running...\nLoop running...\nLoop running...\nLoop running...\nLoop running...\nLoop running...\nLoop running...\n\nScan done\n17 networks found\nNr | SSID            | RSSI | CH | Encryption\n 1 | IoTNetwork      |  -62 |  1 | WPA2\n 2 | WiFiSSID        |  -62 |  1 | WPA2-EAP\n 3 | B3A7992         |  -63 |  6 | WPA+WPA2\n 4 | WiFi            |  -63 |  6 | WPA3\n 5 | IoTNetwork2     |  -64 | 11 | WPA2+WPA3\n...\n```\n\n----------------------------------------\n\nTITLE: De-initializing USB MSC\nDESCRIPTION: This function de-initializes the USB MSC peripheral, releasing all allocated resources. After calling `end`, the `begin` function must be called again to re-initialize the USB MSC driver. It effectively disconnects the device as a mass storage device.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_msc.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nvoid end();\n```\n\n----------------------------------------\n\nTITLE: Alternative Arduino Installation - Bash\nDESCRIPTION: This script provides an alternative installation location for Arduino if the standard location (~/) is not suitable. It creates the necessary directories, clones the Arduino-ESP32 repository, and runs the get.py script to download additional tools.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/installing.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/Arduino/hardware\nmkdir -p espressif && \\\ncd espressif && \\\ngit clone https://github.com/espressif/arduino-esp32.git esp32 && \\\ncd esp32/tools && \\\npython3 get.py\n```\n\n----------------------------------------\n\nTITLE: Requesting Data with Address and Stop - Arduino\nDESCRIPTION: Requests data from a slave device, specifying the address, size, and whether to send a stop signal. Returns the number of bytes read.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_18\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t requestFrom(uint16_t address, uint8_t size, bool sendStop)\n```\n\n----------------------------------------\n\nTITLE: ESP-IDF Partition Table CSV Format\nDESCRIPTION: This code snippet shows the structure of a partition table defined in a CSV file for ESP-IDF. The CSV file defines the name, type, subtype, offset, size, and flags for each partition.  The file is used to define the flash memory organization.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/partition_table.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n# ESP-IDF Partition Table\n# Name, Type, SubType, Offset, Size, Flags\n```\n\n----------------------------------------\n\nTITLE: Opening Zigbee Network on Reboot\nDESCRIPTION: This snippet shows how to configure the Zigbee coordinator to automatically open the network after a reboot.  Setting a time value (in seconds) allows new devices to join the network for a specified duration immediately after the coordinator restarts. This must be set before calling `Zigbee.begin();`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_On_Off_Light/README.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nZigbee.setRebootOpenNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Setting Specific USB Event Callback - Arduino\nDESCRIPTION: This code snippet shows how to set a callback function for a specific USB event using the `onEvent` function, specifying both the event type and the callback. This allows the application to handle different USB events with different callback functions, providing finer-grained control over USB event handling.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nvoid onEvent(arduino_usb_event_t event, esp_event_handler_t callback);\n```\n\n----------------------------------------\n\nTITLE: Check Data Availability on I2S Interface (Arduino)\nDESCRIPTION: This snippet shows how to check if data is available to be read from the I2S interface using the `available()` method. It returns `I2S_READ_CHUNK_SIZE` if data is available, or -1 if not. No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_21\n\nLANGUAGE: arduino\nCODE:\n```\nint available()\n```\n\n----------------------------------------\n\nTITLE: Reading Timer Counter Value in Seconds - timerReadSeconds (Arduino)\nDESCRIPTION: This function reads the current counter value of the timer in seconds. It provides a convenient way to get time elapsed in seconds. It accepts timer struct as parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\ndouble timerReadSeconds(hw_timer_t * timer);\n```\n\n----------------------------------------\n\nTITLE: Define Constants for Ultrasound\nDESCRIPTION: This section defines the constants used in the Ultrasound component, categorizing them as LITERAL1 for syntax highlighting. These constants relate to TCP/IP adapter interfaces.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/AsyncUDP/keywords.txt#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nTCPIP_ADAPTER_IF_STA\tLITERAL1\nTCPIP_ADAPTER_IF_STA\tLITERAL1\nTCPIP_ADAPTER_IF_AP\tLITERAL1\nTCPIP_ADAPTER_IF_ETH\tLITERAL1\nTCPIP_ADAPTER_IF_PPP\tLITERAL1\n```\n\n----------------------------------------\n\nTITLE: Setting Touch Sensor Cycles with touchSetCycles in Arduino\nDESCRIPTION: This function sets the measurement and sleep cycles for the touch sensor.  The touchRead result, threshold and detection accuracy depends on these values.  The defaults are setting touchRead to take ~0.5 ms.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/touch.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nvoid touchSetCycles(uint16_t measure, uint16_t sleep);\n```\n\n----------------------------------------\n\nTITLE: Setting Vendor ID - Arduino\nDESCRIPTION: This code snippet shows how to set the Vendor ID (VID) for the USB device using the `VID` function. The VID is a 16-bit identifier that identifies the company that develops the product.  It takes a 16-bit unsigned integer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nbool VID(uint16_t v);\n```\n\n----------------------------------------\n\nTITLE: WiFi Scan Example Log Output\nDESCRIPTION: This code snippet shows the expected output of the WiFi scan example, displaying discovered networks with their SSID, RSSI, channel, and encryption type. It demonstrates how the program presents the scan results to the user. This is example output and not actual code.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WiFiScan/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nSetup done\nScan start\nScan done\n17 networks found\nNr | SSID            | RSSI | CH | Encryption\n 1 | IoTNetwork      |  -62 |  1 | WPA2\n 2 | WiFiSSID        |  -62 |  1 | WPA2-EAP\n 3 | B3A7992         |  -63 |  6 | WPA+WPA2\n 4 | WiFi            |  -63 |  6 | WPA3\n 5 | IoTNetwork2     |  -64 | 11 | WPA2+WPA3\n...\n```\n\n----------------------------------------\n\nTITLE: Reading Calibrated Analog Value Using analogReadMilliVolts (Arduino)\nDESCRIPTION: This snippet demonstrates using the `analogReadMilliVolts` function to get the calibrated ADC value in millivolts for a specified pin on an ESP32.  It receives a GPIO pin number and returns the calibrated analog reading in millivolts. This function provides a convenient way to obtain voltage readings directly.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nuint32_t analogReadMilliVolts(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: BLE Scanning with Arduino\nDESCRIPTION: This Arduino sketch demonstrates how to scan for nearby BLE devices using the ESP32's built-in BLE capabilities. It utilizes the `BLEDevice` and `BLEScan` classes from the ArduinoBLE library to initiate a scan and print the discovered device addresses and RSSI values to the serial monitor.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ble.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\n``````{literalinclude}:: ../../../libraries/BLE/examples/Scan/Scan.ino\n    :language: arduino``````\n```\n\n----------------------------------------\n\nTITLE: Fedora Installation - Bash\nDESCRIPTION: This script installs the necessary dependencies for Arduino-ESP32 on Fedora systems. It updates the user's dialout group, installs Git, Python3-pip, and Python3-pyserial, clones the Arduino-ESP32 repository, and runs the get.py script to download additional tools.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/installing.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo usermod -a -G dialout $USER && \\\nsudo dnf install git python3-pip python3-pyserial && \\\nmkdir -p ~/Arduino/hardware/espressif && \\\ncd ~/Arduino/hardware/espressif && \\\ngit clone https://github.com/espressif/arduino-esp32.git esp32 && \\\ncd esp32/tools && \\\npython get.py\n```\n\n----------------------------------------\n\nTITLE: Setting USB Power - Arduino\nDESCRIPTION: This code snippet demonstrates how to set the USB power configuration using the `usbPower` function. This configuration indicates the amount of current (in mA) that the USB device will draw. It takes a 16-bit unsigned integer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\nbool usbPower(uint16_t mA);\n```\n\n----------------------------------------\n\nTITLE: Registering RESTful Service Function (handleList)\nDESCRIPTION: Registers the `handleList` function to handle incoming GET requests for the `/api/list` URL. This function retrieves a list of files in the file system and returns it as a JSON object containing the name, size, and last modification timestamp of each file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/WebServer/README.md#_snippet_1\n\nLANGUAGE: CPP\nCODE:\n```\nserver.on(\"/api/sysinfo\", handleList);\n```\n\n----------------------------------------\n\nTITLE: Using ESP-IDF app_main() in main.cpp (C++)\nDESCRIPTION: This code snippet shows how to use the ESP-IDF app_main() function instead of setup() and loop(). It includes Arduino.h, initializes Arduino using initArduino(), and implements an infinite loop within app_main().\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n//file: main.cpp\n#include \"Arduino.h\"\n\nextern \"C\" void app_main()\n{\n  initArduino();\n\n  // Arduino-like setup()\n  Serial.begin(115200);\n  while(!Serial){\n    ; // wait for serial port to connect\n  }\n\n  // Arduino-like loop()\n  while(true){\n    Serial.println(\"loop\");\n  }\n\n  // WARNING: if program reaches end of function app_main() the MCU will restart.\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Parameter to a Device (addParam)\nDESCRIPTION: This function adds a custom parameter to a device using a `Param` object. The `Param` object encapsulates the parameter's name, type, default value, and properties.  It returns an `esp_err_t` indicating success or failure. The `Param` class provides APIs to create custom parameters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_22\n\nLANGUAGE: C\nCODE:\n```\nesp_err_t addParam(Param parameter);\n```\n\n----------------------------------------\n\nTITLE: BLE UART Service with Arduino\nDESCRIPTION: This Arduino sketch implements a BLE UART service, enabling bidirectional communication between an ESP32 and a BLE-enabled device. It defines a custom service UUID and characteristic UUID for sending and receiving data. The example uses the ArduinoBLE library to create and manage the BLE connection, service, and characteristics.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ble.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\n``````{literalinclude}:: ../../../libraries/BLE/examples/UART/UART.ino\n    :language: arduino``````\n```\n\n----------------------------------------\n\nTITLE: Compiling Assembly Files for Arduino ESP32\nDESCRIPTION: This snippet defines the recipe for compiling assembly (S) source files. It uses the C compiler command with specific flags tailored for assembly files.  It generates an object file from the assembly source.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\nrecipe.S.o.pattern=\"{compiler.path}{compiler.c.cmd}\" {compiler.S.extra_flags} {compiler.S.flags} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=\"{build.board}\" -DARDUINO_VARIANT=\"{build.variant}\" -DARDUINO_PARTITION_{build.partitions} {build.extra_flags} {compiler.cpreprocessor.flags} {includes} \"@{build.opt.path}\" \"@{file_opts.path}\" \"{source_file}\" -o \"{object_file}\"\n```\n\n----------------------------------------\n\nTITLE: 8MB With OTA and Storage Partition Table Example\nDESCRIPTION: This code snippet shows an example of a partition table configuration for an 8MB flash with both OTA support and storage. It defines partitions for NVS, OTA data, two application partitions for OTA updates (app0, app1), and a SPIFFS partition for file storage.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/partition_table.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n# Name,   Type, SubType, Offset,  Size, Flags\nnvs,      data, nvs,     36K,     20K,\notadata,  data, ota,     56K,     8K,\napp0,     app,  ota_0,   64K,     2M,\napp1,     app,  ota_1,   ,        2M,\nspiffs,   data, spiffs,  ,        3M,\n```\n\n----------------------------------------\n\nTITLE: Building Arduino Libraries\nDESCRIPTION: These commands build the Arduino libraries after configuring the log level. The first builds for all SoCs, while the second builds for a specific SoC.  The `-t` flag specifies the target SoC. If a debug configuration file `configs/defconfig.debug` is used, then the debug flag needs to be passed.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/core_debug.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh\n```\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh -t <soc>\n```\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh debug\n```\n\n----------------------------------------\n\nTITLE: WiFi Begin with parameters - Arduino\nDESCRIPTION: This function configures and starts the Wi-Fi connection with several parameters. It allows setting the SSID, passphrase, channel, BSSID, and auto-connect option for the Wi-Fi connection. A successful configuration will return a `wl_status_t`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_26\n\nLANGUAGE: arduino\nCODE:\n```\nwl_status_t begin(const char* ssid, const char *passphrase = NULL, int32_t channel = 0, const uint8_t* bssid = NULL, bool connect = true);\n```\n\nLANGUAGE: arduino\nCODE:\n```\nwl_status_t begin(char* ssid, char *passphrase = NULL, int32_t channel = 0, const uint8_t* bssid = NULL, bool connect = true);\n```\n\n----------------------------------------\n\nTITLE: Adding Component Dependencies - CMake\nDESCRIPTION: This snippet defines a function `maybe_add_component` that conditionally adds a dependency on another component. It checks if the component is included in the build and, if so, links the component's library to the current component's library.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(maybe_add_component component_name)\n    idf_build_get_property(components BUILD_COMPONENTS)\n    if (${component_name} IN_LIST components)\n        idf_component_get_property(lib_name ${component_name} COMPONENT_LIB)\n        target_link_libraries(${COMPONENT_LIB} PUBLIC ${lib_name})\n    endif()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Adding Device to Node - C++\nDESCRIPTION: This snippet shows how to add a device to the node.  It takes a Device object as input and returns ESP_OK on success and an error code on failure.  A single node can have multiple devices, but each device name must be unique.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nesp_err_t addDevice(Device device);\n```\n\n----------------------------------------\n\nTITLE: Adding Device Attribute in Arduino\nDESCRIPTION: Adds an attribute to the device. Device attributes are reported only once after a boot-up as part of the node configuration (e.g., Serial Number).  It takes the attribute name and value as input. Returns ESP_OK on success, or an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_17\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t addDeviceAttr(const char *attr_name, const char *val);\n```\n\n----------------------------------------\n\nTITLE: Setting USB Protocol - Arduino\nDESCRIPTION: This code snippet demonstrates how to set the USB protocol using the `usbProtocol` function. The protocol defines the specific communication method used within a USB class and sub-class. It takes an 8-bit unsigned integer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_16\n\nLANGUAGE: arduino\nCODE:\n```\nbool usbProtocol(uint8_t protocol);\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with CMake\nDESCRIPTION: This snippet registers an ESP-IDF component using the `idf_component_register` function in CMake. It specifies `main.cpp` as the source file and the current directory (`.`) as an include directory.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/hello_world/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"main.cpp\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Preferences Namespace Switching in Arduino\nDESCRIPTION: This code snippet demonstrates how to switch between different namespaces within the Preferences library. It shows how to open and close namespaces using the `begin()` and `end()` methods. Only one namespace can be active at a time.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_17\n\nLANGUAGE: arduino\nCODE:\n```\n   Preferences currentNamespace;\n\n      currentNamespace.begin(\"myNamespace\", false);\n         // do stuff...\n\n      currentNamespace.end();                              // closes 'myNamespace'\n\n      currentNamespace.begin(\"myOtherNamespace\", false);   // opens a different Preferences namespace.\n         // do other stuff...\n\n      currentNamespace.end();                              // closes 'myOtherNamespace'\n```\n\n----------------------------------------\n\nTITLE: Build Test Binary\nDESCRIPTION: This script builds the test binary for a specific test name and target board. It compiles the Arduino sketch associated with the specified test using the `arduino-cli` tool.  The `<test_name>` and `<target>` parameters should be replaced with the actual test name and target board, respectively.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n./.github/scripts/tests_build.sh -s <test_name> -t <target>\n```\n\n----------------------------------------\n\nTITLE: Starting LEDC Fade with Interrupt - Arduino\nDESCRIPTION: Sets up and starts a fade effect for a LEDC pin with an interrupt. It accepts the pin number, starting duty, target duty, maximum fade time in milliseconds, and a function to be called when the interrupt is triggered as input and returns a boolean indicating success.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_14\n\nLANGUAGE: arduino\nCODE:\n```\nbool ledcFadeWithInterrupt(uint8_t pin, uint32_t start_duty, uint32_t target_duty, int max_fade_time_ms, void (*userFunc)(void));\n```\n\n----------------------------------------\n\nTITLE: Defining SPI Methods and Functions Keywords for Syntax Coloring\nDESCRIPTION: This snippet defines various SPI methods and functions as keywords for syntax coloring. This enables the IDE or text editor to highlight functions like 'begin', 'end', 'transfer', 'setBitOrder', 'setDataMode', and 'setClockDivider', enhancing code readability and making it easier to identify SPI-related function calls.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/SPI/keywords.txt#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nbegin\tKEYWORD2\nend\tKEYWORD2\ntransfer\tKEYWORD2\nsetBitOrder\tKEYWORD2\nsetDataMode\tKEYWORD2\nsetClockDivider\tKEYWORD2\n```\n\n----------------------------------------\n\nTITLE: Setting Firmware Version - Arduino\nDESCRIPTION: This code snippet shows how to set the firmware version for the USB device using the `firmwareVersion` function. This version is a 16-bit unsigned value. It takes a 16-bit unsigned integer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nbool firmwareVersion(uint16_t version);\n```\n\n----------------------------------------\n\nTITLE: Get SoftAP IPv6 Address - Arduino\nDESCRIPTION: This function retrieves the IPv6 address of the ESP32 access point (AP). It returns the AP's IPv6 address in the IPAddress format, allowing you to identify and manage the AP's network presence.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_17\n\nLANGUAGE: arduino\nCODE:\n```\nIPAddress softAPlinkLocalIPv6();\n```\n\n----------------------------------------\n\nTITLE: Include Image in Documentation reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an image in the documentation using reStructuredText. The ``.. figure::`` directive is used to insert an image with options for alignment, width, and figure class. The image file must be located in the ``_static`` folder.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/docs_contributing.rst#_snippet_9\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. figure:: ../../_static/arduino_i2c_master.png\n    :align: center\n    :width: 720\n    :figclass: align-center\n```\n\n----------------------------------------\n\nTITLE: ESP Insights Node ID Log Example\nDESCRIPTION: This log output shows the Node ID generated for the ESP Insights-enabled device. The Node ID is crucial for identifying and monitoring the specific device on the ESP Insights Dashboard. This ID is unique to each device and essential for filtering and analyzing device-specific diagnostic data.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Insights/examples/MinimalDiagnostics/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nI (4161) esp_insights: =========================================\nI (4171) esp_insights: Insights enabled for Node ID 246F2880371C\nI (4181) esp_insights: =========================================\n```\n\n----------------------------------------\n\nTITLE: Setting Product Name - Arduino\nDESCRIPTION: This code snippet demonstrates how to set the product name for the USB device using the `productName` function. The product name is a string that identifies the device. It takes a constant character pointer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_22\n\nLANGUAGE: arduino\nCODE:\n```\nbool productName(const char * name);\n```\n\n----------------------------------------\n\nTITLE: Setting Python Partition Generation Command\nDESCRIPTION: Defines the command to generate partition files using Python. It specifies where the gen_esp32part.py is and the correct command line arguments.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_10\n\nLANGUAGE: properties\nCODE:\n```\ntools.gen_esp32part.cmd=python3 \"{runtime.platform.path}/tools/gen_esp32part.py\"\ntools.gen_esp32part.cmd.windows=\"{runtime.platform.path}\\tools\\gen_esp32part.exe\"\n```\n\n----------------------------------------\n\nTITLE: Arduino Code Target Limitation Comment\nDESCRIPTION: This snippet presents an inline comment for Arduino code, informing users that a feature is not available on a specific target due to hardware limitations. This helps users understand why certain examples might not work on all ESP32 variants.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\n/*\n  THIS FEATURE REQUIRES WI-FI SUPPORT AND IS NOT AVAILABLE FOR ESP32-S2 AS IT DOES NOT HAVE ENOUGH RAM.\n*/\n```\n\n----------------------------------------\n\nTITLE: Initializing ESP Insights Agent in Arduino\nDESCRIPTION: Initializes the ESP Insights agent with an authentication key and optional node ID, log type, and external RAM allocation. The function returns a boolean indicating success or failure. It depends on the Insights library.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nbool begin(const char *auth_key, const char *node_id = NULL, uint32_t log_type = 0xFFFFFFFF, bool alloc_ext_ram = false);\n```\n\n----------------------------------------\n\nTITLE: Setting Width for ADC Continuous Mode Using analogContinuousSetWidth (Arduino)\nDESCRIPTION: This snippet shows how to set the hardware resolution bits for ADC continuous mode using `analogContinuousSetWidth`.  It takes the number of bits as input. This function only works for ESP32, where the range is 9-12 bits.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\nvoid analogContinuousSetWidth(uint8_t bits);\n```\n\n----------------------------------------\n\nTITLE: Removing Specific Key-Value Pair - Arduino\nDESCRIPTION: This code snippet removes a specific key-value pair from the currently opened namespace using the `remove()` method. The namespace must be open in read-write mode for this to work.  This can be useful for forcing a \"factory reset\" on the next reboot.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\npreferences.remove(\"keyname\");\n```\n\n----------------------------------------\n\nTITLE: Clearing All Key-Value Pairs in Namespace - Arduino\nDESCRIPTION: This code snippet demonstrates how to clear all key-value pairs within the currently opened namespace using the `clear()` method.  The namespace must be opened in read-write mode for this operation to succeed. The namespace itself will still exist after this operation.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\npreferences.clear();\n```\n\n----------------------------------------\n\nTITLE: Combining Objects & Archives for Arduino ESP32\nDESCRIPTION: This snippet defines the recipe for combining object files and archives using the ELF compiler.  It links the object files, libraries and archives to create an ELF file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\nrecipe.c.combine.pattern=\"{compiler.path}{compiler.c.elf.cmd}\" {compiler.c.elf.flags} {compiler.c.elf.extra_flags} -Wl,--start-group {object_files} \"{archive_file_path}\" {build.extra_libs} {build.zigbee_libs} {compiler.c.elf.libs} {compiler.libraries.ldflags} -Wl,--end-group -Wl,-EL -o \"{build.path}/{build.project_name}.elf\"\n```\n\n----------------------------------------\n\nTITLE: Attach Interrupt with Argument to GPIO - Arduino\nDESCRIPTION: Attaches an interrupt to a specified GPIO pin, passing an argument to the handler function. The `attachInterruptArg` function allows passing custom data to the interrupt handler.  It requires the pin number, the handler function, a pointer to the argument, and the interrupt mode as input.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/gpio.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nattachInterruptArg(uint8_t pin, voidFuncPtrArg handler, void * arg, int mode);\n```\n\n----------------------------------------\n\nTITLE: Registering the IDF Component - CMake\nDESCRIPTION: This line registers the component with the ESP-IDF build system using the `idf_component_register` function. It specifies include directories, private include directories, source files, required components, and private required components for the build.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(INCLUDE_DIRS ${includedirs} PRIV_INCLUDE_DIRS ${priv_includes} SRCS ${srcs} REQUIRES ${requires} PRIV_REQUIRES ${priv_requires})\n```\n\n----------------------------------------\n\nTITLE: SD MMC Test Example - Arduino\nDESCRIPTION: This Arduino example demonstrates basic SD MMC functionality. It requires the SD_MMC library. The code interacts with an SD card connected via the SDMMC interface. It reads and writes data to the SD card, printing the results to the serial monitor.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/sdmmc.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\n../../../libraries/SD_MMC/examples/SDMMC_Test/SDMMC_Test.ino\n```\n\n----------------------------------------\n\nTITLE: Get TX Channel Handler Pointer (Arduino)\nDESCRIPTION: This snippet shows how to obtain the transmit (TX) channel handler pointer using the `txChan()` method of the I2SClass. This pointer can be used to directly manipulate the I2S TX channel. No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\ni2s_chan_handle_t txChan()\n```\n\n----------------------------------------\n\nTITLE: Disabling DAC Output on a Pin (dacDisable) - Arduino\nDESCRIPTION: The `dacDisable` function disables the DAC output on a specified GPIO pin. It accepts the pin number as input and turns off the DAC output on that pin. No output voltage will be generated on the specified pin after calling this function.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/dac.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nvoid dacDisable(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: Getting AP Subnet Mask\nDESCRIPTION: Gets the subnet mask of the softAP.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_15\n\nLANGUAGE: arduino\nCODE:\n```\nIPAddress softAPSubnetMask();\n```\n\n----------------------------------------\n\nTITLE: Setting ESP-IDF Commit with Build Script in Bash\nDESCRIPTION: This command executes the `build.sh` script with the `-i` option, which sets the ESP-IDF commit to be used for compilation. Replace `<idf_commit>` with the desired commit hash.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh -i <idf_commit>\n```\n\n----------------------------------------\n\nTITLE: Attaching SigmaDelta channel to a pin - Arduino\nDESCRIPTION: This code snippet shows how to attach a SigmaDelta channel to a specific GPIO pin with a given frequency. It utilizes the `sigmaDeltaAttach` function. The function returns true if the configuration was successful, and false otherwise. Frequency range is 1-14 bits for most ESP32 variants and 1-20 bits for ESP32.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/sigmadelta.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nbool sigmaDeltaAttach(uint8_t pin, uint32_t freq);\n```\n\n----------------------------------------\n\nTITLE: Setting USB Attributes - Arduino\nDESCRIPTION: This code snippet demonstrates how to set the USB attributes using the `usbAttributes` function. USB attributes define specific characteristics of the USB device's configuration. It takes an 8-bit unsigned integer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_18\n\nLANGUAGE: arduino\nCODE:\n```\nbool usbAttributes(uint8_t attr);\n```\n\n----------------------------------------\n\nTITLE: Default UUID for BLE Provisioning\nDESCRIPTION: This snippet shows the default UUID used during BLE provisioning if a custom UUID is not provided. This UUID is a 128-bit value represented as an array of bytes.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFiProv/examples/WiFiProv/README.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n{ 0xb4, 0xdf, 0x5a, 0x1c, 0x3f, 0x6b, 0xf4, 0xbf, 0xea, 0x4a, 0x82, 0x03, 0x04, 0x90, 0x1a, 0x02 }\n```\n\n----------------------------------------\n\nTITLE: Install Sphinx and Requirements\nDESCRIPTION: This code snippet shows how to install Sphinx and other required packages using pip.  Sphinx is used to generate documentation from reStructuredText files. The requirements.txt file lists the other dependencies needed to build the documentation.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/docs_contributing.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -U Sphinx\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: esp_ota Network Upload Configuration (Arduino IDE 2.x)\nDESCRIPTION: This configuration defines parameters for uploading sketches via OTA using a network connection for Arduino IDE 2.x. It uses a specific command and includes options for specifying the IP address, port, and password. It also defines a secret password field.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_33\n\nLANGUAGE: properties\nCODE:\n```\ntools.esp_ota.upload.protocol=network\ntools.esp_ota.upload.field.password=Password\ntools.esp_ota.upload.field.password.secret=true\ntools.esp_ota.upload.pattern={cmd} -i {upload.port.address} -p {upload.port.properties.port} \"--auth={upload.field.password}\" -f \"{build.path}/{build.project_name}.bin\"\n```\n\n----------------------------------------\n\nTITLE: Getting Number of Connected Stations to AP\nDESCRIPTION: Returns the number of clients (stations) currently connected to the Wi-Fi Access Point (AP).\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t softAPgetStationNum();\n```\n\n----------------------------------------\n\nTITLE: Assigning Primary Parameter in Arduino\nDESCRIPTION: Assigns an existing parameter (added via addXParam or addParam) as the primary parameter for the device. Takes a pointer to the parameter handle as input, obtained using `my_device.getParamByName()`. Returns ESP_OK on success, or an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_20\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t assignPrimaryParam(param_handle_t *param);\n```\n\n----------------------------------------\n\nTITLE: Adding UI Type to Parameter in Arduino\nDESCRIPTION: Adds a UI type to the parameter, influencing how it's rendered in client applications. It takes the UI type string as input (e.g., ESP_RMAKER_UI_TOGGLE, ESP_RMAKER_UI_SLIDER). Returns ESP_OK on success, or an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_26\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t addUIType(const char *ui_type);\n```\n\n----------------------------------------\n\nTITLE: Setting TX Timeout - Arduino\nDESCRIPTION: Defines the timeout duration (in milliseconds) for transmit (TX) operations. This timeout determines how long the system will wait for a successful transmission before considering it a failure. The timeout value is passed as an uint32_t.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nvoid setTxTimeoutMs(uint32_t timeout);\n```\n\n----------------------------------------\n\nTITLE: Put Long64 Value Arduino\nDESCRIPTION: This function stores a `long long` or `int64_t` value associated with a given key in the currently open namespace. If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_15\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putLong64(const char* key, int64_t value)\n```\n\n----------------------------------------\n\nTITLE: Writing Timer Counter Value - timerWrite (Arduino)\nDESCRIPTION: This function sets the counter value of the given timer. It allows direct manipulation of the current count. The function takes the timer structure and the counter value to be set as parameters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nvoid timerWrite(hw_timer_t * timer, uint64_t val);\n```\n\n----------------------------------------\n\nTITLE: Cloning TinyUSB and ESP32-arduino-lib-builder (Bash)\nDESCRIPTION: These commands clone the esp32-arduino-lib-builder and TinyUSB repositories. These are needed to use USBHID classes on ESP32-S2 or ESP32-S3. This snippet must be executed before including the builder in the CMakeLists.txt file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/espressif/esp32-arduino-lib-builder.git esp32-arduino-lib-builder && \\\ngit clone https://github.com/hathach/tinyusb.git esp32-arduino-lib-builder/components/arduino_tinyusb/tinyusb\n```\n\n----------------------------------------\n\nTITLE: Initializing GPIO Pin as Output in Arduino\nDESCRIPTION: This code snippet demonstrates how to initialize a digital pin as an output in the Arduino environment. It uses the `pinMode()` function to set the specified pin (in this case, pin 4) to the `OUTPUT` mode, enabling it to be used for controlling external devices like LEDs.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/ESP32/examples/Template/ExampleTemplate/README.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n// initialize digital pin 4 as an output.\npinMode(4, OUTPUT);\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Factory Reset in Arduino\nDESCRIPTION: Resets the device to factory defaults. It takes the number of seconds after which the chip should reboot as input.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_30\n\nLANGUAGE: arduino\nCODE:\n```\nRMakerFactoryReset(int seconds);\n```\n\n----------------------------------------\n\nTITLE: Getting Manufacturer Name - Arduino\nDESCRIPTION: This code snippet demonstrates how to retrieve the manufacturer name of the USB device using the `manufacturerName` function. It returns a constant character pointer to the manufacturer name string.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_25\n\nLANGUAGE: arduino\nCODE:\n```\nconst char * manufacturerName(void);\n```\n\n----------------------------------------\n\nTITLE: Play MP3 from Memory (Arduino)\nDESCRIPTION: This snippet illustrates how to play an MP3 from memory using the `playMP3()` method. It takes a buffer containing the MP3 data and the size of the buffer as input. The function returns true on success or false on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_26\n\nLANGUAGE: arduino\nCODE:\n```\nbool playMP3(uint8_t *src, size_t src_len)\n```\n\n----------------------------------------\n\nTITLE: Determining the Type of a Key-Value Pair - Arduino\nDESCRIPTION: This snippet shows how to determine the data type associated with a given key in the Preferences namespace using the `getType()` method. The return value is a `PreferenceType` enum value indicating the stored type.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\ngetType(\"myKey\")\n```\n\n----------------------------------------\n\nTITLE: Getting Node Info - C++\nDESCRIPTION: This snippet shows how to retrieve a pointer to the node_info_t structure, which contains information configured during node initialization. It returns a pointer to the structure on success and NULL on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nnode_info_t * getNodeInfo();\n```\n\n----------------------------------------\n\nTITLE: Registering RESTful Service Function (handleSysInfo)\nDESCRIPTION: Registers the `handleSysInfo` function to handle incoming GET requests for the `/api/sysinfo` URL. This function is designed to collect system information and return it as a JSON object to the client.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/WebServer/README.md#_snippet_0\n\nLANGUAGE: CPP\nCODE:\n```\nserver.on(\"/api/sysinfo\", handleSysInfo);\n```\n\n----------------------------------------\n\nTITLE: WiFi Get Network Info - Arduino\nDESCRIPTION: This function retrieves information from a scanned Wi-Fi network. It loads all information from a scanned Wi-Fi network into the ptr parameters. A successful operation will return `true`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_41\n\nLANGUAGE: arduino\nCODE:\n```\nbool getNetworkInfo(uint8_t networkItem, String &ssid, uint8_t &encryptionType, int32_t &RSSI, uint8_t* &BSSID, int32_t &channel);\n```\n\n----------------------------------------\n\nTITLE: Put Char Value Arduino\nDESCRIPTION: This function stores a `char` value (int8_t) associated with a given key in the currently open namespace.  If the key does not exist, it is created. Returns the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t putChar(const char* key, int8_t value)\n```\n\n----------------------------------------\n\nTITLE: Running Bash Terminal in Docker Container\nDESCRIPTION: This command runs a bash terminal inside the ESP32 Arduino Lib Builder Docker container. It allows direct interaction with the container's file system and execution of commands within the container environment.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -it espressif/esp32-arduino-lib-builder:release-v5.1 /bin/bash\n```\n\n----------------------------------------\n\nTITLE: Determining Number of Available Entries - Arduino\nDESCRIPTION: This snippet demonstrates how to determine the number of available entries in the namespace's key table using the `freeEntries()` method. The method functions regardless of the mode (read-only or read-write) in which the namespace is opened.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\nfreeEntries()\n```\n\n----------------------------------------\n\nTITLE: Configuring Dual Antenna Functionality\nDESCRIPTION: Configures the dual antenna functionality for ESP32 modules with an RF switch, such as the ESP32-WROOM-DA.  The function allows specifying GPIO pins for antenna control and setting RX and TX antenna modes.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nbool setDualAntennaConfig(uint8_t gpio_ant1, uint8_t gpio_ant2, wifi_rx_ant_t rx_mode, wifi_tx_ant_t tx_mode);\n```\n\n----------------------------------------\n\nTITLE: Zigbee Factory Reset Arduino\nDESCRIPTION: Adds `Zigbee.factoryReset();` to the sketch to reset the device and Zigbee stack. This is useful if the End device flashed with the example is not connecting to the coordinator. It is recommended to do this if you re-flash the coordinator.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_OTA_Client/README.md#_snippet_1\n\nLANGUAGE: Arduino\nCODE:\n```\nZigbee.factoryReset();\n```\n\n----------------------------------------\n\nTITLE: esptool.py Burn Bootloader Configuration\nDESCRIPTION: This configuration defines the parameters for burning the bootloader using esptool.py. In this snippet, the pattern is empty, suggesting the bootloader burning process might be handled differently or defined elsewhere.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_31\n\nLANGUAGE: properties\nCODE:\n```\ntools.esptool_py.bootloader.protocol=serial\ntools.esptool_py.bootloader.params.verbose=\ntools.esptool_py.bootloader.params.quiet=\ntools.esptool_py.bootloader.pattern=\n```\n\n----------------------------------------\n\nTITLE: Setting Start/Stop Callback\nDESCRIPTION: This function sets the callback function to be executed when a start or stop command is received from the host. This allows the device to respond to start/stop unit commands.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_msc.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nvoid onStartStop(msc_start_stop_cb cb);\n```\n\n----------------------------------------\n\nTITLE: esptool.py Network Upload Configuration (Deprecated Arduino IDE 1.x)\nDESCRIPTION: This configuration defines parameters for uploading sketches via OTA using a network connection. It is designed for Arduino IDE 1.x and relies on a custom network command. It specifies the IP address, port, authentication details, and path to the binary file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_32\n\nLANGUAGE: properties\nCODE:\n```\ntools.esptool_py.upload.network_pattern={network_cmd} -i \"{serial.port}\" -p \"{network.port}\" \"--auth={network.password}\" -f \"{build.path}/{build.project_name}.bin\"\n```\n\n----------------------------------------\n\nTITLE: Reading Data from USB CDC - Arduino\nDESCRIPTION: Reads a specified number of bytes from the USB CDC receive buffer into a provided buffer.  Returns the number of bytes actually read.  Parameters include a pointer to the buffer where the data will be stored and the number of bytes to read.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t read(uint8_t *buffer, size_t size);\n```\n\n----------------------------------------\n\nTITLE: Setting Hostname for DHCP Client\nDESCRIPTION: Sets the hostname that the DHCP client uses to identify itself on the network. This name will typically show up in the Wi-Fi router's device list. The hostname must be set before Wi-Fi is started.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nsetHostname(const char *hostname);\n```\n\n----------------------------------------\n\nTITLE: Checking Available Space for Write - Arduino\nDESCRIPTION: Checks if the hardware is ready to accept data for writing.  Returns the number of bytes of available space in the transmit buffer. This function can prevent buffer overflows during write operations.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nint availableForWrite(void);\n```\n\n----------------------------------------\n\nTITLE: Getting Node ID - C++\nDESCRIPTION: This snippet shows how to retrieve the unique node_id assigned to the node. The node_id is usually the MAC address of the board. It returns a pointer to a NULL-terminated string containing the node_id.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nchar * getNodeID()\n```\n\n----------------------------------------\n\nTITLE: Open Zigbee Network in Application (Arduino)\nDESCRIPTION: This snippet shows how to use the `Zigbee.openNetwork(time);` function to open the Zigbee network for devices to join. This allows you to dynamically control when the network is open for pairing.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Range_Extender/README.md#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.openNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Clear Preferences Namespace Arduino\nDESCRIPTION: This function deletes all key-value pairs from the currently opened namespace, effectively clearing its contents. The namespace itself remains after this operation.  Returns a boolean indicating success.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nbool clear()\n```\n\n----------------------------------------\n\nTITLE: Update Git Submodules - Bash\nDESCRIPTION: This command updates the Git submodules within the Arduino-ESP32 hardware directory. It initializes any uninitialized submodules and recursively updates them to the correct versions. This is necessary to ensure that all the required components of the Arduino-ESP32 core are present.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/installing.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit submodule update --init --recursive\n```\n\n----------------------------------------\n\nTITLE: Getting Firmware Version - Arduino\nDESCRIPTION: This code snippet shows how to get the firmware version of the USB device using the `firmwareVersion` function. It retrieves the current firmware version, which is a 16-bit unsigned value.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nuint16_t firmwareVersion(void);\n```\n\n----------------------------------------\n\nTITLE: Unregistering a Variable in Arduino\nDESCRIPTION: Unregisters a previously registered diagnostics variable using its key.  The function returns a boolean indicating success or failure. This API is available via the `Insights.variables` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\nbool remove(const char *key);\n```\n\n----------------------------------------\n\nTITLE: Setting Pins for PDM TX I2S - Arduino\nDESCRIPTION: This function sets the pins for the I2S interface when using the PDM TX mode. It configures the clock (clk) and data output pins (dout0, dout1). The dout1 parameter is optional and defaults to -1 if not used. It supports configuring one or two data output pins for PDM TX operation.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nvoid setPinsPdmTx(int8_t clk, int8_t dout0, int8_t dout1=-1)\n```\n\n----------------------------------------\n\nTITLE: Factory Resetting Zigbee Device in Arduino\nDESCRIPTION: This code snippet shows how to add the `Zigbee.factoryReset();` line to the Arduino sketch to reset the Zigbee device and stack. This is useful when the end device is not connecting to the coordinator, especially after re-flashing the coordinator.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Temp_Hum_Sensor_Sleepy/README.md#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.factoryReset();\n```\n\n----------------------------------------\n\nTITLE: Read Bytes from I2S Interface (Arduino)\nDESCRIPTION: This snippet demonstrates how to read a specific number of bytes from the I2S interface using the `readBytes()` method. The function takes a buffer and the number of bytes to read as input, and returns the number of bytes actually read. The provided buffer must be large enough to accommodate the requested size.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_17\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t readBytes(char *buffer, size_t size)\n```\n\n----------------------------------------\n\nTITLE: Include Preferences Header Arduino\nDESCRIPTION: This line includes the Preferences library header file, which is required to use the Preferences API in an Arduino sketch.  It allows access to functions for interacting with the non-volatile storage (NVS) on the ESP32.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\n#include <Preferences.h>\n```\n\n----------------------------------------\n\nTITLE: Setting EXTRA_COMPONENT_DIRS in CMakeLists.txt\nDESCRIPTION: This CMakeLists.txt setting adds a path to the esp32-arduino-lib-builder component to the build process.  It is necessary when you need to use USBHID classes.  This is required before the project() declaration.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nset(EXTRA_COMPONENT_DIRS <path to esp32-arduino-lib-builder/components/arduino_tinyusb>)\n```\n\n----------------------------------------\n\nTITLE: WiFiMulti Run - Arduino\nDESCRIPTION: This function runs the WiFiMulti connection process. It attempts to connect to the APs added to the list. The function takes a `connectTimeout` parameter. A successful operation will return a `uint8_t`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_37\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t run(uint32_t connectTimeout=5000);\n```\n\n----------------------------------------\n\nTITLE: Get SoftAP Hostname - Arduino\nDESCRIPTION: This function retrieves the hostname of the ESP32 access point (AP). It returns a const char* representing the AP's hostname, enabling you to identify and manage the AP on the network.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_18\n\nLANGUAGE: arduino\nCODE:\n```\nconst char * softAPgetHostname();\n```\n\n----------------------------------------\n\nTITLE: Writing LEDC Channel Duty Cycle - Arduino\nDESCRIPTION: Sets the duty cycle for a given LEDC channel. It takes the channel number and the duty cycle value as input and returns a boolean indicating success.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nbool ledcWriteChannel(uint8_t channel, uint32_t duty);\n```\n\n----------------------------------------\n\nTITLE: Check Key Existence Arduino\nDESCRIPTION: This function checks if a specific key exists within the currently open namespace. It takes the key name as a parameter and returns true if the key exists, and false otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nbool isKey(const char * key)\n```\n\n----------------------------------------\n\nTITLE: Setting Product Revision\nDESCRIPTION: This function sets the product revision for the USB device. The revision is a string that indicates the version or revision of the product. The maximum length of the revision string is 4 characters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_msc.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nvoid productRevision(const char * ver);//max 4 chars\n```\n\n----------------------------------------\n\nTITLE: Setting Vendor ID\nDESCRIPTION: This function sets the vendor ID (VID) for the USB device. The VID is a string that identifies the manufacturer of the device. The maximum length of the VID string is 8 characters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_msc.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nvoid vendorID(const char * vid);//max 8 chars\n```\n\n----------------------------------------\n\nTITLE: Linking Setup and Loop - CMake\nDESCRIPTION: This snippet conditionally links the `setup()` and `loop()` functions to the component's library using the `-u` linker option. This is done when `CONFIG_AUTOSTART_ARDUINO` is enabled, ensuring that these functions, which are typically defined in the user's main sketch, are included in the final executable.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif(CONFIG_AUTOSTART_ARDUINO)\n    # in autostart mode, arduino-esp32 contains app_main() function and needs to\n    # reference setup() and loop() in the main component. If we add main\n    # component to priv_requires then we create a large circular dependency\n    # (arduino-esp32 -> main -> arduino-esp32) and can get linker errors, so\n    # instead we add setup() and loop() to the undefined symbols list so the\n    # linker will always include them.\n    #\n    # (As they are C++ symbol, we need to add the C++ mangled names.)\n    target_link_libraries(${COMPONENT_LIB} INTERFACE \"-u _Z5setupv -u _Z4loopv\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting C++ Standard for ESP-IDF Component\nDESCRIPTION: This snippet sets the C++ standard to C++17 for the component's library. It ensures that the component is compiled using the specified C++ standard, enabling the use of modern C++ features.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset_property(TARGET ${COMPONENT_LIB} PROPERTY CXX_STANDARD 17)\n```\n\n----------------------------------------\n\nTITLE: Defining WiFi Library Keyword\nDESCRIPTION: Defines 'WiFi' as a KEYWORD3 for syntax highlighting. This indicates that 'WiFi' is a core library component and should be visually distinguished within the Arduino IDE.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/keywords.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nWiFi\tKEYWORD3\n```\n\n----------------------------------------\n\nTITLE: Setting Heap Metrics Period in Arduino\nDESCRIPTION: Resets the periodic interval for collecting heap metrics. Setting the interval to 0 disables heap metrics collection. This API is available via the `Insights.metrics` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\nvoid setHeapPeriod(uint32_t period);\n```\n\n----------------------------------------\n\nTITLE: Detach Interrupt from GPIO - Arduino\nDESCRIPTION: Detaches an interrupt from a specified GPIO pin. The `detachInterrupt` function disables the interrupt on the given pin. It takes the pin number as input and removes any previously attached interrupt.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/gpio.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\ndetachInterrupt(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: Enabling ESP_LOGx Macros in Arduino IDE (C)\nDESCRIPTION: This snippet enables the use of ESP_LOGx macros within the Arduino IDE when using Arduino as an ESP-IDF component. It includes the esp32-hal-log.h header if the ARDUINO_ARCH_ESP32 macro is defined.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n#ifdef ARDUINO_ARCH_ESP32\n#include \"esp32-hal-log.h\"\n#endif\n```\n\n----------------------------------------\n\nTITLE: Setting includedirs in Arduino's CMakeLists.txt\nDESCRIPTION: This snippet shows the updated includedirs variable after adding the new library's include path. This is within Arduino's CMakeLists.txt, not the project's CMakeLists.txt file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nset(includedirs\n  variants/${CONFIG_ARDUINO_VARIANT}/\n  cores/esp32/\n  libraries/ArduinoOTA/src\n  libraries/AsyncUDP/src\n  libraries/new_library/src\n```\n\n----------------------------------------\n\nTITLE: Checking WPA3 Support: Compile-Time (Arduino)\nDESCRIPTION: This code snippet allows you to check for WPA3 support at compile time.  If `CONFIG_ESP32_WIFI_ENABLE_WPA3_SAE` is not defined, a warning is issued, indicating the lack of WPA3 support in the SDK.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/troubleshooting.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\n#ifndef CONFIG_ESP32_WIFI_ENABLE_WPA3_SAE\n#warning \"No WPA3 support.\"\n#endif\n```\n\n----------------------------------------\n\nTITLE: Install Test Dependencies (pytest)\nDESCRIPTION: This command installs the necessary Python dependencies required for running the runtime tests using `pip`. The dependencies are listed in the `tests/requirements.txt` file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\npip install -U -r tests/requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Run Test on Target Board\nDESCRIPTION: This script executes the built test binary on the specified target board. It connects to the board and runs the test, displaying the output in the terminal.  The `<test_name>` and `<target>` parameters should be replaced with the actual test name and target board, respectively.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n./.github/scripts/tests_run.sh -s <test_name> -t <target>\n```\n\n----------------------------------------\n\nTITLE: Factory Reset Zigbee Device Arduino\nDESCRIPTION: This code snippet shows how to reset the Zigbee device and stack to its factory default settings. This is useful for troubleshooting connection issues or when re-flashing the coordinator.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_CarbonDioxide_Sensor/README.md#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.factoryReset();\n```\n\n----------------------------------------\n\nTITLE: Registering New Peer Callback - onNewPeer()\nDESCRIPTION: Registers a callback function to handle incoming data from new peers. The `cb` parameter is a pointer to the callback function, and the `arg` parameter is an optional pointer to a user-defined argument to be passed to the callback function.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid onNewPeer(void (*cb)(const esp_now_recv_info_t *info, const uint8_t *data, int len, void *arg), void *arg);\n```\n\nLANGUAGE: cpp\nCODE:\n```\nvoid cb(const esp_now_recv_info_t *info, const uint8_t *data, int len, void *arg);\n```\n\n----------------------------------------\n\nTITLE: Setting USB Event Callback - Arduino\nDESCRIPTION: This code snippet demonstrates how to set a callback function to handle USB events using the `onEvent` function. It registers a user-defined callback to be executed when specific USB events occur, enabling the application to respond dynamically to changes in the USB connection state.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nvoid onEvent(esp_event_handler_t callback);\n```\n\n----------------------------------------\n\nTITLE: Device Constructor - C++\nDESCRIPTION: This snippet demonstrates the parameterized constructor to create a virtual device on the node. It takes the device name, device type, and private data as parameters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nDevice my_device(const char *dev_name, const char *dev_type, void *priv_data);\n```\n\n----------------------------------------\n\nTITLE: Cloning a new Arduino library locally (Bash)\nDESCRIPTION: This command clones a new Arduino library into the components directory of the project. This assumes you are adding the library as a local library to the project.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/esp/esp-idf/examples/your_project\nmkdir components\ngit clone --recursive git@github.com:Author/new_library.git components/new_library\n```\n\n----------------------------------------\n\nTITLE: Setting the Button GPIO - Arduino\nDESCRIPTION: This section explains how to set the Button GPIO by changing the `button` variable. The button variable defaults to BOOT_PIN (BOOT button on ESP32-C6 and ESP32-H2).\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_PM25_Sensor/README.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Installing Required Python Packages in Bash\nDESCRIPTION: This command installs the required Python packages using `pip`. These packages are necessary for building and configuring the ESP32 Arduino libraries.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install --user setuptools pyserial click cryptography future pyparsing pyelftools\n```\n\n----------------------------------------\n\nTITLE: End Preferences Namespace Arduino\nDESCRIPTION: This function closes the currently opened namespace, releasing the resources associated with it. Subsequent attempts to access the closed namespace will fail.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/preferences.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nvoid end()\n```\n\n----------------------------------------\n\nTITLE: Writing to Slave Response Buffer - Arduino\nDESCRIPTION: Writes data to the slave's response buffer before receiving a response message. This function is specific to ESP32 and is used to add slave compatibility.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_22\n\nLANGUAGE: arduino\nCODE:\n```\nWire.slaveWrite((uint8_t *)message, strlen(message));\n```\n\n----------------------------------------\n\nTITLE: Setting Project Version - CMake\nDESCRIPTION: Defines the project version and version number using CMake's `set` command.  These variables can be used later in the build process or for informational purposes. No dependencies.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(PROJECT_VER \"1.0\")\nset(PROJECT_VER_NUMBER 1)\n```\n\n----------------------------------------\n\nTITLE: Enabling OTA Updates\nDESCRIPTION: This code snippet enables Over-The-Air (OTA) updates for the device, following the ESP RainMaker specification. The OTA workflow type needs to be specified.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t enableOTA(ota_type_t type);\n```\n\n----------------------------------------\n\nTITLE: Setting Attenuation for ADC Continuous Mode Using analogContinuousSetAtten (Arduino)\nDESCRIPTION: This snippet illustrates setting the attenuation for the ADC continuous mode using `analogContinuousSetAtten`. It takes an `adc_attenuation_t` value as input.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\nvoid analogContinuousSetAtten(adc_attenuation_t attenuation);\n```\n\n----------------------------------------\n\nTITLE: Getting WebUSB URL - Arduino\nDESCRIPTION: This code snippet demonstrates how to retrieve the currently configured WebUSB URL using the `webUSBURL` function. This URL is used for WebUSB functionality.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_29\n\nLANGUAGE: arduino\nCODE:\n```\nconst char * webUSBURL(void);\n```\n\n----------------------------------------\n\nTITLE: Ending I2C Transmission - Arduino\nDESCRIPTION: Completes the I2C transmission to the slave device. Sends the buffered data.  The `sendStop` parameter enables or disables the stop signal. Returns an error code.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_12\n\nLANGUAGE: arduino\nCODE:\n```\nWire.endTransmission(true);\n```\n\n----------------------------------------\n\nTITLE: Installing Python and Upgrading pip in Bash\nDESCRIPTION: These commands install Python 3 and upgrade `pip`, the Python package installer. Python and pip are required for installing Python dependencies.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install python3\n    sudo pip install --upgrade pip\n```\n\n----------------------------------------\n\nTITLE: Running the Terminal User Interface in Bash\nDESCRIPTION: This command executes the `app.py` script located in the `tools/config_editor` directory. This launches the terminal user interface for configuring the libraries.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n./tools/config_editor/app.py\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Parameter in Arduino\nDESCRIPTION: Adds a custom parameter to the device, created using the Param class. It takes a Param object as input. Returns ESP_OK on success, or an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_22\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t addParam(Param parameter);\n```\n\n----------------------------------------\n\nTITLE: Getting Peer Wi-Fi Interface - getInterface()\nDESCRIPTION: Retrieves the Wi-Fi interface of the peer. Returns the Wi-Fi interface.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nwifi_interface_t getInterface() const;\n```\n\n----------------------------------------\n\nTITLE: Running ESP32 Arduino Lib Builder Docker Image\nDESCRIPTION: This command runs the ESP32 Arduino Lib Builder Docker image, mounting the current directory for library compilation and setting the terminal type for proper color display. It ensures the Lib Builder UI is accessible and that compiled libraries can be copied to the host machine.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -v $PWD:/arduino-esp32 -e TERM=xterm-256color espressif/esp32-arduino-lib-builder:release-v5.1\n```\n\n----------------------------------------\n\nTITLE: Preferences Initialization and Data Handling - Arduino\nDESCRIPTION: This code demonstrates initializing the Preferences library, checking for existing keys to determine if it's the first run, and setting factory default values if needed. It also shows how to retrieve and update operational parameters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\n#include <Preferences.h>\n\n#define RW_MODE false\n#define RO_MODE true\n\nPreferences stcPrefs;\n\nvoid setup() {\n\n   // not the complete setup(), but in setup(), include this...\n\n   stcPrefs.begin(\"STCPrefs\", RO_MODE);           // Open our namespace (or create it\n                                                  //  if it doesn't exist) in RO mode.\n\n   bool tpInit = stcPrefs.isKey(\"nvsInit\");       // Test for the existence\n                                                  // of the \"already initialized\" key.\n\n   if (tpInit == false) {\n      // If tpInit is 'false', the key \"nvsInit\" does not yet exist therefore this\n      //  must be our first-time run. We need to set up our Preferences namespace keys. So...\n      stcPrefs.end();                             // close the namespace in RO mode and...\n      stcPrefs.begin(\"STCPrefs\", RW_MODE);        //  reopen it in RW mode.\n\n\n      // The .begin() method created the \"STCPrefs\" namespace and since this is our\n      //  first-time run we will create\n      //  our keys and store the initial \"factory default\" values.\n      stcPrefs.putUChar(\"curBright\", 10);\n      stcPrefs.putString(\"talChan\", \"one\");\n      stcPrefs.putLong(\"talMax\", -220226);\n      stcPrefs.putBool(\"ctMde\", true);\n\n      stcPrefs.putBool(\"nvsInit\", true);          // Create the \"already initialized\"\n                                                  //  key and store a value.\n\n      // The \"factory defaults\" are created and stored so...\n      stcPrefs.end();                             // Close the namespace in RW mode and...\n      stcPrefs.begin(\"STCPrefs\", RO_MODE);        //  reopen it in RO mode so the setup code\n                                                  //  outside this first-time run 'if' block\n                                                  //  can retrieve the run-time values\n                                                  //  from the \"STCPrefs\" namespace.\n   }\n\n   // Retrieve the operational parameters from the namespace\n   //  and save them into their run-time variables.\n   currentBrightness = stcPrefs.getUChar(\"curBright\");  //\n   tChannel = stcPrefs.getString(\"talChan\");            //  The LHS variables were defined\n   tChanMax = stcPrefs.getLong(\"talMax\");               //   earlier in the sketch.\n   ctMode = stcPrefs.getBool(\"ctMde\");                  //\n\n   // All done. Last run state (or the factory default) is now restored.\n   stcPrefs.end();                                      // Close our preferences namespace.\n\n   // Carry on with the rest of your setup code...\n\n   // When the sketch is running, it updates any changes to an operational parameter\n   //  to the appropriate key-value pair in the namespace.\n\n}\n\n```\n\n----------------------------------------\n\nTITLE: Stopping RainMaker Agent - C++\nDESCRIPTION: This snippet shows how to stop the ESP RainMaker agent, which was previously started using RMaker.start(). It returns ESP_OK on success and an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nesp_err_t stop()\n```\n\n----------------------------------------\n\nTITLE: Unregistering a Metric in Arduino\nDESCRIPTION: Unregisters a previously registered diagnostics metric using its key.  The function returns a boolean indicating success or failure. This API is available via the `Insights.metrics` object.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nbool remove(const char *key);\n```\n\n----------------------------------------\n\nTITLE: Getting Encrypted Peer Count - getEncryptedPeerCount()\nDESCRIPTION: Retrieves the number of peers using encryption in the ESP-NOW network. Returns the number of peers using encryption, or `-1` if an error occurs.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nint getEncryptedPeerCount();\n```\n\n----------------------------------------\n\nTITLE: Deinitializing ESP RainMaker Node\nDESCRIPTION: This code snippet deinitializes the ESP RainMaker agent and the associated node. It should be called when the RainMaker functionality is no longer needed.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t deinitNode(Node node)\n```\n\n----------------------------------------\n\nTITLE: Stopping ESP RainMaker Agent\nDESCRIPTION: This code snippet stops the ESP RainMaker agent that was previously started using `RMaker.start()`. It releases the resources used by the agent.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t stop()\n```\n\n----------------------------------------\n\nTITLE: Defining Pre-Build Hooks (Copy sdkconfig)\nDESCRIPTION: These bash/cmd scripts copy the sdkconfig file from the compiler SDK path to the build path before compilation.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_7\n\nLANGUAGE: properties\nCODE:\n```\nrecipe.hooks.prebuild.8.pattern=/usr/bin/env bash -c \"cp -f \\\"{compiler.sdk.path}\\\"/sdkconfig \\\"{build.path}\\\"/sdkconfig\"\nrecipe.hooks.prebuild.8.pattern.windows=cmd /c COPY /y \"{compiler.sdk.path}\\sdkconfig\" \"{build.path}\\sdkconfig\"\n```\n\n----------------------------------------\n\nTITLE: Example of Using getType() Method - Arduino\nDESCRIPTION: This is a complete example showing how to use the `getType()` method and assign the result to a `PreferenceType` variable.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/preferences.rst#_snippet_14\n\nLANGUAGE: arduino\nCODE:\n```\nPreferenceType whatType = getType(\"myKey\");\n```\n\n----------------------------------------\n\nTITLE: WiFi Scan Delete - Arduino\nDESCRIPTION: This function deletes the last scan result from RAM, freeing up memory.  It's used to clear the scan results.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_40\n\nLANGUAGE: arduino\nCODE:\n```\nvoid scanDelete();\n```\n\n----------------------------------------\n\nTITLE: Get SoftAP SSID - Arduino\nDESCRIPTION: This function retrieves the SSID of the ESP32 access point (AP). It returns a String representing the AP's SSID.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_22\n\nLANGUAGE: arduino\nCODE:\n```\nString softAPSSID(void) const;\n```\n\n----------------------------------------\n\nTITLE: Installing Textual Library for UI in Bash\nDESCRIPTION: This command installs the `textual` library using `pip`. Textual is required to run the terminal user interface.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\npip install --user textual\n```\n\n----------------------------------------\n\nTITLE: Getting Device Name\nDESCRIPTION: This code snippet retrieves the name of the device.  Each device on the node should have a unique device name.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_16\n\nLANGUAGE: arduino\nCODE:\n```\nconst char * getDeviceName();\n```\n\n----------------------------------------\n\nTITLE: Defining Pre-Build Hooks (Partitions)\nDESCRIPTION: These bash/cmd scripts are executed before the build process to copy partition tables. The scripts check for the existence of custom partition files (partitions.csv) in the source, variant, and platform directories, and copy them to the build directory if found. This allows customization of the ESP32's partition scheme.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_3\n\nLANGUAGE: properties\nCODE:\n```\nrecipe.hooks.prebuild.1.pattern=/usr/bin/env bash -c \"[ ! -f \\\"{build.source.path}\\\"/partitions.csv ] || cp -f \\\"{build.source.path}\\\"/partitions.csv \\\"{build.path}\\\"/partitions.csv\"\nrecipe.hooks.prebuild.2.pattern=/usr/bin/env bash -c \"[ -f \\\"{build.path}\\\"/partitions.csv ] || [ ! -f \\\"{build.variant.path}\\\"/\\\"{build.custom_partitions}\\\".csv ] || cp \\\"{build.variant.path}\\\"/\\\"{build.custom_partitions}\\\".csv \\\"{build.path}\\\"/partitions.csv\"\nrecipe.hooks.prebuild.3.pattern=/usr/bin/env bash -c \"[ -f \\\"{build.path}\\\"/partitions.csv ] || cp \\\"{runtime.platform.path}\\\"/tools/partitions/\\\"{build.partitions}\\\".csv \\\"{build.path}\\\"/partitions.csv\"\n\nrecipe.hooks.prebuild.1.pattern.windows=cmd /c if exist \"{build.source.path}\\partitions.csv\" COPY /y \"{build.source.path}\\partitions.csv\" \"{build.path}\\partitions.csv\"\nrecipe.hooks.prebuild.2.pattern.windows=cmd /c if not exist \"{build.path}\\partitions.csv\" if exist \"{build.variant.path}\\{build.custom_partitions}.csv\" COPY \"{build.variant.path}\\{build.custom_partitions}.csv\" \"{build.path}\\partitions.csv\"\nrecipe.hooks.prebuild.3.pattern.windows=cmd /c if not exist \"{build.path}\\partitions.csv\" COPY \"{runtime.platform.path}\\tools\\partitions\\{build.partitions}.csv\" \"{build.path}\\partitions.csv\"\n```\n\n----------------------------------------\n\nTITLE: Customizing Hostname and Timezone\nDESCRIPTION: These `#define` statements allow customization of the hostname and timezone used by the ESP32 web server. `HOSTNAME` sets the hostname, and `TIMEZONE` configures the timezone.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/WebServer/README.md#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n#define HOSTNAME \"webserver\"\n#define TIMEZONE \"CET-1CEST,M3.5.0,M10.5.0/3\"\n```\n\n----------------------------------------\n\nTITLE: Setting esptool_py Path and Command\nDESCRIPTION: Defines the path and command for esptool.py, which is used for flashing and interacting with ESP32 devices. It specifies the location of the esptool.py executable and the command used to run it, including handling for Windows.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_8\n\nLANGUAGE: properties\nCODE:\n```\ntools.esptool_py.path={runtime.platform.path}/tools/esptool\ntools.esptool_py.cmd=esptool\ntools.esptool_py.cmd.windows=esptool.exe\n```\n\n----------------------------------------\n\nTITLE: Setting Arduino-ESP32 Destination Folder in Bash\nDESCRIPTION: This command executes the `build.sh` script with the `-c` option, setting the destination folder for the compiled libraries. Replace `<path>` with the target directory (e.g., `$HOME/Arduino/hardware/espressif/esp32`).\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh -c <path>\n```\n\n----------------------------------------\n\nTITLE: Arduino Header Example\nDESCRIPTION: This snippet demonstrates the required header format for Arduino examples within the ESP32 Arduino core. It includes example name, license information, and a brief description of the code's purpose. This header should be present in all source files within an example.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\n/* Wi-Fi FTM Initiator Arduino Example\n\n  This example code is in the Public Domain (or CC0 licensed, at your option.)\n\n  Unless required by applicable law or agreed to in writing, this\n  software is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n  CONDITIONS OF ANY KIND, either express or implied.\n*/\n```\n\n----------------------------------------\n\nTITLE: Setting Receive Callback - Arduino\nDESCRIPTION: Sets the callback function that will be executed when data is received from the master.  Used in I2C slave mode.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_19\n\nLANGUAGE: arduino\nCODE:\n```\nWire.onReceive(onReceive);\n```\n\n----------------------------------------\n\nTITLE: Writing Data in I2C Transmission - Arduino\nDESCRIPTION: Writes data to the I2C buffer for transmission to the slave device. Data is buffered and sent when `endTransmission` is called.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\nWire.write(x);\n```\n\n----------------------------------------\n\nTITLE: Performing Wi-Fi Reset in Arduino\nDESCRIPTION: Resets Wi-Fi credentials. It takes the number of seconds after which the chip should reboot as input.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_31\n\nLANGUAGE: arduino\nCODE:\n```\nRMakerWiFiReset(int seconds);\n```\n\n----------------------------------------\n\nTITLE: Setting Build Type with Build Script in Bash\nDESCRIPTION: This command sets the build type using the `-b` option along with the `-t` target option. Replace `<build|menuconfig|idf_libs|copy_bootloader|mem_variant>` with the desired build type. The command depends on the ``-t`` argument.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh -t esp32 -b <build|menuconfig|idf_libs|copy_bootloader|mem_variant>\n```\n\n----------------------------------------\n\nTITLE: Getting Touch Interrupt Last Status in Arduino\nDESCRIPTION: This function, specific to ESP32-S2 and ESP32-S3 (TOUCH_V2), retrieves the last ISR status for the touch pad, indicating whether the pad is currently pressed.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/touch.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nbool touchInterruptGetLastStatus(uint8_t pin);\n```\n\n----------------------------------------\n\nTITLE: Printing QR Code for Provisioning in Arduino\nDESCRIPTION: Displays a QR code used for device provisioning. It takes the service name, proof of possession (pop), and transport type (softap or ble) as input.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_29\n\nLANGUAGE: arduino\nCODE:\n```\nprintQR(const char *serv_name, const char *pop, const char *transport);\n```\n\n----------------------------------------\n\nTITLE: Adding Library from Github URL (JSON)\nDESCRIPTION: This JSON snippet demonstrates how to add a library from a GitHub URL to the external libraries test. It includes the URL to the library's repository, a list of required libraries, a list of excluded targets (SoCs), and the paths to the sketches to be tested.  The `required-libs` parameter specifies other libraries needed for the compilation.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/external_libraries_test.rst#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"source-url\": \"https://github.com/me-no-dev/ESPAsyncWebServer.git\",\n    \"required-libs\": [\n        {\"source-url\": \"https://github.com/me-no-dev/AsyncTCP.git\"}\n    ],\n    \"exclude_targets\": [],\n    \"sketch_path\": [\n        \"~/Arduino/libraries/ESPAsyncWebServer/examples/CaptivePortal/CaptivePortal.ino\",\n        \"~/Arduino/libraries/ESPAsyncWebServer/examples/ESP_AsyncFSBrowser/ESP_AsyncFSBrowser.ino\",\n        \"~/Arduino/libraries/ESPAsyncWebServer/examples/regex_patterns/regex_patterns.ino\",\n        \"~/Arduino/libraries/ESPAsyncWebServer/examples/simple_server/simple_server.ino\"\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Touch Interrupt Threshold Direction in Arduino\nDESCRIPTION: This function, specific to ESP32 (TOUCH_V1), configures the interrupt to trigger when the sensor value is either lower or higher than the threshold value. The default is lower.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/touch.rst#_snippet_6\n\nLANGUAGE: arduino\nCODE:\n```\nvoid touchInterruptSetThresholdDirection(bool mustbeLower);\n```\n\n----------------------------------------\n\nTITLE: Skipping Install/Update with Build Script in Bash\nDESCRIPTION: This command executes the `build.sh` script with the `-s` option, which skips the installation/updating of ESP-IDF and all components. This is useful when the environment is already set up.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh -s\n```\n\n----------------------------------------\n\nTITLE: Getting I2C Clock Frequency - Arduino\nDESCRIPTION: Retrieves the current clock frequency of the I2C bus. Returns the current frequency configuration.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_3\n\nLANGUAGE: arduino\nCODE:\n```\nuint32_t getClock();\n```\n\n----------------------------------------\n\nTITLE: Set Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project. This ensures that the project can be built with a compatible version of CMake. The minimum version is set to 3.16.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/hello_world/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: WiFi Reconnect - Arduino\nDESCRIPTION: This function attempts to reconnect the Wi-Fi connection. It returns true if the reconnection is successful.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_30\n\nLANGUAGE: arduino\nCODE:\n```\nbool reconnect();\n```\n\n----------------------------------------\n\nTITLE: Removing Device from Node\nDESCRIPTION: This code snippet removes a device from the node.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t removeDevice(Device device);\n```\n\n----------------------------------------\n\nTITLE: Define Datatypes for Ultrasound\nDESCRIPTION: This section defines the datatypes used in the Ultrasound component, categorizing them as KEYWORD1 for syntax highlighting.  These datatypes include AsyncUDP, AsyncUDPPacket, and AsyncUDPMessage.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/AsyncUDP/keywords.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nAsyncUDP\tKEYWORD1\nAsyncUDPPacket\tKEYWORD1\nAsyncUDPMessage\tKEYWORD1\n```\n\n----------------------------------------\n\nTITLE: ESP32-S3 rebooting error message\nDESCRIPTION: Example output of an ESP32-S3 rebooting even with a bare minimum sketch error.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/troubleshooting.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nE (124) esp_core_dump_flash: Core dump flash config is corrupted! CRC=0x7bd5c66f instead of 0x0\nRebooting...\nESP-ROM:esp32s3-20210327\nBuild:Mar 27 2021\nrst:0xc (RTC_SW_CPU_RST),boot:0x18 (SPI_FAST_FLASH_BOOT)\nSaved PC:0x40376af0\nSPIWP:0xee\nOctal Flash Mode Enabled\nFor OPI Flash, Use Default Flash Boot Mode\nmode:SLOW_RD, clock div:1\nload:0x3fce3808,len:0x44c\nload:0x403c9700,len:0xbec\nload:0x403cc700,len:0x2920\nentry 0x403c98d8\n\nassert failed: do_core_init startup.c:326 (flash_ret == ESP_OK)\n```\n\n----------------------------------------\n\nTITLE: WiFi setMinSecurity - Arduino\nDESCRIPTION: This function sets the minimum security level for APs to be considered connectable.  The `minSecurity` parameter specifies the minimum security mode, with a default of `WIFI_AUTH_WPA2_PSK`.  A successful configuration will return `true`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_35\n\nLANGUAGE: arduino\nCODE:\n```\nbool setMinSecurity(wifi_auth_mode_t minSecurity);\n```\n\n----------------------------------------\n\nTITLE: Create a symlink to use arduino-esp32 with Arduino IDE and ESP-IDF (Bash)\nDESCRIPTION: Creates a symbolic link to the arduino-esp32 hardware folder in the Arduino IDE hardware directory in the ESP-IDF components directory. This allows you to use the same installation of arduino-esp32 with both the Arduino IDE and ESP-IDF. Remember to replace ~/Arduino with the location you have your Arduino install.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nln -s ~/Arduino/hardware/espressif/esp32  ~/esp/esp-idf/components/arduino-esp32\n```\n\n----------------------------------------\n\nTITLE: Setting LIBRARY_SRCS in Arduino's CMakeLists.txt\nDESCRIPTION: This snippet shows the updated LIBRARY_SRCS variable after adding the new library's source files. This is within Arduino's CMakeLists.txt, not the project's CMakeLists.txt file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nset(LIBRARY_SRCS\n  libraries/ArduinoOTA/src/ArduinoOTA.cpp\n  libraries/AsyncUDP/src/AsyncUDP.cpp\n  libraries/new_library/src/new_library.cpp\n  libraries/new_library/src/new_library_extra_file.c\n```\n\n----------------------------------------\n\nTITLE: Getting I2C Timeout - Arduino\nDESCRIPTION: Retrieves the current timeout value in milliseconds for the I2C bus. Returns the current timeout configuration.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nuint16_t getTimeOut();\n```\n\n----------------------------------------\n\nTITLE: Enabling IPv6 Support for SoftAP\nDESCRIPTION: Enables or disables IPv6 support for the softAP.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_16\n\nLANGUAGE: arduino\nCODE:\n```\nbool softAPenableIPv6(bool enable=true);\n```\n\n----------------------------------------\n\nTITLE: Define Project Name\nDESCRIPTION: Defines the name of the project in CMake. This is used to identify the project during the build process and in the generated output files. The project name is set to \"main\".\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/hello_world/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(main)\n```\n\n----------------------------------------\n\nTITLE: openSUSE Installation - Bash\nDESCRIPTION: This script installs the necessary dependencies for Arduino-ESP32 on openSUSE systems. It updates the user's dialout group, installs Git, Python-pip or Python3-pip (depending on Python version), Python-pyserial or Python3-pyserial, clones the Arduino-ESP32 repository, and runs the get.py script to download additional tools.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/installing.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo usermod -a -G dialout $USER && \\\nif [ `python --version 2>&1 | grep '2.7' | wc -l` = \\\"1\\\" ]; then \\\nsudo zypper install git python-pip python-pyserial; \\\nelse \\\nsudo zypper install git python3-pip python3-pyserial; \\\nfi && \\\nmkdir -p ~/Arduino/hardware/espressif && \\\ncd ~/Arduino/hardware/espressif && \\\ngit clone https://github.com/espressif/arduino-esp32.git esp32 && \\\ncd esp32/tools && \\\npython get.py\n```\n\n----------------------------------------\n\nTITLE: Arduino I2C Begin Function Example\nDESCRIPTION: This code snippet shows how to initialize the I2C peripheral in Arduino using the `Wire.begin()` function. The example demonstrates starting I2C with a specific device address.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/docs_contributing.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nWire.begin((uint8_t)I2C_DEV_ADDR);\n```\n\n----------------------------------------\n\nTITLE: Conditional Component Linking - CMake\nDESCRIPTION: These snippets conditionally add dependencies on various components, such as `arduino_tinyusb`, `esp_https_ota`, `espressif__esp_sr`, `espressif__esp_matter`, `joltwallet__littlefs`, and `espressif__network_provisioning`, based on the target device, configuration settings (`CONFIG_TINYUSB_ENABLED`), and whether selective compilation is enabled (`CONFIG_ARDUINO_SELECTIVE_COMPILATION`).\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif(IDF_TARGET MATCHES \"esp32s2|esp32s3|esp32p4\" AND CONFIG_TINYUSB_ENABLED)\n    maybe_add_component(arduino_tinyusb)\nendif()\nif(NOT CONFIG_ARDUINO_SELECTIVE_COMPILATION OR CONFIG_ARDUINO_SELECTIVE_ArduinoOTA)\n    maybe_add_component(esp_https_ota)\nendif()\nif(NOT CONFIG_ARDUINO_SELECTIVE_COMPILATION OR CONFIG_ARDUINO_SELECTIVE_ESP_SR)\n    maybe_add_component(espressif__esp_sr)\nendif()\nif(NOT CONFIG_ARDUINO_SELECTIVE_COMPILATION OR CONFIG_ARDUINO_SELECTIVE_Matter)\n    maybe_add_component(espressif__esp_matter)\nendif()\nif(NOT CONFIG_ARDUINO_SELECTIVE_COMPILATION OR CONFIG_ARDUINO_SELECTIVE_LittleFS)\n    maybe_add_component(joltwallet__littlefs)\nendif()\nif(NOT CONFIG_ARDUINO_SELECTIVE_COMPILATION OR CONFIG_ARDUINO_SELECTIVE_WiFiProv)\n    maybe_add_component(espressif__network_provisioning)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Zigbee Reboot Open Network Arduino\nDESCRIPTION: Sets the Zigbee network to open after rebooting by setting `Zigbee.setRebootOpenNetwork(time);` before calling `Zigbee.begin();`. This allows devices to join the network after a reboot.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_OTA_Client/README.md#_snippet_2\n\nLANGUAGE: Arduino\nCODE:\n```\nZigbee.setRebootOpenNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Analyzing WPS PIN Failure Log - ESP32\nDESCRIPTION: This log shows a failed WPS PIN connection attempt. The ESP32 generates WPS PINs, but the connection times out repeatedly. This typically indicates that the provided PIN was not entered correctly or within the allowed timeframe in the router's WPS settings.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WPS/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nets Jun  8 2016 00:22:57\n\nrst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)\nets Jun  8 2016 00:22:57\n\nrst:0x10 (RTCWDT_RTC_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)\nconfigsip: 0, SPIWP:0xee\nclk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00\nmode:DIO, clock div:1\nload:0x3fff0010,len:4\nload:0x3fff0014,len:732\nload:0x40078000,len:0\nload:0x40078000,len:11572\nentry 0x40078a14\n\nStarting WPS\nStation Mode Started\nWPS_PIN = 94842104\nWPS Timedout, retrying\nWPS_PIN = 55814171\nWPS Timedout, retrying\nWPS_PIN = 71321622\n```\n\n----------------------------------------\n\nTITLE: Inverting Logic for Standard/TDM I2S Pins - Arduino\nDESCRIPTION: This function sets the inverted logic for the bit clock (bclk), word select (ws), and master clock (mclk) pins when using the standard or TDM mode. Data pins cannot be inverted. It allows customizing the polarity of the clock and synchronization signals.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nvoid setInverted(bool bclk, bool ws, bool mclk=false)\n```\n\n----------------------------------------\n\nTITLE: Opening Zigbee Network in Arduino Application\nDESCRIPTION: This snippet illustrates how to open the Zigbee network at any time within the application code using the `Zigbee.openNetwork(time);` function. The `time` parameter determines the duration for which the network is open for devices to join.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Temp_Hum_Sensor_Sleepy/README.md#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nZigbee.openNetwork(time);\n```\n\n----------------------------------------\n\nTITLE: Creating Insights Firmware Package for Arduino ESP32\nDESCRIPTION: This snippet creates an Insights firmware package if the Insights library is present.  It runs a bash script or a cmd command on windows to execute `gen_insights_pkg`\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\nrecipe.hooks.objcopy.postobjcopy.1.pattern_args={build.path} {build.project_name} \"{build.source.path}\"\nrecipe.hooks.objcopy.postobjcopy.1.pattern=/usr/bin/env bash -c \"[ ! -d \\\"{build.path}\\\"/libraries/Insights ] || {tools.gen_insights_pkg.cmd} {recipe.hooks.objcopy.postobjcopy.1.pattern_args}\"\nrecipe.hooks.objcopy.postobjcopy.1.pattern.windows=cmd /c if exist \"{build.path}\\libraries\\Insights\" {tools.gen_insights_pkg.cmd} {recipe.hooks.objcopy.postobjcopy.1.pattern_args}\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Flags for ESP32 Arduino\nDESCRIPTION: Configures the compiler flags used during the build process for C, C++, and assembly files. It includes optimization flags, warning levels, and flags specific to Arduino. The flags are used to control the compilation process and generate optimized code for the ESP32.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_1\n\nLANGUAGE: properties\nCODE:\n```\ncompiler.optimization_flags=-Os\ncompiler.optimization_flags.release=-Os\ncompiler.optimization_flags.debug=-Og -g3\n\ncompiler.warning_flags=-w\ncompiler.warning_flags.none=-w\ncompiler.warning_flags.default=\ncompiler.warning_flags.more=-Wall\ncompiler.warning_flags.all=-Wall -Wextra\n\ncompiler.common_werror_flags=-Werror=return-type\n\ncompiler.cpreprocessor.flags=\"@{compiler.sdk.path}/flags/defines\" \"-I{build.source.path}\" -iprefix \"{compiler.sdk.path}/include/\" \"@{compiler.sdk.path}/flags/includes\" \"-I{compiler.sdk.path}/{build.memory_type}/include\"\ncompiler.c.flags=-MMD -c \"@{compiler.sdk.path}/flags/c_flags\" {compiler.warning_flags} {compiler.optimization_flags} {compiler.common_werror_flags}\ncompiler.cpp.flags=-MMD -c \"@{compiler.sdk.path}/flags/cpp_flags\" {compiler.warning_flags} {compiler.optimization_flags} {compiler.common_werror_flags}\ncompiler.S.flags=-MMD -c -x assembler-with-cpp \"@{compiler.sdk.path}/flags/S_flags\" {compiler.warning_flags} {compiler.optimization_flags}\ncompiler.c.elf.flags=\"-Wl,--Map={build.path}/{build.project_name}.map\" \"-L{compiler.sdk.path}/lib\" \"-L{compiler.sdk.path}/ld\" \"-L{compiler.sdk.path}/{build.memory_type}\" \"-Wl,--wrap=esp_panic_handler\" \"@{compiler.sdk.path}/flags/ld_flags\" \"@{compiler.sdk.path}/flags/ld_scripts\"\ncompiler.c.elf.libs=\"@{compiler.sdk.path}/flags/ld_libs\"\ncompiler.ar.flags=cr\n```\n\n----------------------------------------\n\nTITLE: Analyzing WPS PIN Successful Log - ESP32\nDESCRIPTION: This log showcases a successful WPS PIN connection. The ESP32 displays a WPS PIN, and the log confirms that the connection was established successfully. The ESP32 then disconnects and reconnects to the network and obtains an IP address.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WPS/README.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nets Jun  8 2016 00:22:57\n\nrst:0x10 (RTCWDT_RTC_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)\nconfigsip: 0, SPIWP:0xee\nclk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00\nmode:DIO, clock div:1\nload:0x3fff0010,len:4\nload:0x3fff0014,len:732\nload:0x40078000,len:0\nload:0x40078000,len:11572\nentry 0x40078a14\n\nStarting WPS\nStation Mode Started\nWPS_PIN = 36807581\nWPS Successful, stopping WPS and connecting to: <Your Router SSID>\nDisconnected from station, attempting reconnection\nConnected to :<Your Router SSID>\nGot IP: 192.168.1.100\n```\n\n----------------------------------------\n\nTITLE: Removing Device from Node - C++\nDESCRIPTION: This snippet demonstrates how to remove a device from the node. It takes a Device object as input and returns ESP_OK on success and an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nesp_err_t removeDevice(Device device);\n```\n\n----------------------------------------\n\nTITLE: Device Constructor Sample - C++\nDESCRIPTION: These snippets provide examples of how to create Device objects. The device name is compulsory, while the device type and private data are optional.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nDevice my_device(\"Switch\");\nDevice my_device(\"Switch1\", NULL, NULL);\n```\n\n----------------------------------------\n\nTITLE: Get RX Channel Handler Pointer (Arduino)\nDESCRIPTION: This snippet demonstrates how to get the receive (RX) channel handler pointer using the `rxChan()` method of the I2SClass. This pointer allows direct manipulation of the I2S RX channel. No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\ni2s_chan_handle_t rxChan()\n```\n\n----------------------------------------\n\nTITLE: Flash with esptool.py\nDESCRIPTION: This command uses `esptool.py` to flash the compiled binary to the factory partition of the ESP32-S3 chip.  It requires specifying the chip type, serial port, baud rate, flash mode, flash frequency, flash size, and the address of the factory partition. The `nora_recovery.ino.bin` file is the compiled sketch image.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/variants/arduino_nano_nora/extra/nora_recovery/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nesptool.py --chip esp32s3 --port \"/dev/ttyACM0\" --baud 921600  --before default_reset --after hard_reset write_flash  -z --flash_mode dio --flash_freq 80m --flash_size 16MB 0xF70000 \"nora_recovery.ino.bin\"\n```\n\n----------------------------------------\n\nTITLE: Setting ESP32 Build Flags\nDESCRIPTION: Configures the build flags specific to different ESP32 variants (e.g., ESP32, ESP32-S3). These flags define configurations such as USB mode, CDC on boot, MSC on boot, and DFU on boot. These flags are passed to the compiler to tailor the build for the target ESP32 chip.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_2\n\nLANGUAGE: properties\nCODE:\n```\nbuild.extra_flags.esp32=-DARDUINO_USB_CDC_ON_BOOT=0\nbuild.extra_flags.esp32s3=-DARDUINO_USB_MODE={build.usb_mode} -DARDUINO_USB_CDC_ON_BOOT={build.cdc_on_boot} -DARDUINO_USB_MSC_ON_BOOT={build.msc_on_boot} -DARDUINO_USB_DFU_ON_BOOT={build.dfu_on_boot}\nbuild.extra_flags.esp32s2=-DARDUINO_USB_MODE=0 -DARDUINO_USB_CDC_ON_BOOT={build.cdc_on_boot} -DARDUINO_USB_MSC_ON_BOOT={build.msc_on_boot} -DARDUINO_USB_DFU_ON_BOOT={build.dfu_on_boot}\nbuild.extra_flags.esp32c2=-DARDUINO_USB_CDC_ON_BOOT=0\nbuild.extra_flags.esp32c3=-DARDUINO_USB_MODE=1 -DARDUINO_USB_CDC_ON_BOOT={build.cdc_on_boot}\nbuild.extra_flags.esp32c6=-DARDUINO_USB_MODE=1 -DARDUINO_USB_CDC_ON_BOOT={build.cdc_on_boot}\nbuild.extra_flags.esp32h2=-DARDUINO_USB_MODE=1 -DARDUINO_USB_CDC_ON_BOOT={build.cdc_on_boot}\nbuild.extra_flags.esp32p4=-DARDUINO_USB_MODE={build.usb_mode} -DARDUINO_USB_CDC_ON_BOOT={build.cdc_on_boot} -DARDUINO_USB_MSC_ON_BOOT={build.msc_on_boot} -DARDUINO_USB_DFU_ON_BOOT={build.dfu_on_boot}\n```\n\n----------------------------------------\n\nTITLE: ESP32-C3 Debug Configuration (OpenOCD)\nDESCRIPTION: Defines debug configurations for ESP32-C3 using OpenOCD. Specifies custom commands and server arguments for debugging.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_26\n\nLANGUAGE: text\nCODE:\n```\ndebug_script.esp32c3=esp32c3-builtin.cfg\ndebug_config.esp32c3.cortex-debug.custom.name=Arduino on ESP32-C3\ndebug_config.esp32c3.cortex-debug.custom.serverArgs.0=-d3\ndebug_config.esp32c3.cortex-debug.custom.overrideAttachCommands.0=set remote hardware-watchpoint-limit 8\ndebug_config.esp32c3.cortex-debug.custom.overrideAttachCommands.1=monitor reset\ndebug_config.esp32c3.cortex-debug.custom.overrideAttachCommands.2=monitor halt\ndebug_config.esp32c3.cortex-debug.custom.overrideAttachCommands.3=monitor gdb_sync\ndebug_config.esp32c3.cortex-debug.custom.overrideAttachCommands.4=thb setup\ndebug_config.esp32c3.cortex-debug.custom.overrideRestartCommands.0=monitor reset\ndebug_config.esp32c3.cortex-debug.custom.overrideRestartCommands.1=monitor halt\ndebug_config.esp32c3.cortex-debug.custom.overrideRestartCommands.2=monitor gdb_sync\ndebug_config.esp32c3.cortex-debug.custom.overrideRestartCommands.3=thb setup\n```\n\n----------------------------------------\n\nTITLE: Setting USB Version - Arduino\nDESCRIPTION: This code snippet demonstrates how to set the USB version using the `usbVersion` function. This function configures the USB specification version that the device adheres to. It takes a 16-bit unsigned integer as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\nbool usbVersion(uint16_t version);\n```\n\n----------------------------------------\n\nTITLE: Ending Timer - timerEnd (Arduino)\nDESCRIPTION: This function stops and deallocates the specified timer. It's important to call this function when the timer is no longer needed to free up resources. It accepts timer struct as parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nvoid timerEnd(hw_timer_t * timer);\n```\n\n----------------------------------------\n\nTITLE: Getting WebUSB Setting - Arduino\nDESCRIPTION: This code snippet demonstrates how to retrieve the current WebUSB setting (enabled or disabled) using the `webUSB` function. This allows you to check if WebUSB functionality is currently active.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_21\n\nLANGUAGE: arduino\nCODE:\n```\nbool webUSB(void);\n```\n\n----------------------------------------\n\nTITLE: Attaching Interrupt to Timer - timerAttachInterrupt (Arduino)\nDESCRIPTION: This function attaches an interrupt to the timer. When the timer triggers, the specified user function is called. The function takes the timer structure and a pointer to the user function as parameters.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/timer.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\nvoid timerAttachInterrupt(hw_timer_t * timer, void (*userFunc)(void));\n```\n\n----------------------------------------\n\nTITLE: Creating Archives for Arduino ESP32\nDESCRIPTION: This snippet defines the recipe for creating archives from object files. It uses the archiver command to combine multiple object files into a single archive file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\nrecipe.ar.pattern=\"{compiler.path}{compiler.ar.cmd}\" {compiler.ar.flags} {compiler.ar.extra_flags} \"{archive_file_path}\" \"{object_file}\"\n```\n\n----------------------------------------\n\nTITLE: Enabling System Service\nDESCRIPTION: This code snippet enables the System service for the node, providing functionalities like reboot, factory reset, and Wi-Fi reset. It must be called after `RMaker.initNode()` and before `RMaker.start()`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t enableSystemService(uint16_t flags, int8_t reboot_seconds, int8_t reset_seconds, int8_t reset_reboot_seconds)\n```\n\n----------------------------------------\n\nTITLE: Adding Binary Data for Encrypted OTA - CMake\nDESCRIPTION: Adds binary data from a PEM file to the ELF file for encrypted OTA (Over-The-Air) updates using CMake's `target_add_binary_data` command.  This is conditionally included based on the `CONFIG_ENABLE_ENCRYPTED_OTA` configuration option. Requires light.elf and esp_image_encryption_key.pem.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(CONFIG_ENABLE_ENCRYPTED_OTA)\n    target_add_binary_data(light.elf \"esp_image_encryption_key.pem\" TEXT)\nendif()\n```\n\n----------------------------------------\n\nTITLE: ESP-IDF Component Registration using CMake\nDESCRIPTION: Registers an ESP-IDF component using the idf_component_register function in CMake. This function configures the build system to include source files from the specified directories and make the include files accessible during compilation.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/hw_cdc_hello_world/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(\n    SRC_DIRS     \".\"\n    INCLUDE_DIRS \".\"\n)\n```\n\n----------------------------------------\n\nTITLE: Getting Device Name - C++\nDESCRIPTION: This snippet shows how to retrieve the name of the device. Each device on the node should have a unique name.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nconst char * getDeviceName();\n```\n\n----------------------------------------\n\nTITLE: Starting LEDC Fade - Arduino\nDESCRIPTION: Sets up and starts a fade effect for a LEDC pin. It accepts the pin number, starting duty, target duty, and maximum fade time in milliseconds as input and returns a boolean indicating success.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\nbool ledcFade(uint8_t pin, uint32_t start_duty, uint32_t target_duty, int max_fade_time_ms);\n```\n\n----------------------------------------\n\nTITLE: Handling Incoming Data - onReceive()\nDESCRIPTION: Callback function to handle incoming data from the peer. This is a virtual method and can be implemented by the upper class for custom handling. Provides a pointer to the data, the length of the data, and a boolean indicating if it's a broadcast.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\nvoid onReceive(const uint8_t *data, int len, bool broadcast);\n```\n\n----------------------------------------\n\nTITLE: Including Relinker - CMake\nDESCRIPTION: Conditionally includes a relinker script if the target is ESP32C2. This inclusion is based on the `CONFIG_IDF_TARGET_ESP32C2` configuration option. Relinker is a tool used to remap the program's memory layout during the linking stage.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(CONFIG_IDF_TARGET_ESP32C2)\n    include(relinker)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Flashing ESP32-C3 via Wi-Fi\nDESCRIPTION: This command flashes the ESP32-C3 device using Wi-Fi with the specified serial port. It sets the default SDK configuration file for ESP32-C3 on a Windows machine.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nidf.py -D SDKCONFIG_DEFAULTS=\"sdkconfig.defaults.esp32c3\" -p com3 flash monitor\n```\n\n----------------------------------------\n\nTITLE: Setting Arduino-ESP32 Branch with Build Script in Bash\nDESCRIPTION: This command executes the `build.sh` script with the `-A` option, which sets the Arduino-ESP32 branch to be used for compilation. Replace `<arduino_branch>` with the desired branch name.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh -A <arduino_branch>\n```\n\n----------------------------------------\n\nTITLE: Conditionally Append OpenThread Requirement - CMake\nDESCRIPTION: This snippet checks the ESP32 target and appends the `openthread` component to the `requires` list if the target is `esp32c6` or `esp32h2`. This allows the OpenThread library to be included into the build only when building for specific ESP32 chips that support it.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CONFIG_ARDUINO_SELECTIVE_COMPILATION OR CONFIG_ARDUINO_SELECTIVE_OpenThread)\n  #if(CONFIG_SOC_IEEE802154_SUPPORTED) # Does not work!\n  #if(CONFIG_OPENTHREAD_ENABLED) # Does not work!\n  if(IDF_TARGET STREQUAL \"esp32c6\" OR IDF_TARGET STREQUAL \"esp32h2\") # Sadly only this works\n    list(APPEND requires openthread)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Python OTA Command\nDESCRIPTION: Defines the command to use Python for Over-The-Air updates. It specifies where the espota.py is and the correct command line arguments.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_9\n\nLANGUAGE: properties\nCODE:\n```\ntools.esptool_py.network_cmd=python3 \"{runtime.platform.path}/tools/espota.py\" -r\ntools.esptool_py.network_cmd.windows=\"{runtime.platform.path}\\tools\\espota.exe\" -r\n\ntools.esp_ota.cmd=python3 \"{runtime.platform.path}/tools/espota.py\" -r\ntools.esp_ota.cmd.windows=\"{runtime.platform.path}\\tools\\espota.exe\" -r\n```\n\n----------------------------------------\n\nTITLE: Getting Product ID - Arduino\nDESCRIPTION: This code snippet shows how to get the Product ID (PID) for the USB device using the `PID` function. It retrieves the current PID, which is a 16-bit identifier representing the device's product.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_5\n\nLANGUAGE: arduino\nCODE:\n```\nuint16_t PID(void);\n```\n\n----------------------------------------\n\nTITLE: Run Test Using QEMU\nDESCRIPTION: This command runs the specified test in the QEMU emulator. It requires the `QEMU_PATH` environment variable to be set to the path of the QEMU binary.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nQEMU_PATH=<path_to_qemu_binary> ./.github/scripts/tests_run.sh -s uart -t esp32c3 -Q\n```\n\n----------------------------------------\n\nTITLE: Stopping USB CDC Peripheral - Arduino\nDESCRIPTION: Deactivates and releases all resources allocated for the USB CDC peripheral. After calling this function, the begin() function must be called again to re-initialize the USB CDC driver before further usage.  This is useful for reconfiguring the USB CDC interface or freeing up resources.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_4\n\nLANGUAGE: arduino\nCODE:\n```\nvoid end();\n```\n\n----------------------------------------\n\nTITLE: Deinitializing ESP Insights in Arduino\nDESCRIPTION: Deinitializes the ESP Insights agent, releasing resources and terminating the connection. This function is used to gracefully shut down the insights functionality. There are no parameters and no return value.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/insights.rst#_snippet_2\n\nLANGUAGE: arduino\nCODE:\n```\nvoid end();\n```\n\n----------------------------------------\n\nTITLE: Flashing ESP32-C6 via Thread (Windows)\nDESCRIPTION: This command flashes the ESP32-C6 device using Thread with the specified serial port. It sets the default SDK configuration file for ESP32-C6 to use Thread networking on Windows.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nidf.py -D SDKCONFIG_DEFAULTS=\"sdkconfig.defaults.c6_thread\" -p com3 flash monitor\n```\n\n----------------------------------------\n\nTITLE: Setting the Build Target with Build Script in Bash\nDESCRIPTION: This command executes the `build.sh` script with the `-t` option to set the build target (chip). Replace `<target>` with the desired target (e.g., `esp32s3`).\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh -t <target>\n```\n\n----------------------------------------\n\nTITLE: esptool.py Upload Configuration\nDESCRIPTION: This configuration defines parameters for uploading firmware via serial communication using esptool.py. It specifies the chip type, serial port, baud rate, and flash-related settings like mode, frequency, and size. It also includes the paths to the bootloader, partitions, and application binaries.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_28\n\nLANGUAGE: properties\nCODE:\n```\ntools.esptool_py.upload.protocol=serial\ntools.esptool_py.upload.params.verbose=\ntools.esptool_py.upload.params.quiet=\ntools.esptool_py.upload.pattern_args=--chip {build.mcu} --port \"{serial.port}\" --baud {upload.speed} {upload.flags} --before default_reset --after hard_reset write_flash {upload.erase_cmd} -z --flash_mode keep --flash_freq keep --flash_size keep {build.bootloader_addr} \"{build.path}/{build.project_name}.bootloader.bin\" 0x8000 \"{build.path}/{build.project_name}.partitions.bin\" 0xe000 \"{runtime.platform.path}/tools/partitions/boot_app0.bin\" 0x10000 \"{build.path}/{build.project_name}.bin\" {upload.extra_flags}\ntools.esptool_py.upload.pattern=\"{path}/{cmd}\" {upload.pattern_args}\n```\n\n----------------------------------------\n\nTITLE: Using Arduino setup() and loop() in main.cpp (C++)\nDESCRIPTION: This code snippet demonstrates how to use the Arduino setup() and loop() functions within an ESP-IDF project. It includes the Arduino.h header file and implements the setup() and loop() functions as you would in a standard Arduino sketch.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n//file: main.cpp\n#include \"Arduino.h\"\n\nvoid setup(){\n  Serial.begin(115200);\n  while(!Serial){\n    ; // wait for serial port to connect\n  }\n}\n\nvoid loop(){\n    Serial.println(\"loop\");\n    delay(1000);\n}\n```\n\n----------------------------------------\n\nTITLE: Getting AP Network ID\nDESCRIPTION: Gets the network ID of the softAP.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\nIPAddress softAPNetworkID();\n```\n\n----------------------------------------\n\nTITLE: Getting Peer Communication Channel - getChannel()\nDESCRIPTION: Retrieves the communication channel of the peer. Returns the communication channel.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nuint8_t getChannel() const;\n```\n\n----------------------------------------\n\nTITLE: Setting Peer Communication Channel - setChannel()\nDESCRIPTION: Sets the communication channel of the peer. Takes the channel as a parameter.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/espnow.rst#_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\nvoid setChannel(uint8_t channel);\n```\n\n----------------------------------------\n\nTITLE: Cleaning Build Files (Linux/macOS)\nDESCRIPTION: This command removes build artifacts, managed components, SDK configuration, and dependency lock files. It is used to ensure a clean build environment on Linux and macOS systems before flashing.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nrm -rf build managed_components sdkconfig dependencies.lock\n```\n\n----------------------------------------\n\nTITLE: Run Test Using Wokwi\nDESCRIPTION: This command runs the specified test in the Wokwi simulator. It requires the `WOKWI_CLI_TOKEN` environment variable to be set. The `<timeout_in_ms>` parameter specifies the timeout for the simulation in milliseconds.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nWOKWI_CLI_TOKEN=<your_wokwi_token> ./.github/scripts/tests_run.sh -s uart -t esp32c3 -W <timeout_in_ms>\n```\n\n----------------------------------------\n\nTITLE: dfu-util Upload Configuration\nDESCRIPTION: This configuration defines parameters for uploading sketches via DFU (Device Firmware Upgrade) using dfu-util. It specifies the path to the dfu-util executable, device VID/PID, and the path to the binary file. It uses specific dfu-util command-line options for uploading.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_34\n\nLANGUAGE: properties\nCODE:\n```\ntools.dfu-util.path={runtime.tools.dfu-util-0.11.0-arduino5.path}\ntools.dfu-util.cmd=dfu-util\ntools.dfu-util.upload.params.verbose=-d\ntools.dfu-util.upload.params.quiet=\ntools.dfu-util.upload.pattern=\"{path}/{cmd}\" --device {vid.0}:{pid.0} -D \"{build.path}/{build.project_name}.bin\" -Q\n```\n\n----------------------------------------\n\nTITLE: Enabling Reboot via DTR/RTS - Arduino\nDESCRIPTION: Enables or disables the ability to reboot the device using the DTR and RTS signals. If enabled, toggling the DTR/RTS lines from the host can trigger a device reset. This is useful for remote firmware updates or debugging.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb_cdc.rst#_snippet_13\n\nLANGUAGE: arduino\nCODE:\n```\nvoid enableReboot(bool enable);\n```\n\n----------------------------------------\n\nTITLE: Writing LEDC Note - Arduino\nDESCRIPTION: Sets up an LEDC pin to a specific musical note. It takes the pin number, note (note_t enum), and octave as input and returns the configured frequency. note_t values include NOTE_C, NOTE_Cs, NOTE_D, NOTE_Eb, NOTE_E, NOTE_F, NOTE_Fs, NOTE_G, NOTE_Gs, NOTE_A, NOTE_Bb, and NOTE_B.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/ledc.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\nuint32_t ledcWriteNote(uint8_t pin, note_t note, uint8_t octave);\n```\n\n----------------------------------------\n\nTITLE: Setting LED GPIO Pin\nDESCRIPTION: This code snippet demonstrates how to set the LED GPIO pin by changing the `LED_PIN` definition. The default value is set to `RGB_BUILTIN`. This configuration is crucial for controlling the LED that represents the color dimmable light.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/Zigbee/examples/Zigbee_Color_Dimmable_Light/README.md#_snippet_0\n\nLANGUAGE: Arduino\nCODE:\n```\nSet the LED GPIO by changing the `LED_PIN` definition. By default, the LED_PIN is `RGB_BUILTIN`.\n```\n\n----------------------------------------\n\nTITLE: Cleaning Build Files (Windows)\nDESCRIPTION: This command removes build artifacts, managed components, SDK configuration, and dependency lock files. It is used to ensure a clean build environment on Windows systems before flashing.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nrmdir /s/q build managed_components && del sdkconfig dependencies.lock\n```\n\n----------------------------------------\n\nTITLE: Computing Size of Arduino ESP32 ELF\nDESCRIPTION: This snippet calculates the size of different sections of the ELF file. It uses the size command and regular expressions to extract the sizes of code and data sections.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\nrecipe.size.pattern=\"{compiler.path}{compiler.size.cmd}\" -A \"{build.path}/{build.project_name}.elf\"\nrecipe.size.regex=^(?:\\.iram0\\.text|\\.iram0\\.vectors|\\.dram0\\.data|\\.dram1\\.data|\\.flash\\.text|\\.flash\\.rodata|\\.flash\\.appdesc|\\.flash\\.init_array|\\.eh_frame)\\s+([0-9]+).*\nrecipe.size.regex.data=^(?:\\.dram0\\.data|\\.dram0\\.bss|\\.dram1\\.data|\\.dram1\\.bss|\\.noinit)\\s+([0-9]+).*\n```\n\n----------------------------------------\n\nTITLE: Failed File Upload Log\nDESCRIPTION: This output logs a failed file upload due to insufficient space. It includes an error message from the LittleFS library and an indication that the write operation failed.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/WebServer/README.md#_snippet_9\n\nLANGUAGE: txt\nCODE:\n```\nstarting upload file /huge.jpg...\n./components/esp_littlefs/src/littlefs/lfs.c:584:error: No more free space 531\n  write error!\nfinished.\n```\n\n----------------------------------------\n\nTITLE: WiFi Scan Complete - Arduino\nDESCRIPTION: This function checks the scan complete state in Async mode. A successful operation will return a `int16_t`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_39\n\nLANGUAGE: arduino\nCODE:\n```\nint16_t scanComplete();\n```\n\n----------------------------------------\n\nTITLE: Including Wire Library - Arduino\nDESCRIPTION: Includes the Wire.h header file, which provides the necessary functions for I2C communication in Arduino. This is a prerequisite for using the I2C functionality.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_8\n\nLANGUAGE: arduino\nCODE:\n```\n#include \"Wire.h\"\n```\n\n----------------------------------------\n\nTITLE: Cloning the ESP32 Arduino Lib Builder in Bash\nDESCRIPTION: This command clones the ESP32 Arduino Library Builder repository from GitHub using `git`. This is the first step in installing the library builder.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/espressif/esp32-arduino-lib-builder\n```\n\n----------------------------------------\n\nTITLE: Write a Single Byte to I2S Interface (Arduino)\nDESCRIPTION: This snippet illustrates how to write a single byte to the I2S interface using the `write()` method. It takes the byte to write as input and returns 1 if successful, or 0 if an error occurred.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_20\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t write(uint8_t d)\n```\n\n----------------------------------------\n\nTITLE: esptool.py Erase Flash Configuration\nDESCRIPTION: This configuration defines the parameters for erasing the entire flash memory using esptool.py. It specifies the chip type, serial port, baud rate, and the erase_flash command. This is typically done before burning the bootloader.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_30\n\nLANGUAGE: properties\nCODE:\n```\ntools.esptool_py.erase.protocol=serial\ntools.esptool_py.erase.params.verbose=\ntools.esptool_py.erase.params.quiet=\ntools.esptool_py.erase.pattern_args=--chip {build.mcu} --port \"{serial.port}\" --baud {upload.speed} {upload.flags} --before default_reset --after hard_reset erase_flash\ntools.esptool_py.erase.pattern=\"{path}/{cmd}\" {erase.pattern_args}\n```\n\n----------------------------------------\n\nTITLE: Starting ADC Continuous Conversion Using analogContinuousStart (Arduino)\nDESCRIPTION: This snippet demonstrates starting ADC continuous conversions using `analogContinuousStart`. It returns true if the ADC continuous mode is successfully started, and false otherwise.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_9\n\nLANGUAGE: arduino\nCODE:\n```\nbool analogContinuousStart();\n```\n\n----------------------------------------\n\nTITLE: Defining SPI Datatype Keyword for Syntax Coloring\nDESCRIPTION: This snippet defines the 'SPI' keyword for syntax coloring purposes. It allows the IDE or text editor to highlight 'SPI' as a datatype within Arduino-ESP32 code, improving readability.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/SPI/keywords.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nSPI\tKEYWORD1\n```\n\n----------------------------------------\n\nTITLE: Getting Serial Number - Arduino\nDESCRIPTION: This code snippet demonstrates how to get the serial number of the USB device using the `serialNumber` function. It returns a constant character pointer to the serial number string.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_27\n\nLANGUAGE: arduino\nCODE:\n```\nconst char * serialNumber(void);\n```\n\n----------------------------------------\n\nTITLE: Populating Library Sources/Includes/Requires - CMake\nDESCRIPTION: This CMake loop iterates through a list of Arduino libraries (`ARDUINO_ALL_LIBRARIES`). It conditionally appends source files, requirements, and include directories to corresponding lists based on whether selective compilation is enabled and whether the specific library is selected.  It checks if a `src` directory exists for the library before adding its include path.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(ARDUINO_LIBRARIES_SRCS)\nset(ARDUINO_LIBRARIES_REQUIRES)\nset(ARDUINO_LIBRARIES_INCLUDEDIRS)\nforeach(libname IN LISTS ARDUINO_ALL_LIBRARIES)\n  if(NOT CONFIG_ARDUINO_SELECTIVE_COMPILATION OR CONFIG_ARDUINO_SELECTIVE_${libname})\n    if(ARDUINO_LIBRARY_${libname}_SRCS)\n      list(APPEND ARDUINO_LIBRARIES_SRCS ${ARDUINO_LIBRARY_${libname}_SRCS})\n    endif()\n    if(ARDUINO_LIBRARY_${libname}_REQUIRES)\n      list(APPEND ARDUINO_LIBRARIES_REQUIRES ${ARDUINO_LIBRARY_${libname}_REQUIRES})\n    endif()\n    if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/libraries/${libname}/src)\n      list(APPEND ARDUINO_LIBRARIES_INCLUDEDIRS libraries/${libname}/src)\n    endif()\n  endif()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: esptool.py Program Application Configuration\nDESCRIPTION: This configuration sets up esptool.py for programming the application binary. It includes parameters for the chip type, serial port, baud rate, and flash address. The main function is to write the application binary to the flash memory at a specific address.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_29\n\nLANGUAGE: properties\nCODE:\n```\ntools.esptool_py.program.params.verbose=\ntools.esptool_py.program.params.quiet=\ntools.esptool_py.program.pattern_args=--chip {build.mcu} --port \"{serial.port}\" --baud {upload.speed} {upload.flags} --before default_reset --after hard_reset write_flash -z --flash_mode keep --flash_freq keep --flash_size keep 0x10000 \"{build.path}/{build.project_name}.bin\"\ntools.esptool_py.program.pattern=\"{path}/{cmd}\" {program.pattern_args}\n```\n\n----------------------------------------\n\nTITLE: Adding Node Attribute - C++\nDESCRIPTION: This snippet demonstrates how to add a new attribute as metadata to the node. Only string values are allowed. The function returns ESP_OK on success and an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nesp_err_t addNodeAttr(const char *attr_name, const char *val);\n```\n\n----------------------------------------\n\nTITLE: Defining slaveWrite function for ESP32 I2C\nDESCRIPTION: This snippet defines the `slaveWrite` function, which is specific to the ESP32 and is used for writing data in I2C slave mode. This function should not be used for ESP32-S2 or ESP32-C3. The function takes a pointer to a byte array and the size of the array as input, returning the number of bytes written.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_26\n\nLANGUAGE: arduino\nCODE:\n```\nsize_t slaveWrite(const uint8_t *, size_t);\n```\n\n----------------------------------------\n\nTITLE: Registering Component with idf_component_register in CMake\nDESCRIPTION: This snippet shows how to register a custom component in an ESP-IDF project using CMake. It defines the source files, include directories, and required dependencies, specifically arduino-esp32. This configuration is required to properly integrate the custom library into the project build process.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/hello_world/README.md#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS \"user_library.cpp\" \"another_source.c\"\n                      INCLUDE_DIRS \".\"\n                      REQUIRES arduino-esp32\n                      )\n```\n\n----------------------------------------\n\nTITLE: Finding source files for the library (Bash)\nDESCRIPTION: This command finds all .c and .cpp files in the source directory of the new library. The output of this command needs to be added to the Arduino's CMakeLists.txt file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nfind libraries/new_library/src/ -name '*.c' -o -name '*.cpp'\n  libraries/new_library/src/new_library.cpp\n  libraries/new_library/src/new_library_extra_file.c\n```\n\n----------------------------------------\n\nTITLE: Defining WiFi Datatypes\nDESCRIPTION: Defines various WiFi-related datatypes as KEYWORD1. These types are likely class names or structures used for network operations within the WiFi library, and will be highlighted to differentiate them from other code elements.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/keywords.txt#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nWiFi\tKEYWORD1\nNetworkClient\tKEYWORD1\nNetworkServer\tKEYWORD1\nNetworkUDP\tKEYWORD1\nNetworkClientSecure\tKEYWORD1\n```\n\n----------------------------------------\n\nTITLE: 4MB With OTA Partition Table Example\nDESCRIPTION: This code snippet shows an example of a partition table configuration for a 4MB flash with OTA support. It defines partitions for NVS, OTA data, and two application partitions for OTA updates (app0, app1).\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/partition_table.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n# Name,   Type, SubType, Offset,  Size, Flags\nnvs,      data, nvs,     36K,     20K,\notadata,  data, ota,     56K,     8K,\napp0,     app,  ota_0,   64K,     1900K,\napp1,     app,  ota_1,   ,        1900K,\n```\n\n----------------------------------------\n\nTITLE: Example Log Output\nDESCRIPTION: This is an example of the log output typically observed when an ESP32 device starts up. It includes information about the reset cause, boot mode, clock configuration, memory loading, chip model, number of cores, and chip ID.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/ESP32/examples/Template/ExampleTemplate/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nets Jul 29 2019 12:21:46\n\nrst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)\nconfigsip: 0, SPIWP:0xee\nclk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00\nmode:DIO, clock div:1\nload:0x3fff0030,len:1412\nload:0x40078000,len:13400\nload:0x40080400,len:3672\nentry 0x400805f8\nESP32 Chip model = ESP32-D0WDQ5 Rev 3\nThis chip has 2 cores\nChip ID: 3957392\n```\n\n----------------------------------------\n\nTITLE: Copyright Disclaimer Sample\nDESCRIPTION: This code snippet shows a sample copyright disclaimer that an employer or school can sign to relinquish copyright interest in the library. It requires customization with the employer/school name, library name, author's name, and authorized signature.  This is important to do in cases where an individual develops the software as part of their employment.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/LICENSE.md#_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\n    Yoyodyne, Inc., hereby disclaims all copyright interest in\n    the library `Frob' (a library for tweaking knobs) written\n    by James Random Hacker.\n\n    signature of Ty Coon, 1 April 1990\n    Ty Coon, President of Vice\n```\n\n----------------------------------------\n\nTITLE: Example: UART test execution and pytest output\nDESCRIPTION: This is the output from the pytest framework running the UART test on the ESP32-C3 target. It shows the test session starting, selecting the UART test, and passing it.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_14\n\nLANGUAGE: text\nCODE:\n```\nlucassvaz@Lucas--MacBook-Pro esp32 % ./.github/scripts/tests_run.sh -s uart -t esp32c3\nSketch uart test type: validation\nRunning test: uart -- Config: Default\npytest tests --build-dir /Users/lucassvaz/.arduino/tests/esp32c3/uart/build.tmp -k test_uart --junit-xml=/Users/lucassvaz/Espressif/Arduino/hardware/espressif/esp32/tests/validation/uart/esp32c3/uart.xml --embedded-services esp,arduino\n=============================================================================================== test session starts ================================================================================================\nplatform darwin -- Python 3.12.3, pytest-8.2.2, pluggy-1.5.0\nrootdir: /Users/lucassvaz/Espressif/Arduino/hardware/espressif/esp32/tests\nconfigfile: pytest.ini\nplugins: cov-5.0.0, embedded-1.11.5, anyio-4.4.0\ncollected 15 items / 14 deselected / 1 selected\n\ntests/validation/uart/test_uart.py::test_uart\n-------------------------------------------------------------------------------------------------- live log setup --------------------------------------------------------------------------------------------------\n2024-08-22 11:49:30 INFO Target: esp32c3, Port: /dev/cu.usbserial-2120\nPASSED                                                                                                                                                                                                       [100%]\n------------------------------------------------------------------------------------------------ live log teardown -------------------------------------------------------------------------------------------------\n2024-08-22 11:49:52 INFO Created unity output junit report: /private/var/folders/vp/g9wctsvn7b91k3pv_7cwpt_h0000gn/T/pytest-embedded/2024-08-22_14-49-30-392993/test_uart/dut.xml\n\n\n---------------------------------------------- generated xml file: /Users/lucassvaz/Espressif/Arduino/hardware/espressif/esp32/tests/validation/uart/esp32c3/uart.xml ----------------------------------------------\n======================================================================================== 1 passed, 14 deselected in 22.18s =========================================================================================\n```\n\n----------------------------------------\n\nTITLE: SD card mount fail error message\nDESCRIPTION: Example output of a SD card mount failed error.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/troubleshooting.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n[ 1065][E][sd_diskio.cpp:807] sdcard_mount(): f_mount failed: (3) The physical drive cannot work\n```\n\n----------------------------------------\n\nTITLE: Peek Next Byte from I2S Interface (Arduino)\nDESCRIPTION: This snippet demonstrates how to peek at the next available byte from the I2S interface without removing it from the buffer using the `peek()` method. Currently, this function is not fully implemented and always returns -1. No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_22\n\nLANGUAGE: arduino\nCODE:\n```\nint peek()\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories, Sources, Requires - CMake\nDESCRIPTION: This snippet defines CMake variables for include directories, source files, and required components. It combines core and library-specific sources and include directories. It also defines private include directories and requires and private requires components.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(includedirs variants/${CONFIG_ARDUINO_VARIANT}/ cores/esp32/ ${ARDUINO_LIBRARIES_INCLUDEDIRS})\nset(srcs ${CORE_SRCS} ${ARDUINO_LIBRARIES_SRCS})\nset(priv_includes cores/esp32/libb64)\nset(requires spi_flash esp_partition mbedtls wpa_supplicant esp_adc esp_eth http_parser esp_ringbuf esp_driver_gptimer esp_driver_usb_serial_jtag driver)\nset(priv_requires fatfs nvs_flash app_update spiffs bootloader_support bt esp_hid usb esp_psram ${ARDUINO_LIBRARIES_REQUIRES})\n```\n\n----------------------------------------\n\nTITLE: Getting USB Attributes - Arduino\nDESCRIPTION: This code snippet demonstrates how to retrieve the currently configured USB attributes using the `usbAttributes` function. These attributes describe various aspects of the device's configuration.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_19\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t usbAttributes(void);\n```\n\n----------------------------------------\n\nTITLE: Getting USB Protocol - Arduino\nDESCRIPTION: This code snippet demonstrates how to retrieve the currently configured USB protocol using the `usbProtocol` function. The protocol specifies the data communication rules used by the USB device.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_17\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t usbProtocol(void);\n```\n\n----------------------------------------\n\nTITLE: Build Documentation\nDESCRIPTION: This code snippet shows how to build the documentation using the build-docs script. The -l en option specifies that the documentation should be built for the English language. The generated HTML files are placed in the `_build/en/generic/html` folder.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/docs_contributing.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbuild-docs -l en\n```\n\n----------------------------------------\n\nTITLE: Get RX Data Width (Arduino)\nDESCRIPTION: This snippet illustrates how to get the receive (RX) data width using the `rxDataWidth()` method of the I2SClass. The data width represents the number of bits per sample (e.g., 8, 16, or 32 bits). No parameters are required.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_15\n\nLANGUAGE: arduino\nCODE:\n```\ni2s_data_bit_width_t rxDataWidth()\n```\n\n----------------------------------------\n\nTITLE: Define Methods and Functions for Ultrasound\nDESCRIPTION: This section defines the methods and functions used in the Ultrasound component, categorizing them as KEYWORD2 for syntax highlighting. These include functions related to connection management, data transmission, and reception.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/AsyncUDP/keywords.txt#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nconnect\tKEYWORD2\nconnected\tKEYWORD2\nlisten\tKEYWORD2\nlistenMulticast\tKEYWORD2\nclose\tKEYWORD2\nwrite\tKEYWORD2\nspace\tKEYWORD2\nflush\tKEYWORD2\nisBroadcast\tKEYWORD2\nisMulticast\tKEYWORD2\nisIPv6\tKEYWORD2\ninterface\tKEYWORD2\nlocalIPv6\tKEYWORD2\nremoteIPv6\tKEYWORD2\nremoteMac\tKEYWORD2\nsend\tKEYWORD2\npeek\tKEYWORD2\navailable\tKEYWORD2\nwriteTo\tKEYWORD2\nbroadcastTo\tKEYWORD2\nsendTo\tKEYWORD2\nbroadcast\tKEYWORD2\nonPacket\tKEYWORD2\ndata\tKEYWORD2\nlength\tKEYWORD2\nlocalIP\tKEYWORD2\nlocalPort\tKEYWORD2\nremoteIP\tKEYWORD2\nremotePort\tKEYWORD2\nlistenIP\tKEYWORD2\nlistenIPv6\tKEYWORD2\nlastErr\tKEYWORD2\n_s_recv\tKEYWORD2\n```\n\n----------------------------------------\n\nTITLE: Initializing I2C without Pin Assignment - Arduino\nDESCRIPTION: This code snippet initializes the I2C bus using the default SDA and SCL pins defined within the Arduino Wire library. It is similar to the Arduino Uno approach where I2C pins are predefined.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/io_mux.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nvoid setup()\n{\n    Wire.begin(); // join i2c bus (address optional for master)\n}\n```\n\n----------------------------------------\n\nTITLE: Set SoftAP Hostname - Arduino\nDESCRIPTION: This function sets the hostname for the ESP32 access point (AP). It takes a const char* as input, representing the desired hostname.  A successful configuration will return `true`.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst#_snippet_19\n\nLANGUAGE: arduino\nCODE:\n```\nbool softAPsetHostname(const char * hostname);\n```\n\n----------------------------------------\n\nTITLE: Example: Build UART Test for ESP32-C3\nDESCRIPTION: This command builds the UART test specifically for the ESP32-C3 target. It utilizes the `tests_build.sh` script to compile the associated sketch.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n./.github/scripts/tests_build.sh -s uart -t esp32c3\n```\n\n----------------------------------------\n\nTITLE: Defining WiFi Methods and Functions\nDESCRIPTION: Defines WiFi-related methods and functions as KEYWORD2. These are the functions available within the WiFi library for performing various network operations such as connecting, reading data, configuring settings, etc.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/keywords.txt#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nstatus\tKEYWORD2\nmode\tKEYWORD2\nconnect\tKEYWORD2\nwrite\tKEYWORD2\navailable\tKEYWORD2\nconfig\tKEYWORD2\nsetDNS\tKEYWORD2\nread\tKEYWORD2\nflush\tKEYWORD2\nstop\tKEYWORD2\nconnected\tKEYWORD2\nbegin\tKEYWORD2\nbeginMulticast\tKEYWORD2\ndisconnect\tKEYWORD2\nmacAddress\tKEYWORD2\nlocalIP\tKEYWORD2\nsubnetMask\tKEYWORD2\ngatewayIP\tKEYWORD2\nSSID\tKEYWORD2\npsk\tKEYWORD2\nBSSID\t\tKEYWORD2\nRSSI\tKEYWORD2\nencryptionType\tKEYWORD2\nbeginPacket\tKEYWORD2\nbeginPacketMulticast\tKEYWORD2\nendPacket\tKEYWORD2\nparsePacket\tKEYWORD2\ndestinationIP\tKEYWORD2\nremoteIP\tKEYWORD2\nremotePort\tKEYWORD2\nsoftAP\tKEYWORD2\nsoftAPIP\tKEYWORD2\nsoftAPmacAddress\tKEYWORD2\nsoftAPConfig\tKEYWORD2\nprintDiag\tKEYWORD2\nhostByName\tKEYWORD2\nscanNetworks\tKEYWORD2\n```\n\n----------------------------------------\n\nTITLE: Ending I2C Transmission with Stop - Arduino\nDESCRIPTION: Ends an I2C transmission to the slave device. The `sendStop` parameter controls whether a stop signal is sent at the end of the transmission. Returns an error code.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2c.rst#_snippet_17\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t endTransmission(bool sendStop);\n```\n\nLANGUAGE: arduino\nCODE:\n```\nuint8_t endTransmission(void);\n```\n\n----------------------------------------\n\nTITLE: Deinitializing I2S - Arduino\nDESCRIPTION: This function deinitializes the I2S peripheral. It frees buffers, destroys tasks, and ends the driver operation. This function should be called to safely disable the I2S peripheral and release associated resources.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/i2s.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nvoid end()\n```\n\n----------------------------------------\n\nTITLE: Registering Inline Function for Static Content\nDESCRIPTION: Registers an inline (lambda) function to send static HTML content from a string when the `/upload.htm` URL is requested. The content is retrieved from the `uploadContent` string, defined in `builtinfiles.h`, and sent to the client with the `text/html` content type.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/WebServer/README.md#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nserver.on(\"/$upload.htm\", []() {\n  server.send(200, \"text/html\", FPSTR(uploadContent));\n});\n```\n\n----------------------------------------\n\nTITLE: Reset Reason Example - Arduino\nDESCRIPTION: This Arduino sketch demonstrates how to retrieve and utilize the reset reason information on the ESP32. It requires the ESP32 Arduino core library. The code shows how to access and print the reset reason.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/reset_reason.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\n#include <Arduino.h>\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);\n\n  esp_reset_reason_t reset_reason = esp_reset_reason();\n\n  Serial.print(\"Reset reason: \");\n  Serial.println(reset_reason);\n\n  // You can also print the reset reason as a string:\n  //Serial.print(\"Reset reason string: \");\n  //Serial.println(esp_reset_reason_string(reset_reason));\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  delay(1000);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom I2C Pins - Arduino\nDESCRIPTION: This code snippet demonstrates how to configure custom SDA and SCL pins for the I2C bus in ESP32 using the `Wire.setPins()` function. This function must be called before `Wire.begin()` to ensure the I2C bus uses the specified pins.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/tutorials/io_mux.rst#_snippet_1\n\nLANGUAGE: arduino\nCODE:\n```\nint sda_pin = 16; // GPIO16 as I2C SDA\nint scl_pin = 17; // GPIO17 as I2C SCL\n\nvoid setup()\n{\n    Wire.setPins(sda_pin, scl_pin); // Set the I2C pins before begin\n    Wire.begin(); // join i2c bus (address optional for master)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Node Attribute\nDESCRIPTION: This code snippet adds a new attribute to the node's metadata.  Only string values are allowed for node attributes.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_11\n\nLANGUAGE: arduino\nCODE:\n```\nesp_err_t addNodeAttr(const char *attr_name, const char *val);\n```\n\n----------------------------------------\n\nTITLE: ADC Continuous Data Structure (Arduino)\nDESCRIPTION: This code defines the structure used to store the results of the ADC continuous readings. It includes the pin, channel, average raw data, and average voltage in mV.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/adc.rst#_snippet_7\n\nLANGUAGE: arduino\nCODE:\n```\ntypedef struct {\n        uint8_t pin;           /*!<ADC pin */\n        uint8_t channel;       /*!<ADC channel */\n        int avg_read_raw;      /*!<ADC average raw data */\n        int avg_read_mvolts;   /*!<ADC average voltage in mV */\n    } adc_continuous_data_t;\n```\n\n----------------------------------------\n\nTITLE: Enabling WebUSB - Arduino\nDESCRIPTION: This code snippet demonstrates how to enable or disable the WebUSB functionality using the `webUSB` function. WebUSB allows web pages to directly communicate with USB devices. It takes a boolean value as input and returns a boolean indicating success or failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/usb.rst#_snippet_20\n\nLANGUAGE: arduino\nCODE:\n```\nbool webUSB(bool enabled);\n```\n\n----------------------------------------\n\nTITLE: Getting Node Info\nDESCRIPTION: This code snippet retrieves a pointer to the node_info_t structure, which contains information configured during node initialization, such as name, type, firmware version and model.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rainmaker.rst#_snippet_10\n\nLANGUAGE: arduino\nCODE:\n```\nnode_info_t * getNodeInfo();\n```\n\n----------------------------------------\n\nTITLE: RMT Write RGB LED Example - Arduino\nDESCRIPTION: This Arduino sketch demonstrates how to use the RMT (Remote Control Transceiver) peripheral on the ESP32 to control an RGB LED. It requires the ESP32 Arduino core and utilizes the RMT library. The example outputs PWM signals to the RGB LED pins based on predefined color patterns.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/rmt.rst#_snippet_0\n\nLANGUAGE: arduino\nCODE:\n```\nRMTWrite_RGB_LED.ino content (from file ../../../libraries/ESP32/examples/RMT/RMTWrite_RGB_LED/RMTWrite_RGB_LED.ino)\n```\n\n----------------------------------------\n\nTITLE: Copying ESP_SR Model for Arduino ESP32\nDESCRIPTION: This snippet copies the ESP_SR model binary if the ESP_SR library is present. It uses bash on Linux and CMD on Windows to copy the `srmodels.bin` file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\nrecipe.hooks.objcopy.postobjcopy.2.pattern=/usr/bin/env bash -c \"[ ! -d \\\"{build.path}\\\"/libraries/ESP_SR ] || [ ! -f \\\"{compiler.sdk.path}\\\"/esp_sr/srmodels.bin ] || cp -f \\\"{compiler.sdk.path}\\\"/esp_sr/srmodels.bin \\\"{build.path}\\\"/srmodels.bin\"\nrecipe.hooks.objcopy.postobjcopy.2.pattern.windows=cmd /c if exist \"{build.path}\\libraries\\ESP_SR\" if exist \"{compiler.sdk.path}\\esp_sr\\srmodels.bin\" COPY /y \"{compiler.sdk.path}\\esp_sr\\srmodels.bin\" \"{build.path}\\srmodels.bin\"\n```\n\n----------------------------------------\n\nTITLE: Printing ESP32 Arduino Core Version in C++\nDESCRIPTION: This code snippet shows how to print the ESP32 Arduino core version at runtime using the `ESP_ARDUINO_VERSION_STR` macro. It uses `Serial.printf` to output the version string to the serial port. This allows developers to easily check the core version being used in their applications.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/core_compatibility.rst#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nSerial.printf(\" ESP32 Arduino core version: %s\\n\", ESP_ARDUINO_VERSION_STR);\n```\n\n----------------------------------------\n\nTITLE: Markdown Table for Target Support\nDESCRIPTION: This snippet shows a Markdown table used in a README.md file to indicate which ESP32 targets are supported by a particular example. It gives a clear overview of the compatibility of the example across different ESP32 variants.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/contributing.rst#_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\nCurrently, this example requires Wi-Fi and supports the following targets.\n\n| Supported Targets | ESP32 | ESP32-S3 | ESP32-C3 | ESP32-C6 |\n| ----------------- | ----- | -------- | -------- | -------- |\n```\n\n----------------------------------------\n\nTITLE: Deinitializing RainMaker Node - C++\nDESCRIPTION: This snippet shows how to deinitialize the ESP RainMaker agent and the node created using RMaker.initNode(). It takes a Node object as input and returns ESP_OK on success and an error code on failure.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/RainMaker/README.md#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nesp_err_t deinitNode(Node node)\n```\n\n----------------------------------------\n\nTITLE: Creating Merged Binary for Arduino ESP32\nDESCRIPTION: This snippet merges multiple binary files (bootloader, partition table, application binary) into a single merged binary file.  It utilizes esptool.py's merge_bin functionality to combine the binaries at specified addresses.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\nrecipe.hooks.objcopy.postobjcopy.3.pattern_args=--chip {build.mcu} merge_bin -o \"{build.path}/{build.project_name}.merged.bin\" --fill-flash-size {build.flash_size} --flash_mode keep --flash_freq keep --flash_size keep {build.bootloader_addr} \"{build.path}/{build.project_name}.bootloader.bin\" 0x8000 \"{build.path}/{build.project_name}.partitions.bin\" 0xe000 \"{runtime.platform.path}/tools/partitions/boot_app0.bin\" 0x10000 \"{build.path}/{build.project_name}.bin\"\nrecipe.hooks.objcopy.postobjcopy.3.pattern=\"{tools.esptool_py.path}/{tools.esptool_py.cmd}\" {recipe.hooks.objcopy.postobjcopy.3.pattern_args}\n```\n\n----------------------------------------\n\nTITLE: Creating project from template with Arduino component (Bash)\nDESCRIPTION: This command creates a new ESP-IDF project from a template that includes the Arduino component. It provides a quick way to start a new project with the Arduino framework already integrated.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nidf.py create-project-from-example \"espressif/arduino-esp32^3.0.2:hello_world\"\n```\n\n----------------------------------------\n\nTITLE: Building the Libraries with Build Script in Bash\nDESCRIPTION: This command executes the `build.sh` script to build the libraries. The script handles dependencies and compilation based on the default configuration.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/lib_builder.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh\n```\n\n----------------------------------------\n\nTITLE: Install Xcode Command Line Tools - Bash\nDESCRIPTION: This command installs the Xcode command-line tools on macOS. This is necessary to resolve potential errors related to missing developer paths during the installation of Arduino-ESP32.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/installing.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nxcode-select --install\n```\n\n----------------------------------------\n\nTITLE: Setting Python Insights Package Generation Command\nDESCRIPTION: Defines the command to generate insights packages using Python. It specifies where the gen_insights_package.py is and the correct command line arguments.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/platform.txt#_snippet_11\n\nLANGUAGE: properties\nCODE:\n```\ntools.gen_insights_pkg.cmd=python3 \"{runtime.platform.path}\"/tools/gen_insights_package.py\ntools.gen_insights_pkg.cmd.windows=\"{runtime.platform.path}\\tools\\gen_insights_package.exe\"\n```\n\n----------------------------------------\n\nTITLE: Including a Code Example with literalinclude\nDESCRIPTION: This reStructuredText snippet demonstrates how to embed an Arduino code example using the `literalinclude` directive. It specifies the path to the example file and the programming language.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/docs_contributing.rst#_snippet_5\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. literalinclude:: ../../../libraries/WiFi/examples/WiFiAccessPoint/WiFiAccessPoint.ino\n    :language: arduino\n```\n\n----------------------------------------\n\nTITLE: CMakeLists.txt for a local library\nDESCRIPTION: This is the CMakeLists.txt file for a local arduino library.  It registers the component, defines source files, include directories, and dependencies.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/esp-idf_component.rst#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS \"new_library.cpp\" \"another_source.c\"\n                      INCLUDE_DIRS \".\"\n                      REQUIRES arduino-esp32\n                      )\n```\n\n----------------------------------------\n\nTITLE: Adding Compile Options for ESP-IDF Component\nDESCRIPTION: This snippet adds a private compile option to the component's library. The compile option defines the macro `CHIP_HAVE_CONFIG_H`, which is likely used to conditionally include or exclude code based on the presence of a configuration header file.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/esp_matter_light/main/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(${COMPONENT_LIB} PRIVATE \"-DCHIP_HAVE_CONFIG_H\")\n```\n\n----------------------------------------\n\nTITLE: Successful File Upload Log\nDESCRIPTION: This output shows a log indicating the start and end of the upload process, along with the number of bytes successfully uploaded.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/WebServer/README.md#_snippet_8\n\nLANGUAGE: txt\nCODE:\n```\nstarting upload file /file.txt...\nfinished.\n1652 bytes uploaded.\n```\n\n----------------------------------------\n\nTITLE: Code Block Structure in reStructuredText\nDESCRIPTION: This shows the basic reStructuredText structure for adding a code block, indicating the language and a simple code example.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/docs/en/guides/docs_contributing.rst#_snippet_6\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. code-block:: arduino\n    bool begin(); //Code example\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version - CMake\nDESCRIPTION: Specifies the minimum required version of CMake for the project build. This ensures that the build system has the necessary features and capabilities to process the CMakeLists.txt file correctly. It is crucial for maintaining compatibility across different development environments.\nSOURCE: https://github.com/espressif/arduino-esp32/blob/master/idf_component_examples/hw_cdc_hello_world/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```"
  }
]