[
  {
    "owner": "cline",
    "repo": "linear-mcp",
    "content": "TITLE: Implementing Handler Architecture in TypeScript\nDESCRIPTION: This code snippet demonstrates the handler architecture for MCP tool operations, showing the base handler with shared functionality, feature-specific handlers extending the base, and a factory for managing handlers. This design provides a clean separation of concerns.\nSOURCE: https://github.com/cline/linear-mcp/blob/main/architecture.md#2025-04-15_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Base handler with shared functionality\nabstract class BaseHandler {\n  protected verifyAuth(): LinearGraphQLClient;\n  protected createResponse(text: string): BaseToolResponse;\n  protected createJsonResponse(data: unknown): BaseToolResponse;\n  protected handleError(error: unknown, operation: string): never;\n  protected validateRequiredParams(params: Record<string, unknown>, required: string[]): void;\n}\n\n// Feature-specific handlers extend the base\nclass IssueHandler extends BaseHandler {\n  handleCreateIssue(args: any): Promise<BaseToolResponse>;\n  handleSearchIssues(args: any): Promise<BaseToolResponse>;\n  // ... other issue operations\n}\n\n// Factory for managing handlers\nclass HandlerFactory {\n  private authHandler: AuthHandler;\n  private issueHandler: IssueHandler;\n  // ... other handlers\n\n  getHandlerForTool(toolName: string): { handler: BaseHandler; method: string };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Layer in TypeScript\nDESCRIPTION: This code snippet shows the GraphQL layer implementation that provides domain-specific operations with atomic and composite patterns. It demonstrates how to execute GraphQL operations, perform atomic operations, and build composite operations from atomic ones.\nSOURCE: https://github.com/cline/linear-mcp/blob/main/architecture.md#2025-04-15_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nclass LinearGraphQLClient {\n  // Execute GraphQL operations\n  async execute<T>(document: DocumentNode, variables?: any): Promise<T>;\n  \n  // Atomic operations\n  async createProject(input: ProjectInput): Promise<ProjectResponse>;\n  async createBatchIssues(issues: CreateIssueInput[]): Promise<IssueBatchResponse>;\n  \n  // Composite operations (built from atomic operations)\n  async createProjectWithIssues(\n    projectInput: ProjectInput, \n    issues: CreateIssueInput[]\n  ): Promise<ProjectResponse> {\n    // Creates project first, then creates issues with project reference\n    const project = await this.createProject(projectInput);\n    const issuesWithProject = issues.map(issue => ({\n      ...issue,\n      projectId: project.projectCreate.project.id\n    }));\n    const batchResult = await this.createBatchIssues(issuesWithProject);\n    return { projectCreate: project.projectCreate, issueBatchCreate: batchResult.issueBatchCreate };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Layer in TypeScript\nDESCRIPTION: This code snippet shows the authentication system for Linear MCP, supporting both Personal Access Token (PAT) and OAuth flows. It includes the AuthHandler class for handling authentication operations and an AuthConfig interface defining configuration options.\nSOURCE: https://github.com/cline/linear-mcp/blob/main/architecture.md#2025-04-15_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nclass AuthHandler extends BaseHandler {\n  handleAuth(args: any): Promise<BaseToolResponse>;\n  handleAuthCallback(args: any): Promise<BaseToolResponse>;\n}\n\ninterface AuthConfig {\n  type: 'pat' | 'oauth';\n  accessToken?: string;\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Refactoring with Interface in TypeScript\nDESCRIPTION: This code snippet shows a planned improvement for authentication refactoring, splitting authentication into separate implementations using an interface. This design allows for different authentication strategies while maintaining a consistent interface.\nSOURCE: https://github.com/cline/linear-mcp/blob/main/architecture.md#2025-04-15_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ILinearAuth {\n  initialize(config: AuthConfig): void;\n  isAuthenticated(): boolean;\n  getClient(): LinearClient;\n}\n\nclass OAuthLinearAuth implements ILinearAuth {\n  // OAuth-specific implementation\n}\n\nclass PatLinearAuth implements ILinearAuth {\n  // PAT-specific implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Caching Layer in TypeScript\nDESCRIPTION: This code snippet shows a planned improvement for implementing a caching layer for frequently accessed data. It includes a CacheConfig interface for configuration options and a CacheManager class for managing cached data with methods for getting, setting, and invalidating cache entries.\nSOURCE: https://github.com/cline/linear-mcp/blob/main/architecture.md#2025-04-15_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CacheConfig {\n  ttl: number;\n  maxSize: number;\n}\n\nclass CacheManager {\n  private cache: Map<string, CacheEntry>;\n  \n  get<T>(key: string): T | undefined;\n  set<T>(key: string, value: T, ttl?: number): void;\n  invalidate(pattern: string): void;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rate Limiting in TypeScript\nDESCRIPTION: This code snippet shows a planned improvement for adding rate limiting middleware to prevent API abuse. It includes a RateLimiter class with methods for checking limits and waiting for availability, implementing a time-window based rate limiting approach.\nSOURCE: https://github.com/cline/linear-mcp/blob/main/architecture.md#2025-04-15_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nclass RateLimiter {\n  private readonly limits: Map<string, number>;\n  private readonly windowMs: number;\n\n  async checkLimit(operation: string): Promise<boolean>;\n  async waitForAvailability(operation: string): Promise<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Error Handling Interfaces in TypeScript\nDESCRIPTION: This code snippet defines the interfaces for error handling in the MCP system. It shows the structure of base tool responses and error-specific responses, ensuring consistent error handling throughout the codebase.\nSOURCE: https://github.com/cline/linear-mcp/blob/main/architecture.md#2025-04-15_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BaseToolResponse {\n  content: Array<{\n    type: string;\n    text: string;\n  }>;\n}\n\ninterface ErrorToolResponse extends BaseToolResponse {\n  isError: true;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Domain-Specific Error Types in TypeScript\nDESCRIPTION: This code snippet shows a planned improvement for implementing domain-specific error types. It defines a LinearApiError class that extends the standard Error class with additional properties for error code and operation context, improving error handling and debugging.\nSOURCE: https://github.com/cline/linear-mcp/blob/main/architecture.md#2025-04-15_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nclass LinearApiError extends Error {\n  constructor(\n    public code: string,\n    public operation: string,\n    message: string\n  ) {\n    super(message);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Organizing Linear MCP Feature Files\nDESCRIPTION: This code snippet shows the recommended file organization structure for feature modules in the Linear MCP codebase. It demonstrates how to keep related code together, organizing handlers, types, and tests within a specific domain (issues in this example).\nSOURCE: https://github.com/cline/linear-mcp/blob/main/architecture.md#2025-04-15_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\nfeatures/issues/\n├── handlers/          # Issue-related handlers\n│   └── issue.handler.ts\n├── types/            # Issue-specific types\n│   └── issue.types.ts\n└── __tests__/        # Tests\n    ├── issue.test.ts\n    └── issue.integration.test.ts\n```\n\n----------------------------------------\n\nTITLE: Exploring Linear MCP Directory Structure\nDESCRIPTION: This directory structure outlines the organization of the Linear MCP codebase, showing a layered architecture pattern with domain-specific modules. It demonstrates the separation of core infrastructure, feature modules by domain, infrastructure concerns, and shared utilities.\nSOURCE: https://github.com/cline/linear-mcp/blob/main/architecture.md#2025-04-15_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nsrc/\n├── core/               # Core infrastructure\n│   ├── handlers/      # Base handler and factory\n│   │   ├── base.handler.ts\n│   │   └── handler.factory.ts\n│   ├── types/         # Shared type definitions\n│   │   ├── tool.types.ts     # MCP tool schemas\n│   │   └── common.types.ts\n│   └── interfaces/    # Core interfaces\n│       └── tool-handler.interface.ts\n│\n├── features/          # Feature modules by domain\n│   ├── auth/         # Authentication\n│   │   └── handlers/\n│   ├── issues/       # Issue management\n│   │   └── handlers/\n│   ├── projects/     # Project operations\n│   │   └── handlers/\n│   ├── teams/        # Team operations\n│   │   └── handlers/\n│   └── users/        # User operations\n│       └── handlers/\n│\n├── infrastructure/    # Infrastructure concerns\n│   ├── graphql/      # GraphQL implementation\n│   │   ├── operations/   # GraphQL operations by domain\n│   │   └── fragments/    # Shared GraphQL fragments\n│   └── http/         # HTTP client\n│\n└── utils/            # Shared utilities\n    ├── logger.ts     # Logging system\n    └── config.ts     # Configuration management\n```"
  }
]