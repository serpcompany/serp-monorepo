[
  {
    "owner": "litestar-org",
    "repo": "advanced-alchemy",
    "content": "TITLE: Defining a Basic Blog Post Model with Advanced Alchemy\nDESCRIPTION: Creates a simple blog post model using the BigIntAuditBase from Advanced Alchemy. This model includes fields for title, content, publication status, and timestamps.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/modeling.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport datetime\nfrom typing import Optional\n\nfrom advanced_alchemy.base import BigIntAuditBase\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nclass Post(BigIntAuditBase):\n    \"\"\"Blog post model with auto-incrementing ID and audit fields.\n\n    Attributes:\n        title: The post title\n        content: The post content\n        published: Publication status\n        published_at: Timestamp of publication\n        created_at: Timestamp of creation (from BigIntAuditBase)\n        updated_at: Timestamp of last update (from BigIntAuditBase)\n    \"\"\"\n\n    title: Mapped[str] = mapped_column(index=True)\n    content: Mapped[str]\n    published: Mapped[bool] = mapped_column(default=False)\n    published_at: Mapped[Optional[datetime.datetime]] = mapped_column(default=None)\n```\n\n----------------------------------------\n\nTITLE: Complete Flask CRUD Service with Advanced Alchemy\nDESCRIPTION: A comprehensive example showing how to implement a CRUD API for Author resources using Advanced Alchemy's FlaskServiceMixin. Includes route handlers for listing, creating, retrieving, updating, and deleting authors with JSON serialization.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/flask.rst#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport datetime\nfrom typing import Optional\nfrom uuid import UUID\n\nfrom msgspec import Struct\nfrom flask import Flask\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom advanced_alchemy.extensions.flask import (\n    AdvancedAlchemy,\n    FlaskServiceMixin,\n    service,\n    repository,\n    SQLAlchemySyncConfig,\n    base,\n)\n\nclass Author(base.UUIDBase):\n    \"\"\"Author model.\"\"\"\n\n    name: Mapped[str]\n    dob: Mapped[Optional[datetime.date]]\n\nclass AuthorSchema(Struct):\n    \"\"\"Author schema.\"\"\"\n\n    name: str\n    id: Optional[UUID] = None\n    dob: Optional[datetime.date] = None\n\n\nclass AuthorService(FlaskServiceMixin, service.SQLAlchemySyncRepositoryService[Author]):\n    class Repo(repository.SQLAlchemySyncRepository[Author]):\n        model_type = Author\n\n    repository_type = Repo\n\napp = Flask(__name__)\nconfig = SQLAlchemySyncConfig(connection_string=\"sqlite:///local.db\", commit_mode=\"autocommit\", create_all=True)\nalchemy = AdvancedAlchemy(config, app)\n\n\n@app.route(\"/authors\", methods=[\"GET\"])\ndef list_authors():\n    \"\"\"List authors with pagination.\"\"\"\n    page, page_size = request.args.get(\"currentPage\", 1, type=int), request.args.get(\"pageSize\", 10, type=int)\n    limit_offset = filters.LimitOffset(limit=page_size, offset=page_size * (page - 1))\n    service = AuthorService(session=alchemy.get_sync_session())\n    results, total = service.list_and_count(limit_offset)\n    response = service.to_schema(results, total, filters=[limit_offset], schema_type=AuthorSchema)\n    return service.jsonify(response)\n\n\n@app.route(\"/authors\", methods=[\"POST\"])\ndef create_author():\n    \"\"\"Create a new author.\"\"\"\n    service = AuthorService(session=alchemy.get_sync_session())\n    obj = service.create(**request.get_json())\n    return service.jsonify(obj)\n\n\n@app.route(\"/authors/<uuid:author_id>\", methods=[\"GET\"])\ndef get_author(author_id: UUID):\n    \"\"\"Get an existing author.\"\"\"\n    service = AuthorService(session=alchemy.get_sync_session(), load=[Author.books])\n    obj = service.get(author_id)\n    return service.jsonify(obj)\n\n\n@app.route(\"/authors/<uuid:author_id>\", methods=[\"PATCH\"])\ndef update_author(author_id: UUID):\n    \"\"\"Update an author.\"\"\"\n    service = AuthorService(session=alchemy.get_sync_session(), load=[Author.books])\n    obj = service.update(**request.get_json(), item_id=author_id)\n    return service.jsonify(obj)\n\n\n@app.route(\"/authors/<uuid:author_id>\", methods=[\"DELETE\"])\ndef delete_author(author_id: UUID):\n    \"\"\"Delete an author.\"\"\"\n    service = AuthorService(session=alchemy.get_sync_session())\n    service.delete(author_id)\n    return \"\", 204\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Advanced Alchemy Types with SQLAlchemy ORM\nDESCRIPTION: Demonstrates how to use various Advanced Alchemy types including GUID, DateTimeUTC, EncryptedString, JsonB, and StoredObject in a SQLAlchemy ORM model. The example shows a User model with different column types for various data needs.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom advanced_alchemy.base import DefaultBase\nfrom advanced_alchemy.types import (\n    DateTimeUTC,\n    EncryptedString,\n    GUID,\n    JsonB,\n    StoredObject,\n)\n\nclass User(DefaultBase):\n    __tablename__ = \"users\"\n    id: Mapped[UUID] = mapped_column(GUID, primary_key=True)\n    created_at: Mapped[datetime] = mapped_column(DateTimeUTC)\n    password: Mapped[str] = mapped_column(EncryptedString(key=\"secret-key\"))\n    preferences: Mapped[dict] = mapped_column(JsonB)\n    avatar: Mapped[Optional[FileObject]] = mapped_column(StoredObject(backend=\"local_store\"))\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Post Repository with SQLAlchemyAsyncRepository\nDESCRIPTION: Demonstrates how to create a basic repository for a blog post model using SQLAlchemyAsyncRepository and implement a function to create posts.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/repositories.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.repository import SQLAlchemyAsyncRepository\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom uuid import UUID\n\nclass PostRepository(SQLAlchemyAsyncRepository[Post]):\n    \"\"\"Repository for managing blog posts.\"\"\"\n    model_type = Post\n\nasync def create_post(db_session: AsyncSession, title: str, content: str, author_id: UUID) -> Post:\n    repository = PostRepository(session=db_session)\n    return await repository.add(\n        Post(title=title, content=content, author_id=author_id), auto_commit=True\n    )\n```\n\n----------------------------------------\n\nTITLE: Basic Service Operations\nDESCRIPTION: Shows implementation of basic CRUD operations using the PostService, including create and update methods with schema validation.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/services.rst#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def create_post(\n    post_service: PostService,\n    data: PostCreate,\n) -> PostResponse:\n    \"\"\"Create a post with associated tags.\"\"\"\n    post = await post_service.create(\n        data,\n        auto_commit=True,\n    )\n    return post_service.to_schema(post, schema_type=PostResponse)\n\nasync def update_post(\n    post_service: PostService,\n    post_id: int,\n    data: PostUpdate,\n) -> PostResponse:\n    \"\"\"Update a post.\"\"\"\n    post = await post_service.update(\n        item_id=post_id,\n        data=data,\n        auto_commit=True,\n    )\n    return post_service.to_schema(post, schema_type=PostResponse)\n```\n\n----------------------------------------\n\nTITLE: Implementing User Repository with Advanced Alchemy in Python\nDESCRIPTION: Demonstrates creating a User model and repository, initializing the database, and performing CRUD operations using Advanced Alchemy's synchronous repository.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/README.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy import base, repository, config\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import Mapped, sessionmaker\n\n\nclass User(base.UUIDBase):\n    # you can optionally override the generated table name by manually setting it.\n    __tablename__ = \"user_account\"  # type: ignore[assignment]\n    email: Mapped[str]\n    name: Mapped[str]\n\n\nclass UserRepository(repository.SQLAlchemySyncRepository[User]):\n    \"\"\"User repository.\"\"\"\n\n    model_type = User\n\n\ndb = config.SQLAlchemySyncConfig(connection_string=\"duckdb:///:memory:\", session_config=config.SyncSessionConfig(expire_on_commit=False))\n\n# Initializes the database.\nwith db.get_engine().begin() as conn:\n    User.metadata.create_all(conn)\n\nwith db.get_session() as db_session:\n    repo = UserRepository(session=db_session)\n    # 1) Create multiple users with `add_many`\n    bulk_users = [\n        {\"email\": 'cody@litestar.dev', 'name': 'Cody'},\n        {\"email\": 'janek@litestar.dev', 'name': 'Janek'},\n        {\"email\": 'peter@litestar.dev', 'name': 'Peter'},\n        {\"email\": 'jacob@litestar.dev', 'name': 'Jacob'}\n    ]\n    objs = repo.add_many([User(**raw_user) for raw_user in bulk_users])\n    db_session.commit()\n    print(f\"Created {len(objs)} new objects.\")\n\n    # 2) Select paginated data and total row count.  Pass additional filters as kwargs\n    created_objs, total_objs = repo.list_and_count(LimitOffset(limit=10, offset=0), name=\"Cody\")\n    print(f\"Selected {len(created_objs)} records out of a total of {total_objs}.\")\n\n    # 3) Let's remove the batch of records selected.\n    deleted_objs = repo.delete_many([new_obj.id for new_obj in created_objs])\n    print(f\"Removed {len(deleted_objs)} records out of a total of {total_objs}.\")\n\n    # 4) Let's count the remaining rows\n    remaining_count = repo.count()\n    print(f\"Found {remaining_count} remaining records after delete.\")\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLAlchemy with FastAPI\nDESCRIPTION: Sets up the basic configuration for SQLAlchemy integration with FastAPI using Advanced Alchemy. It defines the database connection string, session configuration, and initializes the AdvancedAlchemy object.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/fastapi.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import AsyncGenerator\n\nfrom fastapi import FastAPI\n\nfrom advanced_alchemy.extensions.fastapi import AdvancedAlchemy, AsyncSessionConfig, SQLAlchemyAsyncConfig\n\nsqlalchemy_config = SQLAlchemyAsyncConfig(\n    connection_string=\"sqlite+aiosqlite:///test.sqlite\",\n    session_config=AsyncSessionConfig(expire_on_commit=False),\n    create_all=True,\n    commit_mode=\"autocommit\",\n)\n\napp = FastAPI()\nalchemy = AdvancedAlchemy(config=sqlalchemy_config, app=app)\n```\n\n----------------------------------------\n\nTITLE: Basic Flask Integration with Advanced Alchemy\nDESCRIPTION: A basic example showing how to initialize Advanced Alchemy with Flask and use a SQLAlchemy session in a route. Uses SQLAlchemySyncConfig for a SQLite database with autocommit mode.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/flask.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask\nfrom sqlalchemy import select\nfrom advanced_alchemy.extensions.flask import (\n    AdvancedAlchemy,\n    SQLAlchemySyncConfig,\n    EngineConfig,\n)\n\napp = Flask(__name__)\ndb_config = SQLAlchemySyncConfig(connection_string=\"sqlite:///local.db\", commit_mode=\"autocommit\", create_all=True)\nalchemy = AdvancedAlchemy(db_config, app)\n\n# Use standard SQLAlchemy session in your routes\n@app.route(\"/users\")\ndef list_users():\n    db_session = alchemy.get_sync_session()\n    users = db_session.execute(select(User))\n    return {\"users\": [user.dict() for user in users.scalars()]}\n```\n\n----------------------------------------\n\nTITLE: Implementing User Service with Advanced Alchemy in Python\nDESCRIPTION: Shows how to create a User model and service, initialize the database, and perform CRUD operations using Advanced Alchemy's synchronous service class.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/README.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy import base, repository, filters, service, config\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import Mapped, sessionmaker\n\n\nclass User(base.UUIDBase):\n    # you can optionally override the generated table name by manually setting it.\n    __tablename__ = \"user_account\"  # type: ignore[assignment]\n    email: Mapped[str]\n    name: Mapped[str]\n\nclass UserService(service.SQLAlchemySyncRepositoryService[User]):\n    \"\"\"User repository.\"\"\"\n    class Repo(repository.SQLAlchemySyncRepository[User]):\n        \"\"\"User repository.\"\"\"\n\n        model_type = User\n\n    repository_type = Repo\n\ndb = config.SQLAlchemySyncConfig(connection_string=\"duckdb:///:memory:\", session_config=config.SyncSessionConfig(expire_on_commit=False))\n\n# Initializes the database.\nwith db.get_engine().begin() as conn:\n    User.metadata.create_all(conn)\n\nwith db.get_session() as db_session:\n    service = UserService(session=db_session)\n    # 1) Create multiple users with `add_many`\n    objs = service.create_many([\n        {\"email\": 'cody@litestar.dev', 'name': 'Cody'},\n        {\"email\": 'janek@litestar.dev', 'name': 'Janek'},\n        {\"email\": 'peter@litestar.dev', 'name': 'Peter'},\n        {\"email\": 'jacob@litestar.dev', 'name': 'Jacob'}\n    ])\n    print(objs)\n    print(f\"Created {len(objs)} new objects.\")\n\n    # 2) Select paginated data and total row count.  Pass additional filters as kwargs\n    created_objs, total_objs = service.list_and_count(LimitOffset(limit=10, offset=0), name=\"Cody\")\n    print(f\"Selected {len(created_objs)} records out of a total of {total_objs}.\")\n\n    # 3) Let's remove the batch of records selected.\n    deleted_objs = service.delete_many([new_obj.id for new_obj in created_objs])\n    print(f\"Removed {len(deleted_objs)} records out of a total of {total_objs}.\")\n\n    # 4) Let's count the remaining rows\n    remaining_count = service.count()\n    print(f\"Found {remaining_count} remaining records after delete.\")\n```\n\n----------------------------------------\n\nTITLE: Basic Service and Schema Definitions\nDESCRIPTION: Demonstrates the basic setup of a Post service with Pydantic models for validation including create, update, and response schemas.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/services.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport datetime\nfrom typing import Optional, List\nfrom uuid import UUID\n\nfrom advanced_alchemy.service import SQLAlchemyAsyncRepositoryService\nfrom pydantic import BaseModel\n\n# Pydantic schemas for validation\nclass PostCreate(BaseModel):\n    title: str\n    content: str\n    tag_names: List[str]\n\nclass PostUpdate(BaseModel):\n    title: Optional[str] = None\n    content: Optional[str] = None\n    published: Optional[bool] = None\n\nclass PostResponse(BaseModel):\n    id: int\n    title: str\n    content: str\n    published: bool\n    published_at: Optional[datetime.datetime]\n    created_at: datetime.datetime\n    updated_at: datetime.datetime\n    tags: List[\"TagResponse\"]\n\n    model_config = {\"from_attributes\": True}\n\nclass PostService(SQLAlchemyAsyncRepositoryService[Post]):\n    \"\"\"Service for managing blog posts with automatic schema validation.\"\"\"\n\n    repository_type = PostRepository\n```\n\n----------------------------------------\n\nTITLE: Filtering and Querying with Advanced Alchemy Repository\nDESCRIPTION: Shows how to use filtering capabilities to retrieve recent posts with specific conditions like publication status and creation date.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/repositories.rst#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport datetime\n\nasync def get_recent_posts(db_session: AsyncSession) -> list[Post]:\n    repository = PostRepository(session=db_session)\n\n    # Create filter for posts from last week\n    return await repository.list(\n        Post.published == True,\n        Post.created_at > (datetime.datetime.utcnow() - timedelta(days=7))\n    )\n```\n\n----------------------------------------\n\nTITLE: FastAPI Database Seeding Implementation\nDESCRIPTION: Demonstrates database seeding in a FastAPI application using Advanced Alchemy with async SQLite database. Includes product model definition, repository setup, and fixture loading with startup lifecycle management.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/database_seeding.rst#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom contextlib import asynccontextmanager\nfrom pathlib import Path\nfrom typing import Optional\n\nimport uvicorn\nfrom fastapi import FastAPI\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom advanced_alchemy.base import UUIDBase\nfrom advanced_alchemy.extensions.fastapi import (\n    AdvancedAlchemy,\n    AsyncSessionConfig,\n    SQLAlchemyAsyncConfig,\n)\nfrom advanced_alchemy.repository import SQLAlchemyAsyncRepository\nfrom advanced_alchemy.utils.fixtures import open_fixture_async\n\nDATABASE_URL = \"sqlite+aiosqlite:///db.sqlite3\"\n\nfixtures_path = Path(__file__).parent / \"fixtures\"\n\nclass Product(UUIDBase):\n    \"\"\"Product model.\"\"\"\n    __tablename__ = \"products\"\n\n    name: Mapped[str] = mapped_column(String(length=100))\n    description: Mapped[Optional[str]] = mapped_column(String(length=500))\n    price: Mapped[float]\n    in_stock: Mapped[bool] = mapped_column(default=True)\n\nclass ProductRepository(SQLAlchemyAsyncRepository[Product]):\n    \"\"\"Product repository.\"\"\"\n    model_type = Product\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    async with sqlalchemy_config.get_session() as db_session:\n        product_repo = ProductRepository(session=db_session)\n        try:\n            print(f\"Attempting to load fixtures from {fixtures_path}/product.json\")\n            product_data = await open_fixture_async(fixtures_path, \"product\")\n            print(f\"Loaded {len(product_data)} products from fixture\")\n            await product_repo.add_many([Product(**item) for item in product_data])\n            await db_session.commit()\n        except FileNotFoundError:\n            print(f\"Could not find fixture file at {fixtures_path}/product.json\")\n        products = await product_repo.list()\n        print(f\"Database seeded with {len(products)} products\")\n    yield\n    print(\"Shutting down...\")\n\nsession_config = AsyncSessionConfig(expire_on_commit=False)\nsqlalchemy_config = SQLAlchemyAsyncConfig(\n    connection_string=DATABASE_URL,\n    commit_mode=\"autocommit\",\n    session_config=session_config,\n    create_all=True,\n)\n\napp = FastAPI(lifespan=lifespan)\nalchemy = AdvancedAlchemy(config=sqlalchemy_config, app=app)\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Posts with Bulk Operations\nDESCRIPTION: Shows how to perform bulk creation of posts using the create_many method to efficiently insert multiple records at once.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/repositories.rst#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def create_posts(db_session: AsyncSession, data: list[tuple[str, str, UUID]]) -> list[Post]:\n    repository = PostRepository(session=db_session)\n\n    # Create posts\n    return await repository.create_many(\n        [Post(title=title, content=content, author_id=author_id) for title, content, author_id in data],\n        auto_commit=True\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Many-to-Many Relationships with Advanced Alchemy\nDESCRIPTION: Demonstrates how to create a many-to-many relationship between posts and tags using Advanced Alchemy. This example includes an association table, relationship configurations, and the use of the SlugKey mixin.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/modeling.rst#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\nfrom sqlalchemy import Column, ForeignKey, Table\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom advanced_alchemy.base import BigIntAuditBase, orm_registry, SlugKey\nfrom typing import List\n\n# Association table for post-tag relationship\npost_tag = Table(\n    \"post_tag\",\n    orm_registry.metadata,\n    Column(\"post_id\", ForeignKey(\"post.id\", ondelete=\"CASCADE\"), primary_key=True),\n    Column(\"tag_id\", ForeignKey(\"tag.id\", ondelete=\"CASCADE\"), primary_key=True)\n)\n\nclass Post(BigIntAuditBase):\n\n    title: Mapped[str] = mapped_column(index=True)\n    content: Mapped[str]\n    published: Mapped[bool] = mapped_column(default=False)\n\n    # Many-to-many relationship with tags\n    tags: Mapped[List[\"Tag\"]] = relationship(\n        secondary=post_tag,\n        back_populates=\"posts\",\n        lazy=\"selectin\"\n    )\n\nclass Tag(BigIntAuditBase, SlugKey):\n    \"\"\"Tag model with automatic slug generation.\n\n    The SlugKey mixin automatically adds a slug field to the model.\n    \"\"\"\n\n    name: Mapped[str] = mapped_column(unique=True, index=True)\n    posts: Mapped[List[Post]] = relationship(\n        secondary=post_tag,\n        back_populates=\"tags\",\n        viewonly=True\n    )\n```\n\n----------------------------------------\n\nTITLE: Defining SQLAlchemy Models and Pydantic Schemas\nDESCRIPTION: Defines SQLAlchemy models (AuthorModel and BookModel) and corresponding Pydantic schemas (Author, AuthorCreate, AuthorUpdate) for the application. It uses Advanced Alchemy's base classes and establishes relationships between models.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/fastapi.rst#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport datetime\nfrom uuid import UUID\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom pydantic import BaseModel as _BaseModel\nfrom advanced_alchemy.base import UUIDAuditBase, UUIDBase\n\nclass BaseModel(_BaseModel):\n    \"\"\"Extend Pydantic's BaseModel to enable ORM mode\"\"\"\n    model_config = {\"from_attributes\": True}\n\nclass AuthorModel(UUIDBase):\n    __tablename__ = \"author\"\n    name: Mapped[str]\n    dob: Mapped[date | None]\n    books: Mapped[list[BookModel]] = relationship(back_populates=\"author\", lazy=\"noload\")\n\nclass BookModel(UUIDAuditBase):\n    __tablename__ = \"book\"\n    title: Mapped[str]\n    author_id: Mapped[UUID] = mapped_column(ForeignKey(\"author.id\"))\n    author: Mapped[AuthorModel] = relationship(lazy=\"joined\", innerjoin=True, viewonly=True)\n\nclass Author(BaseModel):\n    id: UUID | None\n    name: str\n    dob: datetime.date | None = None\n\nclass AuthorCreate(BaseModel):\n    name: str\n    dob: datetime.date | None = None\n\nclass AuthorUpdate(BaseModel):\n    name: str | None = None\n    dob: datetime.date | None = None\n```\n\n----------------------------------------\n\nTITLE: Creating Repository and Service Classes\nDESCRIPTION: Defines the AuthorService class which extends SQLAlchemyAsyncRepositoryService, and its nested Repo class extending SQLAlchemyAsyncRepository. These classes provide the core functionality for interacting with the author data.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/fastapi.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, AsyncGenerator, Optional\n\nfrom advanced_alchemy.extensions.fastapi import repository, service\nfrom fastapi import Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n\nclass AuthorService(service.SQLAlchemyAsyncRepositoryService[AuthorModel]):\n    \"\"\"Author service.\"\"\"\n\n    class Repo(repository.SQLAlchemyAsyncRepository[AuthorModel]):\n        \"\"\"Author repository.\"\"\"\n        model_type = AuthorModel\n\n    repository_type = Repo\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Database Seeding with Advanced Alchemy\nDESCRIPTION: Python script showing asynchronous database initialization and seeding using Advanced Alchemy. It includes async database configuration, Product model definition, repository setup, and fixture loading using asyncio.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/database_seeding.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom sqlalchemy import String\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom advanced_alchemy.base import UUIDBase\nfrom advanced_alchemy.config import AsyncSessionConfig, SQLAlchemyAsyncConfig\nfrom advanced_alchemy.repository import SQLAlchemyAsyncRepository\nfrom advanced_alchemy.utils.fixtures import open_fixture_async\n\n# Database connection string\nDATABASE_URL = \"sqlite+aiosqlite:///db.sqlite3\"\n\nconfig = SQLAlchemyAsyncConfig(\n    engine_instance=create_async_engine(DATABASE_URL),\n    session_config=AsyncSessionConfig(expire_on_commit=False)\n)\n\nclass Product(UUIDBase):\n    \"\"\"Product model.\"\"\"\n    __tablename__ = \"products\"\n\n    name: Mapped[str] = mapped_column(String(length=100))\n    description: Mapped[Optional[str]] = mapped_column(String(length=500))\n    price: Mapped[float]\n    in_stock: Mapped[bool] = mapped_column(default=True)\n\n\n# Repository\nclass ProductRepository(SQLAlchemyAsyncRepository[Product]):\n    \"\"\"Product repository.\"\"\"\n    model_type = Product\n\n\n# Set up fixtures path\nfixtures_path = Path(__file__).parent / \"fixtures\"\n\n\nasync def initialize_database():\n    \"\"\"Initialize the database and create tables.\"\"\"\n    print(\"Creating database tables...\")\n    async with config.get_engine().begin() as conn:\n        await conn.run_sync(UUIDBase.metadata.create_all)\n    print(\"Tables created successfully\")\n\n\nasync def seed_database():\n    \"\"\"Seed the database with fixture data.\"\"\"\n    print(\"Seeding database...\")\n\n    # Create a session\n    async with config.get_session() as db_session:\n        # Create repository for product model\n        product_repo = ProductRepository(session=db_session)\n\n        # Load and add product data\n        try:\n            print(f\"Attempting to load fixtures from {fixtures_path}/product.json\")\n            product_data = await open_fixture_async(fixtures_path, \"product\")\n            print(f\"Loaded {len(product_data)} products from fixture\")\n            await product_repo.add_many([Product(**item) for item in product_data])\n            await db_session.commit()\n        except FileNotFoundError:\n            print(f\"Could not find fixture file at {fixtures_path}/product.json\")\n\n\n\nasync def main():\n    \"\"\"Main async function to run the example.\"\"\"\n    # Initialize the database\n    await initialize_database()\n\n    # Seed the database\n    await seed_database()\n\n\n\nif __name__ == \"__main__\":\n    # Run the async main function\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Using DateTimeUTC Type in SQLAlchemy Models\nDESCRIPTION: Demonstrates how to use the DateTimeUTC type which ensures all datetime values are stored in UTC timezone. This type requires timezone information for input values and automatically converts stored values to UTC timezone.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom advanced_alchemy.base import DefaultBase\nfrom advanced_alchemy.types import DateTimeUTC\n\nclass MyModel(DefaultBase):\n    created_at: Mapped[datetime] = mapped_column(DateTimeUTC)\n```\n\n----------------------------------------\n\nTITLE: Simplified Tag Addition Using UniqueMixin\nDESCRIPTION: Shows how to use the UniqueMixin's as_unique_async method to simplify the process of adding tags to a post. This approach automatically handles looking up existing tags, creating new ones if needed, and merging duplicates.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/modeling.rst#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom advanced_alchemy.utils.text import slugify\n\nasync def add_tags_to_post(\n    db_session: AsyncSession,\n    post: Post,\n    tag_names: list[str]\n) -> Post:\n    \"\"\"Add tags to a post, creating new tags if needed.\"\"\"\n    # The UniqueMixin automatically handles:\n    # 1. Looking up existing tags\n    # 2. Creating new tags if needed\n    # 3. Merging duplicates\n    post.tags = [\n      await Tag.as_unique_async(db_session, name=tag_text, slug=slugify(tag_text))\n      for tag_text in tag_names\n    ]\n    db_session.merge(post)\n    await db_session.flush()\n    return post\n```\n\n----------------------------------------\n\nTITLE: Complex Service Operations\nDESCRIPTION: Demonstrates advanced service implementation with custom methods for handling complex operations like tag management, post publishing, and trending post retrieval.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/services.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import List\n\nfrom advanced_alchemy.exceptions import ErrorMessages\nfrom advanced_alchemy.service import SQLAlchemyAsyncRepositoryService\nfrom advanced_alchemy.service.typing import ModelDictT\n\nfrom .models import Post, Tag\n\nclass PostService(SQLAlchemyAsyncRepositoryService[Post, PostRepository]):\n\n    default_load_options = [Post.tags]\n    repository_type = PostRepository\n    match_fields = [\"name\"]\n\n    # Override creation behavior to handle tags\n    async def create(self, data: ModelDictT[Post], **kwargs) -> Post:\n        \"\"\"Create a new post with tags, if provided.\"\"\"\n        tags_added: list[str] = []\n        if isinstance(data, dict):\n            data[\"id\"] = data.get(\"id\", uuid4())\n            tags_added = data.pop(\"tags\", [])\n        data = await self.to_model(data, \"create\")\n        if tags_added:\n            data.tags.extend(\n                [\n                    await Tag.as_unique_async(self.repository.session, name=tag_text, slug=slugify(tag_text))\n                    for tag_text in tags_added\n                ],\n            )\n        return await super().create(data=data, **kwargs)\n\n    # Override update behavior to handle tags\n    async def update(\n        self,\n        data: ModelDictT[Post],\n        item_id: Any | None = None,\n        **kwargs,\n    ) -> Post:\n        \"\"\"Update a post with tags, if provided.\"\"\"\n        tags_updated: list[str] = []\n        if isinstance(data, dict):\n            tags_updated.extend(data.pop(\"tags\", None) or [])\n            data[\"id\"] = item_id\n            data = await self.to_model(data, \"update\")\n            existing_tags = [tag.name for tag in data.tags]\n            tags_to_remove = [tag for tag in data.tags if tag.name not in tags_updated]\n            tags_to_add = [tag for tag in tags_updated if tag not in existing_tags]\n            for tag_rm in tags_to_remove:\n                data.tags.remove(tag_rm)\n            data.tags.extend(\n                [\n                    await Tag.as_unique_async(self.repository.session, name=tag_text, slug=slugify(tag_text))\n                    for tag_text in tags_to_add\n                ],\n            )\n        return await super().update(\n            data=data,\n            item_id=item_id,\n            **kwargs,\n        )\n\n    # A custom write operation\n    async def publish_post(\n        self,\n        post_id: int,\n        publish: bool = True,\n    ) -> PostResponse:\n        \"\"\"Publish or unpublish a post with timestamp.\"\"\"\n        data = PostUpdate(\n            published=publish,\n            published_at=datetime.datetime.utcnow() if publish else None,\n        )\n        post = await self.repository.update(\n            item_id=post_id,\n            data=data,\n            auto_commit=True,\n        )\n        return self.to_schema(post, schema_type=PostResponse)\n\n    # A custom read operation\n    async def get_trending_posts(\n        self,\n        days: int = 7,\n        min_views: int = 100,\n    ) -> List[PostResponse]:\n        \"\"\"Get trending posts based on view count and recency.\"\"\"\n        posts = await self.post_service.list(\n            Post.published == True,\n            Post.created_at > (datetime.datetime.utcnow() - timedelta(days=days)),\n            Post.view_count >= min_views,\n            order_by=[Post.view_count.desc()],\n        )\n        return self.post_service.to_schema(posts, schema_type=PostResponse)\n\n    # Override the default `to_model` to handle slugs\n    async def to_model(self, data: ModelDictT[Post], operation: str | None = None) -> Post:\n        \"\"\"Convert a dictionary, msgspec Struct, or Pydantic model to a Post model. \"\"\"\n        if (is_msgspec_struct(data) or is_pydantic_model(data)) and operation in {\"create\", \"update\"} and data.slug is None:\n            data.slug = await self.repository.get_available_slug(data.name)\n        if is_dict(data) and \"slug\" not in data and operation == \"create\":\n            data[\"slug\"] = await self.repository.get_available_slug(data[\"name\"])\n        if is_dict(data) and \"slug\" not in data and \"name\" in data and operation == \"update\":\n            data[\"slug\"] = await self.repository.get_available_slug(data[\"name\"])\n        return await super().to_model(data, operation)\n```\n\n----------------------------------------\n\nTITLE: Customizing Declarative Base with Server-Side UUID Primary Key\nDESCRIPTION: Demonstrates how to create a custom declarative base class that uses server-side generated UUID primary keys for PostgreSQL. This example includes a mixin for the UUID primary key and a custom base class that incorporates it.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/modeling.rst#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport datetime\nfrom uuid import UUID, uuid4\n\nfrom advanced_alchemy.base import CommonTableAttributes, orm_registry\nfrom sqlalchemy import text\nfrom sqlalchemy.orm import (\n    DeclarativeBase,\n    Mapped,\n    declared_attr,\n    mapped_column,\n    orm_insert_sentinel,\n)\n\n\nclass ServerSideUUIDPrimaryKey:\n    \"\"\"UUID Primary Key Field Mixin.\"\"\"\n\n    id: Mapped[UUID] = mapped_column(default=uuid4, primary_key=True, server_default=text(\"gen_random_uuid()\"))\n    \"\"\"UUID Primary key column.\"\"\"\n\n    # noinspection PyMethodParameters\n    @declared_attr\n    def _sentinel(cls) -> Mapped[int]:\n        \"\"\"Sentinel value required for SQLAlchemy bulk DML with UUIDs.\"\"\"\n        return orm_insert_sentinel(name=\"sa_orm_sentinel\")\n\n\nclass ServerSideUUIDBase(ServerSideUUIDPrimaryKey, CommonTableAttributes, DeclarativeBase):\n    \"\"\"Base for all SQLAlchemy declarative models with the custom UUID primary key .\"\"\"\n\n    registry = orm_registry\n\n\n# Using ServerSideUUIDBase\nclass User(ServerSideUUIDBase):\n    \"\"\"User model with ServerSideUUIDBase.\"\"\"\n\n    username: Mapped[str] = mapped_column(unique=True, index=True)\n    email: Mapped[str] = mapped_column(unique=True)\n    full_name: Mapped[str]\n    is_active: Mapped[bool] = mapped_column(default=True)\n    last_login: Mapped[datetime.datetime | None] = mapped_column(default=None)\n```\n\n----------------------------------------\n\nTITLE: Implementing Pagination with Advanced Alchemy Repository\nDESCRIPTION: Demonstrates how to implement pagination using the list_and_count method with LimitOffset filter to retrieve a specific page of results along with the total count.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/repositories.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.filters import LimitOffset\n\nasync def get_paginated_posts(\n    db_session: AsyncSession,\n    page: int = 1,\n    page_size: int = 20\n) -> tuple[list[Post], int]:\n    repository = PostRepository(session=db_session)\n\n    # Get page of results and total count\n    results, total = await repository.list_and_count(\n        LimitOffset(offset=page, limit=page_size)\n    )\n\n    return results, total\n```\n\n----------------------------------------\n\nTITLE: Using GUID Type for UUID Primary Keys\nDESCRIPTION: Shows how to use the GUID type which provides a platform-independent UUID type that adapts to different database backends. It uses native UUID types where available or falls back to appropriate alternatives.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom advanced_alchemy.base import DefaultBase\nfrom advanced_alchemy.types import GUID\nfrom uuid import UUID\n\nclass MyModel(DefaultBase):\n    __tablename__ = \"my_model\"\n    id: Mapped[UUID] = mapped_column(GUID, primary_key=True)\n```\n\n----------------------------------------\n\nTITLE: Managing Transactions with Multiple Repositories\nDESCRIPTION: Shows how to manage transactions across multiple repositories to ensure atomicity when creating a post with associated tags.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/repositories.rst#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nasync def create_post_with_tags(\n    db_session: AsyncSession,\n    title: str,\n    content: str,\n    tag_names: list[str]\n) -> Post:\n    # Both repositories share the same transaction\n    post_repo = PostRepository(session=db_session)\n    tag_repo = TagRepository(session=db_session)\n\n    async with db_session.begin():\n        # Create or get existing tags\n        tags = []\n        for name in tag_names:\n            tag = await tag_repo.get_one_or_none(name=name)\n            if not tag:\n                tag = await tag_repo.add(Tag(name=name, slug=slugify(name)))\n            tags.append(tag)\n\n        # Create post with tags\n        post = await post_repo.add(\n            Post(title=title, content=content, tags=tags),\n            auto_commit=True\n        )\n\n        return post\n```\n\n----------------------------------------\n\nTITLE: Async SQLAlchemy with Flask and Advanced Alchemy\nDESCRIPTION: Demonstrates how to use Advanced Alchemy with async SQLAlchemy in Flask. Uses SQLAlchemyAsyncConfig with PostgreSQL and asyncpg driver to create an async session.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/flask.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.extensions.flask import (\n    AdvancedAlchemy,\n    SQLAlchemyAsyncConfig,\n)\nfrom sqlalchemy import select\n\napp = Flask(__name__)\ndb_config = SQLAlchemyAsyncConfig(connection_string=\"postgresql+asyncpg://user:pass@localhost/db\", create_all=True)\nalchemy = AdvancedAlchemy(db_config, app)\n\n# Use async session in your routes\n@app.route(\"/users\")\nasync def list_users():\n    db_session = alchemy.get_async_session()\n    users = await db_session.execute(select(User))\n    return {\"users\": [user.dict() for user in users.scalars()]}\n```\n\n----------------------------------------\n\nTITLE: Using EncryptedString Type for Secure String Storage\nDESCRIPTION: Shows how to use the EncryptedString type for storing encrypted string values with configurable length. This type requires a secret key for encryption and decryption operations.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom advanced_alchemy.base import DefaultBase\nfrom advanced_alchemy.types import EncryptedString\n\nclass MyModel(DefaultBase):\n    secret: Mapped[str] = mapped_column(EncryptedString(key=\"my-secret-key\"))\n```\n\n----------------------------------------\n\nTITLE: Using Query Repository for Complex Custom Queries\nDESCRIPTION: Shows how to use SQLAlchemyAsyncQueryRepository for complex queries like aggregations to get the count of posts per author.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/repositories.rst#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.repository import SQLAlchemyAsyncQueryRepository\nfrom sqlalchemy import select, func\n\nasync def get_posts_per_author(db_session: AsyncSession) -> list[tuple[UUID, int]]:\n    repository = SQLAlchemyAsyncQueryRepository(session=db_session)\n    return await repository.list(select(Post.author_id, func.count(Post.id)).group_by(Post.author_id))\n```\n\n----------------------------------------\n\nTITLE: Implementing FastAPI Controllers\nDESCRIPTION: Defines FastAPI route handlers for CRUD operations on authors. It includes endpoints for listing, creating, retrieving, updating, and deleting authors, utilizing the AuthorService for data operations.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/fastapi.rst#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom fastapi import APIRouter, Depends\nfrom uuid import UUID\nfrom advanced_alchemy.extensions.fastapi import filters\n\nauthor_router = APIRouter()\n\n@author_router.get(path=\"/authors\", response_model=filters.OffsetPagination[Author])\nasync def list_authors(\n    authors_service: Authors,\n    limit_offset: Annotated[filters.LimitOffset, Depends(provide_limit_offset_pagination)],\n) -> filters.OffsetPagination[AuthorModel]:\n    \"\"\"List authors.\"\"\"\n    results, total = await authors_service.list_and_count(limit_offset)\n    return authors_service.to_schema(results, total, filters=[limit_offset])\n\n@author_router.post(path=\"/authors\", response_model=Author)\nasync def create_author(\n    authors_service: Authors,\n    data: AuthorCreate,\n) -> AuthorModel:\n    \"\"\"Create a new author.\"\"\"\n    obj = await authors_service.create(data)\n    return authors_service.to_schema(obj)\n\n@author_router.get(path=\"/authors/{author_id}\", response_model=Author)\nasync def get_author(\n    authors_service: Authors,\n    author_id: UUID,\n) -> AuthorModel:\n    \"\"\"Get an existing author.\"\"\"\n    obj = await authors_service.get(author_id)\n    return authors_service.to_schema(obj)\n\n@author_router.patch(path=\"/authors/{author_id}\", response_model=Author)\nasync def update_author(\n    authors_service: Authors,\n    data: AuthorUpdate,\n    author_id: UUID,\n) -> AuthorModel:\n    \"\"\"Update an author.\"\"\"\n    obj = await authors_service.update(data, item_id=author_id)\n    return authors_service.to_schema(obj)\n\n@author_router.delete(path=\"/authors/{author_id}\")\nasync def delete_author(\n    authors_service: Authors,\n    author_id: UUID,\n) -> None:\n    \"\"\"Delete an author from the system.\"\"\"\n    _ = await authors_service.delete(author_id)\n```\n\n----------------------------------------\n\nTITLE: Using Advanced Alchemy Types in Alembic Migrations\nDESCRIPTION: Shows an example of how Advanced Alchemy types can be used in generated Alembic migration files after proper configuration. This example creates a users table with various custom column types.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# In generated migration file\ndef upgrade():\n    op.create_table(\n        'users',\n        sa.Column('id', sa.GUID(), primary_key=True),\n        sa.Column('created_at', sa.DateTimeUTC(), nullable=False),\n        sa.Column('secret', sa.EncryptedString(), nullable=True),\n        sa.Column('avatar', sa.StoredObject(backend=\"local_store\"), nullable=True),\n    )\n```\n\n----------------------------------------\n\nTITLE: Integrating Advanced Alchemy with Litestar Web Framework\nDESCRIPTION: Demonstrates how to integrate Advanced Alchemy with the Litestar web framework using the SQLAlchemyPlugin and SQLAlchemyAsyncConfig.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/README.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.plugins.sqlalchemy import SQLAlchemyPlugin, SQLAlchemyAsyncConfig\n# alternately...\n# from advanced_alchemy.extensions.litestar import SQLAlchemyAsyncConfig, SQLAlchemyPlugin\n\nalchemy = SQLAlchemyPlugin(\n  config=SQLAlchemyAsyncConfig(connection_string=\"sqlite+aiosqlite:///test.sqlite\"),\n)\napp = Litestar(plugins=[alchemy])\n```\n\n----------------------------------------\n\nTITLE: File Operations with FileObject\nDESCRIPTION: Shows various operations that can be performed with the FileObject class including saving files, retrieving content, deleting files, and generating signed URLs for temporary access.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Save a file\nfile_obj = FileObject(\n    backend=\"local_test_store\",\n    filename=\"test.txt\",\n    content=b\"Hello, World!\",\n)\nawait file_obj.save_async()\n\n# Get file content\ncontent = await file_obj.get_content_async()\n\n# Delete a file\nawait file_obj.delete_async()\n\n# Get signed URL\nurl = await file_obj.sign_async(expires_in=3600)  # URL expires in 1 hour\n```\n\n----------------------------------------\n\nTITLE: Integrating Advanced Alchemy with FastAPI Web Framework\nDESCRIPTION: Illustrates the integration of Advanced Alchemy with the FastAPI web framework using AdvancedAlchemy and SQLAlchemyAsyncConfig.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/README.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.extensions.fastapi import AdvancedAlchemy, SQLAlchemyAsyncConfig\nfrom fastapi import FastAPI\n\napp = FastAPI()\nalchemy = AdvancedAlchemy(\n    config=SQLAlchemyAsyncConfig(connection_string=\"sqlite+aiosqlite:///test.sqlite\"), app=app,\n)\n```\n\n----------------------------------------\n\nTITLE: Using StoredObject Type for File Storage\nDESCRIPTION: Demonstrates how to use the StoredObject type for file object storage with support for both single and multiple file storage. This example shows a Document model with fields for storing attachments and images.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom advanced_alchemy.base import UUIDBase\nfrom advanced_alchemy.types.file_object import FileObject, StoredObject\n\nclass Document(UUIDBase):\n    __tablename__ = \"documents\"\n\n    # Single file storage\n    attachment: Mapped[Optional[FileObject]] = mapped_column(\n        StoredObject(backend=\"local_test_store\"),\n        nullable=True,\n    )\n\n    # Multiple file storage\n    images: Mapped[Optional[FileObjectList]] = mapped_column(\n        StoredObject(backend=\"local_test_store\", multiple=True),\n        nullable=True,\n    )\n```\n\n----------------------------------------\n\nTITLE: Using EncryptedText Type for Large Encrypted Content\nDESCRIPTION: Demonstrates the EncryptedText type for storing larger encrypted text content (CLOB). Like EncryptedString, it requires a secret key for encryption and decryption operations.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom advanced_alchemy.base import DefaultBase\nfrom advanced_alchemy.types import EncryptedText\n\nclass MyModel(DefaultBase):\n    large_secret: Mapped[str] = mapped_column(EncryptedText(key=\"my-secret-key\"))\n```\n\n----------------------------------------\n\nTITLE: Using AsyncSession in Sync Context with Advanced Alchemy\nDESCRIPTION: Shows how to use an AsyncSession within a synchronous Flask route using Advanced Alchemy's portal. This experimental feature allows calling async methods from sync code.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/flask.rst#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@app.route(\"/users\")\ndef list_users():\n    db_session = alchemy.get_async_session()\n    users = alchemy.portal.call(db_session.execute, select(User))\n    return {\"users\": [user.dict() for user in users.scalars()]}\n```\n\n----------------------------------------\n\nTITLE: Multiple Database Configuration with Advanced Alchemy\nDESCRIPTION: Example showing how to configure Advanced Alchemy with multiple databases. The bind_key parameter is used to specify which database to use when getting a session.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/flask.rst#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nconfigs = [\n    SQLAlchemySyncConfig(connection_string=\"sqlite:///users.db\", bind_key=\"users\"),\n    SQLAlchemySyncConfig(connection_string=\"sqlite:///products.db\", bind_key=\"products\"),\n]\n\nalchemy = AdvancedAlchemy(configs, app)\n\n# Get session for specific database\nusers_session = alchemy.get_sync_session(\"users\")\nproducts_session = alchemy.get_sync_session(\"products\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Slug-based Repository for Articles\nDESCRIPTION: Demonstrates how to create a specialized slug repository that adds a get_by_slug method for models using the SlugKey mixin.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/repositories.rst#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.repository import SQLAlchemyAsyncSlugRepository\n\nclass ArticleRepository(SQLAlchemyAsyncSlugRepository[Article]):\n    \"\"\"Repository for articles with slug-based lookups.\"\"\"\n    model_type = Article\n\nasync def get_article_by_slug(db_session: AsyncSession, slug: str) -> Article:\n    repository = ArticleRepository(session=db_session)\n    return await repository.get_by_slug(slug)\n```\n\n----------------------------------------\n\nTITLE: Using JsonB Type for Efficient JSON Storage\nDESCRIPTION: Shows how to use the JsonB type which uses the most efficient JSON storage for each database. It uses native JSONB for PostgreSQL/CockroachDB, Binary JSON for Oracle, and standard JSON type for other databases.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom advanced_alchemy.base import DefaultBase\nfrom advanced_alchemy.types import JsonB\n\nclass MyModel(DefaultBase):\n    data: Mapped[dict] = mapped_column(JsonB)\n```\n\n----------------------------------------\n\nTITLE: Configuring FastAPI Application\nDESCRIPTION: Adds the author router to the FastAPI application, integrating all the defined routes into the main application.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/fastapi.rst#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\napp.include_router(author_router)\n```\n\n----------------------------------------\n\nTITLE: Configuring FSSpec Backend for StoredObject\nDESCRIPTION: Shows how to configure the FSSpec backend for the StoredObject type. This backend uses the fsspec library to support various storage systems like local filesystem and S3 storage.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport fsspec\nfrom advanced_alchemy.types.file_object.backends.fsspec import FSSpecBackend\n\n# Local filesystem\nfs = fsspec.filesystem(\"file\")\nbackend = FSSpecBackend(fs=fs, key=\"local\")\n\n# S3 storage\nfs = fsspec.S3FileSystem(\n    anon=False,\n    key=\"your-access-key\",\n    secret=\"your-secret-key\",\n    endpoint_url=\"https://your-s3-endpoint\",\n)\nbackend = FSSpecBackend(fs=fs, key=\"s3\", prefix=\"your-bucket\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Advanced Alchemy with Sanic\nDESCRIPTION: This code demonstrates how to set up the Advanced Alchemy extension with Sanic. It creates a Sanic app, configures the AdvancedAlchemy extension with an async SQLite connection, and registers it with the Sanic application.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/README.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom sanic import Sanic\nfrom sanic_ext import Extend\n\nfrom advanced_alchemy.extensions.sanic import AdvancedAlchemy, SQLAlchemyAsyncConfig\n\napp = Sanic(\"AlchemySanicApp\")\nalchemy = AdvancedAlchemy(\n    sqlalchemy_config=SQLAlchemyAsyncConfig(connection_string=\"sqlite+aiosqlite:///test.sqlite\"),\n)\nExtend.register(alchemy)\n```\n\n----------------------------------------\n\nTITLE: Configuring Obstore Backend for StoredObject\nDESCRIPTION: Demonstrates how to configure the Obstore backend for the StoredObject type. This backend provides a simple interface for object storage with support for both local storage and S3.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.types.file_object.backends.obstore import ObstoreBackend\n\n# Local storage\nbackend = ObstoreBackend(\n    key=\"local\",\n    fs=\"file:///path/to/storage\",\n)\n\n# S3 storage\nbackend = ObstoreBackend(\n    key=\"s3\",\n    fs=\"s3://your-bucket/\",\n    aws_access_key_id=\"your-access-key\",\n    aws_secret_access_key=\"your-secret-key\",\n    aws_endpoint=\"https://your-s3-endpoint\",\n)\n```\n\n----------------------------------------\n\nTITLE: Automatic File Cleanup with StoredObject\nDESCRIPTION: Shows how files are automatically cleaned up when file objects are removed from models or when models are deleted. This feature helps prevent orphaned files in storage systems.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Update file\ndoc.attachment = new_file_obj\nawait db_session.commit()  # Old file is automatically deleted\n\n# Clear file\ndoc.attachment = None\nawait db_session.commit()  # File is automatically deleted\n\n# Delete model\nawait db_session.delete(doc)\nawait db_session.commit()  # All associated files are automatically deleted\n```\n\n----------------------------------------\n\nTITLE: Integrating Advanced Alchemy with Starlette Web Framework\nDESCRIPTION: Shows how to integrate Advanced Alchemy with the Starlette web framework using AdvancedAlchemy and SQLAlchemyAsyncConfig.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/README.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.extensions.starlette import AdvancedAlchemy, SQLAlchemyAsyncConfig\nfrom starlette.applications import Starlette\n\napp = Starlette()\nalchemy = AdvancedAlchemy(\n    config=SQLAlchemyAsyncConfig(connection_string=\"sqlite+aiosqlite:///test.sqlite\"), app=app,\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Database Migrations\nDESCRIPTION: Command to initialize the migrations directory for an Advanced Alchemy project.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nalchemy init --config path.to.alchemy-config.config [DIRECTORY]\n```\n\n----------------------------------------\n\nTITLE: Showing Current Database Revision\nDESCRIPTION: Command to display the current revision of the database using the Advanced Alchemy CLI.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nalchemy show-current-revision --config path.to.alchemy-config.config\n```\n\n----------------------------------------\n\nTITLE: Integrating Advanced Alchemy with Flask Web Framework\nDESCRIPTION: Shows how to integrate Advanced Alchemy with the Flask web framework using AdvancedAlchemy and SQLAlchemySyncConfig.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/README.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask\nfrom advanced_alchemy.extensions.flask import AdvancedAlchemy, SQLAlchemySyncConfig\n\napp = Flask(__name__)\nalchemy = AdvancedAlchemy(\n    config=SQLAlchemySyncConfig(connection_string=\"duckdb:///:memory:\"), app=app,\n)\n```\n\n----------------------------------------\n\nTITLE: Extending CLI with Custom Commands using Click\nDESCRIPTION: Example of extending the Advanced Alchemy CLI with custom commands using Click. This adds a new command to the existing CLI framework.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.cli import get_alchemy_group, add_migration_commands\nimport click\n\n# Get the base group\nalchemy_group = get_alchemy_group()\n\n# Add your custom commands\n@alchemy_group.command(name=\"my-command\")\n@click.option(\"--my-option\", help=\"Custom option\")\ndef my_command(my_option):\n    \"\"\"My custom command.\"\"\"\n    click.echo(f\"Running my command with option: {my_option}\")\n\n# Add migration commands to your group\nadd_migration_commands(alchemy_group)\n```\n\n----------------------------------------\n\nTITLE: Implementing CollectionFilter Fix in Python\nDESCRIPTION: Fixes a bug where CollectionFilter returns all entries if the values list is empty. Appends '1=-1' to the 'where' clause when an empty list is passed to the 'in' statement.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/changelog.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Assuming the fix is implemented in the CollectionFilter class\nclass CollectionFilter:\n    def apply_filter(self, query, values):\n        if not values:\n            query = query.where(text(\"1=-1\"))  # Append this when values is empty\n        else:\n            # Apply normal filtering logic\n        return query\n```\n\n----------------------------------------\n\nTITLE: Integrating Alchemy Commands into Existing Click Group\nDESCRIPTION: Example of integrating Advanced Alchemy commands into an existing Click command group. This allows using Alchemy commands within a custom CLI application.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport click\nfrom advanced_alchemy.cli import add_migration_commands\n\n@click.group()\ndef cli():\n    \"\"\"My application CLI.\"\"\"\n    pass\n\n# Add migration commands to your CLI group\nadd_migration_commands(cli)\n\n@cli.command()\ndef my_command():\n    \"\"\"Custom command in your CLI.\"\"\"\n    pass\n\nif __name__ == \"__main__\":\n    cli()\n```\n\n----------------------------------------\n\nTITLE: Adding Tags to Posts with Manual Handling\nDESCRIPTION: Shows how to add tags to a post, including looking up existing tags and creating new ones if needed. This approach demonstrates manual handling of tag creation and association.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/modeling.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom advanced_alchemy.utils.text import slugify\n\nasync def add_tags_to_post(\n    db_session: AsyncSession,\n    post: Post,\n    tag_names: list[str]\n) -> Post:\n    \"\"\"Add tags to a post, looking up existing tags and creating new ones if needed.\"\"\"\n    existing_tags = await db_session.scalars(\n        select(Tag).filter(Tag.slug.in_([slugify(name) for name in tag_names]))\n    )\n    new_tags = [Tag(name=name, slug=slugify(name)) for name in tag_names if name not in {tag.name for tag in existing_tags}]\n    post.tags.extend(new_tags + list(existing_tags))\n    db_session.merge(post)\n    await db_session.flush()\n    return post\n```\n\n----------------------------------------\n\nTITLE: Using Combined Typer and Advanced Alchemy CLI Commands\nDESCRIPTION: Examples of using the combined CLI with both Typer commands and Advanced Alchemy commands. Shows command execution patterns after integration.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n# Use your Typer commands\npython cli.py hello Cody\n\n# Use Advanced Alchemy commands\npython cli.py alchemy upgrade --config path.to.config\npython cli.py alchemy make-migrations --config path.to.config\n```\n\n----------------------------------------\n\nTITLE: Configuring Alembic Type Aliasing for Advanced Alchemy Types\nDESCRIPTION: Shows how to configure the Alembic script.py.mako template to properly support Advanced Alchemy custom types. This configuration creates aliases in the sa namespace that Alembic uses when generating migrations.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"${message}\n\nRevision ID: ${up_revision}\nRevises: ${down_revision | comma,n}\nCreate Date: ${create_date}\n\n\"\"\"\nimport sqlalchemy as sa\n# ...\n\n# Import the types\nfrom advanced_alchemy.types import (\n    EncryptedString,\n    EncryptedText,\n    GUID,\n    ORA_JSONB,\n    DateTimeUTC,\n    StoredObject,\n)\n\n# Create aliases in the sa namespace\nsa.GUID = GUID\nsa.DateTimeUTC = DateTimeUTC\nsa.ORA_JSONB = ORA_JSONB\nsa.EncryptedString = EncryptedString\nsa.EncryptedText = EncryptedText\nsa.StoredObject = StoredObject\n# ...\n```\n\n----------------------------------------\n\nTITLE: Flask CLI Database Migration Commands\nDESCRIPTION: CLI commands for database migrations that are automatically added to the Flask CLI when using Advanced Alchemy. These commands help manage database schema changes.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/flask.rst#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Initialize migrations\nflask database init\n\n# Create a new migration\nflask database revision --autogenerate -m \"Add users table\"\n\n# Apply migrations\nflask database upgrade\n\n# Revert migrations\nflask database downgrade\n\n# Show migration history\nflask database history\n\n# Show all commands\nflask database --help\n```\n\n----------------------------------------\n\nTITLE: Enhancing Tag Model with UniqueMixin\nDESCRIPTION: Demonstrates how to use the UniqueMixin from Advanced Alchemy to enhance the Tag model. This mixin provides automatic handling of unique constraints and merging of duplicate records.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/modeling.rst#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.base import BigIntAuditBase, SlugKey\nfrom advanced_alchemy.mixins import UniqueMixin\nfrom advanced_alchemy.utils.text import slugify\nfrom sqlalchemy.sql.elements import ColumnElement\nfrom typing import Hashable\n\nclass Tag(BigIntAuditBase, SlugKey, UniqueMixin):\n    \"\"\"Tag model with unique name constraint and automatic slug generation.\n\n    The UniqueMixin provides:\n    - Automatic lookup of existing records\n    - Safe merging of duplicates\n    - Consistent slug generation\n    \"\"\"\n\n    name: Mapped[str] = mapped_column(unique=True, index=True)\n    posts: Mapped[list[Post]] = relationship(\n        secondary=post_tag,\n        back_populates=\"tags\",\n        viewonly=True\n    )\n\n    @classmethod\n    def unique_hash(cls, name: str, slug: str | None = None) -> Hashable:\n        \"\"\"Generate a unique hash for deduplication.\"\"\"\n        return slugify(name)\n\n    @classmethod\n    def unique_filter(\n        cls,\n        name: str,\n        slug: str | None = None,\n    ) -> ColumnElement[bool]:\n        \"\"\"SQL filter for finding existing records.\"\"\"\n        return cls.slug == slugify(name)\n```\n\n----------------------------------------\n\nTITLE: Handling Empty Collection Filters in Python\nDESCRIPTION: Improves the handling of empty collection filters in dependency injection, allowing all filters to be passed into the repository function without checking their nullability.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/changelog.rst#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example of improved filter handling in a dependency\ndef id_filter(request: Request) -> Optional[CollectionFilter]:\n    filter_value = request.query_params.get(\"id\")\n    return CollectionFilter(\"id\", filter_value) if filter_value else None\n\n# In repository function\ndef get_items(filters: List[Optional[CollectionFilter]]):\n    query = select(Item)\n    for filter in filters:\n        if filter is not None:\n            query = filter.apply(query)\n    return query.all()\n```\n\n----------------------------------------\n\nTITLE: Installing Advanced Alchemy via pip\nDESCRIPTION: Command to install the Advanced Alchemy library using pip package manager.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/README.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npip install advanced-alchemy\n```\n\n----------------------------------------\n\nTITLE: Updating Multiple Posts with Bulk Operations\nDESCRIPTION: Demonstrates how to update multiple posts in a single operation by fetching posts matching specified IDs and modifying their properties.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/repositories.rst#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nasync def publish_posts(db_session: AsyncSession, post_ids: list[int]) -> list[Post]:\n    repository = PostRepository(session=db_session)\n\n    # Fetch posts to update\n    posts = await repository.list(Post.id.in_(post_ids), published =False)\n\n    # Update all posts\n    for post in posts:\n        post.published = True\n\n    return await repository.update_many(posts)\n```\n\n----------------------------------------\n\nTITLE: Installing Advanced Alchemy with UV\nDESCRIPTION: Command to install the Advanced Alchemy package using UV package manager.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/getting-started.rst#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nuv add advanced-alchemy\n```\n\n----------------------------------------\n\nTITLE: Installing Advanced Alchemy with PDM\nDESCRIPTION: Command to install the Advanced Alchemy package using PDM package manager.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/getting-started.rst#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npdm add advanced-alchemy\n```\n\n----------------------------------------\n\nTITLE: Deleting Multiple Posts with delete_many Method\nDESCRIPTION: Shows how to delete multiple posts at once using their IDs with the delete_many method of the repository.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/repositories.rst#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nasync def delete_posts(db_session: AsyncSession, post_ids: list[int]) -> list[Post]:\n    repository = PostRepository(session=db_session)\n\n    return await repository.delete_many(Post.id.in_(post_ids))\n```\n\n----------------------------------------\n\nTITLE: Installing Advanced Alchemy with Poetry\nDESCRIPTION: Command to install the Advanced Alchemy package using Poetry dependency manager.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/getting-started.rst#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npoetry add advanced-alchemy\n```\n\n----------------------------------------\n\nTITLE: Installing Advanced Alchemy CLI with Poetry\nDESCRIPTION: Command to install the Advanced Alchemy CLI using Poetry package manager.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npoetry add advanced-alchemy[cli]\n```\n\n----------------------------------------\n\nTITLE: Deleting Posts by Condition with delete_where Method\nDESCRIPTION: Demonstrates how to delete posts that match a specific condition using the delete_where method to remove unpublished posts.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/repositories.rst#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nasync def delete_unpublished_posts (db_session: AsyncSession) -> list[Post]:\n    repository = PostRepository(session=db_session)\n\n    return await repository.delete_where(Post.published == False)\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Make Commands\nDESCRIPTION: Commands to install UV package manager and project dependencies for contributing to Advanced Alchemy.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/CONTRIBUTING.rst#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake install-uv\n```\n\nLANGUAGE: bash\nCODE:\n```\nmake install\n```\n\n----------------------------------------\n\nTITLE: Installing Advanced Alchemy with pip\nDESCRIPTION: Command to install the Advanced Alchemy package using pip package manager.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/getting-started.rst#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m pip install advanced-alchemy\n```\n\n----------------------------------------\n\nTITLE: Running Linters and Code Quality Tools\nDESCRIPTION: Commands for running linters and formatters to ensure code quality before committing changes.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/CONTRIBUTING.rst#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake lint\n```\n\n----------------------------------------\n\nTITLE: Using BigIntIdentity Type for Integer Primary Keys\nDESCRIPTION: Demonstrates the BigIntIdentity type which provides a BigInteger primary key that automatically falls back to Integer for SQLite databases, ensuring cross-database compatibility.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom advanced_alchemy.base import DefaultBase\nfrom advanced_alchemy.types import BigIntIdentity\n\nclass MyModel(DefaultBase):\n    __tablename__ = \"my_model\"\n    id: Mapped[int] = mapped_column(BigIntIdentity, primary_key=True)\n```\n\n----------------------------------------\n\nTITLE: Managing Metadata with FileObject\nDESCRIPTION: Demonstrates how to add and update metadata for file objects. Metadata can be used to store additional information about files such as categories, tags, or any other custom data.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/types.rst#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfile_obj = FileObject(\n    backend=\"local_test_store\",\n    filename=\"test.txt\",\n    metadata={\n        \"category\": \"document\",\n        \"tags\": [\"important\", \"review\"],\n    },\n)\n\n# Update metadata\nfile_obj.update_metadata({\"priority\": \"high\"})\n```\n\n----------------------------------------\n\nTITLE: Installing Advanced Alchemy CLI with pipx\nDESCRIPTION: Command to install the Advanced Alchemy CLI using pipx for isolated environments.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npipx install advanced-alchemy[cli]\n```\n\n----------------------------------------\n\nTITLE: Synchronous Database Seeding with Advanced Alchemy\nDESCRIPTION: Python script demonstrating synchronous database initialization and seeding using Advanced Alchemy. It includes setting up the database configuration, defining a Product model, creating a repository, and loading fixtures from a JSON file.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/database_seeding.rst#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\n\nfrom sqlalchemy import String, create_engine\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom advanced_alchemy.base import UUIDBase\nfrom advanced_alchemy.config import SQLAlchemySyncConfig, SyncSessionConfig\nfrom advanced_alchemy.repository import SQLAlchemySyncRepository\nfrom advanced_alchemy.utils.fixtures import open_fixture\n\n# Database connection string\nDATABASE_URL = \"sqlite:///db.sqlite3\"\n\nconfig = SQLAlchemySyncConfig(\n    engine_instance=create_engine(DATABASE_URL),\n    session_config=SyncSessionConfig(expire_on_commit=False)\n)\n\nclass Product(UUIDBase):\n    \"\"\"Product model.\"\"\"\n    __tablename__ = \"products\"\n\n    name: Mapped[str] = mapped_column(String(length=100))\n    description: Mapped[str | None] = mapped_column(String(length=500))\n    price: Mapped[float]\n    in_stock: Mapped[bool] = mapped_column(default=True)\n\n\n# Repository\nclass ProductRepository(SQLAlchemySyncRepository[Product]):\n    \"\"\"Product repository.\"\"\"\n    model_type = Product\n\n\n# Set up fixtures path\nfixtures_path = Path(__file__).parent / \"fixtures\"\n\n\ndef initialize_database():\n    \"\"\"Initialize the database and create tables.\"\"\"\n    print(\"Creating database tables...\")\n    with config.get_engine().begin() as conn:\n        UUIDBase.metadata.create_all(conn)\n    print(\"Tables created successfully\")\n\n\ndef seed_database():\n    \"\"\"Seed the database with fixture data.\"\"\"\n    print(\"Seeding database...\")\n\n    # Create a session\n    with config.get_session() as db_session:\n        # Create repository for product model\n        product_repo = ProductRepository(session=db_session)\n\n        # Load and add product data\n        try:\n            print(f\"Attempting to load fixtures from {fixtures_path}/product.json\")\n            product_data = open_fixture(fixtures_path, \"product\")\n            print(f\"Loaded {len(product_data)} products from fixture\")\n            product_repo.add_many([Product(**item) for item in product_data])\n            db_session.commit()\n        except FileNotFoundError:\n            print(f\"Could not find fixture file at {fixtures_path}/product.json\")\n\n\nif __name__ == \"__main__\":\n    # Initialize the database\n    initialize_database()\n\n    # Seed the database\n    seed_database()\n```\n\n----------------------------------------\n\nTITLE: Markdown Status Table Implementation\nDESCRIPTION: Markdown table displaying project status information including CI/CD, quality metrics, package information, community links, and meta information with badge implementations.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/README.md#2025-04-17_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n| Project   |     | Status                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n|-----------|:----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n```\n\n----------------------------------------\n\nTITLE: Integrating Advanced Alchemy with Litestar Web Framework\nDESCRIPTION: Python script demonstrating how to integrate Advanced Alchemy with the Litestar web framework. It includes setting up SQLAlchemy configuration, defining a Product model, creating a repository, and implementing a startup routine for database seeding.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/database_seeding.rst#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\nfrom typing import Optional\n\nimport uvicorn\nfrom litestar import Litestar\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom advanced_alchemy.base import UUIDBase\nfrom advanced_alchemy.extensions.litestar import (\n    AsyncSessionConfig,\n    SQLAlchemyAsyncConfig,\n    SQLAlchemyPlugin,\n)\nfrom advanced_alchemy.repository import SQLAlchemyAsyncRepository\nfrom advanced_alchemy.utils.fixtures import open_fixture_async\n\n# Database connection string\nDATABASE_URL = \"sqlite+aiosqlite:///db.sqlite3\"\n\n# Set up fixtures path\nfixtures_path = Path(__file__).parent / \"fixtures\"\n\nsession_config = AsyncSessionConfig(expire_on_commit=False)\nsqlalchemy_config = SQLAlchemyAsyncConfig(\n    connection_string=DATABASE_URL,\n    before_send_handler=\"autocommit\",\n    session_config=session_config,\n    create_all=True,\n)\nalchemy = SQLAlchemyPlugin(config=sqlalchemy_config)\n\n\nclass Product(UUIDBase):\n    \"\"\"Product model.\"\"\"\n    __tablename__ = \"products\"\n\n    name: Mapped[str] = mapped_column(String(length=100))\n    description: Mapped[Optional[str]] = mapped_column(String(length=500))\n    price: Mapped[float]\n    in_stock: Mapped[bool] = mapped_column(default=True)\n\n\n# Repository\nclass ProductRepository(SQLAlchemyAsyncRepository[Product]):\n    \"\"\"Product repository.\"\"\"\n    model_type = Product\n\n\n# Startup function to seed the database\nasync def on_startup() -> None:\n    \"\"\"Seed the database during application startup.\"\"\"\n    print(\"Running startup routine...\")\n\n    # Create a session and seed data\n    async with sqlalchemy_config.get_session() as db_session:\n        # Create repository for product model\n        product_repo = ProductRepository(session=db_session)\n        # Load and add product data\n        try:\n            print(f\"Attempting to load fixtures from {fixtures_path}/product.json\")\n            product_data = await open_fixture_async(fixtures_path, \"product\")\n            print(f\"Loaded {len(product_data)} products from fixture\")\n            await product_repo.add_many([Product(**item) for item in product_data])\n            await db_session.commit()\n        except FileNotFoundError:\n            print(f\"Could not find fixture file at {fixtures_path}/product.json\")\n\n        # Verify data was added\n        products = await product_repo.list()\n        print(f\"Database seeded with {len(products)} products\")\n\n\n# Create the Litestar application\napp = Litestar(\n```\n\n----------------------------------------\n\nTITLE: Flask Database Seeding Implementation\nDESCRIPTION: Shows database seeding in a Flask application using Advanced Alchemy with synchronous SQLite database. Includes product model definition, repository configuration, and fixture loading within Flask's application context.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/database_seeding.rst#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom flask import Flask\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom advanced_alchemy.base import UUIDBase\nfrom advanced_alchemy.extensions.flask import (\n    AdvancedAlchemy,\n    SQLAlchemySyncConfig,\n    SyncSessionConfig,\n)\nfrom advanced_alchemy.repository import SQLAlchemySyncRepository\nfrom advanced_alchemy.utils.fixtures import open_fixture\n\nDATABASE_URL = \"sqlite:///db.sqlite3\"\n\nfixtures_path = Path(__file__).parent / \"fixtures\"\n\nclass Product(UUIDBase):\n    \"\"\"Product model.\"\"\"\n    __tablename__ = \"products\"\n\n    name: Mapped[str] = mapped_column(String(length=100))\n    description: Mapped[Optional[str]] = mapped_column(String(length=500))\n    price: Mapped[float]\n    in_stock: Mapped[bool] = mapped_column(default=True)\n\nclass ProductRepository(SQLAlchemySyncRepository[Product]):\n    \"\"\"Product repository.\"\"\"\n    model_type = Product\n\napp = Flask(__name__)\n\nsqlalchemy_config = SQLAlchemySyncConfig(\n    connection_string=DATABASE_URL,\n    commit_mode=\"autocommit\",\n    session_config=SyncSessionConfig(\n        expire_on_commit=False,\n    ),\n    create_all=True\n)\n\ndb = AdvancedAlchemy(config=sqlalchemy_config)\ndb.init_app(app)\n\nwith app.app_context():\n    with db.get_session() as session:\n        product_repo = ProductRepository(session=db_session)\n        try:\n            print(f\"Attempting to load fixtures from {fixtures_path}/product.json\")\n            product_data = open_fixture(fixtures_path, \"product\")\n            print(f\"Loaded {len(product_data)} products from fixture\")\n            product_repo.add_many([Product(**item) for item in product_data])\n            db_session.commit()\n        except FileNotFoundError:\n            print(f\"Could not find fixture file at {fixtures_path}/product.json\")\n        products = product_repo.list()\n        print(f\"Database seeded with {len(products)} products\")\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=5000)\n```\n\n----------------------------------------\n\nTITLE: Basic CLI Usage Help Command\nDESCRIPTION: Command to display help information for the Advanced Alchemy CLI.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nalchemy --help\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Repository Module\nDESCRIPTION: ReStructuredText directive for auto-generating module documentation. Specifies to include members, imported members, undocumented members and inheritance information for the advanced_alchemy.repository module.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/repository.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: advanced_alchemy.repository\n    :members:\n    :imported-members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Creating SQLAlchemy Configuration for CLI\nDESCRIPTION: Example configuration file for the Advanced Alchemy CLI using SQLAlchemyConfig. This defines the database connection used by CLI commands.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy import create_engine\nfrom advanced_alchemy.config import SQLAlchemyConfig\n\n# Create a test config using SQLite\nconfig = SQLAlchemyConfig(\n    connection_url=\"sqlite:///test.db\"\n)\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Block for Advanced Alchemy Alembic Utils Module\nDESCRIPTION: This RST (reStructuredText) code block configures Sphinx to automatically generate documentation for all members within the advanced_alchemy.alembic.utils module. The automodule directive instructs Sphinx to extract docstrings and member information from the specified module.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/alembic/utils.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: advanced_alchemy.alembic.utils\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodoc for AsyncIO Module in Advanced Alchemy\nDESCRIPTION: This RST directive configures Sphinx to automatically generate documentation for the asyncio module in the Advanced Alchemy library. It includes all members, imported members, undocumented members, and shows inheritance relationships.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/config/asyncio.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: advanced_alchemy.config.asyncio\n    :members:\n    :imported-members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Integrating Alchemy CLI with Typer Framework\nDESCRIPTION: Example of integrating Advanced Alchemy CLI commands into a Typer application. This creates a CLI that combines Typer commands with Advanced Alchemy commands.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport typer\nfrom advanced_alchemy.cli import get_alchemy_group, add_migration_commands\n\napp = typer.Typer()\n\n@app.command()\ndef hello(name: str) -> None:\n    \"\"\"Says hello to the world.\"\"\"\n    typer.echo(f\"Hello {name}\")\n\n@app.callback()\ndef callback():\n    \"\"\"\n    Typer app, including Click subapp\n    \"\"\"\n    pass\n\ndef create_cli() -> typer.Typer:\n    \"\"\"Create the CLI application with both Typer and Click commands.\"\"\"\n    # Get the Click group from advanced_alchemy\n    alchemy_group = get_alchemy_group()\n\n    # Convert our Typer app to a Click command object\n    typer_click_object = typer.main.get_command(app)\n\n    # Add all migration commands from the alchemy group to our CLI\n    typer_click_object.add_command(add_migration_commands(alchemy_group))\n\n    return typer_click_object\n\nif __name__ == \"__main__\":\n    cli = create_cli()\n    cli()\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Documentation for Advanced Alchemy Plugin Module\nDESCRIPTION: RST directive configuration for auto-generating module documentation, excluding specific engine and SQLAlchemy configuration members from the documentation output.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/extensions/litestar/plugins.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: advanced_alchemy.extensions.litestar.plugins\n    :members:\n    :exclude-members:\n    :no-index: EngineConfig, SQLAlchemyAsyncConfig, SQLAlchemySyncConfig\n```\n\n----------------------------------------\n\nTITLE: Sphinx AutoModule Directive for Audit Module\nDESCRIPTION: Sphinx documentation directive that automatically generates API documentation from the advanced_alchemy.mixins.audit module, including all its members.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/mixins/audit.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: advanced_alchemy.mixins.audit\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Dumping Table Data to JSON Files\nDESCRIPTION: Command to dump specified tables from the database to JSON files using the Advanced Alchemy CLI.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nalchemy dump-data --config path.to.alchemy-config.config --table TABLE_NAME\n```\n\n----------------------------------------\n\nTITLE: Generating BigInt Mixin Documentation with Sphinx\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for the bigint mixin module in Advanced Alchemy. It includes all members of the module.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/mixins/bigint.rst#2025-04-17_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: advanced_alchemy.mixins.bigint\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Sphinx automodule directive for NanoID documentation\nDESCRIPTION: A Sphinx documentation directive that automatically generates API documentation for the advanced_alchemy.mixins.nanoid module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/mixins/nanoid.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: advanced_alchemy.mixins.nanoid\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Dropping All Tables from Database\nDESCRIPTION: Command to drop all tables from the database using the Advanced Alchemy CLI.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nalchemy drop-all --config path.to.alchemy-config.config\n```\n\n----------------------------------------\n\nTITLE: Generating Slug Mixin Documentation with reStructuredText\nDESCRIPTION: This snippet uses the automodule directive to automatically generate documentation for all members of the advanced_alchemy.mixins.slug module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/mixins/slug.rst#2025-04-17_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: advanced_alchemy.mixins.slug\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating UUID Mixin Documentation with Sphinx\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the advanced_alchemy.mixins.uuid module. It includes all public classes, functions, and attributes in the documentation.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/mixins/uuid.rst#2025-04-17_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: advanced_alchemy.mixins.uuid\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Creating New Migration Revision\nDESCRIPTION: Command to create a new migration revision with the Advanced Alchemy CLI.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nalchemy make-migrations --config path.to.alchemy-config.config\n```\n\n----------------------------------------\n\nTITLE: Setting up Sphinx automodule for Alembic commands documentation in RST\nDESCRIPTION: A reStructuredText directive that configures Sphinx to automatically generate documentation for all members of the advanced_alchemy.alembic.commands module. This is part of the API documentation generation process.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/alembic/commands.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: advanced_alchemy.alembic.commands\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Importing Sanic Extensions Module in Python\nDESCRIPTION: This snippet shows how to import the Sanic extensions module and its components. It includes various submodules and classes for SQLAlchemy and Alembic integration.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/extensions/sanic/index.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.extensions.sanic import (\n    AlembicAsyncConfig,\n    AlembicSyncConfig,\n    AsyncSessionConfig,\n    EngineConfig,\n    SQLAlchemyAsyncConfig,\n    SQLAlchemySyncConfig,\n    SyncSessionConfig\n)\n```\n\n----------------------------------------\n\nTITLE: Upgrading Database to Specific Revision\nDESCRIPTION: Command to upgrade a database to a specific revision with the Advanced Alchemy CLI.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nalchemy upgrade --config path.to.alchemy-config.config [REVISION]\n```\n\n----------------------------------------\n\nTITLE: Including CONTRIBUTING.rst Document in RST\nDESCRIPTION: RST directive to include the CONTRIBUTING.rst file from parent directory into the current document.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/contribution-guide.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n:orphan:\n\n.. include:: ../CONTRIBUTING.rst\n```\n\n----------------------------------------\n\nTITLE: Rendering HTML for Advanced Alchemy Logo in RST\nDESCRIPTION: This snippet renders a custom HTML div to display the Advanced Alchemy logo and brand text. It's used to create a visually appealing header for the documentation landing page.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/index.rst#2025-04-17_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<div class=\"title-with-logo\">\n    <div class=\"brand-text\">Advanced Alchemy</div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Downgrading Database to Specific Revision\nDESCRIPTION: Command to downgrade a database to a specific revision with the Advanced Alchemy CLI.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nalchemy downgrade --config path.to.alchemy-config.config [REVISION]\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dependency Injection\nDESCRIPTION: Configures dependency injection for the FastAPI application. It defines types for database sessions and author services, and provides a function to create and yield author service instances.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/frameworks/fastapi.rst#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom fastapi import Request\n\nDatabaseSession = Annotated[AsyncSession, Depends(alchemy.provide_session())]\nAuthors = Annotated[AuthorService, Depends(provide_authors_service)]\n\nasync def provide_authors_service(db_session: DatabaseSession) -> AsyncGenerator[AuthorService, None]:\n    \"\"\"This provides the default Authors repository.\"\"\"\n    async with AuthorService.new(session=db_session) as service:\n        yield service\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Fixture for Product Data\nDESCRIPTION: Example of a JSON fixture file containing product data for database seeding. Each object represents a row in the products table with fields for name, description, price, and stock status.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/database_seeding.rst#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n[\n    {\n        \"name\": \"Laptop\",\n        \"description\": \"High-performance laptop with 16GB RAM and 1TB SSD\",\n        \"price\": 999.99,\n        \"in_stock\": true\n    },\n    {\n        \"name\": \"Smartphone\",\n        \"description\": \"Latest smartphone model with 5G and advanced camera\",\n        \"price\": 699.99,\n        \"in_stock\": true\n    },\n    {\n        \"name\": \"Headphones\",\n        \"description\": \"Noise-cancelling wireless headphones with 30-hour battery life\",\n        \"price\": 199.99,\n        \"in_stock\": true\n    },\n    {\n        \"name\": \"Smartwatch\",\n        \"description\": \"Fitness tracker with heart rate monitor and GPS\",\n        \"price\": 149.99,\n        \"in_stock\": false\n    },\n    {\n        \"name\": \"Tablet\",\n        \"description\": \"10-inch tablet with high-resolution display\",\n        \"price\": 349.99,\n        \"in_stock\": true\n    }\n]\n```\n\n----------------------------------------\n\nTITLE: Installing Advanced Alchemy CLI with PDM\nDESCRIPTION: Command to install the Advanced Alchemy CLI using PDM package manager.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npdm add advanced-alchemy[cli]\n```\n\n----------------------------------------\n\nTITLE: Installing Advanced Alchemy CLI with UV\nDESCRIPTION: Command to install the Advanced Alchemy CLI using UV package manager.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nuv add advanced-alchemy[cli]\n```\n\n----------------------------------------\n\nTITLE: Installing Advanced Alchemy CLI with pip\nDESCRIPTION: Command to install the Advanced Alchemy CLI using pip package manager.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/usage/cli.rst#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m pip install advanced-alchemy[cli]\n```\n\n----------------------------------------\n\nTITLE: Installing Advanced Alchemy with pipx\nDESCRIPTION: Command to install the Advanced Alchemy package using pipx for isolated environments.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/getting-started.rst#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npipx install advanced-alchemy\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for advanced_alchemy.mixins.unique Module\nDESCRIPTION: This reStructuredText directive automatically generates documentation for the advanced_alchemy.mixins.unique module, including all its members. It's typically used in Sphinx documentation to create API references.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/mixins/unique.rst#2025-04-17_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: advanced_alchemy.mixins.unique\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting CLI Extension Module for Litestar in Python\nDESCRIPTION: This code snippet uses the Sphinx automodule directive to generate documentation for the 'advanced_alchemy.extensions.litestar.cli' module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/extensions/litestar/cli.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. automodule:: advanced_alchemy.extensions.litestar.cli\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Configuration for Advanced Alchemy Services Module\nDESCRIPTION: Sphinx documentation directive that automatically generates documentation for the advanced_alchemy.service module. The configuration includes all members, imported members, undocumented members, and inheritance information.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/service.rst#2025-04-17_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: advanced_alchemy.service\n    :members:\n    :imported-members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Defining Extensions Module API Reference Structure in RST\nDESCRIPTION: This RST (reStructuredText) snippet defines the structure for the Extensions module API reference documentation. It includes a title, a note about private methods, and a table of contents for different framework integrations.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/extensions/index.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==========\nExtensions\n==========\n\nAPI Reference for the ``Extensions`` module\n\n.. note:: Private methods and attributes are not included in the API reference.\n\nAvailable API References\n------------------------\n\n.. toctree::\n    :titlesonly:\n\n    litestar/index\n    flask/index\n    sanic/index\n    starlette/index\n    fastapi/index\n```\n\n----------------------------------------\n\nTITLE: Importing Advanced Alchemy Modules for FastAPI Extension\nDESCRIPTION: This code snippet shows the module imports for the FastAPI extension. It includes various components from the advanced_alchemy package that are relevant for FastAPI integration.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/extensions/fastapi/index.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.utils import *\nfrom advanced_alchemy.base import *\nfrom advanced_alchemy.exceptions import *\nfrom advanced_alchemy.filters import *\nfrom advanced_alchemy.mixins import *\nfrom advanced_alchemy.operations import *\nfrom advanced_alchemy.repository import *\nfrom advanced_alchemy.service import *\nfrom advanced_alchemy.types import *\nfrom advanced_alchemy.alembic.commands import AlembicCommands\nfrom advanced_alchemy.extensions.starlette import EngineConfig, SQLAlchemyAsyncConfig, SQLAlchemySyncConfig\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx AutoModule Documentation for Operations Module\nDESCRIPTION: RST directive configuration to automatically generate documentation for the advanced_alchemy.operations module. This configuration shows all members, imported members, undocumented members and inheritance relationships.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/operations.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: advanced_alchemy.operations\n    :members:\n    :imported-members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx AutoModule for Advanced Alchemy Exceptions\nDESCRIPTION: A reStructuredText directive for Sphinx that configures automatic documentation generation for the advanced_alchemy.exceptions module. It includes all members while excluding ErrorMessages from the index and showing inheritance hierarchies.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/exceptions.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: advanced_alchemy.exceptions\n    :members:\n    :no-index: ErrorMessages\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Building and Serving Documentation\nDESCRIPTION: Commands for setting up, building, and locally serving the project documentation.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/CONTRIBUTING.rst#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake install\n```\n\nLANGUAGE: bash\nCODE:\n```\nmake docs-serve\n```\n\nLANGUAGE: bash\nCODE:\n```\nmake docs\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx AutoModule Documentation\nDESCRIPTION: Sphinx documentation configuration directive that specifies how to document the advanced_alchemy.config.types module. It includes settings to show all members, imported members, undocumented members and inheritance information.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/config/types.rst#2025-04-17_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: advanced_alchemy.config.types\n    :members:\n    :imported-members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Generating Sentinel Module Documentation using Sphinx\nDESCRIPTION: This reStructuredText directive instructs Sphinx to automatically generate documentation for the advanced_alchemy.mixins.sentinel module, including all its members. It's typically used in Sphinx documentation projects to create API references.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/mixins/sentinel.rst#2025-04-17_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: advanced_alchemy.mixins.sentinel\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Python Module Documentation for Advanced Alchemy Sync Configuration\nDESCRIPTION: This snippet uses Sphinx's autodoc extension to automatically generate documentation for the advanced_alchemy.config.sync module. It includes all members, imported members, undocumented members, and shows inheritance relationships.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/reference/config/sync.rst#2025-04-17_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: advanced_alchemy.config.sync\n    :members:\n    :imported-members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Rendering HTML for Documentation Navigation Buttons in RST\nDESCRIPTION: This snippet creates HTML buttons for navigating to different sections of the Advanced Alchemy documentation. It includes links to 'Get Started', 'Usage Docs', and 'API Docs'.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/index.rst#2025-04-17_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<a href=\"getting-started.html\" class=\"btn-no-wrap\">Get Started</a>\n<a href=\"usage/index.html\" class=\"btn-no-wrap\">Usage Docs</a>\n<a href=\"reference/index.html\" class=\"btn-no-wrap\">API Docs</a>\n```\n\n----------------------------------------\n\nTITLE: Enhancing SQLAlchemy DTO Generation for Non-Column Fields in Python\nDESCRIPTION: Improves SQLAlchemy DTO generation for Litestar when using models with fields that are not instances of Column, such as ColumnClause and Label generated by sqlalchemy.func.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/changelog.rst#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy import Column, func\nfrom sqlalchemy.sql import ColumnClause, Label\n\ndef generate_dto(model):\n    dto_fields = {}\n    for name, field in model.__dict__.items():\n        if isinstance(field, (Column, ColumnClause, Label)):\n            dto_fields[name] = field.type.python_type\n    return type(f\"{model.__name__}DTO\", (), dto_fields)\n```\n\n----------------------------------------\n\nTITLE: Preventing ID Overwrite in Python Service\nDESCRIPTION: Fixes an issue where the primary key could be overwritten with None when using the service without the item_id parameter.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/changelog.rst#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass ItemService:\n    def update_item(self, item: Item, item_id: Optional[int] = None):\n        if item_id is not None:\n            item.id = item_id\n        # Proceed with update logic\n```\n\n----------------------------------------\n\nTITLE: Updating Service Exists Method in Python\nDESCRIPTION: Modifies the service 'exists' method to use the repository's implementation instead of a new one with a 'count'.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/changelog.rst#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass ItemService:\n    def __init__(self, repository: ItemRepository):\n        self.repository = repository\n\n    def exists(self, item_id: int) -> bool:\n        return self.repository.exists(item_id)  # Use repository's exists method\n```\n\n----------------------------------------\n\nTITLE: Project Banner HTML Markup\nDESCRIPTION: HTML markup for displaying the project banner image with center alignment and responsive sizing.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/docs/PYPI_README.md#2025-04-17_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/litestar-org/branding/refs/heads/main/assets/Branding%20-%20SVG%20-%20Transparent/AA%20-%20Banner%20-%20Inline%20-%20Light.svg\" alt=\"Litestar Logo - Light\" width=\"100%\" height=\"auto\" />\n</p>\n```\n\n----------------------------------------\n\nTITLE: HTML Banner Implementation with Light/Dark Mode\nDESCRIPTION: HTML code block implementing responsive banner images that switch between light and dark modes using GitHub's theme detection. Includes centered alignment and SVG image references.\nSOURCE: https://github.com/litestar-org/advanced-alchemy/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/litestar-org/branding/main/assets/Branding%20-%20SVG%20-%20Transparent/AA%20-%20Banner%20-%20Inline%20-%20Light.svg#gh-light-mode-only\" alt=\"Litestar Logo - Light\" width=\"100%\" height=\"auto\" />\n  <img src=\"https://raw.githubusercontent.com/litestar-org/branding/main/assets/Branding%20-%20SVG%20-%20Transparent/AA%20-%20Banner%20-%20Inline%20-%20Dark.svg#gh-dark-mode-only\" alt=\"Litestar Logo - Dark\" width=\"100%\" height=\"auto\" />\n</p>\n```"
  }
]