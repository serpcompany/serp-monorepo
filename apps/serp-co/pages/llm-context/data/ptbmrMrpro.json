[
  {
    "owner": "ptb-mr",
    "repo": "mrpro",
    "content": "TITLE: Loading MRI K-space Data in Python using mrpro\nDESCRIPTION: Reads fully sampled and undersampled k-space data from ISMRMRD files using mrpro library. This data will be used for image reconstruction and coil sensitivity map estimation.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport mrpro\n\nkdata_fullysampled = mrpro.data.KData.from_file(\n    data_folder / 'radial2D_402spokes_golden_angle_with_traj.h5',\n    mrpro.data.traj_calculators.KTrajectoryIsmrmrd(),\n)\nkdata_undersampled = mrpro.data.KData.from_file(\n    data_folder / 'radial2D_24spokes_golden_angle_with_traj.h5',\n    mrpro.data.traj_calculators.KTrajectoryIsmrmrd(),\n)\n```\n\n----------------------------------------\n\nTITLE: Direct Reconstruction with MRpro's High-Level API\nDESCRIPTION: Uses MRpro's DirectReconstruction algorithm to simplify the reconstruction process. This high-level API handles the entire pipeline automatically, operating on KData objects and producing IData objects.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n\n# Create DirectReconstruction object from KData object\ndirect_recon_pe_pf = mrpro.algorithms.reconstruction.DirectReconstruction(kdata_pe_pf)\n\n# Reconstruct image by calling the DirectReconstruction object\nidat_pe_pf = direct_recon_pe_pf(kdata_pe_pf)\n```\n\n----------------------------------------\n\nTITLE: Defining Inversion Recovery Signal Model for T1 Mapping\nDESCRIPTION: Creates a signal model for inversion recovery using the mrpro library. The model combines a magnitude operator with an inversion recovery model to handle the magnitude data from DICOM images.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmodel = mrpro.operators.MagnitudeOp() @ mrpro.operators.models.InversionRecovery(ti=idata_multi_ti.header.ti)\n```\n\n----------------------------------------\n\nTITLE: Iterative SENSE Reconstruction for Undersampled MRI Data\nDESCRIPTION: Applies the more sophisticated iterative SENSE reconstruction algorithm to reduce undersampling artifacts in the MRI image.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nsense_recon_us = mrpro.algorithms.reconstruction.IterativeSENSEReconstruction(\n    kdata_us,\n    csm=direct_recon_calib_lines.csm,\n    n_iterations=8,\n)\nidat_us_sense = sense_recon_us(kdata_us)\nshow_images(idat_us_sense.rss().squeeze(), titles=['Iterative SENSE'])\n```\n\n----------------------------------------\n\nTITLE: MRI Operator Composition for Simplified Reconstruction\nDESCRIPTION: Demonstrates how to compose multiple MRpro operators (Fourier and coil sensitivity) and use the adjoint of the composite operator for streamlined image reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n### Operator Composition\n# Create composite operator\nadjoint_operator = (fourier_op @ csm_op).H\n(magnitude_pe_pf,) = adjoint_operator(kdata_pe_pf.data)\nmagnitude_pe_pf = magnitude_pe_pf.abs().squeeze()\nshow_images(magnitude_pe_pf, titles=['PF & PE'])\n```\n\n----------------------------------------\n\nTITLE: Reconstructing Fully Sampled MRI Image in Python\nDESCRIPTION: Performs unregularized iterative SENSE reconstruction on fully sampled data to create a reference image for regularization. It also estimates coil sensitivity maps.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndirect_reconstruction = mrpro.algorithms.reconstruction.DirectReconstruction(kdata_fullysampled)\ncsm = direct_reconstruction.csm\nassert csm is not None\n\niterative_sense_reconstruction = mrpro.algorithms.reconstruction.IterativeSENSEReconstruction(\n    kdata_fullysampled, csm=csm, n_iterations=3\n)\nimg_iterative_sense = iterative_sense_reconstruction(kdata_fullysampled)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Iterative SENSE Reconstruction\nDESCRIPTION: Configures an iterative SENSE reconstruction using pre-computed Fourier operator, coil sensitivity maps and density compensation from the direct reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\niterative_sense_reconstruction = mrpro.algorithms.reconstruction.IterativeSENSEReconstruction(\n    fourier_op=direct_reconstruction.fourier_op,\n    csm=direct_reconstruction.csm,\n    dcf=direct_reconstruction.dcf,\n    n_iterations=4,\n)\n```\n\n----------------------------------------\n\nTITLE: Displaying Comparison of Different MRI Reconstruction Methods\nDESCRIPTION: Visualizes and compares different MRI reconstruction results including fully sampled (402 spokes), direct reconstruction (24 spokes), SENSE reconstruction (24 spokes), and wavelet-regularized PGD reconstruction (24 spokes). This helps evaluate the effectiveness of the wavelet regularization approach.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# see the collapsed cell above for the implementation of show_images\nshow_images(\n    img_direct_402.rss().squeeze(),\n    img_direct_24.rss().squeeze(),\n    img_sense_24.rss().squeeze(),\n    img_pgd_24.abs().squeeze(),\n    titles=['402 spokes', '24 spokes (Direct)', '24 spokes (SENSE)', '24 spokes (PGD)'],\n)\n```\n\n----------------------------------------\n\nTITLE: Running PDHG Algorithm\nDESCRIPTION: Executes the PDHG algorithm for TV-minimization reconstruction using the previously defined components.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/tv_minimization_reconstruction_pdhg.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n(img_pdhg_24,) = mrpro.algorithms.optimizers.pdhg(\n    f=f,\n    g=g,\n    operator=K,\n    initial_values=(img_sense_24.data,),\n    max_iterations=257,\n    callback=callback,\n)\n```\n\n----------------------------------------\n\nTITLE: Calculating Coil Sensitivity Maps with Walsh Method\nDESCRIPTION: Creates coil sensitivity maps using the Walsh method and applies them to combine multi-coil data. This improves image quality by addressing the \"hole\" artifact that appears with simple root-sum-of-squares combination.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Calculate coil sensitivity maps\n(img_pe_pf,) = fft_op.adjoint(*cart_sampling_op.adjoint(kdata_pe_pf.data))\n\n# This algorithms is designed to calculate coil sensitivity maps for each other dimension.\ncsm_data = mrpro.algorithms.csm.walsh(img_pe_pf[0, ...], smoothing_width=5)[None, ...]\n\n# Create SensitivityOp\ncsm_op = mrpro.operators.SensitivityOp(csm_data)\n\n# Reconstruct coil-combined image\n(img_walsh_combined,) = csm_op.adjoint(*fourier_op.adjoint(kdata_pe_pf.data))\nmagnitude_walsh_combined = img_walsh_combined.abs().squeeze()\nshow_images(magnitude_pe_pf, magnitude_walsh_combined, titles=['RSS', 'Adaptive Combination'])\n```\n\n----------------------------------------\n\nTITLE: Visualizing MRI Parametric Maps using Matplotlib\nDESCRIPTION: Creates a figure with three subplots showing different MRI parametric maps: M0 magnitude (grayscale), T1 relaxation time (magma colormap), and flip angle (default colormap). Each subplot includes a colorbar and appropriate units.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfig, axes = plt.subplots(1, 3, figsize=(10, 2), squeeze=False)\n\nim = axes[0, 0].imshow(m0.abs(), cmap='gray')\naxes[0, 0].set_title('$|M_0|$')\naxes[0, 0].set_axis_off()\nfig.colorbar(im, ax=axes[0, 0])\n\nim = axes[0, 1].imshow(t1, vmin=0, vmax=2, cmap='magma')\naxes[0, 1].set_title('$T_1$ (s)')\naxes[0, 1].set_axis_off()\nfig.colorbar(im, ax=axes[0, 1])\n\nim = axes[0, 2].imshow(torch.rad2deg(flip_angle), vmin=0, vmax=8)\naxes[0, 2].set_title('Flip angle (Â°)')\naxes[0, 2].set_axis_off()\nfig.colorbar(im, ax=axes[0, 2])\n\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Simple Reconstruction Using MRpro in Python\nDESCRIPTION: This snippet demonstrates how to read MR data and trajectory from an ISMRMRD file, and perform a simple reconstruction using MRpro's DirectReconstruction algorithm.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Read the trajectory from the ISMRMRD file\ntrajectory = mrpro.data.traj_calculators.KTrajectoryIsmrmrd()\n# Load in the Data from the ISMRMRD file\nkdata = mrpro.data.KData.from_file(data_file.name, trajectory)\n# Perform the reconstruction\nreconstruction = mrpro.algorithms.reconstruction.DirectReconstruction(kdata)\nimg = reconstruction(kdata)\n```\n\n----------------------------------------\n\nTITLE: Estimating Coil Sensitivity Maps\nDESCRIPTION: Calculates coil-wise images and estimates coil sensitivity maps using the Walsh method to create the sensitivity operator.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimg_coilwise = mrpro.data.IData.from_tensor_and_kheader(*fourier_operator.H(*dcf_operator(kdata.data)), kdata.header)\ncsm_data = mrpro.data.CsmData.from_idata_walsh(img_coilwise)\ncsm_operator = csm_data.as_operator()\n```\n\n----------------------------------------\n\nTITLE: Setting Up Composite MRI Forward Operator with Wavelet Transform\nDESCRIPTION: Creates the forward operator Ã by combining the Fourier transform, coil sensitivity maps, and adjoint wavelet transform. This operator maps from wavelet domain to k-space, enabling optimization in the wavelet domain.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfourier_operator = direct_reconstruction_24.fourier_op\n\nassert direct_reconstruction_24.csm is not None\ncsm_operator = direct_reconstruction_24.csm.as_operator()\n\n# Define the wavelet operator\nwavelet_operator = mrpro.operators.WaveletOp(\n    domain_shape=img_direct_24.data.shape[-2:], dim=(-2, -1), wavelet_name='db4', level=None\n)\n\n# Create the full acquisition operator $\\tilde{A}$ including the adjoint of the wavelet operator\nacquisition_operator = fourier_operator @ csm_operator @ wavelet_operator.H\n```\n\n----------------------------------------\n\nTITLE: Running Iterative SENSE Reconstruction\nDESCRIPTION: Applies the configured iterative SENSE reconstruction to the k-space data to produce a reconstructed image.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimg = iterative_sense_reconstruction(kdata)\n```\n\n----------------------------------------\n\nTITLE: Manual MRI Direct Reconstruction in Python\nDESCRIPTION: Performs a manual direct reconstruction of MRI data, combining Fourier transform and coil sensitivity maps.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nadjoint_operator = (fourier_operator @ csm_operator).H\nimg_manual = mrpro.data.IData.from_tensor_and_kheader(*adjoint_operator(kdata.data), kdata.header)\n```\n\n----------------------------------------\n\nTITLE: Displaying MRI Reconstruction Comparisons in Python\nDESCRIPTION: Shows the results of fully sampled, unregularized undersampled, and regularized undersampled MRI reconstructions side by side for visual comparison.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nshow_images(\n    img_iterative_sense.rss()[0, 0],\n    img_us_iterative_sense.rss()[0, 0],\n    img_us_regularized_iterative_sense.rss()[0, 0],\n    titles=['Fully sampled', 'Iterative SENSE R=20', 'Regularized Iterative SENSE R=20'],\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing PDHG Problem Components\nDESCRIPTION: Sets up the functional components and operators needed for the PDHG algorithm implementation.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/tv_minimization_reconstruction_pdhg.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nregularization_lambda = 0.2\nf_1 = 0.5 * mrpro.operators.functionals.L2NormSquared(target=kdata_24spokes.data, divide_by_n=True)\nf_2 = regularization_lambda * mrpro.operators.functionals.L1NormViewAsReal(divide_by_n=True)\nf = mrpro.operators.ProximableFunctionalSeparableSum(f_1, f_2)\n\nnabla = mrpro.operators.FiniteDifferenceOp(dim=(-2, -1), mode='forward')\nK = mrpro.operators.LinearOperatorMatrix(((acquisition_operator,), (nabla,)))\n\ng = mrpro.operators.functionals.ZeroFunctional()\n```\n\n----------------------------------------\n\nTITLE: Reconstruction with Pre-Calculated Coil Sensitivity Maps\nDESCRIPTION: Performs MRI image reconstruction using pre-calculated coil sensitivity maps from calibration data instead of auto-calibration.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndirect_recon_us_csm = mrpro.algorithms.reconstruction.DirectReconstruction(kdata_us, csm=direct_recon_calib_lines.csm)\nidat_us_csm = direct_recon_us_csm(kdata_us)\nshow_images(idat_us.rss().squeeze(), idat_us_csm.rss().squeeze(), titles=['Autocalibration', 'Calibration Lines'])\n```\n\n----------------------------------------\n\nTITLE: Direct Reconstruction Implementation\nDESCRIPTION: Performs direct (adjoint) reconstruction on both 24 and 402 spokes datasets for comparison purposes.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/tv_minimization_reconstruction_pdhg.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndirect_reconstruction_402 = mrpro.algorithms.reconstruction.DirectReconstruction(kdata_402spokes)\ndirect_reconstruction_24 = mrpro.algorithms.reconstruction.DirectReconstruction(kdata_24spokes)\nimg_direct_402 = direct_reconstruction_402(kdata_402spokes)\nimg_direct_24 = direct_reconstruction_24(kdata_24spokes)\n```\n\n----------------------------------------\n\nTITLE: Defining Cost Function Components for L1-Regularized Reconstruction\nDESCRIPTION: Sets up the data fidelity term (L2 norm) and regularization term (L1 norm) for the optimization problem. The L1 norm promotes sparsity in the wavelet domain, controlled by the regularization parameter.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Regularization parameter for the $\\ell_1$-norm\nregularization_parameter = 1e-5\n\n# Set up the problem by using the previously described identification\nl2 = 0.5 * mrpro.operators.functionals.L2NormSquared(target=kdata_24spokes.data, divide_by_n=False)\nl1 = mrpro.operators.functionals.L1NormViewAsReal(divide_by_n=False)\n\nf = l2 @ acquisition_operator\ng = regularization_parameter * l1\n```\n\n----------------------------------------\n\nTITLE: Setting Up Fourier Operator for MRI Acquisition Model\nDESCRIPTION: Creates a Fourier operator from the trajectory and header information to model the MRI acquisition process.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfourier_operator = mrpro.operators.FourierOp(\n    traj=kdata.traj,\n    recon_matrix=kdata.header.recon_matrix,\n    encoding_matrix=kdata.header.encoding_matrix,\n)\n```\n\n----------------------------------------\n\nTITLE: Running FISTA Optimization with Wavelet Regularization\nDESCRIPTION: Executes the FISTA algorithm with L1-wavelet regularization on the undersampled data. The implementation calculates the operator norm to determine an appropriate stepsize, initializes with wavelet coefficients from the SENSE reconstruction, and runs for 48 iterations.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# compute the stepsize based on the operator norm of the acquisition operator and run FISTA\nimport torch\n\n# initialize FISTA with adjoint solution\ninitial_values = wavelet_operator(img_direct_24.data)\n\nop_norm = acquisition_operator.operator_norm(\n    initial_value=torch.randn_like(initial_values[0]), dim=(-2, -1), max_iterations=36\n).item()\n\n# define step size with a security factor to ensure to\n# have stepsize $t \\in (0, L(f))$, where $L(f)=1/\\|\\tilde{A}\\|_2^2)$ is\n# the Lipschitz constant of the functional $f$\nstepsize = 0.9 * (1 / op_norm**2)\n\n(img_wave_pgd_24,) = mrpro.algorithms.optimizers.pgd(\n    f=f,\n    g=g,\n    initial_value=initial_values,\n    stepsize=stepsize,\n    max_iterations=48,\n    backtrack_factor=1.0,\n    callback=callback,\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Linear Operator for MRI Reconstruction in Python\nDESCRIPTION: Defines the linear self-adjoint operator for regularized MRI reconstruction, combining acquisition model and regularization term.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\noperator = (\n    acquisition_operator.H @ dcf_operator @ acquisition_operator + mrpro.operators.IdentityOp() * regularization_weight\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Fourier Operator for MRI Reconstruction in Python\nDESCRIPTION: Creates a Fourier operator for MRI reconstruction, combining it with density compensation.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfourier_operator = dcf_operator @ mrpro.operators.FourierOp.from_kdata(kdata)\nadjoint_operator = fourier_operator.H\n```\n\n----------------------------------------\n\nTITLE: Setting up Acquisition Operator\nDESCRIPTION: Defines the acquisition operator A by combining Fourier and sensitivity operators for the reconstruction process.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/tv_minimization_reconstruction_pdhg.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfourier_operator = mrpro.operators.FourierOp.from_kdata(kdata_24spokes)\n\nassert direct_reconstruction_24.csm is not None\ncsm_operator = direct_reconstruction_24.csm.as_operator()\n\nacquisition_operator = fourier_operator @ csm_operator\n```\n\n----------------------------------------\n\nTITLE: Basic Fourier Transform Reconstruction with Partial Fourier and Phase Encoding\nDESCRIPTION: Demonstrates applying the adjoint Fourier operator to k-space data with partial Fourier and phase encoding, then calculating magnitude images through root-sum-of-squares method.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n(img_pe_pf,) = fourier_op.adjoint(kdata_pe_pf.data)\nmagnitude_pe_pf = img_pe_pf.abs().square().sum(dim=-4).sqrt().squeeze()\nshow_images(magnitude_fully_sampled, magnitude_pe_pf, titles=['fully sampled', 'PF & PE'])\n```\n\n----------------------------------------\n\nTITLE: Setting Up MRI Reconstruction Operators in Python\nDESCRIPTION: Defines the density compensation, Fourier transform, and coil sensitivity operators for MRI reconstruction using mrpro library.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndcf_operator = mrpro.data.DcfData.from_traj_voronoi(kdata_undersampled.traj).as_operator()\nfourier_operator = mrpro.operators.FourierOp.from_kdata(kdata_undersampled)\ncsm_operator = csm.as_operator()\nacquisition_operator = fourier_operator @ csm_operator\n```\n\n----------------------------------------\n\nTITLE: Visualizing T1 Mapping Results with Error Analysis\nDESCRIPTION: Calculates the relative error between the fitted model and the actual data, and visualizes the final M0 and T1 maps along with the error map. Background is masked based on M0 threshold.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nerror = model(m0, t1)[0] - idata_multi_ti.data\nrelative_absolute_error = error.abs().sum(dim=0) / (idata_multi_ti.data.abs().sum(dim=0) + 1e-9)\n\nmask = torch.isnan(t1) | (m0 < 500)\nm0[mask] = 0\nt1[mask] = 0\nrelative_absolute_error[mask] = 0\n\nfig, axes = plt.subplots(1, 3, figsize=(10, 2), squeeze=False)\nim = axes[0, 0].imshow(m0[0, 0])\naxes[0, 0].set_title('$M_0$')\naxes[0, 0].set_axis_off()\nfig.colorbar(im, ax=axes[0, 0], label='a.u.')\n\nim = axes[0, 1].imshow(t1[0, 0], vmin=0, vmax=2.5, cmap='magma')\naxes[0, 1].set_title('$T_1$')\naxes[0, 1].set_axis_off()\nfig.colorbar(im, ax=axes[0, 1], label='s')\n\nim = axes[0, 2].imshow(relative_absolute_error[0, 0], vmin=0, vmax=0.1)\naxes[0, 2].set_title('Relative error')\naxes[0, 2].set_axis_off()\nfig.colorbar(im, ax=axes[0, 2])\n\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Solving Linear System with Conjugate Gradient\nDESCRIPTION: Applies the conjugate gradient algorithm to solve the linear system and reconstruct the MRI image with early stopping after 4 iterations.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n(img_manual,) = mrpro.algorithms.optimizers.cg(\n    operator, right_hand_side, initial_value=right_hand_side, max_iterations=4, tolerance=0.0\n)\n```\n\n----------------------------------------\n\nTITLE: Loading and Processing MRI Calibration Data\nDESCRIPTION: Demonstrates loading calibration lines from k-space data using a custom acquisition filter criterion. These lines are used to create a low-resolution image for coil sensitivity map calculation.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nkdata_calib_lines = mrpro.data.KData.from_file(\n    data_folder / 'cart_t1_msense_integrated.mrd',\n    mrpro.data.traj_calculators.KTrajectoryCartesian(),\n    acquisition_filter_criterion=mrpro.data.acq_filters.is_coil_calibration_acquisition,\n)\n\ndirect_recon_calib_lines = mrpro.algorithms.reconstruction.DirectReconstruction(kdata_calib_lines)\nidat_calib_lines = direct_recon_calib_lines(kdata_calib_lines)\n```\n\n----------------------------------------\n\nTITLE: Reconstructing Undersampled MRI Image with Regularization in Python\nDESCRIPTION: Performs regularized iterative SENSE reconstruction on undersampled data using the fully sampled image as regularization.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nregularized_iterative_sense_reconstruction = mrpro.algorithms.reconstruction.RegularizedIterativeSENSEReconstruction(\n    kdata_undersampled,\n    csm=csm,\n    n_iterations=6,\n    regularization_data=img_iterative_sense.data,\n    regularization_weight=1.0,\n)\nimg_us_regularized_iterative_sense = regularized_iterative_sense_reconstruction(kdata_undersampled)\n```\n\n----------------------------------------\n\nTITLE: Mapping Wavelet Solution to Image Domain for MRI Reconstruction\nDESCRIPTION: Maps the solution from wavelet domain back to image domain using the Hermitian adjoint of the wavelet operator. This operation is essential for visualizing the final reconstructed image after wavelet-based regularization.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# map the solution back to image domain\n(img_pgd_24,) = wavelet_operator.H(img_wave_pgd_24)\n```\n\n----------------------------------------\n\nTITLE: Estimating Quantitative Parameters with MRpro in Python\nDESCRIPTION: This code snippet shows how to estimate quantitative parameter maps using MRpro by defining a signal model, creating a functional to be minimized, and using the ADAM optimizer.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/README.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Define signal model\nmodel = MagnitudeOp() @ InversionRecovery(ti=idata_multi_ti.header.ti)\n# Define loss function and combine with signal model\nmse = MSE(idata_multi_ti.data.abs())\nfunctional = mse @ model\n[...]\n# Run optimization\nparams_result = adam(functional, [m0_start, t1_start], n_iterations=n_iterations, learning_rate=learning_rate)\n```\n\n----------------------------------------\n\nTITLE: Reconstructing Average MRI Image from Radial Lines\nDESCRIPTION: Reads the raw k-space data, performs direct reconstruction to create an average image from all radial lines, and visualizes the result.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Read raw data and trajectory\nkdata = mrpro.data.KData.from_file(data_folder / '2D_GRad_map_t1.h5', mrpro.data.traj_calculators.KTrajectoryIsmrmrd())\n\n# Perform the reconstruction\nreconstruction = mrpro.algorithms.reconstruction.DirectReconstruction(kdata)\nimg_average = reconstruction(kdata)\n\n# Visualize average image\nplt.imshow(img_average.rss()[0, 0], cmap='gray')\nplt.title('Average image')\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Composing MRI Acquisition Operator\nDESCRIPTION: Creates the complete acquisition operator by composing the Fourier operator with the coil sensitivity operator.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nacquisition_operator = fourier_operator @ csm_operator\n```\n\n----------------------------------------\n\nTITLE: Combining Model and Loss into a Functional\nDESCRIPTION: Combines the signal model and MSE loss function into a single functional that can be minimized by the optimizer. This represents the complete objective function for T1 mapping.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfunctional = mse @ model\n```\n\n----------------------------------------\n\nTITLE: Reconstructing Dynamic MRI Images\nDESCRIPTION: Performs direct reconstruction on the dynamic k-space data using the previously estimated coil sensitivity map, and normalizes the resulting images.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Perform the reconstruction\n# Here we use the same coil sensitivity map for all dynamics\nreconstruction_dynamic = mrpro.algorithms.reconstruction.DirectReconstruction(kdata_dynamic, csm=reconstruction.csm)\nimg_dynamic = reconstruction_dynamic(kdata_dynamic)\n# Get absolute value of complex image and normalize the images\nimg_rss_dynamic = img_dynamic.rss()\nimg_rss_dynamic /= img_rss_dynamic.max()\n```\n\n----------------------------------------\n\nTITLE: Finding Starting Values using Dictionary Matching\nDESCRIPTION: Creates a dictionary of T1 values and matches the signal curves to each voxel to find good starting values for the optimization. This approach is similar to MR Fingerprinting and helps avoid local minima.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Define 100 T1 values between 0.1 and 3.0 s\nt1_values = torch.linspace(0.1, 3.0, 100)\n# Create the dictionary. We set M0 to constant 1, as the scaling is handled by the dictionary matching operator.\ndictionary = mrpro.operators.DictionaryMatchOp(model, 0).append(torch.ones(1), t1_values)\n# Select the closest values in the dictionary for each voxel based on cosine similarity\nm0_start, t1_start = dictionary(idata_multi_ti.data.real)\n```\n\n----------------------------------------\n\nTITLE: Combining Components into Complete Functional for Optimization\nDESCRIPTION: Combines the loss function, signal model, and constraints into a single functional that can be minimized to find the optimal T1 parameters.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfunctional = mse_loss @ magnitude_model_op @ constraints_op\n```\n\n----------------------------------------\n\nTITLE: Running LBFGS Optimization for T1 Mapping\nDESCRIPTION: Executes the LBFGS optimizer to find the optimal parameters (M0, T1, flip angle) that minimize the difference between the model and the image data.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nresult = mrpro.algorithms.optimizers.lbfgs(functional, initial_parameters=initial_parameters)\n```\n\n----------------------------------------\n\nTITLE: Advanced reconstruction using CartesianSamplingOp and FFT\nDESCRIPTION: Applies the CartesianSamplingOp followed by the FFT operator to correctly reconstruct partial echo and partial Fourier data, then displays the result compared to fully sampled data.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n(img_pe_pf,) = fft_op.adjoint(cart_sampling_op.adjoint(kdata_pe_pf.data)[0])\nmagnitude_pe_pf = img_pe_pf.abs().square().sum(dim=-4).sqrt().squeeze()\n\nshow_images(magnitude_fully_sampled, magnitude_pe_pf, titles=['fully sampled', 'PF & PE'])\n```\n\n----------------------------------------\n\nTITLE: Optimizing T1 Parameters using ADAM\nDESCRIPTION: Performs optimization using the ADAM optimizer from PyTorch to fit the signal model to the data. The code handles GPU acceleration if available and returns the optimized M0 and T1 parameters.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Move initial values and model to GPU if available\nif torch.cuda.is_available():\n    print('Using GPU')\n    functional.cuda()\n    m0_start = m0_start.cuda()\n    t1_start = t1_start.cuda()\n\n# Hyperparameters for optimizer\nmax_iterations = 2000\nlearning_rate = 1e-1\n\n# Run optimization\nresult = mrpro.algorithms.optimizers.adam(\n    functional, [m0_start, t1_start], max_iterations=max_iterations, learning_rate=learning_rate\n)\nm0, t1 = (p.detach().cpu() for p in result)\nmodel.cpu()\n```\n\n----------------------------------------\n\nTITLE: SENSE Reconstruction Setup\nDESCRIPTION: Implements iterative SENSE reconstruction for 24 spokes data with early stopping as initial guess for TV-minimization.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/tv_minimization_reconstruction_pdhg.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsense_reconstruction = mrpro.algorithms.reconstruction.IterativeSENSEReconstruction(\n    kdata_24spokes,\n    n_iterations=8,\n    csm=direct_reconstruction_24.csm,\n    dcf=direct_reconstruction_24.dcf,\n)\nimg_sense_24 = sense_reconstruction(kdata_24spokes)\n```\n\n----------------------------------------\n\nTITLE: Low-Level MRI Reconstruction Setup in Python\nDESCRIPTION: Sets up Fourier operator and calculates density compensation factors manually for MRI reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfourier_operator = mrpro.operators.FourierOp(\n    recon_matrix=kdata.header.recon_matrix,\n    encoding_matrix=kdata.header.encoding_matrix,\n    traj=kdata.traj,\n)\n\nkykx = torch.stack((kdata.traj.ky[0, 0], kdata.traj.kx[0, 0]))\ndcf_tensor = mrpro.algorithms.dcf.dcf_2d3d_voronoi(kykx)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Linear Self-Adjoint Operator\nDESCRIPTION: Creates the self-adjoint operator that forms the left-hand side of the linear system to be solved in the iterative reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\noperator = acquisition_operator.H @ dcf_operator @ acquisition_operator\n```\n\n----------------------------------------\n\nTITLE: Loading Cartesian MRI data with MRpro\nDESCRIPTION: Loads a fully sampled Cartesian MRI acquisition from an ISMRMRD file into an MRpro KData object using a Cartesian trajectory calculator.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport mrpro\n\nkdata = mrpro.data.KData.from_file(\n    data_folder / 'cart_t1.mrd',\n    mrpro.data.traj_calculators.KTrajectoryCartesian(),\n)\n```\n\n----------------------------------------\n\nTITLE: Basic FFT reconstruction with FastFourierOp\nDESCRIPTION: Creates an FFT operator that works on the last two dimensions and applies its adjoint to transform k-space data to image space.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfft_op = mrpro.operators.FastFourierOp(dim=(-2, -1))\n(img,) = fft_op.adjoint(kdata.data)\n```\n\n----------------------------------------\n\nTITLE: Calculating Coil Sensitivity Maps for MRI in Python\nDESCRIPTION: Computes coil-wise images and calculates coil sensitivity maps using the Walsh method.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimg_coilwise = mrpro.data.IData.from_tensor_and_kheader(*adjoint_operator(kdata.data), kdata.header)\ncsm_operator = mrpro.data.CsmData.from_idata_walsh(img_coilwise).as_operator()\n```\n\n----------------------------------------\n\nTITLE: FFT reconstruction with matrix size specification\nDESCRIPTION: Creates an FFT operator with specified reconstruction and encoding matrix sizes to properly handle oversampling in the readout direction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Create FFT-operator with correct output matrix size\nfft_op = mrpro.operators.FastFourierOp(\n    dim=(-2, -1),\n    recon_matrix=kdata.header.recon_matrix,\n    encoding_matrix=kdata.header.encoding_matrix,\n)\n\n(img,) = fft_op.adjoint(kdata.data)\nprint('Shape:', img.shape)\n```\n\n----------------------------------------\n\nTITLE: Defining T1 Signal Model for MRI\nDESCRIPTION: Creates a signal model that describes the transient steady-state magnetization behavior after an inversion pulse, including a spoiler gradient delay.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmodel_op = mrpro.operators.models.TransientSteadyStateWithPreparation(\n    sampling_time, repetition_time, m0_scaling_preparation=-1, delay_after_preparation=0.02\n)\n```\n\n----------------------------------------\n\nTITLE: Calculating Right-Hand Side of Linear System\nDESCRIPTION: Computes the right-hand side of the linear system to be solved in the iterative reconstruction by applying adjoint of the weighted acquisition operator to the k-space data.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n(right_hand_side,) = (acquisition_operator.H @ dcf_operator)(kdata.data)\n```\n\n----------------------------------------\n\nTITLE: Downloading MRI Data from Zenodo in Python\nDESCRIPTION: Uses zenodo_get to download the required MRI dataset from Zenodo. The data is stored in a temporary directory for further processing.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport tempfile\nfrom pathlib import Path\n\nimport zenodo_get\n\ndataset = '14617082'\n\ntmp = tempfile.TemporaryDirectory()  # RAII, automatically cleaned up\ndata_folder = Path(tmp.name)\nzenodo_get.zenodo_get([dataset, '-r', 5, '-o', data_folder])  # r: retries\n```\n\n----------------------------------------\n\nTITLE: Performing Low-Level MRI Image Reconstruction in Python\nDESCRIPTION: Executes a low-level MRI image reconstruction using manually calculated components.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n(img_tensor_coilwise,) = fourier_operator.adjoint(dcf_tensor * kdata.data)\n\ncsm_data = mrpro.algorithms.csm.walsh(img_tensor_coilwise[0], smoothing_width=5)\ncsm_operator = mrpro.operators.SensitivityOp(csm_data)\n\n(img_tensor_coilcombined,) = csm_operator.adjoint(img_tensor_coilwise)\nimg_more_manual = mrpro.data.IData.from_tensor_and_kheader(img_tensor_coilcombined, kdata.header)\n```\n\n----------------------------------------\n\nTITLE: Verifying MRI Reconstruction Results in Python\nDESCRIPTION: Compares the results of different MRI reconstruction methods to ensure they produce equivalent outputs.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ntorch.testing.assert_close(img.data, img_manual.data)\ntorch.testing.assert_close(img.data, img_more_manual.data, atol=1e-4, rtol=1e-4)\n```\n\n----------------------------------------\n\nTITLE: Visualizing k-space trajectories\nDESCRIPTION: Extracts and plots the k-space trajectories for both fully sampled and partial Fourier/partial echo acquisitions to visualize their differences.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Plot the fully sampled trajectory (in blue)\nfull_kz, full_ky, full_kx = kdata.traj.as_tensor()\nplt.plot(full_ky[0, 0].flatten(), full_kx[0, 0].flatten(), 'ob')\n\n# Plot the partial echo and partial Fourier trajectory (in red)\nfull_kz, full_ky, full_kx = kdata_pe_pf.traj.as_tensor()\nplt.plot(full_ky[0, 0].flatten(), full_kx[0, 0].flatten(), '+r')\n\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Displaying Reconstruction Results\nDESCRIPTION: Compares and displays the results from different reconstruction methods including direct, SENSE, and PDHG.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/tv_minimization_reconstruction_pdhg.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nshow_images(\n    img_direct_402.rss().squeeze(),\n    img_direct_24.rss().squeeze(),\n    img_sense_24.rss().squeeze(),\n    img_pdhg_24.abs().squeeze(),\n    titles=['402 spokes', '24 spokes (direct)', '24 spokes (SENSE)', '24 spokes (PDHG)'],\n)\n```\n\n----------------------------------------\n\nTITLE: Validating Reconstruction Results\nDESCRIPTION: Verifies that the high-level iterative SENSE reconstruction and the manual implementation produce identical results.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# If the assert statement did not raise an exception, the results are equal.\nassert torch.allclose(img.data, img_manual)\n```\n\n----------------------------------------\n\nTITLE: Visualizing MRI Reconstruction Results in Python\nDESCRIPTION: Defines a function to display multiple MRI images side by side for comparison of reconstruction methods.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport torch\n\n\ndef show_images(*images: torch.Tensor, titles: list[str] | None = None) -> None:\n    \"\"\"Plot images.\"\"\"\n    n_images = len(images)\n    _, axes = plt.subplots(1, n_images, squeeze=False, figsize=(n_images * 3, 3))\n    for i in range(n_images):\n        axes[0][i].imshow(images[i], cmap='gray')\n        axes[0][i].axis('off')\n        if titles:\n            axes[0][i].set_title(titles[i])\n    plt.show()\n```\n\n----------------------------------------\n\nTITLE: Creating Iterative SENSE Reconstruction for Comparison and Initialization\nDESCRIPTION: Performs an iterative SENSE reconstruction with early stopping (8 iterations) on the undersampled data. This serves as both a comparison and an initial guess for the FISTA algorithm to improve convergence.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsense_reconstruction = mrpro.algorithms.reconstruction.IterativeSENSEReconstruction(\n    kdata_24spokes,\n    n_iterations=8,\n    csm=direct_reconstruction_24.csm,\n    dcf=direct_reconstruction_24.dcf,\n)\nimg_sense_24 = sense_reconstruction(kdata_24spokes)\n```\n\n----------------------------------------\n\nTITLE: Loading Trajectory from ISMRMRD File\nDESCRIPTION: Loads k-space trajectory data directly from an ISMRMRD file and performs image reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/comparison_trajectory_calculators.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nkdata = mrpro.data.KData.from_file(\n    data_folder / 'radial2D_402spokes_golden_angle_with_traj.h5',\n    mrpro.data.traj_calculators.KTrajectoryIsmrmrd(),\n)\n\nreconstruction = mrpro.algorithms.reconstruction.DirectReconstruction(kdata)\nimg_using_ismrmrd_traj = reconstruction(kdata)\n```\n\n----------------------------------------\n\nTITLE: Visualization Helper Function\nDESCRIPTION: Creates a helper function to display and compare reconstruction results using matplotlib.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/tv_minimization_reconstruction_pdhg.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport torch\n\ndef show_images(*images: torch.Tensor, titles: list[str] | None = None) -> None:\n    \"\"\"Plot images.\"\"\"\n    n_images = len(images)\n    _, axes = plt.subplots(1, n_images, squeeze=False, figsize=(n_images * 3, 3))\n    for i in range(n_images):\n        axes[0][i].imshow(images[i], cmap='gray')\n        axes[0][i].axis('off')\n        if titles:\n            axes[0][i].set_title(titles[i])\n    plt.show()\n```\n\n----------------------------------------\n\nTITLE: Comparing Manual and Automated MRI Reconstructions in Python\nDESCRIPTION: Visually compares the results of manual regularized reconstruction with the automated RegularizedIterativeSENSEReconstruction method.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nshow_images(\n    img_us_regularized_iterative_sense.rss()[0, 0],\n    img_manual.abs()[0, 0, 0],\n    titles=['RegularizedIterativeSense', 'Manual'],\n)\n```\n\n----------------------------------------\n\nTITLE: Calculating Density Compensation for MRI Reconstruction in Python\nDESCRIPTION: Uses Voronoi tessellation to calculate density compensation factors for MRI reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndcf_operator = mrpro.data.DcfData.from_traj_voronoi(kdata.traj).as_operator()\n```\n\n----------------------------------------\n\nTITLE: Creating Callback Function for FISTA Progress Monitoring\nDESCRIPTION: Implements a callback function to track the objective function value and stepsize during the optimization process. The function prints these values every 8 iterations to monitor convergence.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# This is a \"callback\" function to track the value of the objective functional f(x) + g(x)\n# and stepsize update\nfrom mrpro.algorithms.optimizers.pgd import PGDStatus\n\n\ndef callback(optimizer_status: PGDStatus) -> None:\n    \"\"\"Print the value of the objective functional every 8th iteration.\"\"\"\n    iteration = optimizer_status['iteration_number']\n    solution = optimizer_status['solution']\n    if iteration % 8 == 0:\n        print(\n            f'{iteration}: {optimizer_status[\"objective\"](*solution).item()}, stepsize: {optimizer_status[\"stepsize\"]}'\n        )\n```\n\n----------------------------------------\n\nTITLE: Reconstructing Undersampled MRI Data\nDESCRIPTION: Applies direct reconstruction to undersampled k-space data and compares the result with the partial Fourier and phase-encoded reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nkdata_us = mrpro.data.KData.from_file(\n    data_folder / 'cart_t1_msense_integrated.mrd',\n    mrpro.data.traj_calculators.KTrajectoryCartesian(),\n)\ndirect_recon_us = mrpro.algorithms.reconstruction.DirectReconstruction(kdata_us)\nidat_us = direct_recon_us(kdata_us)\n\nshow_images(idat_pe_pf.rss().squeeze(), idat_us.rss().squeeze(), titles=['PE & PF', 'Undersampled'])\n```\n\n----------------------------------------\n\nTITLE: Visualizing MRI Coil Sensitivity Maps\nDESCRIPTION: Displays the magnitude of coil sensitivity maps calculated from the calibration data.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# The coil sensitivity maps\nassert direct_recon_calib_lines.csm is not None\nshow_images(\n    *direct_recon_calib_lines.csm.data[0].abs().squeeze(),\n    titles=[f'|CSM {i}|' for i in range(direct_recon_calib_lines.csm.data.size(-4))],\n)\n```\n\n----------------------------------------\n\nTITLE: Converting Parameters to Unconstrained Space\nDESCRIPTION: Transforms the initial parameters to the unconstrained space required by the optimizer using the inverse of the constraints operator.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ninitial_parameters = constraints_op.inverse(m0_start, t1_start, flip_angle_start)\n```\n\n----------------------------------------\n\nTITLE: Performing MRI Image Reconstruction in Python\nDESCRIPTION: Executes the MRI image reconstruction using the previously set up DirectReconstruction instance.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimg = reconstruction(kdata)\n```\n\n----------------------------------------\n\nTITLE: Visualizing MRI Calibration Image\nDESCRIPTION: Displays the low-resolution calibration image used for coil sensitivity calculation.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nshow_images(idat_calib_lines.rss().squeeze(), titles=['Calibration Image'])\n```\n\n----------------------------------------\n\nTITLE: Visualizing Images at Different Inversion Times\nDESCRIPTION: Displays the MRI images at different inversion times using the show_images helper function. The titles show the corresponding TI values to illustrate how the signal changes with inversion time.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Let's have a look at some of the images\nshow_images(\n    *idata_multi_ti.data[:, 0, 0].abs(),\n    titles=[f'TI = {ti:.3f}s' for ti in idata_multi_ti.header.ti],\n)\n```\n\n----------------------------------------\n\nTITLE: Converting Results Back to Constrained Space\nDESCRIPTION: Transforms the optimization results from the unconstrained space back to the original parameter space to obtain the final M0, T1, and flip angle maps.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nm0, t1, flip_angle = (p.detach().cpu().squeeze() for p in constraints_op(*result))\n```\n\n----------------------------------------\n\nTITLE: Root-sum-of-squares coil combination and image display\nDESCRIPTION: Combines multi-coil MRI data using root-sum-of-squares method and displays the resulting magnitude image.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Combine data from different coils and show magnitude image\nmagnitude_fully_sampled = img.abs().square().sum(dim=-4).sqrt().squeeze()\nshow_images(magnitude_fully_sampled)\n```\n\n----------------------------------------\n\nTITLE: Solving MRI Reconstruction Equation with Conjugate Gradient in Python\nDESCRIPTION: Uses conjugate gradient method to solve the linear system for MRI image reconstruction, with early stopping after 8 iterations.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n(img_manual,) = mrpro.algorithms.optimizers.cg(\n    operator, right_hand_side, initial_value=right_hand_side, max_iterations=8, tolerance=0.0\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a CartesianSamplingOp for handling asymmetric sampling\nDESCRIPTION: Creates a CartesianSamplingOp to properly sort asymmetrically sampled k-space data based on the trajectory and encoding matrix.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ncart_sampling_op = mrpro.operators.CartesianSamplingOp(\n    encoding_matrix=kdata_pe_pf.header.encoding_matrix, traj=kdata_pe_pf.traj\n)\n```\n\n----------------------------------------\n\nTITLE: Displaying Reconstructed MRI Images for Comparison\nDESCRIPTION: Shows the direct reconstruction, the iterative SENSE reconstruction using the high-level API, and the manual implementation side by side.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nshow_images(\n    img_direct.rss()[0, 0],\n    img.rss()[0, 0],\n    img_manual.abs()[0, 0, 0],\n    titles=['Direct', 'Iterative SENSE', 'Manual Iterative SENSE'],\n)\n```\n\n----------------------------------------\n\nTITLE: Verifying MRI Reconstruction Results in Python\nDESCRIPTION: Asserts that the manual and automated regularized MRI reconstructions produce identical results using PyTorch's testing module.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ntorch.testing.assert_close(img_us_regularized_iterative_sense.data, img_manual)\n```\n\n----------------------------------------\n\nTITLE: Using the automated FourierOp for reconstruction\nDESCRIPTION: Creates a FourierOp directly from the KData object, which automatically handles the correct sampling pattern and transformation.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfourier_op = mrpro.operators.FourierOp.from_kdata(kdata_pe_pf)\n```\n\n----------------------------------------\n\nTITLE: Creating an image display utility function\nDESCRIPTION: Defines a utility function for displaying multiple MRI images with optional titles using matplotlib.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport torch\n\n\ndef show_images(*images: torch.Tensor, titles: list[str] | None = None) -> None:\n    \"\"\"Plot images.\"\"\"\n    n_images = len(images)\n    _, axes = plt.subplots(1, n_images, squeeze=False, figsize=(n_images * 3, 3))\n    for i in range(n_images):\n        axes[0][i].imshow(images[i], cmap='gray')\n        axes[0][i].axis('off')\n        if titles:\n            axes[0][i].set_title(titles[i])\n    plt.show()\n```\n\n----------------------------------------\n\nTITLE: Installing MRPro Library in Notebook Environment\nDESCRIPTION: Checks if the mrpro library is installed and installs it with notebook dependencies if not found. This ensures all required packages are available for the reconstruction workflow.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport importlib\n\nif not importlib.util.find_spec('mrpro'):\n    %pip install mrpro[notebooks]\n```\n\n----------------------------------------\n\nTITLE: Plotting Multiple MRI Images for Comparison in PyTorch\nDESCRIPTION: A utility function that creates a figure with multiple MRI images for comparison. It takes an arbitrary number of PyTorch tensors representing images, displays them with a grayscale colormap, and optionally adds titles to each subplot.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport torch\n\n\ndef show_images(*images: torch.Tensor, titles: list[str] | None = None) -> None:\n    \"\"\"Plot images.\"\"\"\n    n_images = len(images)\n    _, axes = plt.subplots(1, n_images, squeeze=False, figsize=(n_images * 3, 3))\n    for i in range(n_images):\n        axes[0][i].imshow(images[i], cmap='gray', clim=[0, 3e-4])\n        axes[0][i].axis('off')\n        if titles:\n            axes[0][i].set_title(titles[i])\n    plt.show()\n```\n\n----------------------------------------\n\nTITLE: Creating Image Display Function\nDESCRIPTION: Defines a utility function to display and compare multiple reconstructed MRI images side by side.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport torch\n\n\ndef show_images(*images: torch.Tensor, titles: list[str] | None = None) -> None:\n    \"\"\"Plot images.\"\"\"\n    n_images = len(images)\n    _, axes = plt.subplots(1, n_images, squeeze=False, figsize=(n_images * 3, 3))\n    for i in range(n_images):\n        axes[0][i].imshow(images[i], cmap='gray')\n        axes[0][i].axis('off')\n        if titles:\n            axes[0][i].set_title(titles[i])\n    plt.show()\n```\n\n----------------------------------------\n\nTITLE: Creating IData Object from DICOM Files with Inversion Times\nDESCRIPTION: Reads DICOM files and combines them into an mrpro IData object. The inversion times are extracted from the DICOM headers and stored in the IData header for T1 mapping.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport mrpro\n\nti_dicom_files = data_folder.glob('**/*.dcm')\nidata_multi_ti = mrpro.data.IData.from_dicom_files(ti_dicom_files)\n\nif idata_multi_ti.header.ti is None:\n    raise ValueError('Inversion times need to be defined in the DICOM files.')\n```\n\n----------------------------------------\n\nTITLE: Calculating Radial 2D Trajectory\nDESCRIPTION: Calculates k-space trajectory using the radial 2D trajectory calculator with golden angle spacing.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/comparison_trajectory_calculators.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ngolden_angle = torch.pi * 0.618034\nkdata = mrpro.data.KData.from_file(\n    data_folder / 'radial2D_402spokes_golden_angle_with_traj.h5',\n    mrpro.data.traj_calculators.KTrajectoryRadial2D(golden_angle),\n)\n\nreconstruction = mrpro.algorithms.reconstruction.DirectReconstruction(kdata)\nimg_using_rad2d_traj = reconstruction(kdata)\n```\n\n----------------------------------------\n\nTITLE: Image Display Utility Function\nDESCRIPTION: Defines a helper function to display multiple images side by side using matplotlib.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/comparison_trajectory_calculators.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport torch\n\n\ndef show_images(*images: torch.Tensor, titles: list[str] | None = None) -> None:\n    \"\"\"Plot images.\"\"\"\n    n_images = len(images)\n    _, axes = plt.subplots(1, n_images, squeeze=False, figsize=(n_images * 3, 3))\n    for i in range(n_images):\n        axes[0][i].imshow(images[i], cmap='gray')\n        axes[0][i].axis('off')\n        if titles:\n            axes[0][i].set_title(titles[i])\n    plt.show()\n```\n\n----------------------------------------\n\nTITLE: Calculating Sampling Time for T1 Model\nDESCRIPTION: Calculates the time since the inversion pulse for each dynamic image by averaging the acquisition timestamps for each frame.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Calculate the time since the inversion pulse, taking the average over all radial lines in each dynamic.\nsampling_time = kdata_dynamic.header.acq_info.acquisition_time_stamp.squeeze()\nsampling_time = (sampling_time - sampling_time[0, 0]).mean(-1)\n```\n\n----------------------------------------\n\nTITLE: Calculating Trajectory from Pulseq File\nDESCRIPTION: Generates k-space trajectory from a Pulseq sequence file using the PyPulseq trajectory calculator.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/comparison_trajectory_calculators.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nseq_path = data_folder / 'radial2D_402spokes_golden_angle.seq'\nkdata = mrpro.data.KData.from_file(\n    data_folder / 'radial2D_402spokes_golden_angle_with_traj.h5',\n    mrpro.data.traj_calculators.KTrajectoryPulseq(seq_path),\n)\n\nreconstruction = mrpro.algorithms.reconstruction.DirectReconstruction(kdata)\nimg_using_pulseq_traj = reconstruction(kdata)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Starting Values for M0 and T1\nDESCRIPTION: Displays the starting values for M0 and T1 parameters that were obtained from dictionary matching. This visualization helps assess the quality of the initial parameter estimates before optimization.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfig, axes = plt.subplots(1, 2, figsize=(6, 2), squeeze=False)\n\nim = axes[0, 0].imshow(m0_start[0, 0])\naxes[0, 0].set_title('$M_0$ start values')\naxes[0, 0].set_axis_off()\nfig.colorbar(im, ax=axes[0, 0], label='a.u.')\n\nim = axes[0, 1].imshow(t1_start[0, 0], vmin=0, vmax=2.5, cmap='magma')\naxes[0, 1].set_title('$T_1$ start values')\naxes[0, 1].set_axis_off()\nfig.colorbar(im, ax=axes[0, 1], label='s')\n\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Calculating Right-Hand Side of MRI Reconstruction Equation in Python\nDESCRIPTION: Computes the right-hand side of the linear system for regularized MRI reconstruction, combining acquired data and regularization term.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nregularization_weight = 1.0\nregularization_image = img_iterative_sense.data\n\n(right_hand_side,) = (acquisition_operator.H @ dcf_operator)(kdata_undersampled.data)\nright_hand_side = right_hand_side + regularization_weight * regularization_image\n```\n\n----------------------------------------\n\nTITLE: Splitting k-space Data into Dynamic Time Frames\nDESCRIPTION: Divides the k-space data into multiple dynamic frames with 30 radial lines each, based on acquisition timestamps.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nidx_dynamic = mrpro.utils.split_idx(kdata.header.acq_info.acquisition_time_stamp.squeeze().argsort(), 30, 0)\nkdata_dynamic = kdata.split_k1_into_other(idx_dynamic, other_label='repetition')\n```\n\n----------------------------------------\n\nTITLE: Setting Parameter Constraints for T1 Fitting\nDESCRIPTION: Defines constraints for the model parameters: T1 is constrained between 50ms and 3s, and the flip angle is constrained to vary only by 50% from the nominal value.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nif kdata_dynamic.header.fa is None:\n    raise ValueError('Nominal flip angle needs to be defined.')\n\nnominal_flip_angle = float(kdata_dynamic.header.fa[0])\n\nconstraints_op = mrpro.operators.ConstraintsOp(\n    bounds=(\n        (None, None),  # M0 is not constrained\n        (0.05, 3.0),  # T1 is constrained between 50 ms and 3 s\n        (nominal_flip_angle * 0.5, nominal_flip_angle * 1.5),  # alpha is constrained\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing PDHG Callback\nDESCRIPTION: Creates a callback function to monitor PDHG algorithm progress and print objective values.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/tv_minimization_reconstruction_pdhg.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom mrpro.algorithms.optimizers.pdhg import PDHGStatus\n\ndef callback(optimizer_status: PDHGStatus) -> None:\n    \"\"\"Print the value of the objective functional every 16th iteration.\"\"\"\n    iteration = optimizer_status['iteration_number']\n    solution = optimizer_status['solution']\n    if iteration % 16 == 0:\n        print(f'Iteration {iteration: >3}: Objective = {optimizer_status[\"objective\"](*solution).item():.3e}')\n```\n\n----------------------------------------\n\nTITLE: Setting Up DirectReconstruction for MRI in Python\nDESCRIPTION: Creates a DirectReconstruction instance using the loaded k-space data for MRI image reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nreconstruction = mrpro.algorithms.reconstruction.DirectReconstruction(kdata)\n```\n\n----------------------------------------\n\nTITLE: Loading MRI K-Space Data with Trajectory\nDESCRIPTION: Loads k-space data and trajectory information from an ISMRMRD file using mrpro's KData class.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport mrpro\n\ntrajectory_calculator = mrpro.data.traj_calculators.KTrajectoryIsmrmrd()\nkdata = mrpro.data.KData.from_file(data_folder / 'radial2D_402spokes_golden_angle_with_traj.h5', trajectory_calculator)\n```\n\n----------------------------------------\n\nTITLE: Creating Image Visualization Helper Function\nDESCRIPTION: Defines a helper function to visualize MRI images with matplotlib. The function allows displaying multiple images side by side with optional titles for comparing images at different inversion times.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport torch\n\n\ndef show_images(*images: torch.Tensor, titles: list[str] | None = None) -> None:\n    \"\"\"Plot images.\"\"\"\n    n_images = len(images)\n    _, axes = plt.subplots(1, n_images, squeeze=False, figsize=(n_images * 3, 3))\n    for i in range(n_images):\n        axes[0][i].imshow(images[i], cmap='gray')\n        axes[0][i].axis('off')\n        if titles:\n            axes[0][i].set_title(titles[i])\n    plt.show()\n```\n\n----------------------------------------\n\nTITLE: Displaying Reconstructed MRI Image in Python\nDESCRIPTION: Uses matplotlib to display the first slice of the reconstructed MRI image.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n\n# If there are multiple slices, ..., only the first one is selected\nfirst_img = img.rss()[0, 0]  #  images, z, y, x\nplt.imshow(first_img, cmap='gray')\nplt.axis('off')\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Direct MRI Reconstruction for Comparison\nDESCRIPTION: Performs a direct MRI reconstruction using mrpro's DirectReconstruction class to create a reference image.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndirect_reconstruction = mrpro.algorithms.reconstruction.DirectReconstruction(kdata)\nimg_direct = direct_reconstruction(kdata)\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Values for T1 Parameter Optimization\nDESCRIPTION: Initializes the starting values for the optimization: M0 from the first dynamic image, T1 at 1 second, and flip angle at the nominal value.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nm0_start = img_rss_dynamic[0]\nt1_start = torch.ones_like(m0_start)\nflip_angle_start = torch.ones_like(m0_start) * torch.as_tensor(kdata_dynamic.header.fa)\n```\n\n----------------------------------------\n\nTITLE: Loading and reconstructing partial echo and partial Fourier data\nDESCRIPTION: Loads and reconstructs a Cartesian MRI acquisition with partial echo and partial Fourier acceleration using the same approach as for fully sampled data.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Read in the data\nkdata_pe_pf = mrpro.data.KData.from_file(\n    data_folder / 'cart_t1_partial_echo_partial_fourier.mrd',\n    mrpro.data.traj_calculators.KTrajectoryCartesian(),\n)\n\n# Create FFT-operator with correct output matrix size\nfft_op = mrpro.operators.FastFourierOp(\n    dim=(-2, -1),\n    recon_matrix=kdata.header.recon_matrix,\n    encoding_matrix=kdata.header.encoding_matrix,\n)\n\n# Reconstruct coil resolved image(s)\n(img_pe_pf,) = fft_op.adjoint(kdata_pe_pf.data)\n\n# Combine data from different coils using root-sum-of-squares\nmagnitude_pe_pf = img_pe_pf.abs().square().sum(dim=-4).sqrt().squeeze()\n\n# Plot both images\nshow_images(magnitude_fully_sampled, magnitude_pe_pf, titles=['fully sampled', 'PF & PE'])\n```\n\n----------------------------------------\n\nTITLE: Using Pulseq Support in MRpro with Python\nDESCRIPTION: This example demonstrates how to use MRpro's Pulseq support to calculate the trajectory directly from a provided pulseq-file when reading raw data.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/README.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Read raw data and calculate trajectory using KTrajectoryPulseq\nkdata = KData.from_file(data_file.name, KTrajectoryPulseq(seq_path=seq_file.name))\n```\n\n----------------------------------------\n\nTITLE: Installing MRPro Package\nDESCRIPTION: Checks if mrpro package is installed and installs it with notebook dependencies if not present.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/tv_minimization_reconstruction_pdhg.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport importlib\n\nif not importlib.util.find_spec('mrpro'):\n    %pip install mrpro[notebooks]\n```\n\n----------------------------------------\n\nTITLE: Displaying Reconstructed Images\nDESCRIPTION: Displays the reconstructed images from all three trajectory calculation methods side by side for comparison.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/comparison_trajectory_calculators.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nshow_images(\n    img_using_ismrmrd_traj.rss()[0, 0],\n    img_using_rad2d_traj.rss()[0, 0],\n    img_using_pulseq_traj.rss()[0, 0],\n    titles=['KTrajectoryIsmrmrd', 'KTrajectoryRadial2D', 'KTrajectoryPulseq'],\n)\n```\n\n----------------------------------------\n\nTITLE: Determining Repetition Time for T1 Model\nDESCRIPTION: Extracts the repetition time between two RF pulses from the header's echo spacing parameter, which is required for the signal model.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nif kdata_dynamic.header.echo_spacing is None:\n    raise ValueError('Echo spacing needs to be defined.')\nelse:\n    repetition_time = kdata_dynamic.header.echo_spacing[0]\n```\n\n----------------------------------------\n\nTITLE: Installing mrpro Package for T1 Mapping\nDESCRIPTION: Checks if the mrpro package is installed and installs it with notebook support if needed.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport importlib\n\nif not importlib.util.find_spec('mrpro'):\n    %pip install mrpro[notebooks]\n```\n\n----------------------------------------\n\nTITLE: Visualizing Dynamic MRI Images\nDESCRIPTION: Creates a 2x3 grid to visualize the first six dynamic images from the time series after inversion.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Visualize the first six dynamic images\nfig, ax = plt.subplots(2, 3, squeeze=False)\nfor idx, cax in enumerate(ax.flatten()):\n    cax.imshow(img_rss_dynamic[idx, 0, :, :], cmap='gray', vmin=0, vmax=0.8)\n    cax.set_title(f'Dynamic {idx}')\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Correcting MRD File Headers using Python and ISMRMRD\nDESCRIPTION: Script to fix incorrect header information in MRD (Magnetic Resonance Data) files by reading the original file, modifying header parameters, and creating a new corrected file. This can be used to adjust matrix sizes, add trajectory information, or select data subsets.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/docs/source/faq.rst#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport ismrmrd\n\n# Get info and acquisitions from original data\nwith ismrmrd.File(fname_wrong_header, 'r') as file:\n    ds = file[list(file.keys())[0]]\n    mrd_header = ds.header\n    acquisitions = ds.acquisitions[:]\n\n# Correct wrong entries in header\nmrd_header.encoding[0].reconSpace.matrixSize.y = 192\nmrd_header.encoding[0].reconSpace.matrixSize.z = 192\n\n# Create new file and add header and data\nds = ismrmrd.Dataset(fname_correct_header)\nds.write_xml_header(mrd_header.toXML())\n\nfor acq in acquisitions:\n    ds.append_acquisition(acq)\nds.close()\n```\n\n----------------------------------------\n\nTITLE: Downloading QMRI Challenge Data from Zenodo\nDESCRIPTION: Downloads the T1 inversion recovery data from Zenodo repository and extracts it to a temporary directory. The dataset contains DICOM files at different inversion times for T1 mapping.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport tempfile\nimport zipfile\nfrom pathlib import Path\n\nimport zenodo_get\n\ndataset = '10868350'\n\ntmp = tempfile.TemporaryDirectory()  # RAII, automatically cleaned up\ndata_folder = Path(tmp.name)\nzenodo_get.zenodo_get([dataset, '-r', 5, '-o', data_folder])  # r: retries\nwith zipfile.ZipFile(data_folder / Path('T1 IR.zip'), 'r') as zip_ref:\n    zip_ref.extractall(data_folder)\n```\n\n----------------------------------------\n\nTITLE: Examining trajectory information\nDESCRIPTION: Prints trajectory information to understand the k-space coverage of the fully sampled acquisition.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nprint(kdata.traj)\n```\n\n----------------------------------------\n\nTITLE: Checking output tensor shape\nDESCRIPTION: Prints the shape of the reconstructed image tensor to understand its dimensions.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint('Shape:', img.shape)\n```\n\n----------------------------------------\n\nTITLE: Installing mrpro Library for MRI Processing in Python\nDESCRIPTION: Checks if the mrpro package is installed and installs it with notebook dependencies if needed. This ensures all required dependencies are available for MRI data processing.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport importlib\n\nif not importlib.util.find_spec('mrpro'):\n    %pip install mrpro[notebooks]\n```\n\n----------------------------------------\n\nTITLE: Loading ISMRMRD Data with Embedded Trajectory Information\nDESCRIPTION: Loads MRI k-space data from ISMRMRD files containing both fully sampled (402 spokes) and undersampled (24 spokes) acquisitions. Uses the KTrajectoryIsmrmrd calculator to extract trajectory information from the files.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Load in the data from the ISMRMRD file\nimport mrpro\n\n# We have embedded the trajectory information in the ISMRMRD files.\nkdata_402spokes = mrpro.data.KData.from_file(\n    data_folder / 'radial2D_402spokes_golden_angle_with_traj.h5', mrpro.data.traj_calculators.KTrajectoryIsmrmrd()\n)\nkdata_24spokes = mrpro.data.KData.from_file(\n    data_folder / 'radial2D_24spokes_golden_angle_with_traj.h5', mrpro.data.traj_calculators.KTrajectoryIsmrmrd()\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing specific header information\nDESCRIPTION: Retrieves and prints specific header information from the KData object, such as the proton Lamor frequency.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint('Lamor Frequency:', kdata.header.lamor_frequency_proton)\n```\n\n----------------------------------------\n\nTITLE: Downloading MRI Test Data from Zenodo\nDESCRIPTION: Downloads a dataset containing radial MRI acquisitions with different undersampling factors from Zenodo. The dataset includes scans with 402, 96, and 24 spokes using a golden angle radial trajectory.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# ### Download raw data from Zenodo\nimport tempfile\nfrom pathlib import Path\n\nimport zenodo_get\n\ndataset = '14617082'\n\ntmp = tempfile.TemporaryDirectory()  # RAII, automatically cleaned up\ndata_folder = Path(tmp.name)\nzenodo_get.zenodo_get([dataset, '-r', 5, '-o', data_folder])  # r: retries\n```\n\n----------------------------------------\n\nTITLE: Defining Loss Function for T1 Parameter Fitting\nDESCRIPTION: Creates a mean squared error loss function to measure the difference between the model predictions and the actual image data.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nmse_loss = mrpro.operators.functionals.MSE(img_rss_dynamic)\n```\n\n----------------------------------------\n\nTITLE: Exploring KData object information\nDESCRIPTION: Prints basic information about the loaded KData object to see its structure and properties.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(kdata)\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Class Documentation Template in RST\nDESCRIPTION: Template directives for generating comprehensive class documentation in Sphinx, including special methods and inheritance settings. Configures the display of members, special methods, inherited members and inheritance relationships.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/docs/source/_templates/class_template.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n{{ fullname | escape | underline}}\n\n.. currentmodule:: {{ module }}\n\n.. autoclass:: {{ objname }}\n   :members:\n   :special-members: '__init__, __call__, __matmul__, __add__, __mul__, __or__, __and__, __radd__, __rmul__, __rmatmul__, __ror__, __rand__, __truediv__, __eq__, __pow__'\n   :inherited-members: Module\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Creating Mean Squared Error Loss Function\nDESCRIPTION: Defines the mean squared error (MSE) loss function to measure the difference between the model predictions and the actual image data. This loss function will be minimized during optimization.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_sg_challenge_2024_t1.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nmse = mrpro.operators.functionals.MSE(idata_multi_ti.data.abs())\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for T1 Mapping\nDESCRIPTION: Imports necessary Python libraries including matplotlib for visualization, mrpro for MRI processing, and torch for tensor operations.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport mrpro\nimport torch\n```\n\n----------------------------------------\n\nTITLE: Loading MRI K-Space Data with Trajectory in Python\nDESCRIPTION: Loads MRI k-space data from an ISMRMRD file, including the stored trajectory information.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport mrpro\nimport torch\n\ntrajectory_calculator = mrpro.data.traj_calculators.KTrajectoryIsmrmrd()\nkdata = mrpro.data.KData.from_file(data_folder / 'radial2D_402spokes_golden_angle_with_traj.h5', trajectory_calculator)\n```\n\n----------------------------------------\n\nTITLE: Downloading MRI dataset from Zenodo\nDESCRIPTION: Creates a temporary directory and downloads a dataset from Zenodo containing Cartesian MRI scans for reconstruction examples.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Get the raw data from zenodo\nimport tempfile\nfrom pathlib import Path\n\nimport zenodo_get\n\ndataset = '14173489'\n\ntmp = tempfile.TemporaryDirectory()  # RAII, automatically cleaned up\ndata_folder = Path(tmp.name)\nzenodo_get.zenodo_get([dataset, '-r', 5, '-o', data_folder])  # r: retries\n```\n\n----------------------------------------\n\nTITLE: Creating Magnitude Model for T1 Fitting\nDESCRIPTION: Combines the signal model with a magnitude operator to fit the magnitude of the model to the magnitude of the image data for more robust fitting.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nmagnitude_model_op = mrpro.operators.MagnitudeOp() @ model_op\n```\n\n----------------------------------------\n\nTITLE: Downloading MRI Data from Zenodo in Python\nDESCRIPTION: Downloads raw MRI data from Zenodo using zenodo_get library and stores it in a temporary directory.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport tempfile\nfrom pathlib import Path\n\nimport zenodo_get\n\ndataset = '14617082'\n\ntmp = tempfile.TemporaryDirectory()  # RAII, automatically cleaned up\ndata_folder = Path(tmp.name)\nzenodo_get.zenodo_get([dataset, '-r', 5, '-o', data_folder])  # r: retries\n```\n\n----------------------------------------\n\nTITLE: Loading MRI K-Space Data\nDESCRIPTION: Loads k-space data from ISMRMRD files for both 402 and 24 spokes datasets using the MRPro library.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/tv_minimization_reconstruction_pdhg.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport mrpro\n\nkdata_402spokes = mrpro.data.KData.from_file(\n    data_folder / 'radial2D_402spokes_golden_angle_with_traj.h5', mrpro.data.traj_calculators.KTrajectoryIsmrmrd()\n)\nkdata_24spokes = mrpro.data.KData.from_file(\n    data_folder / 'radial2D_24spokes_golden_angle_with_traj.h5', mrpro.data.traj_calculators.KTrajectoryIsmrmrd()\n)\n```\n\n----------------------------------------\n\nTITLE: Downloading Raw MRI Data from Zenodo\nDESCRIPTION: Sets up a temporary directory and downloads the required dataset from Zenodo using zenodo_get library.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/comparison_trajectory_calculators.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport tempfile\nfrom pathlib import Path\n\nimport mrpro\nimport torch\nimport zenodo_get\n\ndataset = '14617082'\n\ntmp = tempfile.TemporaryDirectory()  # RAII, automatically cleaned up\ndata_folder = Path(tmp.name)\nzenodo_get.zenodo_get([dataset, '-r', 5, '-o', data_folder])  # r: retries\n```\n\n----------------------------------------\n\nTITLE: Downloading MRI Dataset from Zenodo\nDESCRIPTION: Downloads raw MRI data from Zenodo repository containing different numbers of radial spokes (24, 96, and 402).\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/tv_minimization_reconstruction_pdhg.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport tempfile\nfrom pathlib import Path\n\nimport zenodo_get\n\ndataset = '14617082'\n\ntmp = tempfile.TemporaryDirectory()  # RAII, automatically cleaned up\ndata_folder = Path(tmp.name)\nzenodo_get.zenodo_get([dataset, '-r', 5, '-o', data_folder])  # r: retries\n```\n\n----------------------------------------\n\nTITLE: Downloading MRI Test Data from Zenodo\nDESCRIPTION: Downloads radial MRI test datasets from Zenodo repository to a temporary directory for reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# ### Download raw data from Zenodo\nimport tempfile\nfrom pathlib import Path\n\nimport zenodo_get\n\ndataset = '14617082'\n\ntmp = tempfile.TemporaryDirectory()  # RAII, automatically cleaned up\ndata_folder = Path(tmp.name)\nzenodo_get.zenodo_get([dataset, '-r', 5, '-o', data_folder])  # r: retries\n```\n\n----------------------------------------\n\nTITLE: Reconstructing Undersampled MRI Image without Regularization in Python\nDESCRIPTION: Performs unregularized iterative SENSE reconstruction on undersampled data for comparison with regularized reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\niterative_sense_reconstruction = mrpro.algorithms.reconstruction.IterativeSENSEReconstruction(\n    kdata_undersampled, csm=csm, n_iterations=6\n)\nimg_us_iterative_sense = iterative_sense_reconstruction(kdata_undersampled)\n```\n\n----------------------------------------\n\nTITLE: Installing MRpro via pip\nDESCRIPTION: Commands for installing the MRpro package from PyPI, including options for additional notebook dependencies or installing the development version from GitHub.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/docs/source/user_guide.rst#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install mrpro\n```\n\nLANGUAGE: bash\nCODE:\n```\npip install mrpro[notebooks]\n```\n\nLANGUAGE: bash\nCODE:\n```\npip install \"git+https://github.com/PTB-MR/mrpro\"\n```\n\n----------------------------------------\n\nTITLE: Downloading MRI Dataset from Zenodo\nDESCRIPTION: Downloads the raw MRI data in ISMRMRD format from Zenodo into a temporary directory for processing.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/qmri_t1_mapping_with_grad_acq.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Download raw data in ISMRMRD format from zenodo into a temporary directory\nimport tempfile\nfrom pathlib import Path\n\nimport zenodo_get\n\ndataset = '13207352'\n\ntmp = tempfile.TemporaryDirectory()  # RAII, automatically cleaned up\ndata_folder = Path(tmp.name)\nzenodo_get.zenodo_get([dataset, '-r', 5, '-o', data_folder])  # r: retries\n```\n\n----------------------------------------\n\nTITLE: Installing MRpro with notebook dependencies if not already installed\nDESCRIPTION: Checks if the 'mrpro' package is installed and installs it with notebook dependencies if necessary.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/cartesian_reconstruction.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport importlib\n\nif not importlib.util.find_spec('mrpro'):\n    %pip install mrpro[notebooks]\n```\n\n----------------------------------------\n\nTITLE: Installing mrpro Library in Python\nDESCRIPTION: Checks if mrpro is installed and installs it with notebook dependencies if not found.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/direct_reconstruction.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport importlib\n\nif not importlib.util.find_spec('mrpro'):\n    %pip install mrpro[notebooks]\n```\n\n----------------------------------------\n\nTITLE: Installing MRPro Package\nDESCRIPTION: Checks if the mrpro package is installed and installs it with notebook dependencies if not found.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport importlib\n\nif not importlib.util.find_spec('mrpro'):\n    %pip install mrpro[notebooks]\n```\n\n----------------------------------------\n\nTITLE: Installing MRPro Package\nDESCRIPTION: Checks for and installs the MRPro package with notebook dependencies if not already present.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/comparison_trajectory_calculators.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport importlib\n\nif not importlib.util.find_spec('mrpro'):\n    %pip install mrpro[notebooks]\n```\n\n----------------------------------------\n\nTITLE: Installing mrpro Library in Python\nDESCRIPTION: Checks if mrpro is installed and installs it if not present. This ensures the required library is available for the reconstruction tasks.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_with_regularization.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport importlib\n\nif not importlib.util.find_spec('mrpro'):\n    %pip install mrpro[notebooks]\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies for PTB-MR Project\nDESCRIPTION: A comprehensive list of Python package dependencies with specific version requirements needed to run the PTB-MR/mrpro project. The dependencies include deep learning frameworks (PyTorch), scientific computing libraries (NumPy, SciPy), and specialized MRI-related packages like ISMRMRD, pypulseq, and FINUFFT implementations.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/docker/minimal-requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ntorch==2.3.1\ntorchvision==0.18.1\nnumpy==1.23\nismrmrd==1.14.1\neinops==0.7.0\npydicom==3.0.1\npypulseq==1.4.2\npytorch-finufft==0.1.0\ncufinufft==2.3.1\nscipy==1.12\nptwt==0.1.8\ntqdm==4.60.0\ntyping-extensions==4.12\n--extra-index-url https://download.pytorch.org/whl/cpu\n```\n\n----------------------------------------\n\nTITLE: Defining Module Documentation Structure with Jinja2 in Sphinx\nDESCRIPTION: This template configures how Python module documentation is structured in Sphinx. It establishes sections for module attributes, functions, classes, exceptions, and submodules, using the autosummary directive to generate summaries with links to detailed documentation. The template uses Jinja2 conditionals to only display sections that have content.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/docs/source/_templates/module_template.rst#2025-04-17_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{{ fullname | escape | underline}}\n\n.. automodule:: {{ fullname }}\n\n   {% block attributes %}\n   {% if attributes %}\n   .. rubric:: Module Attributes\n\n   .. autosummary::\n      :toctree:\n   {% for item in attributes %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block functions %}\n   {% if functions %}\n   .. rubric:: {{ _('Functions') }}\n\n   .. autosummary::\n      :toctree:\n   {% for item in functions %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block classes %}\n   {% if classes %}\n   .. rubric:: {{ _('Classes') }}\n\n   .. autosummary::\n      :toctree:\n      :template: class_template.rst\n   {% for item in classes %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block exceptions %}\n   {% if exceptions %}\n   .. rubric:: {{ _('Exceptions') }}\n\n   .. autosummary::\n      :toctree:\n   {% for item in exceptions %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n{% block modules %}\n{% if modules %}\n.. rubric:: Modules\n\n.. autosummary::\n   :toctree:\n   :template: module_template.rst\n   :recursive:\n{% for item in modules %}\n   {{ item }}\n{%- endfor %}\n{% endif %}\n{% endblock %}\n```\n\n----------------------------------------\n\nTITLE: Configuring RST Documentation Image\nDESCRIPTION: RST directive for displaying the MRpro logo in the documentation with center alignment and specified width.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/docs/source/index.rst#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. image:: _static/logo.svg\n   :align: center\n   :width: 300\n```\n\n----------------------------------------\n\nTITLE: Performing Direct Adjoint Reconstruction for Reference Images\nDESCRIPTION: Uses direct (adjoint) reconstruction to create reference images from both the fully sampled (402 spokes) and undersampled (24 spokes) data. These images will be used for comparison with the wavelet-regularized reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/pgd_wavelet_reconstruction.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndirect_reconstruction_402 = mrpro.algorithms.reconstruction.DirectReconstruction(kdata_402spokes)\ndirect_reconstruction_24 = mrpro.algorithms.reconstruction.DirectReconstruction(kdata_24spokes)\nimg_direct_402 = direct_reconstruction_402(kdata_402spokes)\nimg_direct_24 = direct_reconstruction_24(kdata_24spokes)\n```\n\n----------------------------------------\n\nTITLE: Creating Density Compensation Function\nDESCRIPTION: Generates a density compensation operator using Voronoi tessellation of the k-space trajectory to weight the loss function in the iterative reconstruction.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/examples/notebooks/iterative_sense_reconstruction_radial2D.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndcf_operator = mrpro.data.DcfData.from_traj_voronoi(kdata.traj).as_operator()\n```\n\n----------------------------------------\n\nTITLE: Configuring RST Table of Contents\nDESCRIPTION: RST directive for creating a table of contents with maximum depth of 2 levels, including various documentation sections.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/docs/source/index.rst#2025-04-17_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n\n   user_guide\n   examples\n   contributor_guide\n   api\n   faq\n```\n\n----------------------------------------\n\nTITLE: Configuring RST Colab Badge\nDESCRIPTION: RST directive for creating a Colab badge with link to the MRpro Colab notebook.\nSOURCE: https://github.com/PTB-MR/mrpro/blob/main/docs/source/index.rst#2025-04-17_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. |colab-badge| image:: https://colab.research.google.com/assets/colab-badge.svg\n    :target: https://colab.research.google.com/github/PTB-MR/mrpro\n```"
  }
]