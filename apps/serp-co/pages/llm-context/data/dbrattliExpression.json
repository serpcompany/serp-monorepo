[
  {
    "owner": "dbrattli",
    "repo": "expression",
    "content": "TITLE: Implementing Pipeline for Multiple Function Composition\nDESCRIPTION: Creates a pipeline function using reduce to compose any number of Result-returning functions, enabling Kleisli composition for chaining multiple operations.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import reduce\n\ndef pipeline(*fns):\n    return reduce(lambda res, fn: lambda x: res(x).bind(fn), fns)\n```\n\n----------------------------------------\n\nTITLE: Implementing Result Type for Error Handling in Python\nDESCRIPTION: Shows how to use the Result type from the Expression library for error-tolerant code. It demonstrates using the Result effect decorator for composing operations that may fail.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import Ok, Result, effect\n\n\n@effect.result[int, Exception]()\ndef fn5() -> Generator[int, int, int]:\n    x = yield from Ok(42)\n    y = yield from Ok(10)\n    return x + y\n\n\nxs = fn5()\nassert isinstance(xs, Result)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Result Type in Python\nDESCRIPTION: Defines a simple Result type with Ok and Error classes for representing successful and failed operations, providing a type-based alternative to exception handling.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Result:\n    pass\n\nclass Ok(Result):\n    def __init__(self, value):\n        self._value = value\n\n    def __str__(self):\n        return \"Ok %s\" % str(self._value)\n\nclass Error(Result):\n    def __init__(self, exn):\n        self._exn = exn\n\n    def __str__(self):\n        return \"Error %s\" % str(self._exn)\n```\n\n----------------------------------------\n\nTITLE: Using Sequence Operations in Python with Expression Library\nDESCRIPTION: Demonstrates the use of Sequence operations from the Expression library for working with Python iterables. It shows how to use pipe, map, filter, and fold operations on a sequence in a functional style.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport functools\nfrom collections.abc import Iterable\n\nfrom expression import pipe\nfrom expression.collections import seq\n\n\n# Normal python way. Nested functions are hard to read since you need to\n# start reading from the end of the expression.\nxs: Iterable[int]\nxs = range(100)\nys = functools.reduce(lambda s, x: s + x, filter(lambda x: x > 100, map(lambda x: x * 10, xs)), 0)\n\nmapper: Callable[[int], int] = lambda x: x * 10\npredicate: Callable[[int], bool] = lambda x: x > 100\nfolder: Callable[[int, int], int] = lambda s, x: s + x\n\n# With Expression, you pipe the result, so it flows from one operator to the next:\nzs: int = pipe(\n    xs,\n    seq.map(mapper),\n    seq.filter(predicate),\n    seq.fold(folder, 0),\n)\nassert ys == zs\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncResult for Asynchronous Error Handling in Python\nDESCRIPTION: Demonstrates the use of AsyncResult from the Expression library for handling errors in asynchronous code. It shows how to compose asynchronous operations that may fail.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import AsyncGenerator\n\nfrom expression import Error, Ok, effect\n\n\n@effect.async_result[int, str]()\nasync def fn() -> AsyncGenerator[int, int]:\n    x: int = yield 42  # Regular value\n    y: int = yield await Ok(43)  # Awaitable Ok value\n\n    # Short-circuit if condition is met\n    if x + y > 80:\n        z: int = yield await Error(\"Value too large\")  # This will short-circuit\n    else:\n        z: int = yield 44\n\n    yield x + y + z  # Final value\n\n\n# This would be run in an async context\n# result = await fn()\n# assert result == Error(\"Value too large\")\n```\n\n----------------------------------------\n\nTITLE: Sequence Transformation Pipeline\nDESCRIPTION: Demonstrates creating a data processing pipeline using the Seq collection type. The example maps, filters, and folds a sequence of integers, showcasing the composability of sequence operations.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\n\nfrom expression.collections import Seq, seq\n\n\n# Since static type checkes aren't good good at inferring lambda types\nmapper: Callable[[int], int] = lambda x: x * 10\npredicate: Callable[[int], bool] = lambda x: x > 100\nfolder: Callable[[int, int], int] = lambda s, x: s + x\n\nxs = Seq.of(9, 10, 11)\nys = xs.pipe(\n    seq.map(mapper),\n    seq.filter(predicate),\n    seq.fold(folder, 0),\n)\n\nassert ys == 110\n```\n\n----------------------------------------\n\nTITLE: Basic Piping Function with Expression\nDESCRIPTION: Demonstrates the pipe function that allows passing a value through a series of functions, similar to F#'s |> operator. It shows how to chain function calls in a readable, sequential manner.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\n\nfrom expression import pipe\n\n\nv = 1\nfn1: Callable[[int], int] = lambda x: x + 1\ngn1: Callable[[int], int] = lambda x: x * 2\n\nassert pipe(v, fn1, gn1) == gn1(fn1(v))\n```\n\n----------------------------------------\n\nTITLE: Creating a Fetch Function with Result Type\nDESCRIPTION: Implements a fetch function that returns an Ok for successful operations or Error for failures. Demonstrates how to wrap potentially failing operations in a Result type.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import Ok, Error\n\ndef fetch(url):\n    try:\n        if not \"http://\" in url:\n            raise Exception(\"Error: unable to fetch from: '%s'\" % url)\n\n        value = url.replace(\"http://\", \"\")\n        return Ok(value)\n    except Exception as exn:\n        return Error(exn)\n```\n\n----------------------------------------\n\nTITLE: Implementing Option Type for Handling Optional Values in Python\nDESCRIPTION: Demonstrates the use of the Option type from the Expression library to handle cases where a function might not produce a meaningful output for a given input.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import Nothing, Option, Some\n\n\ndef keep_positive(a: int) -> Option[int]:\n    if a > 0:\n        return Some(a)\n\n    return Nothing\n```\n\n----------------------------------------\n\nTITLE: Using Functional Syntax with Expression Library in Python\nDESCRIPTION: Demonstrates the functional syntax for sequence operations using the Expression library. It shows how to use pipe, map, filter, and fold operations on a sequence.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import pipe\nfrom expression.collections import Seq, seq\n\n\nmapper: Callable[[int], int] = lambda x: x * 100\n\nxs = Seq.of(1, 2, 3)\nys = pipe(\n    xs,\n    seq.map(mapper),\n    seq.filter(lambda x: x > 100),\n    seq.fold(lambda s, x: s + x, 0),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncOption for Asynchronous Optional Values in Python\nDESCRIPTION: Demonstrates the use of AsyncOption from the Expression library for handling optional values in asynchronous code. It shows how to compose asynchronous operations that may return an optional value.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import AsyncGenerator\n\nfrom expression import Nothing, Some, effect\n\n\n@effect.async_option[int]()\nasync def fn_option() -> AsyncGenerator[int, int]:\n    x: int = yield 42  # Regular value\n    y: int = yield await Some(43)  # Awaitable Some value\n\n    # Short-circuit if condition is met\n    if x + y > 80:\n        z: int = yield await Nothing  # This will short-circuit\n    else:\n        z: int = yield 44\n\n    yield x + y + z  # Final value\n\n\n# This would be run in an async context\n# result = await fn_option()\n# assert result is Nothing\n```\n\n----------------------------------------\n\nTITLE: Creating Tagged Union for Shape Types in Python\nDESCRIPTION: Demonstrates how to use the tagged_union decorator to create a sum type for different shapes. Each shape case produces the same type (Shape) with static methods to create instances.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/data_modelling.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@tagged_union\nclass Shape:\n    tag: Literal[\"rectangle\", \"circle\"] = tag()\n\n    rectangle: Rectangle = case()\n    circle: Circle = case()\n\n    @staticmethod\n    def Rectangle(width: float, length: float) -> Shape:\n        return Shape(rectangle=Rectangle(width, length))\n\n    @staticmethod\n    def Circle(radius: float) -> Shape:\n        return Shape(circle=Circle(radius))\n```\n\n----------------------------------------\n\nTITLE: Functional Composition with Higher-Order Functions\nDESCRIPTION: Demonstrates functional composition using a higher-order function that combines two functions and returns a new function.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Functional compose. Inject all dependencies.\ndef compose(f, g):\n    return lambda x: g(f(x))\n\nh = compose(f, g)\nh(42)\n```\n\n----------------------------------------\n\nTITLE: Using Pipeline for Function Composition\nDESCRIPTION: Demonstrates using the pipeline function to compose fetch and parse operations, showing a cleaner alternative to nested bind calls.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfetch_and_parse = pipeline(fetch, parse)\nresult = fetch_and_parse(\"http://123\")\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Using Bind for Function Composition\nDESCRIPTION: Demonstrates using the bind function to compose fetch and parse operations, showing how bind enables clean functional composition of Result-returning functions.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nresult = bind(parse, fetch(\"http://42\"))\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Composition in Python\nDESCRIPTION: Defines a compose function that takes multiple functions as arguments and returns a new function that applies them in sequence from left to right using reduce.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable, Any\n\ndef compose(*fns: Callable[[Any], Any]) -> Callable[[Any], Any]:\n    \"\"\"Compose multiple functions left to right.\"\"\"\n\n    def _compose(source: Any) -> Any:\n        return reduce(lambda acc, f: f(acc), fns, source)\n\n    return _compose\n```\n\n----------------------------------------\n\nTITLE: Creating Safe Division Function with Option Type\nDESCRIPTION: Implements a division function that returns an Option type to handle division by zero safely without exceptions.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef divide(a: float, divisor: float) -> Option[int]:\n    try:\n        return Some(a/divisor)\n    except ZeroDivisionError:\n        return Nothing\n```\n\n----------------------------------------\n\nTITLE: Implementing a Parse Function with Result Type\nDESCRIPTION: Creates a parse function that attempts to convert a string to a float, returning Ok for success or Error for failure, showing another example of error handling with Result types.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef parse(string):\n    try:\n        value = float(string)\n        return Ok(value)\n    except Exception as exn:\n        return Error(exn)\n```\n\n----------------------------------------\n\nTITLE: Cont Monad Implementation in Python\nDESCRIPTION: Implements a Cont monad class to encapsulate continuation passing style functions with proper type abstractions.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/continuations.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Cont:\n    def __init__(self, cps):\n        self.__cps = cps # fn: ('a -> 'r) -> 'r\n\n    @staticmethod\n    def rtn(a):\n        return Cont(lambda cont: cont(a))\n\n    def run(self, cont):\n        self.__cps(cont)\n\n    def then(self, fn):\n        # Cont <| fun c -> run cont (fun a -> run (fn a) c )\n        return Cont(lambda c: self.run(lambda a: fn(a).run(c)))\n```\n\n----------------------------------------\n\nTITLE: IO Effect Implementation in Python\nDESCRIPTION: Implementation of an IO monad for handling side effects in a pure functional way. The Io class wraps world-changing functions and provides bind and return operations.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/effects.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, Tuple, TypeVar\n\nTSource = TypeVar(\"TSource\")\n\nclass Io(Generic[TSource]):\n    def __init__(self, fn):\n        self.__fn = fn  # a world changing function\n\n    def rtn(a) -> \"Io[TSource]\":\n        return Io(lambda world: (a, world + 1))\n\n    def run(self, world: int=0) -> Tuple[TSource, int]:\n        return self.__fn(world)\n\n    def bind(self, fn: Callable[[TSource], \"Io[TSource]\"]) -> \"Io[TSource]\":\n        def run(world):\n            a, newWorld = self.run(world)\n            return fn(a).run(newWorld)\n        return Io(run)\n\n    def __repr__(self):\n        return \"Io\"\n```\n\n----------------------------------------\n\nTITLE: Using Pattern Matching with Tagged Union Types in Python\nDESCRIPTION: Shows how to leverage Python's pattern matching to implement domain logic for calculating card values in a card game, demonstrating the power of structured data types.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/data_modelling.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef calculate_value(card: Card) -> int:\n    match card:\n        case Card(tag=\"face\", face=(Suit(spades=True), Face(queen=True))):\n            return 40\n        case Card(tag=\"face\", face=(_suit, Face(ace=True))):\n            return 15\n        case Card(tag=\"face\", face=(_suit, _face)):\n            return 10\n        case Card(tag=\"value\", value=(_suit, value)):\n            return value\n        case Card(tag=\"joker\", joker=True):\n            return 0\n        case _:\n            raise AssertionError(\"Should not match\")\n\n\nrummy_score = calculate_value(jack_of_hearts)\nprint(\"Score: \", rummy_score)\n\nrummy_score = calculate_value(three_of_clubs)\nprint(\"Score: \", rummy_score)\n\nrummy_score = calculate_value(joker)\nprint(\"Score: \", rummy_score)\n```\n\n----------------------------------------\n\nTITLE: IO Operations with Effects\nDESCRIPTION: Implementation of put and get functions using the IO effect type to handle input/output operations in a pure functional way.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/effects.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef put(string) -> Io[str]:\n    def side_effect(_):\n        return Io.rtn(print(string))\n\n    return Io.rtn(None).bind(side_effect)\n\ndef get(fn: Callable[[str], Io[str]]) -> Io[str]:\n    def side_effect(_):\n        return fn(input())\n    return Io.rtn(None).bind(side_effect)\n```\n\n----------------------------------------\n\nTITLE: Enhancing Result Type with Bind Method\nDESCRIPTION: Extends the Result classes with a bind method to enable functional composition. This creates a more elegant way to chain operations that return Result types.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Ok(Result):\n    def __init__(self, value):\n        self._value = value\n\n    def bind(self, fn):\n        return fn(self._value)\n\n    def __str__(self):\n        return \"Ok %s\" % str(self._value)\n\nclass Error(Result):\n    def __init__(self, exn):\n        self._exn = exn\n\n    def bind(self, fn):\n        return self\n\n    def __str__(self):\n        return \"Error %s\" % str(self._exn)\n\ndef bind(fn, result):\n    \"\"\"We don't want method chaining in Python.\"\"\"\n    return result.bind(fn)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Tagged Unions in Python\nDESCRIPTION: Shows how to use pattern matching with tagged unions to extract values from a Shape instance.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nshape = Shape.Rectangle(2.3, 3.3)\n\nmatch shape:\n    case Shape(tag=\"rectangle\", rectangle=Rectangle(width=2.3)):\n        assert shape.rectangle.width == 2.3\n    case _:\n        assert False\n```\n\n----------------------------------------\n\nTITLE: Function Composition for Custom Operators\nDESCRIPTION: Shows how to create custom operators by composing multiple functions together. This example composes mapping, filtering, and folding operations into a single function that can be applied to a sequence.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import compose\nfrom expression.collections import Seq, seq\n\n\nmapper: Callable[[int], int] = lambda x: x * 10\npredicate: Callable[[int], bool] = lambda x: x > 100\nfolder: Callable[[int, int], int] = lambda s, x: s + x\n\nxs = Seq.of(9, 10, 11)\ncustom = compose(\n    seq.map(mapper),\n    seq.filter(predicate),\n    seq.fold(folder, 0),\n)\nys = custom(xs)\n\nassert ys == 110\n```\n\n----------------------------------------\n\nTITLE: Implementing Tagged Union Class in Python using Expression\nDESCRIPTION: Demonstrates how to create a tagged union class for shapes using the Expression library's @tagged_union decorator. Shows implementation of Rectangle and Circle cases with static constructors.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import Literal\n\nfrom expression import case, tag, tagged_union\n\n\n@dataclass\nclass Rectangle:\n    width: float\n    length: float\n\n\n@dataclass\nclass Circle:\n    radius: float\n\n\n@tagged_union\nclass Shape:\n    tag: Literal[\"rectangle\", \"circle\"] = tag()\n\n    rectangle: Rectangle = case()\n    circle: Circle = case()\n\n    @staticmethod\n    def Rectangle(width: float, length: float) -> \"Shape\":\n        \"\"\"Optional static method for creating a tagged union case\"\"\"\n        return Shape(rectangle=Rectangle(width, length))\n\n    @staticmethod\n    def Circle(radius: float) -> \"Shape\":\n        \"\"\"Optional static method for creating a tagged union case\"\"\"\n        return Shape(circle=Circle(radius))\n```\n\n----------------------------------------\n\nTITLE: Function Pipelining with Expression Library\nDESCRIPTION: Demonstrates how to create a pipeline of operations using the pipe function from the Expression library.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import pipe\nfrom expression.collections import seq\n\nxs = seq.of_iterable(range(10))\n\nmapping = seq.map(lambda x: x * 10)\nfilter = seq.filter(lambda x: x > 30)\n\npipe(xs,\n    mapping,\n    filter,\n    list,\n)\n```\n\n----------------------------------------\n\nTITLE: Improved Readability with Expression Pipe\nDESCRIPTION: Demonstrates how using the pipe function from Expression library improves code readability by enabling a left-to-right flow of operations.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import pipe\nfrom expression.collections import seq\n\nxs = seq.range(10)\n\npipe(\n    xs,\n    seq.map(lambda x: x * 10),\n    seq.filter(lambda x: x > 50),\n    seq.fold(lambda s, x: s + x, 0),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Playing Card Type System with Tagged Unions in Python\nDESCRIPTION: A complex example that models a card game system using nested tagged unions for Suit, Face, and Card types, demonstrating how to create and validate structured data types.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/data_modelling.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\nfrom typing import Tuple, final\n\nfrom expression import case, tag, tagged_union\n\n\n@tagged_union\nclass Suit:\n    tag: Literal[\"spades\", \"hearts\", \"clubs\", \"diamonds\"] = tag()\n\n    spades: Literal[True] = case()\n    hearts: Literal[True] = case()\n    clubs: Literal[True] = case()\n    diamonds: Literal[True] = case()\n\n    @staticmethod\n    def Spades() -> Suit:\n        return Suit(spades=True)\n\n    @staticmethod\n    def Hearts() -> Suit:\n        return Suit(hearts=True)\n\n    @staticmethod\n    def Clubs() -> Suit:\n        return Suit(clubs=True)\n\n    @staticmethod\n    def Diamonds() -> Suit:\n        return Suit(diamonds=True)\n\n@tagged_union\nclass Face:\n    tag: Literal[\"jack\", \"queen\", \"king\", \"ace\"] = tag()\n\n    jack: Literal[True] = case()\n    queen: Literal[True] = case()\n    king: Literal[True] = case()\n    ace: Literal[True] = case()\n\n    @staticmethod\n    def Jack() -> Face:\n        return Face(jack=True)\n\n    @staticmethod\n    def Queen() -> Face:\n        return Face(queen=True)\n\n    @staticmethod\n    def King() -> Face:\n        return Face(king=True)\n\n    @staticmethod\n    def Ace() -> Face:\n        return Face(ace=True)\n\n\n@tagged_union\nclass Card:\n    tag: Literal[\"value\", \"face\", \"joker\"] = tag()\n\n    face: tuple[Suit, Face] = case()\n    value: tuple[Suit, int] = case()\n    joker: Literal[True] = case()\n\n    @staticmethod\n    def Face(suit: Suit, face: Face) -> Card:\n        return Card(face=(suit, face))\n\n    @staticmethod\n    def Value(suit: Suit, value: int) -> Card:\n        if value < 1 or value > 10:\n            raise ValueError(\"Value must be between 1 and 10\")\n        return Card(value=(suit, value))\n\n    @staticmethod\n    def Joker() -> Card:\n        return Card(joker=True)\n\n\njack_of_hearts = Card.Face(suit=Suit.Hearts(), face=Face.Jack())\nthree_of_clubs = Card.Value(suit=Suit.Clubs(), value=3)\njoker = Card.Joker()\n```\n\n----------------------------------------\n\nTITLE: Manual Currying in Python\nDESCRIPTION: Demonstrates how to manually curry a function by creating a function that returns another function, allowing for partial application.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nadd = lambda a: lambda b: a + b\nadd(10)(20)\n```\n\n----------------------------------------\n\nTITLE: Async/Await Implementation with Cont Monad\nDESCRIPTION: Extends the Cont monad to support async/await syntax through __await__ implementation, demonstrating how continuations relate to async programming.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/continuations.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nclass Cont:\n    def __init__(self, cps):\n        self.__cps = cps # fn: ('a -> 'r) -> 'r\n\n    @staticmethod\n    def rtn(a):\n        return Cont(lambda cont: cont(a))\n\n    def run(self, cont):\n        self.__cps(cont)\n\n    def __await__(self):\n        loop = asyncio.get_event_loop()\n        future = loop.create_future()\n        def done(value):\n            future.set_result(value)\n        self.run(done)\n        return iter(future)\n\n    def then(self, fn):\n        return Cont(lambda c: self.run(lambda a: (fn(a).run(c))))\n```\n\n----------------------------------------\n\nTITLE: Creating Functions that Return Functions\nDESCRIPTION: Shows how to create a higher-order function that returns another function, enabling partial application.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef add_n(n):\n    def partial(x):\n        return x+n\n    return partial\n```\n\n----------------------------------------\n\nTITLE: Functions Taking Functions as Arguments\nDESCRIPTION: Demonstrates how to create a higher-order function that accepts another function as a parameter.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef square(x, multiply):\n    return multiply(x, x)\n```\n\n----------------------------------------\n\nTITLE: Using Map: Immutable Dict in Python\nDESCRIPTION: This code demonstrates the usage of the Map class from the Expression library, which is an immutable Dict type. It shows how to create a Map and filter its contents.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/containers.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom expression.collections import Map\n\nitems = dict(a=10, b=20).items()\nxs = Map.of_seq(items)\nprint(xs)\n\nys = xs.filter(lambda k, v: v>10)\nprint(ys)\n```\n\n----------------------------------------\n\nTITLE: Nesting AsyncResult Functions in Python with Expression Library\nDESCRIPTION: Shows how to nest AsyncResult functions using the Expression library. It demonstrates calling and awaiting inner AsyncResult functions within an outer AsyncResult function.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n@effect.async_result[int, str]()\nasync def inner(x: int) -> AsyncGenerator[int, int]:\n    y: int = yield x + 1\n    yield y + 1  # Final value is y + 1\n\n\n@effect.async_result[int, str]()\nasync def outer() -> AsyncGenerator[int, int]:\n    x: int = yield 40\n\n    # Call inner and await its result\n    inner_result = await inner(x)\n    y: int = yield await inner_result\n\n    yield y  # Final value is y\n\n\n# This would be run in an async context\n# result = await outer()\n# assert result == Ok(42)  # 40 -> 41 -> 42\n```\n\n----------------------------------------\n\nTITLE: Implementing Push Collections (Observable) in Python\nDESCRIPTION: This snippet demonstrates the implementation of a push collection (Observable) using functions in Python, including an infinite sequence generator and a 'take' operator.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/containers.md#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\ndef observer(value):\n    print(f\"got value: {value}\")\n\ndef infinite():\n    def subscribe(obv):\n        for x in range(1000):\n            obv(x)\n\n    return subscribe\n\ndef take(count):\n    def obs(source):\n        def subscribe(obv):\n            n = count\n            def observer(value):\n                nonlocal n\n                if n > 0:\n                    obv(value)\n                n -= 1\n\n            source(observer)\n        return subscribe\n    return obs\n\ntake(10)(infinite())(observer)\n```\n\n----------------------------------------\n\nTITLE: Continuation Passing Style Implementation in Python\nDESCRIPTION: Demonstrates continuation passing style (CPS) implementation of the same mathematical functions, where results are passed to continuation functions.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/continuations.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport math\n\ndef add(a, b, cont):\n    cont(a + b)\n\ndef square(x, cont):\n    cont(x * x)\n\ndef sqrt(x, cont):\n    cont(math.sqrt(x))\n\n# Pythagoras rewritten in CPS\ndef pythagoras(a, b, cont):\n    square(a, (lambda aa:\n        square(b, (lambda bb:\n            add(aa, bb, (lambda aabb:\n                sqrt(aabb, (lambda result:\n                    cont(result))\n                ))\n            ))\n        ))\n    ))\n```\n\n----------------------------------------\n\nTITLE: Creating a Compose Function for Result Types\nDESCRIPTION: Implements a compose function that takes two Result-returning functions and returns a new function that chains them together using bind, enabling cleaner composition patterns.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef compose(f, g):\n    return lambda x: f(x).bind(g)\n\nfetch_parse = compose(fetch, parse)\nresult = fetch_parse(\"http://123.0\")\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Implementing Closures in Python\nDESCRIPTION: This snippet demonstrates the concept of closures in Python, showing how functions can act as containers by storing values in their scope.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/containers.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef hat(item):\n    def pull():\n        return item\n    return pull\n\nsmall_hat = lambda item: lambda pull: item\n\npull = hat(\"rabbit\")\npull()\n```\n\n----------------------------------------\n\nTITLE: Fluent Syntax with Method Chaining\nDESCRIPTION: Demonstrates the fluent syntax style using method chaining. This approach uses dot notation to chain operations together in a compact way, but can be challenging for line breaks in larger pipelines.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom expression.collections import Seq\n\n\nxs = Seq.of(1, 2, 3)\nys = xs.map(lambda x: x * 100).filter(lambda x: x > 100).fold(lambda s, x: s + x, 0)\n```\n\n----------------------------------------\n\nTITLE: Using Option as an Effect with Coroutines\nDESCRIPTION: Shows how to use options with the effect decorator to implement railway-oriented programming, allowing for seamless option chaining.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import effect, Some\n\n@effect.option[int]()\ndef fn():\n    x = yield 42\n    y = yield from Some(43)\n\n    return x + y\n\nfn()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Referential Transparency in Python\nDESCRIPTION: Example showing how referential transparency can be affected by side-effects in Python functions. The function demonstrates various impure operations like input(), print(), and list mutation.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/effects.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nz = [42]\n\ndef expr(a):\n    #return a + 1\n\n    a += int(input())\n    return a\n    #print(a)\n    #z[0] += a\n    #return z[0]\n```\n\n----------------------------------------\n\nTITLE: Mixing Fluent and Functional Syntax in Expression Library\nDESCRIPTION: Shows how to combine fluent and functional syntax using the Expression library. It demonstrates using the pipe method in a fluent style.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom expression.collections import Seq, seq\n\n\nxs = Seq.of(1, 2, 3).pipe(seq.map(mapper))\n```\n\n----------------------------------------\n\nTITLE: Using Option as an Effect in Python with Expression Library\nDESCRIPTION: Demonstrates how to use Option as an effect using decorated coroutines in the Expression library. It shows how to consume and generate optional values using yield and yield from.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Generator\n\nfrom expression import Some, effect\n\n\n@effect.option[int]()\ndef fn3() -> Generator[int, int, int]:\n    x = yield 42\n    y = yield from Some(43)\n\n    return x + y\n\n\nxs = fn3()\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Lambda Calculus Functions in Python\nDESCRIPTION: Defines fundamental lambda calculus concepts including identity function and numeric representations using nested lambda functions.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/lambda_calculus.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nidentity = lambda x: x\n\nzero = lambda f: identity\none = lambda f: lambda x: f(x)\ntwo = lambda f: lambda x: f(f(x))\nthree = lambda f: lambda x: f(f(f(x)))\n```\n\n----------------------------------------\n\nTITLE: Effect Usage with Expression Library\nDESCRIPTION: Example showing how to use the Expression library to handle effects safely using the Option type and effect decorators.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/effects.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import effect, Option, Some, Nothing\n\n\ndef divide(a: float, divisor: float) -> Option[float]:\n    try:\n        return Some(a / divisor)\n    except ZeroDivisionError:\n        return Nothing\n\n\n@effect.option[float]()\ndef comp(x: float):\n    result: float = yield from divide(42, x)\n    result += 32\n    print(f\"The result is {result}\")\n    return result\n\n\ncomp(42)\n```\n\n----------------------------------------\n\nTITLE: Using Pipeline for Multiple Fetch Operations\nDESCRIPTION: Shows how to use the pipeline function to chain multiple fetch operations, demonstrating a solution to the Pyramid of Doom problem.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom expression.extra.result import pipeline\n\nfetch_with_value = lambda x: fetch(\"http://%s\" % x)\n\nrequest = pipeline(\n            fetch,\n            fetch_with_value,\n            fetch_with_value,\n            fetch_with_value,\n            fetch_with_value,\n            fetch_with_value,\n            fetch_with_value,\n            parse\n          )\n\nresult = request(\"http://123\")\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Using Option-Returning Functions with Positive Input\nDESCRIPTION: Demonstrates calling an option-returning function with a positive value, resulting in a Some value.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nkeep_positive(42)\n```\n\n----------------------------------------\n\nTITLE: Point-free Programming Example using Reduce\nDESCRIPTION: Demonstrates point-free programming style using reduce function, comparing verbose and simplified implementations.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/lambda_calculus.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import reduce\n\nxs = reduce(lambda acc, x: max(acc, x), range(10))\nprint(xs)\n\nxs = reduce(max, range(10))\nprint(xs)\n```\n\n----------------------------------------\n\nTITLE: Creating Option-Returning Functions\nDESCRIPTION: Implements a function that returns an Option type to handle conditional values safely, returning Some for positive integers and Nothing otherwise.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef keep_positive(a: int) -> Option[int]:\n    if a > 0:\n        return Some(a)\n\n    return Nothing\n```\n\n----------------------------------------\n\nTITLE: Creating Some Values with Option Type\nDESCRIPTION: Demonstrates how to create an option value containing a value using the Some constructor from the Expression library.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import Some\n\nxs = Some(42)\nprint(xs)\n```\n\n----------------------------------------\n\nTITLE: Implementing Successor Function in Lambda Calculus\nDESCRIPTION: Demonstrates the successor function implementation and its usage to generate sequential numbers.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/lambda_calculus.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Don't repeat yourself (DRY)\nsucc = lambda numeral: lambda f: lambda x: f(numeral(f)(x))\ntwo = succ(one)\nthree = succ(two)\n\nthree(lambda x: x+1)(0)\n```\n\n----------------------------------------\n\nTITLE: Reimplementing the Compose Function\nDESCRIPTION: Reimplements the compose function for Result types, showing a cleaner approach to function composition with Result types.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef compose(f, g):\n    return lambda x: f(x).bind(g)\n\nfetch_parse = compose(fetch, parse)\nresult = fetch_parse(\"http://42\")\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Ambiguity with None Values in Dictionaries\nDESCRIPTION: Demonstrates the ambiguity in dictionaries where you can't distinguish between a missing key and a key with a None value using get().\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmapping = dict(a=None)\nmapping.get(\"a\")\n```\n\n----------------------------------------\n\nTITLE: Curried Continuation Style in Python\nDESCRIPTION: Shows an alternative approach using currying to handle continuations, returning functions that accept continuations instead of taking them as parameters.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/continuations.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport math\n\ndef add(a, b):\n    return lambda cont: cont(a + b)\n\ndef square(x):\n    return lambda cont: cont(x * x)\n\ndef sqrt(x):\n    return lambda cont: cont(math.sqrt(x))\n\ndef pythagoras(a, b):\n    def then(cont):\n        then = square(a)\n        def next(aa):\n            then = square(b)\n            def next(bb):\n                then = add(aa, bb)\n                def next(aabb):\n                    then = sqrt(aabb)\n                    def next(result):\n                        cont(result)\n                    then(next)\n                then(next)\n            then(next)\n        then(next)\n    return then\n```\n\n----------------------------------------\n\nTITLE: Implementing Railway Oriented Programming with Option in Python\nDESCRIPTION: Shows how to implement railway oriented programming using the Option effect in the Expression library. It demonstrates short-circuiting when yielding Nothing.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Generator\n\nfrom expression import Nothing, Some, effect\n\n\n@effect.option[int]()\ndef fn4() -> Generator[int, int, int]:\n    x = yield from Nothing  # or a function returning Nothing\n\n    # -- The rest of the function will never be executed --\n    y = yield from Some(43)\n\n    return x + y\n\n\nxs = fn4()\nassert xs is Nothing\n```\n\n----------------------------------------\n\nTITLE: Using Optional Type Hint with None\nDESCRIPTION: Demonstrates how to properly type hint an optional integer value using the Optional type from the typing module.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nxs: Optional[int] = None\n\nprint(xs)\n```\n\n----------------------------------------\n\nTITLE: Using Curry Decorator from Expression\nDESCRIPTION: Shows how to use the curry decorator from the Expression library to simplify currying in Python.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import curry\n\n@curry(1)\ndef add(a: int, b: int) -> int:\n    return a + b\n\nadd(3)(4)\n```\n\n----------------------------------------\n\nTITLE: Creating Single Case Tagged Unions for Type Safety in Python\nDESCRIPTION: Demonstrates using a single-case tagged union to create a secure password type that prevents leaking sensitive information through string representation, enhancing type safety.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/data_modelling.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@tagged_union(frozen=True, repr=False)\nclass SecurePassword:\n    password: str = case()\n\n    # Override __str__ and __repr__ to make sure we don't leak the password in logs\n    def __str__(self) -> str:\n        return \"********\"\n\n    def __repr__(self) -> str:\n        return \"SecurePassword(password='********')\"\n\npassword = SecurePassword(password=\"secret\")\nmatch password:\n    case SecurePassword(password=p):\n        assert p == \"secret\"\n```\n\n----------------------------------------\n\nTITLE: Basic Timer Callback Implementation in Python\nDESCRIPTION: Demonstrates a simple asynchronous callback using threading.Timer to execute a function after 5 seconds.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/continuations.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport threading\n\ndef long_running(callback):\n    def done():\n        result = 42\n        callback(result)\n    timer = threading.Timer(5.0, done)\n    timer.start()\n\nlong_running(print)\n```\n\n----------------------------------------\n\nTITLE: Creating a Functional List Implementation in Python\nDESCRIPTION: This code demonstrates how to create a fully functional list implementation using only functions in Python, showcasing concepts of functional programming.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/containers.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nempty_list = None\n\ndef prepend(el, lst):\n    return lambda selector: selector(el, lst)\n\ndef head(lst):\n    return lst(lambda h, t: h)\n\ndef tail(lst):\n    return lst(lambda h, t: t)\n\ndef is_empty(lst):\n    return (lst == empty_list)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Block: Immutable List in Python\nDESCRIPTION: This snippet showcases the usage of the Block class from the Expression library, which is an immutable List type. It demonstrates creating a Block, adding an element, and getting the tail.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/containers.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom expression.collections import Block\n\nxs = Block.of_seq(range(10))\nprint(xs)\n\nys = xs.cons(10)\nprint(ys)\n\nzs = xs.tail()\nprint(zs)\n```\n\n----------------------------------------\n\nTITLE: Testing Functional List Implementation in Python\nDESCRIPTION: This snippet tests the functional list implementation created in the previous code block, demonstrating its usage and functionality.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/containers.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\na = prepend(\"a\", prepend(\"b\", empty_list))\n\nassert(\"a\" == head(a))\nassert(\"b\" == head(tail(a)))\nassert(tail(tail(a))==empty_list)\nassert(not is_empty(a))\nassert(is_empty(empty_list))\n\nprint(\"all tests are green!\")\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Option Type in Python\nDESCRIPTION: Shows how to use pattern matching with the Option type from the Expression library to check for the existence of a value.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nfrom expression import Ok, Option\n\n\ndef exists(x: Option[int]) -> bool:\n    match x:\n        case Option(tag=\"some\"):\n            return True\n        case _:\n            return False\n```\n\n----------------------------------------\n\nTITLE: Using Bind Method for Error Handling\nDESCRIPTION: Shows how bind handles error cases by chaining fetch and parse operations, demonstrating how errors short-circuit the computation chain.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nresult = fetch(\"http://invalid\").bind(parse)\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Testing for Nothing Values\nDESCRIPTION: Demonstrates how to test if an option value is Nothing using the 'is' operator for identity comparison.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nxs = Nothing\nassert xs is Nothing\n```\n\n----------------------------------------\n\nTITLE: Testing Function Composition Associativity in Python\nDESCRIPTION: Demonstrates the associative property of function composition using lambda functions. Tests that composing functions in different orders yields the same result.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef test(x):\n    f = lambda x: x + 1\n    g = lambda x: x * 2\n    h = lambda x: x - 10\n\n    right = compose(f, compose(g, h))\n    left = compose(compose(f, g), h)\n\n    assert right(x) == left(x)\n\ntest(10)\n```\n\n----------------------------------------\n\nTITLE: Using Option as an Applicative in Python with Expression Library\nDESCRIPTION: Demonstrates how to use Option as an applicative in the Expression library. It shows how to combine two Option values using the map2 function.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom operator import add\n\nfrom expression import Nothing, Option, Some\n\n\ndef keep_positive(a: int) -> Option[int]:\n    if a > 0:\n        return Some(a)\n    else:\n        return Nothing\n\n\ndef add_options(a: Option[int], b: Option[int]):\n    return a.map2(add, b)\n\n\nassert add_options(keep_positive(4), keep_positive(-2)) is Nothing\n\nassert add_options(keep_positive(3), keep_positive(2)) == Some(5)\n```\n\n----------------------------------------\n\nTITLE: Creating Nothing Values with Option Type\nDESCRIPTION: Shows how to create an empty option value using the Nothing singleton from the Expression library.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import Nothing\n\nxs = Nothing\nprint(xs)\n```\n\n----------------------------------------\n\nTITLE: Monad Protocol Definition in Python\nDESCRIPTION: Defines a Protocol for Monads in Python using typing_extensions, establishing the interface for monadic types.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/continuations.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Protocol, runtime_checkable\nfrom abc import abstractmethod\n\n@runtime_checkable\nclass Monad(Protocol):\n    @staticmethod\n    @abstractmethod\n    def rtn(a):\n        raise NotImplementedError\n\n    @abstractmethod\n    def then(self, fn):\n        raise NotImplementedError\n```\n\n----------------------------------------\n\nTITLE: Railway-Oriented Programming with Nothing\nDESCRIPTION: Demonstrates how a function with the option effect decorator short-circuits when it encounters a Nothing value, skipping remaining code.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import effect, Some, Nothing\n\n@effect.option[int]()\ndef fn():\n    x = yield from Nothing # or a function returning Nothing\n\n    # -- The rest of the function will never be executed --\n    y = yield from Some(43)\n\n    return x + y\n\nfn()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating the Pyramid of Doom\nDESCRIPTION: Illustrates the 'Pyramid of Doom' problem when chaining multiple bind operations without proper composition tools, showing deeply nested function calls.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom expression.core import result\n\nresult = bind(parse,\n            bind(lambda x: fetch(\"http://%s\" % x),\n               bind(lambda x: fetch(\"http://%s\" % x),\n                  bind(lambda x: fetch(\"http://%s\" % x),\n                     bind(lambda x: fetch(\"http://%s\" % x),\n                         bind(lambda x: fetch(\"http://%s\" % x),\n                             bind(lambda x: fetch(\"http://%s\" % x),\n                                 fetch(\"http://123\")\n                            )\n                         )\n                     )\n                  )\n               )\n            )\n         )\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Safe Division with Non-Zero Divisor\nDESCRIPTION: Demonstrates using the safe division function with a non-zero divisor, returning a Some value with the result.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndivide(42, 2)\n```\n\n----------------------------------------\n\nTITLE: Using Result with Effect Decorator in Expression Library\nDESCRIPTION: Demonstrates using the effect decorator from the Expression library to create a function that yields Result values, showing a more advanced pattern for working with Result types.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import effect, Ok, Result\n\n@effect.result[int, Exception]()\ndef fn():\n    x = yield from Ok(42)\n    y = yield from Ok(10)\n    return x + y\n\nxs = fn()\nassert isinstance(xs, Result)\n```\n\n----------------------------------------\n\nTITLE: Mapping Nothing Preserves Nothing\nDESCRIPTION: Demonstrates that applying map to a Nothing value simply returns Nothing, maintaining the short-circuit behavior.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nxs = Nothing\nys = pipe(\n    xs,\n    option.map(lambda x: x*10)\n)\nprint(ys)\n```\n\n----------------------------------------\n\nTITLE: Creating Functions that Return Functions with Lambda\nDESCRIPTION: A concise way to create higher-order functions using lambda expressions that return other lambda functions.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nlambda n: lambda x: x+n\n```\n\n----------------------------------------\n\nTITLE: Defining Record Types with Data Classes in Python\nDESCRIPTION: Shows how to create record types using Python's data-classes decorator, defining Rectangle and Circle classes with their respective properties.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/data_modelling.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass Rectangle:\n    width: float\n    length: float\n\n\n@dataclass\nclass Circle:\n    radius: float\n```\n\n----------------------------------------\n\nTITLE: Using None in Python\nDESCRIPTION: Demonstrates basic usage of None in Python to represent the absence of a value, showing how to define a None value and print it.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nxs = None\nprint(xs)\n```\n\n----------------------------------------\n\nTITLE: Eta Conversion Implementation in Python\nDESCRIPTION: Shows eta conversion concept where abstraction over a function can be added or removed while maintaining equivalence.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/lambda_calculus.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Eta-conversion\n# x.(f x) and f\nf = lambda x: x\n\n(lambda x: f(x)) == f\n```\n\n----------------------------------------\n\nTITLE: Creating Lambda Functions in Python\nDESCRIPTION: Demonstrates how to create anonymous lambda functions in Python, which can be assigned to variables and used like regular functions.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nadd = lambda a, b: a + b\n\nadd(10, 20)\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Auto-documentation for Tagged Union Module\nDESCRIPTION: A restructuredtext directive that automatically generates documentation for all members of the expression.core.tagged_union module. This directive instructs Sphinx to parse and display documentation from docstrings in the module.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/union.md#2025-04-16_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: expression.core.tagged_union\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Testing for None Values\nDESCRIPTION: Shows how to correctly test for None values using 'is None' and 'is not None' operators in Python.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nxs = None\nassert xs is None\ny = 42\nassert y is not None\n```\n\n----------------------------------------\n\nTITLE: Compact Functional List Implementation in Python\nDESCRIPTION: This code provides a more compact version of the functional list implementation using lambda functions.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/containers.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nempty_list = None\nprepend = lambda el, lst: lambda selector: selector(el, lst)\nhead = lambda lst: lst(lambda h, t: h)\ntail = lambda lst: lst(lambda h, t: t)\nis_empty = lambda lst: lst is empty_list\n```\n\n----------------------------------------\n\nTITLE: Generating Seq Module Documentation with Sphinx\nDESCRIPTION: This code snippet uses the Sphinx automodule directive to automatically generate documentation for the expression.collections.seq module. It includes all members of the module in the documentation.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/seq.md#2025-04-16_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: expression.collections.seq\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Testing Compact Functional List in Python\nDESCRIPTION: This snippet tests the compact functional list implementation, demonstrating its usage and functionality.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/containers.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\na = prepend(\"a\", prepend(\"b\", empty_list))\n\nassert(\"a\" == head(a))\nassert(\"b\" == head(tail(a)))\nassert(tail(tail(a))==empty_list)\nassert(not is_empty(a))\nassert(is_empty(empty_list))\n\nprint(\"all tests are green!\")\n```\n\n----------------------------------------\n\nTITLE: Nesting AsyncOption Functions in Python with Expression Library\nDESCRIPTION: Shows how to nest AsyncOption functions using the Expression library. It demonstrates calling and awaiting inner AsyncOption functions within an outer AsyncOption function.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n@effect.async_option[int]()\nasync def inner_option(x: int) -> AsyncGenerator[int, int]:\n    y: int = yield x + 1\n    yield y + 1  # Final value is y + 1\n\n\n@effect.async_option[int]()\nasync def outer_option() -> AsyncGenerator[int, int]:\n    x: int = yield 40\n\n    # Call inner and await its result\n    inner_result = await inner_option(x)\n    y: int = yield await inner_result\n\n    yield y  # Final value is y\n\n\n# This would be run in an async context\n# result = await outer_option()\n# assert result == Some(42)  # 40 -> 41 -> 42\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Expression Compose Module using Sphinx\nDESCRIPTION: This code snippet uses Sphinx's automodule directive to automatically generate documentation for the compose module in the Expression library. It includes all members of the module in the documentation.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/compose.md#2025-04-16_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: expression.core.compose\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Procedural Function Composition\nDESCRIPTION: Shows the traditional way of composing functions in an imperative style, where functions are hard-coded together.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    return x+1\n\ndef g(x):\n    return x*2\n\n# Procedural / imperative composition. The function `h` becomes hard-coded to `f` ang `g`\ndef h(x):\n    y = f(x)\n    z = g(y)\n    return z\nh(42)\n```\n\n----------------------------------------\n\nTITLE: Implementing Imperative Composition of Result Functions\nDESCRIPTION: Creates a fetch_parse function that composes fetch and parse using imperative style with type checks. Shows a basic but less elegant way to chain operations that return Result types.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef fetch_parse(url):\n    b = fetch(url)\n    if isinstance(b, Ok):\n        val_b = b._value # <--- Don't look inside the box!!!\n        return parse(val_b)\n    else: # Must be error\n        return b\n\nresult = fetch_parse(\"http://42\")\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Traditional Nested Function Calls in Python\nDESCRIPTION: Shows the traditional way of nesting function calls in Python, which can be difficult to read when there are many operations.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport functools\nfrom builtins import filter, map\n\n\nxs = range(10)\n\nfunctools.reduce(lambda s, x: s + x, filter(lambda x: x > 50, map(lambda x: x * 10, xs)), 0)\n```\n\n----------------------------------------\n\nTITLE: Transforming Option Values with map\nDESCRIPTION: Shows how to transform the value inside a Some option using the option.map function within a pipe, preserving the option type.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import Some, option, pipe, Nothing\n\nxs = Some(42)\nys = pipe(\n    xs,\n    option.map(lambda x: x*10)\n)\nprint(ys)\n```\n\n----------------------------------------\n\nTITLE: Assigning Functions to Variables\nDESCRIPTION: Shows how to assign functions to variables in Python, demonstrating that functions are first-class objects.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmultiply = lambda a, b: a * b\n```\n\n----------------------------------------\n\nTITLE: Object-based Piping with Method Chaining\nDESCRIPTION: Shows how Expression objects provide a pipe method for dot-chaining operations. This example uses the Option type to demonstrate piping on objects rather than standalone values.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import Option, Some\n\n\nv = Some(1)\nfn2: Callable[[Option[int]], Option[int]] = lambda x: x.map(lambda y: y + 1)\ngn2: Callable[[Option[int]], Option[int]] = lambda x: x.map(lambda y: y * 2)\n\nassert v.pipe(fn2, gn2) == gn2(fn2(v))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Falsy Values in Python\nDESCRIPTION: Lists various falsy values in Python that evaluate to False in conditional statements, including None, 0, empty lists, dictionaries, tuples, and strings.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nassert not None\nassert not 0\nassert not []\nassert not {}\nassert not ()\nassert not \"\"\n```\n\n----------------------------------------\n\nTITLE: Using Pipe for Composing Observables in Python\nDESCRIPTION: This code demonstrates the use of a 'pipe' function to compose Observable operations, creating a sequence of 10 values from an infinite sequence.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/containers.md#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef pipe(arg, *fns):\n    for fn in fns:\n        arg = fn(arg)\n    return arg\n\n\nobservable = pipe(\n    infinite(),  # infinite sequence of values\n    take(10)     # take the first 10\n)\n\nobservable(observer)\n```\n\n----------------------------------------\n\nTITLE: Assigning Regular Functions to Variables\nDESCRIPTION: Demonstrates how to define a regular function and then assign it to a variable to use elsewhere.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef add(a, b):\n    return a + b\n\nadding = add\n```\n\n----------------------------------------\n\nTITLE: Using the Fetch Function with Result Type\nDESCRIPTION: Demonstrates calling the fetch function and printing the Result value, showing how Result types can be used in practice.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nresult = fetch(\"http://42\")\n\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Expression Module and Type Usage Example\nDESCRIPTION: Demonstrates the difference between module (lowercase) and type (uppercase) naming conventions in Expression compared to F#.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> from expression import Option, option\n>>> Option\n<class'expression.core.option.Option'>\n>>> option\n<module 'expression.core.option' from '/Users/dbrattli/Developer/Github/Expression/expression/core/option.py'>\n```\n\n----------------------------------------\n\nTITLE: Traditional Function Implementation in Python\nDESCRIPTION: Shows traditional implementation of mathematical functions including Pythagorean theorem calculation with direct return values.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/continuations.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport math\n\ndef add(a, b):\n    return a + b\n\ndef square(x):\n    return x * x\n\ndef sqrt(x):\n    return math.sqrt(x)\n\ndef pythagoras(a, b):\n    return sqrt(add(square(a), square(b)))\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Functions in Python\nDESCRIPTION: A simple example showing how to define a basic function in Python that adds two numbers and returns the result.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef add(a, b):\n    return a + b\n\nadd(10, 20)\n```\n\n----------------------------------------\n\nTITLE: Safe Division with Zero Divisor\nDESCRIPTION: Demonstrates using the safe division function with a zero divisor, returning Nothing instead of throwing an exception.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndivide(10, 0)\n```\n\n----------------------------------------\n\nTITLE: Importing Required Types for Data Modelling in Python\nDESCRIPTION: This snippet imports necessary types and functions from the standard library and the Expression package to enable data modelling with tagged unions and data classes.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/data_modelling.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Generic, Tuple, TypeVar, final\n\nfrom expression import case, tag, tagged_union\n\n_T = TypeVar(\"_T\")\n```\n\n----------------------------------------\n\nTITLE: Alpha Conversion Example in Python\nDESCRIPTION: Shows alpha conversion concept where bound variables can be renamed while maintaining equivalent functionality.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/lambda_calculus.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n(lambda x: x)(42) == (lambda y: y)(42) # Renaming\n```\n\n----------------------------------------\n\nTITLE: Error When Dereferencing None Value\nDESCRIPTION: Shows the error that occurs when attempting to call a method on a None value, which results in a NameError exception.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nxs.run()\n```\n\n----------------------------------------\n\nTITLE: Beta Reduction Example in Python\nDESCRIPTION: Demonstrates beta reduction where a function is applied to an expression to calculate a result.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/lambda_calculus.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n(lambda n: n*2)(7) == 7*2\n```\n\n----------------------------------------\n\nTITLE: Creating Functions Dynamically with eval\nDESCRIPTION: Shows how to create functions dynamically at runtime using eval, with a warning about security risks.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nadd_10 = eval(\"lambda x: x+10\")\nadd_10(20)\n```\n\n----------------------------------------\n\nTITLE: Using Option-Returning Functions with Negative Input\nDESCRIPTION: Demonstrates calling an option-returning function with a negative value, resulting in Nothing.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nkeep_positive(-1)\n```\n\n----------------------------------------\n\nTITLE: Installing Expression Package with pip\nDESCRIPTION: Commands for installing the Expression library from PyPI. The basic installation includes the core library, while an additional command installs Pydantic v2 support.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n> pip install expression\n```\n\nLANGUAGE: console\nCODE:\n```\n> pip install expression[pydantic]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pull Collections in Python\nDESCRIPTION: This code shows how to use pull collections in Python, specifically demonstrating the usage of an iterator to pull values from a list.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/containers.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\niterable = [1, 2, 3]\niterator = iter(iterable)  # get iterator\n\nvalue = next(iterator)\nprint(value)\n\nvalue = next(iterator)\nprint(value)\n\nvalue = next(iterator)\nprint(value)\n\n# value = next(iterator)\n```\n\n----------------------------------------\n\nTITLE: Generating Result Module Documentation with Sphinx\nDESCRIPTION: Uses Sphinx autodoc directive to generate documentation from the expression.core.result module docstrings and members. The documentation includes all members of the module.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/result.md#2025-04-16_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: expression.core.result\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Using the Parse Function with Result Type\nDESCRIPTION: Demonstrates calling the parse function and printing the Result value to show how the Result type handles successful operations.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/railway.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nresult = parse(\"42\")\n\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Generating Option Module Documentation using eval-rst Directive in RST\nDESCRIPTION: This code snippet uses the eval-rst directive to automatically generate documentation for the option module in the Expression project. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/option.md#2025-04-16_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: expression.core.option\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Importing Option Types from Expression Library\nDESCRIPTION: Shows how to import the Option type and related functions from the Expression library for functional programming.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/optional_values.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom expression import Option, option, Some, Nothing\n```\n\n----------------------------------------\n\nTITLE: Generating Map Module Documentation using Sphinx\nDESCRIPTION: This code snippet uses the eval-rst directive to automatically generate documentation for the map module in the expression.collections package. It includes documentation for all members of the module.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/map.md#2025-04-16_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: expression.collections.map\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Type Error Example in Python\nDESCRIPTION: Demonstrates a runtime type error by attempting to concatenate a string with an integer, highlighting the need for static type checking.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/tutorial/introduction.md#2025-04-16_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef run():\n    return \"abc\" + 10\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Curry Module in Python\nDESCRIPTION: This code snippet uses the Sphinx automodule directive to automatically generate documentation for all members of the expression.core.curry module. It includes all public classes, functions, and attributes in the module.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/curry.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. automodule:: expression.core.curry\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Matplotlib Visualization with Color Gradient\nDESCRIPTION: Generates a plot with multiple lines using logarithmic data, random noise, and a custom color gradient. Sets up a legend with custom line styles representing temperature variations from cold to hot.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/notebooks.ipynb#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nN = 10\ndata = [np.logspace(0, 1, 100) + np.random.randn(100) + ii for ii in range(N)]\ndata = np.array(data).T\ncmap = plt.cm.coolwarm\nrcParams['axes.prop_cycle'] = cycler(color=cmap(np.linspace(0, 1, N)))\n\n\nfrom matplotlib.lines import Line2D\ncustom_lines = [Line2D([0], [0], color=cmap(0.), lw=4),\n                Line2D([0], [0], color=cmap(.5), lw=4),\n                Line2D([0], [0], color=cmap(1.), lw=4)]\n\nfig, ax = plt.subplots(figsize=(10, 5))\nlines = ax.plot(data)\nax.legend(custom_lines, ['Cold', 'Medium', 'Hot']);\n```\n\n----------------------------------------\n\nTITLE: Documenting Try Module with Sphinx RST\nDESCRIPTION: Sphinx documentation directive that automatically generates API documentation for the expression.core.try_ module, including all members and inheritance information.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/try.md#2025-04-16_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: expression.core.try_\n    :members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Initializing Matplotlib and NumPy Environment\nDESCRIPTION: Sets up the basic Python environment by importing required libraries for data visualization including matplotlib and numpy, and enabling interactive mode.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/notebooks.ipynb#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom matplotlib import rcParams, cycler\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.ion()\n```\n\n----------------------------------------\n\nTITLE: Generating Sphinx Documentation for Expression Array Module\nDESCRIPTION: A reStructuredText directive that automatically generates API documentation from docstrings in the expression.collections.array module. This uses the Sphinx automodule feature to document all members of the module.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/array.md#2025-04-16_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: expression.collections.array\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Including Expression Core Pipe Module with Sphinx\nDESCRIPTION: This code snippet uses Sphinx's eval-rst directive to automatically generate documentation for the Expression library's pipe module. It includes all members from the expression.core.pipe module.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/pipe.md#2025-04-16_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: expression.core.pipe\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Sphinx automodule directive for expression.core.misc module\nDESCRIPTION: A Sphinx directive to automatically generate documentation for all members of the expression.core.misc module. This uses the eval-rst directive in MyST markdown to include reStructuredText-based Sphinx directives.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/misc.md#2025-04-16_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: expression.core.misc\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Block Module Documentation with Sphinx\nDESCRIPTION: Sphinx directive to automatically generate documentation for the expression.collections.block module and its members using autodoc extension.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/block.md#2025-04-16_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: expression.collections.block\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating API Documentation for Expression Mailbox Module with Sphinx\nDESCRIPTION: An RST directive that automatically generates API documentation from docstrings in the expression.core.mailbox module. This is part of a Sphinx documentation setup that documents members of the module.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/reference/mailbox.md#2025-04-16_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: expression.core.mailbox\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Initializing a Markdown File as MyST Notebook\nDESCRIPTION: A command to quickly add the necessary YAML metadata to convert a regular markdown file into a MyST Markdown notebook for Jupyter Book.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/markdown-notebooks.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\njupyter-book myst init path/to/markdownfile.md\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Note Directive in MyST Markdown\nDESCRIPTION: This snippet shows how to use a 'note' directive in MyST Markdown. Directives in MyST span multiple lines and are used to create special content blocks.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/markdown.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{note}\nHere is a note\n```\n```\n\n----------------------------------------\n\nTITLE: Executing Basic Python Code in MyST Markdown\nDESCRIPTION: A simple Python code cell that demonstrates the execution of a basic arithmetic operation in a MyST Markdown notebook.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/markdown-notebooks.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nprint(2 + 2)\n```\n\n----------------------------------------\n\nTITLE: TableOfContents Directive in Markdown Documentation\nDESCRIPTION: This code snippet uses the tableofcontents directive to automatically generate a table of contents for the documentation. This is part of the Markdown documentation structure for the Expression library.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/intro.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{tableofcontents}\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: This snippet lists the required Python packages and their versions for a project. It includes Jupyter Book, Sphinx with a minimum version of 5.0.0, Sphinx extensions for autodoc and typehints, and the Expression package with a minimum version of 5.0.0.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/docs/requirements.txt#2025-04-16_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\njupyter-book\nsphinx>=5.0.0\nsphinx-autodoc-typehints>=1.17.0\nsphinx-panels\nexpression>=5.0.0\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Hooks for Expression Development\nDESCRIPTION: Command to install pre-commit hooks for running code checks on changed files during development.\nSOURCE: https://github.com/dbrattli/Expression/blob/main/README.md#2025-04-16_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n> pre-commit install\n```"
  }
]