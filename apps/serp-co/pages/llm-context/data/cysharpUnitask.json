[
  {
    "owner": "cysharp",
    "repo": "unitask",
    "content": "TITLE: Implementing an Async Message Broker with Channel and Publish Pattern\nDESCRIPTION: Shows how to implement a publish/subscribe message broker using Channel and multicast pattern with Publish operator. This creates a reusable utility for messaging in async contexts.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_42\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AsyncMessageBroker<T> : IDisposable\n{\n    Channel<T> channel;\n\n    IConnectableUniTaskAsyncEnumerable<T> multicastSource;\n    IDisposable connection;\n\n    public AsyncMessageBroker()\n    {\n        channel = Channel.CreateSingleConsumerUnbounded<T>();\n        multicastSource = channel.Reader.ReadAllAsync().Publish();\n        connection = multicastSource.Connect(); // Publish returns IConnectableUniTaskAsyncEnumerable.\n    }\n\n    public void Publish(T value)\n    {\n        channel.Writer.TryWrite(value);\n    }\n\n    public IUniTaskAsyncEnumerable<T> Subscribe()\n    {\n        return multicastSource;\n    }\n\n    public void Dispose()\n    {\n        channel.Writer.TryComplete();\n        connection.Dispose();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic UniTask Usage in C#\nDESCRIPTION: Demonstrates the basic usage of UniTask, including awaiting Unity's AsyncObjects, handling cancellation, and using various UniTask utility methods.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Cysharp.Threading.Tasks;\n\nasync UniTask<string> DemoAsync()\n{\n    var asset = await Resources.LoadAsync<TextAsset>(\"foo\");\n    var txt = (await UnityWebRequest.Get(\"https://...\").SendWebRequest()).downloadHandler.text;\n    await SceneManager.LoadSceneAsync(\"scene2\");\n\n    var asset2 = await Resources.LoadAsync<TextAsset>(\"bar\").WithCancellation(this.GetCancellationTokenOnDestroy());\n\n    var asset3 = await Resources.LoadAsync<TextAsset>(\"baz\").ToUniTask(Progress.Create<float>(x => Debug.Log(x)));\n\n    await UniTask.DelayFrame(100); \n\n    await UniTask.Delay(TimeSpan.FromSeconds(10), ignoreTimeScale: false);\n    \n    await UniTask.Yield(PlayerLoopTiming.PreLateUpdate);\n\n    await UniTask.Yield();\n    await UniTask.NextFrame();\n\n#if UNITY_2023_1_OR_NEWER\n    await UniTask.WaitForEndOfFrame();\n#else\n    await UniTask.WaitForEndOfFrame(this);\n#endif\n\n    await UniTask.WaitForFixedUpdate();\n    \n    await UniTask.WaitUntil(() => isActive == false);\n\n    await UniTask.WaitUntilValueChanged(this, x => x.isActive);\n\n    await FooCoroutineEnumerator();\n\n    await Task.Run(() => 100);\n\n    await UniTask.SwitchToThreadPool();\n\n    await UniTask.SwitchToMainThread();\n\n    async UniTask<string> GetTextAsync(UnityWebRequest req)\n    {\n        var op = await req.SendWebRequest();\n        return op.downloadHandler.text;\n    }\n\n    var task1 = GetTextAsync(UnityWebRequest.Get(\"http://google.com\"));\n    var task2 = GetTextAsync(UnityWebRequest.Get(\"http://bing.com\"));\n    var task3 = GetTextAsync(UnityWebRequest.Get(\"http://yahoo.com\"));\n\n    var (google, bing, yahoo) = await UniTask.WhenAll(task1, task2, task3);\n\n    var (google2, bing2, yahoo2) = await (task1, task2, task3);\n\n    return (asset as TextAsset)?.text ?? throw new InvalidOperationException(\"Asset not found\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IProgress Interface for Efficient Progress Reporting in Unity C#\nDESCRIPTION: Demonstrates how to implement the IProgress interface in a MonoBehaviour for more efficient progress reporting without lambda allocations. It shows how to use the interface with UnityWebRequest and UniTask.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Foo : MonoBehaviour, IProgress<float>\n{\n    public void Report(float value)\n    {\n        UnityEngine.Debug.Log(value);\n    }\n\n    public async UniTaskVoid WebRequest()\n    {\n        var request = await UnityWebRequest.Get(\"http://google.co.jp\")\n            .SendWebRequest()\n            .ToUniTask(progress: this); // pass this\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Progress Reporting with UniTask in Unity C#\nDESCRIPTION: Shows how to use UniTask's Progress class for efficient progress reporting in async operations. It demonstrates creating a progress callback and using it with UnityWebRequest.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar progress = Progress.Create<float>(x => Debug.Log(x));\n\nvar request = await UnityWebRequest.Get(\"http://google.co.jp\")\n    .SendWebRequest()\n    .ToUniTask(progress: progress);\n```\n\n----------------------------------------\n\nTITLE: UniTask WhenAll Example in C#\nDESCRIPTION: Shows how to use UniTask.WhenAll for parallel asynchronous operations, demonstrating the ability to deconstruct results into value tuples.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic async UniTaskVoid LoadManyAsync()\n{\n    var (a, b, c) = await UniTask.WhenAll(\n        LoadAsSprite(\"foo\"),\n        LoadAsSprite(\"bar\"),\n        LoadAsSprite(\"baz\"));\n}\n\nasync UniTask<Sprite> LoadAsSprite(string path)\n{\n    var resource = await Resources.LoadAsync<Sprite>(path);\n    return (resource as Sprite);\n}\n```\n\n----------------------------------------\n\nTITLE: Cancellation Handling with UniTask in C#\nDESCRIPTION: Shows how to handle cancellation in UniTask operations using CancellationTokenSource and WithCancellation extension method.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar cts = new CancellationTokenSource();\n\ncancelButton.onClick.AddListener(() =>\n{\n    cts.Cancel();\n});\n\nawait UnityWebRequest.Get(\"http://google.co.jp\").SendWebRequest().WithCancellation(cts.Token);\n\nawait UniTask.DelayFrame(1000, cancellationToken: cts.Token);\n```\n\n----------------------------------------\n\nTITLE: Using ForEachAsync with AsyncEnumerable in C# 7.3\nDESCRIPTION: Shows how to use UniTaskAsyncEnumerable.EveryUpdate with ForEachAsync method for C# 7.3 environments to create an asynchronous update loop with cancellation support.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\n// C# 7.3(Unity 2018.3~)\nawait UniTaskAsyncEnumerable.EveryUpdate().ForEachAsync(_ =>\n{\n    Debug.Log(\"Update() \" + Time.frameCount);\n}, token);\n```\n\n----------------------------------------\n\nTITLE: Propagating CancellationToken through Async Methods in Unity C#\nDESCRIPTION: Shows how to pass a CancellationToken through multiple async methods, ensuring proper cancellation propagation from the root to the end of the async chain.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nawait FooAsync(this.GetCancellationTokenOnDestroy());\n\n// ---\n\nasync UniTask FooAsync(CancellationToken cancellationToken)\n{\n    await BarAsync(cancellationToken);\n}\n\nasync UniTask BarAsync(CancellationToken cancellationToken)\n{\n    await UniTask.Delay(TimeSpan.FromSeconds(3), cancellationToken);\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Cancellation Sources in UniTask\nDESCRIPTION: Demonstrates how to combine multiple cancellation sources, including a timeout and a manual cancellation, using CancellationTokenSource.CreateLinkedTokenSource. It shows how to handle different cancellation scenarios.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar cancelToken = new CancellationTokenSource();\ncancelButton.onClick.AddListener(() =>\n{\n    cancelToken.Cancel(); // cancel from button click.\n});\n\nvar timeoutToken = new CancellationTokenSource();\ntimeoutToken.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 5sec timeout.\n\ntry\n{\n    // combine token\n    var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancelToken.Token, timeoutToken.Token);\n\n    await UnityWebRequest.Get(\"http://foo\").SendWebRequest().WithCancellation(linkedTokenSource.Token);\n}\ncatch (OperationCanceledException ex)\n{\n    if (timeoutToken.IsCancellationRequested)\n    {\n        UnityEngine.Debug.Log(\"Timeout.\");\n    }\n    else if (cancelToken.IsCancellationRequested)\n    {\n        UnityEngine.Debug.Log(\"Cancel clicked.\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: UniTaskCompletionSource Usage in C#\nDESCRIPTION: Demonstrates how to use UniTaskCompletionSource to convert callback-based operations to UniTask-based async operations.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic UniTask<int> WrapByUniTaskCompletionSource()\n{\n    var utcs = new UniTaskCompletionSource<int>();\n\n    // when complete, call utcs.TrySetResult();\n    // when failed, call utcs.TrySetException();\n    // when cancel, call utcs.TrySetCanceled();\n\n    return utcs.Task; //return UniTask<int>\n}\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Async Methods with UniTask in C#\nDESCRIPTION: Shows how to use UniTask.ToCoroutine to bridge async/await to coroutines for unit testing async methods.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README_CN.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[UnityTest]\npublic IEnumerator DelayIgnore() => UniTask.ToCoroutine(async () =>\n{\n    var time = Time.realtimeSinceStartup;\n\n    Time.timeScale = 0.5f;\n    try\n    {\n        await UniTask.Delay(TimeSpan.FromSeconds(3), ignoreTimeScale: true);\n\n        var elapsed = Time.realtimeSinceStartup - time;\n        Assert.AreEqual(3, (int)Math.Round(TimeSpan.FromSeconds(elapsed).TotalSeconds, MidpointRounding.ToEven));\n    }\n    finally\n    {\n        Time.timeScale = 1.0f;\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CancellationToken with GetCancellationTokenOnDestroy in Unity C#\nDESCRIPTION: Demonstrates how to create a CancellationToken using the GetCancellationTokenOnDestroy extension method for MonoBehaviour. This token's lifecycle is tied to the GameObject's destruction.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nawait UniTask.DelayFrame(1000, cancellationToken: this.GetCancellationTokenOnDestroy());\n```\n\n----------------------------------------\n\nTITLE: Using UniTask.WhenEach for Handling Multiple Tasks\nDESCRIPTION: Demonstrates how to use UniTask.WhenEach to await multiple tasks and process their results as they complete. Similar to .NET 9's Task.WhenEach functionality.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\nawait foreach (var result in UniTask.WhenEach(task1, task2, task3))\n{\n    // The result is of type WhenEachResult<T>.\n    // It contains either `T Result` or `Exception Exception`.\n    // You can check `IsCompletedSuccessfully` or `IsFaulted` to determine whether to access `.Result` or `.Exception`.\n    // If you want to throw an exception when `IsFaulted` and retrieve the result when successful, use `GetResult()`.\n    Debug.Log(result.GetResult());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom CancellationToken Lifecycle in Unity C#\nDESCRIPTION: Demonstrates how to implement a custom lifecycle for CancellationTokens in a MonoBehaviour, separate from the default CancellationTokenOnDestroy. It shows handling for OnEnable, OnDisable, and OnDestroy events.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyBehaviour : MonoBehaviour\n{\n    CancellationTokenSource disableCancellation = new CancellationTokenSource();\n    CancellationTokenSource destroyCancellation = new CancellationTokenSource();\n\n    private void OnEnable()\n    {\n        if (disableCancellation != null)\n        {\n            disableCancellation.Dispose();\n        }\n        disableCancellation = new CancellationTokenSource();\n    }\n\n    private void OnDisable()\n    {\n        disableCancellation.Cancel();\n    }\n\n    private void OnDestroy()\n    {\n        destroyCancellation.Cancel();\n        destroyCancellation.Dispose();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout with CancellationTokenSource in UniTask\nDESCRIPTION: Shows how to implement a timeout using CancellationTokenSource.CancelAfterSlim and pass the resulting CancellationToken to async methods. It also demonstrates how to handle the timeout exception.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar cts = new CancellationTokenSource();\ncts.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 5sec timeout.\n\ntry\n{\n    await UnityWebRequest.Get(\"http://foo\").SendWebRequest().WithCancellation(cts.Token);\n}\ncatch (OperationCanceledException ex)\n{\n    if (ex.CancellationToken == cts.Token)\n    {\n        UnityEngine.Debug.Log(\"Timeout\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using TimeoutController for Optimized Timeout Handling in UniTask\nDESCRIPTION: Demonstrates the use of UniTask's TimeoutController to optimize timeout handling and reduce allocations when repeatedly calling async methods with timeouts. It shows how to set up, use, and reset the TimeoutController.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nTimeoutController timeoutController = new TimeoutController(); // setup to field for reuse.\n\nasync UniTask FooAsync()\n{\n    try\n    {\n        // you can pass timeoutController.Timeout(TimeSpan) to cancellationToken.\n        await UnityWebRequest.Get(\"http://foo\").SendWebRequest()\n            .WithCancellation(timeoutController.Timeout(TimeSpan.FromSeconds(5)));\n        timeoutController.Reset(); // call Reset(Stop timeout timer and ready for reuse) when succeed.\n    }\n    catch (OperationCanceledException ex)\n    {\n        if (timeoutController.IsTimeout())\n        {\n            UnityEngine.Debug.Log(\"timeout\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using DOTween with UniTask\nDESCRIPTION: Demonstrates how to use DOTween animations with UniTask for both sequential and parallel execution with cancellation support.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\n// sequential\nawait transform.DOMoveX(2, 10);\nawait transform.DOMoveZ(5, 20);\n\n// parallel with cancellation\nvar ct = this.GetCancellationTokenOnDestroy();\n\nawait UniTask.WhenAll(\n    transform.DOMoveX(10, 3).WithCancellation(ct),\n```\n\n----------------------------------------\n\nTITLE: Using UniTaskVoid in MonoBehaviour Start Method\nDESCRIPTION: Shows how to use UniTaskVoid in a MonoBehaviour's Start method for asynchronous initialization.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nclass Sample : MonoBehaviour\n{\n    async UniTaskVoid Start()\n    {\n        // async init code.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using UniTask.Action for Async Event Handlers\nDESCRIPTION: Demonstrates the correct way to use async lambdas with events in UniTask, avoiding async void and using UniTask.Action or UniTask.UnityAction instead.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\nAction actEvent;\nUnityAction unityEvent; // especially used in uGUI\n\n// Bad: async void\nactEvent += async () => { };\nunityEvent += async () => { };\n\n// Ok: create Action delegate by lambda\nactEvent += UniTask.Action(async () => { await UniTask.Yield(); });\nunityEvent += UniTask.UnityAction(async () => { await UniTask.Yield(); });\n```\n\n----------------------------------------\n\nTITLE: Using AsyncTriggers for MonoBehaviour Message Events\nDESCRIPTION: Shows how to use AsyncTriggers to await MonoBehaviour message events like OnCollisionEnter, converting them to awaitable async operations.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_37\n\nLANGUAGE: csharp\nCODE:\n```\nvar trigger = this.GetOnCollisionEnterAsyncHandler();\nawait trigger.OnCollisionEnterAsync();\nawait trigger.OnCollisionEnterAsync();\nawait trigger.OnCollisionEnterAsync();\n\n// every moves.\nawait this.GetAsyncMoveTrigger().ForEachAsync(axisEventData =>\n{\n});\n```\n\n----------------------------------------\n\nTITLE: Using UniTask.SuppressCancellationThrow for Performance Optimization\nDESCRIPTION: Shows how to use UniTask.SuppressCancellationThrow to avoid throwing OperationCanceledException for better performance. It returns a tuple with a boolean indicating cancellation instead of throwing an exception.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar (isCanceled, _) = await UniTask.DelayFrame(10, cancellationToken: cts.Token).SuppressCancellationThrow();\nif (isCanceled)\n{\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using AsyncReactiveProperty for Reactive Programming\nDESCRIPTION: Demonstrates AsyncReactiveProperty for reactive programming, showing how to observe value changes, bind to UI components, and wait for value updates.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_38\n\nLANGUAGE: csharp\nCODE:\n```\nvar rp = new AsyncReactiveProperty<int>(99);\n\n// AsyncReactiveProperty itself is IUniTaskAsyncEnumerable, you can query by LINQ\nrp.ForEachAsync(x =>\n{\n    Debug.Log(x);\n}, this.GetCancellationTokenOnDestroy()).Forget();\n\nrp.Value = 10; // push 10 to all subscriber\nrp.Value = 11; // push 11 to all subscriber\n\n// WithoutCurrent ignore initial value\n// BindTo bind stream value to unity components.\nrp.WithoutCurrent().BindTo(this.textComponent);\n\nawait rp.WaitAsync(); // wait until next value set\n\n// also exists ToReadOnlyAsyncReactiveProperty\nvar rp2 = new AsyncReactiveProperty<int>(99);\nvar rorp = rp.CombineLatest(rp2, (x, y) => (x, y)).ToReadOnlyAsyncReactiveProperty(CancellationToken.None);\n```\n\n----------------------------------------\n\nTITLE: Using AsyncReactiveProperty in C#\nDESCRIPTION: Demonstrates the usage of AsyncReactiveProperty, including waiting for values and combining properties.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README_CN.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nawait rp.WaitAsync(); // 一直等待，直到下一个值被设置\n\n// 同样支持 ToReadOnlyAsyncReactiveProperty\nvar rp2 = new AsyncReactiveProperty<int>(99);\nvar rorp = rp.CombineLatest(rp2, (x, y) => (x, y)).ToReadOnlyAsyncReactiveProperty(CancellationToken.None);\n```\n\n----------------------------------------\n\nTITLE: Using EveryUpdate with AsyncEnumerable in C# 8.0\nDESCRIPTION: Demonstrates how to use UniTaskAsyncEnumerable.EveryUpdate with await foreach syntax in C# 8.0 to create an asynchronous update loop with cancellation support.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\n// Unity 2020.2, C# 8.0\nawait foreach (var _ in UniTaskAsyncEnumerable.EveryUpdate().WithCancellation(token))\n{\n    Debug.Log(\"Update() \" + Time.frameCount);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fire-and-Forget Async Method with UniTaskVoid\nDESCRIPTION: Shows how to create and call a fire-and-forget async method using UniTaskVoid, which is more efficient than async void for UniTask operations.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\npublic async UniTaskVoid FireAndForgetMethod()\n{\n    // do anything...\n    await UniTask.Yield();\n}\n\npublic void Caller()\n{\n    FireAndForgetMethod().Forget();\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Throwing OperationCanceledException in UniTask Async Method\nDESCRIPTION: Shows how to manually throw an OperationCanceledException to cancel behavior in an async UniTask method. This is useful for custom cancellation logic.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic async UniTask<int> FooAsync()\n{\n    await UniTask.Yield();\n    throw new OperationCanceledException();\n}\n```\n\n----------------------------------------\n\nTITLE: Using DOTween with UniTask Cancellation\nDESCRIPTION: Shows how to use DOTween's animation with UniTask's cancellation token support. This is a partial code snippet demonstrating the WithCancellation extension method for DOTween.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\ntransform.DOScale(10, 3).WithCancellation(ct));\n```\n\n----------------------------------------\n\nTITLE: Setting Immediate Cancellation for UniTask Operations\nDESCRIPTION: Demonstrates how to set the cancelImmediately flag for UniTask operations that use Unity's player loop, such as UniTask.Yield. This allows for immediate cancellation instead of waiting for the next player loop execution.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nawait UniTask.Yield(cancellationToken, cancelImmediately: true);\n```\n\n----------------------------------------\n\nTITLE: Basic Button Click Awaiting with OnClickAsync\nDESCRIPTION: Shows a simple way to await for three button clicks using OnClickAsync, managing lifetime through button's GetCancellationTokenOnDestroy method.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\nasync UniTask TripleClick()\n{\n    // In default, used button.GetCancellationTokenOnDestroy to manage lieftime of async\n    await button.OnClickAsync();\n    await button.OnClickAsync();\n    await button.OnClickAsync();\n    Debug.Log(\"Three times clicked\");\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions with Exception Filter in UniTask Async Method\nDESCRIPTION: Demonstrates how to use an exception filter to handle exceptions while still propagating OperationCanceledException for global cancellation handling in a UniTask async method.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic async UniTask<int> BarAsync()\n{\n    try\n    {\n        var x = await FooAsync();\n        return x * 2;\n    }\n    catch (Exception ex) when (!(ex is OperationCanceledException)) // when (ex is not OperationCanceledException) at C# 9.0\n    {\n        return -1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Async Events with ForEachAwaitAsync in C#\nDESCRIPTION: Shows how to handle async events using ForEachAwaitAsync, which may cause data overflow for push-type events like button clicks.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README_CN.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// 在3s延迟结束前，无法获取 event\nawait button.OnClickAsAsyncEnumerable().ForEachAwaitAsync(async x =>\n{\n    await UniTask.Delay(TimeSpan.FromSeconds(3));\n});\n```\n\n----------------------------------------\n\nTITLE: Efficient Button Click Handling with AsyncEventHandler\nDESCRIPTION: Demonstrates a more efficient approach to awaiting button clicks by getting and disposing an AsyncClickEventHandler, reducing overhead for multiple sequential awaits.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_34\n\nLANGUAGE: csharp\nCODE:\n```\n// more efficient way\nasync UniTask TripleClick()\n{\n    using (var handler = button.GetAsyncClickEventHandler())\n    {\n        await handler.OnClickAsync();\n        await handler.OnClickAsync();\n        await handler.OnClickAsync();\n        Debug.Log(\"Three times clicked\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Queue to Preserve Events During Async Processing\nDESCRIPTION: Shows how to use the Queue method to queue events that occur during asynchronous processing, ensuring no events are missed even with long-running operations.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_40\n\nLANGUAGE: csharp\nCODE:\n```\n// queued message in asynchronous processing\nawait button.OnClickAsAsyncEnumerable().Queue().ForEachAwaitAsync(async x =>\n{\n    await UniTask.Delay(TimeSpan.FromSeconds(3));\n});\n```\n\n----------------------------------------\n\nTITLE: Queueing Events During Async Processing in C#\nDESCRIPTION: Demonstrates how to queue events during async processing using the Queue() method.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README_CN.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// 异步处理中对 message 进行排队\nawait button.OnClickAsAsyncEnumerable().Queue().ForEachAwaitAsync(async x =>\n{\n    await UniTask.Delay(TimeSpan.FromSeconds(3));\n});\n```\n\n----------------------------------------\n\nTITLE: Using LINQ with Button Clicks as AsyncEnumerable\nDESCRIPTION: Shows how to apply LINQ operations like Where to button click events converted to an asynchronous stream, filtering to react only to every other click.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\nawait okButton.OnClickAsAsyncEnumerable().Where((x, i) => i % 2 == 0).ForEachAsync(_ =>\n{\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing UniTask PlayerLoop in Unity\nDESCRIPTION: Shows how to initialize the UniTask PlayerLoop before the scene loads to ensure it's available for use in other initialization methods.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]\npublic static void InitUniTaskLoop()\n{\n    var loop = PlayerLoop.GetCurrentPlayerLoop();\n    Cysharp.Threading.Tasks.PlayerLoopHelper.Initialize(ref loop);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Async Iterator with UniTaskAsyncEnumerable.Create\nDESCRIPTION: Shows how to create a custom async iterator using UniTaskAsyncEnumerable.Create with an IAsyncWriter interface that provides YieldAsync method as an alternative to yield return.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\n// UniTaskAsyncEnumerable.Create and use `await writer.YieldAsync` instead of `yield return`.\npublic IUniTaskAsyncEnumerable<int> MyEveryUpdate()\n{\n    // writer(IAsyncWriter<T>) has `YieldAsync(value)` method.\n    return UniTaskAsyncEnumerable.Create<int>(async (writer, token) =>\n    {\n        var frameCount = 0;\n        await UniTask.Yield();\n        while (!token.IsCancellationRequested)\n        {\n            await writer.YieldAsync(frameCount++); // instead of `yield return`\n            await UniTask.Yield();\n        }\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Using LINQ Take and Last with OnClickAsAsyncEnumerable\nDESCRIPTION: Shows how to use async LINQ operators Take and Last to wait for exactly three button clicks, completing after the third click is detected.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\n// use async LINQ\nasync UniTask TripleClick(CancellationToken token)\n{\n    await button.OnClickAsAsyncEnumerable().Take(3).Last();\n    Debug.Log(\"Three times clicked\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using LINQ Take and ForEachAsync with OnClickAsAsyncEnumerable\nDESCRIPTION: Demonstrates using ForEachAsync with Take to execute code on each of three button clicks and then run completion code after all clicks are processed.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_36\n\nLANGUAGE: csharp\nCODE:\n```\n// use async LINQ2\nasync UniTask TripleClick(CancellationToken token)\n{\n    await button.OnClickAsAsyncEnumerable().Take(3).ForEachAsync(_ =>\n    {\n        Debug.Log(\"Every clicked\");\n    });\n    Debug.Log(\"Three times clicked, complete.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using Subscribe for Fire-and-Forget Event Handling\nDESCRIPTION: Demonstrates how to use the Subscribe method for fire-and-forget style event handling with LINQ operators, allowing for processing events without awaiting them.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\nokButton.OnClickAsAsyncEnumerable().Where((x, i) => i % 2 == 0).Subscribe(_ =>\n{\n});\n```\n\n----------------------------------------\n\nTITLE: Using Subscribe for Fire-and-Forget Style in C#\nDESCRIPTION: Shows how to use the Subscribe method for a fire-and-forget style of handling async events.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README_CN.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nbutton.OnClickAsAsyncEnumerable().Subscribe(async x =>\n{\n    await UniTask.Delay(TimeSpan.FromSeconds(3));\n});\n```\n\n----------------------------------------\n\nTITLE: Using Subscribe for Fire-and-Forget Style with Async Operations\nDESCRIPTION: Demonstrates using Subscribe for fire-and-forget style event handling with async operations, allowing events to be processed without blocking or missing subsequent events.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_41\n\nLANGUAGE: csharp\nCODE:\n```\nbutton.OnClickAsAsyncEnumerable().Subscribe(async x =>\n{\n    await UniTask.Delay(TimeSpan.FromSeconds(3));\n});\n```\n\n----------------------------------------\n\nTITLE: Three Overloads for LINQ Methods with Func Arguments\nDESCRIPTION: Shows the three overload patterns available for LINQ methods that take function arguments in UniTaskAsyncEnumerable: standard, await, and await with cancellation.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_30\n\nLANGUAGE: csharp\nCODE:\n```\nSelect(Func<T, TR> selector)\nSelectAwait(Func<T, UniTask<TR>> selector)\nSelectAwaitWithCancellation(Func<T, CancellationToken, UniTask<TR>> selector)\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncMessageBroker with Channel in C#\nDESCRIPTION: Demonstrates how to implement a publish/subscribe tool using Channel and IUniTaskAsyncEnumerable.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README_CN.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AsyncMessageBroker<T> : IDisposable\n{\n    Channel<T> channel;\n\n    IConnectableUniTaskAsyncEnumerable<T> multicastSource;\n    IDisposable connection;\n\n    public AsyncMessageBroker()\n    {\n        channel = Channel.CreateSingleConsumerUnbounded<T>();\n        multicastSource = channel.Reader.ReadAllAsync().Publish();\n        connection = multicastSource.Connect(); // Publish returns IConnectableUniTaskAsyncEnumerable.\n    }\n\n    public void Publish(T value)\n    {\n        channel.Writer.TryWrite(value);\n    }\n\n    public IUniTaskAsyncEnumerable<T> Subscribe()\n    {\n        return multicastSource;\n    }\n\n    public void Dispose()\n    {\n        channel.Writer.TryComplete();\n        connection.Dispose();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using UniTask with ValueTask in .NET Core\nDESCRIPTION: Demonstrates how to use UniTask internally while providing ValueTask as an external API in .NET Core applications. The pattern allows for zero-allocation async/await operations by leveraging static local functions.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_46\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ZeroAllocAsyncAwaitInDotNetCore\n{\n    public ValueTask<int> DoAsync(int x, int y)\n    {\n        return Core(this, x, y);\n\n        static async UniTask<int> Core(ZeroAllocAsyncAwaitInDotNetCore self, int x, int y)\n        {\n            // do anything...\n            await Task.Delay(TimeSpan.FromSeconds(x + y));\n            await UniTask.Yield();\n\n            return 10;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Async Methods with UniTask in Unity\nDESCRIPTION: Demonstrates how to use UniTask.ToCoroutine to test async methods in Unity's Test Runner. This example tests a delay function with time scale changes.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_43\n\nLANGUAGE: csharp\nCODE:\n```\n[UnityTest]\npublic IEnumerator DelayIgnore() => UniTask.ToCoroutine(async () =>\n{\n    var time = Time.realtimeSinceStartup;\n\n    Time.timeScale = 0.5f;\n    try\n    {\n        await UniTask.Delay(TimeSpan.FromSeconds(3), ignoreTimeScale: true);\n\n        var elapsed = Time.realtimeSinceStartup - time;\n        Assert.AreEqual(3, (int)Math.Round(TimeSpan.FromSeconds(elapsed).TotalSeconds, MidpointRounding.ToEven));\n    }\n    finally\n    {\n        Time.timeScale = 1.0f;\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Optimizing UniTask PlayerLoop Injection\nDESCRIPTION: Demonstrates how to optimize the UniTask PlayerLoop by injecting only the necessary timings, reducing overhead.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\nvar loop = PlayerLoop.GetCurrentPlayerLoop();\nPlayerLoopHelper.Initialize(ref loop, InjectPlayerLoopTimings.Minimum); // minimum is Update | FixedUpdate | LastPostLateUpdate\n```\n\n----------------------------------------\n\nTITLE: Showing Limitation of Pull-Based AsyncEnumerable with ForEachAwaitAsync\nDESCRIPTION: Demonstrates a limitation of pull-based AsyncEnumerable where events during async processing might be missed when using ForEachAwaitAsync with long-running operations.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_39\n\nLANGUAGE: csharp\nCODE:\n```\n// can not get click event during 3 seconds complete.\nawait button.OnClickAsAsyncEnumerable().ForEachAwaitAsync(async x =>\n{\n    await UniTask.Delay(TimeSpan.FromSeconds(3));\n});\n```\n\n----------------------------------------\n\nTITLE: Re-initializing UniTask PlayerLoop after ECS Initialization\nDESCRIPTION: Demonstrates how to re-initialize the UniTask PlayerLoop after the Entity Component System (ECS) has initialized, ensuring UniTask continues to work correctly.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nvar playerLoop = ScriptBehaviourUpdateOrder.CurrentPlayerLoop;\n\nPlayerLoopHelper.Initialize(ref playerLoop);\n```\n\n----------------------------------------\n\nTITLE: Diagnosing UniTask PlayerLoop Status\nDESCRIPTION: Shows how to check if the UniTask PlayerLoop is ready and how to dump the current PlayerLoop information to the console for debugging purposes.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Start()\n{\n    UnityEngine.Debug.Log(\"UniTaskPlayerLoop ready? \" + PlayerLoopHelper.IsInjectedUniTaskPlayerLoop());\n    PlayerLoopHelper.DumpCurrentPlayerLoop();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Async Iterator with IAsyncEnumerable (C# 8.0)\nDESCRIPTION: Demonstrates how to create a custom async iterator using C# 8.0's IAsyncEnumerable and async yield return syntax. This approach is not recommended for use with UniTask.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\n// IAsyncEnumerable, C# 8.0 version of async iterator. ( do not use this style, IAsyncEnumerable is not controled in UniTask).\npublic async IAsyncEnumerable<int> MyEveryUpdate([EnumeratorCancellation]CancellationToken cancelationToken = default)\n{\n    var frameCount = 0;\n    await UniTask.Yield();\n    while (!token.IsCancellationRequested)\n    {\n        yield return frameCount++;\n        await UniTask.Yield();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ReturnToCurrentSynchronizationContext with UniTask in .NET Core\nDESCRIPTION: Shows how to use the ReturnToCurrentSynchronizationContext helper method with UniTask in .NET Core. This allows for switching to thread pool operations while ensuring return to the original synchronization context.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_47\n\nLANGUAGE: csharp\nCODE:\n```\npublic ValueTask TestAsync()\n{\n    await using (UniTask.ReturnToCurrentSynchronizationContext())\n    {\n        await UniTask.SwitchToThreadPool();\n        // do anything..\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring UniTask Pooling in Unity\nDESCRIPTION: Shows how to retrieve and log the current cache size information for UniTask's pooled objects using TaskPool.GetCacheSizeInfo.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_44\n\nLANGUAGE: csharp\nCODE:\n```\nforeach (var (type, size) in TaskPool.GetCacheSizeInfo())\n{\n    Debug.Log(type + \":\" + size);\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting UniTaskSynchronizationContext in Unity\nDESCRIPTION: Demonstrates how to replace Unity's default SynchronizationContext with UniTaskSynchronizationContext for improved performance in certain scenarios.\nSOURCE: https://github.com/cysharp/unitask/blob/master/README.md#2025-04-18_snippet_45\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SyncContextInjecter\n{\n    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]\n    public static void Inject()\n    {\n        SynchronizationContext.SetSynchronizationContext(new UniTaskSynchronizationContext());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Unity Editor Version for Project\nDESCRIPTION: This configuration specifies Unity 2022.3.39f1 (revision 4e1b0f82c39a) as the editor version for this project. This information helps ensure consistent behavior across different development environments.\nSOURCE: https://github.com/cysharp/unitask/blob/master/src/UniTask/ProjectSettings/ProjectVersion.txt#2025-04-18_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nm_EditorVersion: 2022.3.39f1\nm_EditorVersionWithRevision: 2022.3.39f1 (4e1b0f82c39a)\n```"
  }
]