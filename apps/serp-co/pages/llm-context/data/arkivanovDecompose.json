[
  {
    "owner": "arkivanov",
    "repo": "decompose",
    "content": "TITLE: Initializing Root Component for Android with Compose\nDESCRIPTION: This snippet shows how to initialize a root component for Android using Jetpack Compose and Decompose. It creates the root component in the Activity's onCreate method and sets up the Compose content.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_9\n\nLANGUAGE: kotlin\nCODE:\n```\nimport android.os.Bundle\nimport androidx.activity.compose.setContent\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Surface\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.defaultComponentContext\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Always create the root component outside Compose on the main thread\n        val root =\n            DefaultRootComponent(\n                componentContext = defaultComponentContext(),\n            )\n\n        setContent {\n            MaterialTheme {\n                Surface {\n                    RootContent(component = root, modifier = Modifier.fillMaxSize())\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Navigation with Child Stack in Kotlin\nDESCRIPTION: Shows how to implement navigation using Decompose's Child Stack, including defining configurations, creating child components, and handling navigation actions.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.router.stack.childStack\nimport com.arkivanov.decompose.router.stack.pop\nimport com.arkivanov.decompose.router.stack.popTo\nimport com.arkivanov.decompose.router.stack.push\nimport com.arkivanov.decompose.value.Value\nimport com.sample.shared.RootComponent.Child.DetailsChild\nimport com.sample.shared.RootComponent.Child.ListChild\nimport kotlinx.serialization.Serializable\n\ninterface RootComponent {\n\n    val stack: Value<ChildStack<*, Child>>\n\n    // It's possible to pop multiple screens at a time on iOS\n    fun onBackClicked(toIndex: Int)\n\n    // Defines all possible child components\n    sealed class Child {\n        class ListChild(val component: ListComponent) : Child()\n        class DetailsChild(val component: DetailsComponent) : Child()\n    }\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\n    private val navigation = StackNavigation<Config>()\n\n    override val stack: Value<ChildStack<*, RootComponent.Child>> =\n        childStack(\n            source = navigation,\n            serializer = Config.serializer(),\n            initialConfiguration = Config.List, // The initial child component is List\n            handleBackButton = true, // Automatically pop from the stack on back button presses\n            childFactory = ::child,\n        )\n\n    private fun child(config: Config, componentContext: ComponentContext): RootComponent.Child =\n        when (config) {\n            is Config.List -> ListChild(listComponent(componentContext))\n            is Config.Details -> DetailsChild(detailsComponent(componentContext, config))\n        }\n\n    private fun listComponent(componentContext: ComponentContext): ListComponent =\n        DefaultListComponent(\n            componentContext = componentContext,\n            onItemSelected = { item: String -> // Supply dependencies and callbacks\n                navigation.push(Config.Details(item = item)) // Push the details component\n            },\n        )\n\n    private fun detailsComponent(componentContext: ComponentContext, config: Config.Details): DetailsComponent =\n        DefaultDetailsComponent(\n            componentContext = componentContext,\n            item = config.item, // Supply arguments from the configuration\n            onFinished = navigation::pop, // Pop the details component\n        )\n\n    override fun onBackClicked(toIndex: Int) {\n        navigation.popTo(index = toIndex)\n    }\n\n    @Serializable // kotlinx-serialization plugin must be applied\n    private sealed interface Config {\n        @Serializable\n        data object List : Config\n\n        @Serializable\n        data class Details(val item: String) : Config\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Component in Kotlin\nDESCRIPTION: The simplest component in Decompose is just a normal Kotlin class, without any need to extend or implement library classes.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nclass RootComponent\n```\n\n----------------------------------------\n\nTITLE: Using ComponentContext in Kotlin\nDESCRIPTION: Shows how to use ComponentContext, a key concept in Decompose that provides access to lifecycle, state preservation, instance retaining, and back button handling.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\n    init {\n        lifecycle... // Access the Lifecycle\n        stateKeeper... // Access the StateKeeper\n        instanceKeeper... // Access the InstanceKeeper\n        backHandler... // Access the BackHandler\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Root Component Interface and Implementation in Kotlin\nDESCRIPTION: This example shows how to define an interface for a root component and its implementation. This approach allows for easier testing and creation of preview implementations for UI frameworks like Compose or SwiftUI.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\n\ninterface RootComponent\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n    // Some code here\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Root Component with ComponentContext in Kotlin\nDESCRIPTION: This snippet demonstrates how to create a root component class that implements the ComponentContext interface using delegation. It shows the basic structure of a component in Decompose.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\n\nclass RootComponent(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    // Some code here\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Root Component in Android with Jetpack Compose\nDESCRIPTION: This snippet demonstrates how to create a root component before starting Jetpack Compose in an Android Activity. It ensures that the root ComponentContext is created on the UI thread.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/overview.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nimport android.os.Bundle\nimport androidx.activity.compose.setContent\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.defaultComponentContext\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Create the root component before starting Compose\n        val root = DefaultRootComponent(componentContext = defaultComponentContext())\n\n        // Start Compose\n        setContent {\n            // The rest of the code\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Observable State with Value in Kotlin\nDESCRIPTION: Demonstrates how to use Decompose's Value for creating observable state in a component, which integrates well with various UI frameworks.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.value.MutableValue\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.sample.shared.ListComponent.Model\n\ninterface ListComponent {\n    val model: Value<Model>\n\n    fun onItemClicked(item: String)\n\n    data class Model(\n        val items: List<String>,\n    )\n}\n\nclass DefaultListComponent(\n    componentContext: ComponentContext,\n    private val onItemSelected: (item: String) -> Unit,\n) : ListComponent {\n    override val model: Value<Model> =\n        MutableValue(Model(items = List(100) { \"Item $it\" }))\n\n    override fun onItemClicked(item: String) {\n        onItemSelected(item)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Child Component With Lifecycle Control in Kotlin\nDESCRIPTION: Example demonstrating how to create a permanent child component with custom lifecycle control. A LifecycleRegistry is used to manually control the child component's lifecycle states, with methods to resume and stop the component.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/child-components.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.childContext\nimport com.arkivanov.essenty.lifecycle.LifecycleRegistry\nimport com.arkivanov.essenty.lifecycle.resume\nimport com.arkivanov.essenty.lifecycle.stop\n\nclass SomeParent(componentContext: ComponentContext) : ComponentContext by componentContext {\n\n    // Never destroy the lifecycle of a permanent child component! \n    private val counterLifecycle = LifecycleRegistry()\n\n    val counter: Counter = Counter(childContext(key = \"Counter\", lifecycle = counterLifecycle))\n\n    private fun resumeCounter() {\n        counterLifecycle.resume()\n    }\n\n    private fun stopCounter() {\n        counterLifecycle.stop()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Root ComponentContext in Android Fragment\nDESCRIPTION: This example shows how to create a root ComponentContext in an Android Fragment using the defaultComponentContext() extension function with an OnBackPressedDispatcher.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/overview.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nimport android.os.Bundle\nimport androidx.fragment.app.Fragment\nimport com.arkivanov.decompose.defaultComponentContext\n\nclass SomeFragment : Fragment() {\n    private lateinit var root: RootComponent\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        root =\n            DefaultRootComponent(\n                componentContext = defaultComponentContext(\n                    onBackPressedDispatcher = requireActivity().onBackPressedDispatcher\n                )\n            )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Root Component with Child Stack Navigation in Decompose\nDESCRIPTION: Demonstrates the setup of a Root component that manages a stack of child components using Decompose's ChildStack. Includes configuration serialization, navigation handling, and component creation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/overview.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.router.stack.childStack\nimport com.arkivanov.decompose.router.stack.pop\nimport com.arkivanov.decompose.router.stack.push\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.sample.shared.RootComponent.Child.DetailsChild\nimport com.arkivanov.sample.shared.RootComponent.Child.ListChild\nimport kotlinx.serialization.Serializable\n\ninterface RootComponent {\n\n    val childStack: Value<ChildStack<*, Child>>\n\n    sealed class Child {\n        class ListChild(val component: ItemListComponent) : Child()\n        class DetailsChild(val component: ItemDetailsComponent) : Child()\n    }\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n    private val navigation = StackNavigation<Config>()\n\n    override val childStack: Value<ChildStack<*, RootComponent.Child>> =\n        childStack(\n            source = navigation,\n            serializer = Config.serializer(), // Or null to disable navigation state saving \n            initialConfiguration = Config.List,\n            handleBackButton = true, // Pop the back stack on back button press\n            childFactory = ::createChild,\n        )\n\n    private fun createChild(config: Config, componentContext: ComponentContext): RootComponent.Child =\n        when (config) {\n            is Config.List -> ListChild(itemList(componentContext))\n            is Config.Details -> DetailsChild(itemDetails(componentContext, config))\n        }\n\n    private fun itemList(componentContext: ComponentContext): ItemListComponent =\n        DefaultItemListComponent(\n            componentContext = componentContext,\n            onItemSelected = { navigation.push(Config.Details(itemId = it)) }\n        )\n\n    private fun itemDetails(componentContext: ComponentContext, config: Config.Details): ItemDetailsComponent =\n        DefaultItemDetailsComponent(\n            componentContext = componentContext,\n            itemId = config.itemId,\n            onFinished = { navigation.pop() }\n        )\n\n    @Serializable // kotlinx-serialization plugin must be applied\n    private sealed class Config {\n        @Serializable\n        data object List : Config()\n\n        @Serializable\n        data class Details(val itemId: Long) : Config()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting a Component Interface in Kotlin\nDESCRIPTION: Demonstrates how to extract an interface for a component, which is useful for creating test doubles and fake implementations for UI previews.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\ninterface RootComponent\n\nclass DefaultRootComponent : RootComponent\n```\n\n----------------------------------------\n\nTITLE: Using Custom Stack Navigation in a Photo Gallery Component with Decompose in Kotlin\nDESCRIPTION: This snippet demonstrates how to use the custom stack navigation in a photo gallery component. It includes a PhotoComponent, a GalleryComponent interface, and a DefaultGalleryComponent implementation that uses the custom stack navigation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/children/overview.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.children.SimpleNavigation\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\n\nclass PhotoComponent(url: String) {\n    // Some code here\n}\n\ninterface GalleryComponent {\n    val stack: Value<Stack<*, PhotoComponent>>\n}\n\nclass DefaultGalleryComponent(\n    componentContext: ComponentContext,\n) : GalleryComponent, ComponentContext by componentContext {\n\n    private val nav = SimpleNavigation<StackNavEvent<Config>>()\n\n    override val stack: Value<Stack<*, PhotoComponent>> =\n        stack(\n            source = nav,\n            serializer = Config.serializer(),\n            childFactory = { config, ctx -> PhotoComponent(url = config.url) },\n        )\n\n    private fun pushPhoto(url: String) {\n        nav.navigate { it + Config(url) }\n    }\n\n    private fun popPhoto() {\n        nav.navigate { it.dropLast(1) }\n    }\n\n    @Serializable\n    private data class Config(val url: String)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Result Passing Between Components in Decompose\nDESCRIPTION: Shows how to deliver results from one component to another when navigating back, using callbacks and the navigation stack in Decompose.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/overview.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\ninterface ItemListComponent {\n\n    fun onItemClicked(id: Long)\n\n    fun onItemDeleted(id: Long)\n}\n\nclass DefaultItemListComponent(\n    componentContext: ComponentContext,\n    private val onItemSelected: (id: Long) -> Unit,\n) : ItemListComponent, ComponentContext by componentContext {\n\n    override fun onItemClicked(id: Long) {\n        onItemSelected(id)\n    }\n\n    override fun onItemDeleted(id: Long) {\n        // TODO: Handle item deleted\n    }\n}\n\ninterface ItemDetailsComponent {\n\n    fun onDeleteClicked()\n}\n\nclass DefaultItemDetailsComponent(\n    componentContext: ComponentContext,\n    private val itemId: Long,\n    private val onDeleted: (itemId: Long) -> Unit\n) : ItemDetailsComponent, ComponentContext by componentContext {\n\n    override fun onDeleteClicked() {\n        // TODO: Delete the item\n        onDeleted(itemId)\n    }\n}\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.pop\nimport com.arkivanov.decompose.router.stack.push\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n    // Omitted code\n\n    private fun itemList(componentContext: ComponentContext): ItemListComponent =\n        DefaultItemListComponent(\n            componentContext = componentContext,\n            onItemSelected = { navigation.push(Config.Details(itemId = it)) }\n        )\n\n    private fun itemDetails(componentContext: ComponentContext, config: Config.Details): ItemDetailsComponent =\n        DefaultItemDetailsComponent(\n            componentContext = componentContext,\n            itemId = config.itemId,\n            onDeleted = { itemId ->\n                navigation.pop { // Pop ItemDetailsComponent\n                    // Deliver the result to ItemList component\n                    (stack.active.instance as? ListChild)?.component?.onItemDeleted(id = itemId)\n                }\n            }\n        )\n\n    // Omitted code\n}\n```\n\n----------------------------------------\n\nTITLE: Using Child Stack with Jetpack Compose\nDESCRIPTION: Demonstrates how to use a Decompose Child Stack in a Jetpack Compose UI, including handling different child types and applying animations.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.extensions.compose.jetbrains.stack.Children\nimport com.arkivanov.decompose.extensions.compose.jetbrains.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.jetbrains.stack.animation.stackAnimation\nimport com.sample.shared.RootComponent.Child.ListChild\nimport com.sample.shared.RootComponent.Child.DetailsChild\n\n@Composable\nfun RootContent(component: RootComponent, modifier: Modifier = Modifier) {\n    Children(\n        stack = component.stack,\n        modifier = modifier,\n        animation = stackAnimation(fade()),\n    ) {\n        when (val child = it.instance) {\n            is ListChild -> ListContent(component = child.component)\n            is DetailsChild -> DetailsContent(component = child.component)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using InstanceKeeper for Component Instance Retention in Kotlin\nDESCRIPTION: This example demonstrates how to use InstanceKeeper to retain component instances across configuration changes. The SomeLogic class acts as a retained instance similar to AndroidX ViewModel, with proper lifecycle handling via the onDestroy method.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/instance-retaining.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\n\nclass SomeComponent(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    private val someLogic = instanceKeeper.getOrCreate { SomeLogic() }\n\n    /*\n     * Instances of this class will be retained (not destroyed on configuration changes).\n     * This is equivalent to AndroidX ViewModel.\n     * ⚠️ Pay attention to not leak any dependencies, \n     * e.g. don't make this class `inner`, and don't pass dependencies like Activity Context into it.\n     */\n    private class SomeLogic : InstanceKeeper.Instance {\n        override fun onDestroy() {\n            // Clean-up\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Counter Component with Decompose in Kotlin\nDESCRIPTION: A simple Counter component implementation using Decompose's MutableValue for state management. The component maintains a state with a count value and provides a method to increment the count.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/overview.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.value.MutableValue\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.decompose.value.update\n\nclass Counter {\n    private val _state = MutableValue(State())\n    val state: Value<State> = _state\n\n    fun increment() {\n        _state.update { it.copy(count = it.count + 1) }\n    }\n\n    data class State(val count: Int = 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Decompose Value to Compose State in Kotlin\nDESCRIPTION: Demonstrates how to convert a Decompose Value to a Compose State using the subscribeAsState() extension function.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.State\nimport androidx.compose.runtime.getValue\nimport com.arkivanov.decompose.extensions.compose.jetbrains.subscribeAsState\nimport com.arkivanov.decompose.value.Value\n\ninterface SomeComponent {\n    val model: Value<Model>\n\n    data class Model(/*...*/)\n}\n\n@Composable\nfun SomeContent(component: SomeComponent) {\n    val model: State<SomeComponent.Model> = component.model.subscribeAsState()\n\n    // Or use the delegation pattern\n    val model by component.model.subscribeAsState()\n}\n```\n\n----------------------------------------\n\nTITLE: Basic ChildStack Implementation in Kotlin Compose\nDESCRIPTION: A simple example of using the ChildStack composable function to display child components based on the current stack state. It demonstrates how to render different content based on the type of child instance.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_11\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\n\n@Composable\nfun RootContent(rootComponent: RootComponent) {\n    ChildStack(rootComponent.childStack) {\n        when (val child = it.instance) {\n            is MainChild -> MainContent(child.component)\n            is DetailsChild -> DetailsContent(child.component)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Child Slot Navigation with AlertDialog in Compose\nDESCRIPTION: Demonstrates how to use Child Slot navigation to display an AlertDialog in a Compose application.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.material.AlertDialog\nimport androidx.compose.material.Text\nimport androidx.compose.material.TextButton\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport com.arkivanov.decompose.extensions.compose.jetbrains.subscribeAsState\nimport com.arkivanov.decompose.router.slot.ChildSlot\nimport com.arkivanov.decompose.value.Value\n\ninterface RootComponent {\n    val dialog: Value<ChildSlot<*, DialogComponent>>\n}\n\n@Composable\nfun RootContent(component: RootComponent) {\n    val dialogSlot by component.dialog.subscribeAsState()\n    dialogSlot.child?.instance?.also {\n        DialogContent(component = it)\n    }\n}\n\ninterface DialogComponent {\n    fun onDismissClicked()\n}\n\n@Composable\nfun DialogContent(component: DialogComponent) {\n    AlertDialog(\n        onDismissRequest = component::onDismissClicked,\n        title = { Text(text = \"Title\") },\n        text = { Text(text = \"Message\") },\n        confirmButton = {\n            TextButton(onClick = component::onDismissClicked) {\n                Text(\"Dismiss\")\n            }\n        },\n        modifier = Modifier.width(300.dp),\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Saving State in a Decompose Component\nDESCRIPTION: Demonstrates how to save and restore component state using StateKeeper. This approach registers a state object with a serializer that will be called when the system needs to preserve state, and consumes previously saved state on initialization.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/state-preservation.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport kotlinx.serialization.Serializable\n\nclass SomeComponent(componentContext: ComponentContext) : ComponentContext by componentContext {\n\n    // Either restore the previously saved state or create a new (initial) one\n    private var state: State = stateKeeper.consume(key = \"SAVED_STATE\", strategy = State.serializer()) ?: State()\n\n    init {\n        stateKeeper.register(key = \"SAVED_STATE\", strategy = State.serializer()) {\n            state // Called when it's time to save the state\n        }\n    }\n\n    @Serializable // Comes from kotlinx-serialization\n    private class State(val someValue: Int = 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Root Component for iOS with ApplicationLifecycle\nDESCRIPTION: This snippet shows how to initialize a root component for iOS using SwiftUI and Decompose with the experimental ApplicationLifecycle. It sets up an AppDelegate and creates the root component.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nclass AppDelegate: NSObject, UIApplicationDelegate {\n    let root: RootComponent = DefaultRootComponent(\n        componentContext: DefaultComponentContext(lifecycle: ApplicationLifecycle())\n    )\n}\n\n@main\nstruct iOSApp: App {\n    @UIApplicationDelegateAdaptor(AppDelegate.self)\n    var appDelegate: AppDelegate\n\n    var body: some Scene {\n        WindowGroup {\n            RootView(root: appDelegate.root)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Lifecycle Callbacks in Kotlin with Decompose\nDESCRIPTION: This snippet demonstrates how to implement lifecycle callbacks in a component using Decompose. It shows different ways to subscribe to lifecycle events, including using a Lifecycle.Callbacks object, lambda functions, and extension functions.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/lifecycle.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.lifecycle.Lifecycle\nimport com.arkivanov.essenty.lifecycle.doOnCreate\nimport com.arkivanov.essenty.lifecycle.subscribe\n\nclass SomeComponent(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    init {\n        lifecycle.subscribe(\n            object : Lifecycle.Callbacks {\n                override fun onCreate() {\n                    /* Component created */\n                }\n\n                // onStart, onResume, onPause, onStop, onDestroy\n            }\n        )\n\n        lifecycle.subscribe(\n            onCreate = { /* Component created */ },\n            // onStart, onResume, onPause, onStop, onDestroy\n        )\n\n        lifecycle.doOnCreate { /* Component created */ }\n        // doOnStart, doOnResume, doOnPause, doOnStop, doOnDestroy\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering a Counter Component with Jetpack/JetBrains Compose UI\nDESCRIPTION: A Composable function that renders the Counter component UI using Jetpack/JetBrains Compose. It subscribes to the counter's state and displays the current count along with an increment button.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/overview.md#2025-04-23_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.material.Button\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport com.arkivanov.decompose.extensions.compose.jetbrains.subscribeAsState\n\n@Composable\nfun CounterContent(counter: Counter) {\n    val state by counter.state.subscribeAsState()\n\n    Column {\n        Text(text = state.count.toString())\n\n        Button(onClick = counter::increment) {\n            Text(\"Increment\")\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Back Button Handling in Decompose Components\nDESCRIPTION: Example of manually registering and managing a back button callback in a component using Decompose's ComponentContext and Essenty's BackCallback.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/back-button.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.backhandler.BackCallback\n\nclass SomeComponent(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    private val backCallback = BackCallback { /* Handle the back button */ }\n\n    init {\n        backHandler.register(backCallback)\n    }\n\n    private fun updateBackCallback() {\n        // Set isEnabled to true if you want to override the back button\n        backCallback.isEnabled = true // or false\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using replaceCurrent Navigation Method in Decompose\nDESCRIPTION: The replaceCurrent method replaces the configuration at the top of the stack with a new one, maintaining the same stack depth but changing the active component.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/navigation.md#2025-04-23_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.replaceCurrent(Configuration.D)\n```\n\n----------------------------------------\n\nTITLE: Using Generic Navigation with Manual State Management in Kotlin\nDESCRIPTION: Signature for the children() extension function that implements Generic Navigation with manual state saving and restoring. This function allows developers to subscribe to navigation events, transform the navigation state, and manage child components.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/children/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nfun <C : Any, T : Any, E : Any, N : NavState<C>, S : Any> ComponentContext.children(\n    source: NavigationSource<E>,\n    key: String,\n    initialState: () -> N,\n    saveState: (state: N) -> SerializableContainer?,\n    restoreState: (container: SerializableContainer) -> N?,\n    navTransformer: (state: N, event: E) -> N,\n    stateMapper: (state: N, children: List<Child<C, T>>) -> S,\n    onStateChanged: (newState: N, oldState: N?) -> Unit = { _, _ -> },\n    onEventComplete: (event: E, newState: N, oldState: N) -> Unit = { _, _, _ -> },\n    backTransformer: (state: N) -> (() -> N)? = { null },\n    childFactory: (configuration: C, componentContext: ComponentContext) -> T,\n): Value<S>\n```\n\n----------------------------------------\n\nTITLE: Installing Main Decompose Module in Gradle (Kotlin)\nDESCRIPTION: This snippet demonstrates adding the main Decompose module as a dependency in a Gradle build file using Kotlin DSL. It should be included in the shared application module.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/installation.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimplementation(\"com.arkivanov.decompose:decompose:<version>\")\n```\n\n----------------------------------------\n\nTITLE: Creating Root ComponentContext in Android Activity\nDESCRIPTION: This snippet demonstrates how to create a root ComponentContext in an Android Activity using the defaultComponentContext() extension function provided by Decompose.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/overview.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.defaultComponentContext\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val root = DefaultRootComponent(defaultComponentContext())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a CoroutineScope in a Decompose Component\nDESCRIPTION: This snippet demonstrates how to create and use a CoroutineScope in a Decompose component. The scope is automatically cancelled when the component is destroyed.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/scopes.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.lifecycle.coroutines.coroutineScope\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport kotlin.coroutines.CoroutineContext\n\nclass SomeComponent(\n    componentContext: ComponentContext,\n    mainContext: CoroutineContext,\n    private val ioContext: CoroutineContext,\n) : ComponentContext by componentContext {\n\n    // The scope is automatically cancelled when the component is destroyed\n    private val scope = coroutineScope(mainContext + SupervisorJob())\n\n    fun foo() {\n        scope.launch {\n            val result =\n                withContext(ioContext) {\n                    \"Result\" // Result from background thread\n                }\n\n            println(result) // Handle the result on main thread\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Child Stack with SwiftUI\nDESCRIPTION: This snippet demonstrates how to implement a Child Stack using SwiftUI and the Decompose library. It uses a StackView to display different child components based on the current state of the root component.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nstruct RootView: View {\n    let root: RootComponent\n    \n    var body: some View {\n        StackView(\n            stackValue: StateValue(root.stack),\n            getTitle: {\n                switch $0 {\n                case is RootComponentChild.ListChild: return \"List\"\n                case is RootComponentChild.DetailsChild: return \"Details\"\n                default: return \"\"\n                }\n            },\n            onBack: root.onBackClicked,\n            childContent: {\n                switch $0 {\n                case let child as RootComponentChild.ListChild: ListView(child.component)\n                case let child as RootComponentChild.DetailsChild: DetailsView(child.component)\n                default: EmptyView()\n                }\n            }\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Dialog Component in Kotlin with Decompose\nDESCRIPTION: A basic implementation of a DialogComponent interface that handles dismiss actions. The DefaultDialogComponent class implements this interface and includes functionality to notify when the dialog is dismissed.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/slot/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\n\ninterface DialogComponent {\n\n    fun onDismissClicked()\n}\n\nclass DefaultDialogComponent(\n    private val componentContext: ComponentContext,\n    private val message: String,\n    private val onDismissed: () -> Unit,\n) : DialogComponent, ComponentContext by componentContext {\n\n    override fun onDismissClicked() {\n        onDismissed()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ItemList Component for Navigation in Decompose\nDESCRIPTION: Defines an ItemList component interface and its implementation that handles item selection and forwards it to the parent component through a callback.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\n\ninterface ItemListComponent {\n\n    // Omitted code\n\n    fun onItemClicked(id: Long)\n}\n\nclass DefaultItemListComponent(\n    componentContext: ComponentContext,\n    private val onItemSelected: (id: Long) -> Unit\n) : ItemListComponent, ComponentContext by componentContext {\n\n    // Omitted code\n\n    override fun onItemClicked(id: Long) {\n        onItemSelected(id)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Stack Navigation Instance in Decompose\nDESCRIPTION: Creates a StackNavigation instance that can be used to navigate between configurations in a component class. This is the basic setup required to use navigation in Decompose.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/navigation.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\n// In your component class\nval navigation = StackNavigation<Configuration>()\n```\n\n----------------------------------------\n\nTITLE: Using pushToFront Navigation Method in Decompose\nDESCRIPTION: The pushToFront method moves a configuration to the top of the stack, removing it from its previous position if it already exists in the stack based on equality comparison.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/navigation.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.pushToFront(Configuration.A(1))\n```\n\n----------------------------------------\n\nTITLE: Basic Implementation of ChildPanels Navigation with Compose\nDESCRIPTION: Simple example of implementing the ChildPanels navigation in Compose UI using Decompose's experimental panels API. Shows basic setup with main and details panels, and responsive mode adaptation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_9\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.panels.ChildPanels\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode\n\n@Composable\nfun PanelsContent(component: PanelsComponent) {\n    ChildPanelsModeChangedEffect(component::setMode)\n\n    ChildPanels(\n        panels = component.panels,\n        mainChild = { MainContent(it.instance) },\n        detailsChild = { DetailsContent(it.instance) },\n    )\n}\n\n@Composable\nfun MainContent(component: MainComponent) {\n    // Omitted code\n}\n\n@Composable\nfun DetailsContent(component: DetailsComponent) {\n    // Omitted code\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Pages Component with Child Pages Navigation in Decompose\nDESCRIPTION: Demonstrates the implementation of a component that manages multiple pages using Decompose's Child Pages navigation. It shows initialization of PagesNavigation, creating child pages, and handling page selection.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/pages/overview.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.pages.ChildPages\nimport com.arkivanov.decompose.router.pages.Pages\nimport com.arkivanov.decompose.router.pages.PagesNavigation\nimport com.arkivanov.decompose.router.pages.childPages\nimport com.arkivanov.decompose.router.pages.select\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\n\ninterface PagesComponent {\n    val pages: Value<ChildPages<*, PageComponent>>\n\n    fun selectPage(index: Int)\n}\n\nclass DefaultPagesComponent(\n    componentContext: ComponentContext,\n) : PagesComponent, ComponentContext by componentContext {\n\n    private val navigation = PagesNavigation<Config>()\n\n    override val pages: Value<ChildPages<*, PageComponent>> =\n        childPages(\n            source = navigation,\n            serializer = Config.serializer(), // Or null to disable navigation state saving\n            initialPages = {\n                Pages(\n                    items = List(10) { index -> Config(data = \"Item $index\") },\n                    selectedIndex = 0,\n                )\n            },\n        ) { config, childComponentContext ->\n            DefaultPageComponent(\n                componentContext = childComponentContext,\n                data = config.data,\n            )\n        }\n\n    override fun selectPage(index: Int) {\n        navigation.select(index = index)\n    }\n\n    @Serializable // kotlinx-serialization plugin must be applied\n    private data class Config(val data: String)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Child Components for Child Panels in Kotlin\nDESCRIPTION: This snippet defines the MainComponent and DetailsComponent interfaces along with their default implementations. These components are used as child panels in the Child Panels navigation model.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\n\ninterface MainComponent\n\nclass DefaultMainComponent(\n    componentContext: ComponentContext,\n    onItemSelected: (id: Long) -> Unit,\n) : MainComponent, ComponentContext by componentContext\n\ninterface DetailsComponent\n\nclass DefaultDetailsComponent(\n    componentContext: ComponentContext,\n    itemId: Long,\n    onFinished: () -> Unit,\n) : DetailsComponent, ComponentContext by componentContext\n```\n\n----------------------------------------\n\nTITLE: Implementing Child Panels Navigation in Kotlin with Decompose\nDESCRIPTION: This snippet demonstrates how to implement the Child Panels navigation model using Decompose. It includes the PanelsComponent interface and its default implementation, showing initialization of Child Panels, navigation logic, and mode setting.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.panels.ChildPanels\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode\nimport com.arkivanov.decompose.router.panels.Panels\nimport com.arkivanov.decompose.router.panels.PanelsNavigation\nimport com.arkivanov.decompose.router.panels.activateDetails\nimport com.arkivanov.decompose.router.panels.childPanels\nimport com.arkivanov.decompose.router.panels.dismissDetails\nimport com.arkivanov.decompose.router.panels.setMode\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.builtins.serializer\n\ninterface PanelsComponent {\n\n    val panels: Value<ChildPanels<*, MainComponent, *, DetailsComponent, Nothing, Nothing>>\n\n    fun setMode(mode: ChildPanelsMode)\n}\n\nclass DefaultPanelsComponent(\n  componentContext: ComponentContext,\n) : PanelsComponent, ComponentContext by componentContext {\n\n    private val nav = PanelsNavigation<Unit, DetailsConfig, Nothing>()\n\n    override val panels: Value<ChildPanels<*, MainComponent, *, DetailsComponent, Nothing, Nothing>> =\n        childPanels(\n            source = nav,\n            serializers = Unit.serializer() to DetailsConfig.serializer(),\n            initialPanels = { Panels(main = Unit) },\n            handleBackButton = true,\n            mainFactory = { _, ctx ->\n                DefaultMainComponent(\n                    componentContext = ctx,\n                    onItemSelected = { nav.activateDetails(details = DetailsConfig(itemId = it)) },\n                )\n            },\n            detailsFactory = { cfg, ctx ->\n                DefaultDetailsComponent(\n                    componentContext = ctx,\n                    itemId = cfg.itemId,\n                    onFinished = nav::dismissDetails,\n                )\n            },\n        )\n\n    override fun setMode(mode: ChildPanelsMode) {\n         nav.setMode(mode)\n    }\n  \n    @Serializable\n    private data class DetailsConfig(val itemId: Long)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Navigation with Decompose Components in Kotlin Compose\nDESCRIPTION: This snippet demonstrates how to use the 'rememberRetainedComponent' function in a navigation setup. It shows a basic app structure with a home screen and a details screen, where the details screen uses a Decompose component.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/navigation-compose-component.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material.Button\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\nimport androidx.navigation.compose.rememberNavController\nimport com.arkivanov.decompose.ComponentContext\n\n@Composable\nfun App() {\n    val nav = rememberNavController()\n\n    NavHost(navController = nav, startDestination = \"home\") {\n        composable(\"home\") {\n            HomeScreen(onShowDetails = { nav.navigate(\"details\") })\n        }\n\n        composable(\"details\") {\n            val detailsComponent = rememberRetainedComponent(factory = ::DetailsComponent)\n            DetailsComponent(component = detailsComponent, onBack = nav::popBackStack)\n        }\n    }\n}\n\n@Composable\nfun HomeScreen(onShowDetails: () -> Unit) {\n    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n        Button(onClick = onShowDetails) {\n            Text(\"Go to details\")\n        }\n    }\n}\n\nclass DetailsComponent(\n    componentContext: ComponentContext,\n) : ComponentContext by componentContext {\n    // Some code here\n}\n\n@Composable\nfun DetailsComponent(component: DetailsComponent, onBack: () -> Unit) {\n    Column(\n        modifier = Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center,\n    ) {\n        Button(onClick = onBack) {\n            Text(\"Go back\")\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Navigating Between Composable Components with Children Function\nDESCRIPTION: Shows how to use the Children function to switch between child Composable components based on ChildStack changes.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.jetbrains.stack.Children\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.value.Value\nimport com.sample.shared.RootComponent.Child.DetailsChild\nimport com.sample.shared.RootComponent.Child.MainChild\n\n// Root\n\ninterface RootComponent {\n    val childStack: Value<ChildStack<*, Child>>\n\n    sealed class Child {\n        data class MainChild(val component: MainComponent) : Child()\n        data class DetailsChild(val component: DetailsComponent) : Child()\n    }\n}\n\n@Composable\nfun RootContent(rootComponent: RootComponent) {\n    Children(rootComponent.childStack) {\n        when (val child = it.instance) {\n            is MainChild -> MainContent(child.component)\n            is DetailsChild -> DetailsContent(child.component)\n        }\n    }\n}\n\n// Children\n\ninterface MainComponent\n\ninterface DetailsComponent\n\n@Composable\nfun MainContent(component: MainComponent) {\n    // Omitted code\n}\n\n@Composable\nfun DetailsContent(component: DetailsComponent) {\n    // Omitted code\n}\n```\n\n----------------------------------------\n\nTITLE: Clearing Navigation Stack in PagesNavigator\nDESCRIPTION: Illustrates how to use the clear() function to remove all components from the current Pages state, effectively clearing the navigation stack.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/pages/navigation.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.clear()\n```\n\n----------------------------------------\n\nTITLE: Creating Root Component for Other Platforms with Compose\nDESCRIPTION: This snippet demonstrates how to create a root component before starting Compose for platforms other than Android or JVM/Desktop. It emphasizes the importance of creating the component on the UI thread.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/overview.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.ui.window.application\nimport com.arkivanov.decompose.DefaultComponentContext\n\nfun main() {\n    // Create the root component before starting Compose.\n    // Make sure that this happens on the UI thread.\n    val root = DefaultRootComponent(componentContext = DefaultComponentContext(...))\n\n    // Start Compose\n    application {\n        // The rest of the code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Separate Animations for Different Children with Default API\nDESCRIPTION: Shows how to specify different animations for different types of child components using the default API. This approach uses a when expression to determine the appropriate animation based on the child type.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_18\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.slide\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation { child ->\n            when (child.instance) {\n                is MainChild -> fade() + scale()\n                is DetailsChild -> fade() + slide()\n            }\n        }\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Simplified retainedInstance API in Decompose\nDESCRIPTION: A simplified approach to instance retention using the experimental retainedInstance API. This method provides a more concise way to create and manage retained instances while maintaining the same functionality as the standard approach.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/instance-retaining.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.retainedInstance\n\nclass SomeComponent(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    private val someLogic = retainedInstance { SomeLogic() }\n\n    /*\n     * Instances of this class will be retained (not destroyed on configuration changes).\n     * This is equivalent to AndroidX ViewModel.\n     * ⚠️ Pay attention to not leak any dependencies,\n     * e.g. don't make this class `inner`, and don't pass dependencies like Activity Context into it.\n     */\n    private class SomeLogic : InstanceKeeper.Instance {\n        override fun onDestroy() {\n            // Clean-up\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Main Component with Decompose in Kotlin\nDESCRIPTION: A basic implementation of a Decompose component for a Main screen that includes navigation capability to show a Details screen. The component follows the Decompose pattern with an interface and implementation class.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/composable-viewmodel.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\n\ninterface MainComponent {\n    fun onShowDetailsClicked()\n}\n\nclass DefaultMainComponent(\n    componentContext: ComponentContext,\n    private val onShowDetails: () -> Unit\n) : MainComponent, ComponentContext by componentContext {\n    // Omitted code\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a ViewModel Injection Function for Decompose in Kotlin\nDESCRIPTION: A specialized function for safely injecting ViewModels into Composable functions when using Decompose. This prevents memory leaks that can occur when screens are removed but still animating during navigation transitions.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/composable-viewmodel.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewmodel.compose.viewModel\n\n@Composable\ninline fun <reified T : ViewModel> rememberViewModel(): T {\n    var vm by remember { mutableStateOf<T?>(null) }\n    if (vm == null) {\n        vm = viewModel<T>()\n    }\n\n    return requireNotNull(vm)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Page Component in Decompose\nDESCRIPTION: Defines a simple page component interface and its implementation. The component receives a ComponentContext and data string, implementing the ComponentContext interface via delegation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/pages/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\n\ninterface PageComponent {\n    val data: String\n}\n\nclass DefaultPageComponent(\n    componentContext: ComponentContext,\n    override val data: String,\n) : PageComponent, ComponentContext by componentContext\n```\n\n----------------------------------------\n\nTITLE: Correcting Navigation Property Assignment in Decompose\nDESCRIPTION: Shows the proper way to assign navigation properties (like ChildStack) to prevent \"Another supplier is already registered with the key\" errors. The fix involves directly assigning the value to a property instead of using a getter.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/faq.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\n- val stack: Value<ChildStack<...>> get() = childStack(...)\n+ val stack: Value<ChildStack<...>> = childStack(...)\n```\n\n----------------------------------------\n\nTITLE: Simplified State Preservation Using Saveable Delegate in Decompose\nDESCRIPTION: Demonstrates the experimental 'saveable' delegate API for simplified state preservation. This approach uses a property delegate to automatically handle state saving and restoration with less boilerplate code.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/state-preservation.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.statekeeper.saveable\nimport kotlinx.serialization.Serializable\n\nclass SomeComponent(componentContext: ComponentContext) : ComponentContext by componentContext {\n    private var state: State by saveable(serializer = State.serializer(), init = ::State)\n\n    @Serializable // Comes from kotlinx-serialization\n    private data class State(val someValue: Int = 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Reaktive DisposableScope in a Decompose Component\nDESCRIPTION: This snippet demonstrates how to create and use a Reaktive DisposableScope in a Decompose component. The scope is automatically disposed when the component is destroyed.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/scopes.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.sample.shared.multipane.utils.disposableScope\nimport com.badoo.reaktive.disposable.scope.DisposableScope\nimport com.badoo.reaktive.scheduler.ioScheduler\nimport com.badoo.reaktive.scheduler.mainScheduler\nimport com.badoo.reaktive.single.observeOn\nimport com.badoo.reaktive.single.singleFromFunction\nimport com.badoo.reaktive.single.subscribeOn\n\nclass SomeComponent(\n    componentContext: ComponentContext,\n) : ComponentContext by componentContext,\n    // The scope is automatically disposed when the component is destroyed\n    DisposableScope by componentContext.disposableScope() {\n\n    fun foo() {\n        singleFromFunction {\n            \"Result\" // Result from background thread\n        }\n            .subscribeOn(ioScheduler)\n            .observeOn(mainScheduler)\n            .subscribeScoped { // Subscribe using the DisposableScope\n                println(it) // Handle the result on main thread\n            }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Communication Between Components Using Reactive Streams in Kotlin Decompose\nDESCRIPTION: Demonstrates how to deliver results between components using reactive streams with Reaktive library. The example shows input interfaces, component implementations, and subscription handling for communication between ItemList and ItemDetails components.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/overview.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\ninterface ItemListComponent {\n\n    fun onItemClicked(id: Long)\n\n    sealed interface Input {\n        class ItemDeleted(val id: Long) : Input\n    }\n}\n\ninterface ItemDetailsComponent {\n\n    fun onDeleteClicked()\n}\n\n// Helper factory function creating DisposableScope attached to the Lifecycle.\n// Creating CoroutineScope is very similar.\nfun LifecycleOwner.disposableScope(): DisposableScope {\n    val scope = DisposableScope()\n    lifecycle.doOnDestroy(scope::dispose)\n    return scope\n}\n\nclass DefaultItemListComponent(\n    componentContext: ComponentContext,\n    input: Observable<ItemList.Input>,\n    private val onItemSelected: (id: Long) -> Unit,\n) : ItemListComponent, ComponentContext by componentContext, DisposableScope by componentContext.disposableScope() {\n\n    init {\n        // Subscribe to input\n        input.subscribeScoped {\n            when (it) {\n                is ItemList.Input.ItemDeleted -> TODO(\"Handle item deleted\")\n            }\n        }\n    }\n\n    override fun onItemClicked(id: Long) {\n        onItemSelected(id)\n    }\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n    // Omitted code\n\n    // Or MutableSharedFlow<ItemList.Input>(extraBufferCapacity = Int.MAX_VALUE)\n    private val listInput = PublishSubject<ItemList.Input>()\n\n    private fun itemList(componentContext: ComponentContext): DefaultItemListComponent =\n        DefaultItemListComponent(\n            componentContext = componentContext,\n            input = listInput, // Pass listInput to ItemListComponent\n            onItemSelected = { navigation.push(Config.Details(itemId = it)) },\n        )\n\n    private fun itemDetails(componentContext: ComponentContext, config: Config.Details): ItemDetailsComponent =\n        DefaultItemDetailsComponent(\n            componentContext = componentContext,\n            itemId = config.itemId,\n            onItemDeleted = { id ->\n                navigation.pop { // Pop ItemDetailsComponent\n                    // Deliver the result to ItemList component\n                    listInput.onNext(ItemList.Input.ItemDeleted(id = id))\n                }\n            },\n        )\n\n    // Omitted code\n}\n```\n\n----------------------------------------\n\nTITLE: Creating PagesNavigation in Kotlin\nDESCRIPTION: This snippet shows how to create a PagesNavigation instance in a component class. It initializes navigation for Child Pages with a generic Configuration type.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/pages/navigation.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\n// In your component class\nval navigation = PagesNavigation<Configuration>()\n```\n\n----------------------------------------\n\nTITLE: Observing Value in Jetpack Compose\nDESCRIPTION: Shows how to observe a Decompose Value in a Jetpack Compose UI using the subscribeAsState extension function.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.extensions.compose.jetbrains.subscribeAsState\n\n@Composable\nfun ListContent(component: ListComponent, modifier: Modifier = Modifier) {\n    val model by component.model.subscribeAsState()\n\n    LazyColumn {\n        items(items = model.items) { item ->\n            Text(\n                text = item,\n                modifier = Modifier.clickable { component.onItemClicked(item = item) },\n            )\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Root Component with Child Slot for Dialog Management\nDESCRIPTION: Implementation of a RootComponent that manages a dialog using Child Slot navigation. It demonstrates how to initialize the SlotNavigation, create a Child Slot, and handle dialog activation and dismissal.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/slot/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.slot.ChildSlot\nimport com.arkivanov.decompose.router.slot.SlotNavigation\nimport com.arkivanov.decompose.router.slot.activate\nimport com.arkivanov.decompose.router.slot.childSlot\nimport com.arkivanov.decompose.router.slot.dismiss\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\n\ninterface RootComponent {\n\n    val dialog: Value<ChildSlot<*, DialogComponent>>\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\n    private val dialogNavigation = SlotNavigation<DialogConfig>()\n\n    override val dialog: Value<ChildSlot<*, DialogComponent>> =\n        childSlot(\n            source = dialogNavigation,\n            serializer = DialogConfig.serializer(), // Or null to disable navigation state saving\n            handleBackButton = true, // Close the dialog on back button press\n        ) { config, childComponentContext ->\n            DefaultDialogComponent(\n                componentContext = childComponentContext,\n                message = config.message,\n                onDismissed = dialogNavigation::dismiss,\n            )\n        }\n\n    private fun showDialog(message: String) {\n        dialogNavigation.activate(DialogConfig(message = message))\n    }\n\n    @Serializable // kotlinx-serialization plugin must be applied\n    private data class DialogConfig(\n        val message: String,\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Context-Aware Animation Selection with Experimental API\nDESCRIPTION: Demonstrates how to select animations based on the context (child, other child, and direction) using the experimental ChildStack API. This provides maximum flexibility for creating tailored transition animations.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_20\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation { child, otherChild, direction ->\n            // Select and return an animator here\n        }\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Back Callback Priorities in Decompose\nDESCRIPTION: Example showing how to set priorities for back callbacks to control the order in which they are called when back button is pressed.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/back-button.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\n// This will make sure your callback is always called first\nprivate val backCallback = BackCallback(priority = Int.MAX_VALUE) { ... }\n\n// This will make sure your callback is always called last\nprivate val backCallback = BackCallback(priority = Int.MIN_VALUE) { ... }\n```\n\n----------------------------------------\n\nTITLE: Saving State of a Retained Instance in Decompose\nDESCRIPTION: Shows how to combine InstanceKeeper with StateKeeper to preserve the state of a retained instance. This allows for maintaining instance state during configuration changes while also preserving data if the process is killed.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/state-preservation.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\nimport com.arkivanov.sample.shared.SomeStatefulEntity.State\nimport kotlinx.serialization.Serializable\n\nclass SomeComponent(componentContext: ComponentContext) : ComponentContext by componentContext {\n    private val statefulEntity =\n        instanceKeeper.getOrCreate {\n            SomeStatefulEntity(savedState = stateKeeper.consume(key = \"SAVED_STATE\", strategy = State.serializer()))\n        }\n\n    init {\n        stateKeeper.register(key = \"SAVED_STATE\", strategy = State.serializer(), supplier = statefulEntity::state)\n    }\n}\n\nclass SomeStatefulEntity(savedState: State?) : InstanceKeeper.Instance {\n    var state: State = savedState ?: State()\n        private set\n\n    @Serializable\n    data class State(val someValue: Int = 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SlotNavigation Instance in Kotlin with Decompose\nDESCRIPTION: Demonstrates how to initialize a SlotNavigation instance for managing dialog configurations in a component class.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/slot/navigation.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\n// In your component class\nval navigation = SlotNavigation<DialogConfig>()\n```\n\n----------------------------------------\n\nTITLE: Using popWhile Navigation Method in Decompose\nDESCRIPTION: The popWhile method removes configurations from the top of the stack as long as they satisfy the given predicate, stopping when the predicate returns false.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/navigation.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.popWhile { topOfStack: Configuration -> topOfStack !is B }\n```\n\n----------------------------------------\n\nTITLE: Using Unique Keys for Multiple Navigation Models in Decompose\nDESCRIPTION: Demonstrates how to use the 'key' parameter when using multiple navigation models of the same kind in a single component to prevent registration conflicts in StateKeeper.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/faq.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nval stack1: Value<ChildStack<...>> = childStack(key = \"stack1\", ...)\nval stack2: Value<ChildStack<...>> = childStack(key = \"stack2\", ...)\n```\n\n----------------------------------------\n\nTITLE: Implementing Pages Component with Web Navigation\nDESCRIPTION: Detailed implementation of a pages-based component with web navigation support, showing configuration for pages navigation and state management.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/web-navigation.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nclass DefaultMyPagesComponent(\n    componentContext: ComponentContext,\n    deepLinkUrl: String?, // Or your favourite data structure, like Uri, etc.\n) : MyPagesComponent, ComponentContext by componentContext {\n\n    private val nav = PagesNavigation<Config>()\n\n    private val _pages: Value<ChildPages<Config, ...>> =\n        childPages(\n            source = nav,\n            serializer = Config.serializer(),\n            initialPages = { TODO(\"Use the deepLinkUrl parameter to initialize the navigation\") },\n            childFactory = { ... },\n        )\n\n    override val pages: Value<ChildPages<*, ...>> = _pages\n\n    override val webNavigation: WebNavigation<*> =\n        childPagesWebNavigation(\n            navigator = nav,\n            pages = _pages,\n            serializer = Config.serializer(),\n            pathMapper = { pages -> TODO(\"Return a path for the navigation state\") }, // Optional\n            parametersMapper = { pages -> TODO(\"Return a Map with parameters for the navigation state\") }, // Optional\n            childSelector = { child -> TODO(\"Return a WebNavigationOwner for the child\") }, // Optional\n        )\n\n    @Serializable\n    private data class Config(...)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter UI with SwiftUI for Decompose\nDESCRIPTION: A SwiftUI view that renders the Counter component using the StateValue property wrapper to make the Decompose Value observable in SwiftUI. The view displays the current count and provides an increment button.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/overview.md#2025-04-23_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nstruct CounterView: View {\n    private let counter: Counter\n\n    @StateValue\n    private var state: CounterState\n\n    init(_ counter: Counter) {\n        self.counter = counter\n        _state = StateValue(counter.state)\n    }\n\n    var body: some View {\n        VStack(spacing: 8) {\n            Text(state.value.text)\n            Button(action: counter.increment, label: { Text(\"Increment\") })\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Component View with ViewContext\nDESCRIPTION: Example of creating a component view using ViewContext. It demonstrates how to inflate a layout, find views, and observe component state changes to update the UI.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/android.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport android.view.View\nimport android.widget.TextView\nimport com.arkivanov.decompose.extensions.android.ViewContext\nimport com.arkivanov.decompose.extensions.android.layoutInflater\nimport com.arkivanov.decompose.value.observe\n\nfun ViewContext.CounterView(component: CounterComponent): View {\n    // Inflate the layout without adding it to the parent\n    val layout = layoutInflater.inflate(R.layout.counter, parent, false)\n\n    // Find required views\n    val counterText: TextView = layout.findViewById(R.id.text_count)\n\n    // Observe Counter models and update the view\n    component.model.observe(lifecycle) { data ->\n        counterText.text = data.text\n    }\n\n    return layout // Return the root of the inflated sub-tree\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChildPages Navigation with Compose (Since v3.2.0-alpha03)\nDESCRIPTION: Example showing how to implement ChildPages navigation in Compose UI using the updated ChildPages component from Decompose since version 3.2.0-alpha03. Shows the updated API with similar functionality.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.jetbrains.pages.ChildPages\nimport com.arkivanov.decompose.extensions.compose.jetbrains.pages.PagesScrollAnimation\n\n@Composable\nfun PagesContent(component: PagesComponent) {\n    ChildPages(\n        pages = component.pages,\n        onPageSelected = component::selectPage,\n        scrollAnimation = PagesScrollAnimation.Default,\n    ) { _, page ->\n        PageContent(page)\n    }\n}\n\n@Composable\nfun PageContent(component: PageComponent) {\n    // Omitted code\n}\n```\n\n----------------------------------------\n\nTITLE: Using replaceAll Navigation Method in Decompose\nDESCRIPTION: The replaceAll method replaces the entire stack with a new set of configurations. Components that remain in the stack are preserved, while others are destroyed.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/navigation.md#2025-04-23_snippet_9\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.replaceAll(Configuration.B, Configuration.C, Configuration.D)\n```\n\n----------------------------------------\n\nTITLE: Window Size Class Detection for Responsive Panels Layout\nDESCRIPTION: Composable function that detects window size class changes and triggers a callback to update the panel mode accordingly. Used to implement responsive layouts with ChildPanels navigation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.material3.windowsizeclass.WindowWidthSizeClass\nimport androidx.compose.material3.windowsizeclass.WindowWidthSizeClass.Companion.Expanded\nimport androidx.compose.material3.windowsizeclass.calculateWindowSizeClass\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode.SINGLE\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode.DUAL\n\n@Composable\nfun ChildPanelsModeChangedEffect(onModeChanged: (ChildPanelsMode) -> Unit) {\n    val windowSize = calculateWindowSizeClass()\n    val mode = if (windowSize.widthSizeClass < Expanded) SINGLE else DUAL\n\n    DisposableEffect(mode) {\n        onModeChanged(mode)\n        onDispose {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a CoroutineScope Surviving Android Configuration Changes\nDESCRIPTION: This snippet shows how to create a CoroutineScope that survives Android configuration changes using InstanceKeeper in a Decompose component.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/scopes.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.cancel\nimport kotlinx.coroutines.launch\nimport kotlin.coroutines.CoroutineContext\n\ninternal class SomeRetainedInstance(mainContext: CoroutineContext) : InstanceKeeper.Instance {\n    // The scope survives Android configuration changes\n    private val scope = CoroutineScope(mainContext + SupervisorJob())\n\n    fun foo() {\n        scope.launch {\n            // Do the job\n        }\n    }\n\n    override fun onDestroy() {\n        scope.cancel() // Cancel the scope when the instance is destroyed\n    }\n}\n\nclass SomeComponent(\n    componentContext: ComponentContext,\n    mainContext: CoroutineContext,\n) : ComponentContext by componentContext {\n\n    private val someRetainedInstance = instanceKeeper.getOrCreate { SomeRetainedInstance(mainContext) }\n}\n```\n\n----------------------------------------\n\nTITLE: Context-Aware Animation Selection with Default API\nDESCRIPTION: Shows how to select animations based on the child, other child, and direction context in the default API. This approach provides maximum flexibility for creating tailored transitions between specific screens.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_19\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation { child, otherChild, direction ->\n            // Select and return an animator here\n        }\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Child Stacks in a Single Decompose Component\nDESCRIPTION: Shows how to implement multiple child stacks within the same component using unique keys. Each child stack must have a distinct key to avoid exceptions, though different components can reuse the same keys.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/overview.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nclass DefaultRootComponent(\n    componentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n    private val topNavigation = StackNavigation<TopConfig>()\n    \n    private val topStack =\n        childStack<TopConfig, TopChild>(\n            source = topNavigation,\n            key = \"TopStack\",\n            // Omitted code\n        )\n\n    private val bottomNavigation = StackNavigation<BottomConfig>()\n    \n    private val bottomStack =\n        childStack<BottomConfig, BottomChild>(\n            source = bottomNavigation,\n            key = \"BottomStack\",\n            // Omitted code\n        )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Empty Stack Navigation with Decompose in Kotlin\nDESCRIPTION: This snippet defines a custom stack navigation that can be empty using Decompose's Generic Navigation. It includes a Stack data class, a stack function for creating the navigation, and a private StackNavState class for managing the navigation state.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/children/overview.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.Child\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.children.ChildNavState\nimport com.arkivanov.decompose.router.children.ChildNavState.Status\nimport com.arkivanov.decompose.router.children.NavState\nimport com.arkivanov.decompose.router.children.NavigationSource\nimport com.arkivanov.decompose.router.children.SimpleChildNavState\nimport com.arkivanov.decompose.router.children.children\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.KSerializer\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.Transient\n\ndata class Stack<out C : Any, out T : Any>(\n    val items: List<Child.Created<C, T>>,\n)\n\ntypealias StackNavEvent<C> = (List<C>) -> List<C>\n\nfun <C : Any, T : Any> ComponentContext.stack(\n    source: NavigationSource<StackNavEvent<C>>,\n    serializer: KSerializer<C>,\n    initialStack: () -> List<C> = ::emptyList,\n    key: String = \"Stack\",\n    childFactory: (configuration: C, componentContext: ComponentContext) -> T,\n): Value<Stack<C, T>> =\n    children(\n        source = source,\n        stateSerializer = StackNavState.serializer(serializer),\n        initialState = { StackNavState(initialStack()) },\n        key = key,\n        navTransformer = { state, event -> StackNavState(event(state.items)) },\n        stateMapper = { _, children -> Stack(children as List<Child.Created<C, T>>) },\n        backTransformer = { state ->\n            state.items.takeUnless(List<*>::isEmpty)?.let { items ->\n                { StackNavState(items.dropLast(1)) }\n            }\n        },\n        childFactory = childFactory,\n    )\n\n@Serializable\nprivate data class StackNavState<out C : Any>(\n    val items: List<C>,\n) : NavState<C> {\n    @Transient\n    override val children: List<ChildNavState<C>> =\n        items.mapIndexed { index, config ->\n            SimpleChildNavState(\n                configuration = config,\n                status = if (index == items.lastIndex) Status.RESUMED else Status.CREATED,\n            )\n        }\n}\n```\n\n----------------------------------------\n\nTITLE: Using stackAnimator Function with Default API\nDESCRIPTION: Shows the simplest way to implement animations using the stackAnimator function with Default API. The function takes care of running the animation while the block focuses on rendering the current frame using the factor and direction.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_27\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.Direction\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimator\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimator\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation(someAnimator()),\n    ) {\n        // Omitted code\n    }\n}\n\nfun someAnimator(): StackAnimator =\n    stackAnimator { factor: Float,\n                    direction: Direction,\n                    content: (Modifier) -> Unit ->\n        // Render the current frame\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Slide Animation with Experimental API in Decompose\nDESCRIPTION: Demonstrates how to apply a slide transition animation using the experimental ChildStack API. This creates a horizontal sliding effect when navigating between screens.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_15\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.slide\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(slide()),\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting Last Page in PagesNavigator\nDESCRIPTION: Demonstrates how to use the selectLast() function to navigate to the last page in the navigation stack.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/pages/navigation.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.selectLast()\n```\n\n----------------------------------------\n\nTITLE: Combining Animations with Experimental API in Decompose\nDESCRIPTION: Demonstrates how to combine multiple animators using the plus operator with the experimental API. This example combines fade and scale animations for more complex transitions.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_17\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(fade() + scale())\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Root Component with ViewModelStoreOwner in Decompose\nDESCRIPTION: A root component implementation that manages navigation between Main and Details screens. For the Details screen, it provides a ViewModelStoreOwner instead of a component, allowing proper ViewModel scoping for Composable functions.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/composable-viewmodel.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.lifecycle.ViewModelStoreOwner\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.router.stack.childStack\nimport com.arkivanov.decompose.router.stack.pushNew\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.sample.app.RootComponent.Child\nimport com.arkivanov.sample.app.RootComponent.Child.ListChild\nimport com.arkivanov.sample.app.RootComponent.Child.MainChild\nimport kotlinx.serialization.Serializable\n\ninterface RootComponent {\n\n    val childStack: Value<ChildStack<*, Child>>\n\n    sealed class Child {\n        class ListChild(val component: MainComponent) : Child()\n        class MainChild(val component: ViewModelStoreOwner) : Child() // ViewModelStoreOwner instead of component\n    }\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\n    private val nav = StackNavigation<Config>()\n\n    override val childStack: Value<ChildStack<*, Child>> =\n        childStack(\n            source = nav,\n            serializer = Config.serializer(),\n            initialConfiguration = Config.Main,\n        ) { config, ctx ->\n            when (config) {\n                is Config.Main ->\n                    ListChild(\n                        component = DefaultMainComponent(\n                            componentContext = ctx,\n                            onShowDetails = { nav.pushNew(Config.Details) },\n                        ),\n                    )\n\n                is Config.Details ->\n                    MainChild(\n                        component = ctx.viewModelStoreOwner(), // Attach a ViewModelStore to the child InstanceKeeper\n                    )\n            }\n        }\n\n    @Serializable\n    private sealed interface Config {\n        @Serializable\n        data object Main : Config\n\n        @Serializable\n        data object Details : Config\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Deep Link Handling in Root Component (Kotlin)\nDESCRIPTION: A Kotlin implementation example showing how to handle deep links in a root component by accepting an initialItemId parameter and setting up the initial navigation stack accordingly.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/deeplinking.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.router.stack.childStack\nimport kotlinx.serialization.Serializable\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n    initialItemId: Long? = null, // It can be any other type, e.g. a sealed class with all possible destinations\n) : RootComponent, ComponentContext by componentContext {\n\n    private val navigation = StackNavigation<Config>()\n\n    private val stack =\n        childStack(\n            source = navigation,\n            initialStack = {\n                listOfNotNull(\n                    Config.List,\n                    if (initialItemId != null) Config.Details(itemId = initialItemId) else null,\n                )\n            },\n            handleBackButton = true,\n            childFactory = ::createChild,\n        )\n\n    // Omitted code\n\n    @Serializable\n    private sealed class Config {\n        @Serializable\n        data object List : Config()\n\n        @Serializable\n        data class Details(val itemId: Long) : Config()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Navigating with Details and Extra Configurations Example\nDESCRIPTION: Example showing navigation state transition when updating details and extra panel configurations.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/navigation.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.navigate(details = Details2, extra = Extra2)\n```\n\n----------------------------------------\n\nTITLE: Custom BackHandler Composable for Decompose Integration\nDESCRIPTION: Implementation of a custom BackHandler Composable that integrates with Decompose's back handling system, providing proper lifecycle management.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/back-button.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.DisposableEffect\nimport androidx.compose.runtime.SideEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberUpdatedState\nimport com.arkivanov.essenty.backhandler.BackCallback\nimport com.arkivanov.essenty.backhandler.BackHandler\n\n@Composable\nfun BackHandler(backHandler: BackHandler, isEnabled: Boolean = true, onBack: () -> Unit) {\n    val currentOnBack by rememberUpdatedState(onBack)\n\n    val callback =\n        remember {\n            BackCallback(isEnabled = isEnabled) {\n                currentOnBack()\n            }\n        }\n\n    SideEffect { callback.isEnabled = isEnabled }\n\n    DisposableEffect(backHandler) {\n        backHandler.register(callback)\n        onDispose { backHandler.unregister(callback) }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Root Component for Desktop with Compose\nDESCRIPTION: This snippet demonstrates how to initialize a root component for desktop applications using Jetpack Compose and Decompose. It sets up the main window and binds the root lifecycle to the window state.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_10\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Surface\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\nimport androidx.compose.ui.window.rememberWindowState\nimport com.arkivanov.decompose.DefaultComponentContext\nimport com.arkivanov.decompose.extensions.compose.jetbrains.lifecycle.LifecycleController\nimport com.arkivanov.essenty.lifecycle.LifecycleRegistry\nimport com.arkivanov.sample.shared.DefaultRootComponent\nimport com.arkivanov.sample.shared.RootContent\n\nfun main() {\n    val lifecycle = LifecycleRegistry()\n\n    // Always create the root component outside Compose on the UI thread\n    val root =\n        runOnUiThread {\n            DefaultRootComponent(\n                componentContext = DefaultComponentContext(lifecycle = lifecycle),\n            )\n        }\n\n    application {\n        val windowState = rememberWindowState()\n\n        LifecycleController(lifecycle, windowState)\n\n        Window(\n            onCloseRequest = ::exitApplication,\n            state = windowState,\n            title = \"My Application\"\n        ) {\n            MaterialTheme {\n                Surface {\n                    RootContent(component = root, modifier = Modifier.fillMaxSize())\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom BackHandler in Compose UI Components\nDESCRIPTION: Example of how to use the custom BackHandler Composable within a Compose UI component to handle back button events.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/back-button.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\n\n@Composable\nfun SomeContent(component: SomeComponent) {\n    BackHandler(backHandler = component.backHandler) {\n        // Handle the back button here\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Deep Links in Android Activity with handleDeepLink (Kotlin)\nDESCRIPTION: Example of how to handle deep links in an Android Activity using the handleDeepLink extension function, which extracts the Uri from the Intent and manages Activity task states appropriately.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/deeplinking.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport android.content.Intent\nimport android.net.Uri\nimport android.os.Bundle\nimport androidx.activity.compose.setContent\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.defaultComponentContext\nimport com.arkivanov.decompose.handleDeepLink\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val root = \n            handleDeepLink { uri ->\n                val initialItemId = uri?.extractInitialItemId()\n                DefaultRootComponent(\n                    componentContext = defaultComponentContext(\n                        discardSavedState = initialItemId != null, // Discard any saved state if there is a deep link\n                    ),\n                    initialItemId = initialItemId,\n                )\n            } ?: return\n\n        setContent {\n            // Omitted code\n        }\n    }\n\n    private fun Uri.extractInitialItemId(): Long = TODO(\"Extract the initial item id from the deep link\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Retained Component Functionality in Kotlin for Navigation-Compose\nDESCRIPTION: This snippet defines a function 'rememberRetainedComponent' and supporting classes to enable hosting of Decompose components within navigation-compose screens. It handles lifecycle management, back press behavior, and state preservation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/navigation-compose-component.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport android.os.Bundle\nimport androidx.activity.OnBackPressedCallback\nimport androidx.activity.compose.LocalOnBackPressedDispatcherOwner\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.DisposableEffect\nimport androidx.compose.ui.platform.LocalLifecycleOwner\nimport androidx.lifecycle.DefaultLifecycleObserver\nimport androidx.lifecycle.LifecycleOwner\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.createSavedStateHandle\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.ComponentContextFactory\nimport com.arkivanov.decompose.DefaultComponentContext\nimport com.arkivanov.essenty.backhandler.BackDispatcher\nimport com.arkivanov.essenty.backhandler.connectOnBackPressedCallback\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeperDispatcher\nimport com.arkivanov.essenty.lifecycle.LifecycleRegistry\nimport com.arkivanov.essenty.lifecycle.create\nimport com.arkivanov.essenty.lifecycle.destroy\nimport com.arkivanov.essenty.lifecycle.pause\nimport com.arkivanov.essenty.lifecycle.resume\nimport com.arkivanov.essenty.lifecycle.start\nimport com.arkivanov.essenty.lifecycle.stop\nimport com.arkivanov.essenty.statekeeper.SerializableContainer\nimport com.arkivanov.essenty.statekeeper.StateKeeperDispatcher\nimport com.arkivanov.essenty.statekeeper.getSerializableContainer\nimport com.arkivanov.essenty.statekeeper.putSerializableContainer\n\n@Composable\nfun <T> rememberRetainedComponent(key: String = \"ComposableComponent\", factory: (ComponentContext) -> T): T {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    val lifecycle = lifecycleOwner.lifecycle\n    val onBackPressedDispatcher = LocalOnBackPressedDispatcherOwner.current?.onBackPressedDispatcher\n\n    val holder =\n        viewModel {\n            val handle = createSavedStateHandle()\n            val ctx = RetainedComponentContext(handle.get<Bundle>(key)?.getSerializableContainer(key))\n            handle.setSavedStateProvider(key) { Bundle().apply { putSerializableContainer(key, ctx.stateKeeper.save()) } }\n            Holder(factory(ctx), ctx)\n        }\n\n    DisposableEffect(lifecycle) {\n        val observer = LifecycleAdapter(holder.componentContext.lifecycle)\n        lifecycle.addObserver(observer)\n        onDispose { lifecycle.removeObserver(observer) }\n    }\n\n    if (onBackPressedDispatcher != null) {\n        DisposableEffect(lifecycleOwner, onBackPressedDispatcher) {\n            val onBackPressedCallback = holder.componentContext.onBackPressedCallback\n            onBackPressedDispatcher.addCallback(lifecycleOwner, onBackPressedCallback)\n            onDispose(onBackPressedCallback::remove)\n        }\n    }\n\n    return holder.instance\n}\n\nprivate class LifecycleAdapter(\n    private val lifecycle: LifecycleRegistry\n) : DefaultLifecycleObserver {\n    override fun onCreate(owner: LifecycleOwner) {\n        lifecycle.create()\n    }\n\n    override fun onStart(owner: LifecycleOwner) {\n        lifecycle.start()\n    }\n\n    override fun onResume(owner: LifecycleOwner) {\n        lifecycle.resume()\n    }\n\n    override fun onPause(owner: LifecycleOwner) {\n        lifecycle.pause()\n    }\n\n    override fun onStop(owner: LifecycleOwner) {\n        lifecycle.stop()\n    }\n}\n\nprivate class RetainedComponentContext(savedState: SerializableContainer?) : ComponentContext {\n    override val lifecycle: LifecycleRegistry = LifecycleRegistry()\n    override val stateKeeper: StateKeeperDispatcher = StateKeeperDispatcher(savedState)\n    override val instanceKeeper: InstanceKeeperDispatcher = InstanceKeeperDispatcher()\n    override val backHandler: BackDispatcher = BackDispatcher()\n    val onBackPressedCallback: OnBackPressedCallback = backHandler.connectOnBackPressedCallback()\n\n    override val componentContextFactory: ComponentContextFactory<ComponentContext> =\n        ComponentContextFactory(::DefaultComponentContext)\n}\n\nprivate class Holder<out T>(\n    val instance: T,\n    val componentContext: RetainedComponentContext,\n) : ViewModel(componentContext.lifecycle::destroy, componentContext.instanceKeeper::destroy)\n```\n\n----------------------------------------\n\nTITLE: Using stackAnimator Function with Experimental API\nDESCRIPTION: Demonstrates the simplest approach to custom animations using the stackAnimator function with Experimental API. This only requires creating and returning a Modifier for each animation frame based on the factor and direction.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_28\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimator\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimator\nimport com.arkivanov.decompose.extensions.compose.stack.animation.Direction\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(someAnimator()),\n    ) {\n        // Omitted code\n    }\n}\n\nfun someAnimator(): StackAnimator =\n    stackAnimator { factor: Float, direction: Direction ->\n        // Create and return a Modifier for the current frame\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Web Navigation Component with Child Panels in Kotlin\nDESCRIPTION: Provides a concrete implementation of the MyPanelsComponent interface using Decompose's ChildPanels API. It initializes panel navigation, sets up web navigation integration, and defines serializable configuration classes for state persistence and restoration.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/web-navigation.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.panels.ChildPanels\nimport com.arkivanov.decompose.router.panels.PanelsNavigation\nimport com.arkivanov.decompose.router.panels.childPanels\nimport com.arkivanov.decompose.router.panels.childPanelsWebNavigation\nimport com.arkivanov.decompose.router.webhistory.WebNavigation\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\n\nclass DefaultMyPanelsComponent(\n    componentContext: ComponentContext,\n    deepLinkUrl: String?, // Or your favourite data structure, like Uri, etc.\n) : MyPanelsComponent, ComponentContext by componentContext {\n\n    private val nav = PanelsNavigation<MainConfig, DetailsConfig, Nothing>()\n\n    private val _panels: Value<ChildPanels<...>> =\n        childPanels(\n            source = nav,\n            serializers = MainConfig.serializer() to DetailsConfig.serializer(),\n            initialPanels = { TODO(\"Use the deepLinkUrl parameter to initialize the navigation\") },\n            mainFactory = { ... },\n            detailsFactory = { ... },\n        )\n\n    override val panels: Value<ChildPanels<...>> = _panels\n\n    override val webNavigation: WebNavigation<*> =\n        childPanelsWebNavigation(\n            navigator = nav,\n            panels = _panels,\n            serializers = MainConfig.serializer() to DetailsConfig.serializer(),\n            pathMapper = { panels -> TODO(\"Return a path for the navigation state\") }, // Optional\n            parametersMapper = { panels -> TODO(\"Return a Map with parameters for the navigation state\") }, // Optional\n            childSelector = { panels -> TODO(\"Return a WebNavigationOwner for the navigation state\") }, // Optional\n        )\n\n    @Serializable\n    private data class MainConfig(...)\n\n    @Serializable\n    private data class DetailsConfig(...)\n}\n```\n\n----------------------------------------\n\nTITLE: Dismissing Details Panel Example\nDESCRIPTION: Example showing how to dismiss the currently active details panel.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/navigation.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.dismissDetails()\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom StackAnimator with Default API\nDESCRIPTION: Shows how to implement a custom StackAnimator with the Default API. This approach handles Modifier manipulation in a given direction and calls onFinished when the animation completes.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_25\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.Direction\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimator\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation(someAnimator()),\n    ) {\n        // Omitted code\n    }\n}\n\nfun someAnimator(): StackAnimator =\n    StackAnimator { direction: Direction,\n                    isInitial: Boolean,\n                    onFinished: () -> Unit,\n                    content: @Composable (Modifier) -> Unit ->\n        // Manipulate the Modifier in the given direction and call onFinished at the end\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stack Component with Web Navigation\nDESCRIPTION: Complete implementation of a stack-based component with web navigation support, including configuration for deep linking and navigation state management.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/web-navigation.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nclass DefaultMyStackComponent(\n    componentContext: ComponentContext,\n    deepLinkUrl: String?, // Or your favourite data structure, like Uri, etc.\n) : MyStackComponent, ComponentContext by componentContext {\n\n    private val nav = StackNavigation<Config>()\n\n    private val _stack: Value<ChildStack<Config, MyStackComponent.Child>> =\n        childStack(\n            source = nav,\n            serializer = Config.serializer(),\n            initialStack = { TODO(\"Use the deepLinkUrl parameter to initialize the stack\") },\n            childFactory = { ... },\n        )\n\n    override val stack: Value<ChildStack<*, MyStackComponent.Child>> = _stack\n\n    override val webNavigation: WebNavigation<*> =\n        childStackWebNavigation(\n            navigator = nav,\n            stack = _stack,\n            serializer = Config.serializer(),\n            pathMapper = { child -> TODO(\"Return a path for the child\") }, // Optional\n            parametersMapper = { child -> TODO(\"Return a Map with parameters for the child\") }, // Optional\n            childSelector = { child -> TODO(\"Return a WebNavigationOwner for the child\") }, // Optional\n        )\n\n    @Serializable\n    private sealed interface Config {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Retained Components in Android Activity\nDESCRIPTION: Example of using retainedComponent in an Android Activity to create components that survive configuration changes. This approach must be used carefully to avoid memory leaks and should only be called once in the Activity's lifecycle.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/instance-retaining.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.retainedComponent\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val root =\n            retainedComponent { componentContext ->\n                DefaultRootComponent(componentContext)\n            }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using StackRouterView for Child Stack Management\nDESCRIPTION: Example showing how to use StackRouterView to observe and manage a stack of child components in the UI. It demonstrates handling navigation between child components and view transitions.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/android.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nimport android.view.View\nimport com.arkivanov.decompose.extensions.android.ViewContext\nimport com.arkivanov.decompose.extensions.android.child\nimport com.arkivanov.decompose.extensions.android.layoutInflater\nimport com.arkivanov.decompose.extensions.android.stack.StackRouterView\n\nfun ViewContext.RootView(component: RootComponent): View {\n    val layout = layoutInflater.inflate(R.layout.counter_root, parent, false)\n    val nextButton: View = layout.findViewById(R.id.button_next)\n    val routerView: StackRouterView = layout.findViewById(R.id.router)\n\n    nextButton.setOnClickListener { counterRoot.onNextChild() }\n\n    // Create a child `ViewContext` for the permanent `CounterView`\n    child(layout.findViewById(R.id.container_counter)) {\n        // Reuse the `CounterView`\n        CounterView(component.counter)\n    }\n\n    // Subscribe the `StackRouterView` to the `ChildStack` changes\n    routerView.children(component.childStack, lifecycle) { parent, newStack, _ ->\n        // Remove all existing views\n        parent.removeAllViews()\n\n        // Add the child view for the currently active child component\n        parent.addView(CounterView(newStack.active.instance))\n    }\n\n    return layout\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom StackAnimation with Experimental API\nDESCRIPTION: Demonstrates implementing a custom low-level StackAnimation using the Experimental API. This approach provides direct control over the animation frames with access to AnimatedVisibilityScope.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_24\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.animation.AnimatedVisibilityScope\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.Child\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimation\nimport com.arkivanov.decompose.router.stack.ChildStack\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = someAnimation(),\n    ) {\n        // Omitted code\n    }\n}\n\nfun <C : Any, T : Any> someAnimation(): StackAnimation<C, T> =\n    StackAnimation { stack: ChildStack<C, T>,\n                     modifier: Modifier,\n                     content: @Composable AnimatedVisibilityScope.(Child.Created<C, T>) -> Unit ->\n        // Render each frame here\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom StackAnimation with Default API\nDESCRIPTION: Shows how to implement a custom low-level StackAnimation using the Default API. This offers the most flexibility by giving direct access to the ChildStack for animation control.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_23\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.Child\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimation\nimport com.arkivanov.decompose.router.stack.ChildStack\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = someAnimation(),\n    ) {\n        // Omitted code\n    }\n}\n\nfun <C : Any, T : Any> someAnimation(): StackAnimation<C, T> =\n    StackAnimation { stack: ChildStack<C, T>,\n                     modifier: Modifier,\n                     content: @Composable (Child.Created<C, T>) -> Unit ->\n        // Render each frame here\n    }\n```\n\n----------------------------------------\n\nTITLE: Component Interface with BackHandlerOwner for Compose Integration\nDESCRIPTION: Example of a component interface that extends BackHandlerOwner to make back handler functionality available to Compose UI.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/back-button.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.essenty.backhandler.BackHandlerOwner\n\ninterface SomeComponent : BackHandlerOwner {\n    // Omitted code\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Slide Animation with Default API in Decompose\nDESCRIPTION: Shows how to implement a slide transition animation between components using the default Children API. This creates a horizontal sliding effect when navigating between screens.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_14\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.slide\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation(slide()),\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fade Animation with Default API in Decompose\nDESCRIPTION: Shows how to apply a fade transition animation to child components using the default Children API. The stackAnimation function is used with a fade animator to create smooth transitions between screens.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_12\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation(fade()),\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing PanelsNavigation in Kotlin\nDESCRIPTION: Creates a new PanelsNavigation instance for handling component navigation with specified Configuration type.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/navigation.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\n// In your component class\nval navigation = PanelsNavigation<Configuration>()\n```\n\n----------------------------------------\n\nTITLE: Implementing BackHandlerOwner for Predictive Back Gesture in Kotlin\nDESCRIPTION: This snippet shows how to implement the BackHandlerOwner interface in a RootComponent to enable Predictive Back Gesture support. It includes the necessary imports and a basic implementation of onBackClicked.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_29\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.essenty.backhandler.BackHandlerOwner\n\ninterface RootComponent : BackHandlerOwner {\n    val childStack: Value<ChildStack<...>>\n\n    fun onBackClicked()\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext, BackHandlerOwner {\n    private val navigation = StackNavigation<Config>()\n\n    // ComponentContext already implements BackHandlerOwner, no need to implement it separately\n\n    // Omitted body\n\n    override fun onBackClicked() {\n        navigation.pop()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Value in SwiftUI\nDESCRIPTION: Demonstrates how to observe a Decompose Value in a SwiftUI view using the StateValue property wrapper.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nstruct DetailsView: View {\n    private let list: ListComponent\n    \n    @StateValue\n    private var model: ListComponentModel\n\n    init(_ list: ListComponent) {\n        self.list = list\n        _model = StateValue(list.model)\n    }\n    \n    var body: some View {\n        List(model.items, ...) { item in\n            // Display the item\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Predictive Back Animation with Default API in Kotlin\nDESCRIPTION: This snippet demonstrates how to configure Predictive Back Animation using the default API in a RootContent composable function. It uses the Children composable and sets up the animation with fallback and onBack callback.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_30\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.predictiveBackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = predictiveBackAnimation(\n            backHandler = component.backHandler,\n            fallbackAnimation = stackAnimation(fade() + scale()), // Your usual animation here\n            onBack = component::onBackClicked,\n        ),\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ItemDetails Component for Navigation in Decompose\nDESCRIPTION: Defines an ItemDetails component interface and its implementation that handles the close action and notifies the parent component through a callback.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/overview.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\n\ninterface ItemDetailsComponent {\n\n    // Omitted code\n\n    fun onCloseClicked()\n}\n\nclass DefaultItemDetailsComponent(\n    componentContext: ComponentContext,\n    itemId: Long,\n    private val onFinished: () -> Unit\n) : ItemDetailsComponent, ComponentContext by componentContext {\n\n    // Omitted code\n\n    override fun onCloseClicked() {\n        onFinished()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Child Slots in a Single Component\nDESCRIPTION: Example of using multiple Child Slots within a single component by assigning unique keys to each slot. The example shows how to create separate navigations and child slots for top and bottom components.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/slot/overview.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.slot.SlotNavigation\nimport com.arkivanov.decompose.router.slot.childSlot\n\nclass Root(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    private val topNavigation = SlotNavigation<TopConfig>()\n\n    private val topSlot =\n        childSlot<TopConfig, TopChild>(\n            source = topNavigation,\n            key = \"TopSlot\",\n            // Omitted code\n        )\n\n    private val bottomNavigation = SlotNavigation<BottomConfig>()\n\n    private val bottomSlot =\n        childSlot<BottomConfig, BottomChild>(\n            source = bottomNavigation,\n            key = \"BottomSlot\",\n            // Omitted code\n        )\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Main Decompose Module in Gradle (Groovy)\nDESCRIPTION: This snippet shows how to add the main Decompose module as a dependency in a Gradle build file using Groovy syntax. It should be added to the shared application module.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/installation.md#2025-04-23_snippet_0\n\nLANGUAGE: groovy\nCODE:\n```\nimplementation \"com.arkivanov.decompose:decompose:<version>\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Material Predictive Back Animation with Experimental API in Kotlin\nDESCRIPTION: This snippet demonstrates how to set up Material Predictive Back Animation using the experimental API in a RootContent composable function. It uses the ChildStack composable and configures the animation with materialPredictiveBackAnimatable.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_32\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.PredictiveBackParams\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.materialPredictiveBackAnimatable\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(\n            animator = fade() + scale(),\n            predictiveBackParams = {\n                PredictiveBackParams(\n                    backHandler = component.backHandler,\n                    onBack = component::onBackClicked,\n                    animatable = ::materialPredictiveBackAnimatable,\n                )\n            },\n        ),\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Generic Navigation with Automatic State Management in Kotlin\nDESCRIPTION: Signature for the children() extension function with automatic state serialization. This variant uses a KSerializer to automatically save and restore navigation state, simplifying implementation for developers.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/children/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nfun <C : Any, T : Any, E : Any, N : NavState<C>, S : Any> ComponentContext.children(\n    source: NavigationSource<E>,\n    stateSerializer: KSerializer<N>?,\n    initialState: () -> N,\n    key: String,\n    navTransformer: (state: N, event: E) -> N,\n    stateMapper: (state: N, children: List<Child<C, T>>) -> S,\n    onStateChanged: (newState: N, oldState: N?) -> Unit = { _, _ -> },\n    onEventComplete: (event: E, newState: N, oldState: N) -> Unit = { _, _, _ -> },\n    backTransformer: (state: N) -> (() -> N)? = { null },\n    childFactory: (configuration: C, componentContext: ComponentContext) -> T,\n): Value<S>\n```\n\n----------------------------------------\n\nTITLE: Implementing Fade Animation with Experimental API in Decompose\nDESCRIPTION: Demonstrates how to apply a fade transition animation to child components using the experimental ChildStack API. This example shows the newer approach to creating animated transitions.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_13\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(fade()),\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using pushNew Navigation Method in Decompose\nDESCRIPTION: The pushNew method pushes a configuration to the top of the stack but does nothing if the configuration is already on top. Useful for preventing duplicate pushes on rapid button clicks.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/navigation.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.pushNew(Configuration.C)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom ComponentContext in Kotlin with Decompose\nDESCRIPTION: This code snippet shows how to create a custom AppComponentContext interface extending GenericComponentContext and implement it using DefaultAppComponentContext class. It demonstrates adding a custom property (logger) and delegating other functionality to the existing ComponentContext.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/custom-component-context.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.ComponentContextFactory\nimport com.arkivanov.decompose.GenericComponentContext\nimport com.arkivanov.essenty.backhandler.BackHandlerOwner\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeperOwner\nimport com.arkivanov.essenty.lifecycle.LifecycleOwner\nimport com.arkivanov.essenty.statekeeper.StateKeeperOwner\n\ninterface AppComponentContext : GenericComponentContext<AppComponentContext> {\n\n    val logger: Logger // Additional property\n}\n\nclass DefaultAppComponentContext(\n    componentContext: ComponentContext,\n    override val logger: Logger,\n) : AppComponentContext,\n    LifecycleOwner by componentContext,\n    StateKeeperOwner by componentContext,\n    InstanceKeeperOwner by componentContext,\n    BackHandlerOwner by componentContext {\n\n    override val componentContextFactory: ComponentContextFactory<AppComponentContext> =\n        ComponentContextFactory { lifecycle, stateKeeper, instanceKeeper, backHandler ->\n            val ctx = componentContext.componentContextFactory(lifecycle, stateKeeper, instanceKeeper, backHandler)\n            DefaultAppComponentContext(ctx, logger)\n        }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Stack Animations with Default API\nDESCRIPTION: Shows how to configure default stack animations using CompositionLocalProvider with the Default API. This example sets up a combined slide and scale animation as the default for all stack transitions in the app.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_21\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.CompositionLocalProvider\nimport com.arkivanov.decompose.extensions.compose.stack.animation.LocalStackAnimationProvider\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimationProvider\nimport com.arkivanov.decompose.extensions.compose.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.slide\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun App() {\n    CompositionLocalProvider(LocalStackAnimationProvider provides DefaultStackAnimationProvider) {\n        // The rest of the code\n    }\n}\n\nprivate object DefaultStackAnimationProvider : StackAnimationProvider {\n    override fun <C : Any, T : Any> provide(): StackAnimation<C, T> =\n        stackAnimation(slide() + scale())\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Stack Animations with Experimental API\nDESCRIPTION: Demonstrates setting up default stack animations using the Experimental API. This configures a combined slide and scale animation that will be used for all stack transitions throughout the app.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_22\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.CompositionLocalProvider\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.LocalStackAnimationProvider\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimation\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimationProvider\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.slide\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun App() {\n    CompositionLocalProvider(LocalStackAnimationProvider provides DefaultStackAnimationProvider) {\n        // The rest of the code\n    }\n}\n\nprivate object DefaultStackAnimationProvider : StackAnimationProvider {\n    override fun <C : Any, T : Any> provide(): StackAnimation<C, T> =\n        stackAnimation(slide() + scale())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChildPages Navigation with Compose (Before v3.2.0-alpha03)\nDESCRIPTION: Example showing how to implement Pages navigation in Compose UI using the Pages component from Decompose before version 3.2.0-alpha03. It demonstrates setting up the Pages component with animation and page selection handling.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.jetbrains.pages.Pages\nimport com.arkivanov.decompose.extensions.compose.jetbrains.pages.PagesScrollAnimation\n\n@Composable\nfun PagesContent(component: PagesComponent) {\n    Pages(\n        pages = component.pages,\n        onPageSelected = component::selectPage,\n        scrollAnimation = PagesScrollAnimation.Default,\n    ) { _, page ->\n        PageContent(page)\n    }\n}\n\n@Composable\nfun PageContent(component: PageComponent) {\n    // Omitted code\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting Previous Page in PagesNavigator\nDESCRIPTION: Shows how to use the selectPrev() function to navigate to the previous page. It demonstrates basic usage, non-circular navigation, and circular navigation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/pages/navigation.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\n1: navigation.selectPrev()\n2: navigation.selectPrev(circular = false)\n3: navigation.selectPrev(circular = true)\n```\n\n----------------------------------------\n\nTITLE: Using push Navigation Method in Decompose\nDESCRIPTION: Demonstration of the push method which adds a new configuration to the top of the stack. Note that Decompose throws an exception if the provided Configuration is already present in the stack.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/navigation.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.push(Configuration.C)\n```\n\n----------------------------------------\n\nTITLE: Implementing ViewModelStoreComponent for ViewModel Management in Decompose\nDESCRIPTION: This class implements ViewModelStoreOwner, SavedStateRegistryOwner, and HasDefaultViewModelProviderFactory interfaces. It manages argument passing and state saving for ViewModels in the Decompose framework.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/composable-viewmodel.md#2025-04-23_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\nclass ViewModelStoreComponent(\n    ctx: ComponentContext,\n    args: Bundle = Bundle(),\n) : ViewModelStoreOwner by ctx.viewModelStoreOwner(),\n    SavedStateRegistryOwner,\n    HasDefaultViewModelProviderFactory {\n\n    private val savedStateRegistryController = SavedStateRegistryController.create(this)\n    override val savedStateRegistry: SavedStateRegistry get() = savedStateRegistryController.savedStateRegistry\n    override val lifecycle: Lifecycle = LifecycleRegistry(provider = this)\n\n    override val defaultViewModelProviderFactory: ViewModelProvider.Factory =\n        SavedStateViewModelFactory(application = null, owner = this, defaultArgs = args)\n\n    init {\n        savedStateRegistryController.performRestore(ctx.stateKeeper.consume(KEY_SAVED_STATE, BundleSerializer))\n\n        ctx.stateKeeper.register(KEY_SAVED_STATE, BundleSerializer) {\n            Bundle().also(savedStateRegistryController::performSave)\n        }\n    }\n\n    private companion object {\n        private const val KEY_SAVED_STATE = \"saved_state\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Activating Main Panel Example\nDESCRIPTION: Example showing how to activate a new main panel configuration while preserving other states.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/navigation.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.activateMain(main = Main2)\n```\n\n----------------------------------------\n\nTITLE: Selecting First Page in PagesNavigator\nDESCRIPTION: Illustrates how to use the selectFirst() function to navigate to the first page in the navigation stack.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/pages/navigation.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.selectFirst()\n```\n\n----------------------------------------\n\nTITLE: Observing Navigation State Manually in Compose\nDESCRIPTION: Demonstrates how to manually observe the navigation state in a Compose function using subscribeAsState().\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport com.arkivanov.decompose.extensions.compose.jetbrains.subscribeAsState\n\n@Composable\nfun RootContent(component: RootComponent) {\n    val stack by component.childStack.subscribeAsState()\n    // Use the stack variable here\n}\n```\n\n----------------------------------------\n\nTITLE: Dismissing Extra Panel Example\nDESCRIPTION: Example showing how to dismiss the currently active extra panel.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/navigation.md#2025-04-23_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.dismissExtra()\n```\n\n----------------------------------------\n\nTITLE: Using pop Navigation Method in Decompose\nDESCRIPTION: The pop method removes the top configuration from the stack. There are two versions - a simple version with no callback, and one that provides feedback about the operation's success.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/navigation.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.pop()\n\n// Or\n\nnavigation.pop { isSuccess ->\n    // Called when the navigation is finished.\n    // isSuccess - `true` if the stack size was greater than 1 and a component was popped, `false` otherwise.\n}\n```\n\n----------------------------------------\n\nTITLE: Using popTo Navigation Method in Decompose\nDESCRIPTION: The popTo method pops configurations from the stack until the component at the specified index becomes the top of the stack, effectively navigating back to that index.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/navigation.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.popTo(index = 1)\n```\n\n----------------------------------------\n\nTITLE: Adding Compose Extensions for Decompose in Gradle (Kotlin)\nDESCRIPTION: This snippet shows how to add Compose extensions for Decompose as a dependency in a Gradle build file using Kotlin DSL. These extensions enable integration between Compose and Decompose components.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/installation.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nimplementation(\"com.arkivanov.decompose:extensions-compose:<version>\")\n```\n\n----------------------------------------\n\nTITLE: Setting Panel Mode Example\nDESCRIPTION: Example showing how to change the panel display mode.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/navigation.md#2025-04-23_snippet_10\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.setMode(ChildPanelsMode.DUAL)\n```\n\n----------------------------------------\n\nTITLE: Adding Android View Extensions in Gradle (Kotlin)\nDESCRIPTION: This snippet shows how to add Android view extensions for Decompose as a dependency in a Gradle build file using Kotlin DSL. These extensions enable integration between Android views and Decompose components.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/installation.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\nimplementation(\"com.arkivanov.decompose:extensions-android:<version>\")\n```\n\n----------------------------------------\n\nTITLE: Navigating with Extra Configuration Example\nDESCRIPTION: Example showing navigation state transition when updating only the extra panel configuration.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/navigation.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.navigate(extra = Extra2)\n```\n\n----------------------------------------\n\nTITLE: Creating a Reaktive DisposableScope Surviving Android Configuration Changes\nDESCRIPTION: This snippet shows how to create a Reaktive DisposableScope that survives Android configuration changes using InstanceKeeper in a Decompose component.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/scopes.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\nimport com.badoo.reaktive.completable.completableFromFunction\nimport com.badoo.reaktive.disposable.scope.DisposableScope\n\ninternal class SomeRetainedInstance : InstanceKeeper.Instance,\n    // The scope survives Android configuration changes\n    DisposableScope by DisposableScope() {\n\n    fun foo() {\n        completableFromFunction {\n            // Do the job\n        }.subscribeScoped()\n    }\n\n    override fun onDestroy() {\n        dispose() // Dispose the scope when the instance is destroyed\n    }\n}\n\nclass SomeComponent(\n    componentContext: ComponentContext,\n) : ComponentContext by componentContext {\n\n    private val someRetainedInstance = instanceKeeper.getOrCreate { SomeRetainedInstance() }\n}\n```\n\n----------------------------------------\n\nTITLE: Using popToFirst Navigation Method in Decompose\nDESCRIPTION: The popToFirst method pops all configurations except the first one, making the first configuration the new top of the stack. This is useful for returning to the root of the navigation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/navigation.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.popToFirst()\n```\n\n----------------------------------------\n\nTITLE: Creating a ViewModel-based Composable Details Screen in Kotlin\nDESCRIPTION: A Composable function for a Details screen that uses an AndroidX ViewModel. This represents a screen that might be difficult to migrate from the official navigation-compose library to Decompose.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/composable-viewmodel.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewmodel.compose.viewModel\n\n@Composable\nfun DetailsContent(viewModel: DetailsViewModel = viewModel()) {\n    // Omitted code\n}\n\nclass DetailsViewModel : ViewModel() { \n    // Omitted code\n}\n```\n\n----------------------------------------\n\nTITLE: Using PredictiveBackGestureOverlay in Compose for iOS\nDESCRIPTION: This code demonstrates how to implement the predictive back gesture overlay for iOS applications using Jetpack Compose. It creates a UIViewController that wraps a PredictiveBackGestureOverlay composable, which handles back gestures and displays a custom back icon that animates based on gesture progress.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_35\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.ArrowBack\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.window.ComposeUIViewController\nimport com.arkivanov.decompose.extensions.compose.PredictiveBackGestureIcon\nimport com.arkivanov.decompose.extensions.compose.PredictiveBackGestureOverlay\nimport com.arkivanov.essenty.backhandler.BackDispatcher\nimport platform.UIKit.UIViewController\n\nfun rootViewController(root: RootComponent, backDispatcher: BackDispatcher): UIViewController =\n    ComposeUIViewController {\n        PredictiveBackGestureOverlay(\n            backDispatcher = backDispatcher,\n            backIcon = { progress, _ ->\n                PredictiveBackGestureIcon(\n                    imageVector = Icons.Default.ArrowBack,\n                    progress = progress,\n                )\n            },\n            modifier = Modifier.fillMaxSize(),\n        ) {\n            RootContent(component = root, modifier = Modifier.fillMaxSize())\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Android-like Predictive Back Animation with Default API in Kotlin\nDESCRIPTION: This snippet shows how to set up Android-like Predictive Back Animation using the default API in a RootContent composable function. It uses the Children composable and configures the animation with androidPredictiveBackAnimatable.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_33\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.androidPredictiveBackAnimatable\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.predictiveBackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = predictiveBackAnimation(\n            backHandler = component.backHandler,\n            fallbackAnimation = stackAnimation(fade() + scale()),\n            selector = { backEvent, _, _ -> androidPredictiveBackAnimatable(backEvent) },\n            onBack = component::onBackClicked,\n        ),\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: iOS Back Animation Implementation\nDESCRIPTION: iOS-specific implementation featuring custom slide animations and modifiers to create native-like back gesture behavior.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_38\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.animation.core.FiniteAnimationSpec\nimport androidx.compose.animation.core.tween\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.drawWithContent\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.layout.layout\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimator\nimport com.arkivanov.decompose.extensions.compose.stack.animation.isFront\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.predictiveBackAnimatable\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.predictiveBackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimator\nimport com.arkivanov.essenty.backhandler.BackHandler\n\nactual fun <C : Any, T : Any> backAnimation(\n    backHandler: BackHandler,\n    onBack: () -> Unit,\n): StackAnimation<C, T> =\n    predictiveBackAnimation(\n        backHandler = backHandler,\n        fallbackAnimation = stackAnimation(iosLikeSlide()),\n        selector = { initialBackEvent, _, _ ->\n            predictiveBackAnimatable(\n                initialBackEvent = initialBackEvent,\n                exitModifier = { progress, _ -> Modifier.slideExitModifier(progress = progress) },\n                enterModifier = { progress, _ -> Modifier.slideEnterModifier(progress = progress) },\n            )\n        },\n        onBack = onBack,\n    )\n```\n\n----------------------------------------\n\nTITLE: Attaching ViewModelStore to InstanceKeeper in Decompose\nDESCRIPTION: Extension function to attach a ViewModelStore to a Decompose component's InstanceKeeper. This allows ViewModels to be scoped to specific components in the navigation hierarchy instead of the entire Activity/Fragment.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/composable-viewmodel.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.lifecycle.ViewModelStore\nimport androidx.lifecycle.ViewModelStoreOwner\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeperOwner\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\n\ninternal fun InstanceKeeperOwner.viewModelStoreOwner(): ViewModelStoreOwner =\n    instanceKeeper.getOrCreate(::ViewModelStoreOwnerInstance)\n\nprivate class ViewModelStoreOwnerInstance : ViewModelStoreOwner, InstanceKeeper.Instance {\n    override val viewModelStore: ViewModelStore = ViewModelStore()\n\n    override fun onDestroy() {\n        viewModelStore.clear()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting Next Page in PagesNavigator\nDESCRIPTION: Demonstrates how to use the selectNext() function to navigate to the next page. It shows three scenarios: basic usage, non-circular navigation, and circular navigation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/pages/navigation.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\n1: navigation.selectNext()\n2: navigation.selectNext(circular = false)\n3: navigation.selectNext(circular = true)\n```\n\n----------------------------------------\n\nTITLE: Using rememberViewModel in a Details Screen with Decompose in Kotlin\nDESCRIPTION: A refactored Details screen Composable function that uses the custom rememberViewModel function instead of the standard viewModel function to prevent memory leaks during navigation animations.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/composable-viewmodel.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.lifecycle.ViewModel\n\n@Composable\nfun DetailsContent(viewModel: DetailsViewModel = rememberViewModel()) {\n    // Omitted code\n}\n\nclass DetailsViewModel : ViewModel() { \n    // Omitted code\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Duplicate Configurations Mode in Decompose\nDESCRIPTION: Shows how to enable the experimental Duplicate Configurations mode which allows having duplicate configurations in all navigation models, useful for resolving the \"Configurations must be unique\" error.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/faq.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nDecomposeExperimentFlags.duplicateConfigurationsEnabled = true\n```\n\n----------------------------------------\n\nTITLE: Initializing Root Component for iOS without ApplicationLifecycle\nDESCRIPTION: This snippet demonstrates how to initialize a root component for iOS using SwiftUI and Decompose without the experimental ApplicationLifecycle. It creates a RootHolder class to manage the component's lifecycle.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nclass RootHolder : ObservableObject {\n    let lifecycle: LifecycleRegistry\n    let root: RootComponent\n\n    init() {\n        lifecycle = LifecycleRegistryKt.LifecycleRegistry()\n\n        root = DefaultRootComponent(\n            componentContext: DefaultComponentContext(lifecycle: lifecycle)\n        )\n\n        LifecycleRegistryExtKt.create(lifecycle)\n    }\n\n    deinit {\n        // Destroy the root component before it is deallocated\n        LifecycleRegistryExtKt.destroy(lifecycle)\n    }\n}\n\nclass AppDelegate: NSObject, UIApplicationDelegate {\n    let rootHolder: RootHolder = RootHolder()\n}\n\n@main\nstruct iOSApp: App {\n    @UIApplicationDelegateAdaptor(AppDelegate.self)\n    var appDelegate: AppDelegate\n\n    @Environment(\\.scenePhase)\n    var scenePhase: ScenePhase\n\n    var rootHolder: RootHolder { appDelegate.rootHolder }\n    \n    var body: some Scene {\n        WindowGroup {\n            RootView(rootHolder.root)\n                .onChange(of: scenePhase) { newPhase in\n                    switch newPhase {\n                    case .background: LifecycleRegistryExtKt.stop(rootHolder.lifecycle)\n                    case .inactive: LifecycleRegistryExtKt.pause(rootHolder.lifecycle)\n                    case .active: LifecycleRegistryExtKt.resume(rootHolder.lifecycle)\n                    @unknown default: break\n                    }\n                }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Web Navigation Component Interface with Child Panels in Kotlin\nDESCRIPTION: Defines a component interface that extends WebNavigationOwner and provides access to ChildPanels. This interface is responsible for exposing the panel state and handling web navigation integration.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/web-navigation.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.router.panels.ChildPanels\nimport com.arkivanov.decompose.router.webhistory.WebNavigationOwner\nimport com.arkivanov.decompose.value.Value\n\ninterface MyPanelsComponent : WebNavigationOwner {\n    val panels: Value<ChildPanels<...>>\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting Page by Index in PagesNavigator\nDESCRIPTION: Shows how to use the select(index) function to navigate to a specific page by its index in the navigation stack. It throws an IllegalArgumentException if the index is out of bounds.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/pages/navigation.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.select(2)\n```\n\n----------------------------------------\n\nTITLE: Integrating Decompose LifecycleRegistry with Web Document\nDESCRIPTION: This code demonstrates how to initialize and connect a Decompose LifecycleRegistry to the web document's visibility state. It shows the setup of a RootComponent with proper lifecycle management that responds to document visibility changes.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/quick-start.md#2025-04-23_snippet_13\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.DefaultComponentContext\nimport com.arkivanov.decompose.ExperimentalDecomposeApi\nimport com.arkivanov.decompose.router.stack.webhistory.DefaultWebHistoryController\nimport com.arkivanov.essenty.lifecycle.LifecycleRegistry\nimport com.arkivanov.essenty.lifecycle.resume\nimport com.arkivanov.essenty.lifecycle.stop\nimport kotlinx.browser.window\nimport react.create\nimport react.dom.client.createRoot\nimport web.dom.DocumentVisibilityState\nimport web.dom.document\nimport web.events.EventType\n\n@OptIn(ExperimentalDecomposeApi::class)\nfun main() {\n    val lifecycle = LifecycleRegistry()\n\n    val root =\n        DefaultRootComponent(\n            // Pass the LifecycleRegistry to the context\n            componentContext = DefaultComponentContext(lifecycle = lifecycle),\n            ... // Other dependencies here\n        )\n\n    // Attach the LifecycleRegistry to document\n    lifecycle.attachToDocument()\n\n    // Render the UI\n    createRoot(document.getElementById(\"app\")!!).render(\n        RootContent.create {\n            component = root\n        }\n    )\n}\n\n// Attaches the LifecycleRegistry to the document\nprivate fun LifecycleRegistry.attachToDocument() {\n    fun onVisibilityChanged() {\n        if (document.visibilityState == DocumentVisibilityState.visible) {\n            resume()\n        } else {\n            stop()\n        }\n    }\n\n    onVisibilityChanged()\n\n    document.addEventListener(type = EventType(\"visibilitychange\"), callback = { onVisibilityChanged() })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Pages Component Interface with Web Navigation\nDESCRIPTION: Kotlin interface definition for a pages-based component implementing WebNavigationOwner, establishing the contract for pages navigation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/web-navigation.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\ninterface MyPagesComponent : WebNavigationOwner {\n    val pages: Value<ChildPages<*, ...>>\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Experimental Duplicate Configurations Mode in Decompose\nDESCRIPTION: Shows how to enable the experimental duplicate configurations mode which allows having duplicate configurations in all navigation models.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nDecomposeExperimentFlags.duplicateConfigurationsEnabled = true\n```\n\n----------------------------------------\n\nTITLE: Defining Stack Component Interface with Web Navigation\nDESCRIPTION: Kotlin interface definition for a stack-based component that implements WebNavigationOwner, defining the basic structure for stack navigation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/web-navigation.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\ninterface MyStackComponent : WebNavigationOwner {\n    val stack: Value<ChildStack<*, Child>>\n\n    sealed class Child {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom StackAnimator with Experimental API\nDESCRIPTION: Demonstrates implementing a custom StackAnimator using the Experimental API. This focuses on animating and returning a Modifier for the given direction without handling animation completion.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_26\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimator\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.Direction\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(someAnimator()),\n    ) {\n        // Omitted code\n    }\n}\n\nfun someAnimator(): StackAnimator =\n    StackAnimator { direction: Direction ->\n        // Animate and return a Modifier for the given direction\n    }\n```\n\n----------------------------------------\n\nTITLE: Navigating with Main, Details and Extra Configurations Example\nDESCRIPTION: Example showing navigation state transition when updating all panel configurations.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/navigation.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.navigate(main = Main2, details = Details2, extra = Extra2)\n```\n\n----------------------------------------\n\nTITLE: Configuring Predictive Back Animation with Experimental API in Kotlin\nDESCRIPTION: This snippet shows how to set up Predictive Back Animation using the experimental API in a RootContent composable function. It uses the ChildStack composable and configures the animation with PredictiveBackParams.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_31\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.PredictiveBackParams\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(\n            animator = fade() + scale(),\n            predictiveBackParams = {\n                PredictiveBackParams(\n                    backHandler = component.backHandler,\n                    onBack = component::onBackClicked,\n                )\n            },\n        ),\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Including Experimental Compose Extensions in Gradle (Kotlin)\nDESCRIPTION: This snippet demonstrates adding experimental Compose extensions for Decompose as a dependency in a Gradle build file using Kotlin DSL. These extensions offer advanced features such as shared transitions.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/installation.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nimplementation(\"com.arkivanov.decompose:extensions-compose-experimental:<version>\")\n```\n\n----------------------------------------\n\nTITLE: Including Experimental Compose Extensions in Gradle (Groovy)\nDESCRIPTION: This code adds experimental Compose extensions for Decompose as a dependency in a Gradle build file using Groovy syntax. These extensions provide additional features like shared transitions.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/installation.md#2025-04-23_snippet_4\n\nLANGUAGE: groovy\nCODE:\n```\nimplementation \"com.arkivanov.decompose:extensions-compose-experimental:<version>\"\n```\n\n----------------------------------------\n\nTITLE: Adding Android View Extensions in Gradle (Groovy)\nDESCRIPTION: This code adds Android view extensions for Decompose as a dependency in a Gradle build file using Groovy syntax. These extensions allow connection of Android views to Decompose components.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/installation.md#2025-04-23_snippet_6\n\nLANGUAGE: groovy\nCODE:\n```\nimplementation \"com.arkivanov.decompose:extensions-android:<version>\"\n```\n\n----------------------------------------\n\nTITLE: Using bringToFront Navigation Method in Decompose\nDESCRIPTION: The bringToFront method removes all components with configurations of the same class as the provided configuration, then adds the provided configuration to the top of the stack. Useful for bottom navigation implementations.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/navigation.md#2025-04-23_snippet_10\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.bringToFront(Configuration.B)\n```\n\n----------------------------------------\n\nTITLE: Configuring Android-like Predictive Back Animation with Experimental API in Kotlin\nDESCRIPTION: This snippet demonstrates how to set up Android-like Predictive Back Animation using the experimental API in a RootContent composable function. It uses the ChildStack composable and configures the animation with androidPredictiveBackAnimatable.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_34\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.PredictiveBackParams\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.androidPredictiveBackAnimatable\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(\n            animator = fade() + scale(),\n            predictiveBackParams = {\n                PredictiveBackParams(\n                    backHandler = component.backHandler,\n                    onBack = component::onBackClicked,\n                    animatable = ::androidPredictiveBackAnimatable,\n                )\n            }\n        ),\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack Dev Server for History API Fallback in Kotlin/JS\nDESCRIPTION: JavaScript configuration for enabling historyApiFallback in webpack-dev-server to support SPA routing. This file should be placed in the webpack.config.d directory of the JS app module to properly handle all paths with the same HTML file.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/browser-history.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// <js app module>/webpack.config.d/devServerConfig.js\n\nconfig.devServer = {\n  ...config.devServer, // Merge with other devServer settings\n  \"historyApiFallback\": true\n};\n```\n\n----------------------------------------\n\nTITLE: Exporting Decompose to iOS Framework in Kotlin Multiplatform\nDESCRIPTION: This Kotlin code snippet demonstrates how to export Decompose and its dependencies to an iOS Framework in a Kotlin Multiplatform project. It includes necessary exports for the main library, lifecycle, state keeper, and Darwin runtime.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/installation.md#2025-04-23_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\nkotlin {\n    targets\n        .filterIsInstance<KotlinNativeTarget>()\n        .filter { it.konanTarget.family == Family.IOS }\n        .forEach {\n            it.binaries.framework {\n                export(\"com.arkivanov.decompose:decompose:<version>\")\n                export(\"com.arkivanov.essenty:lifecycle:<essenty_version>\")\n                export(\"com.arkivanov.essenty:state-keeper:<essenty_version>\")\n                export(\"com.arkivanov.parcelize.darwin:runtime:<parcelize_darwin_version>\")\n            }\n        }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Material MkDocs Docker Container for Local Documentation Preview\nDESCRIPTION: These commands demonstrate how to use Docker to run a local server for previewing documentation changes. It involves pulling the Material MkDocs Docker image and running it with the appropriate volume mapping.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/contributing.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# download the image\ndocker pull squidfunk/mkdocs-material\n\n# run the server locally \ndocker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material\n```\n\n----------------------------------------\n\nTITLE: Exporting Decompose to iOS Framework using CocoaPods in Kotlin Multiplatform\nDESCRIPTION: This Kotlin code snippet shows how to export Decompose and its dependencies to an iOS Framework using CocoaPods in a Kotlin Multiplatform project. It includes necessary exports for the main library, lifecycle, state keeper, and Darwin runtime.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/installation.md#2025-04-23_snippet_9\n\nLANGUAGE: kotlin\nCODE:\n```\nkotlin {\n    cocoapods {\n        framework {\n            export(\"com.arkivanov.decompose:decompose:<version>\")\n            export(\"com.arkivanov.essenty:lifecycle:<essenty_version>\")\n            export(\"com.arkivanov.essenty:state-keeper:<essenty_version>\")\n            export(\"com.arkivanov.parcelize.darwin:runtime:<parcelize_darwin_version>\")\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Common Back Animation Interface\nDESCRIPTION: Common source set implementation that defines the basic structure for back animation handling using either default or experimental Decompose API.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_36\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimation\nimport com.arkivanov.essenty.backhandler.BackHandler\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = backAnimation(\n            backHandler = component.backHandler,\n            onBack = component::onBackClicked,\n        ),\n    ) {\n        // Omitted code\n    }\n}\n\nexpect fun <C : Any, T : Any> backAnimation(\n    backHandler: BackHandler,\n    onBack: () -> Unit,\n): StackAnimation<C, T>\n```\n\n----------------------------------------\n\nTITLE: Android Back Animation Implementation\nDESCRIPTION: Android-specific implementation of the back animation using predictive back animation with fallback to fade animation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_37\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.predictiveBackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\nimport com.arkivanov.essenty.backhandler.BackHandler\n\nactual fun <C : Any, T : Any> backAnimation(\n    backHandler: BackHandler,\n    onBack: () -> Unit,\n): StackAnimation<C, T> =\n    predictiveBackAnimation(\n        backHandler = backHandler,\n        fallbackAnimation = stackAnimation(fade()),\n        onBack = onBack,\n    )\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack Dev Server for History API Fallback\nDESCRIPTION: JavaScript configuration for webpack-dev-server to enable catch-all strategy for single page applications using historyApiFallback.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/web-navigation.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconfig.devServer = {\n  ...config.devServer, // Merge with other devServer settings\n  \"historyApiFallback\": true\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing ViewModel with SavedStateHandle in Decompose\nDESCRIPTION: This snippet shows how to create a ViewModel that uses SavedStateHandle to retrieve passed arguments. It demonstrates accessing the 'text' argument passed from the navigation.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/composable-viewmodel.md#2025-04-23_snippet_10\n\nLANGUAGE: kotlin\nCODE:\n```\nclass ItemDetailsViewModel(savedStateHandle: SavedStateHandle) : ViewModel() {\n    val text: String = checkNotNull(savedStateHandle[\"text\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BundleSerializer for Android Bundle Serialization in Kotlin\nDESCRIPTION: This snippet defines a BundleSerializer object that implements KSerializer<Bundle> to serialize and deserialize Android Bundle objects. It uses Parcel for marshalling and unmarshalling Bundle data.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/composable-viewmodel.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\ninternal object BundleSerializer : KSerializer<Bundle> {\n    private val byteArraySerializer = ByteArraySerializer()\n    override val descriptor: SerialDescriptor = byteArraySerializer.descriptor\n\n    override fun serialize(encoder: Encoder, value: Bundle) {\n        encoder.encodeSerializableValue(byteArraySerializer, value.toByteArray())\n    }\n\n    private fun Bundle.toByteArray(): ByteArray {\n        val parcel = Parcel.obtain()\n        try {\n            parcel.writeBundle(this)\n            return parcel.marshall()\n        } finally {\n            parcel.recycle()\n        }\n    }\n\n    override fun deserialize(decoder: Decoder): Bundle =\n        decoder.decodeSerializableValue(byteArraySerializer).toBundle()\n\n    private fun ByteArray.toBundle(): Bundle {\n        val parcel = Parcel.obtain()\n        try {\n            parcel.unmarshall(this, 0, size)\n            parcel.setDataPosition(0)\n            return requireNotNull(parcel.readBundle())\n        } finally {\n            parcel.recycle()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Animations with Default API in Decompose\nDESCRIPTION: Shows how to combine multiple animators using the plus operator with the default API. This example combines fade and scale animations for a more complex transition effect.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_16\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation(fade() + scale())\n    ) {\n        // Omitted code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Activating Extra Panel Example\nDESCRIPTION: Example showing how to activate a new extra panel configuration.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/navigation.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.activateExtra(extra = Extra1)\n```\n\n----------------------------------------\n\nTITLE: Animated ChildPanels Navigation with Predictive Back Support\nDESCRIPTION: Advanced example of ChildPanels navigation with custom animations and predictive back gesture support. Demonstrates combining fade and scale animations, and configuring predictive back handling.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_10\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.panels.ChildPanels\nimport com.arkivanov.decompose.extensions.compose.experimental.panels.ChildPanelsAnimators\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.PredictiveBackParams\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.materialPredictiveBackAnimatable\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode\n\n@Composable\nfun PanelsContent(component: PanelsComponent) {\n    ChildPanelsModeChangedEffect(component::setMode)\n\n    ChildPanels(\n        panels = component.panels,\n        mainChild = { MainContent(it.instance) },\n        detailsChild = { DetailsContent(it.instance) },\n        animators = ChildPanelsAnimators(single = fade() + scale(), dual = fade() to fade()),\n        predictiveBackParams = { // See the docs below\n            PredictiveBackParams(\n                backHandler = component.backHandler,\n                onBack = component::onBackClicked,\n                animatable = ::materialPredictiveBackAnimatable,\n            )\n        },\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified State Preservation of Retained Instance Using Combined Delegates\nDESCRIPTION: Shows how to use the experimental 'retainedInstance' API combined with 'saveable' to preserve state of a retained instance with minimal boilerplate. This approach simplifies the pattern of maintaining instance state across configuration changes while preserving data in case of process death.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/state-preservation.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.retainedInstance\nimport com.arkivanov.essenty.statekeeper.saveable\nimport com.arkivanov.sample.shared.SomeStatefulEntity.State\nimport kotlinx.serialization.Serializable\n\nclass SomeComponent(componentContext: ComponentContext) : ComponentContext by componentContext {\n    private val statefulEntity by saveable(serializer = State.serializer(), state = { it.state }) { savedState ->\n        retainedInstance {\n            SomeStatefulEntity(savedState = savedState)\n        }\n    }\n}\n\nclass SomeStatefulEntity(savedState: State?) : InstanceKeeper.Instance {\n    var state: State = savedState ?: State()\n        private set\n\n    @Serializable\n    data class State(val someValue: Int = 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Duplicate Configurations for Child Pages in Kotlin\nDESCRIPTION: Shows how to enable the experimental Duplicate Configurations mode in Decompose, which allows having duplicate configurations in all navigation models.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/pages/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nDecomposeExperimentFlags.duplicateConfigurationsEnabled = true\n```\n\n----------------------------------------\n\nTITLE: Implementing Component with BackHandlerOwner Support\nDESCRIPTION: Example showing how to implement a component that provides back handler support by delegating to ComponentContext.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/back-button.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nclass DefaultSomeComponent(\n    componentContext: ComponentContext,\n) : ComponentContext by componentContext {\n    // No need to implement BackHandlerOwner interface, already implemented by ComponentContext\n}\n```\n\n----------------------------------------\n\nTITLE: Activating Component using SlotNavigator in Kotlin\nDESCRIPTION: Shows how to activate a component with a specific DialogConfig configuration using the activate extension function.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/slot/navigation.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.activate(DialogConfig(title = \"Some title\"))\n```\n\n----------------------------------------\n\nTITLE: Dismissing Active Component using SlotNavigator in Kotlin\nDESCRIPTION: Demonstrates how to dismiss the currently active component using the dismiss extension function of SlotNavigator.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/slot/navigation.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.dismiss()\n```\n\n----------------------------------------\n\nTITLE: Activating Details Panel Example\nDESCRIPTION: Example showing how to activate a new details panel configuration.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/navigation.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.activateDetails(details = Details1)\n```\n\n----------------------------------------\n\nTITLE: Pop Navigation Example\nDESCRIPTION: Example showing how to dismiss either Extra or Details panel based on current state.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/panels/navigation.md#2025-04-23_snippet_9\n\nLANGUAGE: kotlin\nCODE:\n```\nnavigation.pop()\n```\n\n----------------------------------------\n\nTITLE: Controlling Lifecycle on Desktop with JetBrains Compose\nDESCRIPTION: Shows how to use LifecycleController to manage lifecycle events in a desktop application using JetBrains Compose.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\nimport androidx.compose.ui.window.rememberWindowState\nimport com.arkivanov.decompose.DefaultComponentContext\nimport com.arkivanov.decompose.extensions.compose.jetbrains.lifecycle.LifecycleController\nimport com.arkivanov.essenty.lifecycle.LifecycleRegistry\n\nfun main() {\n    val lifecycle = LifecycleRegistry()\n\n    val root =\n        runOnUiThread {\n            DefaultRootComponent(DefaultComponentContext(lifecycle))\n        }\n\n    application {\n        val windowState = rememberWindowState()\n        LifecycleController(lifecycle, windowState)\n\n        Window(onCloseRequest = ::exitApplication, state = windowState) {\n            RootContent(root)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Root Component in JVM/Desktop with Compose\nDESCRIPTION: This example shows how to create a root component on the UI thread before starting Compose in a JVM/Desktop application. It uses a custom runOnUiThread function to ensure UI thread execution.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/overview.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.ui.window.application\nimport com.arkivanov.decompose.DefaultComponentContext\n\nfun main() {\n    // Create the root component on the UI thread before starting Compose\n    val root = runOnUiThread { DefaultRootComponent(componentContext = DefaultComponentContext(...)) }\n\n    // Start Compose\n    application {\n        // The rest of the code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Root Composable with ViewModelStoreOwner Provider in Decompose\nDESCRIPTION: A Composable function that renders the root component's children and provides the ViewModelStoreOwner to the Details screen through CompositionLocalProvider. This ensures the Details screen has its own ViewModelStore scope.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/composable-viewmodel.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.CompositionLocalProvider\nimport androidx.lifecycle.viewmodel.compose.LocalViewModelStoreOwner\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.sample.app.RootComponent.Child.MainChild\nimport com.arkivanov.sample.app.RootComponent.Child.ListChild\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(stack = component.childStack) { (_, child) ->\n        when (child) {\n            is ListChild -> MainContent(child.component)\n\n            is MainChild ->\n                CompositionLocalProvider(LocalViewModelStoreOwner provides child.component) {\n                    DetailsContent() // The Details screen now has its own ViewModelStore\n                }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ViewModelStoreComponent in Root Component for Decompose Navigation\nDESCRIPTION: This snippet demonstrates how to use ViewModelStoreComponent in a Root component for navigation in Decompose. It shows how to pass arguments to ViewModels and handle different configurations.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/tips-tricks/composable-viewmodel.md#2025-04-23_snippet_9\n\nLANGUAGE: kotlin\nCODE:\n```\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\n    private val nav = StackNavigation<Config>()\n\n    override val childStack: Value<ChildStack<*, Child>> =\n        childStack(\n            source = nav,\n            serializer = Config.serializer(),\n            initialConfiguration = Config.Main,\n        ) { config, ctx ->\n            when (config) {\n                is Config.Main ->\n                    ListChild(\n                        component = DefaultMainComponent(\n                            componentContext = ctx,\n                            onShowDetails = { text ->\n                                nav.pushNew(Config.Details(text = text)) // Pass text to the Details screen\n                            },\n                        ),\n                    )\n\n                is Config.Details ->\n                    MainChild(\n                        component = ViewModelStoreComponent( // Pass ViewModelStoreComponent as ViewModelStoreOwner\n                            ctx = ctx,\n                            args = bundleOf(\n                                \"text\" to config.text, // Pass arguments to DetailsViewModel\n                            )\n                        ),\n                    )\n            }\n        }\n\n    @Serializable\n    private sealed interface Config {\n        @Serializable\n        data object Main : Config\n\n        @Serializable\n        data class Details(val text: String) : Config\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Deep Link Handling with onNewIntent in Android (Kotlin)\nDESCRIPTION: An alternative approach for handling deep links in Android by manually managing the deep link in onNewIntent instead of restarting the Activity, useful when not using the standard launchMode.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/navigation/stack/deeplinking.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport android.content.Intent\nimport android.net.Uri\nimport android.os.Bundle\nimport androidx.activity.compose.setContent\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.defaultComponentContext\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var root: RootComponent\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val initialItemId = intent.data?.extractInitialItemId()\n\n        root =\n            DefaultRootComponent(\n                componentContext = defaultComponentContext(),\n                initialItemId = initialItemId,\n            )\n\n        setContent {\n            // Omitted code\n        }\n    }\n\n    override fun onNewIntent(intent: Intent) {\n        super.onNewIntent(intent)\n\n        val initialItemId = intent.data?.extractInitialItemId() ?: return\n        root.onDeepLink(initialItemId)\n    }\n\n    private fun Uri.extractInitialItemId(): Long? =\n        TODO(\"Extract the initial item id from the deep link\")\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n    initialItemId: Long? = null,\n) : RootComponent, ComponentContext by componentContext {\n\n    // Omitted code\n\n    fun onDeepLink(initialItemId: Long) {\n        navigation.replaceAll(Config.List, Config.Details(itemId = initialItemId))\n    }\n\n    // Omitted code\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Child Component Without Lifecycle Control in Kotlin\nDESCRIPTION: Example showing how to create a permanent child component without custom lifecycle control. The child component is created with its own ComponentContext derived from the parent using the childContext function.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/child-components.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.childContext\n\nclass SomeParent(componentContext: ComponentContext) : ComponentContext by componentContext {\n\n    val counter: Counter = Counter(childContext(key = \"Counter\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Compose Extensions for Decompose in Gradle (Groovy)\nDESCRIPTION: This code adds the Compose extensions for Decompose as a dependency in a Gradle build file using Groovy syntax. These extensions connect Compose with Decompose components.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/getting-started/installation.md#2025-04-23_snippet_2\n\nLANGUAGE: groovy\nCODE:\n```\nimplementation \"com.arkivanov.decompose:extensions-compose:<version>\"\n```\n\n----------------------------------------\n\nTITLE: Adding Decompose Android Extensions Dependency\nDESCRIPTION: Code snippets showing how to add the Decompose Android extensions dependency to a project using both Groovy and Kotlin build script syntax.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/android.md#2025-04-23_snippet_0\n\nLANGUAGE: groovy\nCODE:\n```\nimplementation \"com.arkivanov.decompose:extensions-android:<version>\"\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nimplementation(\"com.arkivanov.decompose:extensions-android:<version>\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Root Component in Android Activity\nDESCRIPTION: Example code for initializing the root component in an Android Activity. It sets up the DefaultViewContext and connects it to the application's component hierarchy.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/android.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.defaultComponentContext\nimport com.arkivanov.decompose.extensions.android.DefaultViewContext\nimport com.arkivanov.essenty.lifecycle.essentyLifecycle\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContentView(R.layout.main_activity)\n\n        val root = DefaultCounterComponent(defaultComponentContext())\n\n        val viewContext =\n            DefaultViewContext(\n                parent = findViewById(R.id.content),\n                lifecycle = essentyLifecycle()\n            )\n\n        viewContext.apply {\n            parent.addView(CounterView(root))\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Essenty Lifecycle Coroutines Dependency in Gradle\nDESCRIPTION: This snippet shows how to add the Essenty lifecycle-coroutines dependency to a Gradle build file. It's required for using CoroutineScope extensions in components.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/scopes.md#2025-04-23_snippet_0\n\nLANGUAGE: groovy\nCODE:\n```\nimplementation \"com.arkivanov.essenty:lifecycle-coroutines:<version>\"\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nimplementation(\"com.arkivanov.essenty:lifecycle-coroutines:<version>\")\n```\n\n----------------------------------------\n\nTITLE: Adding Essenty Lifecycle Reaktive Dependency in Gradle\nDESCRIPTION: This snippet shows how to add the Essenty lifecycle-reaktive dependency to a Gradle build file. It's required for using DisposableScope extensions in components.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/component/scopes.md#2025-04-23_snippet_3\n\nLANGUAGE: groovy\nCODE:\n```\nimplementation \"com.arkivanov.essenty:lifecycle-reaktive:<version>\"\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nimplementation(\"com.arkivanov.essenty:lifecycle-reaktive:<version>\")\n```\n\n----------------------------------------\n\nTITLE: Listing Decompose Extension Modules in Markdown\nDESCRIPTION: This snippet lists the available extension modules for Decompose, including links to their respective documentation pages.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# Extensions Overview\n\nDecompose provides extension modules for various popular libraries and frameworks:\n\n- [Extensions for Jetpack/JetBrains Compose](compose.md)\n- [Extensions for Android views](android.md)\n```\n\n----------------------------------------\n\nTITLE: Configuring ProGuard Rules for Compose Desktop\nDESCRIPTION: ProGuard rule to keep the SwingMainThreadChecker class for Compose Desktop applications in release mode.\nSOURCE: https://github.com/arkivanov/decompose/blob/master/docs/extensions/compose.md#2025-04-23_snippet_0\n\nLANGUAGE: proguard\nCODE:\n```\n-keep class com.arkivanov.decompose.extensions.compose.jetbrains.mainthread.SwingMainThreadChecker\n```"
  }
]